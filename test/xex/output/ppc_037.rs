pub fn sub_823F14C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F14C8 size=556
    let mut pc: u32 = 0x823F14C8;
    'dispatch: loop {
        match pc {
            0x823F14C8 => {
    //   block [0x823F14C8..0x823F14F4)
	// 823F14C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F14CC: 48143BE5  bl 0x825350b0
	ctx.lr = 0x823F14D0;
	sub_82535080(ctx, base);
	// 823F14D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F14D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823F14D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F14DC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F14E0: 419A0024  beq cr6, 0x823f1504
	if ctx.cr[6].eq {
	pc = 0x823F1504; continue 'dispatch;
	}
	// 823F14E4: 895B0000  lbz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F14E8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F14EC: 41820018  beq 0x823f1504
	if ctx.cr[0].eq {
	pc = 0x823F1504; continue 'dispatch;
	}
	// 823F14F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823F14F4; continue 'dispatch;
            }
            0x823F14F4 => {
    //   block [0x823F14F4..0x823F1504)
	// 823F14F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F14F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F14FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F1500: 4198FFF4  blt cr6, 0x823f14f4
	if ctx.cr[6].lt {
	pc = 0x823F14F4; continue 'dispatch;
	}
	pc = 0x823F1504; continue 'dispatch;
            }
            0x823F1504 => {
    //   block [0x823F1504..0x823F1520)
	// 823F1504: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F1508: 3B8BD13C  addi r28, r11, -0x2ec4
	ctx.r[28].s64 = ctx.r[11].s64 + -11972;
	// 823F150C: 889C0000  lbz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1510: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1514: 4182007C  beq 0x823f1590
	if ctx.cr[0].eq {
	pc = 0x823F1590; continue 'dispatch;
	}
	// 823F1518: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F151C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x823F1520; continue 'dispatch;
            }
            0x823F1520 => {
    //   block [0x823F1520..0x823F1548)
	// 823F1520: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F1524: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F1528: 419A004C  beq cr6, 0x823f1574
	if ctx.cr[6].eq {
	pc = 0x823F1574; continue 'dispatch;
	}
	// 823F152C: 88FB0000  lbz r7, 0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1530: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1534: 41820040  beq 0x823f1574
	if ctx.cr[0].eq {
	pc = 0x823F1574; continue 'dispatch;
	}
	// 823F1538: 1D28000C  mulli r9, r8, 0xc
	ctx.r[9].s32 = ((ctx.r[8].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823F153C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1540: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F1544: 7D2928AE  lbzx r9, r9, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	pc = 0x823F1548; continue 'dispatch;
            }
            0x823F1548 => {
    //   block [0x823F1548..0x823F155C)
	// 823F1548: 1C6B000C  mulli r3, r11, 0xc
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 823F154C: 7C6350AE  lbzx r3, r3, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F1550: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F1554: 409A0008  bne cr6, 0x823f155c
	if !ctx.cr[6].eq {
	pc = 0x823F155C; continue 'dispatch;
	}
	// 823F1558: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x823F155C; continue 'dispatch;
            }
            0x823F155C => {
    //   block [0x823F155C..0x823F1574)
	// 823F155C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F1560: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F1564: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823F1568: 4198FFE0  blt cr6, 0x823f1548
	if ctx.cr[6].lt {
	pc = 0x823F1548; continue 'dispatch;
	}
	// 823F156C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823F1570: 409A0010  bne cr6, 0x823f1580
	if !ctx.cr[6].eq {
	pc = 0x823F1580; continue 'dispatch;
	}
	pc = 0x823F1574; continue 'dispatch;
            }
            0x823F1574 => {
    //   block [0x823F1574..0x823F1580)
	// 823F1574: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 823F1578: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F157C: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x823F1580; continue 'dispatch;
            }
            0x823F1580 => {
    //   block [0x823F1580..0x823F1590)
	// 823F1580: 39680001  addi r11, r8, 1
	ctx.r[11].s64 = ctx.r[8].s64 + 1;
	// 823F1584: 5568063E  clrlwi r8, r11, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F1588: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823F158C: 4198FF94  blt cr6, 0x823f1520
	if ctx.cr[6].lt {
	pc = 0x823F1520; continue 'dispatch;
	}
	pc = 0x823F1590; continue 'dispatch;
            }
            0x823F1590 => {
    //   block [0x823F1590..0x823F15BC)
	// 823F1590: 3D60608A  lis r11, 0x608a
	ctx.r[11].s64 = 1619656704;
	// 823F1594: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 823F1598: 617F2002  ori r31, r11, 0x2002
	ctx.r[31].u64 = ctx.r[11].u64 | 8194;
	// 823F159C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F15A0: 4BFD8C21  bl 0x823ca1c0
	ctx.lr = 0x823F15A4;
	sub_823CA1C0(ctx, base);
	// 823F15A4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F15A8: 41820140  beq 0x823f16e8
	if ctx.cr[0].eq {
	pc = 0x823F16E8; continue 'dispatch;
	}
	// 823F15AC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F15B0: 419A000C  beq cr6, 0x823f15bc
	if ctx.cr[6].eq {
	pc = 0x823F15BC; continue 'dispatch;
	}
	// 823F15B4: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F15B8: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x823F15BC; continue 'dispatch;
            }
            0x823F15BC => {
    //   block [0x823F15BC..0x823F1618)
	// 823F15BC: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F15C0: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 823F15C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F15C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F15CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F15D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823F15D4: 1C6A000C  mulli r3, r10, 0xc
	ctx.r[3].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 823F15D8: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 823F15DC: 4BFD8BE5  bl 0x823ca1c0
	ctx.lr = 0x823F15E0;
	sub_823CA1C0(ctx, base);
	// 823F15E0: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823F15E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F15E8: 418200D4  beq 0x823f16bc
	if ctx.cr[0].eq {
	pc = 0x823F16BC; continue 'dispatch;
	}
	// 823F15EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823F15F0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F15F4: 419A0024  beq cr6, 0x823f1618
	if ctx.cr[6].eq {
	pc = 0x823F1618; continue 'dispatch;
	}
	// 823F15F8: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F15FC: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1600: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 823F1604: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1608: 41820010  beq 0x823f1618
	if ctx.cr[0].eq {
	pc = 0x823F1618; continue 'dispatch;
	}
	// 823F160C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F1610: 1CAB000C  mulli r5, r11, 0xc
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 823F1614: 4814353D  bl 0x82534b50
	ctx.lr = 0x823F1618;
	sub_82534B50(ctx, base);
	pc = 0x823F1618; continue 'dispatch;
            }
            0x823F1618 => {
    //   block [0x823F1618..0x823F162C)
	// 823F1618: 8B5C0000  lbz r26, 0(r28)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F161C: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1620: 418200C8  beq 0x823f16e8
	if ctx.cr[0].eq {
	pc = 0x823F16E8; continue 'dispatch;
	}
	// 823F1624: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1628: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x823F162C; continue 'dispatch;
            }
            0x823F162C => {
    //   block [0x823F162C..0x823F1654)
	// 823F162C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F1630: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F1634: 419A004C  beq cr6, 0x823f1680
	if ctx.cr[6].eq {
	pc = 0x823F1680; continue 'dispatch;
	}
	// 823F1638: 891B0000  lbz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F163C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1640: 41820040  beq 0x823f1680
	if ctx.cr[0].eq {
	pc = 0x823F1680; continue 'dispatch;
	}
	// 823F1644: 1D3E000C  mulli r9, r30, 0xc
	ctx.r[9].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823F1648: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F164C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F1650: 7D29E0AE  lbzx r9, r9, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	pc = 0x823F1654; continue 'dispatch;
            }
            0x823F1654 => {
    //   block [0x823F1654..0x823F1668)
	// 823F1654: 1CCB000C  mulli r6, r11, 0xc
	ctx.r[6].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 823F1658: 7CC650AE  lbzx r6, r6, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F165C: 7F064840  cmplw cr6, r6, r9
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F1660: 409A0008  bne cr6, 0x823f1668
	if !ctx.cr[6].eq {
	pc = 0x823F1668; continue 'dispatch;
	}
	// 823F1664: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x823F1668; continue 'dispatch;
            }
            0x823F1668 => {
    //   block [0x823F1668..0x823F1680)
	// 823F1668: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F166C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F1670: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F1674: 4198FFE0  blt cr6, 0x823f1654
	if ctx.cr[6].lt {
	pc = 0x823F1654; continue 'dispatch;
	}
	// 823F1678: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823F167C: 409A002C  bne cr6, 0x823f16a8
	if !ctx.cr[6].eq {
	pc = 0x823F16A8; continue 'dispatch;
	}
	pc = 0x823F1680; continue 'dispatch;
            }
            0x823F1680 => {
    //   block [0x823F1680..0x823F16A8)
	// 823F1680: 1D7E000C  mulli r11, r30, 0xc
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F1684: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1688: 57FF063E  clrlwi r31, r31, 0x18
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 823F168C: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823F1690: 1D7F000C  mulli r11, r31, 0xc
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F1694: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823F1698: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F169C: 481434B5  bl 0x82534b50
	ctx.lr = 0x823F16A0;
	sub_82534B50(ctx, base);
	// 823F16A0: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 823F16A4: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x823F16A8; continue 'dispatch;
            }
            0x823F16A8 => {
    //   block [0x823F16A8..0x823F16BC)
	// 823F16A8: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 823F16AC: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F16B0: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 823F16B4: 4198FF78  blt cr6, 0x823f162c
	if ctx.cr[6].lt {
	pc = 0x823F162C; continue 'dispatch;
	}
	// 823F16B8: 48000030  b 0x823f16e8
	pc = 0x823F16E8; continue 'dispatch;
            }
            0x823F16BC => {
    //   block [0x823F16BC..0x823F16D8)
	// 823F16BC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F16C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F16C4: 41820014  beq 0x823f16d8
	if ctx.cr[0].eq {
	pc = 0x823F16D8; continue 'dispatch;
	}
	// 823F16C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F16CC: 4BFD8B8D  bl 0x823ca258
	ctx.lr = 0x823F16D0;
	sub_823CA258(ctx, base);
	// 823F16D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F16D4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823F16D8; continue 'dispatch;
            }
            0x823F16D8 => {
    //   block [0x823F16D8..0x823F16E8)
	// 823F16D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F16DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F16E0: 4BFD8B79  bl 0x823ca258
	ctx.lr = 0x823F16E4;
	sub_823CA258(ctx, base);
	// 823F16E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x823F16E8; continue 'dispatch;
            }
            0x823F16E8 => {
    //   block [0x823F16E8..0x823F16F4)
	// 823F16E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F16EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F16F0: 48143A10  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F16F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F16F8 size=264
    let mut pc: u32 = 0x823F16F8;
    'dispatch: loop {
        match pc {
            0x823F16F8 => {
    //   block [0x823F16F8..0x823F1748)
	// 823F16F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F16FC: 481439C1  bl 0x825350bc
	ctx.lr = 0x823F1700;
	sub_82535080(ctx, base);
	// 823F1700: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1704: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1708: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F170C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1710: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823F1714: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823F1718: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823F171C: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823F1724: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1728: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 823F172C: 4BFFFD9D  bl 0x823f14c8
	ctx.lr = 0x823F1730;
	sub_823F14C8(ctx, base);
	// 823F1730: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 823F1734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1738: 40820010  bne 0x823f1748
	if !ctx.cr[0].eq {
	pc = 0x823F1748; continue 'dispatch;
	}
	// 823F173C: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 823F1740: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 823F1744: 480000B0  b 0x823f17f4
	pc = 0x823F17F4; continue 'dispatch;
            }
            0x823F1748 => {
    //   block [0x823F1748..0x823F175C)
	// 823F1748: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F174C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823F1750: 4098000C  bge cr6, 0x823f175c
	if !ctx.cr[6].lt {
	pc = 0x823F175C; continue 'dispatch;
	}
	// 823F1754: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F1758: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	pc = 0x823F175C; continue 'dispatch;
            }
            0x823F175C => {
    //   block [0x823F175C..0x823F1770)
	// 823F175C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 823F1760: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823F1764: 4098000C  bge cr6, 0x823f1770
	if !ctx.cr[6].lt {
	pc = 0x823F1770; continue 'dispatch;
	}
	// 823F1768: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F176C: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	pc = 0x823F1770; continue 'dispatch;
            }
            0x823F1770 => {
    //   block [0x823F1770..0x823F1778)
	// 823F1770: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 823F1774: 48000014  b 0x823f1788
	pc = 0x823F1788; continue 'dispatch;
            }
            0x823F1778 => {
    //   block [0x823F1778..0x823F1788)
	// 823F1778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F177C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F1780: 409A0010  bne cr6, 0x823f1790
	if !ctx.cr[6].eq {
	pc = 0x823F1790; continue 'dispatch;
	}
	// 823F1784: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	pc = 0x823F1788; continue 'dispatch;
            }
            0x823F1788 => {
    //   block [0x823F1788..0x823F1790)
	// 823F1788: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 823F178C: 4198FFEC  blt cr6, 0x823f1778
	if ctx.cr[6].lt {
	pc = 0x823F1778; continue 'dispatch;
	}
	pc = 0x823F1790; continue 'dispatch;
            }
            0x823F1790 => {
    //   block [0x823F1790..0x823F17E8)
	// 823F1790: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1794: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823F1798: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F179C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F17A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F17A4: 4E800421  bctrl
	ctx.lr = 0x823F17A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F17A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F17AC: 40800048  bge 0x823f17f4
	if !ctx.cr[0].lt {
	pc = 0x823F17F4; continue 'dispatch;
	}
	// 823F17B0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823F17B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823F17B8: 419A003C  beq cr6, 0x823f17f4
	if ctx.cr[6].eq {
	pc = 0x823F17F4; continue 'dispatch;
	}
	// 823F17BC: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 823F17C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F17C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F17C8: 41820020  beq 0x823f17e8
	if ctx.cr[0].eq {
	pc = 0x823F17E8; continue 'dispatch;
	}
	// 823F17CC: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823F17D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823F17D4: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823F17D8: 4BFD8A81  bl 0x823ca258
	ctx.lr = 0x823F17DC;
	sub_823CA258(ctx, base);
	// 823F17DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F17E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F17E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
            }
            0x823F17E8 => {
    //   block [0x823F17E8..0x823F17F4)
	// 823F17E8: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823F17EC: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823F17F0: 4BFD8A69  bl 0x823ca258
	ctx.lr = 0x823F17F4;
	sub_823CA258(ctx, base);
	pc = 0x823F17F4; continue 'dispatch;
            }
            0x823F17F4 => {
    //   block [0x823F17F4..0x823F1800)
	// 823F17F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F17F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F17FC: 48143910  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1800 size=124
    let mut pc: u32 = 0x823F1800;
    'dispatch: loop {
        match pc {
            0x823F1800 => {
    //   block [0x823F1800..0x823F1870)
	// 823F1800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1804: 481438B5  bl 0x825350b8
	ctx.lr = 0x823F1808;
	sub_82535080(ctx, base);
	// 823F1808: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F180C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F1810: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823F1814: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823F1818: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823F181C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F1820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F1824: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823F1828: 4BFCFD39  bl 0x823c1560
	ctx.lr = 0x823F182C;
	sub_823C1560(ctx, base);
	// 823F182C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F1830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F1834: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 823F1838: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 823F183C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 823F1840: 48002BB9  bl 0x823f43f8
	ctx.lr = 0x823F1844;
	sub_823F43F8(ctx, base);
	// 823F1844: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F1848: 40800028  bge 0x823f1870
	if !ctx.cr[0].lt {
	pc = 0x823F1870; continue 'dispatch;
	}
	// 823F184C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1850: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1854: 4182001C  beq 0x823f1870
	if ctx.cr[0].eq {
	pc = 0x823F1870; continue 'dispatch;
	}
	// 823F1858: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F185C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F1864: 4E800421  bctrl
	ctx.lr = 0x823F1868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F1868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F186C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x823F1870 => {
    //   block [0x823F1870..0x823F187C)
	// 823F1870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F1874: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F1878: 48143890  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1880 size=12
    let mut pc: u32 = 0x823F1880;
    'dispatch: loop {
        match pc {
            0x823F1880 => {
    //   block [0x823F1880..0x823F188C)
	// 823F1880: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 823F1884: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F1888: 4BFFFF78  b 0x823f1800
	sub_823F1800(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1890 size=108
    let mut pc: u32 = 0x823F1890;
    'dispatch: loop {
        match pc {
            0x823F1890 => {
    //   block [0x823F1890..0x823F18E4)
	// 823F1890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F1898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F189C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F18A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F18A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823F18A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F18AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F18B0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F18B4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F18B8: 4BFCFCA9  bl 0x823c1560
	ctx.lr = 0x823F18BC;
	sub_823C1560(ctx, base);
	// 823F18BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823F18C0: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F18C4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F18C8: 48002E11  bl 0x823f46d8
	ctx.lr = 0x823F18CC;
	sub_823F46D8(ctx, base);
	// 823F18CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F18D0: 40800014  bge 0x823f18e4
	if !ctx.cr[0].lt {
	pc = 0x823F18E4; continue 'dispatch;
	}
	// 823F18D4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F18D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F18DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F18E0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823F18E4; continue 'dispatch;
            }
            0x823F18E4 => {
    //   block [0x823F18E4..0x823F18FC)
	// 823F18E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F18E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F18EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F18F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F18F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F18F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1900 size=80
    let mut pc: u32 = 0x823F1900;
    'dispatch: loop {
        match pc {
            0x823F1900 => {
    //   block [0x823F1900..0x823F193C)
	// 823F1900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F1908: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F190C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1910: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F1914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F1918: 816B72B4  lwz r11, 0x72b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29364 as u32) ) } as u64;
	// 823F191C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823F1920: 48002D01  bl 0x823f4620
	ctx.lr = 0x823F1924;
	sub_823F4620(ctx, base);
	// 823F1924: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F1928: 41800014  blt 0x823f193c
	if ctx.cr[0].lt {
	pc = 0x823F193C; continue 'dispatch;
	}
	// 823F192C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823F1930: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F1934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F1938: 48003A31  bl 0x823f5368
	ctx.lr = 0x823F193C;
	sub_823F5368(ctx, base);
	pc = 0x823F193C; continue 'dispatch;
            }
            0x823F193C => {
    //   block [0x823F193C..0x823F1950)
	// 823F193C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F1940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F1944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F1948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F194C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1950 size=24
    let mut pc: u32 = 0x823F1950;
    'dispatch: loop {
        match pc {
            0x823F1950 => {
    //   block [0x823F1950..0x823F1968)
	// 823F1950: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F1954: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 823F1958: 396BD1B0  addi r11, r11, -0x2e50
	ctx.r[11].s64 = ctx.r[11].s64 + -11856;
	// 823F195C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F1960: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F1964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1968 size=208
    let mut pc: u32 = 0x823F1968;
    'dispatch: loop {
        match pc {
            0x823F1968 => {
    //   block [0x823F1968..0x823F19F0)
	// 823F1968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F196C: 48143751  bl 0x825350bc
	ctx.lr = 0x823F1970;
	sub_82535080(ctx, base);
	// 823F1970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F1978: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F197C: 816B72B4  lwz r11, 0x72b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29364 as u32) ) } as u64;
	// 823F1980: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823F1984: 48002C75  bl 0x823f45f8
	ctx.lr = 0x823F1988;
	sub_823F45F8(ctx, base);
	// 823F1988: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F198C: 418000A4  blt 0x823f1a30
	if ctx.cr[0].lt {
	pc = 0x823F1A30; continue 'dispatch;
	}
	// 823F1990: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F1994: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F1998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F199C: 4BFCFBC5  bl 0x823c1560
	ctx.lr = 0x823F19A0;
	sub_823C1560(ctx, base);
	// 823F19A0: 3D80FBDF  lis r12, -0x421
	ctx.r[12].s64 = -69271552;
	// 823F19A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F19A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F19AC: 618C00DD  ori r12, r12, 0xdd
	ctx.r[12].u64 = ctx.r[12].u64 | 221;
	// 823F19B0: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F19B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F19B8: 798C07C6  sldi r12, r12, 0x20
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(32);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 823F19BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F19C0: 658CEADB  oris r12, r12, 0xeadb
	ctx.r[12].u64 = ctx.r[12].u64 | 3940220928;
	// 823F19C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F19C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F19CC: 618CEEF0  ori r12, r12, 0xeef0
	ctx.r[12].u64 = ctx.r[12].u64 | 61168;
	// 823F19D0: 7D646378  or r4, r11, r12
	ctx.r[4].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 823F19D4: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 823F19D8: 48003A09  bl 0x823f53e0
	ctx.lr = 0x823F19DC;
	sub_823F53E0(ctx, base);
	// 823F19DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F19E0: 41800050  blt 0x823f1a30
	if ctx.cr[0].lt {
	pc = 0x823F1A30; continue 'dispatch;
	}
	// 823F19E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F19E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F19EC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823F19F0; continue 'dispatch;
            }
            0x823F19F0 => {
    //   block [0x823F19F0..0x823F1A30)
	// 823F19F0: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 823F19F4: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F19F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F19FC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F1A00: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F1A04: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 823F1A08: 48003B79  bl 0x823f5580
	ctx.lr = 0x823F1A0C;
	sub_823F5580(ctx, base);
	// 823F1A0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F1A10: 41800020  blt 0x823f1a30
	if ctx.cr[0].lt {
	pc = 0x823F1A30; continue 'dispatch;
	}
	// 823F1A14: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F1A18: 2B1E0004  cmplwi cr6, r30, 4
	ctx.cr[6].compare_u32(ctx.r[30].u32, 4 as u32, &mut ctx.xer);
	// 823F1A1C: 4198FFD4  blt cr6, 0x823f19f0
	if ctx.cr[6].lt {
	pc = 0x823F19F0; continue 'dispatch;
	}
	// 823F1A20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823F1A24: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F1A28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F1A2C: 480038C5  bl 0x823f52f0
	ctx.lr = 0x823F1A30;
	sub_823F52F0(ctx, base);
	pc = 0x823F1A30; continue 'dispatch;
            }
            0x823F1A30 => {
    //   block [0x823F1A30..0x823F1A38)
	// 823F1A30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F1A34: 481436D8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1A38 size=328
    let mut pc: u32 = 0x823F1A38;
    'dispatch: loop {
        match pc {
            0x823F1A38 => {
    //   block [0x823F1A38..0x823F1A68)
	// 823F1A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1A3C: 48143681  bl 0x825350bc
	ctx.lr = 0x823F1A40;
	sub_82535080(ctx, base);
	// 823F1A40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1A44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F1A48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F1A4C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F1A50: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F1A54: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1A58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1A5C: 7D6849D6  mullw r11, r8, r9
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F1A60: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F1A64: 48000104  b 0x823f1b68
	pc = 0x823F1B68; continue 'dispatch;
            }
            0x823F1A68 => {
    //   block [0x823F1A68..0x823F1AA4)
	// 823F1A68: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F1A6C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F1A70: 40980104  bge cr6, 0x823f1b74
	if !ctx.cr[6].lt {
	pc = 0x823F1B74; continue 'dispatch;
	}
	// 823F1A74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F1A78: 409A00AC  bne cr6, 0x823f1b24
	if !ctx.cr[6].eq {
	pc = 0x823F1B24; continue 'dispatch;
	}
	// 823F1A7C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1A80: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1A84: 893F0028  lbz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F1A88: 388BFFFE  addi r4, r11, -2
	ctx.r[4].s64 = ctx.r[11].s64 + -2;
	// 823F1A8C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1A90: 896B008C  lbz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 823F1A94: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823F1A98: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F1A9C: 419A0008  beq cr6, 0x823f1aa4
	if ctx.cr[6].eq {
	pc = 0x823F1AA4; continue 'dispatch;
	}
	// 823F1AA0: 997F0028  stb r11, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u8 ) };
	pc = 0x823F1AA4; continue 'dispatch;
            }
            0x823F1AA4 => {
    //   block [0x823F1AA4..0x823F1AB8)
	// 823F1AA4: A17F002A  lhz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 823F1AA8: 2B0B1000  cmplwi cr6, r11, 0x1000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4096 as u32, &mut ctx.xer);
	// 823F1AAC: 4099000C  ble cr6, 0x823f1ab8
	if !ctx.cr[6].gt {
	pc = 0x823F1AB8; continue 'dispatch;
	}
	// 823F1AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F1AB4: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	pc = 0x823F1AB8; continue 'dispatch;
            }
            0x823F1AB8 => {
    //   block [0x823F1AB8..0x823F1B24)
	// 823F1AB8: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1ABC: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 823F1AC0: 891F0028  lbz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F1AC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F1AC8: 510B6026  rlwimi r11, r8, 0xc, 0, 0x13
	ctx.r[11].u64 = (((ctx.r[8].u32).rotate_left(12) as u64) & 0x00000000FFFFF000) | (ctx.r[11].u64 & 0xFFFFFFFF00000FFF);
	// 823F1ACC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 823F1AD0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823F1AD4: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823F1AD8: A17F002A  lhz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 823F1ADC: 51680D3C  rlwimi r8, r11, 1, 0x14, 0x1e
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x0000000000000FFE) | (ctx.r[8].u64 & 0xFFFFFFFFFFFFF001);
	// 823F1AE0: B1040000  sth r8, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823F1AE4: A17F002A  lhz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 823F1AE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F1AEC: B17F002A  sth r11, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[11].u16 ) };
	// 823F1AF0: 816A00C4  lwz r11, 0xc4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F1AF4: A1440000  lhz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1AF8: 556B031E  rlwinm r11, r11, 0, 0xc, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823F1AFC: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823F1B00: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F1B04: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F1B08: 514B043C  rlwimi r11, r10, 0, 0x10, 0x1e
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(0) as u64) & 0x000000000000FFFE) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF0001);
	// 823F1B0C: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823F1B10: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F1B14: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F1B18: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823F1B1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823F1B20: 480039E9  bl 0x823f5508
	ctx.lr = 0x823F1B24;
	sub_823F5508(ctx, base);
	pc = 0x823F1B24; continue 'dispatch;
            }
            0x823F1B24 => {
    //   block [0x823F1B24..0x823F1B68)
	// 823F1B24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F1B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F1B2C: 4BFFFD65  bl 0x823f1890
	ctx.lr = 0x823F1B30;
	sub_823F1890(ctx, base);
	// 823F1B30: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F1B34: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F1B38: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F1B3C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 823F1B40: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F1B44: 0CCA0000  twi 6, r10, 0
	// 823F1B48: 7D095396  divwu r8, r9, r10
	ctx.r[8].u32 = ctx.r[9].u32 / ctx.r[10].u32;
	// 823F1B4C: 7D4851D6  mullw r10, r8, r10
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F1B50: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823F1B54: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823F1B58: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1B5C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1B60: 7D6851D6  mullw r11, r8, r10
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F1B64: 7FCB4A14  add r30, r11, r9
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x823F1B68; continue 'dispatch;
            }
            0x823F1B68 => {
    //   block [0x823F1B68..0x823F1B74)
	// 823F1B68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1B6C: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F1B70: 409AFEF8  bne cr6, 0x823f1a68
	if !ctx.cr[6].eq {
	pc = 0x823F1A68; continue 'dispatch;
	}
	pc = 0x823F1B74; continue 'dispatch;
            }
            0x823F1B74 => {
    //   block [0x823F1B74..0x823F1B80)
	// 823F1B74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F1B78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F1B7C: 48143590  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1B80 size=360
    let mut pc: u32 = 0x823F1B80;
    'dispatch: loop {
        match pc {
            0x823F1B80 => {
    //   block [0x823F1B80..0x823F1C5C)
	// 823F1B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1B84: 4814352D  bl 0x825350b0
	ctx.lr = 0x823F1B88;
	sub_82535080(ctx, base);
	// 823F1B88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1B8C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823F1B90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F1B94: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823F1B98: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 823F1B9C: 3B5F0010  addi r26, r31, 0x10
	ctx.r[26].s64 = ctx.r[31].s64 + 16;
	// 823F1BA0: 812972B4  lwz r9, 0x72b4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(29364 as u32) ) } as u64;
	// 823F1BA4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F1BA8: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 823F1BAC: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F1BB0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823F1BB4: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 823F1BB8: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823F1BBC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 823F1BC0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 823F1BC4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F1BC8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823F1BCC: 386B0002  addi r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 2;
	// 823F1BD0: 48004779  bl 0x823f6348
	ctx.lr = 0x823F1BD4;
	sub_823F6348(ctx, base);
	// 823F1BD4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F1BD8: 41800104  blt 0x823f1cdc
	if ctx.cr[0].lt {
	pc = 0x823F1CDC; continue 'dispatch;
	}
	// 823F1BDC: 3BBF002C  addi r29, r31, 0x2c
	ctx.r[29].s64 = ctx.r[31].s64 + 44;
	// 823F1BE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F1BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F1BE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823F1BEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F1BF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F1BF4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 823F1BF8: 48003B29  bl 0x823f5720
	ctx.lr = 0x823F1BFC;
	sub_823F5720(ctx, base);
	// 823F1BFC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F1C00: 418000DC  blt 0x823f1cdc
	if ctx.cr[0].lt {
	pc = 0x823F1CDC; continue 'dispatch;
	}
	// 823F1C04: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F1C08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F1C0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F1C10: 4BFCF951  bl 0x823c1560
	ctx.lr = 0x823F1C14;
	sub_823C1560(ctx, base);
	// 823F1C14: 3D80FBDF  lis r12, -0x421
	ctx.r[12].s64 = -69271552;
	// 823F1C18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1C1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F1C20: 618C00DD  ori r12, r12, 0xdd
	ctx.r[12].u64 = ctx.r[12].u64 | 221;
	// 823F1C24: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1C28: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F1C2C: 798C07C6  sldi r12, r12, 0x20
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(32);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 823F1C30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F1C34: 658CEADB  oris r12, r12, 0xeadb
	ctx.r[12].u64 = ctx.r[12].u64 | 3940220928;
	// 823F1C38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1C3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F1C40: 618CEEF0  ori r12, r12, 0xeef0
	ctx.r[12].u64 = ctx.r[12].u64 | 61168;
	// 823F1C44: 7D646378  or r4, r11, r12
	ctx.r[4].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 823F1C48: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 823F1C4C: 48003795  bl 0x823f53e0
	ctx.lr = 0x823F1C50;
	sub_823F53E0(ctx, base);
	// 823F1C50: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F1C54: 41800088  blt 0x823f1cdc
	if ctx.cr[0].lt {
	pc = 0x823F1CDC; continue 'dispatch;
	}
	// 823F1C58: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x823F1C5C; continue 'dispatch;
            }
            0x823F1C5C => {
    //   block [0x823F1C5C..0x823F1C9C)
	// 823F1C5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 823F1C60: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1C64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F1C68: 48003919  bl 0x823f5580
	ctx.lr = 0x823F1C6C;
	sub_823F5580(ctx, base);
	// 823F1C6C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F1C70: 4180006C  blt 0x823f1cdc
	if ctx.cr[0].lt {
	pc = 0x823F1CDC; continue 'dispatch;
	}
	// 823F1C74: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 823F1C78: 2B1C0004  cmplwi cr6, r28, 4
	ctx.cr[6].compare_u32(ctx.r[28].u32, 4 as u32, &mut ctx.xer);
	// 823F1C7C: 4198FFE0  blt cr6, 0x823f1c5c
	if ctx.cr[6].lt {
	pc = 0x823F1C5C; continue 'dispatch;
	}
	// 823F1C80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F1C84: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1C88: 480013C1  bl 0x823f3048
	ctx.lr = 0x823F1C8C;
	sub_823F3048(ctx, base);
	// 823F1C8C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F1C90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F1C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F1C98: 4099003C  ble cr6, 0x823f1cd4
	if !ctx.cr[6].gt {
	pc = 0x823F1CD4; continue 'dispatch;
	}
	pc = 0x823F1C9C; continue 'dispatch;
            }
            0x823F1C9C => {
    //   block [0x823F1C9C..0x823F1CD4)
	// 823F1C9C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1CA0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F1CA4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1CA8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1CAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1CB0: 7D69E9D6  mullw r11, r9, r29
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F1CB4: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F1CB8: 48002A21  bl 0x823f46d8
	ctx.lr = 0x823F1CBC;
	sub_823F46D8(ctx, base);
	// 823F1CBC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F1CC0: 41800014  blt 0x823f1cd4
	if ctx.cr[0].lt {
	pc = 0x823F1CD4; continue 'dispatch;
	}
	// 823F1CC4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F1CC8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F1CCC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F1CD0: 4198FFCC  blt cr6, 0x823f1c9c
	if ctx.cr[6].lt {
	pc = 0x823F1C9C; continue 'dispatch;
	}
	pc = 0x823F1CD4; continue 'dispatch;
            }
            0x823F1CD4 => {
    //   block [0x823F1CD4..0x823F1CDC)
	// 823F1CD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F1CD8: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	pc = 0x823F1CDC; continue 'dispatch;
            }
            0x823F1CDC => {
    //   block [0x823F1CDC..0x823F1CE8)
	// 823F1CDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F1CE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F1CE4: 4814341C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1CE8 size=92
    let mut pc: u32 = 0x823F1CE8;
    'dispatch: loop {
        match pc {
            0x823F1CE8 => {
    //   block [0x823F1CE8..0x823F1D30)
	// 823F1CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1CEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F1CF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F1CF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F1CFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F1D00: 419A0030  beq cr6, 0x823f1d30
	if ctx.cr[6].eq {
	pc = 0x823F1D30; continue 'dispatch;
	}
	// 823F1D04: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F1D08: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F1D0C: 4800135D  bl 0x823f3068
	ctx.lr = 0x823F1D10;
	sub_823F3068(ctx, base);
	// 823F1D10: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F1D14: 48003445  bl 0x823f5158
	ctx.lr = 0x823F1D18;
	sub_823F5158(ctx, base);
	// 823F1D18: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F1D1C: 480044E5  bl 0x823f6200
	ctx.lr = 0x823F1D20;
	sub_823F6200(ctx, base);
	// 823F1D20: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F1D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F1D28: 6084800E  ori r4, r4, 0x800e
	ctx.r[4].u64 = ctx.r[4].u64 | 32782;
	// 823F1D2C: 4BFD852D  bl 0x823ca258
	ctx.lr = 0x823F1D30;
	sub_823CA258(ctx, base);
	pc = 0x823F1D30; continue 'dispatch;
            }
            0x823F1D30 => {
    //   block [0x823F1D30..0x823F1D44)
	// 823F1D30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F1D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F1D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F1D3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F1D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1D48 size=136
    let mut pc: u32 = 0x823F1D48;
    'dispatch: loop {
        match pc {
            0x823F1D48 => {
    //   block [0x823F1D48..0x823F1D90)
	// 823F1D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1D4C: 4814336D  bl 0x825350b8
	ctx.lr = 0x823F1D50;
	sub_82535080(ctx, base);
	// 823F1D50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1D54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F1D58: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F1D5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F1D60: 6084800E  ori r4, r4, 0x800e
	ctx.r[4].u64 = ctx.r[4].u64 | 32782;
	// 823F1D64: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 823F1D68: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823F1D6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F1D70: 4BFD8451  bl 0x823ca1c0
	ctx.lr = 0x823F1D74;
	sub_823CA1C0(ctx, base);
	// 823F1D74: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F1D78: 40820028  bne 0x823f1da0
	if !ctx.cr[0].eq {
	pc = 0x823F1DA0; continue 'dispatch;
	}
	// 823F1D7C: 3FA08007  lis r29, -0x7ff9
	ctx.r[29].s64 = -2147024896;
	// 823F1D80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F1D84: 63BD000E  ori r29, r29, 0xe
	ctx.r[29].u64 = ctx.r[29].u64 | 14;
	// 823F1D88: 4BFFFF61  bl 0x823f1ce8
	ctx.lr = 0x823F1D8C;
	sub_823F1CE8(ctx, base);
	// 823F1D8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823F1D90; continue 'dispatch;
            }
            0x823F1D90 => {
    //   block [0x823F1D90..0x823F1DA0)
	// 823F1D90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F1D94: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F1D98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F1D9C: 4814336C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x823F1DA0 => {
    //   block [0x823F1DA0..0x823F1DD0)
	// 823F1DA0: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823F1DA4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823F1DA8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823F1DAC: 394AD144  addi r10, r10, -0x2ebc
	ctx.r[10].s64 = ctx.r[10].s64 + -11964;
	// 823F1DB0: 93EB0020  stw r31, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 823F1DB4: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 823F1DB8: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 823F1DBC: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 823F1DC0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F1DC4: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 823F1DC8: 98EB0028  stb r7, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[7].u8 ) };
	// 823F1DCC: 4BFFFFC4  b 0x823f1d90
	pc = 0x823F1D90; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1DD0 size=16
    let mut pc: u32 = 0x823F1DD0;
    'dispatch: loop {
        match pc {
            0x823F1DD0 => {
    //   block [0x823F1DD0..0x823F1DE0)
	// 823F1DD0: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F1DD4: 4082000C  bne 0x823f1de0
	if !ctx.cr[0].eq {
		sub_823F1DE0(ctx, base);
		return;
	}
	// 823F1DD8: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 823F1DDC: 4BFFFF6C  b 0x823f1d48
	sub_823F1D48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1DE0 size=12
    let mut pc: u32 = 0x823F1DE0;
    'dispatch: loop {
        match pc {
            0x823F1DE0 => {
    //   block [0x823F1DE0..0x823F1DEC)
	// 823F1DE0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823F1DE4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 823F1DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1DF0 size=12
    let mut pc: u32 = 0x823F1DF0;
    'dispatch: loop {
        match pc {
            0x823F1DF0 => {
    //   block [0x823F1DF0..0x823F1DFC)
	// 823F1DF0: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F1DF4: 386B1DD0  addi r3, r11, 0x1dd0
	ctx.r[3].s64 = ctx.r[11].s64 + 7632;
	// 823F1DF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1E00 size=48
    let mut pc: u32 = 0x823F1E00;
    'dispatch: loop {
        match pc {
            0x823F1E00 => {
    //   block [0x823F1E00..0x823F1E20)
	// 823F1E00: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 823F1E04: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F1E08: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F1E0C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F1E10: 409A0010  bne cr6, 0x823f1e20
	if !ctx.cr[6].eq {
	pc = 0x823F1E20; continue 'dispatch;
	}
	// 823F1E14: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F1E18: 396BD1D0  addi r11, r11, -0x2e30
	ctx.r[11].s64 = ctx.r[11].s64 + -11824;
	// 823F1E1C: 4800000C  b 0x823f1e28
	pc = 0x823F1E28; continue 'dispatch;
            }
            0x823F1E20 => {
    //   block [0x823F1E20..0x823F1E28)
	// 823F1E20: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F1E24: 396BD1B0  addi r11, r11, -0x2e50
	ctx.r[11].s64 = ctx.r[11].s64 + -11856;
	pc = 0x823F1E28; continue 'dispatch;
            }
            0x823F1E28 => {
    //   block [0x823F1E28..0x823F1E30)
	// 823F1E28: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F1E2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F1E30 size=20
    let mut pc: u32 = 0x823F1E30;
    'dispatch: loop {
        match pc {
            0x823F1E30 => {
    //   block [0x823F1E30..0x823F1E44)
	// 823F1E30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F1E38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1E3C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F1E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1E48 size=156
    let mut pc: u32 = 0x823F1E48;
    'dispatch: loop {
        match pc {
            0x823F1E48 => {
    //   block [0x823F1E48..0x823F1EA8)
	// 823F1E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F1E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F1E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F1E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1E5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823F1E60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F1E64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F1E68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1E6C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1E70: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1E74: 4BFCF6ED  bl 0x823c1560
	ctx.lr = 0x823F1E78;
	sub_823C1560(ctx, base);
	// 823F1E78: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1E7C: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F1E80: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1E84: 48002855  bl 0x823f46d8
	ctx.lr = 0x823F1E88;
	sub_823F46D8(ctx, base);
	// 823F1E88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F1E8C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F1E90: 40800018  bge 0x823f1ea8
	if !ctx.cr[0].lt {
	pc = 0x823F1EA8; continue 'dispatch;
	}
	// 823F1E94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1E98: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F1E9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1EA0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F1EA4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823F1EA8; continue 'dispatch;
            }
            0x823F1EA8 => {
    //   block [0x823F1EA8..0x823F1EC4)
	// 823F1EA8: 397E002C  addi r11, r30, 0x2c
	ctx.r[11].s64 = ctx.r[30].s64 + 44;
	// 823F1EAC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F1EB0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1EB4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1EB8: 4182000C  beq 0x823f1ec4
	if ctx.cr[0].eq {
	pc = 0x823F1EC4; continue 'dispatch;
	}
	// 823F1EBC: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F1EC0: 48000008  b 0x823f1ec8
	pc = 0x823F1EC8; continue 'dispatch;
            }
            0x823F1EC4 => {
    //   block [0x823F1EC4..0x823F1EC8)
	// 823F1EC4: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823F1EC8; continue 'dispatch;
            }
            0x823F1EC8 => {
    //   block [0x823F1EC8..0x823F1EE4)
	// 823F1EC8: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F1ECC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F1ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F1ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F1ED8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F1EDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F1EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F1EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F1EE8 size=448
    let mut pc: u32 = 0x823F1EE8;
    'dispatch: loop {
        match pc {
            0x823F1EE8 => {
    //   block [0x823F1EE8..0x823F1F04)
	// 823F1EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F1EEC: 481431CD  bl 0x825350b8
	ctx.lr = 0x823F1EF0;
	sub_82535080(ctx, base);
	// 823F1EF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F1EF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F1EF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F1EFC: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 823F1F00: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	pc = 0x823F1F04; continue 'dispatch;
            }
            0x823F1F04 => {
    //   block [0x823F1F04..0x823F1F38)
	// 823F1F04: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1F08: 4182004C  beq 0x823f1f54
	if ctx.cr[0].eq {
	pc = 0x823F1F54; continue 'dispatch;
	}
	// 823F1F0C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F14: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F1F18: 419A003C  beq cr6, 0x823f1f54
	if ctx.cr[6].eq {
	pc = 0x823F1F54; continue 'dispatch;
	}
	// 823F1F1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1F24: 41820020  beq 0x823f1f44
	if ctx.cr[0].eq {
	pc = 0x823F1F44; continue 'dispatch;
	}
	// 823F1F28: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1F2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F1F30: 409A0008  bne cr6, 0x823f1f38
	if !ctx.cr[6].eq {
	pc = 0x823F1F38; continue 'dispatch;
	}
	// 823F1F34: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x823F1F38; continue 'dispatch;
            }
            0x823F1F38 => {
    //   block [0x823F1F38..0x823F1F44)
	// 823F1F38: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1F3C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F1F40: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x823F1F44; continue 'dispatch;
            }
            0x823F1F44 => {
    //   block [0x823F1F44..0x823F1F54)
	// 823F1F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F1F48: 4BFFFF01  bl 0x823f1e48
	ctx.lr = 0x823F1F4C;
	sub_823F1E48(ctx, base);
	// 823F1F4C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F50: 4BFFFFB4  b 0x823f1f04
	pc = 0x823F1F04; continue 'dispatch;
            }
            0x823F1F54 => {
    //   block [0x823F1F54..0x823F1F5C)
	// 823F1F54: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F1F58: 3BBF002C  addi r29, r31, 0x2c
	ctx.r[29].s64 = ctx.r[31].s64 + 44;
	pc = 0x823F1F5C; continue 'dispatch;
            }
            0x823F1F5C => {
    //   block [0x823F1F5C..0x823F1F94)
	// 823F1F5C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1F60: 4182013C  beq 0x823f209c
	if ctx.cr[0].eq {
	pc = 0x823F209C; continue 'dispatch;
	}
	// 823F1F64: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F68: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F6C: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F1F70: 419A012C  beq cr6, 0x823f209c
	if ctx.cr[6].eq {
	pc = 0x823F209C; continue 'dispatch;
	}
	// 823F1F74: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1F78: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F1F7C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F1F80: 41820020  beq 0x823f1fa0
	if ctx.cr[0].eq {
	pc = 0x823F1FA0; continue 'dispatch;
	}
	// 823F1F84: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1F88: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F1F8C: 409A0008  bne cr6, 0x823f1f94
	if !ctx.cr[6].eq {
	pc = 0x823F1F94; continue 'dispatch;
	}
	// 823F1F90: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x823F1F94; continue 'dispatch;
            }
            0x823F1F94 => {
    //   block [0x823F1F94..0x823F1FA0)
	// 823F1F94: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1F98: 911D0000  stw r8, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823F1F9C: 938A0004  stw r28, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x823F1FA0; continue 'dispatch;
            }
            0x823F1FA0 => {
    //   block [0x823F1FA0..0x823F1FCC)
	// 823F1FA0: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F1FA4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F1FA8: 409A00E4  bne cr6, 0x823f208c
	if !ctx.cr[6].eq {
	pc = 0x823F208C; continue 'dispatch;
	}
	// 823F1FAC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1FB0: 893F003C  lbz r9, 0x3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F1FB4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F1FB8: 894A008C  lbz r10, 0x8c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 823F1FBC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 823F1FC0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F1FC4: 419A0008  beq cr6, 0x823f1fcc
	if ctx.cr[6].eq {
	pc = 0x823F1FCC; continue 'dispatch;
	}
	// 823F1FC8: 995F003C  stb r10, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	pc = 0x823F1FCC; continue 'dispatch;
            }
            0x823F1FCC => {
    //   block [0x823F1FCC..0x823F1FDC)
	// 823F1FCC: A15F003E  lhz r10, 0x3e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(62 as u32) ) } as u64;
	// 823F1FD0: 2B0A1000  cmplwi cr6, r10, 0x1000
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4096 as u32, &mut ctx.xer);
	// 823F1FD4: 40990008  ble cr6, 0x823f1fdc
	if !ctx.cr[6].gt {
	pc = 0x823F1FDC; continue 'dispatch;
	}
	// 823F1FD8: B39F003E  sth r28, 0x3e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[28].u16 ) };
	pc = 0x823F1FDC; continue 'dispatch;
            }
            0x823F1FDC => {
    //   block [0x823F1FDC..0x823F2060)
	// 823F1FDC: A14BFFFE  lhz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823F1FE0: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 823F1FE4: 893F003C  lbz r9, 0x3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F1FE8: 38E00103  li r7, 0x103
	ctx.r[7].s64 = 259;
	// 823F1FEC: 512A6026  rlwimi r10, r9, 0xc, 0, 0x13
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(12) as u64) & 0x00000000FFFFF000) | (ctx.r[10].u64 & 0xFFFFFFFF00000FFF);
	// 823F1FF0: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823F1FF4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 823F1FF8: B14BFFFE  sth r10, -2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[10].u16 ) };
	// 823F1FFC: A15F003E  lhz r10, 0x3e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(62 as u32) ) } as u64;
	// 823F2000: 51490D3C  rlwimi r9, r10, 1, 0x14, 0x1e
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(1) as u64) & 0x0000000000000FFE) | (ctx.r[9].u64 & 0xFFFFFFFFFFFFF001);
	// 823F2004: B12BFFFE  sth r9, -2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[9].u16 ) };
	// 823F2008: A15F003E  lhz r10, 0x3e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(62 as u32) ) } as u64;
	// 823F200C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2010: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F2014: B15F003E  sth r10, 0x3e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[10].u16 ) };
	// 823F2018: 814900C4  lwz r10, 0xc4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F201C: A12BFFFE  lhz r9, -2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 823F2020: 554A031E  rlwinm r10, r10, 0, 0xc, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823F2024: 7D4A4050  subf r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 823F2028: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823F202C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823F2030: 512A043C  rlwimi r10, r9, 0, 0x10, 0x1e
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x000000000000FFFE) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0001);
	// 823F2034: B14BFFFE  sth r10, -2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[10].u16 ) };
	// 823F2038: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F203C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823F2040: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2044: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F2048: 93840004  stw r28, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F204C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2050: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2054: 4182000C  beq 0x823f2060
	if ctx.cr[0].eq {
	pc = 0x823F2060; continue 'dispatch;
	}
	// 823F2058: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F205C: 48000008  b 0x823f2064
	pc = 0x823F2064; continue 'dispatch;
            }
            0x823F2060 => {
    //   block [0x823F2060..0x823F2064)
	// 823F2060: 909E0000  stw r4, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x823F2064; continue 'dispatch;
            }
            0x823F2064 => {
    //   block [0x823F2064..0x823F208C)
	// 823F2064: 909E0004  stw r4, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F2068: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F206C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2070: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F2074: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2078: 7D4A4830  slw r10, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 823F207C: 812B04F4  lwz r9, 0x4f4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1268 as u32) ) } as u64;
	// 823F2080: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 823F2084: 914B04F4  stw r10, 0x4f4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1268 as u32), ctx.r[10].u32 ) };
	// 823F2088: 4800000C  b 0x823f2094
	pc = 0x823F2094; continue 'dispatch;
            }
            0x823F208C => {
    //   block [0x823F208C..0x823F2094)
	// 823F208C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F2090: 4BFFFDB9  bl 0x823f1e48
	ctx.lr = 0x823F2094;
	sub_823F1E48(ctx, base);
	pc = 0x823F2094; continue 'dispatch;
            }
            0x823F2094 => {
    //   block [0x823F2094..0x823F209C)
	// 823F2094: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2098: 4BFFFEC4  b 0x823f1f5c
	pc = 0x823F1F5C; continue 'dispatch;
            }
            0x823F209C => {
    //   block [0x823F209C..0x823F20A8)
	// 823F209C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F20A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F20A4: 48143064  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F20A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F20A8 size=496
    let mut pc: u32 = 0x823F20A8;
    'dispatch: loop {
        match pc {
            0x823F20A8 => {
    //   block [0x823F20A8..0x823F20E8)
	// 823F20A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F20AC: 48142FF9  bl 0x825350a4
	ctx.lr = 0x823F20B0;
	sub_82535080(ctx, base);
	// 823F20B0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F20B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F20B8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 823F20BC: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 823F20C0: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 823F20C4: 831E0040  lwz r24, 0x40(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F20C8: 807E0044  lwz r3, 0x44(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F20CC: 48004A4D  bl 0x823f6b18
	ctx.lr = 0x823F20D0;
	sub_823F6B18(ctx, base);
	// 823F20D0: 83FE002C  lwz r31, 0x2c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F20D4: 3B7E002C  addi r27, r30, 0x2c
	ctx.r[27].s64 = ctx.r[30].s64 + 44;
	// 823F20D8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F20DC: 4082000C  bne 0x823f20e8
	if !ctx.cr[0].eq {
	pc = 0x823F20E8; continue 'dispatch;
	}
	// 823F20E0: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 823F20E4: 4800001C  b 0x823f2100
	pc = 0x823F2100; continue 'dispatch;
            }
            0x823F20E8 => {
    //   block [0x823F20E8..0x823F2100)
	// 823F20E8: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F20EC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F20F0: 41820010  beq 0x823f2100
	if ctx.cr[0].eq {
	pc = 0x823F2100; continue 'dispatch;
	}
	// 823F20F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F20F8: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F20FC: 409A0020  bne cr6, 0x823f211c
	if !ctx.cr[6].eq {
	pc = 0x823F211C; continue 'dispatch;
	}
	pc = 0x823F2100; continue 'dispatch;
            }
            0x823F2100 => {
    //   block [0x823F2100..0x823F211C)
	// 823F2100: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F2104: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F2108: 409A0014  bne cr6, 0x823f211c
	if !ctx.cr[6].eq {
	pc = 0x823F211C; continue 'dispatch;
	}
	// 823F210C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F2110: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F2114: 917E0040  stw r11, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 823F2118: 48191E29  bl 0x82583f40
	ctx.lr = 0x823F211C;
	sub_82583F40(ctx, base);
	pc = 0x823F211C; continue 'dispatch;
            }
            0x823F211C => {
    //   block [0x823F211C..0x823F2124)
	// 823F211C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F2120: 419A00E0  beq cr6, 0x823f2200
	if ctx.cr[6].eq {
	pc = 0x823F2200; continue 'dispatch;
	}
	pc = 0x823F2124; continue 'dispatch;
            }
            0x823F2124 => {
    //   block [0x823F2124..0x823F21B4)
	// 823F2124: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2128: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F212C: 419A00D4  beq cr6, 0x823f2200
	if ctx.cr[6].eq {
	pc = 0x823F2200; continue 'dispatch;
	}
	// 823F2130: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F2134: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F2138: 409800C8  bge cr6, 0x823f2200
	if !ctx.cr[6].lt {
	pc = 0x823F2200; continue 'dispatch;
	}
	// 823F213C: 3B9E0034  addi r28, r30, 0x34
	ctx.r[28].s64 = ctx.r[30].s64 + 52;
	// 823F2140: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F2144: 48003F1D  bl 0x823f6060
	ctx.lr = 0x823F2148;
	sub_823F6060(ctx, base);
	// 823F2148: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F214C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F2150: 409800B0  bge cr6, 0x823f2200
	if !ctx.cr[6].lt {
	pc = 0x823F2200; continue 'dispatch;
	}
	// 823F2154: 39600103  li r11, 0x103
	ctx.r[11].s64 = 259;
	// 823F2158: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 823F215C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F2164: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F2168: 4BFCF3F9  bl 0x823c1560
	ctx.lr = 0x823F216C;
	sub_823C1560(ctx, base);
	// 823F216C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2170: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F2174: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F2178: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F217C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823F2180: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F2184: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 823F2188: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823F218C: 48191BFD  bl 0x82583d88
	ctx.lr = 0x823F2190;
	sub_82583D88(ctx, base);
	// 823F2190: 7C771B79  or. r23, r3, r3
	ctx.r[23].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 823F2194: 41800064  blt 0x823f21f8
	if ctx.cr[0].lt {
	pc = 0x823F21F8; continue 'dispatch;
	}
	// 823F2198: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F219C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F21A0: 41820020  beq 0x823f21c0
	if ctx.cr[0].eq {
	pc = 0x823F21C0; continue 'dispatch;
	}
	// 823F21A4: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F21A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F21AC: 409A0008  bne cr6, 0x823f21b4
	if !ctx.cr[6].eq {
	pc = 0x823F21B4; continue 'dispatch;
	}
	// 823F21B0: 933B0004  stw r25, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	pc = 0x823F21B4; continue 'dispatch;
            }
            0x823F21B4 => {
    //   block [0x823F21B4..0x823F21C0)
	// 823F21B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F21B8: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F21BC: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	pc = 0x823F21C0; continue 'dispatch;
            }
            0x823F21C0 => {
    //   block [0x823F21C0..0x823F21D8)
	// 823F21C0: 933F0004  stw r25, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 823F21C4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F21C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F21CC: 4182000C  beq 0x823f21d8
	if ctx.cr[0].eq {
	pc = 0x823F21D8; continue 'dispatch;
	}
	// 823F21D0: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F21D4: 48000008  b 0x823f21dc
	pc = 0x823F21DC; continue 'dispatch;
            }
            0x823F21D8 => {
    //   block [0x823F21D8..0x823F21DC)
	// 823F21D8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823F21DC; continue 'dispatch;
            }
            0x823F21DC => {
    //   block [0x823F21DC..0x823F21F8)
	// 823F21DC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F21E0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823F21E4: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F21E8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F21EC: 41820014  beq 0x823f2200
	if ctx.cr[0].eq {
	pc = 0x823F2200; continue 'dispatch;
	}
	// 823F21F0: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F21F4: 4BFFFF30  b 0x823f2124
	pc = 0x823F2124; continue 'dispatch;
            }
            0x823F21F8 => {
    //   block [0x823F21F8..0x823F2200)
	// 823F21F8: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 823F21FC: 933D0000  stw r25, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	pc = 0x823F2200; continue 'dispatch;
            }
            0x823F2200 => {
    //   block [0x823F2200..0x823F2234)
	// 823F2200: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F2204: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F2208: 409A002C  bne cr6, 0x823f2234
	if !ctx.cr[6].eq {
	pc = 0x823F2234; continue 'dispatch;
	}
	// 823F220C: 2F180001  cmpwi cr6, r24, 1
	ctx.cr[6].compare_i32(ctx.r[24].s32, 1, &mut ctx.xer);
	// 823F2210: 409A0024  bne cr6, 0x823f2234
	if !ctx.cr[6].eq {
	pc = 0x823F2234; continue 'dispatch;
	}
	// 823F2214: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 823F2218: 48003E49  bl 0x823f6060
	ctx.lr = 0x823F221C;
	sub_823F6060(ctx, base);
	// 823F221C: 2B030002  cmplwi cr6, r3, 2
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2 as u32, &mut ctx.xer);
	// 823F2220: 41980014  blt cr6, 0x823f2234
	if ctx.cr[6].lt {
	pc = 0x823F2234; continue 'dispatch;
	}
	// 823F2224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2228: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F222C: 48191C75  bl 0x82583ea0
	ctx.lr = 0x823F2230;
	sub_82583EA0(ctx, base);
	// 823F2230: 933E0040  stw r25, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[25].u32 ) };
	pc = 0x823F2234; continue 'dispatch;
            }
            0x823F2234 => {
    //   block [0x823F2234..0x823F2240)
	// 823F2234: 809E0034  lwz r4, 0x34(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F2238: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	// 823F223C: 48000048  b 0x823f2284
	pc = 0x823F2284; continue 'dispatch;
            }
            0x823F2240 => {
    //   block [0x823F2240..0x823F226C)
	// 823F2240: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2244: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2248: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F224C: 419A0040  beq cr6, 0x823f228c
	if ctx.cr[6].eq {
	pc = 0x823F228C; continue 'dispatch;
	}
	// 823F2250: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2254: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2258: 41820020  beq 0x823f2278
	if ctx.cr[0].eq {
	pc = 0x823F2278; continue 'dispatch;
	}
	// 823F225C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2260: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F2264: 409A0008  bne cr6, 0x823f226c
	if !ctx.cr[6].eq {
	pc = 0x823F226C; continue 'dispatch;
	}
	// 823F2268: 933F0004  stw r25, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	pc = 0x823F226C; continue 'dispatch;
            }
            0x823F226C => {
    //   block [0x823F226C..0x823F2278)
	// 823F226C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2270: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F2274: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	pc = 0x823F2278; continue 'dispatch;
            }
            0x823F2278 => {
    //   block [0x823F2278..0x823F2284)
	// 823F2278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F227C: 4BFFFBCD  bl 0x823f1e48
	ctx.lr = 0x823F2280;
	sub_823F1E48(ctx, base);
	// 823F2280: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823F2284; continue 'dispatch;
            }
            0x823F2284 => {
    //   block [0x823F2284..0x823F228C)
	// 823F2284: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2288: 4082FFB8  bne 0x823f2240
	if !ctx.cr[0].eq {
	pc = 0x823F2240; continue 'dispatch;
	}
	pc = 0x823F228C; continue 'dispatch;
            }
            0x823F228C => {
    //   block [0x823F228C..0x823F2298)
	// 823F228C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823F2290: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 823F2294: 48142E60  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2298 size=16
    let mut pc: u32 = 0x823F2298;
    'dispatch: loop {
        match pc {
            0x823F2298 => {
    //   block [0x823F2298..0x823F22A8)
	// 823F2298: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F229C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F22A0: 409A0008  bne cr6, 0x823f22a8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x823F22A8);
		return;
	}
	// 823F22A4: 4BFFFE04  b 0x823f20a8
	sub_823F20A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F22B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F22B0 size=152
    let mut pc: u32 = 0x823F22B0;
    'dispatch: loop {
        match pc {
            0x823F22B0 => {
    //   block [0x823F22B0..0x823F22E4)
	// 823F22B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F22B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F22B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F22BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F22C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F22C4: 4800235D  bl 0x823f4620
	ctx.lr = 0x823F22C8;
	sub_823F4620(ctx, base);
	// 823F22C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F22CC: 41800068  blt 0x823f2334
	if ctx.cr[0].lt {
	pc = 0x823F2334; continue 'dispatch;
	}
	// 823F22D0: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F22D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F22D8: 409A0030  bne cr6, 0x823f2308
	if !ctx.cr[6].eq {
	pc = 0x823F2308; continue 'dispatch;
	}
	// 823F22DC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F22E0: 48000020  b 0x823f2300
	pc = 0x823F2300; continue 'dispatch;
            }
            0x823F22E4 => {
    //   block [0x823F22E4..0x823F2300)
	// 823F22E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F22E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F22EC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823F22F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F22F4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F22F8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823F22FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823F2300; continue 'dispatch;
            }
            0x823F2300 => {
    //   block [0x823F2300..0x823F2308)
	// 823F2300: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2304: 4082FFE0  bne 0x823f22e4
	if !ctx.cr[0].eq {
	pc = 0x823F22E4; continue 'dispatch;
	}
	pc = 0x823F2308; continue 'dispatch;
            }
            0x823F2308 => {
    //   block [0x823F2308..0x823F2334)
	// 823F2308: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F230C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F2310: 409A0024  bne cr6, 0x823f2334
	if !ctx.cr[6].eq {
	pc = 0x823F2334; continue 'dispatch;
	}
	// 823F2314: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F2318: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F231C: 41820018  beq 0x823f2334
	if ctx.cr[0].eq {
	pc = 0x823F2334; continue 'dispatch;
	}
	// 823F2320: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F2324: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2328: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823F232C: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 823F2330: 48191BB9  bl 0x82583ee8
	ctx.lr = 0x823F2334;
	sub_82583EE8(ctx, base);
	pc = 0x823F2334; continue 'dispatch;
            }
            0x823F2334 => {
    //   block [0x823F2334..0x823F2348)
	// 823F2334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F2338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F233C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F2340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F2344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F2348 size=212
    let mut pc: u32 = 0x823F2348;
    'dispatch: loop {
        match pc {
            0x823F2348 => {
    //   block [0x823F2348..0x823F23B4)
	// 823F2348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F234C: 48142D69  bl 0x825350b4
	ctx.lr = 0x823F2350;
	sub_82535080(ctx, base);
	// 823F2350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F2354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F2358: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823F235C: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 823F2360: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 823F2364: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 823F2368: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F236C: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 823F2370: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823F2374: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823F2378: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F237C: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823F2380: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F2384: 554AE7BC  rlwinm r10, r10, 0x1c, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 823F2388: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823F238C: 69460002  xori r6, r10, 2
	ctx.r[6].u64 = ctx.r[10].u64 ^ 2;
	// 823F2390: 7C6B3214  add r3, r11, r6
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 823F2394: 48003FB5  bl 0x823f6348
	ctx.lr = 0x823F2398;
	sub_823F6348(ctx, base);
	// 823F2398: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823F239C: 41800074  blt 0x823f2410
	if ctx.cr[0].lt {
	pc = 0x823F2410; continue 'dispatch;
	}
	// 823F23A0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F23A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F23A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F23AC: 40990048  ble cr6, 0x823f23f4
	if !ctx.cr[6].gt {
	pc = 0x823F23F4; continue 'dispatch;
	}
	// 823F23B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x823F23B4; continue 'dispatch;
            }
            0x823F23B4 => {
    //   block [0x823F23B4..0x823F23F4)
	// 823F23B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F23B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F23BC: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F23C0: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F23C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F23C8: 7D68E9D6  mullw r11, r8, r29
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F23CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F23D0: 7D7E492E  stwx r11, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 823F23D4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F23D8: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 823F23DC: 4BFFFA6D  bl 0x823f1e48
	ctx.lr = 0x823F23E0;
	sub_823F1E48(ctx, base);
	// 823F23E0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F23E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F23E8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 823F23EC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F23F0: 4198FFC4  blt cr6, 0x823f23b4
	if ctx.cr[6].lt {
	pc = 0x823F23B4; continue 'dispatch;
	}
	pc = 0x823F23F4; continue 'dispatch;
            }
            0x823F23F4 => {
    //   block [0x823F23F4..0x823F2410)
	// 823F23F4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F23F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F23FC: 409A0014  bne cr6, 0x823f2410
	if !ctx.cr[6].eq {
	pc = 0x823F2410; continue 'dispatch;
	}
	// 823F2400: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 823F2404: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2408: 48004C11  bl 0x823f7018
	ctx.lr = 0x823F240C;
	sub_823F7018(ctx, base);
	// 823F240C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x823F2410; continue 'dispatch;
            }
            0x823F2410 => {
    //   block [0x823F2410..0x823F241C)
	// 823F2410: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F2414: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F2418: 48142CEC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F2420 size=152
    let mut pc: u32 = 0x823F2420;
    'dispatch: loop {
        match pc {
            0x823F2420 => {
    //   block [0x823F2420..0x823F2464)
	// 823F2420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F2428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F242C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F2430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F2434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F2438: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F243C: 419A0064  beq cr6, 0x823f24a0
	if ctx.cr[6].eq {
	pc = 0x823F24A0; continue 'dispatch;
	}
	// 823F2440: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F2444: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F2448: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F244C: 409A0020  bne cr6, 0x823f246c
	if !ctx.cr[6].eq {
	pc = 0x823F246C; continue 'dispatch;
	}
	// 823F2450: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F2454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2458: 4182000C  beq 0x823f2464
	if ctx.cr[0].eq {
	pc = 0x823F2464; continue 'dispatch;
	}
	// 823F245C: 4819174D  bl 0x82583ba8
	ctx.lr = 0x823F2460;
	sub_82583BA8(ctx, base);
	// 823F2460: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	pc = 0x823F2464; continue 'dispatch;
            }
            0x823F2464 => {
    //   block [0x823F2464..0x823F246C)
	// 823F2464: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F2468: 48004639  bl 0x823f6aa0
	ctx.lr = 0x823F246C;
	sub_823F6AA0(ctx, base);
	pc = 0x823F246C; continue 'dispatch;
            }
            0x823F246C => {
    //   block [0x823F246C..0x823F2488)
	// 823F246C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F2470: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2474: 41820014  beq 0x823f2488
	if ctx.cr[0].eq {
	pc = 0x823F2488; continue 'dispatch;
	}
	// 823F2478: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F247C: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823F2480: 4BFD7DD9  bl 0x823ca258
	ctx.lr = 0x823F2484;
	sub_823CA258(ctx, base);
	// 823F2484: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	pc = 0x823F2488; continue 'dispatch;
            }
            0x823F2488 => {
    //   block [0x823F2488..0x823F24A0)
	// 823F2488: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F248C: 48003D75  bl 0x823f6200
	ctx.lr = 0x823F2490;
	sub_823F6200(ctx, base);
	// 823F2490: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F2494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F2498: 60848011  ori r4, r4, 0x8011
	ctx.r[4].u64 = ctx.r[4].u64 | 32785;
	// 823F249C: 4BFD7DBD  bl 0x823ca258
	ctx.lr = 0x823F24A0;
	sub_823CA258(ctx, base);
	pc = 0x823F24A0; continue 'dispatch;
            }
            0x823F24A0 => {
    //   block [0x823F24A0..0x823F24B8)
	// 823F24A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F24A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F24A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F24AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F24B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F24B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F24B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F24B8 size=304
    let mut pc: u32 = 0x823F24B8;
    'dispatch: loop {
        match pc {
            0x823F24B8 => {
    //   block [0x823F24B8..0x823F24F0)
	// 823F24B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F24BC: 48142BED  bl 0x825350a8
	ctx.lr = 0x823F24C0;
	sub_82535080(ctx, base);
	// 823F24C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F24C4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 823F24C8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F24CC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823F24D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823F24D4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F24D8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823F24DC: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 823F24E0: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 823F24E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823F24E8: 419A0008  beq cr6, 0x823f24f0
	if ctx.cr[6].eq {
	pc = 0x823F24F0; continue 'dispatch;
	}
	// 823F24EC: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x823F24F0; continue 'dispatch;
            }
            0x823F24F0 => {
    //   block [0x823F24F0..0x823F24FC)
	// 823F24F0: 83B80034  lwz r29, 0x34(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F24F4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F24F8: 418200AC  beq 0x823f25a4
	if ctx.cr[0].eq {
	pc = 0x823F25A4; continue 'dispatch;
	}
	pc = 0x823F24FC; continue 'dispatch;
            }
            0x823F24FC => {
    //   block [0x823F24FC..0x823F2560)
	// 823F24FC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2500: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2504: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F2508: 419A0090  beq cr6, 0x823f2598
	if ctx.cr[6].eq {
	pc = 0x823F2598; continue 'dispatch;
	}
	// 823F250C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2510: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F2514: 81190000  lwz r8, 0(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2518: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823F251C: 7D1E4050  subf r8, r30, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 823F2520: 3BE90002  addi r31, r9, 2
	ctx.r[31].s64 = ctx.r[9].s64 + 2;
	// 823F2524: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F2528: 419900A8  bgt cr6, 0x823f25d0
	if ctx.cr[6].gt {
	pc = 0x823F25D0; continue 'dispatch;
	}
	// 823F252C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2530: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823F2534: 7C7EDA14  add r3, r30, r27
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[27].u64;
	// 823F2538: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F253C: 388BFFFE  addi r4, r11, -2
	ctx.r[4].s64 = ctx.r[11].s64 + -2;
	// 823F2540: 48142611  bl 0x82534b50
	ctx.lr = 0x823F2544;
	sub_82534B50(ctx, base);
	// 823F2544: 7FDFF214  add r30, r31, r30
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 823F2548: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F254C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823F2550: 419A0010  beq cr6, 0x823f2560
	if ctx.cr[6].eq {
	pc = 0x823F2560; continue 'dispatch;
	}
	// 823F2554: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2558: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F255C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F2560; continue 'dispatch;
            }
            0x823F2560 => {
    //   block [0x823F2560..0x823F2580)
	// 823F2560: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2564: 393FFFFE  addi r9, r31, -2
	ctx.r[9].s64 = ctx.r[31].s64 + -2;
	// 823F2568: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F256C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F2570: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 823F2574: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F2578: 40980008  bge cr6, 0x823f2580
	if !ctx.cr[6].lt {
	pc = 0x823F2580; continue 'dispatch;
	}
	// 823F257C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F2580; continue 'dispatch;
            }
            0x823F2580 => {
    //   block [0x823F2580..0x823F2598)
	// 823F2580: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F2584: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2588: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F258C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F2590: 409A000C  bne cr6, 0x823f259c
	if !ctx.cr[6].eq {
	pc = 0x823F259C; continue 'dispatch;
	}
	// 823F2594: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x823F2598; continue 'dispatch;
            }
            0x823F2598 => {
    //   block [0x823F2598..0x823F259C)
	// 823F2598: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x823F259C; continue 'dispatch;
            }
            0x823F259C => {
    //   block [0x823F259C..0x823F25A4)
	// 823F259C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F25A0: 409AFF5C  bne cr6, 0x823f24fc
	if !ctx.cr[6].eq {
	pc = 0x823F24FC; continue 'dispatch;
	}
	pc = 0x823F25A4; continue 'dispatch;
            }
            0x823F25A4 => {
    //   block [0x823F25A4..0x823F25C4)
	// 823F25A4: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F25A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F25AC: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F25B0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F25B4: 7D4A4830  slw r10, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 823F25B8: 812B04F4  lwz r9, 0x4f4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1268 as u32) ) } as u64;
	// 823F25BC: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	// 823F25C0: 914B04F4  stw r10, 0x4f4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1268 as u32), ctx.r[10].u32 ) };
	pc = 0x823F25C4; continue 'dispatch;
            }
            0x823F25C4 => {
    //   block [0x823F25C4..0x823F25D0)
	// 823F25C4: 93D90000  stw r30, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823F25C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F25CC: 48142B2C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x823F25D0 => {
    //   block [0x823F25D0..0x823F25E8)
	// 823F25D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F25D4: 409AFFF0  bne cr6, 0x823f25c4
	if !ctx.cr[6].eq {
	pc = 0x823F25C4; continue 'dispatch;
	}
	// 823F25D8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 823F25DC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 823F25E0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 823F25E4: 4BFFFFE0  b 0x823f25c4
	pc = 0x823F25C4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F25E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F25E8 size=324
    let mut pc: u32 = 0x823F25E8;
    'dispatch: loop {
        match pc {
            0x823F25E8 => {
    //   block [0x823F25E8..0x823F26B4)
	// 823F25E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F25EC: 48142AC5  bl 0x825350b0
	ctx.lr = 0x823F25F0;
	sub_82535080(ctx, base);
	// 823F25F0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F25F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F25F8: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 823F25FC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F2600: 615A4001  ori r26, r10, 0x4001
	ctx.r[26].u64 = ctx.r[10].u64 | 16385;
	// 823F2604: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F2608: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F260C: 419A0114  beq cr6, 0x823f2720
	if ctx.cr[6].eq {
	pc = 0x823F2720; continue 'dispatch;
	}
	// 823F2610: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2614: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F261C: 4BFCEF45  bl 0x823c1560
	ctx.lr = 0x823F2620;
	sub_823C1560(ctx, base);
	// 823F2620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F2624: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823F2628: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F262C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823F2634: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F2638: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823F263C: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 823F2640: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 823F2644: 4BFCEF1D  bl 0x823c1560
	ctx.lr = 0x823F2648;
	sub_823C1560(ctx, base);
	// 823F2648: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823F264C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823F2650: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2654: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2658: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 823F265C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F2660: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 823F2664: 4BFCEEFD  bl 0x823c1560
	ctx.lr = 0x823F2668;
	sub_823C1560(ctx, base);
	// 823F2668: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F266C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 823F2670: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2674: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F267C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823F2680: 4BFCEEE1  bl 0x823c1560
	ctx.lr = 0x823F2684;
	sub_823C1560(ctx, base);
	// 823F2684: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 823F2688: 807D003C  lwz r3, 0x3c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F268C: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 823F2690: 3B9D003C  addi r28, r29, 0x3c
	ctx.r[28].s64 = ctx.r[29].s64 + 60;
	// 823F2694: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2698: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F269C: 41820018  beq 0x823f26b4
	if ctx.cr[0].eq {
	pc = 0x823F26B4; continue 'dispatch;
	}
	// 823F26A0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F26A4: 419A0078  beq cr6, 0x823f271c
	if ctx.cr[6].eq {
	pc = 0x823F271C; continue 'dispatch;
	}
	// 823F26A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 823F26AC: 481915D5  bl 0x82583c80
	ctx.lr = 0x823F26B0;
	sub_82583C80(ctx, base);
	// 823F26B0: 48000068  b 0x823f2718
	pc = 0x823F2718; continue 'dispatch;
            }
            0x823F26B4 => {
    //   block [0x823F26B4..0x823F2718)
	// 823F26B4: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 823F26B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F26BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F26C0: 4BFCEEA1  bl 0x823c1560
	ctx.lr = 0x823F26C4;
	sub_823C1560(ctx, base);
	// 823F26C4: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F26C8: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F26CC: 9BC10070  stb r30, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u8 ) };
	// 823F26D0: 39203E80  li r9, 0x3e80
	ctx.r[9].s64 = 16000;
	// 823F26D4: 9BC10074  stb r30, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u8 ) };
	// 823F26D8: 396B1E30  addi r11, r11, 0x1e30
	ctx.r[11].s64 = ctx.r[11].s64 + 7728;
	// 823F26DC: 9BC100A9  stb r30, 0xa9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(169 as u32), ctx.r[30].u8 ) };
	// 823F26E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F26E4: 9BC100AA  stb r30, 0xaa(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(170 as u32), ctx.r[30].u8 ) };
	// 823F26E8: 994100AB  stb r10, 0xab(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(171 as u32), ctx.r[10].u8 ) };
	// 823F26EC: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823F26F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F26F4: 9BE100B0  stb r31, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u8 ) };
	// 823F26F8: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 823F26FC: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 823F2700: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 823F2704: 914100B8  stw r10, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 823F2708: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 823F270C: 93E100C4  stw r31, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u32 ) };
	// 823F2710: 93A100C8  stw r29, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 823F2714: 48191BB5  bl 0x825842c8
	ctx.lr = 0x823F2718;
	sub_825842C8(ctx, base);
	pc = 0x823F2718; continue 'dispatch;
            }
            0x823F2718 => {
    //   block [0x823F2718..0x823F271C)
	// 823F2718: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	pc = 0x823F271C; continue 'dispatch;
            }
            0x823F271C => {
    //   block [0x823F271C..0x823F2720)
	// 823F271C: 93DD0040  stw r30, 0x40(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	pc = 0x823F2720; continue 'dispatch;
            }
            0x823F2720 => {
    //   block [0x823F2720..0x823F272C)
	// 823F2720: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F2724: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823F2728: 481429D8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F2730 size=160
    let mut pc: u32 = 0x823F2730;
    'dispatch: loop {
        match pc {
            0x823F2730 => {
    //   block [0x823F2730..0x823F2764)
	// 823F2730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2734: 4814297D  bl 0x825350b0
	ctx.lr = 0x823F2738;
	sub_82535080(ctx, base);
	// 823F2738: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F273C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 823F2740: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F2744: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823F2748: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F274C: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F2750: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F2754: 409A0010  bne cr6, 0x823f2764
	if !ctx.cr[6].eq {
	pc = 0x823F2764; continue 'dispatch;
	}
	// 823F2758: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823F275C: 60634001  ori r3, r3, 0x4001
	ctx.r[3].u64 = ctx.r[3].u64 | 16385;
	// 823F2760: 48000068  b 0x823f27c8
	pc = 0x823F27C8; continue 'dispatch;
            }
            0x823F2764 => {
    //   block [0x823F2764..0x823F278C)
	// 823F2764: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2768: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F276C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F2770: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F2774: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F2778: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 823F277C: 7F6AFB97  divwu. r27, r10, r31
	ctx.r[27].u32 = ctx.r[10].u32 / ctx.r[31].u32;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823F2780: 0CDF0000  twi 6, r31, 0
	// 823F2784: 41820044  beq 0x823f27c8
	if ctx.cr[0].eq {
	pc = 0x823F27C8; continue 'dispatch;
	}
	// 823F2788: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	pc = 0x823F278C; continue 'dispatch;
            }
            0x823F278C => {
    //   block [0x823F278C..0x823F27C8)
	// 823F278C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823F2790: 807A0044  lwz r3, 0x44(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F2794: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F2798: 480045F9  bl 0x823f6d90
	ctx.lr = 0x823F279C;
	sub_823F6D90(ctx, base);
	// 823F279C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F27A0: 41800028  blt 0x823f27c8
	if ctx.cr[0].lt {
	pc = 0x823F27C8; continue 'dispatch;
	}
	// 823F27A4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 823F27A8: 419A0020  beq cr6, 0x823f27c8
	if ctx.cr[6].eq {
	pc = 0x823F27C8; continue 'dispatch;
	}
	// 823F27AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F27B0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F27B4: 7F9CFA14  add r28, r28, r31
	ctx.r[28].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 823F27B8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823F27BC: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 823F27C0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F27C4: 4198FFC8  blt cr6, 0x823f278c
	if ctx.cr[6].lt {
	pc = 0x823F278C; continue 'dispatch;
	}
	pc = 0x823F27C8; continue 'dispatch;
            }
            0x823F27C8 => {
    //   block [0x823F27C8..0x823F27D0)
	// 823F27C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F27CC: 48142934  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F27D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F27D0 size=108
    let mut pc: u32 = 0x823F27D0;
    'dispatch: loop {
        match pc {
            0x823F27D0 => {
    //   block [0x823F27D0..0x823F2808)
	// 823F27D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F27D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F27D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F27DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F27E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F27E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F27E8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F27EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F27F0: 409A0018  bne cr6, 0x823f2808
	if !ctx.cr[6].eq {
	pc = 0x823F2808; continue 'dispatch;
	}
	// 823F27F4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F27F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F27FC: 409A000C  bne cr6, 0x823f2808
	if !ctx.cr[6].eq {
	pc = 0x823F2808; continue 'dispatch;
	}
	// 823F2800: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F2804: 4800475D  bl 0x823f6f60
	ctx.lr = 0x823F2808;
	sub_823F6F60(ctx, base);
	pc = 0x823F2808; continue 'dispatch;
            }
            0x823F2808 => {
    //   block [0x823F2808..0x823F2820)
	// 823F2808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F280C: 48001DED  bl 0x823f45f8
	ctx.lr = 0x823F2810;
	sub_823F45F8(ctx, base);
	// 823F2810: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F2814: 4080000C  bge 0x823f2820
	if !ctx.cr[0].lt {
	pc = 0x823F2820; continue 'dispatch;
	}
	// 823F2818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F281C: 4BFFFA95  bl 0x823f22b0
	ctx.lr = 0x823F2820;
	sub_823F22B0(ctx, base);
	pc = 0x823F2820; continue 'dispatch;
            }
            0x823F2820 => {
    //   block [0x823F2820..0x823F283C)
	// 823F2820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F2824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F2828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F282C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F2830: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F2834: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F2838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F2840 size=212
    let mut pc: u32 = 0x823F2840;
    'dispatch: loop {
        match pc {
            0x823F2840 => {
    //   block [0x823F2840..0x823F28C8)
	// 823F2840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2844: 4814286D  bl 0x825350b0
	ctx.lr = 0x823F2848;
	sub_82535080(ctx, base);
	// 823F2848: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F284C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823F2850: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F2854: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F2858: 60848011  ori r4, r4, 0x8011
	ctx.r[4].u64 = ctx.r[4].u64 | 32785;
	// 823F285C: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 823F2860: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823F2864: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 823F2868: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F286C: 4BFD7955  bl 0x823ca1c0
	ctx.lr = 0x823F2870;
	sub_823CA1C0(ctx, base);
	// 823F2870: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F2874: 4182007C  beq 0x823f28f0
	if ctx.cr[0].eq {
	pc = 0x823F28F0; continue 'dispatch;
	}
	// 823F2878: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F287C: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 823F2880: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 823F2884: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 823F2888: 396BD16C  addi r11, r11, -0x2e94
	ctx.r[11].s64 = ctx.r[11].s64 + -11924;
	// 823F288C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F2890: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 823F2894: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 823F2898: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 823F289C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F28A0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 823F28A4: 409A0024  bne cr6, 0x823f28c8
	if !ctx.cr[6].eq {
	pc = 0x823F28C8; continue 'dispatch;
	}
	// 823F28A8: 809C0048  lwz r4, 0x48(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F28AC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F28B0: 41820020  beq 0x823f28d0
	if ctx.cr[0].eq {
	pc = 0x823F28D0; continue 'dispatch;
	}
	// 823F28B4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F28B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F28BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F28C0: 4E800421  bctrl
	ctx.lr = 0x823F28C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F28C4: 4800000C  b 0x823f28d0
	pc = 0x823F28D0; continue 'dispatch;
            }
            0x823F28C8 => {
    //   block [0x823F28C8..0x823F28D0)
	// 823F28C8: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 823F28CC: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	pc = 0x823F28D0; continue 'dispatch;
            }
            0x823F28D0 => {
    //   block [0x823F28D0..0x823F28F0)
	// 823F28D0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F28D4: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F28D8: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823F28DC: 55631838  slwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 823F28E0: 4BFD78E1  bl 0x823ca1c0
	ctx.lr = 0x823F28E4;
	sub_823CA1C0(ctx, base);
	// 823F28E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F28E8: 907F0028  stw r3, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 823F28EC: 40820018  bne 0x823f2904
	if !ctx.cr[0].eq {
	pc = 0x823F2904; continue 'dispatch;
	}
	pc = 0x823F28F0; continue 'dispatch;
            }
            0x823F28F0 => {
    //   block [0x823F28F0..0x823F2904)
	// 823F28F0: 3F608007  lis r27, -0x7ff9
	ctx.r[27].s64 = -2147024896;
	// 823F28F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F28F8: 637B000E  ori r27, r27, 0xe
	ctx.r[27].u64 = ctx.r[27].u64 | 14;
	// 823F28FC: 4BFFFB25  bl 0x823f2420
	ctx.lr = 0x823F2900;
	sub_823F2420(ctx, base);
	// 823F2900: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823F2904; continue 'dispatch;
            }
            0x823F2904 => {
    //   block [0x823F2904..0x823F2914)
	// 823F2904: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F2908: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F290C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F2910: 481427F0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2918 size=16
    let mut pc: u32 = 0x823F2918;
    'dispatch: loop {
        match pc {
            0x823F2918 => {
    //   block [0x823F2918..0x823F2928)
	// 823F2918: 54A5063F  clrlwi. r5, r5, 0x18
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823F291C: 4082000C  bne 0x823f2928
	if !ctx.cr[0].eq {
		sub_823F2928(ctx, base);
		return;
	}
	// 823F2920: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F2924: 4BFFFF1C  b 0x823f2840
	sub_823F2840(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2928 size=4
    let mut pc: u32 = 0x823F2928;
    'dispatch: loop {
        match pc {
            0x823F2928 => {
    //   block [0x823F2928..0x823F292C)
	// 823F2928: 4BFFFF18  b 0x823f2840
	sub_823F2840(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2930 size=12
    let mut pc: u32 = 0x823F2930;
    'dispatch: loop {
        match pc {
            0x823F2930 => {
    //   block [0x823F2930..0x823F293C)
	// 823F2930: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F2934: 386B2918  addi r3, r11, 0x2918
	ctx.r[3].s64 = ctx.r[11].s64 + 10520;
	// 823F2938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2940 size=24
    let mut pc: u32 = 0x823F2940;
    'dispatch: loop {
        match pc {
            0x823F2940 => {
    //   block [0x823F2940..0x823F2950)
	// 823F2940: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F2944: 419A000C  beq cr6, 0x823f2950
	if ctx.cr[6].eq {
	pc = 0x823F2950; continue 'dispatch;
	}
	// 823F2948: 3960181C  li r11, 0x181c
	ctx.r[11].s64 = 6172;
	// 823F294C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F2950; continue 'dispatch;
            }
            0x823F2950 => {
    //   block [0x823F2950..0x823F2958)
	// 823F2950: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F2954: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2958 size=40
    let mut pc: u32 = 0x823F2958;
    'dispatch: loop {
        match pc {
            0x823F2958 => {
    //   block [0x823F2958..0x823F295C)
	// 823F2958: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x823F295C; continue 'dispatch;
            }
            0x823F295C => {
    //   block [0x823F295C..0x823F2980)
	// 823F295C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F2960: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F2964: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823F2968: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F296C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F2970: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F2974: 4082FFE8  bne 0x823f295c
	if !ctx.cr[0].eq {
	pc = 0x823F295C; continue 'dispatch;
	}
	// 823F2978: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 823F297C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2980 size=40
    let mut pc: u32 = 0x823F2980;
    'dispatch: loop {
        match pc {
            0x823F2980 => {
    //   block [0x823F2980..0x823F2984)
	// 823F2980: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x823F2984; continue 'dispatch;
            }
            0x823F2984 => {
    //   block [0x823F2984..0x823F29A8)
	// 823F2984: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F2988: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F298C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823F2990: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823F2994: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F2998: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F299C: 4082FFE8  bne 0x823f2984
	if !ctx.cr[0].eq {
	pc = 0x823F2984; continue 'dispatch;
	}
	// 823F29A0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 823F29A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F29A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F29A8 size=32
    let mut pc: u32 = 0x823F29A8;
    'dispatch: loop {
        match pc {
            0x823F29A8 => {
    //   block [0x823F29A8..0x823F29C0)
	// 823F29A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F29AC: 419A0014  beq cr6, 0x823f29c0
	if ctx.cr[6].eq {
	pc = 0x823F29C0; continue 'dispatch;
	}
	// 823F29B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F29B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F29B8: 99640000  stb r11, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 823F29BC: B1440002  sth r10, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	pc = 0x823F29C0; continue 'dispatch;
            }
            0x823F29C0 => {
    //   block [0x823F29C0..0x823F29C8)
	// 823F29C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F29C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F29C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F29C8 size=12
    let mut pc: u32 = 0x823F29C8;
    'dispatch: loop {
        match pc {
            0x823F29C8 => {
    //   block [0x823F29C8..0x823F29D4)
	// 823F29C8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823F29CC: 60634001  ori r3, r3, 0x4001
	ctx.r[3].u64 = ctx.r[3].u64 | 16385;
	// 823F29D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F29D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F29D8 size=36
    let mut pc: u32 = 0x823F29D8;
    'dispatch: loop {
        match pc {
            0x823F29D8 => {
    //   block [0x823F29D8..0x823F29F4)
	// 823F29D8: 3D608007  lis r11, -0x7ff9
	ctx.r[11].s64 = -2147024896;
	// 823F29DC: 548A063F  clrlwi. r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F29E0: 616B0057  ori r11, r11, 0x57
	ctx.r[11].u64 = ctx.r[11].u64 | 87;
	// 823F29E4: 40820010  bne 0x823f29f4
	if !ctx.cr[0].eq {
	pc = 0x823F29F4; continue 'dispatch;
	}
	// 823F29E8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F29EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F29F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x823F29F4; continue 'dispatch;
            }
            0x823F29F4 => {
    //   block [0x823F29F4..0x823F29FC)
	// 823F29F4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823F29F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2A00 size=24
    let mut pc: u32 = 0x823F2A00;
    'dispatch: loop {
        match pc {
            0x823F2A00 => {
    //   block [0x823F2A00..0x823F2A10)
	// 823F2A00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F2A04: 419A000C  beq cr6, 0x823f2a10
	if ctx.cr[6].eq {
	pc = 0x823F2A10; continue 'dispatch;
	}
	// 823F2A08: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2A0C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F2A10; continue 'dispatch;
            }
            0x823F2A10 => {
    //   block [0x823F2A10..0x823F2A18)
	// 823F2A10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F2A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F2A18 size=116
    let mut pc: u32 = 0x823F2A18;
    'dispatch: loop {
        match pc {
            0x823F2A18 => {
    //   block [0x823F2A18..0x823F2A5C)
	// 823F2A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2A1C: 481426A1  bl 0x825350bc
	ctx.lr = 0x823F2A20;
	sub_82535080(ctx, base);
	// 823F2A20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F2A24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F2A28: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823F2A2C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F2A30: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F2A34: 3880181C  li r4, 0x181c
	ctx.r[4].s64 = 6172;
	// 823F2A38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2A3C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F2A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F2A44: 4E800421  bctrl
	ctx.lr = 0x823F2A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F2A48: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F2A4C: 40820020  bne 0x823f2a6c
	if !ctx.cr[0].eq {
	pc = 0x823F2A6C; continue 'dispatch;
	}
	// 823F2A50: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 823F2A54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F2A58: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
            }
            0x823F2A5C => {
    //   block [0x823F2A5C..0x823F2A6C)
	// 823F2A5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F2A60: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F2A64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F2A68: 481426A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x823F2A6C => {
    //   block [0x823F2A6C..0x823F2A8C)
	// 823F2A6C: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823F2A70: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823F2A74: 394AD194  addi r10, r10, -0x2e6c
	ctx.r[10].s64 = ctx.r[10].s64 + -11884;
	// 823F2A78: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823F2A7C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F2A80: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2A84: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823F2A88: 4BFFFFD4  b 0x823f2a5c
	pc = 0x823F2A5C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F2A90 size=352
    let mut pc: u32 = 0x823F2A90;
    'dispatch: loop {
        match pc {
            0x823F2A90 => {
    //   block [0x823F2A90..0x823F2AEC)
	// 823F2A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2A94: 48142615  bl 0x825350a8
	ctx.lr = 0x823F2A98;
	sub_82535080(ctx, base);
	// 823F2A98: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 823F2A9C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F2AA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F2AA4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823F2AA8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823F2AAC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823F2AB0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2AB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F2AB8: 419A012C  beq cr6, 0x823f2be4
	if ctx.cr[6].eq {
	pc = 0x823F2BE4; continue 'dispatch;
	}
	// 823F2ABC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 823F2AC0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823F2AC4: 4819192D  bl 0x825843f0
	ctx.lr = 0x823F2AC8;
	sub_825843F0(ctx, base);
	// 823F2AC8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F2ACC: 41800118  blt 0x823f2be4
	if ctx.cr[0].lt {
	pc = 0x823F2BE4; continue 'dispatch;
	}
	// 823F2AD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F2AD4: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 823F2AD8: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 823F2ADC: 3BFE180C  addi r31, r30, 0x180c
	ctx.r[31].s64 = ctx.r[30].s64 + 6156;
	// 823F2AE0: 3B5E000C  addi r26, r30, 0xc
	ctx.r[26].s64 = ctx.r[30].s64 + 12;
	// 823F2AE4: C3EB72B8  lfs f31, 0x72b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823F2AE8: 233EEC4C  subfic r25, r30, -0x13b4
	ctx.xer.ca = ctx.r[30].u32 <= -5044 as u32;
	ctx.r[25].s64 = (-5044 as i64) - ctx.r[30].s64;
	pc = 0x823F2AEC; continue 'dispatch;
            }
            0x823F2AEC => {
    //   block [0x823F2AEC..0x823F2B34)
	// 823F2AEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F2AF0: 7D59FA14  add r10, r25, r31
	ctx.r[10].u64 = ctx.r[25].u64 + ctx.r[31].u64;
	// 823F2AF4: 7FAA582E  lwzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F2AF8: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2AFC: 418200C8  beq 0x823f2bc4
	if ctx.cr[0].eq {
	pc = 0x823F2BC4; continue 'dispatch;
	}
	// 823F2B00: 817D00C4  lwz r11, 0xc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F2B04: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823F2B08: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823F2B0C: 409A00B8  bne cr6, 0x823f2bc4
	if !ctx.cr[6].eq {
	pc = 0x823F2BC4; continue 'dispatch;
	}
	// 823F2B10: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2B14: C01D00B8  lfs f0, 0xb8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F2B18: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823F2B1C: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 823F2B20: 7D5B5214  add r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 823F2B24: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 823F2B28: 554A482C  slwi r10, r10, 9
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F2B2C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 823F2B30: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x823F2B34; continue 'dispatch;
            }
            0x823F2B34 => {
    //   block [0x823F2B34..0x823F2B60)
	// 823F2B34: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823F2B38: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823F2B3C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823F2B40: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 823F2B44: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823F2B48: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823F2B4C: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F2B50: 2F087FFF  cmpwi cr6, r8, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[8].s32, 32767, &mut ctx.xer);
	// 823F2B54: 4198000C  blt cr6, 0x823f2b60
	if ctx.cr[6].lt {
	pc = 0x823F2B60; continue 'dispatch;
	}
	// 823F2B58: 39007FFF  li r8, 0x7fff
	ctx.r[8].s64 = 32767;
	// 823F2B5C: 48000010  b 0x823f2b6c
	pc = 0x823F2B6C; continue 'dispatch;
            }
            0x823F2B60 => {
    //   block [0x823F2B60..0x823F2B6C)
	// 823F2B60: 2F088000  cmpwi cr6, r8, -0x8000
	ctx.cr[6].compare_i32(ctx.r[8].s32, -32768, &mut ctx.xer);
	// 823F2B64: 41990008  bgt cr6, 0x823f2b6c
	if ctx.cr[6].gt {
	pc = 0x823F2B6C; continue 'dispatch;
	}
	// 823F2B68: 3900801E  li r8, -0x7fe2
	ctx.r[8].s64 = -32738;
	pc = 0x823F2B6C; continue 'dispatch;
            }
            0x823F2B6C => {
    //   block [0x823F2B6C..0x823F2BC4)
	// 823F2B6C: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823F2B70: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F2B74: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823F2B78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F2B7C: 4082FFB8  bne 0x823f2b34
	if !ctx.cr[0].eq {
	pc = 0x823F2B34; continue 'dispatch;
	}
	// 823F2B80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2B84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F2B88: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823F2B8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F2B90: 41980038  blt cr6, 0x823f2bc8
	if ctx.cr[6].lt {
	pc = 0x823F2BC8; continue 'dispatch;
	}
	// 823F2B94: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 823F2B98: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 823F2B9C: 38C00300  li r6, 0x300
	ctx.r[6].s64 = 768;
	// 823F2BA0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823F2BA4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823F2BA8: 387D00C8  addi r3, r29, 0xc8
	ctx.r[3].s64 = ctx.r[29].s64 + 200;
	// 823F2BAC: 480057F5  bl 0x823f83a0
	ctx.lr = 0x823F2BB0;
	sub_823F83A0(ctx, base);
	// 823F2BB0: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823F2BB4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823F2BB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F2BBC: 480049FD  bl 0x823f75b8
	ctx.lr = 0x823F2BC0;
	sub_823F75B8(ctx, base);
	// 823F2BC0: 48000008  b 0x823f2bc8
	pc = 0x823F2BC8; continue 'dispatch;
            }
            0x823F2BC4 => {
    //   block [0x823F2BC4..0x823F2BC8)
	// 823F2BC4: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x823F2BC8; continue 'dispatch;
            }
            0x823F2BC8 => {
    //   block [0x823F2BC8..0x823F2BE4)
	// 823F2BC8: 3B9C0400  addi r28, r28, 0x400
	ctx.r[28].s64 = ctx.r[28].s64 + 1024;
	// 823F2BCC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F2BD0: 3B7B0003  addi r27, r27, 3
	ctx.r[27].s64 = ctx.r[27].s64 + 3;
	// 823F2BD4: 3B5A0600  addi r26, r26, 0x600
	ctx.r[26].s64 = ctx.r[26].s64 + 1536;
	// 823F2BD8: 2B1C1000  cmplwi cr6, r28, 0x1000
	ctx.cr[6].compare_u32(ctx.r[28].u32, 4096 as u32, &mut ctx.xer);
	// 823F2BDC: 4198FF10  blt cr6, 0x823f2aec
	if ctx.cr[6].lt {
	pc = 0x823F2AEC; continue 'dispatch;
	}
	// 823F2BE0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	pc = 0x823F2BE4; continue 'dispatch;
            }
            0x823F2BE4 => {
    //   block [0x823F2BE4..0x823F2BF0)
	// 823F2BE4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823F2BE8: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823F2BEC: 4814250C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F2C00 size=696
    let mut pc: u32 = 0x823F2C00;
    'dispatch: loop {
        match pc {
            0x823F2C00 => {
    //   block [0x823F2C00..0x823F2C80)
	// 823F2C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2C04: 481424AD  bl 0x825350b0
	ctx.lr = 0x823F2C08;
	sub_82535080(ctx, base);
	// 823F2C08: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F2C0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823F2C10: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 823F2C14: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F2C18: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823F2C1C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2C20: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 823F2C24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2C28: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 823F2C2C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F2C30: 4BFCE931  bl 0x823c1560
	ctx.lr = 0x823F2C34;
	sub_823C1560(ctx, base);
	// 823F2C34: 3960007F  li r11, 0x7f
	ctx.r[11].s64 = 127;
	// 823F2C38: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2C3C: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 823F2C40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2C44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 823F2C48: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 823F2C4C: 4BFCE915  bl 0x823c1560
	ctx.lr = 0x823F2C50;
	sub_823C1560(ctx, base);
	// 823F2C50: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823F2C54: 9BE10068  stb r31, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u8 ) };
	// 823F2C58: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 823F2C5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2C60: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823F2C64: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823F2C68: 4BFCE8F9  bl 0x823c1560
	ctx.lr = 0x823F2C6C;
	sub_823C1560(ctx, base);
	// 823F2C6C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823F2C70: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 823F2C74: 396100A1  addi r11, r1, 0xa1
	ctx.r[11].s64 = ctx.r[1].s64 + 161;
	// 823F2C78: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 823F2C7C: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823F2C80; continue 'dispatch;
            }
            0x823F2C80 => {
    //   block [0x823F2C80..0x823F2D64)
	// 823F2C80: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 823F2C84: D00B0003  stfs f0, 3(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), tmp.u32 ) };
	// 823F2C88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F2C8C: 9B6B0000  stb r27, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 823F2C90: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 823F2C94: 992BFFFF  stb r9, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[9].u8 ) };
	// 823F2C98: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823F2C9C: 4198FFE4  blt cr6, 0x823f2c80
	if ctx.cr[6].lt {
	pc = 0x823F2C80; continue 'dispatch;
	}
	// 823F2CA0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2CA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2CA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823F2CAC: 4BFCE8B5  bl 0x823c1560
	ctx.lr = 0x823F2CB0;
	sub_823C1560(ctx, base);
	// 823F2CB0: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 823F2CB4: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 823F2CB8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2CBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F2CC4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F2CC8: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 823F2CCC: 4BFCE895  bl 0x823c1560
	ctx.lr = 0x823F2CD0;
	sub_823C1560(ctx, base);
	// 823F2CD0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F2CD4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 823F2CD8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2CDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2CE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F2CE4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823F2CE8: 4BFCE879  bl 0x823c1560
	ctx.lr = 0x823F2CEC;
	sub_823C1560(ctx, base);
	// 823F2CEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823F2CF0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823F2CF4: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 823F2CF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2CFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823F2D00: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F2D04: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 823F2D08: 4BFCE859  bl 0x823c1560
	ctx.lr = 0x823F2D0C;
	sub_823C1560(ctx, base);
	// 823F2D0C: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 823F2D10: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F2D14: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 823F2D18: 615ABB80  ori r26, r10, 0xbb80
	ctx.r[26].u64 = ctx.r[10].u64 | 48000;
	// 823F2D1C: 9BA10081  stb r29, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[29].u8 ) };
	// 823F2D20: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 823F2D24: 9BC10088  stb r30, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u8 ) };
	// 823F2D28: 9BA10089  stb r29, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[29].u8 ) };
	// 823F2D2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2D30: 9B61008A  stb r27, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[27].u8 ) };
	// 823F2D34: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 823F2D38: 93410084  stw r26, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 823F2D3C: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 823F2D40: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823F2D44: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 823F2D48: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 823F2D4C: 41820044  beq 0x823f2d90
	if ctx.cr[0].eq {
	pc = 0x823F2D90; continue 'dispatch;
	}
	// 823F2D50: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2D54: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 823F2D58: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F2D5C: 4182002C  beq 0x823f2d88
	if ctx.cr[0].eq {
	pc = 0x823F2D88; continue 'dispatch;
	}
	// 823F2D60: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x823F2D64; continue 'dispatch;
            }
            0x823F2D64 => {
    //   block [0x823F2D64..0x823F2D88)
	// 823F2D64: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F2D68: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823F2D6C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823F2D70: 7D08502E  lwzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F2D74: 7D0A392E  stwx r8, r10, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 823F2D78: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F2D7C: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2D80: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F2D84: 4198FFE0  blt cr6, 0x823f2d64
	if ctx.cr[6].lt {
	pc = 0x823F2D64; continue 'dispatch;
	}
	pc = 0x823F2D88; continue 'dispatch;
            }
            0x823F2D88 => {
    //   block [0x823F2D88..0x823F2D90)
	// 823F2D88: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2D8C: 48000008  b 0x823f2d94
	pc = 0x823F2D94; continue 'dispatch;
            }
            0x823F2D90 => {
    //   block [0x823F2D90..0x823F2D94)
	// 823F2D90: 89610068  lbz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	pc = 0x823F2D94; continue 'dispatch;
            }
            0x823F2D94 => {
    //   block [0x823F2D94..0x823F2DE8)
	// 823F2D94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F2D98: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823F2D9C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F2DA0: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 823F2DA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F2DA8: 3B7C0038  addi r27, r28, 0x38
	ctx.r[27].s64 = ctx.r[28].s64 + 56;
	// 823F2DAC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823F2DB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823F2DB4: 7D28512E  stwx r9, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 823F2DB8: 99610068  stb r11, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 823F2DBC: 4819156D  bl 0x82584328
	ctx.lr = 0x823F2DC0;
	sub_82584328(ctx, base);
	// 823F2DC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F2DC4: 418000EC  blt 0x823f2eb0
	if ctx.cr[0].lt {
	pc = 0x823F2EB0; continue 'dispatch;
	}
	// 823F2DC8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 823F2DCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2DD0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823F2DD4: 4BFCE78D  bl 0x823c1560
	ctx.lr = 0x823F2DD8;
	sub_823C1560(ctx, base);
	// 823F2DD8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823F2DDC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 823F2DE0: 396100A1  addi r11, r1, 0xa1
	ctx.r[11].s64 = ctx.r[1].s64 + 161;
	// 823F2DE4: C0091850  lfs f0, 0x1850(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823F2DE8; continue 'dispatch;
            }
            0x823F2DE8 => {
    //   block [0x823F2DE8..0x823F2EB0)
	// 823F2DE8: 5549063E  clrlwi r9, r10, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823F2DEC: D00B0003  stfs f0, 3(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), tmp.u32 ) };
	// 823F2DF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F2DF4: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 823F2DF8: 992BFFFF  stb r9, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[9].u8 ) };
	// 823F2DFC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 823F2E00: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823F2E04: 4198FFE4  blt cr6, 0x823f2de8
	if ctx.cr[6].lt {
	pc = 0x823F2DE8; continue 'dispatch;
	}
	// 823F2E08: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2E0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2E10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823F2E14: 4BFCE74D  bl 0x823c1560
	ctx.lr = 0x823F2E18;
	sub_823C1560(ctx, base);
	// 823F2E18: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 823F2E1C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2E20: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 823F2E24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F2E2C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F2E30: 4BFCE731  bl 0x823c1560
	ctx.lr = 0x823F2E34;
	sub_823C1560(ctx, base);
	// 823F2E34: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2E38: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F2E3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2E40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F2E44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 823F2E48: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F2E4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823F2E50: 4BFCE711  bl 0x823c1560
	ctx.lr = 0x823F2E54;
	sub_823C1560(ctx, base);
	// 823F2E54: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823F2E58: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 823F2E5C: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 823F2E60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2E64: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 823F2E68: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F2E6C: 4BFCE6F5  bl 0x823c1560
	ctx.lr = 0x823F2E70;
	sub_823C1560(ctx, base);
	// 823F2E70: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F2E74: 9BE100C0  stb r31, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u8 ) };
	// 823F2E78: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823F2E7C: 9BA100C4  stb r29, 0xc4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[29].u8 ) };
	// 823F2E80: 396B2BF0  addi r11, r11, 0x2bf0
	ctx.r[11].s64 = ctx.r[11].s64 + 11248;
	// 823F2E84: 934100C8  stw r26, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 823F2E88: 389C0040  addi r4, r28, 0x40
	ctx.r[4].s64 = ctx.r[28].s64 + 64;
	// 823F2E8C: 9BC100F9  stb r30, 0xf9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(249 as u32), ctx.r[30].u8 ) };
	// 823F2E90: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 823F2E94: 9BA100FA  stb r29, 0xfa(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(250 as u32), ctx.r[29].u8 ) };
	// 823F2E98: 9BC100FB  stb r30, 0xfb(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(251 as u32), ctx.r[30].u8 ) };
	// 823F2E9C: 9BC10100  stb r30, 0x100(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u8 ) };
	// 823F2EA0: 91410108  stw r10, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[10].u32 ) };
	// 823F2EA4: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 823F2EA8: 93810118  stw r28, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[28].u32 ) };
	// 823F2EAC: 4819141D  bl 0x825842c8
	ctx.lr = 0x823F2EB0;
	sub_825842C8(ctx, base);
	pc = 0x823F2EB0; continue 'dispatch;
            }
            0x823F2EB0 => {
    //   block [0x823F2EB0..0x823F2EB8)
	// 823F2EB0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 823F2EB4: 4814224C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F2EB8 size=396
    let mut pc: u32 = 0x823F2EB8;
    'dispatch: loop {
        match pc {
            0x823F2EB8 => {
    //   block [0x823F2EB8..0x823F2EF8)
	// 823F2EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F2EBC: 481421F9  bl 0x825350b4
	ctx.lr = 0x823F2EC0;
	sub_82535080(ctx, base);
	// 823F2EC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823F2EC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F2EC8: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 823F2ECC: 409A0074  bne cr6, 0x823f2f40
	if !ctx.cr[6].eq {
	pc = 0x823F2F40; continue 'dispatch;
	}
	// 823F2ED0: 39450158  addi r10, r5, 0x158
	ctx.r[10].s64 = ctx.r[5].s64 + 344;
	// 823F2ED4: 83EB0528  lwz r31, 0x528(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1320 as u32) ) } as u64;
	// 823F2ED8: 38EB0530  addi r7, r11, 0x530
	ctx.r[7].s64 = ctx.r[11].s64 + 1328;
	// 823F2EDC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F2EE0: 3BAB0560  addi r29, r11, 0x560
	ctx.r[29].s64 = ctx.r[11].s64 + 1376;
	// 823F2EE4: 390B0458  addi r8, r11, 0x458
	ctx.r[8].s64 = ctx.r[11].s64 + 1112;
	// 823F2EE8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823F2EEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2EF0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 823F2EF4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	pc = 0x823F2EF8; continue 'dispatch;
            }
            0x823F2EF8 => {
    //   block [0x823F2EF8..0x823F2F14)
	// 823F2EF8: 83C80000  lwz r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2EFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F2F00: 419A0014  beq cr6, 0x823f2f14
	if ctx.cr[6].eq {
	pc = 0x823F2F14; continue 'dispatch;
	}
	// 823F2F04: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F2F08: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F2F0C: 419A0008  beq cr6, 0x823f2f14
	if ctx.cr[6].eq {
	pc = 0x823F2F14; continue 'dispatch;
	}
	// 823F2F10: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	pc = 0x823F2F14; continue 'dispatch;
            }
            0x823F2F14 => {
    //   block [0x823F2F14..0x823F2F40)
	// 823F2F14: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F2F18: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823F2F1C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 823F2F20: 4082FFD8  bne 0x823f2ef8
	if !ctx.cr[0].eq {
	pc = 0x823F2EF8; continue 'dispatch;
	}
	// 823F2F24: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F2F28: 419A0028  beq cr6, 0x823f2f50
	if ctx.cr[6].eq {
	pc = 0x823F2F50; continue 'dispatch;
	}
	// 823F2F2C: 7D7F2396  divwu r11, r31, r4
	ctx.r[11].u32 = ctx.r[31].u32 / ctx.r[4].u32;
	// 823F2F30: 0CC40000  twi 6, r4, 0
	// 823F2F34: 7D6B21D6  mullw r11, r11, r4
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F2F38: 7FEBF850  subf r31, r11, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 823F2F3C: 48000014  b 0x823f2f50
	pc = 0x823F2F50; continue 'dispatch;
            }
            0x823F2F40 => {
    //   block [0x823F2F40..0x823F2F50)
	// 823F2F40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823F2F44: 38EB0590  addi r7, r11, 0x590
	ctx.r[7].s64 = ctx.r[11].s64 + 1424;
	// 823F2F48: 3BAB0728  addi r29, r11, 0x728
	ctx.r[29].s64 = ctx.r[11].s64 + 1832;
	// 823F2F4C: 39400022  li r10, 0x22
	ctx.r[10].s64 = 34;
	pc = 0x823F2F50; continue 'dispatch;
            }
            0x823F2F50 => {
    //   block [0x823F2F50..0x823F2F68)
	// 823F2F50: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F2F54: 7F8B3A14  add r28, r11, r7
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823F2F58: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 823F2F5C: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823F2F60: 40980020  bge cr6, 0x823f2f80
	if !ctx.cr[6].lt {
	pc = 0x823F2F80; continue 'dispatch;
	}
	// 823F2F64: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x823F2F68; continue 'dispatch;
            }
            0x823F2F68 => {
    //   block [0x823F2F68..0x823F2F80)
	// 823F2F68: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F2F6C: 7D0800D0  neg r8, r8
	ctx.r[8].s64 = -ctx.r[8].s64;
	// 823F2F70: 7D09592E  stwx r8, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 823F2F74: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823F2F78: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823F2F7C: 4198FFEC  blt cr6, 0x823f2f68
	if ctx.cr[6].lt {
	pc = 0x823F2F68; continue 'dispatch;
	}
	pc = 0x823F2F80; continue 'dispatch;
            }
            0x823F2F80 => {
    //   block [0x823F2F80..0x823F2F90)
	// 823F2F80: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F2F84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F2F88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F2F8C: 419A0078  beq cr6, 0x823f3004
	if ctx.cr[6].eq {
	pc = 0x823F3004; continue 'dispatch;
	}
	pc = 0x823F2F90; continue 'dispatch;
            }
            0x823F2F90 => {
    //   block [0x823F2F90..0x823F2FE8)
	// 823F2F90: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823F2F94: 419A0060  beq cr6, 0x823f2ff4
	if ctx.cr[6].eq {
	pc = 0x823F2FF4; continue 'dispatch;
	}
	// 823F2F98: 7D64FA14  add r11, r4, r31
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[31].u64;
	// 823F2F9C: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F2FA0: 7D2B5396  divwu r9, r11, r10
	ctx.r[9].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 823F2FA4: 0CCA0000  twi 6, r10, 0
	// 823F2FA8: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823F2FAC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823F2FB0: 1D2B000C  mulli r9, r11, 0xc
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823F2FB4: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 3 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F2FB8: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 823F2FBC: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 823F2FC0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F2FC4: 7F6BE82E  lwzx r27, r11, r29
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 823F2FC8: 7D68482E  lwzx r11, r8, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823F2FCC: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 823F2FD0: 40980018  bge cr6, 0x823f2fe8
	if !ctx.cr[6].lt {
	pc = 0x823F2FE8; continue 'dispatch;
	}
	// 823F2FD4: 356B0001  addic. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].u32 > (!(1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F2FD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F2FDC: 7D68492E  stwx r11, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 823F2FE0: 40810008  ble 0x823f2fe8
	if !ctx.cr[0].gt {
	pc = 0x823F2FE8; continue 'dispatch;
	}
	// 823F2FE4: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	pc = 0x823F2FE8; continue 'dispatch;
            }
            0x823F2FE8 => {
    //   block [0x823F2FE8..0x823F2FF4)
	// 823F2FE8: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 823F2FEC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F2FF0: 4198FFA0  blt cr6, 0x823f2f90
	if ctx.cr[6].lt {
	pc = 0x823F2F90; continue 'dispatch;
	}
	pc = 0x823F2FF4; continue 'dispatch;
            }
            0x823F2FF4 => {
    //   block [0x823F2FF4..0x823F3004)
	// 823F2FF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F2FF8: 419A000C  beq cr6, 0x823f3004
	if ctx.cr[6].eq {
	pc = 0x823F3004; continue 'dispatch;
	}
	// 823F2FFC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823F3000: 409AFF80  bne cr6, 0x823f2f80
	if !ctx.cr[6].eq {
	pc = 0x823F2F80; continue 'dispatch;
	}
	pc = 0x823F3004; continue 'dispatch;
            }
            0x823F3004 => {
    //   block [0x823F3004..0x823F3014)
	// 823F3004: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 823F3008: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823F300C: 40980034  bge cr6, 0x823f3040
	if !ctx.cr[6].lt {
	pc = 0x823F3040; continue 'dispatch;
	}
	// 823F3010: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x823F3014; continue 'dispatch;
            }
            0x823F3014 => {
    //   block [0x823F3014..0x823F302C)
	// 823F3014: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F3018: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823F301C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F3020: 4098000C  bge cr6, 0x823f302c
	if !ctx.cr[6].lt {
	pc = 0x823F302C; continue 'dispatch;
	}
	// 823F3024: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F3028: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x823F302C; continue 'dispatch;
            }
            0x823F302C => {
    //   block [0x823F302C..0x823F3040)
	// 823F302C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3030: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823F3034: 7C635214  add r3, r3, r10
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 823F3038: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823F303C: 4198FFD8  blt cr6, 0x823f3014
	if ctx.cr[6].lt {
	pc = 0x823F3014; continue 'dispatch;
	}
	pc = 0x823F3040; continue 'dispatch;
            }
            0x823F3040 => {
    //   block [0x823F3040..0x823F3044)
	// 823F3040: 481420C4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F3048 size=32
    let mut pc: u32 = 0x823F3048;
    'dispatch: loop {
        match pc {
            0x823F3048 => {
    //   block [0x823F3048..0x823F3068)
	// 823F3048: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F304C: 396B011A  addi r11, r11, 0x11a
	ctx.r[11].s64 = ctx.r[11].s64 + 282;
	// 823F3050: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F3054: 7C8B192E  stwx r4, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[4].u32) };
	// 823F3058: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F305C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F3060: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823F3064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3068 size=164
    let mut pc: u32 = 0x823F3068;
    'dispatch: loop {
        match pc {
            0x823F3068 => {
    //   block [0x823F3068..0x823F3090)
	// 823F3068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F306C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F3070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F3074: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F307C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F3080: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3084: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3088: 41820070  beq 0x823f30f8
	if ctx.cr[0].eq {
	pc = 0x823F30F8; continue 'dispatch;
	}
	// 823F308C: 393F0468  addi r9, r31, 0x468
	ctx.r[9].s64 = ctx.r[31].s64 + 1128;
	pc = 0x823F3090; continue 'dispatch;
            }
            0x823F3090 => {
    //   block [0x823F3090..0x823F30B4)
	// 823F3090: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3094: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823F3098: 419A001C  beq cr6, 0x823f30b4
	if ctx.cr[6].eq {
	pc = 0x823F30B4; continue 'dispatch;
	}
	// 823F309C: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F30A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F30A4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823F30A8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F30AC: 4198FFE4  blt cr6, 0x823f3090
	if ctx.cr[6].lt {
	pc = 0x823F3090; continue 'dispatch;
	}
	// 823F30B0: 48000048  b 0x823f30f8
	pc = 0x823F30F8; continue 'dispatch;
            }
            0x823F30B4 => {
    //   block [0x823F30B4..0x823F30F8)
	// 823F30B4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823F30B8: 392B011B  addi r9, r11, 0x11b
	ctx.r[9].s64 = ctx.r[11].s64 + 283;
	// 823F30BC: 396B011A  addi r11, r11, 0x11a
	ctx.r[11].s64 = ctx.r[11].s64 + 282;
	// 823F30C0: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 823F30C4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F30C8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F30CC: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823F30D0: 7C8AFA14  add r4, r10, r31
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823F30D4: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823F30D8: 48142299  bl 0x82535370
	ctx.lr = 0x823F30DC;
	sub_82535370(ctx, base);
	// 823F30DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F30E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F30E4: 394B011A  addi r10, r11, 0x11a
	ctx.r[10].s64 = ctx.r[11].s64 + 282;
	// 823F30E8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F30EC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823F30F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F30F4: 7D6AF92E  stwx r11, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	pc = 0x823F30F8; continue 'dispatch;
            }
            0x823F30F8 => {
    //   block [0x823F30F8..0x823F310C)
	// 823F30F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F30FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F3100: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F3104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F3108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3110 size=132
    let mut pc: u32 = 0x823F3110;
    'dispatch: loop {
        match pc {
            0x823F3110 => {
    //   block [0x823F3110..0x823F3144)
	// 823F3110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F3118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F311C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3120: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823F3124: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 823F3128: 4198004C  blt cr6, 0x823f3174
	if ctx.cr[6].lt {
	pc = 0x823F3174; continue 'dispatch;
	}
	// 823F312C: 419A0024  beq cr6, 0x823f3150
	if ctx.cr[6].eq {
	pc = 0x823F3150; continue 'dispatch;
	}
	// 823F3130: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 823F3134: 41980010  blt cr6, 0x823f3144
	if ctx.cr[6].lt {
	pc = 0x823F3144; continue 'dispatch;
	}
	// 823F3138: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F313C: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F3140: 4800003C  b 0x823f317c
	pc = 0x823F317C; continue 'dispatch;
            }
            0x823F3144 => {
    //   block [0x823F3144..0x823F3150)
	// 823F3144: 386304F8  addi r3, r3, 0x4f8
	ctx.r[3].s64 = ctx.r[3].s64 + 1272;
	// 823F3148: 4831A125  bl 0x8270d26c
	ctx.lr = 0x823F314C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F314C: 48000030  b 0x823f317c
	pc = 0x823F317C; continue 'dispatch;
            }
            0x823F3150 => {
    //   block [0x823F3150..0x823F3168)
	// 823F3150: 386304F8  addi r3, r3, 0x4f8
	ctx.r[3].s64 = ctx.r[3].s64 + 1272;
	// 823F3154: 4831A129  bl 0x8270d27c
	ctx.lr = 0x823F3158;
	// extern call 0x8270D27C  crate::xboxkrnl::RtlTryEnterCriticalSection
	crate::xboxkrnl::RtlTryEnterCriticalSection(ctx, base);
	// 823F3158: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 823F315C: 409A000C  bne cr6, 0x823f3168
	if !ctx.cr[6].eq {
	pc = 0x823F3168; continue 'dispatch;
	}
	// 823F3160: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823F3164: 48000018  b 0x823f317c
	pc = 0x823F317C; continue 'dispatch;
            }
            0x823F3168 => {
    //   block [0x823F3168..0x823F3174)
	// 823F3168: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 823F316C: 63FF4004  ori r31, r31, 0x4004
	ctx.r[31].u64 = ctx.r[31].u64 | 16388;
	// 823F3170: 4800000C  b 0x823f317c
	pc = 0x823F317C; continue 'dispatch;
            }
            0x823F3174 => {
    //   block [0x823F3174..0x823F317C)
	// 823F3174: 386304F8  addi r3, r3, 0x4f8
	ctx.r[3].s64 = ctx.r[3].s64 + 1272;
	// 823F3178: 4831A0E5  bl 0x8270d25c
	ctx.lr = 0x823F317C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	pc = 0x823F317C; continue 'dispatch;
            }
            0x823F317C => {
    //   block [0x823F317C..0x823F3194)
	// 823F317C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3180: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F3184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F3188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F318C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F3190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3198 size=108
    let mut pc: u32 = 0x823F3198;
    'dispatch: loop {
        match pc {
            0x823F3198 => {
    //   block [0x823F3198..0x823F31E0)
	// 823F3198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F319C: 48141F19  bl 0x825350b4
	ctx.lr = 0x823F31A0;
	sub_82535080(ctx, base);
	// 823F31A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F31A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F31A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F31AC: 3B7F04F8  addi r27, r31, 0x4f8
	ctx.r[27].s64 = ctx.r[31].s64 + 1272;
	// 823F31B0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F31B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F31B8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F31BC: 4831A0A1  bl 0x8270d25c
	ctx.lr = 0x823F31C0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F31C0: 397E0116  addi r11, r30, 0x116
	ctx.r[11].s64 = ctx.r[30].s64 + 278;
	// 823F31C4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F31C8: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F31CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F31D0: 40820010  bne 0x823f31e0
	if !ctx.cr[0].eq {
	pc = 0x823F31E0; continue 'dispatch;
	}
	// 823F31D4: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F31D8: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F31DC: 48000014  b 0x823f31f0
	pc = 0x823F31F0; continue 'dispatch;
            }
            0x823F31E0 => {
    //   block [0x823F31E0..0x823F31F0)
	// 823F31E0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F31E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F31E8: 48004781  bl 0x823f7968
	ctx.lr = 0x823F31EC;
	sub_823F7968(ctx, base);
	// 823F31EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F31F0; continue 'dispatch;
            }
            0x823F31F0 => {
    //   block [0x823F31F0..0x823F3204)
	// 823F31F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F31F4: 4831A079  bl 0x8270d26c
	ctx.lr = 0x823F31F8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F31F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F31FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3200: 48141F04  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3208 size=108
    let mut pc: u32 = 0x823F3208;
    'dispatch: loop {
        match pc {
            0x823F3208 => {
    //   block [0x823F3208..0x823F3250)
	// 823F3208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F320C: 48141EA9  bl 0x825350b4
	ctx.lr = 0x823F3210;
	sub_82535080(ctx, base);
	// 823F3210: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3218: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F321C: 3B7F04F8  addi r27, r31, 0x4f8
	ctx.r[27].s64 = ctx.r[31].s64 + 1272;
	// 823F3220: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F3224: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F3228: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F322C: 4831A031  bl 0x8270d25c
	ctx.lr = 0x823F3230;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3230: 397E0116  addi r11, r30, 0x116
	ctx.r[11].s64 = ctx.r[30].s64 + 278;
	// 823F3234: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F3238: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F323C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3240: 40820010  bne 0x823f3250
	if !ctx.cr[0].eq {
	pc = 0x823F3250; continue 'dispatch;
	}
	// 823F3244: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F3248: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F324C: 48000014  b 0x823f3260
	pc = 0x823F3260; continue 'dispatch;
            }
            0x823F3250 => {
    //   block [0x823F3250..0x823F3260)
	// 823F3250: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F3254: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F3258: 48004789  bl 0x823f79e0
	ctx.lr = 0x823F325C;
	sub_823F79E0(ctx, base);
	// 823F325C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F3260; continue 'dispatch;
            }
            0x823F3260 => {
    //   block [0x823F3260..0x823F3274)
	// 823F3260: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F3264: 4831A009  bl 0x8270d26c
	ctx.lr = 0x823F3268;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F326C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3270: 48141E94  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F32A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F32A0 size=184
    let mut pc: u32 = 0x823F32A0;
    'dispatch: loop {
        match pc {
            0x823F32A0 => {
    //   block [0x823F32A0..0x823F32D4)
	// 823F32A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F32A4: 48141E19  bl 0x825350bc
	ctx.lr = 0x823F32A8;
	sub_82535080(ctx, base);
	// 823F32A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F32AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F32B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F32B4: 3BBF04F8  addi r29, r31, 0x4f8
	ctx.r[29].s64 = ctx.r[31].s64 + 1272;
	// 823F32B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F32BC: 48319FA1  bl 0x8270d25c
	ctx.lr = 0x823F32C0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F32C0: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F32C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F32C8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F32CC: 41820028  beq 0x823f32f4
	if ctx.cr[0].eq {
	pc = 0x823F32F4; continue 'dispatch;
	}
	// 823F32D0: 395F0448  addi r10, r31, 0x448
	ctx.r[10].s64 = ctx.r[31].s64 + 1096;
	pc = 0x823F32D4; continue 'dispatch;
            }
            0x823F32D4 => {
    //   block [0x823F32D4..0x823F32F4)
	// 823F32D4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F32D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F32DC: 409A0018  bne cr6, 0x823f32f4
	if !ctx.cr[6].eq {
	pc = 0x823F32F4; continue 'dispatch;
	}
	// 823F32E0: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F32E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F32E8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F32EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F32F0: 4198FFE4  blt cr6, 0x823f32d4
	if ctx.cr[6].lt {
	pc = 0x823F32D4; continue 'dispatch;
	}
	pc = 0x823F32F4; continue 'dispatch;
            }
            0x823F32F4 => {
    //   block [0x823F32F4..0x823F3308)
	// 823F32F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F32F8: 409A0010  bne cr6, 0x823f3308
	if !ctx.cr[6].eq {
	pc = 0x823F3308; continue 'dispatch;
	}
	// 823F32FC: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	// 823F3300: 63DE4005  ori r30, r30, 0x4005
	ctx.r[30].u64 = ctx.r[30].u64 | 16389;
	// 823F3304: 48000040  b 0x823f3344
	pc = 0x823F3344; continue 'dispatch;
            }
            0x823F3308 => {
    //   block [0x823F3308..0x823F3344)
	// 823F3308: 396B0112  addi r11, r11, 0x112
	ctx.r[11].s64 = ctx.r[11].s64 + 274;
	// 823F330C: 393E0116  addi r9, r30, 0x116
	ctx.r[9].s64 = ctx.r[30].s64 + 278;
	// 823F3310: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F3314: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F3318: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F331C: 7D2AF82E  lwzx r9, r10, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F3320: 7D2BF92E  stwx r9, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	// 823F3324: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F3328: 7D2AF92E  stwx r9, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	// 823F332C: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F3330: 48004C39  bl 0x823f7f68
	ctx.lr = 0x823F3334;
	sub_823F7F68(ctx, base);
	// 823F3334: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F3338: 4180000C  blt 0x823f3344
	if ctx.cr[0].lt {
	pc = 0x823F3344; continue 'dispatch;
	}
	// 823F333C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F3340: 917F0524  stw r11, 0x524(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1316 as u32), ctx.r[11].u32 ) };
	pc = 0x823F3344; continue 'dispatch;
            }
            0x823F3344 => {
    //   block [0x823F3344..0x823F3358)
	// 823F3344: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3348: 48319F25  bl 0x8270d26c
	ctx.lr = 0x823F334C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F334C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F3350: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F3354: 48141DB8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3358 size=136
    let mut pc: u32 = 0x823F3358;
    'dispatch: loop {
        match pc {
            0x823F3358 => {
    //   block [0x823F3358..0x823F339C)
	// 823F3358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F335C: 48141D61  bl 0x825350bc
	ctx.lr = 0x823F3360;
	sub_82535080(ctx, base);
	// 823F3360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3368: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F336C: 3BBF04F8  addi r29, r31, 0x4f8
	ctx.r[29].s64 = ctx.r[31].s64 + 1272;
	// 823F3370: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3374: 48319EE9  bl 0x8270d25c
	ctx.lr = 0x823F3378;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3378: 397E0116  addi r11, r30, 0x116
	ctx.r[11].s64 = ctx.r[30].s64 + 278;
	// 823F337C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F3380: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F3384: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F3388: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 823F338C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F3390: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3394: 41820034  beq 0x823f33c8
	if ctx.cr[0].eq {
	pc = 0x823F33C8; continue 'dispatch;
	}
	// 823F3398: 393F0448  addi r9, r31, 0x448
	ctx.r[9].s64 = ctx.r[31].s64 + 1096;
	pc = 0x823F339C; continue 'dispatch;
            }
            0x823F339C => {
    //   block [0x823F339C..0x823F33BC)
	// 823F339C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F33A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F33A4: 419A0018  beq cr6, 0x823f33bc
	if ctx.cr[6].eq {
	pc = 0x823F33BC; continue 'dispatch;
	}
	// 823F33A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F33AC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823F33B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F33B4: 4198FFE8  blt cr6, 0x823f339c
	if ctx.cr[6].lt {
	pc = 0x823F339C; continue 'dispatch;
	}
	// 823F33B8: 48000010  b 0x823f33c8
	pc = 0x823F33C8; continue 'dispatch;
            }
            0x823F33BC => {
    //   block [0x823F33BC..0x823F33C8)
	// 823F33BC: 396A0112  addi r11, r10, 0x112
	ctx.r[11].s64 = ctx.r[10].s64 + 274;
	// 823F33C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F33C4: 7C6BF92E  stwx r3, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[3].u32) };
	pc = 0x823F33C8; continue 'dispatch;
            }
            0x823F33C8 => {
    //   block [0x823F33C8..0x823F33E0)
	// 823F33C8: 48004489  bl 0x823f7850
	ctx.lr = 0x823F33CC;
	sub_823F7850(ctx, base);
	// 823F33CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F33D0: 48319E9D  bl 0x8270d26c
	ctx.lr = 0x823F33D4;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F33D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F33D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F33DC: 48141D30  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F33E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F33E0 size=84
    let mut pc: u32 = 0x823F33E0;
    'dispatch: loop {
        match pc {
            0x823F33E0 => {
    //   block [0x823F33E0..0x823F3420)
	// 823F33E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F33E4: 48141CD5  bl 0x825350b8
	ctx.lr = 0x823F33E8;
	sub_82535080(ctx, base);
	// 823F33E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F33EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F33F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F33F4: 3BBF04F8  addi r29, r31, 0x4f8
	ctx.r[29].s64 = ctx.r[31].s64 + 1272;
	// 823F33F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F33FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3400: 48319E5D  bl 0x8270d25c
	ctx.lr = 0x823F3404;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3404: 397E0116  addi r11, r30, 0x116
	ctx.r[11].s64 = ctx.r[30].s64 + 278;
	// 823F3408: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F340C: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F3410: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3414: 4182000C  beq 0x823f3420
	if ctx.cr[0].eq {
	pc = 0x823F3420; continue 'dispatch;
	}
	// 823F3418: 48003DB9  bl 0x823f71d0
	ctx.lr = 0x823F341C;
	sub_823F71D0(ctx, base);
	// 823F341C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x823F3420; continue 'dispatch;
            }
            0x823F3420 => {
    //   block [0x823F3420..0x823F3434)
	// 823F3420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3424: 48319E49  bl 0x8270d26c
	ctx.lr = 0x823F3428;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3428: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F342C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3430: 48141CD8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3470 size=124
    let mut pc: u32 = 0x823F3470;
    'dispatch: loop {
        match pc {
            0x823F3470 => {
    //   block [0x823F3470..0x823F34BC)
	// 823F3470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3474: 48141C3D  bl 0x825350b0
	ctx.lr = 0x823F3478;
	sub_82535080(ctx, base);
	// 823F3478: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F347C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3480: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F3484: 3B5F04F8  addi r26, r31, 0x4f8
	ctx.r[26].s64 = ctx.r[31].s64 + 1272;
	// 823F3488: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F348C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F3490: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F3494: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823F3498: 48319DC5  bl 0x8270d25c
	ctx.lr = 0x823F349C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F349C: 397E0116  addi r11, r30, 0x116
	ctx.r[11].s64 = ctx.r[30].s64 + 278;
	// 823F34A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F34A4: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F34A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F34AC: 40820010  bne 0x823f34bc
	if !ctx.cr[0].eq {
	pc = 0x823F34BC; continue 'dispatch;
	}
	// 823F34B0: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F34B4: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F34B8: 48000020  b 0x823f34d8
	pc = 0x823F34D8; continue 'dispatch;
            }
            0x823F34BC => {
    //   block [0x823F34BC..0x823F34D8)
	// 823F34BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F34C0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823F34C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823F34C8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823F34CC: 808B72B4  lwz r4, 0x72b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29364 as u32) ) } as u64;
	// 823F34D0: 48004899  bl 0x823f7d68
	ctx.lr = 0x823F34D4;
	sub_823F7D68(ctx, base);
	// 823F34D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F34D8; continue 'dispatch;
            }
            0x823F34D8 => {
    //   block [0x823F34D8..0x823F34EC)
	// 823F34D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F34DC: 48319D91  bl 0x8270d26c
	ctx.lr = 0x823F34E0;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F34E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F34E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F34E8: 48141C18  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F34F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F34F0 size=76
    let mut pc: u32 = 0x823F34F0;
    'dispatch: loop {
        match pc {
            0x823F34F0 => {
    //   block [0x823F34F0..0x823F3504)
	// 823F34F0: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F34F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F34F8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F34FC: 41820028  beq 0x823f3524
	if ctx.cr[0].eq {
	pc = 0x823F3524; continue 'dispatch;
	}
	// 823F3500: 39430468  addi r10, r3, 0x468
	ctx.r[10].s64 = ctx.r[3].s64 + 1128;
	pc = 0x823F3504; continue 'dispatch;
            }
            0x823F3504 => {
    //   block [0x823F3504..0x823F3524)
	// 823F3504: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3508: E9080000  ld r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 823F350C: 7F244040  cmpld cr6, r4, r8
	ctx.cr[6].compare_u64(ctx.r[4].u64, ctx.r[8].u64, &mut ctx.xer);
	// 823F3510: 419A0014  beq cr6, 0x823f3524
	if ctx.cr[6].eq {
	pc = 0x823F3524; continue 'dispatch;
	}
	// 823F3514: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F3518: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F351C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F3520: 4198FFE4  blt cr6, 0x823f3504
	if ctx.cr[6].lt {
	pc = 0x823F3504; continue 'dispatch;
	}
	pc = 0x823F3524; continue 'dispatch;
            }
            0x823F3524 => {
    //   block [0x823F3524..0x823F353C)
	// 823F3524: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F3528: 40980014  bge cr6, 0x823f353c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x823F353C);
		return;
	}
	// 823F352C: 396B011A  addi r11, r11, 0x11a
	ctx.r[11].s64 = ctx.r[11].s64 + 282;
	// 823F3530: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F3534: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823F3538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3548 size=784
    let mut pc: u32 = 0x823F3548;
    'dispatch: loop {
        match pc {
            0x823F3548 => {
    //   block [0x823F3548..0x823F357C)
	// 823F3548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F354C: 48141B55  bl 0x825350a0
	ctx.lr = 0x823F3550;
	sub_82535080(ctx, base);
	// 823F3550: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3558: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 823F355C: 3B1F0560  addi r24, r31, 0x560
	ctx.r[24].s64 = ctx.r[31].s64 + 1376;
	// 823F3560: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3564: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823F3568: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 823F356C: 4BFCDFF5  bl 0x823c1560
	ctx.lr = 0x823F3570;
	sub_823C1560(ctx, base);
	// 823F3570: 3BDF0458  addi r30, r31, 0x458
	ctx.r[30].s64 = ctx.r[31].s64 + 1112;
	// 823F3574: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 823F3578: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	pc = 0x823F357C; continue 'dispatch;
            }
            0x823F357C => {
    //   block [0x823F357C..0x823F3590)
	// 823F357C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3580: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3584: 4182000C  beq 0x823f3590
	if ctx.cr[0].eq {
	pc = 0x823F3590; continue 'dispatch;
	}
	// 823F3588: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F358C: 48004835  bl 0x823f7dc0
	ctx.lr = 0x823F3590;
	sub_823F7DC0(ctx, base);
	pc = 0x823F3590; continue 'dispatch;
            }
            0x823F3590 => {
    //   block [0x823F3590..0x823F35D0)
	// 823F3590: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F3594: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F3598: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 823F359C: 4082FFE0  bne 0x823f357c
	if !ctx.cr[0].eq {
	pc = 0x823F357C; continue 'dispatch;
	}
	// 823F35A0: 3AFF0728  addi r23, r31, 0x728
	ctx.r[23].s64 = ctx.r[31].s64 + 1832;
	// 823F35A4: 38A00198  li r5, 0x198
	ctx.r[5].s64 = 408;
	// 823F35A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F35AC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823F35B0: 4BFCDFB1  bl 0x823c1560
	ctx.lr = 0x823F35B4;
	sub_823C1560(ctx, base);
	// 823F35B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F35B8: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 823F35BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F35C0: 40990140  ble cr6, 0x823f3700
	if !ctx.cr[6].gt {
	pc = 0x823F3700; continue 'dispatch;
	}
	// 823F35C4: 3BDF0468  addi r30, r31, 0x468
	ctx.r[30].s64 = ctx.r[31].s64 + 1128;
	// 823F35C8: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 823F35CC: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	pc = 0x823F35D0; continue 'dispatch;
            }
            0x823F35D0 => {
    //   block [0x823F35D0..0x823F35FC)
	// 823F35D0: 817F051C  lwz r11, 0x51c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1308 as u32) ) } as u64;
	// 823F35D4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F35D8: 409A00F8  bne cr6, 0x823f36d0
	if !ctx.cr[6].eq {
	pc = 0x823F36D0; continue 'dispatch;
	}
	// 823F35DC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F35E0: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823F35E4: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 823F35E8: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 823F35EC: 419A0034  beq cr6, 0x823f3620
	if ctx.cr[6].eq {
	pc = 0x823F3620; continue 'dispatch;
	}
	// 823F35F0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823F35F4: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 823F35F8: 397D0024  addi r11, r29, 0x24
	ctx.r[11].s64 = ctx.r[29].s64 + 36;
	pc = 0x823F35FC; continue 'dispatch;
            }
            0x823F35FC => {
    //   block [0x823F35FC..0x823F360C)
	// 823F35FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3600: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F3604: 41980008  blt cr6, 0x823f360c
	if ctx.cr[6].lt {
	pc = 0x823F360C; continue 'dispatch;
	}
	// 823F3608: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F360C; continue 'dispatch;
            }
            0x823F360C => {
    //   block [0x823F360C..0x823F3620)
	// 823F360C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F3610: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F3614: 4082FFE8  bne 0x823f35fc
	if !ctx.cr[0].eq {
	pc = 0x823F35FC; continue 'dispatch;
	}
	// 823F3618: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 823F361C: 48000008  b 0x823f3624
	pc = 0x823F3624; continue 'dispatch;
            }
            0x823F3620 => {
    //   block [0x823F3620..0x823F3624)
	// 823F3620: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x823F3624; continue 'dispatch;
            }
            0x823F3624 => {
    //   block [0x823F3624..0x823F3640)
	// 823F3624: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3628: 397B0001  addi r11, r27, 1
	ctx.r[11].s64 = ctx.r[27].s64 + 1;
	// 823F362C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 823F3630: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F3634: 4098009C  bge cr6, 0x823f36d0
	if !ctx.cr[6].lt {
	pc = 0x823F36D0; continue 'dispatch;
	}
	// 823F3638: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823F363C: 38DE0004  addi r6, r30, 4
	ctx.r[6].s64 = ctx.r[30].s64 + 4;
	pc = 0x823F3640; continue 'dispatch;
            }
            0x823F3640 => {
    //   block [0x823F3640..0x823F3650)
	// 823F3640: 80E60000  lwz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3644: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823F3648: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 823F364C: 39470024  addi r10, r7, 0x24
	ctx.r[10].s64 = ctx.r[7].s64 + 36;
	pc = 0x823F3650; continue 'dispatch;
            }
            0x823F3650 => {
    //   block [0x823F3650..0x823F3660)
	// 823F3650: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3654: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F3658: 41980008  blt cr6, 0x823f3660
	if ctx.cr[6].lt {
	pc = 0x823F3660; continue 'dispatch;
	}
	// 823F365C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x823F3660; continue 'dispatch;
            }
            0x823F3660 => {
    //   block [0x823F3660..0x823F3688)
	// 823F3660: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F3664: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F3668: 4082FFE8  bne 0x823f3650
	if !ctx.cr[0].eq {
	pc = 0x823F3650; continue 'dispatch;
	}
	// 823F366C: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 823F3670: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 823F3674: 419A0014  beq cr6, 0x823f3688
	if ctx.cr[6].eq {
	pc = 0x823F3688; continue 'dispatch;
	}
	// 823F3678: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 823F367C: 4098000C  bge cr6, 0x823f3688
	if !ctx.cr[6].lt {
	pc = 0x823F3688; continue 'dispatch;
	}
	// 823F3680: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823F3684: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x823F3688; continue 'dispatch;
            }
            0x823F3688 => {
    //   block [0x823F3688..0x823F36D0)
	// 823F3688: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 823F368C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823F3690: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 823F3694: 4198FFAC  blt cr6, 0x823f3640
	if ctx.cr[6].lt {
	pc = 0x823F3640; continue 'dispatch;
	}
	// 823F3698: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 823F369C: 419A0034  beq cr6, 0x823f36d0
	if ctx.cr[6].eq {
	pc = 0x823F36D0; continue 'dispatch;
	}
	// 823F36A0: 397C011A  addi r11, r28, 0x11a
	ctx.r[11].s64 = ctx.r[28].s64 + 282;
	// 823F36A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F36A8: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F36AC: 7D4AEA78  xor r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[29].u64;
	// 823F36B0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F36B4: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F36B8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F36BC: 7D4A4A78  xor r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[9].u64;
	// 823F36C0: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 823F36C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F36C8: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 823F36CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F36D0; continue 'dispatch;
            }
            0x823F36D0 => {
    //   block [0x823F36D0..0x823F36E8)
	// 823F36D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F36D4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 823F36D8: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 823F36DC: 419A000C  beq cr6, 0x823f36e8
	if ctx.cr[6].eq {
	pc = 0x823F36E8; continue 'dispatch;
	}
	// 823F36E0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823F36E4: 48001F8D  bl 0x823f5670
	ctx.lr = 0x823F36E8;
	sub_823F5670(ctx, base);
	pc = 0x823F36E8; continue 'dispatch;
            }
            0x823F36E8 => {
    //   block [0x823F36E8..0x823F3700)
	// 823F36E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F36EC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823F36F0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F36F4: 3B39000C  addi r25, r25, 0xc
	ctx.r[25].s64 = ctx.r[25].s64 + 12;
	// 823F36F8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F36FC: 4198FED4  blt cr6, 0x823f35d0
	if ctx.cr[6].lt {
	pc = 0x823F35D0; continue 'dispatch;
	}
	pc = 0x823F3700; continue 'dispatch;
            }
            0x823F3700 => {
    //   block [0x823F3700..0x823F372C)
	// 823F3700: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823F3704: 92DF051C  stw r22, 0x51c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1308 as u32), ctx.r[22].u32 ) };
	// 823F3708: 397F0530  addi r11, r31, 0x530
	ctx.r[11].s64 = ctx.r[31].s64 + 1328;
	// 823F370C: 394AD400  addi r10, r10, -0x2c00
	ctx.r[10].s64 = ctx.r[10].s64 + -11264;
	// 823F3710: 38EB0030  addi r7, r11, 0x30
	ctx.r[7].s64 = ctx.r[11].s64 + 48;
	// 823F3714: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 823F3718: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823F371C: 80CA000C  lwz r6, 0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F3720: 40980040  bge cr6, 0x823f3760
	if !ctx.cr[6].lt {
	pc = 0x823F3760; continue 'dispatch;
	}
	// 823F3724: 38B80030  addi r5, r24, 0x30
	ctx.r[5].s64 = ctx.r[24].s64 + 48;
	// 823F3728: 7C8BC050  subf r4, r11, r24
	ctx.r[4].s64 = ctx.r[24].s64 - ctx.r[11].s64;
	pc = 0x823F372C; continue 'dispatch;
            }
            0x823F372C => {
    //   block [0x823F372C..0x823F3754)
	// 823F372C: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 823F3730: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 823F3734: 40980020  bge cr6, 0x823f3754
	if !ctx.cr[6].lt {
	pc = 0x823F3754; continue 'dispatch;
	}
	// 823F3738: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F373C: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823F3740: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823F3744: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 823F3748: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823F374C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823F3750: 4198FFDC  blt cr6, 0x823f372c
	if ctx.cr[6].lt {
	pc = 0x823F372C; continue 'dispatch;
	}
	pc = 0x823F3754; continue 'dispatch;
            }
            0x823F3754 => {
    //   block [0x823F3754..0x823F3760)
	// 823F3754: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F3758: 419A0008  beq cr6, 0x823f3760
	if ctx.cr[6].eq {
	pc = 0x823F3760; continue 'dispatch;
	}
	// 823F375C: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	pc = 0x823F3760; continue 'dispatch;
            }
            0x823F3760 => {
    //   block [0x823F3760..0x823F3788)
	// 823F3760: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F3764: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 823F3768: 396BD1B0  addi r11, r11, -0x2e50
	ctx.r[11].s64 = ctx.r[11].s64 + -11856;
	// 823F376C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823F3770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3774: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F3778: 4BFFF741  bl 0x823f2eb8
	ctx.lr = 0x823F377C;
	sub_823F2EB8(ctx, base);
	// 823F377C: 7F03B040  cmplw cr6, r3, r22
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[22].u32, &mut ctx.xer);
	// 823F3780: 40990008  ble cr6, 0x823f3788
	if !ctx.cr[6].gt {
	pc = 0x823F3788; continue 'dispatch;
	}
	// 823F3784: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	pc = 0x823F3788; continue 'dispatch;
            }
            0x823F3788 => {
    //   block [0x823F3788..0x823F379C)
	// 823F3788: 817F052C  lwz r11, 0x52c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 823F378C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F3790: 409A000C  bne cr6, 0x823f379c
	if !ctx.cr[6].eq {
	pc = 0x823F379C; continue 'dispatch;
	}
	// 823F3794: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F3798: 917F052C  stw r11, 0x52c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1324 as u32), ctx.r[11].u32 ) };
	pc = 0x823F379C; continue 'dispatch;
            }
            0x823F379C => {
    //   block [0x823F379C..0x823F37C4)
	// 823F379C: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F37A0: 80DF052C  lwz r6, 0x52c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1324 as u32) ) } as u64;
	// 823F37A4: 3BB70198  addi r29, r23, 0x198
	ctx.r[29].s64 = ctx.r[23].s64 + 408;
	// 823F37A8: 396BD1D0  addi r11, r11, -0x2e30
	ctx.r[11].s64 = ctx.r[11].s64 + -11824;
	// 823F37AC: 3BDF0590  addi r30, r31, 0x590
	ctx.r[30].s64 = ctx.r[31].s64 + 1424;
	// 823F37B0: 7F17E840  cmplw cr6, r23, r29
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F37B4: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F37B8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 823F37BC: 40980028  bge cr6, 0x823f37e4
	if !ctx.cr[6].lt {
	pc = 0x823F37E4; continue 'dispatch;
	}
	// 823F37C0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x823F37C4; continue 'dispatch;
            }
            0x823F37C4 => {
    //   block [0x823F37C4..0x823F37D8)
	// 823F37C4: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F37C8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 823F37CC: 4099000C  ble cr6, 0x823f37d8
	if !ctx.cr[6].gt {
	pc = 0x823F37D8; continue 'dispatch;
	}
	// 823F37D0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823F37D4: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	pc = 0x823F37D8; continue 'dispatch;
            }
            0x823F37D8 => {
    //   block [0x823F37D8..0x823F37E4)
	// 823F37D8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823F37DC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F37E0: 4198FFE4  blt cr6, 0x823f37c4
	if ctx.cr[6].lt {
	pc = 0x823F37C4; continue 'dispatch;
	}
	pc = 0x823F37E4; continue 'dispatch;
            }
            0x823F37E4 => {
    //   block [0x823F37E4..0x823F3804)
	// 823F37E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F37E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F37EC: 4BFFF6CD  bl 0x823f2eb8
	ctx.lr = 0x823F37F0;
	sub_823F2EB8(ctx, base);
	// 823F37F0: 395E0198  addi r10, r30, 0x198
	ctx.r[10].s64 = ctx.r[30].s64 + 408;
	// 823F37F4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 823F37F8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F37FC: 40980030  bge cr6, 0x823f382c
	if !ctx.cr[6].lt {
	pc = 0x823F382C; continue 'dispatch;
	}
	// 823F3800: 7D17F050  subf r8, r23, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[23].s64;
	pc = 0x823F3804; continue 'dispatch;
            }
            0x823F3804 => {
    //   block [0x823F3804..0x823F382C)
	// 823F3804: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F3808: 40980024  bge cr6, 0x823f382c
	if !ctx.cr[6].lt {
	pc = 0x823F382C; continue 'dispatch;
	}
	// 823F380C: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F3810: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823F3814: 7CE7402E  lwzx r7, r7, r8
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 823F3818: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 823F381C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 823F3820: 7D2B4214  add r9, r11, r8
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823F3824: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F3828: 4198FFDC  blt cr6, 0x823f3804
	if ctx.cr[6].lt {
	pc = 0x823F3804; continue 'dispatch;
	}
	pc = 0x823F382C; continue 'dispatch;
            }
            0x823F382C => {
    //   block [0x823F382C..0x823F3838)
	// 823F382C: 7F03B040  cmplw cr6, r3, r22
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[22].u32, &mut ctx.xer);
	// 823F3830: 40990008  ble cr6, 0x823f3838
	if !ctx.cr[6].gt {
	pc = 0x823F3838; continue 'dispatch;
	}
	// 823F3834: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	pc = 0x823F3838; continue 'dispatch;
            }
            0x823F3838 => {
    //   block [0x823F3838..0x823F384C)
	// 823F3838: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823F383C: 419A0010  beq cr6, 0x823f384c
	if ctx.cr[6].eq {
	pc = 0x823F384C; continue 'dispatch;
	}
	// 823F3840: 817F0528  lwz r11, 0x528(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1320 as u32) ) } as u64;
	// 823F3844: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F3848: 917F0528  stw r11, 0x528(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1320 as u32), ctx.r[11].u32 ) };
	pc = 0x823F384C; continue 'dispatch;
            }
            0x823F384C => {
    //   block [0x823F384C..0x823F3858)
	// 823F384C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 823F3850: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823F3854: 4814189C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F3858 size=244
    let mut pc: u32 = 0x823F3858;
    'dispatch: loop {
        match pc {
            0x823F3858 => {
    //   block [0x823F3858..0x823F3918)
	// 823F3858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F385C: 48141861  bl 0x825350bc
	ctx.lr = 0x823F3860;
	sub_82535080(ctx, base);
	// 823F3860: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823F3864: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3868: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F386C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823F3870: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F3874: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F387C: 4BFCDCE5  bl 0x823c1560
	ctx.lr = 0x823F3880;
	sub_823C1560(ctx, base);
	// 823F3880: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823F3884: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3888: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F388C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F3894: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823F3898: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823F389C: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 823F38A0: 4BFCDCC1  bl 0x823c1560
	ctx.lr = 0x823F38A4;
	sub_823C1560(ctx, base);
	// 823F38A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823F38A8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823F38AC: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F38B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F38B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823F38B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F38BC: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 823F38C0: 4BFCDCA1  bl 0x823c1560
	ctx.lr = 0x823F38C4;
	sub_823C1560(ctx, base);
	// 823F38C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F38C8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F38CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F38D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 823F38D4: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 823F38D8: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 823F38DC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F38E0: 4BFCDC81  bl 0x823c1560
	ctx.lr = 0x823F38E4;
	sub_823C1560(ctx, base);
	// 823F38E4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823F38E8: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 823F38EC: 9BC10068  stb r30, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u8 ) };
	// 823F38F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F38F4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 823F38F8: 419A0048  beq cr6, 0x823f3940
	if ctx.cr[6].eq {
	pc = 0x823F3940; continue 'dispatch;
	}
	// 823F38FC: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F3900: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F3904: 40820014  bne 0x823f3918
	if !ctx.cr[0].eq {
	pc = 0x823F3918; continue 'dispatch;
	}
	// 823F3908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F390C: 480038C5  bl 0x823f71d0
	ctx.lr = 0x823F3910;
	sub_823F71D0(ctx, base);
	// 823F3910: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F3914: 4082001C  bne 0x823f3930
	if !ctx.cr[0].eq {
	pc = 0x823F3930; continue 'dispatch;
	}
	pc = 0x823F3918; continue 'dispatch;
            }
            0x823F3918 => {
    //   block [0x823F3918..0x823F3930)
	// 823F3918: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F391C: 556B031F  rlwinm. r11, r11, 0, 0xc, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F3920: 41820010  beq 0x823f3930
	if ctx.cr[0].eq {
	pc = 0x823F3930; continue 'dispatch;
	}
	// 823F3924: C01F00B8  lfs f0, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F3928: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823F392C: 48000008  b 0x823f3934
	pc = 0x823F3934; continue 'dispatch;
            }
            0x823F3930 => {
    //   block [0x823F3930..0x823F3934)
	// 823F3930: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x823F3934; continue 'dispatch;
            }
            0x823F3934 => {
    //   block [0x823F3934..0x823F3940)
	// 823F3934: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 823F3938: 807D0038  lwz r3, 0x38(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 823F393C: 4819039D  bl 0x82583cd8
	ctx.lr = 0x823F3940;
	sub_82583CD8(ctx, base);
	pc = 0x823F3940; continue 'dispatch;
            }
            0x823F3940 => {
    //   block [0x823F3940..0x823F394C)
	// 823F3940: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F3944: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823F3948: 481417C4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F3950 size=100
    let mut pc: u32 = 0x823F3950;
    'dispatch: loop {
        match pc {
            0x823F3950 => {
    //   block [0x823F3950..0x823F3964)
	// 823F3950: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3954: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F3958: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F395C: 41820028  beq 0x823f3984
	if ctx.cr[0].eq {
	pc = 0x823F3984; continue 'dispatch;
	}
	// 823F3960: 39230468  addi r9, r3, 0x468
	ctx.r[9].s64 = ctx.r[3].s64 + 1128;
	pc = 0x823F3964; continue 'dispatch;
            }
            0x823F3964 => {
    //   block [0x823F3964..0x823F3984)
	// 823F3964: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3968: E9080000  ld r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 823F396C: 7F244040  cmpld cr6, r4, r8
	ctx.cr[6].compare_u64(ctx.r[4].u64, ctx.r[8].u64, &mut ctx.xer);
	// 823F3970: 419A0014  beq cr6, 0x823f3984
	if ctx.cr[6].eq {
	pc = 0x823F3984; continue 'dispatch;
	}
	// 823F3974: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F3978: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823F397C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F3980: 4198FFE4  blt cr6, 0x823f3964
	if ctx.cr[6].lt {
	pc = 0x823F3964; continue 'dispatch;
	}
	pc = 0x823F3984; continue 'dispatch;
            }
            0x823F3984 => {
    //   block [0x823F3984..0x823F39B4)
	// 823F3984: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F3988: 1D6B0003  mulli r11, r11, 3
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 3 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F398C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F3990: 394B01CA  addi r10, r11, 0x1ca
	ctx.r[10].s64 = ctx.r[11].s64 + 458;
	// 823F3994: 396B0164  addi r11, r11, 0x164
	ctx.r[11].s64 = ctx.r[11].s64 + 356;
	// 823F3998: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F399C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F39A0: 7D4A182E  lwzx r10, r10, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823F39A4: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F39A8: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823F39AC: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F39B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F39B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F39B8 size=368
    let mut pc: u32 = 0x823F39B8;
    'dispatch: loop {
        match pc {
            0x823F39B8 => {
    //   block [0x823F39B8..0x823F3A18)
	// 823F39B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F39BC: 481416FD  bl 0x825350b8
	ctx.lr = 0x823F39C0;
	sub_82535080(ctx, base);
	// 823F39C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F39C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F39C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F39CC: 419A0154  beq cr6, 0x823f3b20
	if ctx.cr[6].eq {
	pc = 0x823F3B20; continue 'dispatch;
	}
	// 823F39D0: 817F04F0  lwz r11, 0x4f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1264 as u32) ) } as u64;
	// 823F39D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F39D8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 823F39DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F39E0: 41820038  beq 0x823f3a18
	if ctx.cr[0].eq {
	pc = 0x823F3A18; continue 'dispatch;
	}
	// 823F39E4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 823F39E8: 419A0030  beq cr6, 0x823f3a18
	if ctx.cr[6].eq {
	pc = 0x823F3A18; continue 'dispatch;
	}
	// 823F39EC: 807F0518  lwz r3, 0x518(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1304 as u32) ) } as u64;
	// 823F39F0: 4BFCDA51  bl 0x823c1440
	ctx.lr = 0x823F39F4;
	sub_823C1440(ctx, base);
	// 823F39F4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F39F8: 807F04F0  lwz r3, 0x4f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1264 as u32) ) } as u64;
	// 823F39FC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 823F3A00: 917F0514  stw r11, 0x514(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1300 as u32), ctx.r[11].u32 ) };
	// 823F3A04: 4BFCDB15  bl 0x823c1518
	ctx.lr = 0x823F3A08;
	sub_823C1518(ctx, base);
	// 823F3A08: 807F04F0  lwz r3, 0x4f0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1264 as u32) ) } as u64;
	// 823F3A0C: 939F0514  stw r28, 0x514(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1300 as u32), ctx.r[28].u32 ) };
	// 823F3A10: 4BFCCF49  bl 0x823c0958
	ctx.lr = 0x823F3A14;
	sub_823C0958(ctx, base);
	// 823F3A14: 93DF04F0  stw r30, 0x4f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1264 as u32), ctx.r[30].u32 ) };
	pc = 0x823F3A18; continue 'dispatch;
            }
            0x823F3A18 => {
    //   block [0x823F3A18..0x823F3A34)
	// 823F3A18: 807F0518  lwz r3, 0x518(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1304 as u32) ) } as u64;
	// 823F3A1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3A20: 41820014  beq 0x823f3a34
	if ctx.cr[0].eq {
	pc = 0x823F3A34; continue 'dispatch;
	}
	// 823F3A24: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 823F3A28: 419A000C  beq cr6, 0x823f3a34
	if ctx.cr[6].eq {
	pc = 0x823F3A34; continue 'dispatch;
	}
	// 823F3A2C: 4BFCCF2D  bl 0x823c0958
	ctx.lr = 0x823F3A30;
	sub_823C0958(ctx, base);
	// 823F3A30: 93DF0518  stw r30, 0x518(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1304 as u32), ctx.r[30].u32 ) };
	pc = 0x823F3A34; continue 'dispatch;
            }
            0x823F3A34 => {
    //   block [0x823F3A34..0x823F3A50)
	// 823F3A34: 807F0520  lwz r3, 0x520(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1312 as u32) ) } as u64;
	// 823F3A38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3A3C: 41820014  beq 0x823f3a50
	if ctx.cr[0].eq {
	pc = 0x823F3A50; continue 'dispatch;
	}
	// 823F3A40: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 823F3A44: 419A000C  beq cr6, 0x823f3a50
	if ctx.cr[6].eq {
	pc = 0x823F3A50; continue 'dispatch;
	}
	// 823F3A48: 4BFCCF11  bl 0x823c0958
	ctx.lr = 0x823F3A4C;
	sub_823C0958(ctx, base);
	// 823F3A4C: 93DF0520  stw r30, 0x520(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1312 as u32), ctx.r[30].u32 ) };
	pc = 0x823F3A50; continue 'dispatch;
            }
            0x823F3A50 => {
    //   block [0x823F3A50..0x823F3A60)
	// 823F3A50: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F3A54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3A58: 41820008  beq 0x823f3a60
	if ctx.cr[0].eq {
	pc = 0x823F3A60; continue 'dispatch;
	}
	// 823F3A5C: 4819014D  bl 0x82583ba8
	ctx.lr = 0x823F3A60;
	sub_82583BA8(ctx, base);
	pc = 0x823F3A60; continue 'dispatch;
            }
            0x823F3A60 => {
    //   block [0x823F3A60..0x823F3A74)
	// 823F3A60: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F3A64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3A68: 4182000C  beq 0x823f3a74
	if ctx.cr[0].eq {
	pc = 0x823F3A74; continue 'dispatch;
	}
	// 823F3A6C: 4819013D  bl 0x82583ba8
	ctx.lr = 0x823F3A70;
	sub_82583BA8(ctx, base);
	// 823F3A70: 939F0040  stw r28, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[28].u32 ) };
	pc = 0x823F3A74; continue 'dispatch;
            }
            0x823F3A74 => {
    //   block [0x823F3A74..0x823F3A88)
	// 823F3A74: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823F3A78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3A7C: 4182000C  beq 0x823f3a88
	if ctx.cr[0].eq {
	pc = 0x823F3A88; continue 'dispatch;
	}
	// 823F3A80: 48190129  bl 0x82583ba8
	ctx.lr = 0x823F3A84;
	sub_82583BA8(ctx, base);
	// 823F3A84: 939F0038  stw r28, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	pc = 0x823F3A88; continue 'dispatch;
            }
            0x823F3A88 => {
    //   block [0x823F3A88..0x823F3A9C)
	// 823F3A88: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F3A8C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823F3A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F3A94: 40990028  ble cr6, 0x823f3abc
	if !ctx.cr[6].gt {
	pc = 0x823F3ABC; continue 'dispatch;
	}
	// 823F3A98: 3BDF0448  addi r30, r31, 0x448
	ctx.r[30].s64 = ctx.r[31].s64 + 1096;
	pc = 0x823F3A9C; continue 'dispatch;
            }
            0x823F3A9C => {
    //   block [0x823F3A9C..0x823F3ABC)
	// 823F3A9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3AA0: 480043D1  bl 0x823f7e70
	ctx.lr = 0x823F3AA4;
	sub_823F7E70(ctx, base);
	// 823F3AA4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F3AA8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F3AAC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F3AB0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F3AB4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F3AB8: 4198FFE4  blt cr6, 0x823f3a9c
	if ctx.cr[6].lt {
	pc = 0x823F3A9C; continue 'dispatch;
	}
	pc = 0x823F3ABC; continue 'dispatch;
            }
            0x823F3ABC => {
    //   block [0x823F3ABC..0x823F3AC4)
	// 823F3ABC: 3BDF0458  addi r30, r31, 0x458
	ctx.r[30].s64 = ctx.r[31].s64 + 1112;
	// 823F3AC0: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	pc = 0x823F3AC4; continue 'dispatch;
            }
            0x823F3AC4 => {
    //   block [0x823F3AC4..0x823F3AF0)
	// 823F3AC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3AC8: 480043A9  bl 0x823f7e70
	ctx.lr = 0x823F3ACC;
	sub_823F7E70(ctx, base);
	// 823F3ACC: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F3AD0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F3AD4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F3AD8: 4082FFEC  bne 0x823f3ac4
	if !ctx.cr[0].eq {
	pc = 0x823F3AC4; continue 'dispatch;
	}
	// 823F3ADC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3AE0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823F3AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F3AE8: 40990028  ble cr6, 0x823f3b10
	if !ctx.cr[6].gt {
	pc = 0x823F3B10; continue 'dispatch;
	}
	// 823F3AEC: 3BDF0468  addi r30, r31, 0x468
	ctx.r[30].s64 = ctx.r[31].s64 + 1128;
	pc = 0x823F3AF0; continue 'dispatch;
            }
            0x823F3AF0 => {
    //   block [0x823F3AF0..0x823F3B10)
	// 823F3AF0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3AF4: 48001665  bl 0x823f5158
	ctx.lr = 0x823F3AF8;
	sub_823F5158(ctx, base);
	// 823F3AF8: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F3AFC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F3B00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3B04: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F3B08: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F3B0C: 4198FFE4  blt cr6, 0x823f3af0
	if ctx.cr[6].lt {
	pc = 0x823F3AF0; continue 'dispatch;
	}
	pc = 0x823F3B10; continue 'dispatch;
            }
            0x823F3B10 => {
    //   block [0x823F3B10..0x823F3B20)
	// 823F3B10: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F3B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3B18: 6084800C  ori r4, r4, 0x800c
	ctx.r[4].u64 = ctx.r[4].u64 | 32780;
	// 823F3B1C: 4BFD673D  bl 0x823ca258
	ctx.lr = 0x823F3B20;
	sub_823CA258(ctx, base);
	pc = 0x823F3B20; continue 'dispatch;
            }
            0x823F3B20 => {
    //   block [0x823F3B20..0x823F3B28)
	// 823F3B20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3B24: 481415E4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3B28 size=88
    let mut pc: u32 = 0x823F3B28;
    'dispatch: loop {
        match pc {
            0x823F3B28 => {
    //   block [0x823F3B28..0x823F3B3C)
	// 823F3B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3B2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F3B30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F3B34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3B38: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x823F3B3C; continue 'dispatch;
            }
            0x823F3B3C => {
    //   block [0x823F3B3C..0x823F3B68)
	// 823F3B3C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F3B40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F3B44: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823F3B48: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823F3B4C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F3B50: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F3B54: 4082FFE8  bne 0x823f3b3c
	if !ctx.cr[0].eq {
	pc = 0x823F3B3C; continue 'dispatch;
	}
	// 823F3B58: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823F3B5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F3B60: 409A0008  bne cr6, 0x823f3b68
	if !ctx.cr[6].eq {
	pc = 0x823F3B68; continue 'dispatch;
	}
	// 823F3B64: 4BFFFE55  bl 0x823f39b8
	ctx.lr = 0x823F3B68;
	sub_823F39B8(ctx, base);
	pc = 0x823F3B68; continue 'dispatch;
            }
            0x823F3B68 => {
    //   block [0x823F3B68..0x823F3B80)
	// 823F3B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3B6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F3B70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F3B74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F3B78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F3B7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3B80 size=372
    let mut pc: u32 = 0x823F3B80;
    'dispatch: loop {
        match pc {
            0x823F3B80 => {
    //   block [0x823F3B80..0x823F3C04)
	// 823F3B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3B84: 4814152D  bl 0x825350b0
	ctx.lr = 0x823F3B88;
	sub_82535080(ctx, base);
	// 823F3B88: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3B8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3B90: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F3B94: 3B5F04F8  addi r26, r31, 0x4f8
	ctx.r[26].s64 = ctx.r[31].s64 + 1272;
	// 823F3B98: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823F3B9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F3BA0: 483196BD  bl 0x8270d25c
	ctx.lr = 0x823F3BA4;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3BA4: 817F0514  lwz r11, 0x514(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1300 as u32) ) } as u64;
	// 823F3BA8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823F3BAC: 419A0130  beq cr6, 0x823f3cdc
	if ctx.cr[6].eq {
	pc = 0x823F3CDC; continue 'dispatch;
	}
	// 823F3BB0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 823F3BB4: 807F0520  lwz r3, 0x520(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1312 as u32) ) } as u64;
	// 823F3BB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F3BBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3BC0: 4831943D  bl 0x8270cffc
	ctx.lr = 0x823F3BC4;
	// extern call 0x8270CFFC  crate::xboxkrnl::XNotifyGetNext
	crate::xboxkrnl::XNotifyGetNext(ctx, base);
	// 823F3BC4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823F3BC8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F3BCC: 4182003C  beq 0x823f3c08
	if ctx.cr[0].eq {
	pc = 0x823F3C08; continue 'dispatch;
	}
	// 823F3BD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F3BD4: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 823F3BD8: 419A002C  beq cr6, 0x823f3c04
	if ctx.cr[6].eq {
	pc = 0x823F3C04; continue 'dispatch;
	}
	// 823F3BDC: 2B0B000E  cmplwi cr6, r11, 0xe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 14 as u32, &mut ctx.xer);
	// 823F3BE0: 419A0024  beq cr6, 0x823f3c04
	if ctx.cr[6].eq {
	pc = 0x823F3C04; continue 'dispatch;
	}
	// 823F3BE4: 3D400400  lis r10, 0x400
	ctx.r[10].s64 = 67108864;
	// 823F3BE8: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 823F3BEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F3BF0: 419A0014  beq cr6, 0x823f3c04
	if ctx.cr[6].eq {
	pc = 0x823F3C04; continue 'dispatch;
	}
	// 823F3BF4: 3D400400  lis r10, 0x400
	ctx.r[10].s64 = 67108864;
	// 823F3BF8: 614A0003  ori r10, r10, 3
	ctx.r[10].u64 = ctx.r[10].u64 | 3;
	// 823F3BFC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F3C00: 409A0008  bne cr6, 0x823f3c08
	if !ctx.cr[6].eq {
	pc = 0x823F3C08; continue 'dispatch;
	}
	pc = 0x823F3C04; continue 'dispatch;
            }
            0x823F3C04 => {
    //   block [0x823F3C04..0x823F3C08)
	// 823F3C04: 93DF0524  stw r30, 0x524(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1316 as u32), ctx.r[30].u32 ) };
	pc = 0x823F3C08; continue 'dispatch;
            }
            0x823F3C08 => {
    //   block [0x823F3C08..0x823F3C64)
	// 823F3C08: 817F0444  lwz r11, 0x444(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 823F3C0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F3C10: 409A0054  bne cr6, 0x823f3c64
	if !ctx.cr[6].eq {
	pc = 0x823F3C64; continue 'dispatch;
	}
	// 823F3C14: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 823F3C18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3C1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823F3C20: 4BFCD941  bl 0x823c1560
	ctx.lr = 0x823F3C24;
	sub_823C1560(ctx, base);
	// 823F3C24: 397F0044  addi r11, r31, 0x44
	ctx.r[11].s64 = ctx.r[31].s64 + 68;
	// 823F3C28: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 823F3C2C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F3C30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823F3C34: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 823F3C38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823F3C3C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823F3C40: 39600400  li r11, 0x400
	ctx.r[11].s64 = 1024;
	// 823F3C44: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 823F3C48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F3C4C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 823F3C50: 48190139  bl 0x82583d88
	ctx.lr = 0x823F3C54;
	sub_82583D88(ctx, base);
	// 823F3C54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3C58: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F3C5C: 48190245  bl 0x82583ea0
	ctx.lr = 0x823F3C60;
	sub_82583EA0(ctx, base);
	// 823F3C60: 93DF0444  stw r30, 0x444(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), ctx.r[30].u32 ) };
	pc = 0x823F3C64; continue 'dispatch;
            }
            0x823F3C64 => {
    //   block [0x823F3C64..0x823F3C78)
	// 823F3C64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3C68: 4BFFF8E1  bl 0x823f3548
	ctx.lr = 0x823F3C6C;
	sub_823F3548(ctx, base);
	// 823F3C6C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F3C70: 3BDF0458  addi r30, r31, 0x458
	ctx.r[30].s64 = ctx.r[31].s64 + 1112;
	// 823F3C74: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	pc = 0x823F3C78; continue 'dispatch;
            }
            0x823F3C78 => {
    //   block [0x823F3C78..0x823F3C88)
	// 823F3C78: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3C7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3C80: 41820008  beq 0x823f3c88
	if ctx.cr[0].eq {
	pc = 0x823F3C88; continue 'dispatch;
	}
	// 823F3C84: 48003DD5  bl 0x823f7a58
	ctx.lr = 0x823F3C88;
	sub_823F7A58(ctx, base);
	pc = 0x823F3C88; continue 'dispatch;
            }
            0x823F3C88 => {
    //   block [0x823F3C88..0x823F3CA8)
	// 823F3C88: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F3C8C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F3C90: 4082FFE8  bne 0x823f3c78
	if !ctx.cr[0].eq {
	pc = 0x823F3C78; continue 'dispatch;
	}
	// 823F3C94: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3C98: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 823F3C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F3CA0: 40990038  ble cr6, 0x823f3cd8
	if !ctx.cr[6].gt {
	pc = 0x823F3CD8; continue 'dispatch;
	}
	// 823F3CA4: 3BDF0468  addi r30, r31, 0x468
	ctx.r[30].s64 = ctx.r[31].s64 + 1128;
	pc = 0x823F3CA8; continue 'dispatch;
            }
            0x823F3CA8 => {
    //   block [0x823F3CA8..0x823F3CC4)
	// 823F3CA8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3CAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3CB0: 41820014  beq 0x823f3cc4
	if ctx.cr[0].eq {
	pc = 0x823F3CC4; continue 'dispatch;
	}
	// 823F3CB4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 823F3CB8: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 823F3CBC: 419A0008  beq cr6, 0x823f3cc4
	if ctx.cr[6].eq {
	pc = 0x823F3CC4; continue 'dispatch;
	}
	// 823F3CC0: 48001581  bl 0x823f5240
	ctx.lr = 0x823F3CC4;
	sub_823F5240(ctx, base);
	pc = 0x823F3CC4; continue 'dispatch;
            }
            0x823F3CC4 => {
    //   block [0x823F3CC4..0x823F3CD8)
	// 823F3CC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3CC8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F3CCC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F3CD0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F3CD4: 4198FFD4  blt cr6, 0x823f3ca8
	if ctx.cr[6].lt {
	pc = 0x823F3CA8; continue 'dispatch;
	}
	pc = 0x823F3CD8; continue 'dispatch;
            }
            0x823F3CD8 => {
    //   block [0x823F3CD8..0x823F3CDC)
	// 823F3CD8: 937F0524  stw r27, 0x524(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1316 as u32), ctx.r[27].u32 ) };
	pc = 0x823F3CDC; continue 'dispatch;
            }
            0x823F3CDC => {
    //   block [0x823F3CDC..0x823F3CF4)
	// 823F3CDC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F3CE0: 4831958D  bl 0x8270d26c
	ctx.lr = 0x823F3CE4;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3CE4: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 823F3CE8: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F3CEC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 823F3CF0: 48141410  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3CF8 size=108
    let mut pc: u32 = 0x823F3CF8;
    'dispatch: loop {
        match pc {
            0x823F3CF8 => {
    //   block [0x823F3CF8..0x823F3D40)
	// 823F3CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3CFC: 481413B9  bl 0x825350b4
	ctx.lr = 0x823F3D00;
	sub_82535080(ctx, base);
	// 823F3D00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3D08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F3D0C: 3B7F04F8  addi r27, r31, 0x4f8
	ctx.r[27].s64 = ctx.r[31].s64 + 1272;
	// 823F3D10: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F3D14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F3D18: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F3D1C: 48319541  bl 0x8270d25c
	ctx.lr = 0x823F3D20;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3D20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F3D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3D28: 4BFFF7C9  bl 0x823f34f0
	ctx.lr = 0x823F3D2C;
	sub_823F34F0(ctx, base);
	// 823F3D2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3D30: 40820010  bne 0x823f3d40
	if !ctx.cr[0].eq {
	pc = 0x823F3D40; continue 'dispatch;
	}
	// 823F3D34: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F3D38: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F3D3C: 48000014  b 0x823f3d50
	pc = 0x823F3D50; continue 'dispatch;
            }
            0x823F3D40 => {
    //   block [0x823F3D40..0x823F3D50)
	// 823F3D40: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F3D44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F3D48: 480015A9  bl 0x823f52f0
	ctx.lr = 0x823F3D4C;
	sub_823F52F0(ctx, base);
	// 823F3D4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F3D50; continue 'dispatch;
            }
            0x823F3D50 => {
    //   block [0x823F3D50..0x823F3D64)
	// 823F3D50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F3D54: 48319519  bl 0x8270d26c
	ctx.lr = 0x823F3D58;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3D5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3D60: 481413A4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3D68 size=108
    let mut pc: u32 = 0x823F3D68;
    'dispatch: loop {
        match pc {
            0x823F3D68 => {
    //   block [0x823F3D68..0x823F3DB0)
	// 823F3D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3D6C: 48141349  bl 0x825350b4
	ctx.lr = 0x823F3D70;
	sub_82535080(ctx, base);
	// 823F3D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3D78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F3D7C: 3B7F04F8  addi r27, r31, 0x4f8
	ctx.r[27].s64 = ctx.r[31].s64 + 1272;
	// 823F3D80: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F3D84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F3D88: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F3D8C: 483194D1  bl 0x8270d25c
	ctx.lr = 0x823F3D90;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3D90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F3D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3D98: 4BFFF759  bl 0x823f34f0
	ctx.lr = 0x823F3D9C;
	sub_823F34F0(ctx, base);
	// 823F3D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3DA0: 40820010  bne 0x823f3db0
	if !ctx.cr[0].eq {
	pc = 0x823F3DB0; continue 'dispatch;
	}
	// 823F3DA4: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F3DA8: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F3DAC: 48000014  b 0x823f3dc0
	pc = 0x823F3DC0; continue 'dispatch;
            }
            0x823F3DB0 => {
    //   block [0x823F3DB0..0x823F3DC0)
	// 823F3DB0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F3DB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F3DB8: 480015B1  bl 0x823f5368
	ctx.lr = 0x823F3DBC;
	sub_823F5368(ctx, base);
	// 823F3DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F3DC0; continue 'dispatch;
            }
            0x823F3DC0 => {
    //   block [0x823F3DC0..0x823F3DD4)
	// 823F3DC0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F3DC4: 483194A9  bl 0x8270d26c
	ctx.lr = 0x823F3DC8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3DCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3DD0: 48141334  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3DD8 size=264
    let mut pc: u32 = 0x823F3DD8;
    'dispatch: loop {
        match pc {
            0x823F3DD8 => {
    //   block [0x823F3DD8..0x823F3E34)
	// 823F3DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3DDC: 481412D5  bl 0x825350b0
	ctx.lr = 0x823F3DE0;
	sub_82535080(ctx, base);
	// 823F3DE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3DE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F3DE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823F3DEC: 3B5E04F8  addi r26, r30, 0x4f8
	ctx.r[26].s64 = ctx.r[30].s64 + 1272;
	// 823F3DF0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F3DF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F3DF8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F3DFC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823F3E00: 4831945D  bl 0x8270d25c
	ctx.lr = 0x823F3E04;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3E04: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F3E08: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F3E0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F3E10: 4BFCD751  bl 0x823c1560
	ctx.lr = 0x823F3E14;
	sub_823C1560(ctx, base);
	// 823F3E14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F3E18: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F3E1C: 4BFFF6D5  bl 0x823f34f0
	ctx.lr = 0x823F3E20;
	sub_823F34F0(ctx, base);
	// 823F3E20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3E24: 40820010  bne 0x823f3e34
	if !ctx.cr[0].eq {
	pc = 0x823F3E34; continue 'dispatch;
	}
	// 823F3E28: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 823F3E2C: 63BD4005  ori r29, r29, 0x4005
	ctx.r[29].u64 = ctx.r[29].u64 | 16389;
	// 823F3E30: 4800009C  b 0x823f3ecc
	pc = 0x823F3ECC; continue 'dispatch;
            }
            0x823F3E34 => {
    //   block [0x823F3E34..0x823F3E90)
	// 823F3E34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F3E38: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823F3E3C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823F3E40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823F3E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F3E48: 48001599  bl 0x823f53e0
	ctx.lr = 0x823F3E4C;
	sub_823F53E0(ctx, base);
	// 823F3E4C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F3E50: 4180007C  blt 0x823f3ecc
	if ctx.cr[0].lt {
	pc = 0x823F3ECC; continue 'dispatch;
	}
	// 823F3E54: 3D80FBDF  lis r12, -0x421
	ctx.r[12].s64 = -69271552;
	// 823F3E58: 3D40EADB  lis r10, -0x1525
	ctx.r[10].s64 = -354746368;
	// 823F3E5C: 618C00DD  ori r12, r12, 0xdd
	ctx.r[12].u64 = ctx.r[12].u64 | 221;
	// 823F3E60: 3D20FBDF  lis r9, -0x421
	ctx.r[9].s64 = -69271552;
	// 823F3E64: 798C07C6  sldi r12, r12, 0x20
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(32);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 823F3E68: 614AEEF0  ori r10, r10, 0xeef0
	ctx.r[10].u64 = ctx.r[10].u64 | 61168;
	// 823F3E6C: 658CEADB  oris r12, r12, 0xeadb
	ctx.r[12].u64 = ctx.r[12].u64 | 3940220928;
	// 823F3E70: 612900DD  ori r9, r9, 0xdd
	ctx.r[9].u64 = ctx.r[9].u64 | 221;
	// 823F3E74: 618CEEF0  ori r12, r12, 0xeef0
	ctx.r[12].u64 = ctx.r[12].u64 | 61168;
	// 823F3E78: 792A000E  rldimi r10, r9, 0x20, 0
	ctx.r[10].u64 = ((ctx.r[9].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[10].u64 & 0x00000000FFFFFFFF);
	// 823F3E7C: 7FEB6038  and r11, r31, r12
	ctx.r[11].u64 = ctx.r[31].u64 & ctx.r[12].u64;
	// 823F3E80: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 823F3E84: 419A0048  beq cr6, 0x823f3ecc
	if ctx.cr[6].eq {
	pc = 0x823F3ECC; continue 'dispatch;
	}
	// 823F3E88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F3E8C: 397E0458  addi r11, r30, 0x458
	ctx.r[11].s64 = ctx.r[30].s64 + 1112;
	pc = 0x823F3E90; continue 'dispatch;
            }
            0x823F3E90 => {
    //   block [0x823F3E90..0x823F3EB0)
	// 823F3E90: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3E94: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3E98: 41820018  beq 0x823f3eb0
	if ctx.cr[0].eq {
	pc = 0x823F3EB0; continue 'dispatch;
	}
	// 823F3E9C: 812900C4  lwz r9, 0xc4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F3EA0: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 823F3EA4: 5529031E  rlwinm r9, r9, 0, 0xc, 0xf
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823F3EA8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F3EAC: 419A0018  beq cr6, 0x823f3ec4
	if ctx.cr[6].eq {
	pc = 0x823F3EC4; continue 'dispatch;
	}
	pc = 0x823F3EB0; continue 'dispatch;
            }
            0x823F3EB0 => {
    //   block [0x823F3EB0..0x823F3EC4)
	// 823F3EB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F3EB4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F3EB8: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 823F3EBC: 4198FFD4  blt cr6, 0x823f3e90
	if ctx.cr[6].lt {
	pc = 0x823F3E90; continue 'dispatch;
	}
	// 823F3EC0: 4800000C  b 0x823f3ecc
	pc = 0x823F3ECC; continue 'dispatch;
            }
            0x823F3EC4 => {
    //   block [0x823F3EC4..0x823F3ECC)
	// 823F3EC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F3EC8: 917E0524  stw r11, 0x524(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1316 as u32), ctx.r[11].u32 ) };
	pc = 0x823F3ECC; continue 'dispatch;
            }
            0x823F3ECC => {
    //   block [0x823F3ECC..0x823F3EE0)
	// 823F3ECC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F3ED0: 4831939D  bl 0x8270d26c
	ctx.lr = 0x823F3ED4;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3ED4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3ED8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F3EDC: 48141224  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3EE0 size=92
    let mut pc: u32 = 0x823F3EE0;
    'dispatch: loop {
        match pc {
            0x823F3EE0 => {
    //   block [0x823F3EE0..0x823F3F20)
	// 823F3EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3EE4: 481411D9  bl 0x825350bc
	ctx.lr = 0x823F3EE8;
	sub_82535080(ctx, base);
	// 823F3EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3EF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F3EF4: 3BBF04F8  addi r29, r31, 0x4f8
	ctx.r[29].s64 = ctx.r[31].s64 + 1272;
	// 823F3EF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3EFC: 48319361  bl 0x8270d25c
	ctx.lr = 0x823F3F00;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3F00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F3F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3F08: 4BFFF5E9  bl 0x823f34f0
	ctx.lr = 0x823F3F0C;
	sub_823F34F0(ctx, base);
	// 823F3F0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F3F10: 40820010  bne 0x823f3f20
	if !ctx.cr[0].eq {
	pc = 0x823F3F20; continue 'dispatch;
	}
	// 823F3F14: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F3F18: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F3F1C: 4800000C  b 0x823f3f28
	pc = 0x823F3F28; continue 'dispatch;
            }
            0x823F3F20 => {
    //   block [0x823F3F20..0x823F3F28)
	// 823F3F20: 48001561  bl 0x823f5480
	ctx.lr = 0x823F3F24;
	sub_823F5480(ctx, base);
	// 823F3F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F3F28; continue 'dispatch;
            }
            0x823F3F28 => {
    //   block [0x823F3F28..0x823F3F3C)
	// 823F3F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F3F2C: 48319341  bl 0x8270d26c
	ctx.lr = 0x823F3F30;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F3F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F3F38: 481411D4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F3F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F3F40 size=188
    let mut pc: u32 = 0x823F3F40;
    'dispatch: loop {
        match pc {
            0x823F3F40 => {
    //   block [0x823F3F40..0x823F3F7C)
	// 823F3F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F3F44: 48141175  bl 0x825350b8
	ctx.lr = 0x823F3F48;
	sub_82535080(ctx, base);
	// 823F3F48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F3F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F3F50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F3F54: 3B9F04F8  addi r28, r31, 0x4f8
	ctx.r[28].s64 = ctx.r[31].s64 + 1272;
	// 823F3F58: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F3F5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F3F60: 483192FD  bl 0x8270d25c
	ctx.lr = 0x823F3F64;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F3F64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F3F68: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F3F6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F3F74: 40990074  ble cr6, 0x823f3fe8
	if !ctx.cr[6].gt {
	pc = 0x823F3FE8; continue 'dispatch;
	}
	// 823F3F78: 393F0468  addi r9, r31, 0x468
	ctx.r[9].s64 = ctx.r[31].s64 + 1128;
	pc = 0x823F3F7C; continue 'dispatch;
            }
            0x823F3F7C => {
    //   block [0x823F3F7C..0x823F3FD4)
	// 823F3F7C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3F80: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823F3F84: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 823F3F88: 419A004C  beq cr6, 0x823f3fd4
	if ctx.cr[6].eq {
	pc = 0x823F3FD4; continue 'dispatch;
	}
	// 823F3F8C: 3D80FBDF  lis r12, -0x421
	ctx.r[12].s64 = -69271552;
	// 823F3F90: 3CE0EADB  lis r7, -0x1525
	ctx.r[7].s64 = -354746368;
	// 823F3F94: 618C00DD  ori r12, r12, 0xdd
	ctx.r[12].u64 = ctx.r[12].u64 | 221;
	// 823F3F98: 3CC0FBDF  lis r6, -0x421
	ctx.r[6].s64 = -69271552;
	// 823F3F9C: 798C07C6  sldi r12, r12, 0x20
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(32);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 823F3FA0: 60E7EEF0  ori r7, r7, 0xeef0
	ctx.r[7].u64 = ctx.r[7].u64 | 61168;
	// 823F3FA4: 658CEADB  oris r12, r12, 0xeadb
	ctx.r[12].u64 = ctx.r[12].u64 | 3940220928;
	// 823F3FA8: 60C600DD  ori r6, r6, 0xdd
	ctx.r[6].u64 = ctx.r[6].u64 | 221;
	// 823F3FAC: 618CEEF0  ori r12, r12, 0xeef0
	ctx.r[12].u64 = ctx.r[12].u64 | 61168;
	// 823F3FB0: 78C7000E  rldimi r7, r6, 0x20, 0
	ctx.r[7].u64 = ((ctx.r[6].u64).rotate_left(32) & 0xFFFFFFFF00000000) | (ctx.r[7].u64 & 0x00000000FFFFFFFF);
	// 823F3FB4: 7D686038  and r8, r11, r12
	ctx.r[8].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 823F3FB8: 7F283840  cmpld cr6, r8, r7
	ctx.cr[6].compare_u64(ctx.r[8].u64, ctx.r[7].u64, &mut ctx.xer);
	// 823F3FBC: 419A0018  beq cr6, 0x823f3fd4
	if ctx.cr[6].eq {
	pc = 0x823F3FD4; continue 'dispatch;
	}
	// 823F3FC0: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 823F3FC4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 823F3FC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F3FCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F3FD0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F3FD4; continue 'dispatch;
            }
            0x823F3FD4 => {
    //   block [0x823F3FD4..0x823F3FE8)
	// 823F3FD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F3FD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F3FDC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823F3FE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F3FE4: 4198FF98  blt cr6, 0x823f3f7c
	if ctx.cr[6].lt {
	pc = 0x823F3F7C; continue 'dispatch;
	}
	pc = 0x823F3FE8; continue 'dispatch;
            }
            0x823F3FE8 => {
    //   block [0x823F3FE8..0x823F3FFC)
	// 823F3FE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F3FEC: 48319281  bl 0x8270d26c
	ctx.lr = 0x823F3FF0;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F3FF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F3FF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F3FF8: 48141110  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4000 size=84
    let mut pc: u32 = 0x823F4000;
    'dispatch: loop {
        match pc {
            0x823F4000 => {
    //   block [0x823F4000..0x823F4040)
	// 823F4000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4004: 481410B5  bl 0x825350b8
	ctx.lr = 0x823F4008;
	sub_82535080(ctx, base);
	// 823F4008: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F400C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F4010: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F4014: 3BBF04F8  addi r29, r31, 0x4f8
	ctx.r[29].s64 = ctx.r[31].s64 + 1272;
	// 823F4018: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F401C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F4020: 4831923D  bl 0x8270d25c
	ctx.lr = 0x823F4024;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F4024: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F4028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F402C: 4BFFF4C5  bl 0x823f34f0
	ctx.lr = 0x823F4030;
	sub_823F34F0(ctx, base);
	// 823F4030: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4034: 4182000C  beq 0x823f4040
	if ctx.cr[0].eq {
	pc = 0x823F4040; continue 'dispatch;
	}
	// 823F4038: 48001571  bl 0x823f55a8
	ctx.lr = 0x823F403C;
	sub_823F55A8(ctx, base);
	// 823F403C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x823F4040; continue 'dispatch;
            }
            0x823F4040 => {
    //   block [0x823F4040..0x823F4054)
	// 823F4040: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F4044: 48319229  bl 0x8270d26c
	ctx.lr = 0x823F4048;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F4048: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F404C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F4050: 481410B8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4058 size=100
    let mut pc: u32 = 0x823F4058;
    'dispatch: loop {
        match pc {
            0x823F4058 => {
    //   block [0x823F4058..0x823F409C)
	// 823F4058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F405C: 4814105D  bl 0x825350b8
	ctx.lr = 0x823F4060;
	sub_82535080(ctx, base);
	// 823F4060: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F4068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F406C: 3B9F04F8  addi r28, r31, 0x4f8
	ctx.r[28].s64 = ctx.r[31].s64 + 1272;
	// 823F4070: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F4074: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F4078: 483191E5  bl 0x8270d25c
	ctx.lr = 0x823F407C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F407C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F4080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4084: 4BFFF46D  bl 0x823f34f0
	ctx.lr = 0x823F4088;
	sub_823F34F0(ctx, base);
	// 823F4088: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F408C: 40820010  bne 0x823f409c
	if !ctx.cr[0].eq {
	pc = 0x823F409C; continue 'dispatch;
	}
	// 823F4090: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F4094: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F4098: 48000010  b 0x823f40a8
	pc = 0x823F40A8; continue 'dispatch;
            }
            0x823F409C => {
    //   block [0x823F409C..0x823F40A8)
	// 823F409C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F40A0: 48000A49  bl 0x823f4ae8
	ctx.lr = 0x823F40A4;
	sub_823F4AE8(ctx, base);
	// 823F40A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F40A8; continue 'dispatch;
            }
            0x823F40A8 => {
    //   block [0x823F40A8..0x823F40BC)
	// 823F40A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F40AC: 483191C1  bl 0x8270d26c
	ctx.lr = 0x823F40B0;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F40B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F40B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F40B8: 48141050  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F40C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F40C0 size=132
    let mut pc: u32 = 0x823F40C0;
    'dispatch: loop {
        match pc {
            0x823F40C0 => {
    //   block [0x823F40C0..0x823F4114)
	// 823F40C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F40C4: 48140FE5  bl 0x825350a8
	ctx.lr = 0x823F40C8;
	sub_82535080(ctx, base);
	// 823F40C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F40CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F40D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F40D4: 3B1F04F8  addi r24, r31, 0x4f8
	ctx.r[24].s64 = ctx.r[31].s64 + 1272;
	// 823F40D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F40DC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823F40E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F40E4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823F40E8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 823F40EC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 823F40F0: 4831916D  bl 0x8270d25c
	ctx.lr = 0x823F40F4;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F40F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F40F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F40FC: 4BFFF3F5  bl 0x823f34f0
	ctx.lr = 0x823F4100;
	sub_823F34F0(ctx, base);
	// 823F4100: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4104: 40820010  bne 0x823f4114
	if !ctx.cr[0].eq {
	pc = 0x823F4114; continue 'dispatch;
	}
	// 823F4108: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F410C: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F4110: 48000020  b 0x823f4130
	pc = 0x823F4130; continue 'dispatch;
            }
            0x823F4114 => {
    //   block [0x823F4114..0x823F4130)
	// 823F4114: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 823F4118: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 823F411C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823F4120: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F4124: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F4128: 48000AC9  bl 0x823f4bf0
	ctx.lr = 0x823F412C;
	sub_823F4BF0(ctx, base);
	// 823F412C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F4130; continue 'dispatch;
            }
            0x823F4130 => {
    //   block [0x823F4130..0x823F4144)
	// 823F4130: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823F4134: 48319139  bl 0x8270d26c
	ctx.lr = 0x823F4138;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F4138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F413C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F4140: 48140FB8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4148 size=108
    let mut pc: u32 = 0x823F4148;
    'dispatch: loop {
        match pc {
            0x823F4148 => {
    //   block [0x823F4148..0x823F4190)
	// 823F4148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F414C: 48140F69  bl 0x825350b4
	ctx.lr = 0x823F4150;
	sub_82535080(ctx, base);
	// 823F4150: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F4158: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F415C: 3B7F04F8  addi r27, r31, 0x4f8
	ctx.r[27].s64 = ctx.r[31].s64 + 1272;
	// 823F4160: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F4164: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F4168: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F416C: 483190F1  bl 0x8270d25c
	ctx.lr = 0x823F4170;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F4170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F4174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4178: 4BFFF379  bl 0x823f34f0
	ctx.lr = 0x823F417C;
	sub_823F34F0(ctx, base);
	// 823F417C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4180: 40820010  bne 0x823f4190
	if !ctx.cr[0].eq {
	pc = 0x823F4190; continue 'dispatch;
	}
	// 823F4184: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F4188: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F418C: 48000014  b 0x823f41a0
	pc = 0x823F41A0; continue 'dispatch;
            }
            0x823F4190 => {
    //   block [0x823F4190..0x823F41A0)
	// 823F4190: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F4194: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F4198: 480013E9  bl 0x823f5580
	ctx.lr = 0x823F419C;
	sub_823F5580(ctx, base);
	// 823F419C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F41A0; continue 'dispatch;
            }
            0x823F41A0 => {
    //   block [0x823F41A0..0x823F41B4)
	// 823F41A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F41A4: 483190C9  bl 0x8270d26c
	ctx.lr = 0x823F41A8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F41A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F41AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F41B0: 48140F54  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F41B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F41B8 size=108
    let mut pc: u32 = 0x823F41B8;
    'dispatch: loop {
        match pc {
            0x823F41B8 => {
    //   block [0x823F41B8..0x823F4200)
	// 823F41B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F41BC: 48140EF9  bl 0x825350b4
	ctx.lr = 0x823F41C0;
	sub_82535080(ctx, base);
	// 823F41C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F41C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F41C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F41CC: 3B7F04F8  addi r27, r31, 0x4f8
	ctx.r[27].s64 = ctx.r[31].s64 + 1272;
	// 823F41D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F41D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F41D8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F41DC: 48319081  bl 0x8270d25c
	ctx.lr = 0x823F41E0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 823F41E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F41E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F41E8: 4BFFF309  bl 0x823f34f0
	ctx.lr = 0x823F41EC;
	sub_823F34F0(ctx, base);
	// 823F41EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F41F0: 40820010  bne 0x823f4200
	if !ctx.cr[0].eq {
	pc = 0x823F4200; continue 'dispatch;
	}
	// 823F41F4: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F41F8: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F41FC: 48000014  b 0x823f4210
	pc = 0x823F4210; continue 'dispatch;
            }
            0x823F4200 => {
    //   block [0x823F4200..0x823F4210)
	// 823F4200: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F4204: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F4208: 48001301  bl 0x823f5508
	ctx.lr = 0x823F420C;
	sub_823F5508(ctx, base);
	// 823F420C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x823F4210; continue 'dispatch;
            }
            0x823F4210 => {
    //   block [0x823F4210..0x823F4224)
	// 823F4210: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F4214: 48319059  bl 0x8270d26c
	ctx.lr = 0x823F4218;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 823F4218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F421C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F4220: 48140EE4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4228 size=176
    let mut pc: u32 = 0x823F4228;
    'dispatch: loop {
        match pc {
            0x823F4228 => {
    //   block [0x823F4228..0x823F426C)
	// 823F4228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F422C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F4230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F4234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F4238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F423C: 3D60FFFE  lis r11, -2
	ctx.r[11].s64 = -131072;
	// 823F4240: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F4244: 616B7960  ori r11, r11, 0x7960
	ctx.r[11].u64 = ctx.r[11].u64 | 31072;
	// 823F4248: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F424C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F4250: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F4254: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823F4258: 48152351  bl 0x825465a8
	ctx.lr = 0x823F425C;
	sub_825465A8(ctx, base);
	// 823F425C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F4260: 4082000C  bne 0x823f426c
	if !ctx.cr[0].eq {
	pc = 0x823F426C; continue 'dispatch;
	}
	// 823F4264: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823F4268: 48152319  bl 0x82546580
	ctx.lr = 0x823F426C;
	sub_82546580(ctx, base);
	pc = 0x823F426C; continue 'dispatch;
            }
            0x823F426C => {
    //   block [0x823F426C..0x823F4298)
	// 823F426C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F4270: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F4274: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F4278: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 823F427C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F4280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4284: 48152295  bl 0x82546518
	ctx.lr = 0x823F4288;
	sub_82546518(ctx, base);
	// 823F4288: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F428C: 4082000C  bne 0x823f4298
	if !ctx.cr[0].eq {
	pc = 0x823F4298; continue 'dispatch;
	}
	// 823F4290: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823F4294: 481522ED  bl 0x82546580
	ctx.lr = 0x823F4298;
	sub_82546580(ctx, base);
	pc = 0x823F4298; continue 'dispatch;
            }
            0x823F4298 => {
    //   block [0x823F4298..0x823F42A4)
	// 823F4298: 807E0518  lwz r3, 0x518(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1304 as u32) ) } as u64;
	// 823F429C: 4BFCD285  bl 0x823c1520
	ctx.lr = 0x823F42A0;
	sub_823C1520(ctx, base);
	// 823F42A0: 48000014  b 0x823f42b4
	pc = 0x823F42B4; continue 'dispatch;
            }
            0x823F42A4 => {
    //   block [0x823F42A4..0x823F42B4)
	// 823F42A4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 823F42A8: 4BFCD271  bl 0x823c1518
	ctx.lr = 0x823F42AC;
	sub_823C1518(ctx, base);
	// 823F42AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F42B0: 4BFFF8D1  bl 0x823f3b80
	ctx.lr = 0x823F42B4;
	sub_823F3B80(ctx, base);
	pc = 0x823F42B4; continue 'dispatch;
            }
            0x823F42B4 => {
    //   block [0x823F42B4..0x823F42D8)
	// 823F42B4: 817E0514  lwz r11, 0x514(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1300 as u32) ) } as u64;
	// 823F42B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F42BC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 823F42C0: 409AFFE4  bne cr6, 0x823f42a4
	if !ctx.cr[6].eq {
	pc = 0x823F42A4; continue 'dispatch;
	}
	// 823F42C4: 48152215  bl 0x825464d8
	ctx.lr = 0x823F42C8;
	sub_825464D8(ctx, base);
	// 823F42C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F42CC: 4BFCC68D  bl 0x823c0958
	ctx.lr = 0x823F42D0;
	sub_823C0958(ctx, base);
	// 823F42D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F42D4: 481522AD  bl 0x82546580
	ctx.lr = 0x823F42D8;
	sub_82546580(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F42D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F42D8 size=288
    let mut pc: u32 = 0x823F42D8;
    'dispatch: loop {
        match pc {
            0x823F42D8 => {
    //   block [0x823F42D8..0x823F43F4)
	// 823F42D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F42DC: 48140DB5  bl 0x82535090
	ctx.lr = 0x823F42E0;
	sub_82535080(ctx, base);
	// 823F42E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F42E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F42E8: 409A010C  bne cr6, 0x823f43f4
	if !ctx.cr[6].eq {
	pc = 0x823F43F4; continue 'dispatch;
	}
	// 823F42EC: 3E40823F  lis r18, -0x7dc1
	ctx.r[18].s64 = -2109800448;
	// 823F42F0: 3E60823F  lis r19, -0x7dc1
	ctx.r[19].s64 = -2109800448;
	// 823F42F4: 3E80823F  lis r20, -0x7dc1
	ctx.r[20].s64 = -2109800448;
	// 823F42F8: 3EA0823F  lis r21, -0x7dc1
	ctx.r[21].s64 = -2109800448;
	// 823F42FC: 3EC0823F  lis r22, -0x7dc1
	ctx.r[22].s64 = -2109800448;
	// 823F4300: 3EE0823F  lis r23, -0x7dc1
	ctx.r[23].s64 = -2109800448;
	// 823F4304: 3F00823F  lis r24, -0x7dc1
	ctx.r[24].s64 = -2109800448;
	// 823F4308: 3F20823F  lis r25, -0x7dc1
	ctx.r[25].s64 = -2109800448;
	// 823F430C: 3F40823F  lis r26, -0x7dc1
	ctx.r[26].s64 = -2109800448;
	// 823F4310: 3F60823F  lis r27, -0x7dc1
	ctx.r[27].s64 = -2109800448;
	// 823F4314: 3F80823F  lis r28, -0x7dc1
	ctx.r[28].s64 = -2109800448;
	// 823F4318: 3FA0823F  lis r29, -0x7dc1
	ctx.r[29].s64 = -2109800448;
	// 823F431C: 3FC0823F  lis r30, -0x7dc1
	ctx.r[30].s64 = -2109800448;
	// 823F4320: 3FE0823F  lis r31, -0x7dc1
	ctx.r[31].s64 = -2109800448;
	// 823F4324: 3C80823F  lis r4, -0x7dc1
	ctx.r[4].s64 = -2109800448;
	// 823F4328: 3CA0823F  lis r5, -0x7dc1
	ctx.r[5].s64 = -2109800448;
	// 823F432C: 3CC0823F  lis r6, -0x7dc1
	ctx.r[6].s64 = -2109800448;
	// 823F4330: 3CE0823F  lis r7, -0x7dc1
	ctx.r[7].s64 = -2109800448;
	// 823F4334: 3D00823F  lis r8, -0x7dc1
	ctx.r[8].s64 = -2109800448;
	// 823F4338: 3D20823F  lis r9, -0x7dc1
	ctx.r[9].s64 = -2109800448;
	// 823F433C: 3D40823F  lis r10, -0x7dc1
	ctx.r[10].s64 = -2109800448;
	// 823F4340: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F4344: 3A522958  addi r18, r18, 0x2958
	ctx.r[18].s64 = ctx.r[18].s64 + 10584;
	// 823F4348: 3A733B28  addi r19, r19, 0x3b28
	ctx.r[19].s64 = ctx.r[19].s64 + 15144;
	// 823F434C: 3A943110  addi r20, r20, 0x3110
	ctx.r[20].s64 = ctx.r[20].s64 + 12560;
	// 823F4350: 3AB53198  addi r21, r21, 0x3198
	ctx.r[21].s64 = ctx.r[21].s64 + 12696;
	// 823F4354: 3AD63208  addi r22, r22, 0x3208
	ctx.r[22].s64 = ctx.r[22].s64 + 12808;
	// 823F4358: 3AF73CF8  addi r23, r23, 0x3cf8
	ctx.r[23].s64 = ctx.r[23].s64 + 15608;
	// 823F435C: 92430000  stw r18, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 823F4360: 3B183D68  addi r24, r24, 0x3d68
	ctx.r[24].s64 = ctx.r[24].s64 + 15720;
	// 823F4364: 92630004  stw r19, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[19].u32 ) };
	// 823F4368: 3B393278  addi r25, r25, 0x3278
	ctx.r[25].s64 = ctx.r[25].s64 + 12920;
	// 823F436C: 92830008  stw r20, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 823F4370: 3B5A32A0  addi r26, r26, 0x32a0
	ctx.r[26].s64 = ctx.r[26].s64 + 12960;
	// 823F4374: 92A3000C  stw r21, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[21].u32 ) };
	// 823F4378: 3B7B3358  addi r27, r27, 0x3358
	ctx.r[27].s64 = ctx.r[27].s64 + 13144;
	// 823F437C: 92C30010  stw r22, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[22].u32 ) };
	// 823F4380: 3B9C3DD8  addi r28, r28, 0x3dd8
	ctx.r[28].s64 = ctx.r[28].s64 + 15832;
	// 823F4384: 92E30014  stw r23, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[23].u32 ) };
	// 823F4388: 3BBD3EE0  addi r29, r29, 0x3ee0
	ctx.r[29].s64 = ctx.r[29].s64 + 16096;
	// 823F438C: 93030018  stw r24, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 823F4390: 3BDE3F40  addi r30, r30, 0x3f40
	ctx.r[30].s64 = ctx.r[30].s64 + 16192;
	// 823F4394: 9323001C  stw r25, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	// 823F4398: 3BFF33E0  addi r31, r31, 0x33e0
	ctx.r[31].s64 = ctx.r[31].s64 + 13280;
	// 823F439C: 93430020  stw r26, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 823F43A0: 38843438  addi r4, r4, 0x3438
	ctx.r[4].s64 = ctx.r[4].s64 + 13368;
	// 823F43A4: 93630024  stw r27, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[27].u32 ) };
	// 823F43A8: 38A54000  addi r5, r5, 0x4000
	ctx.r[5].s64 = ctx.r[5].s64 + 16384;
	// 823F43AC: 93830028  stw r28, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	// 823F43B0: 38C64058  addi r6, r6, 0x4058
	ctx.r[6].s64 = ctx.r[6].s64 + 16472;
	// 823F43B4: 93A3002C  stw r29, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 823F43B8: 38E740C0  addi r7, r7, 0x40c0
	ctx.r[7].s64 = ctx.r[7].s64 + 16576;
	// 823F43BC: 93C30030  stw r30, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 823F43C0: 39083468  addi r8, r8, 0x3468
	ctx.r[8].s64 = ctx.r[8].s64 + 13416;
	// 823F43C4: 93E30034  stw r31, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 823F43C8: 39293470  addi r9, r9, 0x3470
	ctx.r[9].s64 = ctx.r[9].s64 + 13424;
	// 823F43CC: 90830038  stw r4, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[4].u32 ) };
	// 823F43D0: 394A4148  addi r10, r10, 0x4148
	ctx.r[10].s64 = ctx.r[10].s64 + 16712;
	// 823F43D4: 90A3003C  stw r5, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[5].u32 ) };
	// 823F43D8: 396B41B8  addi r11, r11, 0x41b8
	ctx.r[11].s64 = ctx.r[11].s64 + 16824;
	// 823F43DC: 90C30040  stw r6, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[6].u32 ) };
	// 823F43E0: 90E30044  stw r7, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[7].u32 ) };
	// 823F43E4: 91030048  stw r8, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[8].u32 ) };
	// 823F43E8: 9123004C  stw r9, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 823F43EC: 91430050  stw r10, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 823F43F0: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x823F43F4; continue 'dispatch;
            }
            0x823F43F4 => {
    //   block [0x823F43F4..0x823F43F8)
	// 823F43F4: 48140CEC  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F43F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F43F8 size=512
    let mut pc: u32 = 0x823F43F8;
    'dispatch: loop {
        match pc {
            0x823F43F8 => {
    //   block [0x823F43F8..0x823F4444)
	// 823F43F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F43FC: 48140CAD  bl 0x825350a8
	ctx.lr = 0x823F4400;
	sub_82535080(ctx, base);
	// 823F4400: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4404: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F4408: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823F440C: 3BAB3718  addi r29, r11, 0x3718
	ctx.r[29].s64 = ctx.r[11].s64 + 14104;
	// 823F4410: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 823F4414: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F4418: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F441C: 4BFFFEBD  bl 0x823f42d8
	ctx.lr = 0x823F4420;
	sub_823F42D8(ctx, base);
	// 823F4420: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F4424: 386008C0  li r3, 0x8c0
	ctx.r[3].s64 = 2240;
	// 823F4428: 6084800C  ori r4, r4, 0x800c
	ctx.r[4].u64 = ctx.r[4].u64 | 32780;
	// 823F442C: 4BFD5D95  bl 0x823ca1c0
	ctx.lr = 0x823F4430;
	sub_823CA1C0(ctx, base);
	// 823F4430: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F4434: 40820010  bne 0x823f4444
	if !ctx.cr[0].eq {
	pc = 0x823F4444; continue 'dispatch;
	}
	// 823F4438: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F443C: 639C000E  ori r28, r28, 0xe
	ctx.r[28].u64 = ctx.r[28].u64 | 14;
	// 823F4440: 480001A8  b 0x823f45e8
	pc = 0x823F45E8; continue 'dispatch;
            }
            0x823F4444 => {
    //   block [0x823F4444..0x823F4488)
	// 823F4444: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 823F4448: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F444C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 823F4450: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 823F4454: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F4458: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 823F445C: 481406F5  bl 0x82534b50
	ctx.lr = 0x823F4460;
	sub_82534B50(ctx, base);
	// 823F4460: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F4464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4468: 4BFFE799  bl 0x823f2c00
	ctx.lr = 0x823F446C;
	sub_823F2C00(ctx, base);
	// 823F446C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F4470: 4180016C  blt 0x823f45dc
	if ctx.cr[0].lt {
	pc = 0x823F45DC; continue 'dispatch;
	}
	// 823F4474: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F4478: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F447C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F4480: 40990038  ble cr6, 0x823f44b8
	if !ctx.cr[6].gt {
	pc = 0x823F44B8; continue 'dispatch;
	}
	// 823F4484: 3BBF0448  addi r29, r31, 0x448
	ctx.r[29].s64 = ctx.r[31].s64 + 1096;
	pc = 0x823F4488; continue 'dispatch;
            }
            0x823F4488 => {
    //   block [0x823F4488..0x823F44B8)
	// 823F4488: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823F448C: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F4490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4494: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4498: 48003B89  bl 0x823f8020
	ctx.lr = 0x823F449C;
	sub_823F8020(ctx, base);
	// 823F449C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F44A0: 4180013C  blt 0x823f45dc
	if ctx.cr[0].lt {
	pc = 0x823F45DC; continue 'dispatch;
	}
	// 823F44A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F44A8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823F44AC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823F44B0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F44B4: 4198FFD4  blt cr6, 0x823f4488
	if ctx.cr[6].lt {
	pc = 0x823F4488; continue 'dispatch;
	}
	pc = 0x823F44B8; continue 'dispatch;
            }
            0x823F44B8 => {
    //   block [0x823F44B8..0x823F44CC)
	// 823F44B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F44BC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F44C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F44C4: 40990040  ble cr6, 0x823f4504
	if !ctx.cr[6].gt {
	pc = 0x823F4504; continue 'dispatch;
	}
	// 823F44C8: 3BBF0468  addi r29, r31, 0x468
	ctx.r[29].s64 = ctx.r[31].s64 + 1128;
	pc = 0x823F44CC; continue 'dispatch;
            }
            0x823F44CC => {
    //   block [0x823F44CC..0x823F4504)
	// 823F44CC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 823F44D0: 80FE0028  lwz r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F44D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F44D8: 80DE0024  lwz r6, 0x24(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F44DC: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F44E0: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F44E4: 4800123D  bl 0x823f5720
	ctx.lr = 0x823F44E8;
	sub_823F5720(ctx, base);
	// 823F44E8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F44EC: 418000F0  blt 0x823f45dc
	if ctx.cr[0].lt {
	pc = 0x823F45DC; continue 'dispatch;
	}
	// 823F44F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F44F4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823F44F8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823F44FC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F4500: 4198FFCC  blt cr6, 0x823f44cc
	if ctx.cr[6].lt {
	pc = 0x823F44CC; continue 'dispatch;
	}
	pc = 0x823F4504; continue 'dispatch;
            }
            0x823F4504 => {
    //   block [0x823F4504..0x823F4524)
	// 823F4504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F4508: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F450C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F4510: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F4514: 4BFCCF65  bl 0x823c1478
	ctx.lr = 0x823F4518;
	sub_823C1478(ctx, base);
	// 823F4518: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F451C: 907F0518  stw r3, 0x518(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1304 as u32), ctx.r[3].u32 ) };
	// 823F4520: 40820010  bne 0x823f4530
	if !ctx.cr[0].eq {
	pc = 0x823F4530; continue 'dispatch;
	}
	pc = 0x823F4524; continue 'dispatch;
            }
            0x823F4524 => {
    //   block [0x823F4524..0x823F4530)
	// 823F4524: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 823F4528: 639C4005  ori r28, r28, 0x4005
	ctx.r[28].u64 = ctx.r[28].u64 | 16389;
	// 823F452C: 480000B0  b 0x823f45dc
	pc = 0x823F45DC; continue 'dispatch;
            }
            0x823F4530 => {
    //   block [0x823F4530..0x823F45D4)
	// 823F4530: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 823F4534: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 823F4538: 48318C65  bl 0x8270d19c
	ctx.lr = 0x823F453C;
	// extern call 0x8270D19C  crate::xam::XamNotifyCreateListener
	crate::xam::XamNotifyCreateListener(ctx, base);
	// 823F453C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4540: 907F0520  stw r3, 0x520(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1312 as u32), ctx.r[3].u32 ) };
	// 823F4544: 4182FFE0  beq 0x823f4524
	if ctx.cr[0].eq {
	pc = 0x823F4524; continue 'dispatch;
	}
	// 823F4548: 387F04F8  addi r3, r31, 0x4f8
	ctx.r[3].s64 = ctx.r[31].s64 + 1272;
	// 823F454C: 935F0524  stw r26, 0x524(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1316 as u32), ctx.r[26].u32 ) };
	// 823F4550: 48318D3D  bl 0x8270d28c
	ctx.lr = 0x823F4554;
	// extern call 0x8270D28C  crate::xboxkrnl::RtlInitializeCriticalSection
	crate::xboxkrnl::RtlInitializeCriticalSection(ctx, base);
	// 823F4554: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4558: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F455C: 409A0078  bne cr6, 0x823f45d4
	if !ctx.cr[6].eq {
	pc = 0x823F45D4; continue 'dispatch;
	}
	// 823F4560: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F4564: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F4568: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823F456C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F4570: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823F4574: 38AB4228  addi r5, r11, 0x4228
	ctx.r[5].s64 = ctx.r[11].s64 + 16936;
	// 823F4578: 3C800001  lis r4, 1
	ctx.r[4].s64 = 65536;
	// 823F457C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F4580: 4BFD9451  bl 0x823cd9d0
	ctx.lr = 0x823F4584;
	sub_823CD9D0(ctx, base);
	// 823F4584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4588: 907F04F0  stw r3, 0x4f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1264 as u32), ctx.r[3].u32 ) };
	// 823F458C: 4182FF98  beq 0x823f4524
	if ctx.cr[0].eq {
	pc = 0x823F4524; continue 'dispatch;
	}
	// 823F4590: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 823F4594: 807F0518  lwz r3, 0x518(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1304 as u32) ) } as u64;
	// 823F4598: 4BFCCF81  bl 0x823c1518
	ctx.lr = 0x823F459C;
	sub_823C1518(ctx, base);
	// 823F459C: 80D90004  lwz r6, 4(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F45A0: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F45A4: 41820030  beq 0x823f45d4
	if ctx.cr[0].eq {
	pc = 0x823F45D4; continue 'dispatch;
	}
	// 823F45A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F45AC: 809F04F0  lwz r4, 0x4f0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1264 as u32) ) } as u64;
	// 823F45B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F45B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F45B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F45BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F45C0: 48152071  bl 0x82546630
	ctx.lr = 0x823F45C4;
	sub_82546630(ctx, base);
	// 823F45C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F45C8: 4082000C  bne 0x823f45d4
	if !ctx.cr[0].eq {
	pc = 0x823F45D4; continue 'dispatch;
	}
	// 823F45CC: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 823F45D0: 639C4005  ori r28, r28, 0x4005
	ctx.r[28].u64 = ctx.r[28].u64 | 16389;
	pc = 0x823F45D4; continue 'dispatch;
            }
            0x823F45D4 => {
    //   block [0x823F45D4..0x823F45DC)
	// 823F45D4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F45D8: 40980010  bge cr6, 0x823f45e8
	if !ctx.cr[6].lt {
	pc = 0x823F45E8; continue 'dispatch;
	}
	pc = 0x823F45DC; continue 'dispatch;
            }
            0x823F45DC => {
    //   block [0x823F45DC..0x823F45E8)
	// 823F45DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F45E0: 4BFFF549  bl 0x823f3b28
	ctx.lr = 0x823F45E4;
	sub_823F3B28(ctx, base);
	// 823F45E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823F45E8; continue 'dispatch;
            }
            0x823F45E8 => {
    //   block [0x823F45E8..0x823F45F8)
	// 823F45E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F45EC: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F45F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F45F4: 48140B04  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F45F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F45F8 size=40
    let mut pc: u32 = 0x823F45F8;
    'dispatch: loop {
        match pc {
            0x823F45F8 => {
    //   block [0x823F45F8..0x823F4620)
	// 823F45F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823F45FC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823F4600: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F4604: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F4608: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F460C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F4610: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F4614: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 823F4618: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 823F461C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F4620 size=40
    let mut pc: u32 = 0x823F4620;
    'dispatch: loop {
        match pc {
            0x823F4620 => {
    //   block [0x823F4620..0x823F4648)
	// 823F4620: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823F4624: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F4628: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F462C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F4630: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4634: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F4638: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 823F463C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F4640: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 823F4644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4648 size=144
    let mut pc: u32 = 0x823F4648;
    'dispatch: loop {
        match pc {
            0x823F4648 => {
    //   block [0x823F4648..0x823F4674)
	// 823F4648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F464C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F4650: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4654: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F4658: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F465C: 409A0068  bne cr6, 0x823f46c4
	if !ctx.cr[6].eq {
	pc = 0x823F46C4; continue 'dispatch;
	}
	// 823F4660: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4664: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4668: 4182005C  beq 0x823f46c4
	if ctx.cr[0].eq {
	pc = 0x823F46C4; continue 'dispatch;
	}
	// 823F466C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F4670: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	pc = 0x823F4674; continue 'dispatch;
            }
            0x823F4674 => {
    //   block [0x823F4674..0x823F468C)
	// 823F4674: 810BFFF8  lwz r8, -8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F4678: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F467C: 419A0010  beq cr6, 0x823f468c
	if ctx.cr[6].eq {
	pc = 0x823F468C; continue 'dispatch;
	}
	// 823F4680: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4684: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 823F4688: 419A002C  beq cr6, 0x823f46b4
	if ctx.cr[6].eq {
	pc = 0x823F46B4; continue 'dispatch;
	}
	pc = 0x823F468C; continue 'dispatch;
            }
            0x823F468C => {
    //   block [0x823F468C..0x823F46A0)
	// 823F468C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F4690: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F4694: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823F4698: 4198FFDC  blt cr6, 0x823f4674
	if ctx.cr[6].lt {
	pc = 0x823F4674; continue 'dispatch;
	}
	// 823F469C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823F46A0; continue 'dispatch;
            }
            0x823F46A0 => {
    //   block [0x823F46A0..0x823F46B4)
	// 823F46A0: 39630000  addi r11, r3, 0
	ctx.r[11].s64 = ctx.r[3].s64 + 0;
	// 823F46A4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F46A8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F46AC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 823F46B0: 48000018  b 0x823f46c8
	pc = 0x823F46C8; continue 'dispatch;
            }
            0x823F46B4 => {
    //   block [0x823F46B4..0x823F46C4)
	// 823F46B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F46B8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 823F46BC: 480019A5  bl 0x823f6060
	ctx.lr = 0x823F46C0;
	sub_823F6060(ctx, base);
	// 823F46C0: 4BFFFFE0  b 0x823f46a0
	pc = 0x823F46A0; continue 'dispatch;
            }
            0x823F46C4 => {
    //   block [0x823F46C4..0x823F46C8)
	// 823F46C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823F46C8; continue 'dispatch;
            }
            0x823F46C8 => {
    //   block [0x823F46C8..0x823F46D8)
	// 823F46C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F46CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F46D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F46D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F46D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F46D8 size=40
    let mut pc: u32 = 0x823F46D8;
    'dispatch: loop {
        match pc {
            0x823F46D8 => {
    //   block [0x823F46D8..0x823F46EC)
	// 823F46D8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823F46DC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823F46E0: 409A000C  bne cr6, 0x823f46ec
	if !ctx.cr[6].eq {
	pc = 0x823F46EC; continue 'dispatch;
	}
	// 823F46E4: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F46E8: 48000010  b 0x823f46f8
	pc = 0x823F46F8; continue 'dispatch;
            }
            0x823F46EC => {
    //   block [0x823F46EC..0x823F46F8)
	// 823F46EC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823F46F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F46F4: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	pc = 0x823F46F8; continue 'dispatch;
            }
            0x823F46F8 => {
    //   block [0x823F46F8..0x823F4700)
	// 823F46F8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823F46FC: 48001A04  b 0x823f6100
	sub_823F6100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4700 size=292
    let mut pc: u32 = 0x823F4700;
    'dispatch: loop {
        match pc {
            0x823F4700 => {
    //   block [0x823F4700..0x823F4720)
	// 823F4700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4704: 481409B1  bl 0x825350b4
	ctx.lr = 0x823F4708;
	sub_82535080(ctx, base);
	// 823F4708: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F470C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F4710: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F4714: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F4718: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 823F471C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	pc = 0x823F4720; continue 'dispatch;
            }
            0x823F4720 => {
    //   block [0x823F4720..0x823F4738)
	// 823F4720: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F4724: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F4728: 419A0010  beq cr6, 0x823f4738
	if ctx.cr[6].eq {
	pc = 0x823F4738; continue 'dispatch;
	}
	// 823F472C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4730: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 823F4734: 419A0030  beq cr6, 0x823f4764
	if ctx.cr[6].eq {
	pc = 0x823F4764; continue 'dispatch;
	}
	pc = 0x823F4738; continue 'dispatch;
            }
            0x823F4738 => {
    //   block [0x823F4738..0x823F474C)
	// 823F4738: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F473C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F4740: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823F4744: 4198FFDC  blt cr6, 0x823f4720
	if ctx.cr[6].lt {
	pc = 0x823F4720; continue 'dispatch;
	}
	// 823F4748: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	pc = 0x823F474C; continue 'dispatch;
            }
            0x823F474C => {
    //   block [0x823F474C..0x823F4764)
	// 823F474C: 7FDD2050  subf r30, r29, r4
	ctx.r[30].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 823F4750: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 823F4754: 419A004C  beq cr6, 0x823f47a0
	if ctx.cr[6].eq {
	pc = 0x823F47A0; continue 'dispatch;
	}
	// 823F4758: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F475C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4760: 48000038  b 0x823f4798
	pc = 0x823F4798; continue 'dispatch;
            }
            0x823F4764 => {
    //   block [0x823F4764..0x823F476C)
	// 823F4764: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 823F4768: 4BFFFFE4  b 0x823f474c
	pc = 0x823F474C; continue 'dispatch;
            }
            0x823F476C => {
    //   block [0x823F476C..0x823F4798)
	// 823F476C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 823F4770: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F4774: 419A002C  beq cr6, 0x823f47a0
	if ctx.cr[6].eq {
	pc = 0x823F47A0; continue 'dispatch;
	}
	// 823F4778: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F477C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 823F4780: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4784: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F4788: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F478C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F4790: 480018F1  bl 0x823f6080
	ctx.lr = 0x823F4794;
	sub_823F6080(ctx, base);
	// 823F4794: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	pc = 0x823F4798; continue 'dispatch;
            }
            0x823F4798 => {
    //   block [0x823F4798..0x823F47A0)
	// 823F4798: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F479C: 409AFFD0  bne cr6, 0x823f476c
	if !ctx.cr[6].eq {
	pc = 0x823F476C; continue 'dispatch;
	}
	pc = 0x823F47A0; continue 'dispatch;
            }
            0x823F47A0 => {
    //   block [0x823F47A0..0x823F47D0)
	// 823F47A0: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 823F47A4: 409A0034  bne cr6, 0x823f47d8
	if !ctx.cr[6].eq {
	pc = 0x823F47D8; continue 'dispatch;
	}
	// 823F47A8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F47AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F47B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F47B4: 4182001C  beq 0x823f47d0
	if ctx.cr[0].eq {
	pc = 0x823F47D0; continue 'dispatch;
	}
	// 823F47B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F47BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F47C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F47C4: 4E800421  bctrl
	ctx.lr = 0x823F47C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F47C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823F47CC: 4800004C  b 0x823f4818
	pc = 0x823F4818; continue 'dispatch;
            }
            0x823F47D0 => {
    //   block [0x823F47D0..0x823F47D8)
	// 823F47D0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 823F47D4: 48000044  b 0x823f4818
	pc = 0x823F4818; continue 'dispatch;
            }
            0x823F47D8 => {
    //   block [0x823F47D8..0x823F47E4)
	// 823F47D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F47DC: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F47E0: 48000030  b 0x823f4810
	pc = 0x823F4810; continue 'dispatch;
            }
            0x823F47E4 => {
    //   block [0x823F47E4..0x823F4810)
	// 823F47E4: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 823F47E8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F47EC: 419A002C  beq cr6, 0x823f4818
	if ctx.cr[6].eq {
	pc = 0x823F4818; continue 'dispatch;
	}
	// 823F47F0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F47F4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 823F47F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F47FC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F4800: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F4804: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F4808: 48001879  bl 0x823f6080
	ctx.lr = 0x823F480C;
	sub_823F6080(ctx, base);
	// 823F480C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	pc = 0x823F4810; continue 'dispatch;
            }
            0x823F4810 => {
    //   block [0x823F4810..0x823F4818)
	// 823F4810: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F4814: 409AFFD0  bne cr6, 0x823f47e4
	if !ctx.cr[6].eq {
	pc = 0x823F47E4; continue 'dispatch;
	}
	pc = 0x823F4818; continue 'dispatch;
            }
            0x823F4818 => {
    //   block [0x823F4818..0x823F4824)
	// 823F4818: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F481C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F4820: 481408E4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4828 size=304
    let mut pc: u32 = 0x823F4828;
    'dispatch: loop {
        match pc {
            0x823F4828 => {
    //   block [0x823F4828..0x823F4854)
	// 823F4828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F482C: 48140885  bl 0x825350b0
	ctx.lr = 0x823F4830;
	sub_82535080(ctx, base);
	// 823F4830: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4834: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823F4838: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F483C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823F4840: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 823F4844: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F4848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F484C: 419A0008  beq cr6, 0x823f4854
	if ctx.cr[6].eq {
	pc = 0x823F4854; continue 'dispatch;
	}
	// 823F4850: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823F4854; continue 'dispatch;
            }
            0x823F4854 => {
    //   block [0x823F4854..0x823F4860)
	// 823F4854: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F4858: 419A0008  beq cr6, 0x823f4860
	if ctx.cr[6].eq {
	pc = 0x823F4860; continue 'dispatch;
	}
	// 823F485C: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823F4860; continue 'dispatch;
            }
            0x823F4860 => {
    //   block [0x823F4860..0x823F48A4)
	// 823F4860: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F4864: 3D20C000  lis r9, -0x4000
	ctx.r[9].s64 = -1073741824;
	// 823F4868: 613F0001  ori r31, r9, 1
	ctx.r[31].u64 = ctx.r[9].u64 | 1;
	// 823F486C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4870: 41820054  beq 0x823f48c4
	if ctx.cr[0].eq {
	pc = 0x823F48C4; continue 'dispatch;
	}
	// 823F4874: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F487C: 419A0028  beq cr6, 0x823f48a4
	if ctx.cr[6].eq {
	pc = 0x823F48A4; continue 'dispatch;
	}
	// 823F4880: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F4884: 419A0040  beq cr6, 0x823f48c4
	if ctx.cr[6].eq {
	pc = 0x823F48C4; continue 'dispatch;
	}
	// 823F4888: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F488C: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F4890: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4894: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F4898: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F489C: 480017E5  bl 0x823f6080
	ctx.lr = 0x823F48A0;
	sub_823F6080(ctx, base);
	// 823F48A0: 48000024  b 0x823f48c4
	pc = 0x823F48C4; continue 'dispatch;
            }
            0x823F48A4 => {
    //   block [0x823F48A4..0x823F48AC)
	// 823F48A4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F48A8: 419A001C  beq cr6, 0x823f48c4
	if ctx.cr[6].eq {
	pc = 0x823F48C4; continue 'dispatch;
	}
	pc = 0x823F48AC; continue 'dispatch;
            }
            0x823F48AC => {
    //   block [0x823F48AC..0x823F48C4)
	// 823F48AC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F48B0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F48B4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F48B8: 480017C9  bl 0x823f6080
	ctx.lr = 0x823F48BC;
	sub_823F6080(ctx, base);
	// 823F48BC: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823F48C0: 4082FFEC  bne 0x823f48ac
	if !ctx.cr[0].eq {
	pc = 0x823F48AC; continue 'dispatch;
	}
	pc = 0x823F48C4; continue 'dispatch;
            }
            0x823F48C4 => {
    //   block [0x823F48C4..0x823F48C8)
	// 823F48C4: 3BBC0008  addi r29, r28, 8
	ctx.r[29].s64 = ctx.r[28].s64 + 8;
	pc = 0x823F48C8; continue 'dispatch;
            }
            0x823F48C8 => {
    //   block [0x823F48C8..0x823F48E4)
	// 823F48C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F48CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F48D0: 41820040  beq 0x823f4910
	if ctx.cr[0].eq {
	pc = 0x823F4910; continue 'dispatch;
	}
	// 823F48D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F48D8: 419A000C  beq cr6, 0x823f48e4
	if ctx.cr[6].eq {
	pc = 0x823F48E4; continue 'dispatch;
	}
	// 823F48DC: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 823F48E0: 409A0030  bne cr6, 0x823f4910
	if !ctx.cr[6].eq {
	pc = 0x823F4910; continue 'dispatch;
	}
	pc = 0x823F48E4; continue 'dispatch;
            }
            0x823F48E4 => {
    //   block [0x823F48E4..0x823F48F8)
	// 823F48E4: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F48E8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F48EC: 409A0038  bne cr6, 0x823f4924
	if !ctx.cr[6].eq {
	pc = 0x823F4924; continue 'dispatch;
	}
	// 823F48F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F48F4: 419A001C  beq cr6, 0x823f4910
	if ctx.cr[6].eq {
	pc = 0x823F4910; continue 'dispatch;
	}
	pc = 0x823F48F8; continue 'dispatch;
            }
            0x823F48F8 => {
    //   block [0x823F48F8..0x823F4910)
	// 823F48F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F48FC: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F4900: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4904: 4800177D  bl 0x823f6080
	ctx.lr = 0x823F4908;
	sub_823F6080(ctx, base);
	// 823F4908: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823F490C: 4082FFEC  bne 0x823f48f8
	if !ctx.cr[0].eq {
	pc = 0x823F48F8; continue 'dispatch;
	}
	pc = 0x823F4910; continue 'dispatch;
            }
            0x823F4910 => {
    //   block [0x823F4910..0x823F4924)
	// 823F4910: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F4914: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823F4918: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 823F491C: 4198FFAC  blt cr6, 0x823f48c8
	if ctx.cr[6].lt {
	pc = 0x823F48C8; continue 'dispatch;
	}
	// 823F4920: 4800002C  b 0x823f494c
	pc = 0x823F494C; continue 'dispatch;
            }
            0x823F4924 => {
    //   block [0x823F4924..0x823F494C)
	// 823F4924: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F4928: 419A0024  beq cr6, 0x823f494c
	if ctx.cr[6].eq {
	pc = 0x823F494C; continue 'dispatch;
	}
	// 823F492C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4930: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 823F4934: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F4938: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F493C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4940: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F4944: 7C6AE02E  lwzx r3, r10, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 823F4948: 48001739  bl 0x823f6080
	ctx.lr = 0x823F494C;
	sub_823F6080(ctx, base);
	pc = 0x823F494C; continue 'dispatch;
            }
            0x823F494C => {
    //   block [0x823F494C..0x823F4958)
	// 823F494C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F4950: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F4954: 481407AC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4958 size=168
    let mut pc: u32 = 0x823F4958;
    'dispatch: loop {
        match pc {
            0x823F4958 => {
    //   block [0x823F4958..0x823F49A8)
	// 823F4958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F495C: 4814075D  bl 0x825350b8
	ctx.lr = 0x823F4960;
	sub_82535080(ctx, base);
	// 823F4960: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F4968: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F496C: 419A008C  beq cr6, 0x823f49f8
	if ctx.cr[6].eq {
	pc = 0x823F49F8; continue 'dispatch;
	}
	// 823F4970: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F4974: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F4978: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F497C: 4BFFFEAD  bl 0x823f4828
	ctx.lr = 0x823F4980;
	sub_823F4828(ctx, base);
	// 823F4980: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F4984: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F4988: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F498C: 41820020  beq 0x823f49ac
	if ctx.cr[0].eq {
	pc = 0x823F49AC; continue 'dispatch;
	}
	// 823F4990: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F4994: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4998: 41820010  beq 0x823f49a8
	if ctx.cr[0].eq {
	pc = 0x823F49A8; continue 'dispatch;
	}
	// 823F499C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F49A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F49A4: 4E800421  bctrl
	ctx.lr = 0x823F49A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823F49A8 => {
    //   block [0x823F49A8..0x823F49AC)
	// 823F49A8: 939E0018  stw r28, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	pc = 0x823F49AC; continue 'dispatch;
            }
            0x823F49AC => {
    //   block [0x823F49AC..0x823F49C0)
	// 823F49AC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F49B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F49B4: 4182000C  beq 0x823f49c0
	if ctx.cr[0].eq {
	pc = 0x823F49C0; continue 'dispatch;
	}
	// 823F49B8: 480017E9  bl 0x823f61a0
	ctx.lr = 0x823F49BC;
	sub_823F61A0(ctx, base);
	// 823F49BC: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x823F49C0; continue 'dispatch;
            }
            0x823F49C0 => {
    //   block [0x823F49C0..0x823F49C8)
	// 823F49C0: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 823F49C4: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	pc = 0x823F49C8; continue 'dispatch;
            }
            0x823F49C8 => {
    //   block [0x823F49C8..0x823F49DC)
	// 823F49C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F49CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F49D0: 4182000C  beq 0x823f49dc
	if ctx.cr[0].eq {
	pc = 0x823F49DC; continue 'dispatch;
	}
	// 823F49D4: 480017CD  bl 0x823f61a0
	ctx.lr = 0x823F49D8;
	sub_823F61A0(ctx, base);
	// 823F49D8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F49DC; continue 'dispatch;
            }
            0x823F49DC => {
    //   block [0x823F49DC..0x823F49F8)
	// 823F49DC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F49E0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F49E4: 4082FFE4  bne 0x823f49c8
	if !ctx.cr[0].eq {
	pc = 0x823F49C8; continue 'dispatch;
	}
	// 823F49E8: 3C80648A  lis r4, 0x648a
	ctx.r[4].s64 = 1686765568;
	// 823F49EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F49F0: 60840008  ori r4, r4, 8
	ctx.r[4].u64 = ctx.r[4].u64 | 8;
	// 823F49F4: 4BFD5865  bl 0x823ca258
	ctx.lr = 0x823F49F8;
	sub_823CA258(ctx, base);
	pc = 0x823F49F8; continue 'dispatch;
            }
            0x823F49F8 => {
    //   block [0x823F49F8..0x823F4A00)
	// 823F49F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F49FC: 4814070C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4A00 size=228
    let mut pc: u32 = 0x823F4A00;
    'dispatch: loop {
        match pc {
            0x823F4A00 => {
    //   block [0x823F4A00..0x823F4A44)
	// 823F4A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4A04: 481406A9  bl 0x825350ac
	ctx.lr = 0x823F4A08;
	sub_82535080(ctx, base);
	// 823F4A08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4A0C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823F4A10: 3C80648A  lis r4, 0x648a
	ctx.r[4].s64 = 1686765568;
	// 823F4A14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F4A18: 60840008  ori r4, r4, 8
	ctx.r[4].u64 = ctx.r[4].u64 | 8;
	// 823F4A1C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F4A20: 807A0010  lwz r3, 0x10(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F4A24: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F4A28: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 823F4A2C: 4BFD5795  bl 0x823ca1c0
	ctx.lr = 0x823F4A30;
	sub_823CA1C0(ctx, base);
	// 823F4A30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F4A34: 40820010  bne 0x823f4a44
	if !ctx.cr[0].eq {
	pc = 0x823F4A44; continue 'dispatch;
	}
	// 823F4A38: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 823F4A3C: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 823F4A40: 48000088  b 0x823f4ac8
	pc = 0x823F4AC8; continue 'dispatch;
            }
            0x823F4A44 => {
    //   block [0x823F4A44..0x823F4A64)
	// 823F4A44: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 823F4A48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823F4A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F4A50: 48001839  bl 0x823f6288
	ctx.lr = 0x823F4A54;
	sub_823F6288(ctx, base);
	// 823F4A54: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F4A58: 41800070  blt 0x823f4ac8
	if ctx.cr[0].lt {
	pc = 0x823F4AC8; continue 'dispatch;
	}
	// 823F4A5C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F4A60: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	pc = 0x823F4A64; continue 'dispatch;
            }
            0x823F4A64 => {
    //   block [0x823F4A64..0x823F4A80)
	// 823F4A64: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4A68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4A6C: 41820014  beq 0x823f4a80
	if ctx.cr[0].eq {
	pc = 0x823F4A80; continue 'dispatch;
	}
	// 823F4A70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F4A74: 48001815  bl 0x823f6288
	ctx.lr = 0x823F4A78;
	sub_823F6288(ctx, base);
	// 823F4A78: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F4A7C: 4180004C  blt 0x823f4ac8
	if ctx.cr[0].lt {
	pc = 0x823F4AC8; continue 'dispatch;
	}
	pc = 0x823F4A80; continue 'dispatch;
            }
            0x823F4A80 => {
    //   block [0x823F4A80..0x823F4ABC)
	// 823F4A80: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823F4A84: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823F4A88: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823F4A8C: 2B1B0002  cmplwi cr6, r27, 2
	ctx.cr[6].compare_u32(ctx.r[27].u32, 2 as u32, &mut ctx.xer);
	// 823F4A90: 4198FFD4  blt cr6, 0x823f4a64
	if ctx.cr[6].lt {
	pc = 0x823F4A64; continue 'dispatch;
	}
	// 823F4A94: 935F0018  stw r26, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 823F4A98: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F4AA0: 419A001C  beq cr6, 0x823f4abc
	if ctx.cr[6].eq {
	pc = 0x823F4ABC; continue 'dispatch;
	}
	// 823F4AA4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F4AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4AAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F4AB0: 4E800421  bctrl
	ctx.lr = 0x823F4AB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F4AB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F4AB8: 48000008  b 0x823f4ac0
	pc = 0x823F4AC0; continue 'dispatch;
            }
            0x823F4ABC => {
    //   block [0x823F4ABC..0x823F4AC0)
	// 823F4ABC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x823F4AC0; continue 'dispatch;
            }
            0x823F4AC0 => {
    //   block [0x823F4AC0..0x823F4AC8)
	// 823F4AC0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F4AC4: 40980010  bge cr6, 0x823f4ad4
	if !ctx.cr[6].lt {
	pc = 0x823F4AD4; continue 'dispatch;
	}
	pc = 0x823F4AC8; continue 'dispatch;
            }
            0x823F4AC8 => {
    //   block [0x823F4AC8..0x823F4AD4)
	// 823F4AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F4ACC: 4BFFFE8D  bl 0x823f4958
	ctx.lr = 0x823F4AD0;
	sub_823F4958(ctx, base);
	// 823F4AD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823F4AD4; continue 'dispatch;
            }
            0x823F4AD4 => {
    //   block [0x823F4AD4..0x823F4AE4)
	// 823F4AD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F4AD8: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F4ADC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F4AE0: 4814061C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F4AE8 size=264
    let mut pc: u32 = 0x823F4AE8;
    'dispatch: loop {
        match pc {
            0x823F4AE8 => {
    //   block [0x823F4AE8..0x823F4B5C)
	// 823F4AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4AEC: 481405D1  bl 0x825350bc
	ctx.lr = 0x823F4AF0;
	sub_82535080(ctx, base);
	// 823F4AF0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823F4AF4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4AF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F4AFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F4B00: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 823F4B04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F4B08: 80BF004C  lwz r5, 0x4c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823F4B0C: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 823F4B10: 419A00D4  beq cr6, 0x823f4be4
	if ctx.cr[6].eq {
	pc = 0x823F4BE4; continue 'dispatch;
	}
	// 823F4B14: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F4B18: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 823F4B1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F4B20: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823F4B24: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 823F4B28: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 823F4B2C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 823F4B30: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823F4B34: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 823F4B38: 393F0024  addi r9, r31, 0x24
	ctx.r[9].s64 = ctx.r[31].s64 + 36;
	// 823F4B3C: C0071FF8  lfs f0, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F4B40: C3E81850  lfs f31, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823F4B44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823F4B48: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823F4B4C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F4B50: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 823F4B54: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F4B58: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	pc = 0x823F4B5C; continue 'dispatch;
            }
            0x823F4B5C => {
    //   block [0x823F4B5C..0x823F4B88)
	// 823F4B5C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4B60: 98CBFFFC  stb r6, -4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u8 ) };
	// 823F4B64: 2B08FFFF  cmplwi cr6, r8, 0xffff
	ctx.cr[6].compare_u32(ctx.r[8].u32, 65535 as u32, &mut ctx.xer);
	// 823F4B68: 994BFFFD  stb r10, -3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-3 as u32), ctx.r[10].u8 ) };
	// 823F4B6C: 4199001C  bgt cr6, 0x823f4b88
	if ctx.cr[6].gt {
	pc = 0x823F4B88; continue 'dispatch;
	}
	// 823F4B70: 891F0040  lbz r8, 0x40(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F4B74: 7FA75030  slw r7, r29, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[29].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823F4B78: 7D083839  and. r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F4B7C: 4082000C  bne 0x823f4b88
	if !ctx.cr[0].eq {
	pc = 0x823F4B88; continue 'dispatch;
	}
	// 823F4B80: D3EB0000  stfs f31, 0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823F4B84: 48000008  b 0x823f4b8c
	pc = 0x823F4B8C; continue 'dispatch;
            }
            0x823F4B88 => {
    //   block [0x823F4B88..0x823F4B8C)
	// 823F4B88: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823F4B8C; continue 'dispatch;
            }
            0x823F4B8C => {
    //   block [0x823F4B8C..0x823F4BB0)
	// 823F4B8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F4B90: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823F4B94: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823F4B98: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 823F4B9C: 4198FFC0  blt cr6, 0x823f4b5c
	if ctx.cr[6].lt {
	pc = 0x823F4B5C; continue 'dispatch;
	}
	// 823F4BA0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 823F4BA4: 419A000C  beq cr6, 0x823f4bb0
	if ctx.cr[6].eq {
	pc = 0x823F4BB0; continue 'dispatch;
	}
	// 823F4BA8: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 823F4BAC: 4818EFFD  bl 0x82583ba8
	ctx.lr = 0x823F4BB0;
	sub_82583BA8(ctx, base);
	pc = 0x823F4BB0; continue 'dispatch;
            }
            0x823F4BB0 => {
    //   block [0x823F4BB0..0x823F4BC4)
	// 823F4BB0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F4BB4: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 823F4BB8: 409A000C  bne cr6, 0x823f4bc4
	if !ctx.cr[6].eq {
	pc = 0x823F4BC4; continue 'dispatch;
	}
	// 823F4BBC: 83DF0050  lwz r30, 0x50(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F4BC0: 48000014  b 0x823f4bd4
	pc = 0x823F4BD4; continue 'dispatch;
            }
            0x823F4BC4 => {
    //   block [0x823F4BC4..0x823F4BD4)
	// 823F4BC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F4BC8: 4818EF79  bl 0x82583b40
	ctx.lr = 0x823F4BCC;
	sub_82583B40(ctx, base);
	// 823F4BCC: D3E10074  stfs f31, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 823F4BD0: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	pc = 0x823F4BD4; continue 'dispatch;
            }
            0x823F4BD4 => {
    //   block [0x823F4BD4..0x823F4BE4)
	// 823F4BD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823F4BD8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F4BDC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 823F4BE0: 4818F0A1  bl 0x82583c80
	ctx.lr = 0x823F4BE4;
	sub_82583C80(ctx, base);
	pc = 0x823F4BE4; continue 'dispatch;
            }
            0x823F4BE4 => {
    //   block [0x823F4BE4..0x823F4BF0)
	// 823F4BE4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823F4BE8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823F4BEC: 48140520  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F4BF0 size=48
    let mut pc: u32 = 0x823F4BF0;
    'dispatch: loop {
        match pc {
            0x823F4BF0 => {
    //   block [0x823F4BF0..0x823F4C10)
	// 823F4BF0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823F4BF4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823F4BF8: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 823F4BFC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823F4C00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F4C04: 419A000C  beq cr6, 0x823f4c10
	if ctx.cr[6].eq {
	pc = 0x823F4C10; continue 'dispatch;
	}
	// 823F4C08: 80630050  lwz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F4C0C: 48000008  b 0x823f4c14
	pc = 0x823F4C14; continue 'dispatch;
            }
            0x823F4C10 => {
    //   block [0x823F4C10..0x823F4C14)
	// 823F4C10: 80630048  lwz r3, 0x48(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	pc = 0x823F4C14; continue 'dispatch;
            }
            0x823F4C14 => {
    //   block [0x823F4C14..0x823F4C20)
	// 823F4C14: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 823F4C18: 4818EFF8  b 0x82583c10
	sub_82583C10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F4C20 size=116
    let mut pc: u32 = 0x823F4C20;
    'dispatch: loop {
        match pc {
            0x823F4C20 => {
    //   block [0x823F4C20..0x823F4C48)
	// 823F4C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4C24: 48140495  bl 0x825350b8
	ctx.lr = 0x823F4C28;
	sub_82535080(ctx, base);
	// 823F4C28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4C2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F4C30: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823F4C34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F4C38: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F4C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F4C40: 40990038  ble cr6, 0x823f4c78
	if !ctx.cr[6].gt {
	pc = 0x823F4C78; continue 'dispatch;
	}
	// 823F4C44: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	pc = 0x823F4C48; continue 'dispatch;
            }
            0x823F4C48 => {
    //   block [0x823F4C48..0x823F4C78)
	// 823F4C48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4C4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4C50: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F4C54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F4C58: 4E800421  bctrl
	ctx.lr = 0x823F4C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F4C5C: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 823F4C60: 419A0024  beq cr6, 0x823f4c84
	if ctx.cr[6].eq {
	pc = 0x823F4C84; continue 'dispatch;
	}
	// 823F4C64: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F4C68: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F4C6C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F4C70: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F4C74: 4198FFD4  blt cr6, 0x823f4c48
	if ctx.cr[6].lt {
	pc = 0x823F4C48; continue 'dispatch;
	}
            }
            0x823F4C78 => {
    //   block [0x823F4C78..0x823F4C7C)
	// 823F4C78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823F4C7C; continue 'dispatch;
            }
            0x823F4C7C => {
    //   block [0x823F4C7C..0x823F4C84)
	// 823F4C7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F4C80: 48140488  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x823F4C84 => {
    //   block [0x823F4C84..0x823F4C94)
	// 823F4C84: 397D0003  addi r11, r29, 3
	ctx.r[11].s64 = ctx.r[29].s64 + 3;
	// 823F4C88: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F4C8C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 823F4C90: 4BFFFFEC  b 0x823f4c7c
	pc = 0x823F4C7C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F4C98 size=632
    let mut pc: u32 = 0x823F4C98;
    'dispatch: loop {
        match pc {
            0x823F4C98 => {
    //   block [0x823F4C98..0x823F4D30)
	// 823F4C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4C9C: 4814040D  bl 0x825350a8
	ctx.lr = 0x823F4CA0;
	sub_82535080(ctx, base);
	// 823F4CA0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 823F4CA4: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4CA8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823F4CAC: 90A1007C  stw r5, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[5].u32 ) };
	// 823F4CB0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F4CB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F4CB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F4CBC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823F4CC0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 823F4CC4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823F4CC8: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 823F4CCC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F4CD0: 99610071  stb r11, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 823F4CD4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 823F4CD8: 99610079  stb r11, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[11].u8 ) };
	// 823F4CDC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F4CE0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F4CE4: 3B3F0048  addi r25, r31, 0x48
	ctx.r[25].s64 = ctx.r[31].s64 + 72;
	// 823F4CE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 823F4CEC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823F4CF0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 823F4CF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4CF8: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 823F4CFC: 9B810070  stb r28, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u8 ) };
	// 823F4D00: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 823F4D04: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 823F4D08: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 823F4D0C: 9BC1007A  stb r30, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[30].u8 ) };
	// 823F4D10: 614ABB80  ori r10, r10, 0xbb80
	ctx.r[10].u64 = ctx.r[10].u64 | 48000;
	// 823F4D14: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 823F4D18: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 823F4D1C: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 823F4D20: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 823F4D24: 4182000C  beq 0x823f4d30
	if ctx.cr[0].eq {
	pc = 0x823F4D30; continue 'dispatch;
	}
	// 823F4D28: 4818EE81  bl 0x82583ba8
	ctx.lr = 0x823F4D2C;
	sub_82583BA8(ctx, base);
	// 823F4D2C: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F4D30; continue 'dispatch;
            }
            0x823F4D30 => {
    //   block [0x823F4D30..0x823F4D48)
	// 823F4D30: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F4D34: 3B1F0050  addi r24, r31, 0x50
	ctx.r[24].s64 = ctx.r[31].s64 + 80;
	// 823F4D38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4D3C: 4182000C  beq 0x823f4d48
	if ctx.cr[0].eq {
	pc = 0x823F4D48; continue 'dispatch;
	}
	// 823F4D40: 4818EE69  bl 0x82583ba8
	ctx.lr = 0x823F4D44;
	sub_82583BA8(ctx, base);
	// 823F4D44: 93980000  stw r28, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F4D48; continue 'dispatch;
            }
            0x823F4D48 => {
    //   block [0x823F4D48..0x823F4D5C)
	// 823F4D48: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823F4D4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4D50: 4182000C  beq 0x823f4d5c
	if ctx.cr[0].eq {
	pc = 0x823F4D5C; continue 'dispatch;
	}
	// 823F4D54: 4818EE55  bl 0x82583ba8
	ctx.lr = 0x823F4D58;
	sub_82583BA8(ctx, base);
	// 823F4D58: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	pc = 0x823F4D5C; continue 'dispatch;
            }
            0x823F4D5C => {
    //   block [0x823F4D5C..0x823F4D78)
	// 823F4D5C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4D60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823F4D64: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 823F4D68: 81290038  lwz r9, 0x38(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 823F4D6C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 823F4D70: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823F4D74: C3E91850  lfs f31, 0x1850(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x823F4D78; continue 'dispatch;
            }
            0x823F4D78 => {
    //   block [0x823F4D78..0x823F4DD8)
	// 823F4D78: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F4D7C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 823F4D80: 38E10091  addi r7, r1, 0x91
	ctx.r[7].s64 = ctx.r[1].s64 + 145;
	// 823F4D84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F4D88: 38C10094  addi r6, r1, 0x94
	ctx.r[6].s64 = ctx.r[1].s64 + 148;
	// 823F4D8C: 7D6941AE  stbx r11, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 823F4D90: 7D6939AE  stbx r11, r9, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u8) };
	// 823F4D94: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823F4D98: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823F4D9C: 7FE9352E  stfsx f31, r9, r6
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 823F4DA0: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 823F4DA4: 4198FFD4  blt cr6, 0x823f4d78
	if ctx.cr[6].lt {
	pc = 0x823F4D78; continue 'dispatch;
	}
	// 823F4DA8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 823F4DAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F4DB0: 4818F579  bl 0x82584328
	ctx.lr = 0x823F4DB4;
	sub_82584328(ctx, base);
	// 823F4DB4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F4DB8: 41800120  blt 0x823f4ed8
	if ctx.cr[0].lt {
	pc = 0x823F4ED8; continue 'dispatch;
	}
	// 823F4DBC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823F4DC0: 9BC10071  stb r30, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[30].u8 ) };
	// 823F4DC4: 9B81007A  stb r28, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[28].u8 ) };
	// 823F4DC8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 823F4DCC: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 823F4DD0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 823F4DD4: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823F4DD8; continue 'dispatch;
            }
            0x823F4DD8 => {
    //   block [0x823F4DD8..0x823F4E1C)
	// 823F4DD8: 390B0009  addi r8, r11, 9
	ctx.r[8].s64 = ctx.r[11].s64 + 9;
	// 823F4DDC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F4DE0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F4DE4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 823F4DE8: 38C10091  addi r6, r1, 0x91
	ctx.r[6].s64 = ctx.r[1].s64 + 145;
	// 823F4DEC: 7D08F82E  lwzx r8, r8, r31
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F4DF0: 7F8A39AE  stbx r28, r10, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[28].u8) };
	// 823F4DF4: 2B08FFFF  cmplwi cr6, r8, 0xffff
	ctx.cr[6].compare_u32(ctx.r[8].u32, 65535 as u32, &mut ctx.xer);
	// 823F4DF8: 7D2A31AE  stbx r9, r10, r6
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[9].u8) };
	// 823F4DFC: 41990020  bgt cr6, 0x823f4e1c
	if ctx.cr[6].gt {
	pc = 0x823F4E1C; continue 'dispatch;
	}
	// 823F4E00: 893F0040  lbz r9, 0x40(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F4E04: 7FC85830  slw r8, r30, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[30].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F4E08: 7D294039  and. r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F4E0C: 40820010  bne 0x823f4e1c
	if !ctx.cr[0].eq {
	pc = 0x823F4E1C; continue 'dispatch;
	}
	// 823F4E10: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 823F4E14: 7FEA4D2E  stfsx f31, r10, r9
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 823F4E18: 4800000C  b 0x823f4e24
	pc = 0x823F4E24; continue 'dispatch;
            }
            0x823F4E1C => {
    //   block [0x823F4E1C..0x823F4E24)
	// 823F4E1C: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 823F4E20: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	pc = 0x823F4E24; continue 'dispatch;
            }
            0x823F4E24 => {
    //   block [0x823F4E24..0x823F4E4C)
	// 823F4E24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F4E28: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F4E2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823F4E30: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 823F4E34: 4198FFA4  blt cr6, 0x823f4dd8
	if ctx.cr[6].lt {
	pc = 0x823F4DD8; continue 'dispatch;
	}
	// 823F4E38: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 823F4E3C: 935F004C  stw r26, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[26].u32 ) };
	// 823F4E40: 409A000C  bne cr6, 0x823f4e4c
	if !ctx.cr[6].eq {
	pc = 0x823F4E4C; continue 'dispatch;
	}
	// 823F4E44: 83580000  lwz r26, 0(r24)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4E48: 48000014  b 0x823f4e5c
	pc = 0x823F4E5C; continue 'dispatch;
            }
            0x823F4E4C => {
    //   block [0x823F4E4C..0x823F4E5C)
	// 823F4E4C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F4E50: 4818ECF1  bl 0x82583b40
	ctx.lr = 0x823F4E54;
	sub_82583B40(ctx, base);
	// 823F4E54: D3E10094  stfs f31, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823F4E58: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	pc = 0x823F4E5C; continue 'dispatch;
            }
            0x823F4E5C => {
    //   block [0x823F4E5C..0x823F4E84)
	// 823F4E5C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823F4E60: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 823F4E64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F4E68: 4818F4C1  bl 0x82584328
	ctx.lr = 0x823F4E6C;
	sub_82584328(ctx, base);
	// 823F4E6C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F4E70: 41800068  blt 0x823f4ed8
	if ctx.cr[0].lt {
	pc = 0x823F4ED8; continue 'dispatch;
	}
	// 823F4E74: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F4E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F4E7C: 40990054  ble cr6, 0x823f4ed0
	if !ctx.cr[6].gt {
	pc = 0x823F4ED0; continue 'dispatch;
	}
	// 823F4E80: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x823F4E84; continue 'dispatch;
            }
            0x823F4E84 => {
    //   block [0x823F4E84..0x823F4EBC)
	// 823F4E84: 397E0003  addi r11, r30, 3
	ctx.r[11].s64 = ctx.r[30].s64 + 3;
	// 823F4E88: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4E8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F4E90: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823F4E94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4E98: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F4E9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F4EA0: 4E800421  bctrl
	ctx.lr = 0x823F4EA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F4EA4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F4EA8: 40800014  bge 0x823f4ebc
	if !ctx.cr[0].lt {
	pc = 0x823F4EBC; continue 'dispatch;
	}
	// 823F4EAC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 823F4EB0: 616B4001  ori r11, r11, 0x4001
	ctx.r[11].u64 = ctx.r[11].u64 | 16385;
	// 823F4EB4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823F4EB8: 409A0018  bne cr6, 0x823f4ed0
	if !ctx.cr[6].eq {
	pc = 0x823F4ED0; continue 'dispatch;
	}
            }
            0x823F4EBC => {
    //   block [0x823F4EBC..0x823F4ED0)
	// 823F4EBC: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 823F4EC0: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F4EC4: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F4EC8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F4ECC: 4198FFB8  blt cr6, 0x823f4e84
	if ctx.cr[6].lt {
	pc = 0x823F4E84; continue 'dispatch;
	}
	pc = 0x823F4ED0; continue 'dispatch;
            }
            0x823F4ED0 => {
    //   block [0x823F4ED0..0x823F4ED8)
	// 823F4ED0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F4ED4: 4098002C  bge cr6, 0x823f4f00
	if !ctx.cr[6].lt {
	pc = 0x823F4F00; continue 'dispatch;
	}
	pc = 0x823F4ED8; continue 'dispatch;
            }
            0x823F4ED8 => {
    //   block [0x823F4ED8..0x823F4EEC)
	// 823F4ED8: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4EDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4EE0: 4182000C  beq 0x823f4eec
	if ctx.cr[0].eq {
	pc = 0x823F4EEC; continue 'dispatch;
	}
	// 823F4EE4: 4818ECC5  bl 0x82583ba8
	ctx.lr = 0x823F4EE8;
	sub_82583BA8(ctx, base);
	// 823F4EE8: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F4EEC; continue 'dispatch;
            }
            0x823F4EEC => {
    //   block [0x823F4EEC..0x823F4F00)
	// 823F4EEC: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F4EF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F4EF4: 4182000C  beq 0x823f4f00
	if ctx.cr[0].eq {
	pc = 0x823F4F00; continue 'dispatch;
	}
	// 823F4EF8: 4818ECB1  bl 0x82583ba8
	ctx.lr = 0x823F4EFC;
	sub_82583BA8(ctx, base);
	// 823F4EFC: 93980000  stw r28, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F4F00; continue 'dispatch;
            }
            0x823F4F00 => {
    //   block [0x823F4F00..0x823F4F10)
	// 823F4F00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F4F04: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 823F4F08: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823F4F0C: 481401EC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F4F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F4F10 size=584
    let mut pc: u32 = 0x823F4F10;
    'dispatch: loop {
        match pc {
            0x823F4F10 => {
    //   block [0x823F4F10..0x823F4FB0)
	// 823F4F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F4F14: 4814019D  bl 0x825350b0
	ctx.lr = 0x823F4F18;
	sub_82535080(ctx, base);
	// 823F4F18: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F4F1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823F4F20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F4F24: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F4F28: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 823F4F2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F4F30: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F4F34: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F4F38: 815E004C  lwz r10, 0x4c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 823F4F3C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 823F4F40: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 823F4F44: 9B810080  stb r28, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u8 ) };
	// 823F4F48: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 823F4F4C: 9B610088  stb r27, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[27].u8 ) };
	// 823F4F50: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 823F4F54: 9B810060  stb r28, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 823F4F58: 99610090  stb r11, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 823F4F5C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F4F60: 9B610068  stb r27, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u8 ) };
	// 823F4F64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F4F68: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 823F4F6C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F4F70: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 823F4F74: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 823F4F78: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F4F7C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 823F4F80: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823F4F84: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F4F88: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 823F4F8C: 409A01C4  bne cr6, 0x823f5150
	if !ctx.cr[6].eq {
	pc = 0x823F5150; continue 'dispatch;
	}
	// 823F4F90: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823F4F94: 83BE0044  lwz r29, 0x44(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F4F98: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 823F4F9C: 3BE00458  li r31, 0x458
	ctx.r[31].s64 = 1112;
	// 823F4FA0: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 823F4FA4: 3B4BFBA8  addi r26, r11, -0x458
	ctx.r[26].s64 = ctx.r[11].s64 + -1112;
	// 823F4FA8: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 823F4FAC: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	pc = 0x823F4FB0; continue 'dispatch;
            }
            0x823F4FB0 => {
    //   block [0x823F4FB0..0x823F4FE8)
	// 823F4FB0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F4FB4: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F4FB8: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823F4FBC: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823F4FC0: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 823F4FC4: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F4FC8: 41820020  beq 0x823f4fe8
	if ctx.cr[0].eq {
	pc = 0x823F4FE8; continue 'dispatch;
	}
	// 823F4FCC: 7D3F582E  lwzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F4FD0: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 823F4FD4: 812900C4  lwz r9, 0xc4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F4FD8: 5529031E  rlwinm r9, r9, 0, 0xc, 0xf
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823F4FDC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F4FE0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 823F4FE4: 419A0008  beq cr6, 0x823f4fec
	if ctx.cr[6].eq {
	pc = 0x823F4FEC; continue 'dispatch;
	}
	pc = 0x823F4FE8; continue 'dispatch;
            }
            0x823F4FE8 => {
    //   block [0x823F4FE8..0x823F4FEC)
	// 823F4FE8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x823F4FEC; continue 'dispatch;
            }
            0x823F4FEC => {
    //   block [0x823F4FEC..0x823F5014)
	// 823F4FEC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F4FF0: 419A0054  beq cr6, 0x823f5044
	if ctx.cr[6].eq {
	pc = 0x823F5044; continue 'dispatch;
	}
	// 823F4FF4: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F4FF8: 814A00C4  lwz r10, 0xc4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F4FFC: 554A031F  rlwinm. r10, r10, 0, 0xc, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F5000: 41820040  beq 0x823f5040
	if ctx.cr[0].eq {
	pc = 0x823F5040; continue 'dispatch;
	}
	// 823F5004: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F5008: 409A000C  bne cr6, 0x823f5014
	if !ctx.cr[6].eq {
	pc = 0x823F5014; continue 'dispatch;
	}
	// 823F500C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F5010: 419A0034  beq cr6, 0x823f5044
	if ctx.cr[6].eq {
	pc = 0x823F5044; continue 'dispatch;
	}
	pc = 0x823F5014; continue 'dispatch;
            }
            0x823F5014 => {
    //   block [0x823F5014..0x823F5040)
	// 823F5014: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 823F5018: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F501C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F5020: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823F5024: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823F5028: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F502C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5030: 4831807D  bl 0x8270d0ac
	ctx.lr = 0x823F5034;
	// extern call 0x8270D0AC  crate::xam::XamUserAreUsersFriends
	crate::xam::XamUserAreUsersFriends(ctx, base);
	// 823F5034: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F5038: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F503C: 409A0008  bne cr6, 0x823f5044
	if !ctx.cr[6].eq {
	pc = 0x823F5044; continue 'dispatch;
	}
	pc = 0x823F5040; continue 'dispatch;
            }
            0x823F5040 => {
    //   block [0x823F5040..0x823F5044)
	// 823F5040: 7F9AF92E  stwx r28, r26, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[31].u32), ctx.r[28].u32) };
	pc = 0x823F5044; continue 'dispatch;
            }
            0x823F5044 => {
    //   block [0x823F5044..0x823F5068)
	// 823F5044: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F5048: 2B1F0468  cmplwi cr6, r31, 0x468
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1128 as u32, &mut ctx.xer);
	// 823F504C: 4198FF64  blt cr6, 0x823f4fb0
	if ctx.cr[6].lt {
	pc = 0x823F4FB0; continue 'dispatch;
	}
	// 823F5050: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823F5054: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823F5058: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 823F505C: 39600458  li r11, 0x458
	ctx.r[11].s64 = 1112;
	// 823F5060: 389EFBCC  addi r4, r30, -0x434
	ctx.r[4].s64 = ctx.r[30].s64 + -1076;
	// 823F5064: C00A1850  lfs f0, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823F5068; continue 'dispatch;
            }
            0x823F5068 => {
    //   block [0x823F5068..0x823F508C)
	// 823F5068: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F506C: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F5070: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5074: 41820018  beq 0x823f508c
	if ctx.cr[0].eq {
	pc = 0x823F508C; continue 'dispatch;
	}
	// 823F5078: 5528003E  slwi r8, r9, 0
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F507C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823F5080: 810800C0  lwz r8, 0xc0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(192 as u32) ) } as u64;
	// 823F5084: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F5088: 409A0008  bne cr6, 0x823f5090
	if !ctx.cr[6].eq {
	pc = 0x823F5090; continue 'dispatch;
	}
	pc = 0x823F508C; continue 'dispatch;
            }
            0x823F508C => {
    //   block [0x823F508C..0x823F5090)
	// 823F508C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x823F5090; continue 'dispatch;
            }
            0x823F5090 => {
    //   block [0x823F5090..0x823F50B0)
	// 823F5090: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F5094: 419A0080  beq cr6, 0x823f5114
	if ctx.cr[6].eq {
	pc = 0x823F5114; continue 'dispatch;
	}
	// 823F5098: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F509C: 814A00C4  lwz r10, 0xc4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F50A0: 554A07BD  rlwinm. r10, r10, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F50A4: 4082000C  bne 0x823f50b0
	if !ctx.cr[0].eq {
	pc = 0x823F50B0; continue 'dispatch;
	}
	// 823F50A8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823F50AC: 409A0068  bne cr6, 0x823f5114
	if !ctx.cr[6].eq {
	pc = 0x823F5114; continue 'dispatch;
	}
	pc = 0x823F50B0; continue 'dispatch;
            }
            0x823F50B0 => {
    //   block [0x823F50B0..0x823F50B8)
	// 823F50B0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 823F50B4: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	pc = 0x823F50B8; continue 'dispatch;
            }
            0x823F50B8 => {
    //   block [0x823F50B8..0x823F5100)
	// 823F50B8: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823F50BC: 419A0048  beq cr6, 0x823f5104
	if ctx.cr[6].eq {
	pc = 0x823F5104; continue 'dispatch;
	}
	// 823F50C0: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F50C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F50C8: 409A003C  bne cr6, 0x823f5104
	if !ctx.cr[6].eq {
	pc = 0x823F5104; continue 'dispatch;
	}
	// 823F50CC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F50D0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F50D4: 814A00C4  lwz r10, 0xc4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F50D8: 554A077B  rlwinm. r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F50DC: 41820024  beq 0x823f5100
	if ctx.cr[0].eq {
	pc = 0x823F5100; continue 'dispatch;
	}
	// 823F50E0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823F50E4: 419A001C  beq cr6, 0x823f5100
	if ctx.cr[6].eq {
	pc = 0x823F5100; continue 'dispatch;
	}
	// 823F50E8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F50EC: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 823F50F0: 806A00C4  lwz r3, 0xc4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F50F4: 546307FA  rlwinm r3, r3, 0, 0x1f, 0x1d
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 823F50F8: 906A00C4  stw r3, 0xc4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 823F50FC: 48000008  b 0x823f5104
	pc = 0x823F5104; continue 'dispatch;
            }
            0x823F5100 => {
    //   block [0x823F5100..0x823F5104)
	// 823F5100: 7F8BD12E  stwx r28, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[28].u32) };
	pc = 0x823F5104; continue 'dispatch;
            }
            0x823F5104 => {
    //   block [0x823F5104..0x823F5114)
	// 823F5104: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823F5108: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823F510C: 2B090004  cmplwi cr6, r9, 4
	ctx.cr[6].compare_u32(ctx.r[9].u32, 4 as u32, &mut ctx.xer);
	// 823F5110: 4198FFA8  blt cr6, 0x823f50b8
	if ctx.cr[6].lt {
	pc = 0x823F50B8; continue 'dispatch;
	}
	pc = 0x823F5114; continue 'dispatch;
            }
            0x823F5114 => {
    //   block [0x823F5114..0x823F5130)
	// 823F5114: 7D4BD02E  lwzx r10, r11, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 823F5118: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F511C: 419A0014  beq cr6, 0x823f5130
	if ctx.cr[6].eq {
	pc = 0x823F5130; continue 'dispatch;
	}
	// 823F5120: 7D44582E  lwzx r10, r4, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F5124: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 823F5128: 41990008  bgt cr6, 0x823f5130
	if ctx.cr[6].gt {
	pc = 0x823F5130; continue 'dispatch;
	}
	// 823F512C: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823F5130; continue 'dispatch;
            }
            0x823F5130 => {
    //   block [0x823F5130..0x823F5150)
	// 823F5130: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F5134: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 823F5138: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 823F513C: 2B0B0468  cmplwi cr6, r11, 0x468
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1128 as u32, &mut ctx.xer);
	// 823F5140: 4198FF28  blt cr6, 0x823f5068
	if ctx.cr[6].lt {
	pc = 0x823F5068; continue 'dispatch;
	}
	// 823F5144: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 823F5148: 807E0048  lwz r3, 0x48(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F514C: 4818EB8D  bl 0x82583cd8
	ctx.lr = 0x823F5150;
	sub_82583CD8(ctx, base);
	pc = 0x823F5150; continue 'dispatch;
            }
            0x823F5150 => {
    //   block [0x823F5150..0x823F5158)
	// 823F5150: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 823F5154: 4813FFAC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5158 size=228
    let mut pc: u32 = 0x823F5158;
    'dispatch: loop {
        match pc {
            0x823F5158 => {
    //   block [0x823F5158..0x823F5188)
	// 823F5158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F515C: 4813FF5D  bl 0x825350b8
	ctx.lr = 0x823F5160;
	sub_82535080(ctx, base);
	// 823F5160: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5164: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5168: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F516C: 419A00C8  beq cr6, 0x823f5234
	if ctx.cr[6].eq {
	pc = 0x823F5234; continue 'dispatch;
	}
	// 823F5170: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F5174: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F5178: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823F517C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F5180: 40990028  ble cr6, 0x823f51a8
	if !ctx.cr[6].gt {
	pc = 0x823F51A8; continue 'dispatch;
	}
	// 823F5184: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	pc = 0x823F5188; continue 'dispatch;
            }
            0x823F5188 => {
    //   block [0x823F5188..0x823F51A8)
	// 823F5188: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F518C: 4BFFF7CD  bl 0x823f4958
	ctx.lr = 0x823F5190;
	sub_823F4958(ctx, base);
	// 823F5190: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F5194: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F5198: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F519C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F51A0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F51A4: 4198FFE4  blt cr6, 0x823f5188
	if ctx.cr[6].lt {
	pc = 0x823F5188; continue 'dispatch;
	}
	pc = 0x823F51A8; continue 'dispatch;
            }
            0x823F51A8 => {
    //   block [0x823F51A8..0x823F51BC)
	// 823F51A8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F51AC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823F51B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F51B4: 40990034  ble cr6, 0x823f51e8
	if !ctx.cr[6].gt {
	pc = 0x823F51E8; continue 'dispatch;
	}
	// 823F51B8: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x823F51BC; continue 'dispatch;
            }
            0x823F51BC => {
    //   block [0x823F51BC..0x823F51E8)
	// 823F51BC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F51C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F51C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F51C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F51CC: 4E800421  bctrl
	ctx.lr = 0x823F51D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F51D0: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F51D4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F51D8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F51DC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F51E0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F51E4: 4198FFD8  blt cr6, 0x823f51bc
	if ctx.cr[6].lt {
	pc = 0x823F51BC; continue 'dispatch;
	}
            }
            0x823F51E8 => {
    //   block [0x823F51E8..0x823F51FC)
	// 823F51E8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F51EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F51F0: 4182000C  beq 0x823f51fc
	if ctx.cr[0].eq {
	pc = 0x823F51FC; continue 'dispatch;
	}
	// 823F51F4: 4818E9B5  bl 0x82583ba8
	ctx.lr = 0x823F51F8;
	sub_82583BA8(ctx, base);
	// 823F51F8: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	pc = 0x823F51FC; continue 'dispatch;
            }
            0x823F51FC => {
    //   block [0x823F51FC..0x823F5210)
	// 823F51FC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F5200: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5204: 4182000C  beq 0x823f5210
	if ctx.cr[0].eq {
	pc = 0x823F5210; continue 'dispatch;
	}
	// 823F5208: 4818E9A1  bl 0x82583ba8
	ctx.lr = 0x823F520C;
	sub_82583BA8(ctx, base);
	// 823F520C: 939F0050  stw r28, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x823F5210; continue 'dispatch;
            }
            0x823F5210 => {
    //   block [0x823F5210..0x823F5224)
	// 823F5210: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823F5214: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5218: 4182000C  beq 0x823f5224
	if ctx.cr[0].eq {
	pc = 0x823F5224; continue 'dispatch;
	}
	// 823F521C: 4818E98D  bl 0x82583ba8
	ctx.lr = 0x823F5220;
	sub_82583BA8(ctx, base);
	// 823F5220: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	pc = 0x823F5224; continue 'dispatch;
            }
            0x823F5224 => {
    //   block [0x823F5224..0x823F5234)
	// 823F5224: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F5228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F522C: 60848010  ori r4, r4, 0x8010
	ctx.r[4].u64 = ctx.r[4].u64 | 32784;
	// 823F5230: 4BFD5029  bl 0x823ca258
	ctx.lr = 0x823F5234;
	sub_823CA258(ctx, base);
	pc = 0x823F5234; continue 'dispatch;
            }
            0x823F5234 => {
    //   block [0x823F5234..0x823F523C)
	// 823F5234: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F5238: 4813FED0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5240 size=172
    let mut pc: u32 = 0x823F5240;
    'dispatch: loop {
        match pc {
            0x823F5240 => {
    //   block [0x823F5240..0x823F5264)
	// 823F5240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5244: 4813FE79  bl 0x825350bc
	ctx.lr = 0x823F5248;
	sub_82535080(ctx, base);
	// 823F5248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F524C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5250: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F5254: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F5258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F525C: 40990048  ble cr6, 0x823f52a4
	if !ctx.cr[6].gt {
	pc = 0x823F52A4; continue 'dispatch;
	}
	// 823F5260: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	pc = 0x823F5264; continue 'dispatch;
            }
            0x823F5264 => {
    //   block [0x823F5264..0x823F52A4)
	// 823F5264: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5268: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 823F526C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 823F5270: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 823F5274: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5278: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F527C: 4BFFE6D5  bl 0x823f3950
	ctx.lr = 0x823F5280;
	sub_823F3950(ctx, base);
	// 823F5280: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F5284: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5288: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823F528C: 4BFFF475  bl 0x823f4700
	ctx.lr = 0x823F5290;
	sub_823F4700(ctx, base);
	// 823F5290: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F5294: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F5298: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F529C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F52A0: 4198FFC4  blt cr6, 0x823f5264
	if ctx.cr[6].lt {
	pc = 0x823F5264; continue 'dispatch;
	}
	pc = 0x823F52A4; continue 'dispatch;
            }
            0x823F52A4 => {
    //   block [0x823F52A4..0x823F52B8)
	// 823F52A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F52A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F52AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F52B0: 40990030  ble cr6, 0x823f52e0
	if !ctx.cr[6].gt {
	pc = 0x823F52E0; continue 'dispatch;
	}
	// 823F52B4: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x823F52B8; continue 'dispatch;
            }
            0x823F52B8 => {
    //   block [0x823F52B8..0x823F52E0)
	// 823F52B8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F52BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F52C0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F52C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F52C8: 4E800421  bctrl
	ctx.lr = 0x823F52CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F52CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F52D0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F52D4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F52D8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F52DC: 4198FFDC  blt cr6, 0x823f52b8
	if ctx.cr[6].lt {
	pc = 0x823F52B8; continue 'dispatch;
	}
            }
            0x823F52E0 => {
    //   block [0x823F52E0..0x823F52EC)
	// 823F52E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F52E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F52E8: 4813FE24  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F52F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F52F0 size=116
    let mut pc: u32 = 0x823F52F0;
    'dispatch: loop {
        match pc {
            0x823F52F0 => {
    //   block [0x823F52F0..0x823F531C)
	// 823F52F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F52F4: 4813FDC1  bl 0x825350b4
	ctx.lr = 0x823F52F8;
	sub_82535080(ctx, base);
	// 823F52F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F52FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F5300: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F5304: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823F5308: 639C0057  ori r28, r28, 0x57
	ctx.r[28].u64 = ctx.r[28].u64 | 87;
	// 823F530C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F5310: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F5314: 419A0044  beq cr6, 0x823f5358
	if ctx.cr[6].eq {
	pc = 0x823F5358; continue 'dispatch;
	}
	// 823F5318: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x823F531C; continue 'dispatch;
            }
            0x823F531C => {
    //   block [0x823F531C..0x823F5358)
	// 823F531C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F5320: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5324: 4BFFF8FD  bl 0x823f4c20
	ctx.lr = 0x823F5328;
	sub_823F4C20(ctx, base);
	// 823F5328: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F532C: 4182002C  beq 0x823f5358
	if ctx.cr[0].eq {
	pc = 0x823F5358; continue 'dispatch;
	}
	// 823F5330: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5334: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5338: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F533C: 4E800421  bctrl
	ctx.lr = 0x823F5340;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F5340: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F5344: 41800014  blt 0x823f5358
	if ctx.cr[0].lt {
	pc = 0x823F5358; continue 'dispatch;
	}
	// 823F5348: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F534C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F5350: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F5354: 4198FFC8  blt cr6, 0x823f531c
	if ctx.cr[6].lt {
	pc = 0x823F531C; continue 'dispatch;
	}
            }
            0x823F5358 => {
    //   block [0x823F5358..0x823F5364)
	// 823F5358: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F535C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F5360: 4813FDA4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5368 size=116
    let mut pc: u32 = 0x823F5368;
    'dispatch: loop {
        match pc {
            0x823F5368 => {
    //   block [0x823F5368..0x823F5394)
	// 823F5368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F536C: 4813FD49  bl 0x825350b4
	ctx.lr = 0x823F5370;
	sub_82535080(ctx, base);
	// 823F5370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5374: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F5378: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F537C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823F5380: 639C0057  ori r28, r28, 0x57
	ctx.r[28].u64 = ctx.r[28].u64 | 87;
	// 823F5384: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F5388: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F538C: 419A0044  beq cr6, 0x823f53d0
	if ctx.cr[6].eq {
	pc = 0x823F53D0; continue 'dispatch;
	}
	// 823F5390: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x823F5394; continue 'dispatch;
            }
            0x823F5394 => {
    //   block [0x823F5394..0x823F53D0)
	// 823F5394: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F5398: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F539C: 4BFFF885  bl 0x823f4c20
	ctx.lr = 0x823F53A0;
	sub_823F4C20(ctx, base);
	// 823F53A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F53A4: 4182002C  beq 0x823f53d0
	if ctx.cr[0].eq {
	pc = 0x823F53D0; continue 'dispatch;
	}
	// 823F53A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F53AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F53B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F53B4: 4E800421  bctrl
	ctx.lr = 0x823F53B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F53B8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F53BC: 41800014  blt 0x823f53d0
	if ctx.cr[0].lt {
	pc = 0x823F53D0; continue 'dispatch;
	}
	// 823F53C0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F53C4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F53C8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F53CC: 4198FFC8  blt cr6, 0x823f5394
	if ctx.cr[6].lt {
	pc = 0x823F5394; continue 'dispatch;
	}
            }
            0x823F53D0 => {
    //   block [0x823F53D0..0x823F53DC)
	// 823F53D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F53D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F53D8: 4813FD2C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F53E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F53E0 size=156
    let mut pc: u32 = 0x823F53E0;
    'dispatch: loop {
        match pc {
            0x823F53E0 => {
    //   block [0x823F53E0..0x823F5448)
	// 823F53E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F53E4: 4813FCCD  bl 0x825350b0
	ctx.lr = 0x823F53E8;
	sub_82535080(ctx, base);
	// 823F53E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F53EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F53F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823F53F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823F53F8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 823F53FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F5400: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 823F5404: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823F5408: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823F540C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 823F5410: 4BFCC151  bl 0x823c1560
	ctx.lr = 0x823F5414;
	sub_823C1560(ctx, base);
	// 823F5414: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F5418: 9B7F0040  stb r27, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[27].u8 ) };
	// 823F541C: 409A002C  bne cr6, 0x823f5448
	if !ctx.cr[6].eq {
	pc = 0x823F5448; continue 'dispatch;
	}
	// 823F5420: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823F5424: 409A0024  bne cr6, 0x823f5448
	if !ctx.cr[6].eq {
	pc = 0x823F5448; continue 'dispatch;
	}
	// 823F5428: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F542C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F5430: 4BFFF6B9  bl 0x823f4ae8
	ctx.lr = 0x823F5434;
	sub_823F4AE8(ctx, base);
	// 823F5434: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 823F5438: 409A002C  bne cr6, 0x823f5464
	if !ctx.cr[6].eq {
	pc = 0x823F5464; continue 'dispatch;
	}
	// 823F543C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F5440: 4BFFFAD1  bl 0x823f4f10
	ctx.lr = 0x823F5444;
	sub_823F4F10(ctx, base);
	// 823F5444: 48000020  b 0x823f5464
	pc = 0x823F5464; continue 'dispatch;
            }
            0x823F5448 => {
    //   block [0x823F5448..0x823F5464)
	// 823F5448: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823F544C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F5450: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F5454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F5458: 4BFFF841  bl 0x823f4c98
	ctx.lr = 0x823F545C;
	sub_823F4C98(ctx, base);
	// 823F545C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F5460: 41800014  blt 0x823f5474
	if ctx.cr[0].lt {
	pc = 0x823F5474; continue 'dispatch;
	}
	pc = 0x823F5464; continue 'dispatch;
            }
            0x823F5464 => {
    //   block [0x823F5464..0x823F5474)
	// 823F5464: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5468: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F546C: FB5F0000  std r26, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 823F5470: 914B051C  stw r10, 0x51c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1308 as u32), ctx.r[10].u32 ) };
	pc = 0x823F5474; continue 'dispatch;
            }
            0x823F5474 => {
    //   block [0x823F5474..0x823F547C)
	// 823F5474: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823F5478: 4813FC88  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5480 size=136
    let mut pc: u32 = 0x823F5480;
    'dispatch: loop {
        match pc {
            0x823F5480 => {
    //   block [0x823F5480..0x823F54B0)
	// 823F5480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5484: 4813FC39  bl 0x825350bc
	ctx.lr = 0x823F5488;
	sub_82535080(ctx, base);
	// 823F5488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F548C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F5490: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F5494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5498: 4BFCC0C9  bl 0x823c1560
	ctx.lr = 0x823F549C;
	sub_823C1560(ctx, base);
	// 823F549C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F54A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F54A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F54A8: 40990030  ble cr6, 0x823f54d8
	if !ctx.cr[6].gt {
	pc = 0x823F54D8; continue 'dispatch;
	}
	// 823F54AC: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x823F54B0; continue 'dispatch;
            }
            0x823F54B0 => {
    //   block [0x823F54B0..0x823F54D8)
	// 823F54B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F54B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F54B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F54BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F54C0: 4E800421  bctrl
	ctx.lr = 0x823F54C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F54C4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F54C8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F54CC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F54D0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F54D4: 4198FFDC  blt cr6, 0x823f54b0
	if ctx.cr[6].lt {
	pc = 0x823F54B0; continue 'dispatch;
	}
            }
            0x823F54D8 => {
    //   block [0x823F54D8..0x823F54F0)
	// 823F54D8: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823F54DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F54E0: 41820010  beq 0x823f54f0
	if ctx.cr[0].eq {
	pc = 0x823F54F0; continue 'dispatch;
	}
	// 823F54E4: 4818E6C5  bl 0x82583ba8
	ctx.lr = 0x823F54E8;
	sub_82583BA8(ctx, base);
	// 823F54E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F54EC: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x823F54F0; continue 'dispatch;
            }
            0x823F54F0 => {
    //   block [0x823F54F0..0x823F5508)
	// 823F54F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F54F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F54F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F54FC: 914B051C  stw r10, 0x51c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1308 as u32), ctx.r[10].u32 ) };
	// 823F5500: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F5504: 4813FC08  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5508 size=116
    let mut pc: u32 = 0x823F5508;
    'dispatch: loop {
        match pc {
            0x823F5508 => {
    //   block [0x823F5508..0x823F555C)
	// 823F5508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F550C: 4813FBA9  bl 0x825350b4
	ctx.lr = 0x823F5510;
	sub_82535080(ctx, base);
	// 823F5510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5514: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F5518: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 823F551C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823F5520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5524: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823F5528: 808B72B4  lwz r4, 0x72b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29364 as u32) ) } as u64;
	// 823F552C: 63BD4005  ori r29, r29, 0x4005
	ctx.r[29].u64 = ctx.r[29].u64 | 16389;
	// 823F5530: 4BFFF6F1  bl 0x823f4c20
	ctx.lr = 0x823F5534;
	sub_823F4C20(ctx, base);
	// 823F5534: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F5538: 41820038  beq 0x823f5570
	if ctx.cr[0].eq {
	pc = 0x823F5570; continue 'dispatch;
	}
	// 823F553C: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5540: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F5544: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 823F5548: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823F554C: 419A0010  beq cr6, 0x823f555c
	if ctx.cr[6].eq {
	pc = 0x823F555C; continue 'dispatch;
	}
	// 823F5550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F5554: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 823F5558: 4BFFF9B9  bl 0x823f4f10
	ctx.lr = 0x823F555C;
	sub_823F4F10(ctx, base);
	pc = 0x823F555C; continue 'dispatch;
            }
            0x823F555C => {
    //   block [0x823F555C..0x823F5570)
	// 823F555C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823F5560: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F5564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F5568: 4BFFD1C9  bl 0x823f2730
	ctx.lr = 0x823F556C;
	sub_823F2730(ctx, base);
	// 823F556C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x823F5570; continue 'dispatch;
            }
            0x823F5570 => {
    //   block [0x823F5570..0x823F557C)
	// 823F5570: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F5574: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F5578: 4813FB8C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F5580 size=40
    let mut pc: u32 = 0x823F5580;
    'dispatch: loop {
        match pc {
            0x823F5580 => {
    //   block [0x823F5580..0x823F55A4)
	// 823F5580: 39640009  addi r11, r4, 9
	ctx.r[11].s64 = ctx.r[4].s64 + 9;
	// 823F5584: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F5588: 7D4B182E  lwzx r10, r11, r3
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 823F558C: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F5590: 419A0014  beq cr6, 0x823f55a4
	if ctx.cr[6].eq {
	pc = 0x823F55A4; continue 'dispatch;
	}
	// 823F5594: 7CAB192E  stwx r5, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[5].u32) };
	// 823F5598: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F559C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F55A0: 914B051C  stw r10, 0x51c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1308 as u32), ctx.r[10].u32 ) };
	pc = 0x823F55A4; continue 'dispatch;
            }
            0x823F55A4 => {
    //   block [0x823F55A4..0x823F55A8)
	// 823F55A4: 4BFFF96C  b 0x823f4f10
	sub_823F4F10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F55A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F55A8 size=196
    let mut pc: u32 = 0x823F55A8;
    'dispatch: loop {
        match pc {
            0x823F55A8 => {
    //   block [0x823F55A8..0x823F55D4)
	// 823F55A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F55AC: 4813FB0D  bl 0x825350b8
	ctx.lr = 0x823F55B0;
	sub_82535080(ctx, base);
	// 823F55B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F55B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F55B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F55BC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 823F55C0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F55C4: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	// 823F55C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F55CC: 4099003C  ble cr6, 0x823f5608
	if !ctx.cr[6].gt {
	pc = 0x823F5608; continue 'dispatch;
	}
	// 823F55D0: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x823F55D4; continue 'dispatch;
            }
            0x823F55D4 => {
    //   block [0x823F55D4..0x823F55F4)
	// 823F55D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F55D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F55DC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F55E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F55E4: 4E800421  bctrl
	ctx.lr = 0x823F55E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F55E8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 823F55EC: 409A0008  bne cr6, 0x823f55f4
	if !ctx.cr[6].eq {
	pc = 0x823F55F4; continue 'dispatch;
	}
	// 823F55F0: 939F0034  stw r28, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
            }
            0x823F55F4 => {
    //   block [0x823F55F4..0x823F5608)
	// 823F55F4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F55F8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F55FC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F5600: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F5604: 4198FFD0  blt cr6, 0x823f55d4
	if ctx.cr[6].lt {
	pc = 0x823F55D4; continue 'dispatch;
	}
	pc = 0x823F5608; continue 'dispatch;
            }
            0x823F5608 => {
    //   block [0x823F5608..0x823F5620)
	// 823F5608: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F560C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5610: 419A0010  beq cr6, 0x823f5620
	if ctx.cr[6].eq {
	pc = 0x823F5620; continue 'dispatch;
	}
	// 823F5614: 396000C8  li r11, 0xc8
	ctx.r[11].s64 = 200;
	// 823F5618: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 823F561C: 48000038  b 0x823f5654
	pc = 0x823F5654; continue 'dispatch;
            }
            0x823F5620 => {
    //   block [0x823F5620..0x823F5650)
	// 823F5620: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823F5624: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5628: 4099002C  ble cr6, 0x823f5654
	if !ctx.cr[6].gt {
	pc = 0x823F5654; continue 'dispatch;
	}
	// 823F562C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F5630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F5634: 419A001C  beq cr6, 0x823f5650
	if ctx.cr[6].eq {
	pc = 0x823F5650; continue 'dispatch;
	}
	// 823F5638: 4BFCA5A1  bl 0x823bfbd8
	ctx.lr = 0x823F563C;
	sub_823BFBD8(ctx, base);
	// 823F563C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F5640: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823F5644: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 823F5648: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F564C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x823F5650; continue 'dispatch;
            }
            0x823F5650 => {
    //   block [0x823F5650..0x823F5654)
	// 823F5650: 939F0034  stw r28, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	pc = 0x823F5654; continue 'dispatch;
            }
            0x823F5654 => {
    //   block [0x823F5654..0x823F566C)
	// 823F5654: 4BFCA585  bl 0x823bfbd8
	ctx.lr = 0x823F5658;
	sub_823BFBD8(ctx, base);
	// 823F5658: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823F565C: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F5660: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 823F5664: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F5668: 4813FAA0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5670 size=172
    let mut pc: u32 = 0x823F5670;
    'dispatch: loop {
        match pc {
            0x823F5670 => {
    //   block [0x823F5670..0x823F56A8)
	// 823F5670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5674: 4813FA41  bl 0x825350b4
	ctx.lr = 0x823F5678;
	sub_82535080(ctx, base);
	// 823F5678: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F567C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F5680: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F5684: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823F5688: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F568C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F5690: 4BFCBED1  bl 0x823c1560
	ctx.lr = 0x823F5694;
	sub_823C1560(ctx, base);
	// 823F5694: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F5698: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F569C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F56A0: 40990064  ble cr6, 0x823f5704
	if !ctx.cr[6].gt {
	pc = 0x823F5704; continue 'dispatch;
	}
	// 823F56A4: 3BFC0018  addi r31, r28, 0x18
	ctx.r[31].s64 = ctx.r[28].s64 + 24;
	pc = 0x823F56A8; continue 'dispatch;
            }
            0x823F56A8 => {
    //   block [0x823F56A8..0x823F56BC)
	// 823F56A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F56AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F56B0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F56B4: 83AA000C  lwz r29, 0xc(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F56B8: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	pc = 0x823F56BC; continue 'dispatch;
            }
            0x823F56BC => {
    //   block [0x823F56BC..0x823F56D4)
	// 823F56BC: 810AFFF8  lwz r8, -8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F56C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F56C4: 419A0010  beq cr6, 0x823f56d4
	if ctx.cr[6].eq {
	pc = 0x823F56D4; continue 'dispatch;
	}
	// 823F56C8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F56CC: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 823F56D0: 419A003C  beq cr6, 0x823f570c
	if ctx.cr[6].eq {
	pc = 0x823F570C; continue 'dispatch;
	}
	pc = 0x823F56D4; continue 'dispatch;
            }
            0x823F56D4 => {
    //   block [0x823F56D4..0x823F56E8)
	// 823F56D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823F56D8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F56DC: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 823F56E0: 4198FFDC  blt cr6, 0x823f56bc
	if ctx.cr[6].lt {
	pc = 0x823F56BC; continue 'dispatch;
	}
	// 823F56E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823F56E8; continue 'dispatch;
            }
            0x823F56E8 => {
    //   block [0x823F56E8..0x823F5704)
	// 823F56E8: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F56EC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F56F0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F56F4: 7C6BD92E  stwx r3, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[3].u32) };
	// 823F56F8: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F56FC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F5700: 4198FFA8  blt cr6, 0x823f56a8
	if ctx.cr[6].lt {
	pc = 0x823F56A8; continue 'dispatch;
	}
	pc = 0x823F5704; continue 'dispatch;
            }
            0x823F5704 => {
    //   block [0x823F5704..0x823F570C)
	// 823F5704: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F5708: 4813F9FC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x823F570C => {
    //   block [0x823F570C..0x823F571C)
	// 823F570C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5710: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 823F5714: 4800094D  bl 0x823f6060
	ctx.lr = 0x823F5718;
	sub_823F6060(ctx, base);
	// 823F5718: 4BFFFFD0  b 0x823f56e8
	pc = 0x823F56E8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5720 size=616
    let mut pc: u32 = 0x823F5720;
    'dispatch: loop {
        match pc {
            0x823F5720 => {
    //   block [0x823F5720..0x823F576C)
	// 823F5720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5724: 4813F969  bl 0x8253508c
	ctx.lr = 0x823F5728;
	sub_82535080(ctx, base);
	// 823F5728: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F572C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823F5730: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F5734: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 823F5738: 60848010  ori r4, r4, 0x8010
	ctx.r[4].u64 = ctx.r[4].u64 | 32784;
	// 823F573C: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 823F5740: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823F5744: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 823F5748: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 823F574C: 7D114378  mr r17, r8
	ctx.r[17].u64 = ctx.r[8].u64;
	// 823F5750: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823F5754: 4BFD4A6D  bl 0x823ca1c0
	ctx.lr = 0x823F5758;
	sub_823CA1C0(ctx, base);
	// 823F5758: 7C791B79  or. r25, r3, r3
	ctx.r[25].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823F575C: 40820010  bne 0x823f576c
	if !ctx.cr[0].eq {
	pc = 0x823F576C; continue 'dispatch;
	}
	// 823F5760: 3F408007  lis r26, -0x7ff9
	ctx.r[26].s64 = -2147024896;
	// 823F5764: 635A000E  ori r26, r26, 0xe
	ctx.r[26].u64 = ctx.r[26].u64 | 14;
	// 823F5768: 48000204  b 0x823f596c
	pc = 0x823F596C; continue 'dispatch;
            }
            0x823F576C => {
    //   block [0x823F576C..0x823F57A8)
	// 823F576C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F5770: 92990008  stw r20, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 823F5774: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 823F5778: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F577C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F5780: 91790044  stw r11, 0x44(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 823F5784: 4BFCBDDD  bl 0x823c1560
	ctx.lr = 0x823F5788;
	sub_823C1560(ctx, base);
	// 823F5788: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823F578C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F5790: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823F5794: 4BFCBDCD  bl 0x823c1560
	ctx.lr = 0x823F5798;
	sub_823C1560(ctx, base);
	// 823F5798: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F579C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823F57A0: 419A008C  beq cr6, 0x823f582c
	if ctx.cr[6].eq {
	pc = 0x823F582C; continue 'dispatch;
	}
	// 823F57A4: 3BF9000C  addi r31, r25, 0xc
	ctx.r[31].s64 = ctx.r[25].s64 + 12;
	pc = 0x823F57A8; continue 'dispatch;
            }
            0x823F57A8 => {
    //   block [0x823F57A8..0x823F582C)
	// 823F57A8: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 823F57AC: 40980080  bge cr6, 0x823f582c
	if !ctx.cr[6].lt {
	pc = 0x823F582C; continue 'dispatch;
	}
	// 823F57B0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F57B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823F57B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 823F57BC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823F57C0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 823F57C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F57C8: 4E800421  bctrl
	ctx.lr = 0x823F57CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F57CC: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F57D0: 4180005C  blt 0x823f582c
	if ctx.cr[0].lt {
	pc = 0x823F582C; continue 'dispatch;
	}
	// 823F57D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F57D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F57DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F57E0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F57E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F57E8: 4E800421  bctrl
	ctx.lr = 0x823F57EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F57EC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F57F0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 823F57F4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823F57F8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823F57FC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5800: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F5804: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F5808: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 823F580C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F5810: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F5814: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 823F5818: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 823F581C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5820: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F5824: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 823F5828: 4198FF80  blt cr6, 0x823f57a8
	if ctx.cr[6].lt {
	pc = 0x823F57A8; continue 'dispatch;
	}
            }
            0x823F582C => {
    //   block [0x823F582C..0x823F5850)
	// 823F582C: 39790014  addi r11, r25, 0x14
	ctx.r[11].s64 = ctx.r[25].s64 + 20;
	// 823F5830: 93D90014  stw r30, 0x14(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823F5834: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F5838: 41980134  blt cr6, 0x823f596c
	if ctx.cr[6].lt {
	pc = 0x823F596C; continue 'dispatch;
	}
	// 823F583C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823F5840: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 823F5844: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 823F5848: 3AC10060  addi r22, r1, 0x60
	ctx.r[22].s64 = ctx.r[1].s64 + 96;
	// 823F584C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x823F5850; continue 'dispatch;
            }
            0x823F5850 => {
    //   block [0x823F5850..0x823F5870)
	// 823F5850: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F5854: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F5858: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F585C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F5860: 4BFCBD01  bl 0x823c1560
	ctx.lr = 0x823F5864;
	sub_823C1560(ctx, base);
	// 823F5864: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 823F5868: 7FF7FB78  mr r23, r31
	ctx.r[23].u64 = ctx.r[31].u64;
	// 823F586C: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	pc = 0x823F5870; continue 'dispatch;
            }
            0x823F5870 => {
    //   block [0x823F5870..0x823F58A0)
	// 823F5870: 80770000  lwz r3, 0(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5874: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5878: 41820028  beq 0x823f58a0
	if ctx.cr[0].eq {
	pc = 0x823F58A0; continue 'dispatch;
	}
	// 823F587C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5880: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F5884: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F5888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F588C: 4E800421  bctrl
	ctx.lr = 0x823F5890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F5890: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823F5894: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F5898: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F589C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
            }
            0x823F58A0 => {
    //   block [0x823F58A0..0x823F58E4)
	// 823F58A0: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823F58A4: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 823F58A8: 4082FFC8  bne 0x823f5870
	if !ctx.cr[0].eq {
	pc = 0x823F5870; continue 'dispatch;
	}
	// 823F58AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F58B0: 419A0080  beq cr6, 0x823f5930
	if ctx.cr[6].eq {
	pc = 0x823F5930; continue 'dispatch;
	}
	// 823F58B4: 38FC0004  addi r7, r28, 4
	ctx.r[7].s64 = ctx.r[28].s64 + 4;
	// 823F58B8: 80960000  lwz r4, 0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F58BC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 823F58C0: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 823F58C4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 823F58C8: 4BFFF139  bl 0x823f4a00
	ctx.lr = 0x823F58CC;
	sub_823F4A00(ctx, base);
	// 823F58CC: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F58D0: 41800074  blt 0x823f5944
	if ctx.cr[0].lt {
	pc = 0x823F5944; continue 'dispatch;
	}
	// 823F58D4: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 823F58D8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823F58DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F58E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x823F58E4; continue 'dispatch;
            }
            0x823F58E4 => {
    //   block [0x823F58E4..0x823F5918)
	// 823F58E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F58E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F58EC: 4182002C  beq 0x823f5918
	if ctx.cr[0].eq {
	pc = 0x823F5918; continue 'dispatch;
	}
	// 823F58F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F58F4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823F58F8: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F58FC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 823F5900: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F5908: 4E800421  bctrl
	ctx.lr = 0x823F590C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F590C: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F5910: 41800034  blt 0x823f5944
	if ctx.cr[0].lt {
	pc = 0x823F5944; continue 'dispatch;
	}
	// 823F5914: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
            }
            0x823F5918 => {
    //   block [0x823F5918..0x823F5930)
	// 823F5918: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F591C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F5920: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 823F5924: 4198FFC0  blt cr6, 0x823f58e4
	if ctx.cr[6].lt {
	pc = 0x823F58E4; continue 'dispatch;
	}
	// 823F5928: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F592C: 41980018  blt cr6, 0x823f5944
	if ctx.cr[6].lt {
	pc = 0x823F5944; continue 'dispatch;
	}
	pc = 0x823F5930; continue 'dispatch;
            }
            0x823F5930 => {
    //   block [0x823F5930..0x823F5944)
	// 823F5930: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 823F5934: 3AD60004  addi r22, r22, 4
	ctx.r[22].s64 = ctx.r[22].s64 + 4;
	// 823F5938: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 823F593C: 2B150003  cmplwi cr6, r21, 3
	ctx.cr[6].compare_u32(ctx.r[21].u32, 3 as u32, &mut ctx.xer);
	// 823F5940: 4198FF10  blt cr6, 0x823f5850
	if ctx.cr[6].lt {
	pc = 0x823F5850; continue 'dispatch;
	}
	pc = 0x823F5944; continue 'dispatch;
            }
            0x823F5944 => {
    //   block [0x823F5944..0x823F596C)
	// 823F5944: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F5948: 93190020  stw r24, 0x20(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(32 as u32), ctx.r[24].u32 ) };
	// 823F594C: 41980020  blt cr6, 0x823f596c
	if ctx.cr[6].lt {
	pc = 0x823F596C; continue 'dispatch;
	}
	// 823F5950: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F5954: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 823F5958: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 823F595C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823F5960: 4BFFF339  bl 0x823f4c98
	ctx.lr = 0x823F5964;
	sub_823F4C98(ctx, base);
	// 823F5964: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F5968: 40800010  bge 0x823f5978
	if !ctx.cr[0].lt {
	pc = 0x823F5978; continue 'dispatch;
	}
	pc = 0x823F596C; continue 'dispatch;
            }
            0x823F596C => {
    //   block [0x823F596C..0x823F5978)
	// 823F596C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823F5970: 4BFFF7E9  bl 0x823f5158
	ctx.lr = 0x823F5974;
	sub_823F5158(ctx, base);
	// 823F5974: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x823F5978; continue 'dispatch;
            }
            0x823F5978 => {
    //   block [0x823F5978..0x823F5988)
	// 823F5978: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F597C: 93310000  stw r25, 0(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 823F5980: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823F5984: 4813F758  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F59A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F59A0 size=48
    let mut pc: u32 = 0x823F59A0;
    'dispatch: loop {
        match pc {
            0x823F59A0 => {
    //   block [0x823F59A0..0x823F59D0)
	// 823F59A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F59A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F59A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F59AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F59B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F59B4: 4BFCBBAD  bl 0x823c1560
	ctx.lr = 0x823F59B8;
	sub_823C1560(ctx, base);
	// 823F59B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F59BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F59C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F59C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F59C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F59CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F59D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F59D0 size=48
    let mut pc: u32 = 0x823F59D0;
    'dispatch: loop {
        match pc {
            0x823F59D0 => {
    //   block [0x823F59D0..0x823F5A00)
	// 823F59D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F59D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F59D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F59DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F59E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F59E4: 4813F16D  bl 0x82534b50
	ctx.lr = 0x823F59E8;
	sub_82534B50(ctx, base);
	// 823F59E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F59EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F59F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F59F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F59F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F59FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5A00 size=40
    let mut pc: u32 = 0x823F5A00;
    'dispatch: loop {
        match pc {
            0x823F5A00 => {
    //   block [0x823F5A00..0x823F5A28)
	// 823F5A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F5A08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5A0C: 38630034  addi r3, r3, 0x34
	ctx.r[3].s64 = ctx.r[3].s64 + 52;
	// 823F5A10: 48002FA1  bl 0x823f89b0
	ctx.lr = 0x823F5A14;
	sub_823F89B0(ctx, base);
	// 823F5A14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F5A18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F5A1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F5A20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F5A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5A28 size=40
    let mut pc: u32 = 0x823F5A28;
    'dispatch: loop {
        match pc {
            0x823F5A28 => {
    //   block [0x823F5A28..0x823F5A50)
	// 823F5A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F5A30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5A34: 38630034  addi r3, r3, 0x34
	ctx.r[3].s64 = ctx.r[3].s64 + 52;
	// 823F5A38: 480033A1  bl 0x823f8dd8
	ctx.lr = 0x823F5A3C;
	sub_823F8DD8(ctx, base);
	// 823F5A3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F5A40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F5A44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F5A48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F5A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5A60 size=100
    let mut pc: u32 = 0x823F5A60;
    'dispatch: loop {
        match pc {
            0x823F5A60 => {
    //   block [0x823F5A60..0x823F5AC4)
	// 823F5A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F5A68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5A6C: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F5A70: 386B5988  addi r3, r11, 0x5988
	ctx.r[3].s64 = ctx.r[11].s64 + 22920;
	// 823F5A74: 480034BD  bl 0x823f8f30
	ctx.lr = 0x823F5A78;
	sub_823F8F30(ctx, base);
	// 823F5A78: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F5A7C: 386B5A50  addi r3, r11, 0x5a50
	ctx.r[3].s64 = ctx.r[11].s64 + 23120;
	// 823F5A80: 480034C1  bl 0x823f8f40
	ctx.lr = 0x823F5A84;
	sub_823F8F40(ctx, base);
	// 823F5A84: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F5A88: 386B59A0  addi r3, r11, 0x59a0
	ctx.r[3].s64 = ctx.r[11].s64 + 22944;
	// 823F5A8C: 480034C5  bl 0x823f8f50
	ctx.lr = 0x823F5A90;
	sub_823F8F50(ctx, base);
	// 823F5A90: 3D60823F  lis r11, -0x7dc1
	ctx.r[11].s64 = -2109800448;
	// 823F5A94: 386B59D0  addi r3, r11, 0x59d0
	ctx.r[3].s64 = ctx.r[11].s64 + 22992;
	// 823F5A98: 480034C9  bl 0x823f8f60
	ctx.lr = 0x823F5A9C;
	sub_823F8F60(ctx, base);
	// 823F5A9C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 823F5AA0: 386B6328  addi r3, r11, 0x6328
	ctx.r[3].s64 = ctx.r[11].s64 + 25384;
	// 823F5AA4: 480034CD  bl 0x823f8f70
	ctx.lr = 0x823F5AA8;
	sub_823F8F70(ctx, base);
	// 823F5AA8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 823F5AAC: 386B6258  addi r3, r11, 0x6258
	ctx.r[3].s64 = ctx.r[11].s64 + 25176;
	// 823F5AB0: 480034D1  bl 0x823f8f80
	ctx.lr = 0x823F5AB4;
	sub_823F8F80(ctx, base);
	// 823F5AB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F5AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F5ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F5AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5AC8 size=128
    let mut pc: u32 = 0x823F5AC8;
    'dispatch: loop {
        match pc {
            0x823F5AC8 => {
    //   block [0x823F5AC8..0x823F5B0C)
	// 823F5AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F5AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F5AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F5AD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5ADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5AE0: 4BFFFF81  bl 0x823f5a60
	ctx.lr = 0x823F5AE4;
	sub_823F5A60(ctx, base);
	// 823F5AE4: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 823F5AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F5AEC: 48002FE5  bl 0x823f8ad0
	ctx.lr = 0x823F5AF0;
	sub_823F8AD0(ctx, base);
	// 823F5AF0: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5AF4: 41820018  beq 0x823f5b0c
	if ctx.cr[0].eq {
	pc = 0x823F5B0C; continue 'dispatch;
	}
	// 823F5AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F5AFC: 48002EB5  bl 0x823f89b0
	ctx.lr = 0x823F5B00;
	sub_823F89B0(ctx, base);
	// 823F5B00: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823F5B04: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823F5B08: 48000028  b 0x823f5b30
	pc = 0x823F5B30; continue 'dispatch;
            }
            0x823F5B0C => {
    //   block [0x823F5B0C..0x823F5B30)
	// 823F5B0C: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 823F5B10: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 823F5B14: 393F0180  addi r9, r31, 0x180
	ctx.r[9].s64 = ctx.r[31].s64 + 384;
	// 823F5B18: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 823F5B1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F5B20: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823F5B24: B15F0020  sth r10, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u16 ) };
	// 823F5B28: 913F0024  stw r9, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 823F5B2C: B11F0028  sth r8, 0x28(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u16 ) };
	pc = 0x823F5B30; continue 'dispatch;
            }
            0x823F5B30 => {
    //   block [0x823F5B30..0x823F5B48)
	// 823F5B30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F5B34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F5B38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F5B3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F5B40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F5B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5B48 size=512
    let mut pc: u32 = 0x823F5B48;
    'dispatch: loop {
        match pc {
            0x823F5B48 => {
    //   block [0x823F5B48..0x823F5B8C)
	// 823F5B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5B4C: 4813F54D  bl 0x82535098
	ctx.lr = 0x823F5B50;
	sub_82535080(ctx, base);
	// 823F5B50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5B58: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823F5B5C: 3AFF0008  addi r23, r31, 8
	ctx.r[23].s64 = ctx.r[31].s64 + 8;
	// 823F5B60: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 823F5B64: 7F14C378  mr r20, r24
	ctx.r[20].u64 = ctx.r[24].u64;
	// 823F5B68: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5B6C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 823F5B70: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 823F5B74: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823F5B78: 832A0008  lwz r25, 8(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5B7C: 395F001C  addi r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 + 28;
	// 823F5B80: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 823F5B84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 823F5B88: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	pc = 0x823F5B8C; continue 'dispatch;
            }
            0x823F5B8C => {
    //   block [0x823F5B8C..0x823F5BB0)
	// 823F5B8C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5B90: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5B94: 41820034  beq 0x823f5bc8
	if ctx.cr[0].eq {
	pc = 0x823F5BC8; continue 'dispatch;
	}
	// 823F5B98: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5B9C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 823F5BA0: 409A0010  bne cr6, 0x823f5bb0
	if !ctx.cr[6].eq {
	pc = 0x823F5BB0; continue 'dispatch;
	}
	// 823F5BA4: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5BA8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823F5BAC: 48000008  b 0x823f5bb4
	pc = 0x823F5BB4; continue 'dispatch;
            }
            0x823F5BB0 => {
    //   block [0x823F5BB0..0x823F5BB4)
	// 823F5BB0: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x823F5BB4; continue 'dispatch;
            }
            0x823F5BB4 => {
    //   block [0x823F5BB4..0x823F5BC8)
	// 823F5BB4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5BB8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F5BBC: 419A0010  beq cr6, 0x823f5bcc
	if ctx.cr[6].eq {
	pc = 0x823F5BCC; continue 'dispatch;
	}
	// 823F5BC0: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 823F5BC4: 48000008  b 0x823f5bcc
	pc = 0x823F5BCC; continue 'dispatch;
            }
            0x823F5BC8 => {
    //   block [0x823F5BC8..0x823F5BCC)
	// 823F5BC8: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x823F5BCC; continue 'dispatch;
            }
            0x823F5BCC => {
    //   block [0x823F5BCC..0x823F5BF4)
	// 823F5BCC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F5BD0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F5BD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F5BD8: 4082FFB4  bne 0x823f5b8c
	if !ctx.cr[0].eq {
	pc = 0x823F5B8C; continue 'dispatch;
	}
	// 823F5BDC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823F5BE0: 419A015C  beq cr6, 0x823f5d3c
	if ctx.cr[6].eq {
	pc = 0x823F5D3C; continue 'dispatch;
	}
	// 823F5BE4: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 823F5BE8: 419A0154  beq cr6, 0x823f5d3c
	if ctx.cr[6].eq {
	pc = 0x823F5D3C; continue 'dispatch;
	}
	// 823F5BEC: 7F16C378  mr r22, r24
	ctx.r[22].u64 = ctx.r[24].u64;
	// 823F5BF0: 48000144  b 0x823f5d34
	pc = 0x823F5D34; continue 'dispatch;
            }
            0x823F5BF4 => {
    //   block [0x823F5BF4..0x823F5C68)
	// 823F5BF4: 3AB5FFFF  addi r21, r21, -1
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	// 823F5BF8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823F5BFC: 419A0140  beq cr6, 0x823f5d3c
	if ctx.cr[6].eq {
	pc = 0x823F5D3C; continue 'dispatch;
	}
	// 823F5C00: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 823F5C04: 419A0138  beq cr6, 0x823f5d3c
	if ctx.cr[6].eq {
	pc = 0x823F5D3C; continue 'dispatch;
	}
	// 823F5C08: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F5C0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F5C10: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5C14: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 823F5C18: 387F0190  addi r3, r31, 0x190
	ctx.r[3].s64 = ctx.r[31].s64 + 400;
	// 823F5C1C: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F5C20: 5546F87E  srwi r6, r10, 1
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823F5C24: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5C28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5C2C: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F5C30: 48002771  bl 0x823f83a0
	ctx.lr = 0x823F5C34;
	sub_823F83A0(ctx, base);
	// 823F5C34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F5C38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 823F5C3C: B31F002E  sth r24, 0x2e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(46 as u32), ctx.r[24].u16 ) };
	// 823F5C40: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 823F5C44: 9B1F0030  stb r24, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[24].u8 ) };
	// 823F5C48: 48002C01  bl 0x823f8848
	ctx.lr = 0x823F5C4C;
	sub_823F8848(ctx, base);
	// 823F5C4C: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5C50: 408200EC  bne 0x823f5d3c
	if !ctx.cr[0].eq {
	pc = 0x823F5D3C; continue 'dispatch;
	}
	// 823F5C54: A3BF002E  lhz r29, 0x2e(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 823F5C58: 7F16C378  mr r22, r24
	ctx.r[22].u64 = ctx.r[24].u64;
	// 823F5C5C: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 823F5C60: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 823F5C64: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	pc = 0x823F5C68; continue 'dispatch;
            }
            0x823F5C68 => {
    //   block [0x823F5C68..0x823F5CAC)
	// 823F5C68: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5C6C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5C70: 4182006C  beq 0x823f5cdc
	if ctx.cr[0].eq {
	pc = 0x823F5CDC; continue 'dispatch;
	}
	// 823F5C74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5C78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823F5C7C: 389F0180  addi r4, r31, 0x180
	ctx.r[4].s64 = ctx.r[31].s64 + 384;
	// 823F5C80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5C84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5C88: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F5C8C: 4813EEC5  bl 0x82534b50
	ctx.lr = 0x823F5C90;
	sub_82534B50(ctx, base);
	// 823F5C90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5C94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5C98: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5C9C: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 823F5CA0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F5CA4: 40980008  bge cr6, 0x823f5cac
	if !ctx.cr[6].lt {
	pc = 0x823F5CAC; continue 'dispatch;
	}
	// 823F5CA8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F5CAC; continue 'dispatch;
            }
            0x823F5CAC => {
    //   block [0x823F5CAC..0x823F5CDC)
	// 823F5CAC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F5CB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5CB4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5CB8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F5CBC: 409A0020  bne cr6, 0x823f5cdc
	if !ctx.cr[6].eq {
	pc = 0x823F5CDC; continue 'dispatch;
	}
	// 823F5CC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F5CC4: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5CC8: 480003B9  bl 0x823f6080
	ctx.lr = 0x823F5CCC;
	sub_823F6080(ctx, base);
	// 823F5CCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5CD0: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823F5CD4: 40820008  bne 0x823f5cdc
	if !ctx.cr[0].eq {
	pc = 0x823F5CDC; continue 'dispatch;
	}
	// 823F5CD8: 3A94FFFF  addi r20, r20, -1
	ctx.r[20].s64 = ctx.r[20].s64 + -1;
	pc = 0x823F5CDC; continue 'dispatch;
            }
            0x823F5CDC => {
    //   block [0x823F5CDC..0x823F5D10)
	// 823F5CDC: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F5CE0: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 823F5CE4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823F5CE8: 4082FF80  bne 0x823f5c68
	if !ctx.cr[0].eq {
	pc = 0x823F5C68; continue 'dispatch;
	}
	// 823F5CEC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F5CF0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5CF4: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F5CF8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5CFC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5D00: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 823F5D04: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F5D08: 40980008  bge cr6, 0x823f5d10
	if !ctx.cr[6].lt {
	pc = 0x823F5D10; continue 'dispatch;
	}
	// 823F5D0C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F5D10; continue 'dispatch;
            }
            0x823F5D10 => {
    //   block [0x823F5D10..0x823F5D34)
	// 823F5D10: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F5D14: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5D18: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5D1C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F5D20: 409A0014  bne cr6, 0x823f5d34
	if !ctx.cr[6].eq {
	pc = 0x823F5D34; continue 'dispatch;
	}
	// 823F5D24: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 823F5D28: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5D2C: 48000355  bl 0x823f6080
	ctx.lr = 0x823F5D30;
	sub_823F6080(ctx, base);
	// 823F5D30: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	pc = 0x823F5D34; continue 'dispatch;
            }
            0x823F5D34 => {
    //   block [0x823F5D34..0x823F5D3C)
	// 823F5D34: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 823F5D38: 409AFEBC  bne cr6, 0x823f5bf4
	if !ctx.cr[6].eq {
	pc = 0x823F5BF4; continue 'dispatch;
	}
	pc = 0x823F5D3C; continue 'dispatch;
            }
            0x823F5D3C => {
    //   block [0x823F5D3C..0x823F5D48)
	// 823F5D3C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 823F5D40: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823F5D44: 4813F3A4  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5D48 size=120
    let mut pc: u32 = 0x823F5D48;
    'dispatch: loop {
        match pc {
            0x823F5D48 => {
    //   block [0x823F5D48..0x823F5D8C)
	// 823F5D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F5D50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F5D54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F5D58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5D5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5D60: 4BFFFD01  bl 0x823f5a60
	ctx.lr = 0x823F5D64;
	sub_823F5A60(ctx, base);
	// 823F5D64: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 823F5D68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F5D6C: 480031BD  bl 0x823f8f28
	ctx.lr = 0x823F5D70;
	sub_823F8F28(ctx, base);
	// 823F5D70: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5D74: 41820018  beq 0x823f5d8c
	if ctx.cr[0].eq {
	pc = 0x823F5D8C; continue 'dispatch;
	}
	// 823F5D78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F5D7C: 4800305D  bl 0x823f8dd8
	ctx.lr = 0x823F5D80;
	sub_823F8DD8(ctx, base);
	// 823F5D80: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823F5D84: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823F5D88: 48000020  b 0x823f5da8
	pc = 0x823F5DA8; continue 'dispatch;
            }
            0x823F5D8C => {
    //   block [0x823F5D8C..0x823F5DA8)
	// 823F5D8C: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 823F5D90: 395F02C0  addi r10, r31, 0x2c0
	ctx.r[10].s64 = ctx.r[31].s64 + 704;
	// 823F5D94: 39200009  li r9, 9
	ctx.r[9].s64 = 9;
	// 823F5D98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F5D9C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 823F5DA0: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823F5DA4: B13F0028  sth r9, 0x28(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u16 ) };
	pc = 0x823F5DA8; continue 'dispatch;
            }
            0x823F5DA8 => {
    //   block [0x823F5DA8..0x823F5DC0)
	// 823F5DA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F5DAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F5DB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F5DB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F5DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F5DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F5DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F5DC0 size=672
    let mut pc: u32 = 0x823F5DC0;
    'dispatch: loop {
        match pc {
            0x823F5DC0 => {
    //   block [0x823F5DC0..0x823F5E04)
	// 823F5DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F5DC4: 4813F2C9  bl 0x8253508c
	ctx.lr = 0x823F5DC8;
	sub_82535080(ctx, base);
	// 823F5DC8: 9421FC90  stwu r1, -0x370(r1)
	ea = ctx.r[1].u32.wrapping_add(-880 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F5DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F5DD0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 823F5DD4: 3ABF001C  addi r21, r31, 0x1c
	ctx.r[21].s64 = ctx.r[31].s64 + 28;
	// 823F5DD8: 3A9F0008  addi r20, r31, 8
	ctx.r[20].s64 = ctx.r[31].s64 + 8;
	// 823F5DDC: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 823F5DE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5DE4: 7EF2BB78  mr r18, r23
	ctx.r[18].u64 = ctx.r[23].u64;
	// 823F5DE8: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 823F5DEC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823F5DF0: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 823F5DF4: 82CB0008  lwz r22, 8(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5DF8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F5DFC: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 823F5E00: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	pc = 0x823F5E04; continue 'dispatch;
            }
            0x823F5E04 => {
    //   block [0x823F5E04..0x823F5E28)
	// 823F5E04: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5E08: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5E0C: 41820034  beq 0x823f5e40
	if ctx.cr[0].eq {
	pc = 0x823F5E40; continue 'dispatch;
	}
	// 823F5E10: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5E14: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 823F5E18: 409A0010  bne cr6, 0x823f5e28
	if !ctx.cr[6].eq {
	pc = 0x823F5E28; continue 'dispatch;
	}
	// 823F5E1C: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5E20: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823F5E24: 48000008  b 0x823f5e2c
	pc = 0x823F5E2C; continue 'dispatch;
            }
            0x823F5E28 => {
    //   block [0x823F5E28..0x823F5E2C)
	// 823F5E28: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x823F5E2C; continue 'dispatch;
            }
            0x823F5E2C => {
    //   block [0x823F5E2C..0x823F5E40)
	// 823F5E2C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5E30: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F5E34: 419A0010  beq cr6, 0x823f5e44
	if ctx.cr[6].eq {
	pc = 0x823F5E44; continue 'dispatch;
	}
	// 823F5E38: 3A520001  addi r18, r18, 1
	ctx.r[18].s64 = ctx.r[18].s64 + 1;
	// 823F5E3C: 48000008  b 0x823f5e44
	pc = 0x823F5E44; continue 'dispatch;
            }
            0x823F5E40 => {
    //   block [0x823F5E40..0x823F5E44)
	// 823F5E40: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x823F5E44; continue 'dispatch;
            }
            0x823F5E44 => {
    //   block [0x823F5E44..0x823F5E6C)
	// 823F5E44: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F5E48: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F5E4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F5E50: 4082FFB4  bne 0x823f5e04
	if !ctx.cr[0].eq {
	pc = 0x823F5E04; continue 'dispatch;
	}
	// 823F5E54: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823F5E58: 419A01FC  beq cr6, 0x823f6054
	if ctx.cr[6].eq {
	pc = 0x823F6054; continue 'dispatch;
	}
	// 823F5E5C: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 823F5E60: 419A01F4  beq cr6, 0x823f6054
	if ctx.cr[6].eq {
	pc = 0x823F6054; continue 'dispatch;
	}
	// 823F5E64: 7EF1BB78  mr r17, r23
	ctx.r[17].u64 = ctx.r[23].u64;
	// 823F5E68: 480001E4  b 0x823f604c
	pc = 0x823F604C; continue 'dispatch;
            }
            0x823F5E6C => {
    //   block [0x823F5E6C..0x823F5EB8)
	// 823F5E6C: 3A73FFFF  addi r19, r19, -1
	ctx.r[19].s64 = ctx.r[19].s64 + -1;
	// 823F5E70: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823F5E74: 419A01E0  beq cr6, 0x823f6054
	if ctx.cr[6].eq {
	pc = 0x823F6054; continue 'dispatch;
	}
	// 823F5E78: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 823F5E7C: 419A01D8  beq cr6, 0x823f6054
	if ctx.cr[6].eq {
	pc = 0x823F6054; continue 'dispatch;
	}
	// 823F5E80: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F5E84: 387F02C0  addi r3, r31, 0x2c0
	ctx.r[3].s64 = ctx.r[31].s64 + 704;
	// 823F5E88: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5E8C: 80AA0018  lwz r5, 0x18(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F5E90: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5E94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5E98: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F5E9C: 4813ECB5  bl 0x82534b50
	ctx.lr = 0x823F5EA0;
	sub_82534B50(ctx, base);
	// 823F5EA0: 3B9F0040  addi r28, r31, 0x40
	ctx.r[28].s64 = ctx.r[31].s64 + 64;
	// 823F5EA4: B2FF0020  sth r23, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[23].u16 ) };
	// 823F5EA8: 3BDF0034  addi r30, r31, 0x34
	ctx.r[30].s64 = ctx.r[31].s64 + 52;
	// 823F5EAC: B2FF002A  sth r23, 0x2a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(42 as u32), ctx.r[23].u16 ) };
	// 823F5EB0: 9AFF002C  stb r23, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[23].u8 ) };
	// 823F5EB4: 93950000  stw r28, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F5EB8; continue 'dispatch;
            }
            0x823F5EB8 => {
    //   block [0x823F5EB8..0x823F5F04)
	// 823F5EB8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823F5EBC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 823F5EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F5EC4: 48002DAD  bl 0x823f8c70
	ctx.lr = 0x823F5EC8;
	sub_823F8C70(ctx, base);
	// 823F5EC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F5ECC: 57AB043F  clrlwi. r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5ED0: 40820034  bne 0x823f5f04
	if !ctx.cr[0].eq {
	pc = 0x823F5F04; continue 'dispatch;
	}
	// 823F5ED4: A17F0020  lhz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F5ED8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823F5EDC: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5EE0: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 823F5EE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5EE8: B2FF0020  sth r23, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[23].u16 ) };
	// 823F5EEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F5EF0: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F5EF4: 48002E15  bl 0x823f8d08
	ctx.lr = 0x823F5EF8;
	sub_823F8D08(ctx, base);
	// 823F5EF8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823F5EFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5F00: 4182FFB8  beq 0x823f5eb8
	if ctx.cr[0].eq {
	pc = 0x823F5EB8; continue 'dispatch;
	}
	pc = 0x823F5F04; continue 'dispatch;
            }
            0x823F5F04 => {
    //   block [0x823F5F04..0x823F5F4C)
	// 823F5F04: 57AB043F  clrlwi. r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F5F08: 4082014C  bne 0x823f6054
	if !ctx.cr[0].eq {
	pc = 0x823F6054; continue 'dispatch;
	}
	// 823F5F0C: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 823F5F10: A31F002A  lhz r24, 0x2a(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 823F5F14: 38A00140  li r5, 0x140
	ctx.r[5].s64 = 320;
	// 823F5F18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F5F1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F5F20: B17F0020  sth r11, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 823F5F24: 4813EC2D  bl 0x82534b50
	ctx.lr = 0x823F5F28;
	sub_82534B50(ctx, base);
	// 823F5F28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 823F5F2C: 38C000A0  li r6, 0xa0
	ctx.r[6].s64 = 160;
	// 823F5F30: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 823F5F34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F5F38: 387F02D0  addi r3, r31, 0x2d0
	ctx.r[3].s64 = ctx.r[31].s64 + 720;
	// 823F5F3C: 48002465  bl 0x823f83a0
	ctx.lr = 0x823F5F40;
	sub_823F83A0(ctx, base);
	// 823F5F40: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 823F5F44: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 823F5F48: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	pc = 0x823F5F4C; continue 'dispatch;
            }
            0x823F5F4C => {
    //   block [0x823F5F4C..0x823F5F94)
	// 823F5F4C: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5F50: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5F54: 418200A8  beq 0x823f5ffc
	if ctx.cr[0].eq {
	pc = 0x823F5FFC; continue 'dispatch;
	}
	// 823F5F58: A17F0020  lhz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F5F5C: 39401F40  li r10, 0x1f40
	ctx.r[10].s64 = 8000;
	// 823F5F60: 1D6B3E80  mulli r11, r11, 0x3e80
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 16000 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F5F64: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 823F5F68: 557D083C  slwi r29, r11, 1
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 823F5F6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5F70: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5F74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5F78: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823F5F7C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F5F80: 41980014  blt cr6, 0x823f5f94
	if ctx.cr[6].lt {
	pc = 0x823F5F94; continue 'dispatch;
	}
	// 823F5F84: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5F88: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5F8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5F90: 7FAB5050  subf r29, r11, r10
	ctx.r[29].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x823F5F94; continue 'dispatch;
            }
            0x823F5F94 => {
    //   block [0x823F5F94..0x823F5FCC)
	// 823F5F94: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5F98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823F5F9C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823F5FA0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F5FA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5FA8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F5FAC: 4813EBA5  bl 0x82534b50
	ctx.lr = 0x823F5FB0;
	sub_82534B50(ctx, base);
	// 823F5FB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5FB4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F5FB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5FBC: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 823F5FC0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F5FC4: 40980008  bge cr6, 0x823f5fcc
	if !ctx.cr[6].lt {
	pc = 0x823F5FCC; continue 'dispatch;
	}
	// 823F5FC8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F5FCC; continue 'dispatch;
            }
            0x823F5FCC => {
    //   block [0x823F5FCC..0x823F5FFC)
	// 823F5FCC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F5FD0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5FD4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F5FD8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F5FDC: 409A0020  bne cr6, 0x823f5ffc
	if !ctx.cr[6].eq {
	pc = 0x823F5FFC; continue 'dispatch;
	}
	// 823F5FE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F5FE4: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F5FE8: 48000099  bl 0x823f6080
	ctx.lr = 0x823F5FEC;
	sub_823F6080(ctx, base);
	// 823F5FEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F5FF0: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823F5FF4: 40820008  bne 0x823f5ffc
	if !ctx.cr[0].eq {
	pc = 0x823F5FFC; continue 'dispatch;
	}
	// 823F5FF8: 3A52FFFF  addi r18, r18, -1
	ctx.r[18].s64 = ctx.r[18].s64 + -1;
	pc = 0x823F5FFC; continue 'dispatch;
            }
            0x823F5FFC => {
    //   block [0x823F5FFC..0x823F6028)
	// 823F5FFC: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823F6000: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 823F6004: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 823F6008: 4082FF44  bne 0x823f5f4c
	if !ctx.cr[0].eq {
	pc = 0x823F5F4C; continue 'dispatch;
	}
	// 823F600C: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6010: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6014: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6018: 7D384A14  add r9, r24, r9
	ctx.r[9].u64 = ctx.r[24].u64 + ctx.r[9].u64;
	// 823F601C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F6020: 40980008  bge cr6, 0x823f6028
	if !ctx.cr[6].lt {
	pc = 0x823F6028; continue 'dispatch;
	}
	// 823F6024: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F6028; continue 'dispatch;
            }
            0x823F6028 => {
    //   block [0x823F6028..0x823F604C)
	// 823F6028: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F602C: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6030: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6034: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F6038: 409A0014  bne cr6, 0x823f604c
	if !ctx.cr[6].eq {
	pc = 0x823F604C; continue 'dispatch;
	}
	// 823F603C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 823F6040: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6044: 4800003D  bl 0x823f6080
	ctx.lr = 0x823F6048;
	sub_823F6080(ctx, base);
	// 823F6048: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	pc = 0x823F604C; continue 'dispatch;
            }
            0x823F604C => {
    //   block [0x823F604C..0x823F6054)
	// 823F604C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 823F6050: 409AFE1C  bne cr6, 0x823f5e6c
	if !ctx.cr[6].eq {
	pc = 0x823F5E6C; continue 'dispatch;
	}
	pc = 0x823F6054; continue 'dispatch;
            }
            0x823F6054 => {
    //   block [0x823F6054..0x823F6060)
	// 823F6054: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 823F6058: 38210370  addi r1, r1, 0x370
	ctx.r[1].s64 = ctx.r[1].s64 + 880;
	// 823F605C: 4813F080  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F6060 size=32
    let mut pc: u32 = 0x823F6060;
    'dispatch: loop {
        match pc {
            0x823F6060 => {
    //   block [0x823F6060..0x823F606C)
	// 823F6060: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6064: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F6068: 4800000C  b 0x823f6074
	pc = 0x823F6074; continue 'dispatch;
            }
            0x823F606C => {
    //   block [0x823F606C..0x823F6074)
	// 823F606C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6070: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x823F6074; continue 'dispatch;
            }
            0x823F6074 => {
    //   block [0x823F6074..0x823F6080)
	// 823F6074: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6078: 4082FFF4  bne 0x823f606c
	if !ctx.cr[0].eq {
	pc = 0x823F606C; continue 'dispatch;
	}
	// 823F607C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F6080 size=128
    let mut pc: u32 = 0x823F6080;
    'dispatch: loop {
        match pc {
            0x823F6080 => {
    //   block [0x823F6080..0x823F609C)
	// 823F6080: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6084: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823F6088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F608C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6090: 2F090103  cmpwi cr6, r9, 0x103
	ctx.cr[6].compare_i32(ctx.r[9].s32, 259, &mut ctx.xer);
	// 823F6094: 409A0008  bne cr6, 0x823f609c
	if !ctx.cr[6].eq {
	pc = 0x823F609C; continue 'dispatch;
	}
	// 823F6098: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F609C; continue 'dispatch;
            }
            0x823F609C => {
    //   block [0x823F609C..0x823F60CC)
	// 823F609C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F60A0: 39280008  addi r9, r8, 8
	ctx.r[9].s64 = ctx.r[8].s64 + 8;
	// 823F60A4: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F60A8: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F60AC: 409A002C  bne cr6, 0x823f60d8
	if !ctx.cr[6].eq {
	pc = 0x823F60D8; continue 'dispatch;
	}
	// 823F60B0: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F60B4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F60B8: 41820020  beq 0x823f60d8
	if ctx.cr[0].eq {
	pc = 0x823F60D8; continue 'dispatch;
	}
	// 823F60BC: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F60C0: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823F60C4: 409A0008  bne cr6, 0x823f60cc
	if !ctx.cr[6].eq {
	pc = 0x823F60CC; continue 'dispatch;
	}
	// 823F60C8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823F60CC; continue 'dispatch;
            }
            0x823F60CC => {
    //   block [0x823F60CC..0x823F60D8)
	// 823F60CC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F60D0: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823F60D4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823F60D8; continue 'dispatch;
            }
            0x823F60D8 => {
    //   block [0x823F60D8..0x823F60F0)
	// 823F60D8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F60DC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F60E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F60E4: 4182000C  beq 0x823f60f0
	if ctx.cr[0].eq {
	pc = 0x823F60F0; continue 'dispatch;
	}
	// 823F60E8: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F60EC: 48000008  b 0x823f60f4
	pc = 0x823F60F4; continue 'dispatch;
            }
            0x823F60F0 => {
    //   block [0x823F60F0..0x823F60F4)
	// 823F60F0: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x823F60F4; continue 'dispatch;
            }
            0x823F60F4 => {
    //   block [0x823F60F4..0x823F6100)
	// 823F60F4: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F60F8: 90880004  stw r4, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F60FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6100 size=156
    let mut pc: u32 = 0x823F6100;
    'dispatch: loop {
        match pc {
            0x823F6100 => {
    //   block [0x823F6100..0x823F6134)
	// 823F6100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6104: 4813EFB5  bl 0x825350b8
	ctx.lr = 0x823F6108;
	sub_82535080(ctx, base);
	// 823F6108: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F610C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F6110: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823F6114: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F6118: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F611C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6120: 4182005C  beq 0x823f617c
	if ctx.cr[0].eq {
	pc = 0x823F617C; continue 'dispatch;
	}
	// 823F6124: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6128: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F612C: 409A0008  bne cr6, 0x823f6134
	if !ctx.cr[6].eq {
	pc = 0x823F6134; continue 'dispatch;
	}
	// 823F6130: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x823F6134; continue 'dispatch;
            }
            0x823F6134 => {
    //   block [0x823F6134..0x823F617C)
	// 823F6134: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6138: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F613C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F6140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6144: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F6148: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F614C: 4BFCB415  bl 0x823c1560
	ctx.lr = 0x823F6150;
	sub_823C1560(ctx, base);
	// 823F6150: 39400103  li r10, 0x103
	ctx.r[10].s64 = 259;
	// 823F6154: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F6158: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 823F615C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F6160: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F6164: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F6168: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F616C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6170: 41820018  beq 0x823f6188
	if ctx.cr[0].eq {
	pc = 0x823F6188; continue 'dispatch;
	}
	// 823F6174: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F6178: 48000014  b 0x823f618c
	pc = 0x823F618C; continue 'dispatch;
            }
            0x823F617C => {
    //   block [0x823F617C..0x823F6188)
	// 823F617C: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F6180: 639C007A  ori r28, r28, 0x7a
	ctx.r[28].u64 = ctx.r[28].u64 | 122;
	// 823F6184: 4800000C  b 0x823f6190
	pc = 0x823F6190; continue 'dispatch;
            }
            0x823F6188 => {
    //   block [0x823F6188..0x823F618C)
	// 823F6188: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823F618C; continue 'dispatch;
            }
            0x823F618C => {
    //   block [0x823F618C..0x823F6190)
	// 823F618C: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x823F6190; continue 'dispatch;
            }
            0x823F6190 => {
    //   block [0x823F6190..0x823F619C)
	// 823F6190: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F6194: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F6198: 4813EF70  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F61A0 size=96
    let mut pc: u32 = 0x823F61A0;
    'dispatch: loop {
        match pc {
            0x823F61A0 => {
    //   block [0x823F61A0..0x823F61DC)
	// 823F61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F61A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F61A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F61AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F61B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F61B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F61B8: 419A0034  beq cr6, 0x823f61ec
	if ctx.cr[6].eq {
	pc = 0x823F61EC; continue 'dispatch;
	}
	// 823F61BC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F61C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F61C4: 41820018  beq 0x823f61dc
	if ctx.cr[0].eq {
	pc = 0x823F61DC; continue 'dispatch;
	}
	// 823F61C8: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F61CC: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823F61D0: 4BFD4089  bl 0x823ca258
	ctx.lr = 0x823F61D4;
	sub_823CA258(ctx, base);
	// 823F61D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F61D8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x823F61DC; continue 'dispatch;
            }
            0x823F61DC => {
    //   block [0x823F61DC..0x823F61EC)
	// 823F61DC: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F61E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F61E4: 60848005  ori r4, r4, 0x8005
	ctx.r[4].u64 = ctx.r[4].u64 | 32773;
	// 823F61E8: 4BFD4071  bl 0x823ca258
	ctx.lr = 0x823F61EC;
	sub_823CA258(ctx, base);
	pc = 0x823F61EC; continue 'dispatch;
            }
            0x823F61EC => {
    //   block [0x823F61EC..0x823F6200)
	// 823F61EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F61F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F61F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F61F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F61FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6200 size=132
    let mut pc: u32 = 0x823F6200;
    'dispatch: loop {
        match pc {
            0x823F6200 => {
    //   block [0x823F6200..0x823F6240)
	// 823F6200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F6208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F620C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F6210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F6218: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F621C: 419A0050  beq cr6, 0x823f626c
	if ctx.cr[6].eq {
	pc = 0x823F626C; continue 'dispatch;
	}
	// 823F6220: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6224: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F6228: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F622C: 41820014  beq 0x823f6240
	if ctx.cr[0].eq {
	pc = 0x823F6240; continue 'dispatch;
	}
	// 823F6230: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823F6234: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823F6238: 4BFD4021  bl 0x823ca258
	ctx.lr = 0x823F623C;
	sub_823CA258(ctx, base);
	// 823F623C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823F6240; continue 'dispatch;
            }
            0x823F6240 => {
    //   block [0x823F6240..0x823F625C)
	// 823F6240: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6244: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6248: 41820014  beq 0x823f625c
	if ctx.cr[0].eq {
	pc = 0x823F625C; continue 'dispatch;
	}
	// 823F624C: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F6250: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823F6254: 4BFD4005  bl 0x823ca258
	ctx.lr = 0x823F6258;
	sub_823CA258(ctx, base);
	// 823F6258: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x823F625C; continue 'dispatch;
            }
            0x823F625C => {
    //   block [0x823F625C..0x823F626C)
	// 823F625C: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F6260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6264: 60848006  ori r4, r4, 0x8006
	ctx.r[4].u64 = ctx.r[4].u64 | 32774;
	// 823F6268: 4BFD3FF1  bl 0x823ca258
	ctx.lr = 0x823F626C;
	sub_823CA258(ctx, base);
	pc = 0x823F626C; continue 'dispatch;
            }
            0x823F626C => {
    //   block [0x823F626C..0x823F6284)
	// 823F626C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F6270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F6274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F6278: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F627C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F6280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6288 size=192
    let mut pc: u32 = 0x823F6288;
    'dispatch: loop {
        match pc {
            0x823F6288 => {
    //   block [0x823F6288..0x823F62B8)
	// 823F6288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F628C: 4813EE29  bl 0x825350b4
	ctx.lr = 0x823F6290;
	sub_82535080(ctx, base);
	// 823F6290: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6294: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F6298: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F629C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F62A0: 60848005  ori r4, r4, 0x8005
	ctx.r[4].u64 = ctx.r[4].u64 | 32773;
	// 823F62A4: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 823F62A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F62AC: 4BFD3F15  bl 0x823ca1c0
	ctx.lr = 0x823F62B0;
	sub_823CA1C0(ctx, base);
	// 823F62B0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F62B4: 40820028  bne 0x823f62dc
	if !ctx.cr[0].eq {
	pc = 0x823F62DC; continue 'dispatch;
	}
	pc = 0x823F62B8; continue 'dispatch;
            }
            0x823F62B8 => {
    //   block [0x823F62B8..0x823F62CC)
	// 823F62B8: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F62BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F62C0: 639C000E  ori r28, r28, 0xe
	ctx.r[28].u64 = ctx.r[28].u64 | 14;
	// 823F62C4: 4BFFFEDD  bl 0x823f61a0
	ctx.lr = 0x823F62C8;
	sub_823F61A0(ctx, base);
	// 823F62C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823F62CC; continue 'dispatch;
            }
            0x823F62CC => {
    //   block [0x823F62CC..0x823F62DC)
	// 823F62CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F62D0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F62D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F62D8: 4813EE2C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x823F62DC => {
    //   block [0x823F62DC..0x823F6308)
	// 823F62DC: 57DD1838  slwi r29, r30, 3
	ctx.r[29].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 823F62E0: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F62E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F62E8: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823F62EC: 4BFD3ED5  bl 0x823ca1c0
	ctx.lr = 0x823F62F0;
	sub_823CA1C0(ctx, base);
	// 823F62F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F62F4: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 823F62F8: 4182FFC0  beq 0x823f62b8
	if ctx.cr[0].eq {
	pc = 0x823F62B8; continue 'dispatch;
	}
	// 823F62FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F6300: 419AFFCC  beq cr6, 0x823f62cc
	if ctx.cr[6].eq {
	pc = 0x823F62CC; continue 'dispatch;
	}
	// 823F6304: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x823F6308; continue 'dispatch;
            }
            0x823F6308 => {
    //   block [0x823F6308..0x823F6334)
	// 823F6308: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F630C: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 823F6310: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F6314: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F6318: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 823F631C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823F6320: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6324: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6328: 4182000C  beq 0x823f6334
	if ctx.cr[0].eq {
	pc = 0x823F6334; continue 'dispatch;
	}
	// 823F632C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F6330: 48000008  b 0x823f6338
	pc = 0x823F6338; continue 'dispatch;
            }
            0x823F6334 => {
    //   block [0x823F6334..0x823F6338)
	// 823F6334: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6338; continue 'dispatch;
            }
            0x823F6338 => {
    //   block [0x823F6338..0x823F6348)
	// 823F6338: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F633C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F6340: 409AFFC8  bne cr6, 0x823f6308
	if !ctx.cr[6].eq {
	pc = 0x823F6308; continue 'dispatch;
	}
	// 823F6344: 4BFFFF88  b 0x823f62cc
	pc = 0x823F62CC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6348 size=236
    let mut pc: u32 = 0x823F6348;
    'dispatch: loop {
        match pc {
            0x823F6348 => {
    //   block [0x823F6348..0x823F63DC)
	// 823F6348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F634C: 4813ED5D  bl 0x825350a8
	ctx.lr = 0x823F6350;
	sub_82535080(ctx, base);
	// 823F6350: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6354: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823F6358: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F635C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F6360: 60848006  ori r4, r4, 0x8006
	ctx.r[4].u64 = ctx.r[4].u64 | 32774;
	// 823F6364: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 823F6368: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823F636C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823F6370: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 823F6374: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 823F6378: 4BFD3E49  bl 0x823ca1c0
	ctx.lr = 0x823F637C;
	sub_823CA1C0(ctx, base);
	// 823F637C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F6380: 41820090  beq 0x823f6410
	if ctx.cr[0].eq {
	pc = 0x823F6410; continue 'dispatch;
	}
	// 823F6384: 7F5DF1D6  mullw r26, r29, r30
	ctx.r[26].s32 = ((ctx.r[29].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 823F6388: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 823F638C: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823F6390: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F6394: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823F6398: 4BFD3E29  bl 0x823ca1c0
	ctx.lr = 0x823F639C;
	sub_823CA1C0(ctx, base);
	// 823F639C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823F63A0: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F63A4: 7C7CF1D6  mullw r3, r28, r30
	ctx.r[3].s32 = ((ctx.r[28].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 823F63A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F63AC: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823F63B0: 4BFD3E11  bl 0x823ca1c0
	ctx.lr = 0x823F63B4;
	sub_823CA1C0(ctx, base);
	// 823F63B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F63B8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823F63BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F63C0: 419A0050  beq cr6, 0x823f6410
	if ctx.cr[6].eq {
	pc = 0x823F6410; continue 'dispatch;
	}
	// 823F63C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823F63C8: 419A0048  beq cr6, 0x823f6410
	if ctx.cr[6].eq {
	pc = 0x823F6410; continue 'dispatch;
	}
	// 823F63CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823F63D0: 419A0054  beq cr6, 0x823f6424
	if ctx.cr[6].eq {
	pc = 0x823F6424; continue 'dispatch;
	}
	// 823F63D4: 7D1BE850  subf r8, r27, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 823F63D8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x823F63DC; continue 'dispatch;
            }
            0x823F63DC => {
    //   block [0x823F63DC..0x823F6410)
	// 823F63DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F63E0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F63E4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F63E8: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 823F63EC: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F63F0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823F63F4: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 823F63F8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F63FC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823F6400: 7D29DA14  add r9, r9, r27
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[27].u64;
	// 823F6404: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 823F6408: 4082FFD4  bne 0x823f63dc
	if !ctx.cr[0].eq {
	pc = 0x823F63DC; continue 'dispatch;
	}
	// 823F640C: 48000018  b 0x823f6424
	pc = 0x823F6424; continue 'dispatch;
            }
            0x823F6410 => {
    //   block [0x823F6410..0x823F6424)
	// 823F6410: 3F208007  lis r25, -0x7ff9
	ctx.r[25].s64 = -2147024896;
	// 823F6414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6418: 6339000E  ori r25, r25, 0xe
	ctx.r[25].u64 = ctx.r[25].u64 | 14;
	// 823F641C: 4BFFFDE5  bl 0x823f6200
	ctx.lr = 0x823F6420;
	sub_823F6200(ctx, base);
	// 823F6420: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823F6424; continue 'dispatch;
            }
            0x823F6424 => {
    //   block [0x823F6424..0x823F6434)
	// 823F6424: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823F6428: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F642C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F6430: 4813ECC8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6438 size=84
    let mut pc: u32 = 0x823F6438;
    'dispatch: loop {
        match pc {
            0x823F6438 => {
    //   block [0x823F6438..0x823F648C)
	// 823F6438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F643C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F6440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F6444: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F644C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F6450: 4BFD3E29  bl 0x823ca278
	ctx.lr = 0x823F6454;
	sub_823CA278(ctx, base);
	// 823F6454: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F6458: E93F0148  ld r9, 0x148(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	// 823F645C: 1D4B03E8  mulli r10, r11, 0x3e8
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 1000 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F6460: 794B0800  rotldi r11, r10, 1
	ctx.r[11].u64 = (ctx.r[10].u64).rotate_left(1);
	// 823F6464: 7C6A4BD2  divd r3, r10, r9
	ctx.r[3].s64 = ctx.r[10].s64 / ctx.r[9].s64;
	// 823F6468: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F646C: 08C90000  tdi 6, r9, 0
	// tdi: trap doubleword immediate  TODO: implement trap semantics
	// 823F6470: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F6474: 08ABFFFF  tdi 5, r11, -1
	// tdi: trap doubleword immediate  TODO: implement trap semantics
	// 823F6478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F647C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F6480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F6484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F6488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6490 size=108
    let mut pc: u32 = 0x823F6490;
    'dispatch: loop {
        match pc {
            0x823F6490 => {
    //   block [0x823F6490..0x823F64E0)
	// 823F6490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F6498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F649C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F64A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F64A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F64A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F64AC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F64B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F64B4: 419A002C  beq cr6, 0x823f64e0
	if ctx.cr[6].eq {
	pc = 0x823F64E0; continue 'dispatch;
	}
	// 823F64B8: 4BFFFF81  bl 0x823f6438
	ctx.lr = 0x823F64BC;
	sub_823F6438(ctx, base);
	// 823F64BC: E95F0018  ld r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 823F64C0: E93F0010  ld r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 823F64C4: 7D4A1850  subf r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 823F64C8: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 823F64CC: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823F64D0: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 823F64D4: 4198000C  blt cr6, 0x823f64e0
	if ctx.cr[6].lt {
	pc = 0x823F64E0; continue 'dispatch;
	}
	// 823F64D8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823F64DC: F97F0038  std r11, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	pc = 0x823F64E0; continue 'dispatch;
            }
            0x823F64E0 => {
    //   block [0x823F64E0..0x823F64FC)
	// 823F64E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F64E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F64E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F64EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F64F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F64F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F64F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823F6500 size=168
    let mut pc: u32 = 0x823F6500;
    'dispatch: loop {
        match pc {
            0x823F6500 => {
    //   block [0x823F6500..0x823F6594)
	// 823F6500: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823F6504: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 823F6508: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F650C: E9690010  ld r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 823F6510: A1090020  lhz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F6514: 7D4B5392  divdu r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 / ctx.r[10].u64;
	// 823F6518: A1690042  lhz r11, 0x42(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(66 as u32) ) } as u64;
	// 823F651C: F8C50000  std r6, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 823F6520: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823F6524: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823F6528: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823F652C: 7D486670  srawi r8, r10, 0xc
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 12) as i64;
	// 823F6530: 7D080194  addze r8, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[8].s64 = tmp.s64;
	// 823F6534: 55086026  slwi r8, r8, 0xc
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(12);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F6538: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 823F653C: 5547043E  clrlwi r7, r10, 0x10
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823F6540: 39471000  addi r10, r7, 0x1000
	ctx.r[10].s64 = ctx.r[7].s64 + 4096;
	// 823F6544: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823F6548: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823F654C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F6550: 7D0B6670  srawi r11, r8, 0xc
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 12) as i64;
	// 823F6554: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 823F6558: 7D436670  srawi r3, r10, 0xc
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[10].s32 >> 12) as i64;
	// 823F655C: 556B6026  slwi r11, r11, 0xc
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(12);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F6560: 7C630194  addze r3, r3
	tmp.s64 = ctx.r[3].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[3].u32);
	ctx.r[3].s64 = tmp.s64;
	// 823F6564: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 823F6568: 54686026  slwi r8, r3, 0xc
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(12);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F656C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 823F6570: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 823F6574: 5488043E  clrlwi r8, r4, 0x10
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 823F6578: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823F657C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F6580: 40980028  bge cr6, 0x823f65a8
	if !ctx.cr[6].lt {
		sub_823F65A8(ctx, base);
		return;
	}
	// 823F6584: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F6588: 4198000C  blt cr6, 0x823f6594
	if ctx.cr[6].lt {
	pc = 0x823F6594; continue 'dispatch;
	}
	// 823F658C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F6590: 40990054  ble cr6, 0x823f65e4
	if !ctx.cr[6].gt {
		sub_823F65DC(ctx, base);
		return;
	}
	pc = 0x823F6594; continue 'dispatch;
            }
            0x823F6594 => {
    //   block [0x823F6594..0x823F65A8)
	// 823F6594: 81690164  lwz r11, 0x164(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(356 as u32) ) } as u64;
	// 823F6598: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 823F659C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F65A0: 91690164  stw r11, 0x164(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 823F65A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F65A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F65A8 size=52
    let mut pc: u32 = 0x823F65A8;
    'dispatch: loop {
        match pc {
            0x823F65A8 => {
    //   block [0x823F65A8..0x823F65B8)
	// 823F65A8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F65AC: 4098000C  bge cr6, 0x823f65b8
	if !ctx.cr[6].lt {
	pc = 0x823F65B8; continue 'dispatch;
	}
	// 823F65B0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F65B4: 4199FFE0  bgt cr6, 0x823f6594
	if ctx.cr[6].gt {
		sub_823F6500(ctx, base);
		return;
	}
	pc = 0x823F65B8; continue 'dispatch;
            }
            0x823F65B8 => {
    //   block [0x823F65B8..0x823F65D0)
	// 823F65B8: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F65BC: 40980020  bge cr6, 0x823f65dc
	if !ctx.cr[6].lt {
		sub_823F65DC(ctx, base);
		return;
	}
	// 823F65C0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F65C4: 4199000C  bgt cr6, 0x823f65d0
	if ctx.cr[6].gt {
	pc = 0x823F65D0; continue 'dispatch;
	}
	// 823F65C8: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F65CC: 40990020  ble cr6, 0x823f65ec
	if !ctx.cr[6].gt {
		sub_823F65DC(ctx, base);
		return;
	}
	pc = 0x823F65D0; continue 'dispatch;
            }
            0x823F65D0 => {
    //   block [0x823F65D0..0x823F65DC)
	// 823F65D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823F65D4: 90C90164  stw r6, 0x164(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(356 as u32), ctx.r[6].u32 ) };
	// 823F65D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F65DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823F65DC size=72
    let mut pc: u32 = 0x823F65DC;
    'dispatch: loop {
        match pc {
            0x823F65DC => {
    //   block [0x823F65DC..0x823F65EC)
	// 823F65DC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F65E0: 4199000C  bgt cr6, 0x823f65ec
	if ctx.cr[6].gt {
	pc = 0x823F65EC; continue 'dispatch;
	}
	// 823F65E4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823F65E8: 4198FFE8  blt cr6, 0x823f65d0
	if ctx.cr[6].lt {
		sub_823F65A8(ctx, base);
		return;
	}
	pc = 0x823F65EC; continue 'dispatch;
            }
            0x823F65EC => {
    //   block [0x823F65EC..0x823F6624)
	// 823F65EC: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 823F65F0: E9490010  ld r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 823F65F4: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 823F65F8: 396B1000  addi r11, r11, 0x1000
	ctx.r[11].s64 = ctx.r[11].s64 + 4096;
	// 823F65FC: 7D686670  srawi r8, r11, 0xc
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 12) as i64;
	// 823F6600: 7D080194  addze r8, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[8].s64 = tmp.s64;
	// 823F6604: 55086026  slwi r8, r8, 0xc
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(12);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F6608: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 823F660C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 823F6610: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F6614: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F6618: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F661C: F9650000  std r11, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 823F6620: 4BFFFFB4  b 0x823f65d4
	sub_823F65A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F6628 size=136
    let mut pc: u32 = 0x823F6628;
    'dispatch: loop {
        match pc {
            0x823F6628 => {
    //   block [0x823F6628..0x823F664C)
	// 823F6628: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823F662C: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6630: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F6634: 390A0174  addi r8, r10, 0x174
	ctx.r[8].s64 = ctx.r[10].s64 + 372;
	// 823F6638: 816A0174  lwz r11, 0x174(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(372 as u32) ) } as u64;
	// 823F663C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823F6640: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6644: 41820048  beq 0x823f668c
	if ctx.cr[0].eq {
	pc = 0x823F668C; continue 'dispatch;
	}
	// 823F6648: E8E90018  ld r7, 0x18(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	pc = 0x823F664C; continue 'dispatch;
            }
            0x823F664C => {
    //   block [0x823F664C..0x823F666C)
	// 823F664C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6650: E8C90018  ld r6, 0x18(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	// 823F6654: 7F273040  cmpld cr6, r7, r6
	ctx.cr[6].compare_u64(ctx.r[7].u64, ctx.r[6].u64, &mut ctx.xer);
	// 823F6658: 41980014  blt cr6, 0x823f666c
	if ctx.cr[6].lt {
	pc = 0x823F666C; continue 'dispatch;
	}
	// 823F665C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823F6660: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6664: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6668: 4082FFE4  bne 0x823f664c
	if !ctx.cr[0].eq {
	pc = 0x823F664C; continue 'dispatch;
	}
	pc = 0x823F666C; continue 'dispatch;
            }
            0x823F666C => {
    //   block [0x823F666C..0x823F668C)
	// 823F666C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F6670: 409A0040  bne cr6, 0x823f66b0
	if !ctx.cr[6].eq {
		sub_823F66B0(ctx, base);
		return;
	}
	// 823F6674: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F6678: 419A0014  beq cr6, 0x823f668c
	if ctx.cr[6].eq {
	pc = 0x823F668C; continue 'dispatch;
	}
	// 823F667C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6680: E96B0018  ld r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823F6684: 7F2B3840  cmpld cr6, r11, r7
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[7].u64, &mut ctx.xer);
	// 823F6688: 419A0068  beq cr6, 0x823f66f0
	if ctx.cr[6].eq {
		sub_823F66F0(ctx, base);
		return;
	}
	pc = 0x823F668C; continue 'dispatch;
            }
            0x823F668C => {
    //   block [0x823F668C..0x823F66A4)
	// 823F668C: 90640004  stw r3, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823F6690: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6694: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6698: 4182000C  beq 0x823f66a4
	if ctx.cr[0].eq {
	pc = 0x823F66A4; continue 'dispatch;
	}
	// 823F669C: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F66A0: 48000008  b 0x823f66a8
	pc = 0x823F66A8; continue 'dispatch;
            }
            0x823F66A4 => {
    //   block [0x823F66A4..0x823F66A8)
	// 823F66A4: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	pc = 0x823F66A8; continue 'dispatch;
            }
            0x823F66A8 => {
    //   block [0x823F66A8..0x823F66B0)
	// 823F66A8: 90880004  stw r4, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F66AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F66B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F66B0 size=48
    let mut pc: u32 = 0x823F66B0;
    'dispatch: loop {
        match pc {
            0x823F66B0 => {
    //   block [0x823F66B0..0x823F66E0)
	// 823F66B0: E9690018  ld r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	// 823F66B4: 7F2B3840  cmpld cr6, r11, r7
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[7].u64, &mut ctx.xer);
	// 823F66B8: 419A0038  beq cr6, 0x823f66f0
	if ctx.cr[6].eq {
		sub_823F66F0(ctx, base);
		return;
	}
	// 823F66BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F66C0: 409A0020  bne cr6, 0x823f66e0
	if !ctx.cr[6].eq {
		sub_823F66E0(ctx, base);
		return;
	}
	// 823F66C4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F66C8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F66CC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F66D0: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823F66D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F66D8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 823F66DC: 4BFFFFCC  b 0x823f66a8
	sub_823F6628(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F66E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F66E0 size=16
    let mut pc: u32 = 0x823F66E0;
    'dispatch: loop {
        match pc {
            0x823F66E0 => {
    //   block [0x823F66E0..0x823F66F0)
	// 823F66E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F66E4: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F66E8: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 823F66EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F66F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F66F0 size=12
    let mut pc: u32 = 0x823F66F0;
    'dispatch: loop {
        match pc {
            0x823F66F0 => {
    //   block [0x823F66F0..0x823F66FC)
	// 823F66F0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823F66F4: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823F66F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823F6700 size=208
    let mut pc: u32 = 0x823F6700;
    'dispatch: loop {
        match pc {
            0x823F6700 => {
    //   block [0x823F6700..0x823F6764)
	// 823F6700: A1630040  lhz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F6704: 5486043E  clrlwi r6, r4, 0x10
	ctx.r[6].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 823F6708: E8E30018  ld r7, 0x18(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 823F670C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F6710: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 823F6714: E9030010  ld r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 823F6718: 39430174  addi r10, r3, 0x174
	ctx.r[10].s64 = ctx.r[3].s64 + 372;
	// 823F671C: 396B1000  addi r11, r11, 0x1000
	ctx.r[11].s64 = ctx.r[11].s64 + 4096;
	// 823F6720: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823F6724: 7D676670  srawi r7, r11, 0xc
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 12) as i64;
	// 823F6728: F9230010  std r9, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u64 ) };
	// 823F672C: 91230138  stw r9, 0x138(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), ctx.r[9].u32 ) };
	// 823F6730: 7CE70194  addze r7, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[7].s64 = tmp.s64;
	// 823F6734: 91230130  stw r9, 0x130(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(304 as u32), ctx.r[9].u32 ) };
	// 823F6738: F9030018  std r8, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u64 ) };
	// 823F673C: 54E86026  slwi r8, r7, 0xc
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(12);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F6740: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 823F6744: B1630020  sth r11, 0x20(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 823F6748: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F674C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6750: 41820020  beq 0x823f6770
	if ctx.cr[0].eq {
	pc = 0x823F6770; continue 'dispatch;
	}
	// 823F6754: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6758: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F675C: 409A0008  bne cr6, 0x823f6764
	if !ctx.cr[6].eq {
	pc = 0x823F6764; continue 'dispatch;
	}
	// 823F6760: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823F6764; continue 'dispatch;
            }
            0x823F6764 => {
    //   block [0x823F6764..0x823F6770)
	// 823F6764: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6768: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823F676C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823F6770; continue 'dispatch;
            }
            0x823F6770 => {
    //   block [0x823F6770..0x823F677C)
	// 823F6770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F6774: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 823F6778: 38E3016C  addi r7, r3, 0x16c
	ctx.r[7].s64 = ctx.r[3].s64 + 364;
	pc = 0x823F677C; continue 'dispatch;
            }
            0x823F677C => {
    //   block [0x823F677C..0x823F6794)
	// 823F677C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823F6780: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6784: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6788: 4182000C  beq 0x823f6794
	if ctx.cr[0].eq {
	pc = 0x823F6794; continue 'dispatch;
	}
	// 823F678C: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F6790: 48000008  b 0x823f6798
	pc = 0x823F6798; continue 'dispatch;
            }
            0x823F6794 => {
    //   block [0x823F6794..0x823F6798)
	// 823F6794: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6798; continue 'dispatch;
            }
            0x823F6798 => {
    //   block [0x823F6798..0x823F67B8)
	// 823F6798: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F679C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F67A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F67A4: 41820020  beq 0x823f67c4
	if ctx.cr[0].eq {
	pc = 0x823F67C4; continue 'dispatch;
	}
	// 823F67A8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F67AC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F67B0: 409A0008  bne cr6, 0x823f67b8
	if !ctx.cr[6].eq {
	pc = 0x823F67B8; continue 'dispatch;
	}
	// 823F67B4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823F67B8; continue 'dispatch;
            }
            0x823F67B8 => {
    //   block [0x823F67B8..0x823F67C4)
	// 823F67B8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F67BC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823F67C0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x823F67C4; continue 'dispatch;
            }
            0x823F67C4 => {
    //   block [0x823F67C4..0x823F67D0)
	// 823F67C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F67C8: 409AFFB4  bne cr6, 0x823f677c
	if !ctx.cr[6].eq {
	pc = 0x823F677C; continue 'dispatch;
	}
	// 823F67CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F67D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F67D0 size=564
    let mut pc: u32 = 0x823F67D0;
    'dispatch: loop {
        match pc {
            0x823F67D0 => {
    //   block [0x823F67D0..0x823F6828)
	// 823F67D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F67D4: 4813E8DD  bl 0x825350b0
	ctx.lr = 0x823F67D8;
	sub_82535080(ctx, base);
	// 823F67D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F67DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F67E0: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 823F67E4: 811F0130  lwz r8, 0x130(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 823F67E8: A13F0044  lhz r9, 0x44(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823F67EC: A15F0040  lhz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 823F67F0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823F67F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823F67F8: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 823F67FC: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823F6800: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F6804: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823F6808: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 823F680C: FC006E9C  fcfid f0, f13
	ctx.f[0].f64 = (ctx.f[13].s64 as f64);
	// 823F6810: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 823F6814: FD6C0024  fdiv f11, f12, f0
	ctx.f[11].f64 = ctx.f[12].f64 / ctx.f[0].f64;
	// 823F6818: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 823F681C: 4098000C  bge cr6, 0x823f6828
	if !ctx.cr[6].lt {
	pc = 0x823F6828; continue 'dispatch;
	}
	// 823F6820: FD8C0024  fdiv f12, f12, f0
	ctx.f[12].f64 = ctx.f[12].f64 / ctx.f[0].f64;
	// 823F6824: 48000008  b 0x823f682c
	pc = 0x823F682C; continue 'dispatch;
            }
            0x823F6828 => {
    //   block [0x823F6828..0x823F682C)
	// 823F6828: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	pc = 0x823F682C; continue 'dispatch;
            }
            0x823F682C => {
    //   block [0x823F682C..0x823F6840)
	// 823F682C: C97F0120  lfd f11, 0x120(r31)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	// 823F6830: FC0B0032  fmul f0, f11, f0
	ctx.f[0].f64 = ctx.f[11].f64 * ctx.f[0].f64;
	// 823F6834: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823F6838: 41980008  blt cr6, 0x823f6840
	if ctx.cr[6].lt {
	pc = 0x823F6840; continue 'dispatch;
	}
	// 823F683C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823F6840; continue 'dispatch;
            }
            0x823F6840 => {
    //   block [0x823F6840..0x823F6914)
	// 823F6840: FDAD0028  fsub f13, f13, f0
	ctx.f[13].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 823F6844: 396A000A  addi r11, r10, 0xa
	ctx.r[11].s64 = ctx.r[10].s64 + 10;
	// 823F6848: FD800332  fmul f12, f0, f12
	ctx.f[12].f64 = ctx.f[0].f64 * ctx.f[12].f64;
	// 823F684C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823F6850: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F6854: D81F0128  stfd f0, 0x128(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.f[0].u64 ) };
	// 823F6858: 7C0BFCAE  lfdx f0, r11, r31
	ctx.f[0].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	// 823F685C: FC0D603A  fmadd f0, f13, f0, f12
	ctx.f[0].f64 = ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64;
	// 823F6860: 7C0BFDAE  stfdx f0, r11, r31
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.f[0].u64) };
	// 823F6864: 935F0130  stw r26, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[26].u32 ) };
	// 823F6868: C81F0118  lfd f0, 0x118(r31)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	// 823F686C: 935F0138  stw r26, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[26].u32 ) };
	// 823F6870: 7DABFCAE  lfdx f13, r11, r31
	ctx.f[13].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	// 823F6874: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823F6878: 40980128  bge cr6, 0x823f69a0
	if !ctx.cr[6].lt {
	pc = 0x823F69A0; continue 'dispatch;
	}
	// 823F687C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F6880: 419A017C  beq cr6, 0x823f69fc
	if ctx.cr[6].eq {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F6884: 396A0009  addi r11, r10, 9
	ctx.r[11].s64 = ctx.r[10].s64 + 9;
	// 823F6888: FDAD0028  fsub f13, f13, f0
	ctx.f[13].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 823F688C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F6890: 7D8BFCAE  lfdx f12, r11, r31
	ctx.f[12].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	// 823F6894: FC0C0028  fsub f0, f12, f0
	ctx.f[0].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 823F6898: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 823F689C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 823F68A0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823F68A4: 40980158  bge cr6, 0x823f69fc
	if !ctx.cr[6].lt {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F68A8: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 823F68AC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 823F68B0: 839F0174  lwz r28, 0x174(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 823F68B4: 3BDF0174  addi r30, r31, 0x174
	ctx.r[30].s64 = ctx.r[31].s64 + 372;
	// 823F68B8: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 823F68BC: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F68C0: 7D4B5392  divdu r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 / ctx.r[10].u64;
	// 823F68C4: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 823F68C8: B15F0040  sth r10, 0x40(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u16 ) };
	// 823F68CC: 41820130  beq 0x823f69fc
	if ctx.cr[0].eq {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F68D0: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 823F68D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F68D8: 837C0000  lwz r27, 0(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F68DC: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 823F68E0: EBBB0018  ld r29, 0x18(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	// 823F68E4: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 823F68E8: 4BFFF779  bl 0x823f6060
	ctx.lr = 0x823F68EC;
	sub_823F6060(ctx, base);
	// 823F68EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F68F0: 4182010C  beq 0x823f69fc
	if ctx.cr[0].eq {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F68F4: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 823F68F8: 7F2BE840  cmpld cr6, r11, r29
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[29].u64, &mut ctx.xer);
	// 823F68FC: 40990100  ble cr6, 0x823f69fc
	if !ctx.cr[6].gt {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F6900: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6904: 393D0014  addi r9, r29, 0x14
	ctx.r[9].s64 = ctx.r[29].s64 + 20;
	// 823F6908: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 823F690C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6910: 41820080  beq 0x823f6990
	if ctx.cr[0].eq {
	pc = 0x823F6990; continue 'dispatch;
	}
	pc = 0x823F6914; continue 'dispatch;
            }
            0x823F6914 => {
    //   block [0x823F6914..0x823F692C)
	// 823F6914: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6918: E94A0018  ld r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 823F691C: 7F2A4840  cmpld cr6, r10, r9
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[9].u64, &mut ctx.xer);
	// 823F6920: 41990018  bgt cr6, 0x823f6938
	if ctx.cr[6].gt {
	pc = 0x823F6938; continue 'dispatch;
	}
	// 823F6924: 409A0008  bne cr6, 0x823f692c
	if !ctx.cr[6].eq {
	pc = 0x823F692C; continue 'dispatch;
	}
	// 823F6928: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x823F692C; continue 'dispatch;
            }
            0x823F692C => {
    //   block [0x823F692C..0x823F6938)
	// 823F692C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6930: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6934: 4082FFE0  bne 0x823f6914
	if !ctx.cr[0].eq {
	pc = 0x823F6914; continue 'dispatch;
	}
	pc = 0x823F6938; continue 'dispatch;
            }
            0x823F6938 => {
    //   block [0x823F6938..0x823F695C)
	// 823F6938: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F693C: 419A0054  beq cr6, 0x823f6990
	if ctx.cr[6].eq {
	pc = 0x823F6990; continue 'dispatch;
	}
	// 823F6940: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6944: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6948: 41820020  beq 0x823f6968
	if ctx.cr[0].eq {
	pc = 0x823F6968; continue 'dispatch;
	}
	// 823F694C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6950: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F6954: 409A0008  bne cr6, 0x823f695c
	if !ctx.cr[6].eq {
	pc = 0x823F695C; continue 'dispatch;
	}
	// 823F6958: 935E0004  stw r26, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x823F695C; continue 'dispatch;
            }
            0x823F695C => {
    //   block [0x823F695C..0x823F6968)
	// 823F695C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6960: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F6964: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x823F6968; continue 'dispatch;
            }
            0x823F6968 => {
    //   block [0x823F6968..0x823F6984)
	// 823F6968: 397F016C  addi r11, r31, 0x16c
	ctx.r[11].s64 = ctx.r[31].s64 + 364;
	// 823F696C: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 823F6970: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6974: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6978: 4182000C  beq 0x823f6984
	if ctx.cr[0].eq {
	pc = 0x823F6984; continue 'dispatch;
	}
	// 823F697C: 938A0004  stw r28, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F6980: 48000008  b 0x823f6988
	pc = 0x823F6988; continue 'dispatch;
            }
            0x823F6984 => {
    //   block [0x823F6984..0x823F6988)
	// 823F6984: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x823F6988; continue 'dispatch;
            }
            0x823F6988 => {
    //   block [0x823F6988..0x823F6990)
	// 823F6988: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F698C: 48000070  b 0x823f69fc
	pc = 0x823F69FC; continue 'dispatch;
            }
            0x823F6990 => {
    //   block [0x823F6990..0x823F69A0)
	// 823F6990: E97B0018  ld r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	// 823F6994: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 823F6998: F97B0018  std r11, 0x18(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823F699C: 48000060  b 0x823f69fc
	pc = 0x823F69FC; continue 'dispatch;
            }
            0x823F69A0 => {
    //   block [0x823F69A0..0x823F69FC)
	// 823F69A0: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 823F69A4: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 823F69A8: 40980054  bge cr6, 0x823f69fc
	if !ctx.cr[6].lt {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F69AC: 396A000B  addi r11, r10, 0xb
	ctx.r[11].s64 = ctx.r[10].s64 + 11;
	// 823F69B0: FDAD0028  fsub f13, f13, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 823F69B4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F69B8: 7D8BFCAE  lfdx f12, r11, r31
	ctx.f[12].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	// 823F69BC: FC0C0028  fsub f0, f12, f0
	ctx.f[0].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 823F69C0: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 823F69C4: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 823F69C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823F69CC: 40980030  bge cr6, 0x823f69fc
	if !ctx.cr[6].lt {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F69D0: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 823F69D4: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 823F69D8: 419A0024  beq cr6, 0x823f69fc
	if ctx.cr[6].eq {
	pc = 0x823F69FC; continue 'dispatch;
	}
	// 823F69DC: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 823F69E0: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 823F69E4: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 823F69E8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 823F69EC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 823F69F0: 7D4B4B92  divdu r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 / ctx.r[9].u64;
	// 823F69F4: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 823F69F8: B15F0040  sth r10, 0x40(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u16 ) };
	pc = 0x823F69FC; continue 'dispatch;
            }
            0x823F69FC => {
    //   block [0x823F69FC..0x823F6A04)
	// 823F69FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F6A00: 4813E700  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6A08 size=148
    let mut pc: u32 = 0x823F6A08;
    'dispatch: loop {
        match pc {
            0x823F6A08 => {
    //   block [0x823F6A08..0x823F6A6C)
	// 823F6A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6A0C: 4813E6B1  bl 0x825350bc
	ctx.lr = 0x823F6A10;
	sub_82535080(ctx, base);
	// 823F6A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6A14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F6A18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F6A1C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823F6A20: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6A24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823F6A28: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6A2C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6A30: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823F6A34: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 823F6A38: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823F6A3C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823F6A40: 807D0188  lwz r3, 0x188(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(392 as u32) ) } as u64;
	// 823F6A44: 4BFFDC95  bl 0x823f46d8
	ctx.lr = 0x823F6A48;
	sub_823F46D8(ctx, base);
	// 823F6A48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F6A4C: 40800020  bge 0x823f6a6c
	if !ctx.cr[0].lt {
	pc = 0x823F6A6C; continue 'dispatch;
	}
	// 823F6A50: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6A54: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6A58: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 823F6A5C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823F6A60: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823F6A64: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823F6A68: 4800002C  b 0x823f6a94
	pc = 0x823F6A94; continue 'dispatch;
            }
            0x823F6A6C => {
    //   block [0x823F6A6C..0x823F6A8C)
	// 823F6A6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F6A70: 397D017C  addi r11, r29, 0x17c
	ctx.r[11].s64 = ctx.r[29].s64 + 380;
	// 823F6A74: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F6A78: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6A7C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6A80: 4182000C  beq 0x823f6a8c
	if ctx.cr[0].eq {
	pc = 0x823F6A8C; continue 'dispatch;
	}
	// 823F6A84: 93CA0004  stw r30, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823F6A88: 48000008  b 0x823f6a90
	pc = 0x823F6A90; continue 'dispatch;
            }
            0x823F6A8C => {
    //   block [0x823F6A8C..0x823F6A90)
	// 823F6A8C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823F6A90; continue 'dispatch;
            }
            0x823F6A90 => {
    //   block [0x823F6A90..0x823F6A94)
	// 823F6A90: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x823F6A94; continue 'dispatch;
            }
            0x823F6A94 => {
    //   block [0x823F6A94..0x823F6A9C)
	// 823F6A94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F6A98: 4813E674  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6AA0 size=116
    let mut pc: u32 = 0x823F6AA0;
    'dispatch: loop {
        match pc {
            0x823F6AA0 => {
    //   block [0x823F6AA0..0x823F6AE0)
	// 823F6AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F6AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F6AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F6AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F6AB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F6ABC: 419A0040  beq cr6, 0x823f6afc
	if ctx.cr[6].eq {
	pc = 0x823F6AFC; continue 'dispatch;
	}
	// 823F6AC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6AC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F6AC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6ACC: 41820014  beq 0x823f6ae0
	if ctx.cr[0].eq {
	pc = 0x823F6AE0; continue 'dispatch;
	}
	// 823F6AD0: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F6AD4: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823F6AD8: 4BFD3781  bl 0x823ca258
	ctx.lr = 0x823F6ADC;
	sub_823CA258(ctx, base);
	// 823F6ADC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x823F6AE0; continue 'dispatch;
            }
            0x823F6AE0 => {
    //   block [0x823F6AE0..0x823F6AFC)
	// 823F6AE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6AE4: 4BFFF71D  bl 0x823f6200
	ctx.lr = 0x823F6AE8;
	sub_823F6200(ctx, base);
	// 823F6AE8: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F6AEC: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823F6AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6AF4: 60848013  ori r4, r4, 0x8013
	ctx.r[4].u64 = ctx.r[4].u64 | 32787;
	// 823F6AF8: 4BFD3761  bl 0x823ca258
	ctx.lr = 0x823F6AFC;
	sub_823CA258(ctx, base);
	pc = 0x823F6AFC; continue 'dispatch;
            }
            0x823F6AFC => {
    //   block [0x823F6AFC..0x823F6B14)
	// 823F6AFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F6B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F6B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F6B08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F6B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F6B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6B18 size=632
    let mut pc: u32 = 0x823F6B18;
    'dispatch: loop {
        match pc {
            0x823F6B18 => {
    //   block [0x823F6B18..0x823F6B9C)
	// 823F6B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6B1C: 4813E599  bl 0x825350b4
	ctx.lr = 0x823F6B20;
	sub_82535080(ctx, base);
	// 823F6B20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6B24: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 823F6B28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F6B2C: 639C4005  ori r28, r28, 0x4005
	ctx.r[28].u64 = ctx.r[28].u64 | 16389;
	// 823F6B30: 4BFFF961  bl 0x823f6490
	ctx.lr = 0x823F6B34;
	sub_823F6490(ctx, base);
	// 823F6B34: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823F6B38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F6B3C: 41820150  beq 0x823f6c8c
	if ctx.cr[0].eq {
	pc = 0x823F6C8C; continue 'dispatch;
	}
	// 823F6B40: 83BE0174  lwz r29, 0x174(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(372 as u32) ) } as u64;
	// 823F6B44: 3BFE0174  addi r31, r30, 0x174
	ctx.r[31].s64 = ctx.r[30].s64 + 372;
	// 823F6B48: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6B4C: 4182013C  beq 0x823f6c88
	if ctx.cr[0].eq {
	pc = 0x823F6C88; continue 'dispatch;
	}
	// 823F6B50: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6B54: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 823F6B58: E92A0018  ld r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	// 823F6B5C: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 823F6B60: 419A00A4  beq cr6, 0x823f6c04
	if ctx.cr[6].eq {
	pc = 0x823F6C04; continue 'dispatch;
	}
	// 823F6B64: 817E013C  lwz r11, 0x13c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 823F6B68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F6B6C: 917E013C  stw r11, 0x13c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 823F6B70: 817E0160  lwz r11, 0x160(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 823F6B74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F6B78: 419A0108  beq cr6, 0x823f6c80
	if ctx.cr[6].eq {
	pc = 0x823F6C80; continue 'dispatch;
	}
	// 823F6B7C: 3BBE016C  addi r29, r30, 0x16c
	ctx.r[29].s64 = ctx.r[30].s64 + 364;
	// 823F6B80: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6B84: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6B88: 41820138  beq 0x823f6cc0
	if ctx.cr[0].eq {
	pc = 0x823F6CC0; continue 'dispatch;
	}
	// 823F6B8C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6B90: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F6B94: 409A0008  bne cr6, 0x823f6b9c
	if !ctx.cr[6].eq {
	pc = 0x823F6B9C; continue 'dispatch;
	}
	// 823F6B98: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823F6B9C; continue 'dispatch;
            }
            0x823F6B9C => {
    //   block [0x823F6B9C..0x823F6C04)
	// 823F6B9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6BA0: 389E0154  addi r4, r30, 0x154
	ctx.r[4].s64 = ctx.r[30].s64 + 340;
	// 823F6BA4: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 823F6BA8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F6BAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6BB0: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823F6BB4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6BB8: 4813DF99  bl 0x82534b50
	ctx.lr = 0x823F6BBC;
	sub_82534B50(ctx, base);
	// 823F6BBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6BC0: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 823F6BC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F6BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F6BCC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F6BD0: 4BFFFE39  bl 0x823f6a08
	ctx.lr = 0x823F6BD4;
	sub_823F6A08(ctx, base);
	// 823F6BD4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F6BD8: 408000A0  bge 0x823f6c78
	if !ctx.cr[0].lt {
	pc = 0x823F6C78; continue 'dispatch;
	}
	// 823F6BDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6BE0: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823F6BE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6BE8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F6BEC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6BF0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F6BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F6BF8: 409A00A8  bne cr6, 0x823f6ca0
	if !ctx.cr[6].eq {
	pc = 0x823F6CA0; continue 'dispatch;
	}
	// 823F6BFC: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F6C00: 480000A0  b 0x823f6ca0
	pc = 0x823F6CA0; continue 'dispatch;
            }
            0x823F6C04 => {
    //   block [0x823F6C04..0x823F6C20)
	// 823F6C04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6C08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6C0C: 41820020  beq 0x823f6c2c
	if ctx.cr[0].eq {
	pc = 0x823F6C2C; continue 'dispatch;
	}
	// 823F6C10: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6C14: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823F6C18: 409A0008  bne cr6, 0x823f6c20
	if !ctx.cr[6].eq {
	pc = 0x823F6C20; continue 'dispatch;
	}
	// 823F6C1C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823F6C20; continue 'dispatch;
            }
            0x823F6C20 => {
    //   block [0x823F6C20..0x823F6C2C)
	// 823F6C20: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6C24: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823F6C28: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823F6C2C; continue 'dispatch;
            }
            0x823F6C2C => {
    //   block [0x823F6C2C..0x823F6C78)
	// 823F6C2C: 387E0154  addi r3, r30, 0x154
	ctx.r[3].s64 = ctx.r[30].s64 + 340;
	// 823F6C30: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6C34: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6C38: 4813DF19  bl 0x82534b50
	ctx.lr = 0x823F6C3C;
	sub_82534B50(ctx, base);
	// 823F6C3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F6C40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823F6C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F6C48: 917E0160  stw r11, 0x160(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 823F6C4C: 4BFFFDBD  bl 0x823f6a08
	ctx.lr = 0x823F6C50;
	sub_823F6A08(ctx, base);
	// 823F6C50: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F6C54: 40800040  bge 0x823f6c94
	if !ctx.cr[0].lt {
	pc = 0x823F6C94; continue 'dispatch;
	}
	// 823F6C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6C5C: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F6C60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6C64: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F6C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F6C6C: 409A0034  bne cr6, 0x823f6ca0
	if !ctx.cr[6].eq {
	pc = 0x823F6CA0; continue 'dispatch;
	}
	// 823F6C70: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823F6C74: 4800002C  b 0x823f6ca0
	pc = 0x823F6CA0; continue 'dispatch;
            }
            0x823F6C78 => {
    //   block [0x823F6C78..0x823F6C80)
	// 823F6C78: 937E0160  stw r27, 0x160(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(352 as u32), ctx.r[27].u32 ) };
	// 823F6C7C: 48000024  b 0x823f6ca0
	pc = 0x823F6CA0; continue 'dispatch;
            }
            0x823F6C80 => {
    //   block [0x823F6C80..0x823F6C88)
	// 823F6C80: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823F6C84: 4800001C  b 0x823f6ca0
	pc = 0x823F6CA0; continue 'dispatch;
            }
            0x823F6C88 => {
    //   block [0x823F6C88..0x823F6C8C)
	// 823F6C88: 937E0048  stw r27, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[27].u32 ) };
	pc = 0x823F6C8C; continue 'dispatch;
            }
            0x823F6C8C => {
    //   block [0x823F6C8C..0x823F6C94)
	// 823F6C8C: FB7E0038  std r27, 0x38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[27].u64 ) };
	// 823F6C90: 48000010  b 0x823f6ca0
	pc = 0x823F6CA0; continue 'dispatch;
            }
            0x823F6C94 => {
    //   block [0x823F6C94..0x823F6CA0)
	// 823F6C94: E97E0038  ld r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 823F6C98: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 823F6C9C: F97E0038  std r11, 0x38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	pc = 0x823F6CA0; continue 'dispatch;
            }
            0x823F6CA0 => {
    //   block [0x823F6CA0..0x823F6CC0)
	// 823F6CA0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F6CA4: 4198001C  blt cr6, 0x823f6cc0
	if ctx.cr[6].lt {
	pc = 0x823F6CC0; continue 'dispatch;
	}
	// 823F6CA8: E95E0010  ld r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 823F6CAC: 817E0140  lwz r11, 0x140(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 823F6CB0: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 823F6CB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F6CB8: F95E0010  std r10, 0x10(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 823F6CBC: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6CC0; continue 'dispatch;
            }
            0x823F6CC0 => {
    //   block [0x823F6CC0..0x823F6CD4)
	// 823F6CC0: E97E0038  ld r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 823F6CC4: 2F2B0000  cmpdi cr6, r11, 0
	ctx.cr[6].compare_i64(ctx.r[11].s64, 0, &mut ctx.xer);
	// 823F6CC8: 4099000C  ble cr6, 0x823f6cd4
	if !ctx.cr[6].gt {
	pc = 0x823F6CD4; continue 'dispatch;
	}
	// 823F6CCC: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 823F6CD0: F97E0038  std r11, 0x38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	pc = 0x823F6CD4; continue 'dispatch;
            }
            0x823F6CD4 => {
    //   block [0x823F6CD4..0x823F6CE0)
	// 823F6CD4: 83FE017C  lwz r31, 0x17c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(380 as u32) ) } as u64;
	// 823F6CD8: 3BBE017C  addi r29, r30, 0x17c
	ctx.r[29].s64 = ctx.r[30].s64 + 380;
	// 823F6CDC: 480000A0  b 0x823f6d7c
	pc = 0x823F6D7C; continue 'dispatch;
            }
            0x823F6CE0 => {
    //   block [0x823F6CE0..0x823F6D0C)
	// 823F6CE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6CE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6CE8: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F6CEC: 419A0098  beq cr6, 0x823f6d84
	if ctx.cr[6].eq {
	pc = 0x823F6D84; continue 'dispatch;
	}
	// 823F6CF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6CF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6CF8: 41820020  beq 0x823f6d18
	if ctx.cr[0].eq {
	pc = 0x823F6D18; continue 'dispatch;
	}
	// 823F6CFC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6D00: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F6D04: 409A0008  bne cr6, 0x823f6d0c
	if !ctx.cr[6].eq {
	pc = 0x823F6D0C; continue 'dispatch;
	}
	// 823F6D08: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823F6D0C; continue 'dispatch;
            }
            0x823F6D0C => {
    //   block [0x823F6D0C..0x823F6D18)
	// 823F6D0C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6D10: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F6D14: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823F6D18; continue 'dispatch;
            }
            0x823F6D18 => {
    //   block [0x823F6D18..0x823F6D70)
	// 823F6D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6D1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F6D20: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6D24: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 823F6D28: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823F6D2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6D30: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6D34: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823F6D38: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823F6D3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6D40: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823F6D44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6D48: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F6D4C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6D50: 4BFCA811  bl 0x823c1560
	ctx.lr = 0x823F6D54;
	sub_823C1560(ctx, base);
	// 823F6D54: 397E016C  addi r11, r30, 0x16c
	ctx.r[11].s64 = ctx.r[30].s64 + 364;
	// 823F6D58: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823F6D5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6D60: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6D64: 4182000C  beq 0x823f6d70
	if ctx.cr[0].eq {
	pc = 0x823F6D70; continue 'dispatch;
	}
	// 823F6D68: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F6D6C: 48000008  b 0x823f6d74
	pc = 0x823F6D74; continue 'dispatch;
            }
            0x823F6D70 => {
    //   block [0x823F6D70..0x823F6D74)
	// 823F6D70: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823F6D74; continue 'dispatch;
            }
            0x823F6D74 => {
    //   block [0x823F6D74..0x823F6D7C)
	// 823F6D74: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F6D78: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823F6D7C; continue 'dispatch;
            }
            0x823F6D7C => {
    //   block [0x823F6D7C..0x823F6D84)
	// 823F6D7C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6D80: 4082FF60  bne 0x823f6ce0
	if !ctx.cr[0].eq {
	pc = 0x823F6CE0; continue 'dispatch;
	}
	pc = 0x823F6D84; continue 'dispatch;
            }
            0x823F6D84 => {
    //   block [0x823F6D84..0x823F6D90)
	// 823F6D84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F6D88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F6D8C: 4813E378  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F6D90 size=460
    let mut pc: u32 = 0x823F6D90;
    'dispatch: loop {
        match pc {
            0x823F6D90 => {
    //   block [0x823F6D90..0x823F6E04)
	// 823F6D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F6D94: 4813E315  bl 0x825350a8
	ctx.lr = 0x823F6D98;
	sub_82535080(ctx, base);
	// 823F6D98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F6D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F6DA0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823F6DA4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823F6DA8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823F6DAC: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 823F6DB0: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823F6DB4: A17A0000  lhz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6DB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F6DBC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823F6DC0: 556BA33E  srwi r11, r11, 0xc
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(12);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F6DC4: 555BFD7E  rlwinm r27, r10, 0x1f, 0x15, 0x1f
	ctx.r[27].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 823F6DC8: 557E073E  clrlwi r30, r11, 0x1c
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F6DCC: 409A0060  bne cr6, 0x823f6e2c
	if !ctx.cr[6].eq {
	pc = 0x823F6E2C; continue 'dispatch;
	}
	// 823F6DD0: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 823F6DD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F6DD8: 419A0034  beq cr6, 0x823f6e0c
	if ctx.cr[6].eq {
	pc = 0x823F6E0C; continue 'dispatch;
	}
	// 823F6DDC: 4BFC8DFD  bl 0x823bfbd8
	ctx.lr = 0x823F6DE0;
	sub_823BFBD8(ctx, base);
	// 823F6DE0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F6DE4: 396B3770  addi r11, r11, 0x3770
	ctx.r[11].s64 = ctx.r[11].s64 + 14192;
	// 823F6DE8: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823F6DEC: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 823F6DF0: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 823F6DF4: 409A0010  bne cr6, 0x823f6e04
	if !ctx.cr[6].eq {
	pc = 0x823F6E04; continue 'dispatch;
	}
	// 823F6DF8: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 823F6DFC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823F6E00: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	pc = 0x823F6E04; continue 'dispatch;
            }
            0x823F6E04 => {
    //   block [0x823F6E04..0x823F6E0C)
	// 823F6E04: F95F0018  std r10, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823F6E08: 48000010  b 0x823f6e18
	pc = 0x823F6E18; continue 'dispatch;
            }
            0x823F6E0C => {
    //   block [0x823F6E0C..0x823F6E18)
	// 823F6E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6E10: 4BFFF629  bl 0x823f6438
	ctx.lr = 0x823F6E14;
	sub_823F6438(ctx, base);
	// 823F6E14: F87F0018  std r3, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u64 ) };
	pc = 0x823F6E18; continue 'dispatch;
            }
            0x823F6E18 => {
    //   block [0x823F6E18..0x823F6E2C)
	// 823F6E18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F6E1C: FB1F0010  std r24, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[24].u64 ) };
	// 823F6E20: 9BDF0134  stb r30, 0x134(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u8 ) };
	// 823F6E24: B37F0020  sth r27, 0x20(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u16 ) };
	// 823F6E28: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6E2C; continue 'dispatch;
            }
            0x823F6E2C => {
    //   block [0x823F6E2C..0x823F6E48)
	// 823F6E2C: 897F0134  lbz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 823F6E30: 57DD063E  clrlwi r29, r30, 0x18
	ctx.r[29].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 823F6E34: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F6E38: 419A0010  beq cr6, 0x823f6e48
	if ctx.cr[6].eq {
	pc = 0x823F6E48; continue 'dispatch;
	}
	// 823F6E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6E40: 4BFFF991  bl 0x823f67d0
	ctx.lr = 0x823F6E44;
	sub_823F67D0(ctx, base);
	// 823F6E44: 9BDF0134  stb r30, 0x134(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u8 ) };
	pc = 0x823F6E48; continue 'dispatch;
            }
            0x823F6E48 => {
    //   block [0x823F6E48..0x823F6E98)
	// 823F6E48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F6E4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823F6E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6E54: 4BFFF6AD  bl 0x823f6500
	ctx.lr = 0x823F6E58;
	sub_823F6500(ctx, base);
	// 823F6E58: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 823F6E5C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 823F6E60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F6E64: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 823F6E68: 41980030  blt cr6, 0x823f6e98
	if ctx.cr[6].lt {
	pc = 0x823F6E98; continue 'dispatch;
	}
	// 823F6E6C: 419A00AC  beq cr6, 0x823f6f18
	if ctx.cr[6].eq {
	pc = 0x823F6F18; continue 'dispatch;
	}
	// 823F6E70: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 823F6E74: 409800DC  bge cr6, 0x823f6f50
	if !ctx.cr[6].lt {
	pc = 0x823F6F50; continue 'dispatch;
	}
	// 823F6E78: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 823F6E7C: 815F0164  lwz r10, 0x164(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 823F6E80: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F6E84: 409800C8  bge cr6, 0x823f6f4c
	if !ctx.cr[6].lt {
	pc = 0x823F6F4C; continue 'dispatch;
	}
	// 823F6E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6E8C: 4BFFF875  bl 0x823f6700
	ctx.lr = 0x823F6E90;
	sub_823F6700(ctx, base);
	// 823F6E90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F6E94: 4BFFF66D  bl 0x823f6500
	ctx.lr = 0x823F6E98;
	sub_823F6500(ctx, base);
	pc = 0x823F6E98; continue 'dispatch;
            }
            0x823F6E98 => {
    //   block [0x823F6E98..0x823F6EB8)
	// 823F6E98: 3BBF016C  addi r29, r31, 0x16c
	ctx.r[29].s64 = ctx.r[31].s64 + 364;
	// 823F6E9C: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6EA0: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6EA4: 418200A8  beq 0x823f6f4c
	if ctx.cr[0].eq {
	pc = 0x823F6F4C; continue 'dispatch;
	}
	// 823F6EA8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6EAC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F6EB0: 409A0008  bne cr6, 0x823f6eb8
	if !ctx.cr[6].eq {
	pc = 0x823F6EB8; continue 'dispatch;
	}
	// 823F6EB4: 931D0004  stw r24, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	pc = 0x823F6EB8; continue 'dispatch;
            }
            0x823F6EB8 => {
    //   block [0x823F6EB8..0x823F6F18)
	// 823F6EB8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6EBC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823F6EC0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F6EC4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823F6EC8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F6ECC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6ED0: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 823F6ED4: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823F6ED8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6EDC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F6EE0: 4813DC71  bl 0x82534b50
	ctx.lr = 0x823F6EE4;
	sub_82534B50(ctx, base);
	// 823F6EE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6EE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F6EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F6EF0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 823F6EF4: 4BFFF735  bl 0x823f6628
	ctx.lr = 0x823F6EF8;
	sub_823F6628(ctx, base);
	// 823F6EF8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F6EFC: 40800054  bge 0x823f6f50
	if !ctx.cr[0].lt {
	pc = 0x823F6F50; continue 'dispatch;
	}
	// 823F6F00: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 823F6F04: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6F08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6F0C: 4182002C  beq 0x823f6f38
	if ctx.cr[0].eq {
	pc = 0x823F6F38; continue 'dispatch;
	}
	// 823F6F10: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823F6F14: 48000028  b 0x823f6f3c
	pc = 0x823F6F3C; continue 'dispatch;
            }
            0x823F6F18 => {
    //   block [0x823F6F18..0x823F6F38)
	// 823F6F18: 897F0134  lbz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 823F6F1C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 823F6F20: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F6F24: 409A002C  bne cr6, 0x823f6f50
	if !ctx.cr[6].eq {
	pc = 0x823F6F50; continue 'dispatch;
	}
	// 823F6F28: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 823F6F2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823F6F30: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 823F6F34: 4800001C  b 0x823f6f50
	pc = 0x823F6F50; continue 'dispatch;
            }
            0x823F6F38 => {
    //   block [0x823F6F38..0x823F6F3C)
	// 823F6F38: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x823F6F3C; continue 'dispatch;
            }
            0x823F6F3C => {
    //   block [0x823F6F3C..0x823F6F4C)
	// 823F6F3C: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823F6F40: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 823F6F44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F6F48: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6F4C; continue 'dispatch;
            }
            0x823F6F4C => {
    //   block [0x823F6F4C..0x823F6F50)
	// 823F6F4C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x823F6F50; continue 'dispatch;
            }
            0x823F6F50 => {
    //   block [0x823F6F50..0x823F6F5C)
	// 823F6F50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F6F54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823F6F58: 4813E1A0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F6F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F6F60 size=184
    let mut pc: u32 = 0x823F6F60;
    'dispatch: loop {
        match pc {
            0x823F6F60 => {
    //   block [0x823F6F60..0x823F6FA4)
	// 823F6F60: E9030028  ld r8, 0x28(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	// 823F6F64: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 823F6F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F6F6C: 81430174  lwz r10, 0x174(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(372 as u32) ) } as u64;
	// 823F6F70: 7D284B92  divdu r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 / ctx.r[9].u64;
	// 823F6F74: 39030174  addi r8, r3, 0x174
	ctx.r[8].s64 = ctx.r[3].s64 + 372;
	// 823F6F78: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6F7C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 823F6F80: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 823F6F84: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823F6F88: B1230040  sth r9, 0x40(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[9].u16 ) };
	// 823F6F8C: F9630128  std r11, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[11].u64 ) };
	// 823F6F90: 91630130  stw r11, 0x130(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 823F6F94: 99630134  stb r11, 0x134(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), ctx.r[11].u8 ) };
	// 823F6F98: 91630138  stw r11, 0x138(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 823F6F9C: 4182005C  beq 0x823f6ff8
	if ctx.cr[0].eq {
	pc = 0x823F6FF8; continue 'dispatch;
	}
	// 823F6FA0: 38E3016C  addi r7, r3, 0x16c
	ctx.r[7].s64 = ctx.r[3].s64 + 364;
	pc = 0x823F6FA4; continue 'dispatch;
            }
            0x823F6FA4 => {
    //   block [0x823F6FA4..0x823F6FC0)
	// 823F6FA4: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6FA8: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6FAC: 41820020  beq 0x823f6fcc
	if ctx.cr[0].eq {
	pc = 0x823F6FCC; continue 'dispatch;
	}
	// 823F6FB0: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6FB4: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823F6FB8: 409A0008  bne cr6, 0x823f6fc0
	if !ctx.cr[6].eq {
	pc = 0x823F6FC0; continue 'dispatch;
	}
	// 823F6FBC: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6FC0; continue 'dispatch;
            }
            0x823F6FC0 => {
    //   block [0x823F6FC0..0x823F6FCC)
	// 823F6FC0: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6FC4: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 823F6FC8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823F6FCC; continue 'dispatch;
            }
            0x823F6FCC => {
    //   block [0x823F6FCC..0x823F6FE4)
	// 823F6FCC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F6FD0: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F6FD4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6FD8: 4182000C  beq 0x823f6fe4
	if ctx.cr[0].eq {
	pc = 0x823F6FE4; continue 'dispatch;
	}
	// 823F6FDC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F6FE0: 48000008  b 0x823f6fe8
	pc = 0x823F6FE8; continue 'dispatch;
            }
            0x823F6FE4 => {
    //   block [0x823F6FE4..0x823F6FE8)
	// 823F6FE4: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823F6FE8; continue 'dispatch;
            }
            0x823F6FE8 => {
    //   block [0x823F6FE8..0x823F6FF8)
	// 823F6FE8: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F6FEC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F6FF0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F6FF4: 4082FFB0  bne 0x823f6fa4
	if !ctx.cr[0].eq {
	pc = 0x823F6FA4; continue 'dispatch;
	}
	pc = 0x823F6FF8; continue 'dispatch;
            }
            0x823F6FF8 => {
    //   block [0x823F6FF8..0x823F7000)
	// 823F6FF8: 39430050  addi r10, r3, 0x50
	ctx.r[10].s64 = ctx.r[3].s64 + 80;
	// 823F6FFC: 39600019  li r11, 0x19
	ctx.r[11].s64 = 25;
	pc = 0x823F7000; continue 'dispatch;
            }
            0x823F7000 => {
    //   block [0x823F7000..0x823F7018)
	// 823F7000: E9230118  ld r9, 0x118(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) };
	// 823F7004: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F7008: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 823F700C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823F7010: 4082FFF0  bne 0x823f7000
	if !ctx.cr[0].eq {
	pc = 0x823F7000; continue 'dispatch;
	}
	// 823F7014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7018 size=440
    let mut pc: u32 = 0x823F7018;
    'dispatch: loop {
        match pc {
            0x823F7018 => {
    //   block [0x823F7018..0x823F7044)
	// 823F7018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F701C: 4813E0A1  bl 0x825350bc
	ctx.lr = 0x823F7020;
	sub_82535080(ctx, base);
	// 823F7020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7024: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823F7028: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F702C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F7030: 60848013  ori r4, r4, 0x8013
	ctx.r[4].u64 = ctx.r[4].u64 | 32787;
	// 823F7034: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 823F7038: 4BFD3189  bl 0x823ca1c0
	ctx.lr = 0x823F703C;
	sub_823CA1C0(ctx, base);
	// 823F703C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823F7040: 40820010  bne 0x823f7050
	if !ctx.cr[0].eq {
	pc = 0x823F7050; continue 'dispatch;
	}
	pc = 0x823F7044; continue 'dispatch;
            }
            0x823F7044 => {
    //   block [0x823F7044..0x823F7050)
	// 823F7044: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 823F7048: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 823F704C: 48000168  b 0x823f71b4
	pc = 0x823F71B4; continue 'dispatch;
            }
            0x823F7050 => {
    //   block [0x823F7050..0x823F70C8)
	// 823F7050: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F7054: 93DF0188  stw r30, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[30].u32 ) };
	// 823F7058: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 823F705C: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 823F7060: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 823F7064: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 823F7068: C80B72C8  lfd f0, 0x72c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(29384 as u32) ) };
	// 823F706C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F7070: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 823F7074: D81F0118  stfd f0, 0x118(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.f[0].u64 ) };
	// 823F7078: 387F0148  addi r3, r31, 0x148
	ctx.r[3].s64 = ctx.r[31].s64 + 328;
	// 823F707C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823F7080: B13F0040  sth r9, 0x40(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u16 ) };
	// 823F7084: B11F0044  sth r8, 0x44(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[8].u16 ) };
	// 823F7088: C9AB72C0  lfd f13, 0x72c0(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(29376 as u32) ) };
	// 823F708C: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 823F7090: D9BF0120  stfd f13, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.f[13].u64 ) };
	// 823F7094: B15F0042  sth r10, 0x42(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(66 as u32), ctx.r[10].u16 ) };
	// 823F7098: 90FF0168  stw r7, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[7].u32 ) };
	// 823F709C: 90DF0150  stw r6, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[6].u32 ) };
	// 823F70A0: F97F0030  std r11, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 823F70A4: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 823F70A8: 4814EFA9  bl 0x82546050
	ctx.lr = 0x823F70AC;
	sub_82546050(ctx, base);
	// 823F70AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F70B0: 40820024  bne 0x823f70d4
	if !ctx.cr[0].eq {
	pc = 0x823F70D4; continue 'dispatch;
	}
	// 823F70B4: 4BFC95CD  bl 0x823c0680
	ctx.lr = 0x823F70B8;
	sub_823C0680(ctx, base);
	// 823F70B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F70BC: 4181000C  bgt 0x823f70c8
	if ctx.cr[0].gt {
	pc = 0x823F70C8; continue 'dispatch;
	}
	// 823F70C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F70C4: 480000E8  b 0x823f71ac
	pc = 0x823F71AC; continue 'dispatch;
            }
            0x823F70C8 => {
    //   block [0x823F70C8..0x823F70D4)
	// 823F70C8: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 823F70CC: 657E8007  oris r30, r11, 0x8007
	ctx.r[30].u64 = ctx.r[11].u64 | 2147942400;
	// 823F70D0: 480000DC  b 0x823f71ac
	pc = 0x823F71AC; continue 'dispatch;
            }
            0x823F70D4 => {
    //   block [0x823F70D4..0x823F70DC)
	// 823F70D4: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 823F70D8: 39600019  li r11, 0x19
	ctx.r[11].s64 = 25;
	pc = 0x823F70DC; continue 'dispatch;
            }
            0x823F70DC => {
    //   block [0x823F70DC..0x823F7150)
	// 823F70DC: C81F0118  lfd f0, 0x118(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	// 823F70E0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F70E4: D80A0000  stfd f0, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 823F70E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823F70EC: 4082FFF0  bne 0x823f70dc
	if !ctx.cr[0].eq {
	pc = 0x823F70DC; continue 'dispatch;
	}
	// 823F70F0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F70F4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823F70F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F70FC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7100: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 823F7104: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F7108: 386B0002  addi r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 2;
	// 823F710C: 4BFFF23D  bl 0x823f6348
	ctx.lr = 0x823F7110;
	sub_823F6348(ctx, base);
	// 823F7110: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F7114: 418000A0  blt 0x823f71b4
	if ctx.cr[0].lt {
	pc = 0x823F71B4; continue 'dispatch;
	}
	// 823F7118: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F711C: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F7120: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823F7124: 55631838  slwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 823F7128: 4BFD3099  bl 0x823ca1c0
	ctx.lr = 0x823F712C;
	sub_823CA1C0(ctx, base);
	// 823F712C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7130: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823F7134: 4182FF10  beq 0x823f7044
	if ctx.cr[0].eq {
	pc = 0x823F7044; continue 'dispatch;
	}
	// 823F7138: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F713C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F7140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7144: 40990068  ble cr6, 0x823f71ac
	if !ctx.cr[6].gt {
	pc = 0x823F71AC; continue 'dispatch;
	}
	// 823F7148: 38FF016C  addi r7, r31, 0x16c
	ctx.r[7].s64 = ctx.r[31].s64 + 364;
	// 823F714C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x823F7150; continue 'dispatch;
            }
            0x823F7150 => {
    //   block [0x823F7150..0x823F7190)
	// 823F7150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7154: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7158: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F715C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7160: 7D6541D6  mullw r11, r5, r8
	ctx.r[11].s32 = ((ctx.r[5].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F7164: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F7168: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F716C: 7D6A312E  stwx r11, r10, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 823F7170: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7174: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F7178: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 823F717C: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7180: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7184: 4182000C  beq 0x823f7190
	if ctx.cr[0].eq {
	pc = 0x823F7190; continue 'dispatch;
	}
	// 823F7188: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F718C: 48000008  b 0x823f7194
	pc = 0x823F7194; continue 'dispatch;
            }
            0x823F7190 => {
    //   block [0x823F7190..0x823F7194)
	// 823F7190: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F7194; continue 'dispatch;
            }
            0x823F7194 => {
    //   block [0x823F7194..0x823F71AC)
	// 823F7194: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F7198: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823F719C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F71A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823F71A4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F71A8: 4198FFA8  blt cr6, 0x823f7150
	if ctx.cr[6].lt {
	pc = 0x823F7150; continue 'dispatch;
	}
	pc = 0x823F71AC; continue 'dispatch;
            }
            0x823F71AC => {
    //   block [0x823F71AC..0x823F71B4)
	// 823F71AC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F71B0: 40980010  bge cr6, 0x823f71c0
	if !ctx.cr[6].lt {
	pc = 0x823F71C0; continue 'dispatch;
	}
	pc = 0x823F71B4; continue 'dispatch;
            }
            0x823F71B4 => {
    //   block [0x823F71B4..0x823F71C0)
	// 823F71B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F71B8: 4BFFF8E9  bl 0x823f6aa0
	ctx.lr = 0x823F71BC;
	sub_823F6AA0(ctx, base);
	// 823F71BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823F71C0; continue 'dispatch;
            }
            0x823F71C0 => {
    //   block [0x823F71C0..0x823F71D0)
	// 823F71C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F71C4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823F71C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F71CC: 4813DF40  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F71D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F71D0 size=8
    let mut pc: u32 = 0x823F71D0;
    'dispatch: loop {
        match pc {
            0x823F71D0 => {
    //   block [0x823F71D0..0x823F71D8)
	// 823F71D0: 806300C0  lwz r3, 0xc0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 823F71D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F71D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F71D8 size=116
    let mut pc: u32 = 0x823F71D8;
    'dispatch: loop {
        match pc {
            0x823F71D8 => {
    //   block [0x823F71D8..0x823F7200)
	// 823F71D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F71DC: 4813DEDD  bl 0x825350b8
	ctx.lr = 0x823F71E0;
	sub_82535080(ctx, base);
	// 823F71E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F71E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F71E8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823F71EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F71F0: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F71F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F71F8: 40990038  ble cr6, 0x823f7230
	if !ctx.cr[6].gt {
	pc = 0x823F7230; continue 'dispatch;
	}
	// 823F71FC: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	pc = 0x823F7200; continue 'dispatch;
            }
            0x823F7200 => {
    //   block [0x823F7200..0x823F7230)
	// 823F7200: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7204: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7208: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F720C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F7210: 4E800421  bctrl
	ctx.lr = 0x823F7214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F7214: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 823F7218: 419A0024  beq cr6, 0x823f723c
	if ctx.cr[6].eq {
	pc = 0x823F723C; continue 'dispatch;
	}
	// 823F721C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7220: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F7224: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F7228: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F722C: 4198FFD4  blt cr6, 0x823f7200
	if ctx.cr[6].lt {
	pc = 0x823F7200; continue 'dispatch;
	}
            }
            0x823F7230 => {
    //   block [0x823F7230..0x823F7234)
	// 823F7230: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823F7234; continue 'dispatch;
            }
            0x823F7234 => {
    //   block [0x823F7234..0x823F723C)
	// 823F7234: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F7238: 4813DED0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x823F723C => {
    //   block [0x823F723C..0x823F724C)
	// 823F723C: 397D0003  addi r11, r29, 3
	ctx.r[11].s64 = ctx.r[29].s64 + 3;
	// 823F7240: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F7244: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 823F7248: 4BFFFFEC  b 0x823f7234
	pc = 0x823F7234; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F7250 size=868
    let mut pc: u32 = 0x823F7250;
    'dispatch: loop {
        match pc {
            0x823F7250 => {
    //   block [0x823F7250..0x823F7288)
	// 823F7250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7254: 4813DE5D  bl 0x825350b0
	ctx.lr = 0x823F7258;
	sub_82535080(ctx, base);
	// 823F7258: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F725C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F7260: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823F7264: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 823F7268: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 823F726C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7270: 4831699D  bl 0x8270dc0c
	ctx.lr = 0x823F7274;
	// extern call 0x8270DC0C  crate::xam::XamVoiceHeadsetPresent
	crate::xam::XamVoiceHeadsetPresent(ctx, base);
	// 823F7274: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 823F7278: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F727C: 4182000C  beq 0x823f7288
	if ctx.cr[0].eq {
	pc = 0x823F7288; continue 'dispatch;
	}
	// 823F7280: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823F7284: 419A0014  beq cr6, 0x823f7298
	if ctx.cr[6].eq {
	pc = 0x823F7298; continue 'dispatch;
	}
	pc = 0x823F7288; continue 'dispatch;
            }
            0x823F7288 => {
    //   block [0x823F7288..0x823F7298)
	// 823F7288: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F728C: 409A0014  bne cr6, 0x823f72a0
	if !ctx.cr[6].eq {
	pc = 0x823F72A0; continue 'dispatch;
	}
	// 823F7290: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823F7294: 419A000C  beq cr6, 0x823f72a0
	if ctx.cr[6].eq {
	pc = 0x823F72A0; continue 'dispatch;
	}
	pc = 0x823F7298; continue 'dispatch;
            }
            0x823F7298 => {
    //   block [0x823F7298..0x823F72A0)
	// 823F7298: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 823F729C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x823F72A0; continue 'dispatch;
            }
            0x823F72A0 => {
    //   block [0x823F72A0..0x823F72C0)
	// 823F72A0: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 823F72A4: 907F00C0  stw r3, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[3].u32 ) };
	// 823F72A8: 816B0524  lwz r11, 0x524(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1316 as u32) ) } as u64;
	// 823F72AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F72B0: 409A0010  bne cr6, 0x823f72c0
	if !ctx.cr[6].eq {
	pc = 0x823F72C0; continue 'dispatch;
	}
	// 823F72B4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 823F72B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F72BC: 419A0184  beq cr6, 0x823f7440
	if ctx.cr[6].eq {
	pc = 0x823F7440; continue 'dispatch;
	}
	pc = 0x823F72C0; continue 'dispatch;
            }
            0x823F72C0 => {
    //   block [0x823F72C0..0x823F7318)
	// 823F72C0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F72C4: 48315DD9  bl 0x8270d09c
	ctx.lr = 0x823F72C8;
	// extern call 0x8270D09C  crate::xam::XamUserGetSigninState
	crate::xam::XamUserGetSigninState(ctx, base);
	// 823F72C8: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 823F72CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F72D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F72D4: 419A01EC  beq cr6, 0x823f74c0
	if ctx.cr[6].eq {
	pc = 0x823F74C0; continue 'dispatch;
	}
	// 823F72D8: 3BDF0094  addi r30, r31, 0x94
	ctx.r[30].s64 = ctx.r[31].s64 + 148;
	// 823F72DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F72E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F72E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F72E8: 4BFC8EB1  bl 0x823c0198
	ctx.lr = 0x823F72EC;
	sub_823C0198(ctx, base);
	// 823F72EC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F72F0: 419A0124  beq cr6, 0x823f7414
	if ctx.cr[6].eq {
	pc = 0x823F7414; continue 'dispatch;
	}
	// 823F72F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823F72F8: 409A011C  bne cr6, 0x823f7414
	if !ctx.cr[6].eq {
	pc = 0x823F7414; continue 'dispatch;
	}
	// 823F72FC: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 823F7300: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 823F7304: 935F00BC  stw r26, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	// 823F7308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F730C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7310: 40990130  ble cr6, 0x823f7440
	if !ctx.cr[6].gt {
	pc = 0x823F7440; continue 'dispatch;
	}
	// 823F7314: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x823F7318; continue 'dispatch;
            }
            0x823F7318 => {
    //   block [0x823F7318..0x823F7358)
	// 823F7318: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 823F731C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7320: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F7324: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F7328: 3D4AEFFC  addis r10, r10, -0x1004
	ctx.r[10].s64 = ctx.r[10].s64 + -268697600;
	// 823F732C: 354AFFF4  addic. r10, r10, -0xc
	ctx.xer.ca = (ctx.r[10].u32 > (!(-12 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F7330: 418200A8  beq 0x823f73d8
	if ctx.cr[0].eq {
	pc = 0x823F73D8; continue 'dispatch;
	}
	// 823F7334: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823F7338: 419A005C  beq cr6, 0x823f7394
	if ctx.cr[6].eq {
	pc = 0x823F7394; continue 'dispatch;
	}
	// 823F733C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823F7340: 409A00B8  bne cr6, 0x823f73f8
	if !ctx.cr[6].eq {
	pc = 0x823F73F8; continue 'dispatch;
	}
	// 823F7344: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7348: 2F0A0064  cmpwi cr6, r10, 0x64
	ctx.cr[6].compare_i32(ctx.r[10].s32, 100, &mut ctx.xer);
	// 823F734C: 4099000C  ble cr6, 0x823f7358
	if !ctx.cr[6].gt {
	pc = 0x823F7358; continue 'dispatch;
	}
	// 823F7350: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 823F7354: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	pc = 0x823F7358; continue 'dispatch;
            }
            0x823F7358 => {
    //   block [0x823F7358..0x823F7394)
	// 823F7358: E94B0022  lwa r10, 0x20(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as i32) as i64;
	// 823F735C: C01F00B8  lfs f0, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F7360: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 823F7364: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 823F7368: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823F736C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823F7370: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823F7374: 419A0084  beq cr6, 0x823f73f8
	if ctx.cr[6].eq {
	pc = 0x823F73F8; continue 'dispatch;
	}
	// 823F7378: 9B5F00C6  stb r26, 0xc6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(198 as u32), ctx.r[26].u8 ) };
	// 823F737C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 823F7380: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7384: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F7388: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F738C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823F7390: 48000064  b 0x823f73f4
	pc = 0x823F73F4; continue 'dispatch;
            }
            0x823F7394 => {
    //   block [0x823F7394..0x823F73AC)
	// 823F7394: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7398: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F739C: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F73A0: 419A000C  beq cr6, 0x823f73ac
	if ctx.cr[6].eq {
	pc = 0x823F73AC; continue 'dispatch;
	}
	// 823F73A4: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 823F73A8: 48000008  b 0x823f73b0
	pc = 0x823F73B0; continue 'dispatch;
            }
            0x823F73AC => {
    //   block [0x823F73AC..0x823F73B0)
	// 823F73AC: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823F73B0; continue 'dispatch;
            }
            0x823F73B0 => {
    //   block [0x823F73B0..0x823F73CC)
	// 823F73B0: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 823F73B4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F73B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F73BC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F73C0: 419A000C  beq cr6, 0x823f73cc
	if ctx.cr[6].eq {
	pc = 0x823F73CC; continue 'dispatch;
	}
	// 823F73C4: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 823F73C8: 48000008  b 0x823f73d0
	pc = 0x823F73D0; continue 'dispatch;
            }
            0x823F73CC => {
    //   block [0x823F73CC..0x823F73D0)
	// 823F73CC: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823F73D0; continue 'dispatch;
            }
            0x823F73D0 => {
    //   block [0x823F73D0..0x823F73D8)
	// 823F73D0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 823F73D4: 48000020  b 0x823f73f4
	pc = 0x823F73F4; continue 'dispatch;
            }
            0x823F73D8 => {
    //   block [0x823F73D8..0x823F73F0)
	// 823F73D8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F73DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F73E0: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F73E4: 419A000C  beq cr6, 0x823f73f0
	if ctx.cr[6].eq {
	pc = 0x823F73F0; continue 'dispatch;
	}
	// 823F73E8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 823F73EC: 48000008  b 0x823f73f4
	pc = 0x823F73F4; continue 'dispatch;
            }
            0x823F73F0 => {
    //   block [0x823F73F0..0x823F73F4)
	// 823F73F0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823F73F4; continue 'dispatch;
            }
            0x823F73F4 => {
    //   block [0x823F73F4..0x823F73F8)
	// 823F73F4: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	pc = 0x823F73F8; continue 'dispatch;
            }
            0x823F73F8 => {
    //   block [0x823F73F8..0x823F7414)
	// 823F73F8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 823F73FC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823F7400: 39290028  addi r9, r9, 0x28
	ctx.r[9].s64 = ctx.r[9].s64 + 40;
	// 823F7404: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7408: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F740C: 4198FF0C  blt cr6, 0x823f7318
	if ctx.cr[6].lt {
	pc = 0x823F7318; continue 'dispatch;
	}
	// 823F7410: 48000030  b 0x823f7440
	pc = 0x823F7440; continue 'dispatch;
            }
            0x823F7414 => {
    //   block [0x823F7414..0x823F7424)
	// 823F7414: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7418: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 823F741C: 419A0024  beq cr6, 0x823f7440
	if ctx.cr[6].eq {
	pc = 0x823F7440; continue 'dispatch;
	}
	// 823F7420: 935F00BC  stw r26, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7424; continue 'dispatch;
            }
            0x823F7424 => {
    //   block [0x823F7424..0x823F7440)
	// 823F7424: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823F7428: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F742C: 616B6404  ori r11, r11, 0x6404
	ctx.r[11].u64 = ctx.r[11].u64 | 25604;
	// 823F7430: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7434: 419A000C  beq cr6, 0x823f7440
	if ctx.cr[6].eq {
	pc = 0x823F7440; continue 'dispatch;
	}
	// 823F7438: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 823F743C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x823F7440; continue 'dispatch;
            }
            0x823F7440 => {
    //   block [0x823F7440..0x823F7448)
	// 823F7440: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 823F7444: 409A003C  bne cr6, 0x823f7480
	if !ctx.cr[6].eq {
	pc = 0x823F7480; continue 'dispatch;
	}
	pc = 0x823F7448; continue 'dispatch;
            }
            0x823F7448 => {
    //   block [0x823F7448..0x823F744C)
	// 823F7448: 3BC00468  li r30, 0x468
	ctx.r[30].s64 = 1128;
	pc = 0x823F744C; continue 'dispatch;
            }
            0x823F744C => {
    //   block [0x823F744C..0x823F7470)
	// 823F744C: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 823F7450: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F7454: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F7458: 419A0018  beq cr6, 0x823f7470
	if ctx.cr[6].eq {
	pc = 0x823F7470; continue 'dispatch;
	}
	// 823F745C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 823F7460: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 823F7464: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 823F7468: 419A0008  beq cr6, 0x823f7470
	if ctx.cr[6].eq {
	pc = 0x823F7470; continue 'dispatch;
	}
	// 823F746C: 4BFFDAA5  bl 0x823f4f10
	ctx.lr = 0x823F7470;
	sub_823F4F10(ctx, base);
	pc = 0x823F7470; continue 'dispatch;
            }
            0x823F7470 => {
    //   block [0x823F7470..0x823F7480)
	// 823F7470: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F7474: 2B1E04F0  cmplwi cr6, r30, 0x4f0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1264 as u32, &mut ctx.xer);
	// 823F7478: 4198FFD4  blt cr6, 0x823f744c
	if ctx.cr[6].lt {
	pc = 0x823F744C; continue 'dispatch;
	}
	// 823F747C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x823F7480; continue 'dispatch;
            }
            0x823F7480 => {
    //   block [0x823F7480..0x823F74B8)
	// 823F7480: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 823F7484: 409A0034  bne cr6, 0x823f74b8
	if !ctx.cr[6].eq {
	pc = 0x823F74B8; continue 'dispatch;
	}
	// 823F7488: 897F00C6  lbz r11, 0xc6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(198 as u32) ) } as u64;
	// 823F748C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F7490: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 823F7494: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 823F7498: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823F749C: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 823F74A0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823F74A4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823F74A8: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F74AC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823F74B0: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 823F74B4: 4BFFC3A5  bl 0x823f3858
	ctx.lr = 0x823F74B8;
	sub_823F3858(ctx, base);
	pc = 0x823F74B8; continue 'dispatch;
            }
            0x823F74B8 => {
    //   block [0x823F74B8..0x823F74C0)
	// 823F74B8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823F74BC: 4813DC44  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x823F74C0 => {
    //   block [0x823F74C0..0x823F7528)
	// 823F74C0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F74C4: 419AFF60  beq cr6, 0x823f7424
	if ctx.cr[6].eq {
	pc = 0x823F7424; continue 'dispatch;
	}
	// 823F74C8: 38BF0094  addi r5, r31, 0x94
	ctx.r[5].s64 = ctx.r[31].s64 + 148;
	// 823F74CC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F74D0: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F74D4: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 823F74D8: 3C60FFFE  lis r3, -2
	ctx.r[3].s64 = -131072;
	// 823F74DC: 390BD1F0  addi r8, r11, -0x2e10
	ctx.r[8].s64 = ctx.r[11].s64 + -11792;
	// 823F74E0: 393F00B4  addi r9, r31, 0xb4
	ctx.r[9].s64 = ctx.r[31].s64 + 180;
	// 823F74E4: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 823F74E8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 823F74EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F74F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F74F4: 606307D1  ori r3, r3, 0x7d1
	ctx.r[3].u64 = ctx.r[3].u64 | 2001;
	// 823F74F8: 48316705  bl 0x8270dbfc
	ctx.lr = 0x823F74FC;
	// extern call 0x8270DBFC  crate::xam::XamUserReadProfileSettings
	crate::xam::XamUserReadProfileSettings(ctx, base);
	// 823F74FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7500: 41820028  beq 0x823f7528
	if ctx.cr[0].eq {
	pc = 0x823F7528; continue 'dispatch;
	}
	// 823F7504: 2B0303E5  cmplwi cr6, r3, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 997 as u32, &mut ctx.xer);
	// 823F7508: 419A0020  beq cr6, 0x823f7528
	if ctx.cr[6].eq {
	pc = 0x823F7528; continue 'dispatch;
	}
	// 823F750C: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823F7510: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F7514: 616B6404  ori r11, r11, 0x6404
	ctx.r[11].u64 = ctx.r[11].u64 | 25604;
	// 823F7518: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F751C: 419A0014  beq cr6, 0x823f7530
	if ctx.cr[6].eq {
	pc = 0x823F7530; continue 'dispatch;
	}
	// 823F7520: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 823F7524: 4800000C  b 0x823f7530
	pc = 0x823F7530; continue 'dispatch;
            }
            0x823F7528 => {
    //   block [0x823F7528..0x823F7530)
	// 823F7528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F752C: 917F00BC  stw r11, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	pc = 0x823F7530; continue 'dispatch;
            }
            0x823F7530 => {
    //   block [0x823F7530..0x823F7580)
	// 823F7530: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823F7534: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7538: 388000FC  li r4, 0xfc
	ctx.r[4].s64 = 252;
	// 823F753C: 48315B81  bl 0x8270d0bc
	ctx.lr = 0x823F7540;
	// extern call 0x8270D0BC  crate::xam::XamUserCheckPrivilege
	crate::xam::XamUserCheckPrivilege(ctx, base);
	// 823F7540: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7544: 40820044  bne 0x823f7588
	if !ctx.cr[0].eq {
	pc = 0x823F7588; continue 'dispatch;
	}
	// 823F7548: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823F754C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F7550: 419A0038  beq cr6, 0x823f7588
	if ctx.cr[6].eq {
	pc = 0x823F7588; continue 'dispatch;
	}
	// 823F7554: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823F7558: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F755C: 388000FB  li r4, 0xfb
	ctx.r[4].s64 = 251;
	// 823F7560: 48315B5D  bl 0x8270d0bc
	ctx.lr = 0x823F7564;
	// extern call 0x8270D0BC  crate::xam::XamUserCheckPrivilege
	crate::xam::XamUserCheckPrivilege(ctx, base);
	// 823F7564: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7568: 40820018  bne 0x823f7580
	if !ctx.cr[0].eq {
	pc = 0x823F7580; continue 'dispatch;
	}
	// 823F756C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823F7570: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F7574: 409A000C  bne cr6, 0x823f7580
	if !ctx.cr[6].eq {
	pc = 0x823F7580; continue 'dispatch;
	}
	// 823F7578: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 823F757C: 48000010  b 0x823f758c
	pc = 0x823F758C; continue 'dispatch;
            }
            0x823F7580 => {
    //   block [0x823F7580..0x823F7588)
	// 823F7580: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823F7584: 48000008  b 0x823f758c
	pc = 0x823F758C; continue 'dispatch;
            }
            0x823F7588 => {
    //   block [0x823F7588..0x823F758C)
	// 823F7588: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	pc = 0x823F758C; continue 'dispatch;
            }
            0x823F758C => {
    //   block [0x823F758C..0x823F75A0)
	// 823F758C: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 823F7590: 814A0024  lwz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F7594: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F7598: 419A0008  beq cr6, 0x823f75a0
	if ctx.cr[6].eq {
	pc = 0x823F75A0; continue 'dispatch;
	}
	// 823F759C: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	pc = 0x823F75A0; continue 'dispatch;
            }
            0x823F75A0 => {
    //   block [0x823F75A0..0x823F75B4)
	// 823F75A0: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F75A4: 554A0416  rlwinm r10, r10, 0, 0x10, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823F75A8: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 823F75AC: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 823F75B0: 4BFFFE98  b 0x823f7448
	pc = 0x823F7448; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F75B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F75B8 size=660
    let mut pc: u32 = 0x823F75B8;
    'dispatch: loop {
        match pc {
            0x823F75B8 => {
    //   block [0x823F75B8..0x823F75E4)
	// 823F75B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F75BC: 4813DADD  bl 0x82535098
	ctx.lr = 0x823F75C0;
	sub_82535080(ctx, base);
	// 823F75C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F75C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F75C8: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 823F75CC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 823F75D0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823F75D4: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 823F75D8: 3AFC0048  addi r23, r28, 0x48
	ctx.r[23].s64 = ctx.r[28].s64 + 72;
	// 823F75DC: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 823F75E0: 3AA00002  li r21, 2
	ctx.r[21].s64 = 2;
	pc = 0x823F75E4; continue 'dispatch;
            }
            0x823F75E4 => {
    //   block [0x823F75E4..0x823F7608)
	// 823F75E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 823F75E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F75EC: 7D60B828  lwarx r11, 0, r23
	// lwarx
	let ea = ctx.r[23].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 823F75F0: 7F0BA000  cmpw cr6, r11, r20
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[20].s32, &mut ctx.xer);
	// 823F75F4: 409A0014  bne cr6, 0x823f7608
	if !ctx.cr[6].eq {
	pc = 0x823F7608; continue 'dispatch;
	}
	// 823F75F8: 7EA0B92D  stwcx. r21, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[21].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F75FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F7600: 4082FFE4  bne 0x823f75e4
	if !ctx.cr[0].eq {
	pc = 0x823F75E4; continue 'dispatch;
	}
	// 823F7604: 4800000C  b 0x823f7610
	pc = 0x823F7610; continue 'dispatch;
            }
            0x823F7608 => {
    //   block [0x823F7608..0x823F7610)
	// 823F7608: 7D60B92D  stwcx. r11, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F760C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	pc = 0x823F7610; continue 'dispatch;
            }
            0x823F7610 => {
    //   block [0x823F7610..0x823F7658)
	// 823F7610: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 823F7614: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F7618: 409A0180  bne cr6, 0x823f7798
	if !ctx.cr[6].eq {
	pc = 0x823F7798; continue 'dispatch;
	}
	// 823F761C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7624: 419A0170  beq cr6, 0x823f7794
	if ctx.cr[6].eq {
	pc = 0x823F7794; continue 'dispatch;
	}
	// 823F7628: 817C00C4  lwz r11, 0xc4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) } as u64;
	// 823F762C: 556B031F  rlwinm. r11, r11, 0, 0xc, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F7630: 41820164  beq 0x823f7794
	if ctx.cr[0].eq {
	pc = 0x823F7794; continue 'dispatch;
	}
	// 823F7634: 3B5C0044  addi r26, r28, 0x44
	ctx.r[26].s64 = ctx.r[28].s64 + 68;
	// 823F7638: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 823F763C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F7640: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 823F7644: 48316039  bl 0x8270d67c
	ctx.lr = 0x823F7648;
	// extern call 0x8270D67C  crate::xboxkrnl::KfAcquireSpinLock
	crate::xboxkrnl::KfAcquireSpinLock(ctx, base);
	// 823F7648: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F764C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823F7650: 3B7C0034  addi r27, r28, 0x34
	ctx.r[27].s64 = ctx.r[28].s64 + 52;
	// 823F7654: 48000024  b 0x823f7678
	pc = 0x823F7678; continue 'dispatch;
            }
            0x823F7658 => {
    //   block [0x823F7658..0x823F7678)
	// 823F7658: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 823F765C: 40980024  bge cr6, 0x823f7680
	if !ctx.cr[6].lt {
	pc = 0x823F7680; continue 'dispatch;
	}
	// 823F7660: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7664: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7668: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F766C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7670: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823F7674: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	pc = 0x823F7678; continue 'dispatch;
            }
            0x823F7678 => {
    //   block [0x823F7678..0x823F7680)
	// 823F7678: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F767C: 4082FFDC  bne 0x823f7658
	if !ctx.cr[0].eq {
	pc = 0x823F7658; continue 'dispatch;
	}
	pc = 0x823F7680; continue 'dispatch;
            }
            0x823F7680 => {
    //   block [0x823F7680..0x823F769C)
	// 823F7680: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F7684: 48315FE9  bl 0x8270d66c
	ctx.lr = 0x823F7688;
	// extern call 0x8270D66C  crate::xboxkrnl::KfReleaseSpinLock
	crate::xboxkrnl::KfReleaseSpinLock(ctx, base);
	// 823F7688: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 823F768C: 4198010C  blt cr6, 0x823f7798
	if ctx.cr[6].lt {
	pc = 0x823F7798; continue 'dispatch;
	}
	// 823F7690: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7694: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7698: 41820100  beq 0x823f7798
	if ctx.cr[0].eq {
	pc = 0x823F7798; continue 'dispatch;
	}
	pc = 0x823F769C; continue 'dispatch;
            }
            0x823F769C => {
    //   block [0x823F769C..0x823F76D4)
	// 823F769C: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 823F76A0: 409800F8  bge cr6, 0x823f7798
	if !ctx.cr[6].lt {
	pc = 0x823F7798; continue 'dispatch;
	}
	// 823F76A4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F76A8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 823F76AC: 419A00EC  beq cr6, 0x823f7798
	if ctx.cr[6].eq {
	pc = 0x823F7798; continue 'dispatch;
	}
	// 823F76B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F76B4: 7D3DC850  subf r9, r29, r25
	ctx.r[9].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 823F76B8: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823F76BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F76C0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F76C4: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 823F76C8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823F76CC: 41980008  blt cr6, 0x823f76d4
	if ctx.cr[6].lt {
	pc = 0x823F76D4; continue 'dispatch;
	}
	// 823F76D0: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	pc = 0x823F76D4; continue 'dispatch;
            }
            0x823F76D4 => {
    //   block [0x823F76D4..0x823F7704)
	// 823F76D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F76D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823F76DC: 7C9DC214  add r4, r29, r24
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[24].u64;
	// 823F76E0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F76E4: 4813D46D  bl 0x82534b50
	ctx.lr = 0x823F76E8;
	sub_82534B50(ctx, base);
	// 823F76E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F76EC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F76F0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F76F4: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 823F76F8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F76FC: 40980008  bge cr6, 0x823f7704
	if !ctx.cr[6].lt {
	pc = 0x823F7704; continue 'dispatch;
	}
	// 823F7700: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F7704; continue 'dispatch;
            }
            0x823F7704 => {
    //   block [0x823F7704..0x823F7740)
	// 823F7704: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F7708: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F770C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7710: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7714: 409A0070  bne cr6, 0x823f7784
	if !ctx.cr[6].eq {
	pc = 0x823F7784; continue 'dispatch;
	}
	// 823F7718: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F771C: 48315F61  bl 0x8270d67c
	ctx.lr = 0x823F7720;
	// extern call 0x8270D67C  crate::xboxkrnl::KfAcquireSpinLock
	crate::xboxkrnl::KfAcquireSpinLock(ctx, base);
	// 823F7720: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7724: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823F7728: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F772C: 41820020  beq 0x823f774c
	if ctx.cr[0].eq {
	pc = 0x823F774C; continue 'dispatch;
	}
	// 823F7730: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7734: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F7738: 409A0008  bne cr6, 0x823f7740
	if !ctx.cr[6].eq {
	pc = 0x823F7740; continue 'dispatch;
	}
	// 823F773C: 92DB0004  stw r22, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	pc = 0x823F7740; continue 'dispatch;
            }
            0x823F7740 => {
    //   block [0x823F7740..0x823F774C)
	// 823F7740: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7744: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F7748: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	pc = 0x823F774C; continue 'dispatch;
            }
            0x823F774C => {
    //   block [0x823F774C..0x823F7770)
	// 823F774C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7750: 409A0028  bne cr6, 0x823f7778
	if !ctx.cr[6].eq {
	pc = 0x823F7778; continue 'dispatch;
	}
	// 823F7754: 397C003C  addi r11, r28, 0x3c
	ctx.r[11].s64 = ctx.r[28].s64 + 60;
	// 823F7758: 92DF0004  stw r22, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 823F775C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7760: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7764: 4182000C  beq 0x823f7770
	if ctx.cr[0].eq {
	pc = 0x823F7770; continue 'dispatch;
	}
	// 823F7768: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F776C: 48000008  b 0x823f7774
	pc = 0x823F7774; continue 'dispatch;
            }
            0x823F7770 => {
    //   block [0x823F7770..0x823F7774)
	// 823F7770: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823F7774; continue 'dispatch;
            }
            0x823F7774 => {
    //   block [0x823F7774..0x823F7778)
	// 823F7774: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x823F7778; continue 'dispatch;
            }
            0x823F7778 => {
    //   block [0x823F7778..0x823F7784)
	// 823F7778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823F777C: 48315EF1  bl 0x8270d66c
	ctx.lr = 0x823F7780;
	// extern call 0x8270D66C  crate::xboxkrnl::KfReleaseSpinLock
	crate::xboxkrnl::KfReleaseSpinLock(ctx, base);
	// 823F7780: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823F7784; continue 'dispatch;
            }
            0x823F7784 => {
    //   block [0x823F7784..0x823F7794)
	// 823F7784: 7FBEEA14  add r29, r30, r29
	ctx.r[29].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 823F7788: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F778C: 409AFF10  bne cr6, 0x823f769c
	if !ctx.cr[6].eq {
	pc = 0x823F769C; continue 'dispatch;
	}
	// 823F7790: 48000008  b 0x823f7798
	pc = 0x823F7798; continue 'dispatch;
            }
            0x823F7794 => {
    //   block [0x823F7794..0x823F7798)
	// 823F7794: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	pc = 0x823F7798; continue 'dispatch;
            }
            0x823F7798 => {
    //   block [0x823F7798..0x823F779C)
	// 823F7798: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	pc = 0x823F779C; continue 'dispatch;
            }
            0x823F779C => {
    //   block [0x823F779C..0x823F77C0)
	// 823F779C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F77A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F77A4: 7D60B828  lwarx r11, 0, r23
	// lwarx
	let ea = ctx.r[23].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 823F77A8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823F77AC: 409A0080  bne cr6, 0x823f782c
	if !ctx.cr[6].eq {
	pc = 0x823F782C; continue 'dispatch;
	}
	// 823F77B0: 7EC0B92D  stwcx. r22, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[22].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F77B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F77B8: 4082FFE4  bne 0x823f779c
	if !ctx.cr[0].eq {
	pc = 0x823F779C; continue 'dispatch;
	}
	// 823F77BC: 48000078  b 0x823f7834
	pc = 0x823F7834; continue 'dispatch;
            }
            0x823F77C0 => {
    //   block [0x823F77C0..0x823F77E4)
	// 823F77C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F77C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F77C8: 7D60B828  lwarx r11, 0, r23
	// lwarx
	let ea = ctx.r[23].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 823F77CC: 7F0BA800  cmpw cr6, r11, r21
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[21].s32, &mut ctx.xer);
	// 823F77D0: 409A0014  bne cr6, 0x823f77e4
	if !ctx.cr[6].eq {
	pc = 0x823F77E4; continue 'dispatch;
	}
	// 823F77D4: 7E80B92D  stwcx. r20, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[20].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F77D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F77DC: 4082FFE4  bne 0x823f77c0
	if !ctx.cr[0].eq {
	pc = 0x823F77C0; continue 'dispatch;
	}
	// 823F77E0: 4800000C  b 0x823f77ec
	pc = 0x823F77EC; continue 'dispatch;
            }
            0x823F77E4 => {
    //   block [0x823F77E4..0x823F77EC)
	// 823F77E4: 7D60B92D  stwcx. r11, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F77E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	pc = 0x823F77EC; continue 'dispatch;
            }
            0x823F77EC => {
    //   block [0x823F77EC..0x823F7808)
	// 823F77EC: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 823F77F0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 823F77F4: 419A004C  beq cr6, 0x823f7840
	if ctx.cr[6].eq {
	pc = 0x823F7840; continue 'dispatch;
	}
	// 823F77F8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823F77FC: 419A0044  beq cr6, 0x823f7840
	if ctx.cr[6].eq {
	pc = 0x823F7840; continue 'dispatch;
	}
	// 823F7800: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F7804: 419A003C  beq cr6, 0x823f7840
	if ctx.cr[6].eq {
	pc = 0x823F7840; continue 'dispatch;
	}
	pc = 0x823F7808; continue 'dispatch;
            }
            0x823F7808 => {
    //   block [0x823F7808..0x823F782C)
	// 823F7808: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F780C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F7810: 7D60B828  lwarx r11, 0, r23
	// lwarx
	let ea = ctx.r[23].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 823F7814: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823F7818: 409A0014  bne cr6, 0x823f782c
	if !ctx.cr[6].eq {
	pc = 0x823F782C; continue 'dispatch;
	}
	// 823F781C: 7EC0B92D  stwcx. r22, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[22].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F7820: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F7824: 4082FFE4  bne 0x823f7808
	if !ctx.cr[0].eq {
	pc = 0x823F7808; continue 'dispatch;
	}
	// 823F7828: 4800000C  b 0x823f7834
	pc = 0x823F7834; continue 'dispatch;
            }
            0x823F782C => {
    //   block [0x823F782C..0x823F7834)
	// 823F782C: 7D60B92D  stwcx. r11, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F7830: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	pc = 0x823F7834; continue 'dispatch;
            }
            0x823F7834 => {
    //   block [0x823F7834..0x823F7840)
	// 823F7834: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 823F7838: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 823F783C: 409AFF84  bne cr6, 0x823f77c0
	if !ctx.cr[6].eq {
	pc = 0x823F77C0; continue 'dispatch;
	}
	pc = 0x823F7840; continue 'dispatch;
            }
            0x823F7840 => {
    //   block [0x823F7840..0x823F784C)
	// 823F7840: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F7844: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823F7848: 4813D8A0  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7850 size=280
    let mut pc: u32 = 0x823F7850;
    'dispatch: loop {
        match pc {
            0x823F7850 => {
    //   block [0x823F7850..0x823F7878)
	// 823F7850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7854: 4813D869  bl 0x825350bc
	ctx.lr = 0x823F7858;
	sub_82535080(ctx, base);
	// 823F7858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F785C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F7860: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823F7864: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 823F7868: 3BDF0048  addi r30, r31, 0x48
	ctx.r[30].s64 = ctx.r[31].s64 + 72;
	// 823F786C: 48315921  bl 0x8270d18c
	ctx.lr = 0x823F7870;
	// extern call 0x8270D18C  crate::xboxkrnl::XMsgCancelIORequest
	crate::xboxkrnl::XMsgCancelIORequest(ctx, base);
	// 823F7870: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F7874: 48000074  b 0x823f78e8
	pc = 0x823F78E8; continue 'dispatch;
            }
            0x823F7878 => {
    //   block [0x823F7878..0x823F7880)
	// 823F7878: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F787C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	pc = 0x823F7880; continue 'dispatch;
            }
            0x823F7880 => {
    //   block [0x823F7880..0x823F78A4)
	// 823F7880: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 823F7884: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F7888: 7D20F028  lwarx r9, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 823F788C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823F7890: 409A0014  bne cr6, 0x823f78a4
	if !ctx.cr[6].eq {
	pc = 0x823F78A4; continue 'dispatch;
	}
	// 823F7894: 7D40F12D  stwcx. r10, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F7898: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F789C: 4082FFE4  bne 0x823f7880
	if !ctx.cr[0].eq {
	pc = 0x823F7880; continue 'dispatch;
	}
	// 823F78A0: 4800000C  b 0x823f78ac
	pc = 0x823F78AC; continue 'dispatch;
            }
            0x823F78A4 => {
    //   block [0x823F78A4..0x823F78AC)
	// 823F78A4: 7D20F12D  stwcx. r9, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F78A8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	pc = 0x823F78AC; continue 'dispatch;
            }
            0x823F78AC => {
    //   block [0x823F78AC..0x823F78BC)
	// 823F78AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823F78B0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 823F78B4: 419A0044  beq cr6, 0x823f78f8
	if ctx.cr[6].eq {
	pc = 0x823F78F8; continue 'dispatch;
	}
	// 823F78B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x823F78BC; continue 'dispatch;
            }
            0x823F78BC => {
    //   block [0x823F78BC..0x823F78E0)
	// 823F78BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F78C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F78C4: 7D40F028  lwarx r10, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823F78C8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823F78CC: 409A0014  bne cr6, 0x823f78e0
	if !ctx.cr[6].eq {
	pc = 0x823F78E0; continue 'dispatch;
	}
	// 823F78D0: 7FA0F12D  stwcx. r29, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[29].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F78D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F78D8: 4082FFE4  bne 0x823f78bc
	if !ctx.cr[0].eq {
	pc = 0x823F78BC; continue 'dispatch;
	}
	// 823F78DC: 4800000C  b 0x823f78e8
	pc = 0x823F78E8; continue 'dispatch;
            }
            0x823F78E0 => {
    //   block [0x823F78E0..0x823F78E8)
	// 823F78E0: 7D40F12D  stwcx. r10, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F78E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	pc = 0x823F78E8; continue 'dispatch;
            }
            0x823F78E8 => {
    //   block [0x823F78E8..0x823F78F8)
	// 823F78E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F78EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F78F0: 409AFF88  bne cr6, 0x823f7878
	if !ctx.cr[6].eq {
	pc = 0x823F7878; continue 'dispatch;
	}
	// 823F78F4: 48000010  b 0x823f7904
	pc = 0x823F7904; continue 'dispatch;
            }
            0x823F78F8 => {
    //   block [0x823F78F8..0x823F7904)
	// 823F78F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F78FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F7900: 409AFFF8  bne cr6, 0x823f78f8
	if !ctx.cr[6].eq {
	pc = 0x823F78F8; continue 'dispatch;
	}
	pc = 0x823F7904; continue 'dispatch;
            }
            0x823F7904 => {
    //   block [0x823F7904..0x823F7918)
	// 823F7904: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7908: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F790C: 4182000C  beq 0x823f7918
	if ctx.cr[0].eq {
	pc = 0x823F7918; continue 'dispatch;
	}
	// 823F7910: 4831630D  bl 0x8270dc1c
	ctx.lr = 0x823F7914;
	// extern call 0x8270DC1C  crate::xam::XamVoiceClose
	crate::xam::XamVoiceClose(ctx, base);
	// 823F7914: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x823F7918; continue 'dispatch;
            }
            0x823F7918 => {
    //   block [0x823F7918..0x823F7938)
	// 823F7918: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F791C: 48002CFD  bl 0x823fa618
	ctx.lr = 0x823F7920;
	sub_823FA618(ctx, base);
	// 823F7920: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F7924: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7928: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F792C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F7930: 40990030  ble cr6, 0x823f7960
	if !ctx.cr[6].gt {
	pc = 0x823F7960; continue 'dispatch;
	}
	// 823F7934: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x823F7938; continue 'dispatch;
            }
            0x823F7938 => {
    //   block [0x823F7938..0x823F7960)
	// 823F7938: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F793C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7940: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7944: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F7948: 4E800421  bctrl
	ctx.lr = 0x823F794C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F794C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7950: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F7954: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F7958: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F795C: 4198FFDC  blt cr6, 0x823f7938
	if ctx.cr[6].lt {
	pc = 0x823F7938; continue 'dispatch;
	}
            }
            0x823F7960 => {
    //   block [0x823F7960..0x823F7968)
	// 823F7960: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F7964: 4813D7A8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7968 size=116
    let mut pc: u32 = 0x823F7968;
    'dispatch: loop {
        match pc {
            0x823F7968 => {
    //   block [0x823F7968..0x823F7994)
	// 823F7968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F796C: 4813D749  bl 0x825350b4
	ctx.lr = 0x823F7970;
	sub_82535080(ctx, base);
	// 823F7970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7974: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F7978: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F797C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823F7980: 639C0057  ori r28, r28, 0x57
	ctx.r[28].u64 = ctx.r[28].u64 | 87;
	// 823F7984: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F7988: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F798C: 419A0044  beq cr6, 0x823f79d0
	if ctx.cr[6].eq {
	pc = 0x823F79D0; continue 'dispatch;
	}
	// 823F7990: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x823F7994; continue 'dispatch;
            }
            0x823F7994 => {
    //   block [0x823F7994..0x823F79D0)
	// 823F7994: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F7998: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F799C: 4BFFF83D  bl 0x823f71d8
	ctx.lr = 0x823F79A0;
	sub_823F71D8(ctx, base);
	// 823F79A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F79A4: 4182002C  beq 0x823f79d0
	if ctx.cr[0].eq {
	pc = 0x823F79D0; continue 'dispatch;
	}
	// 823F79A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F79AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F79B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F79B4: 4E800421  bctrl
	ctx.lr = 0x823F79B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F79B8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F79BC: 41800014  blt 0x823f79d0
	if ctx.cr[0].lt {
	pc = 0x823F79D0; continue 'dispatch;
	}
	// 823F79C0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F79C4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F79C8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F79CC: 4198FFC8  blt cr6, 0x823f7994
	if ctx.cr[6].lt {
	pc = 0x823F7994; continue 'dispatch;
	}
            }
            0x823F79D0 => {
    //   block [0x823F79D0..0x823F79DC)
	// 823F79D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F79D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F79D8: 4813D72C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F79E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F79E0 size=116
    let mut pc: u32 = 0x823F79E0;
    'dispatch: loop {
        match pc {
            0x823F79E0 => {
    //   block [0x823F79E0..0x823F7A0C)
	// 823F79E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F79E4: 4813D6D1  bl 0x825350b4
	ctx.lr = 0x823F79E8;
	sub_82535080(ctx, base);
	// 823F79E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F79EC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F79F0: 3F808007  lis r28, -0x7ff9
	ctx.r[28].s64 = -2147024896;
	// 823F79F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823F79F8: 639C0057  ori r28, r28, 0x57
	ctx.r[28].u64 = ctx.r[28].u64 | 87;
	// 823F79FC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F7A00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F7A04: 419A0044  beq cr6, 0x823f7a48
	if ctx.cr[6].eq {
	pc = 0x823F7A48; continue 'dispatch;
	}
	// 823F7A08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x823F7A0C; continue 'dispatch;
            }
            0x823F7A0C => {
    //   block [0x823F7A0C..0x823F7A48)
	// 823F7A0C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F7A10: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7A14: 4BFFF7C5  bl 0x823f71d8
	ctx.lr = 0x823F7A18;
	sub_823F71D8(ctx, base);
	// 823F7A18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7A1C: 4182002C  beq 0x823f7a48
	if ctx.cr[0].eq {
	pc = 0x823F7A48; continue 'dispatch;
	}
	// 823F7A20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7A24: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7A28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F7A2C: 4E800421  bctrl
	ctx.lr = 0x823F7A30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F7A30: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823F7A34: 41800014  blt 0x823f7a48
	if ctx.cr[0].lt {
	pc = 0x823F7A48; continue 'dispatch;
	}
	// 823F7A38: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F7A3C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F7A40: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 823F7A44: 4198FFC8  blt cr6, 0x823f7a0c
	if ctx.cr[6].lt {
	pc = 0x823F7A0C; continue 'dispatch;
	}
            }
            0x823F7A48 => {
    //   block [0x823F7A48..0x823F7A54)
	// 823F7A48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823F7A4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F7A50: 4813D6B4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7A58 size=780
    let mut pc: u32 = 0x823F7A58;
    'dispatch: loop {
        match pc {
            0x823F7A58 => {
    //   block [0x823F7A58..0x823F7A7C)
	// 823F7A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7A5C: 4813D649  bl 0x825350a4
	ctx.lr = 0x823F7A60;
	sub_82535080(ctx, base);
	// 823F7A60: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7A64: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823F7A68: 4BFFF7E9  bl 0x823f7250
	ctx.lr = 0x823F7A6C;
	sub_823F7250(ctx, base);
	// 823F7A6C: 83F9004C  lwz r31, 0x4c(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(76 as u32) ) } as u64;
	// 823F7A70: 3B19004C  addi r24, r25, 0x4c
	ctx.r[24].s64 = ctx.r[25].s64 + 76;
	// 823F7A74: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823F7A78: 480000A8  b 0x823f7b20
	pc = 0x823F7B20; continue 'dispatch;
            }
            0x823F7A7C => {
    //   block [0x823F7A7C..0x823F7AA8)
	// 823F7A7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7A80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7A84: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823F7A88: 419A00A0  beq cr6, 0x823f7b28
	if ctx.cr[6].eq {
	pc = 0x823F7B28; continue 'dispatch;
	}
	// 823F7A8C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7A90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7A94: 41820020  beq 0x823f7ab4
	if ctx.cr[0].eq {
	pc = 0x823F7AB4; continue 'dispatch;
	}
	// 823F7A98: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7A9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F7AA0: 409A0008  bne cr6, 0x823f7aa8
	if !ctx.cr[6].eq {
	pc = 0x823F7AA8; continue 'dispatch;
	}
	// 823F7AA4: 93580004  stw r26, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7AA8; continue 'dispatch;
            }
            0x823F7AA8 => {
    //   block [0x823F7AA8..0x823F7AB4)
	// 823F7AA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7AAC: 91580000  stw r10, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F7AB0: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7AB4; continue 'dispatch;
            }
            0x823F7AB4 => {
    //   block [0x823F7AB4..0x823F7AD8)
	// 823F7AB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7AB8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F7ABC: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 823F7AC0: 409A0018  bne cr6, 0x823f7ad8
	if !ctx.cr[6].eq {
	pc = 0x823F7AD8; continue 'dispatch;
	}
	// 823F7AC4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7AC8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F7ACC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 823F7AD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7AD4: 934B0014  stw r26, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7AD8; continue 'dispatch;
            }
            0x823F7AD8 => {
    //   block [0x823F7AD8..0x823F7B0C)
	// 823F7AD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7ADC: 3BD90044  addi r30, r25, 0x44
	ctx.r[30].s64 = ctx.r[25].s64 + 68;
	// 823F7AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F7AE4: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 823F7AE8: 48315B95  bl 0x8270d67c
	ctx.lr = 0x823F7AEC;
	// extern call 0x8270D67C  crate::xboxkrnl::KfAcquireSpinLock
	crate::xboxkrnl::KfAcquireSpinLock(ctx, base);
	// 823F7AEC: 39790034  addi r11, r25, 0x34
	ctx.r[11].s64 = ctx.r[25].s64 + 52;
	// 823F7AF0: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 823F7AF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 823F7AF8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7AFC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7B00: 4182000C  beq 0x823f7b0c
	if ctx.cr[0].eq {
	pc = 0x823F7B0C; continue 'dispatch;
	}
	// 823F7B04: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F7B08: 48000008  b 0x823f7b10
	pc = 0x823F7B10; continue 'dispatch;
            }
            0x823F7B0C => {
    //   block [0x823F7B0C..0x823F7B10)
	// 823F7B0C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823F7B10; continue 'dispatch;
            }
            0x823F7B10 => {
    //   block [0x823F7B10..0x823F7B20)
	// 823F7B10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F7B14: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823F7B18: 48315B55  bl 0x8270d66c
	ctx.lr = 0x823F7B1C;
	// extern call 0x8270D66C  crate::xboxkrnl::KfReleaseSpinLock
	crate::xboxkrnl::KfReleaseSpinLock(ctx, base);
	// 823F7B1C: 83F80000  lwz r31, 0(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823F7B20; continue 'dispatch;
            }
            0x823F7B20 => {
    //   block [0x823F7B20..0x823F7B28)
	// 823F7B20: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7B24: 4082FF58  bne 0x823f7a7c
	if !ctx.cr[0].eq {
	pc = 0x823F7A7C; continue 'dispatch;
	}
	pc = 0x823F7B28; continue 'dispatch;
            }
            0x823F7B28 => {
    //   block [0x823F7B28..0x823F7B34)
	// 823F7B28: 8379003C  lwz r27, 0x3c(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(60 as u32) ) } as u64;
	// 823F7B2C: 3AF9003C  addi r23, r25, 0x3c
	ctx.r[23].s64 = ctx.r[25].s64 + 60;
	// 823F7B30: 480001B8  b 0x823f7ce8
	pc = 0x823F7CE8; continue 'dispatch;
            }
            0x823F7B34 => {
    //   block [0x823F7B34..0x823F7B78)
	// 823F7B34: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7B38: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7B3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7B40: 7D6B5051  subf. r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F7B44: 408201C8  bne 0x823f7d0c
	if !ctx.cr[0].eq {
	pc = 0x823F7D0C; continue 'dispatch;
	}
	// 823F7B48: 3BF90044  addi r31, r25, 0x44
	ctx.r[31].s64 = ctx.r[25].s64 + 68;
	// 823F7B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F7B50: 48315B2D  bl 0x8270d67c
	ctx.lr = 0x823F7B54;
	// extern call 0x8270D67C  crate::xboxkrnl::KfAcquireSpinLock
	crate::xboxkrnl::KfAcquireSpinLock(ctx, base);
	// 823F7B54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823F7B58: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823F7B5C: 4BFFE505  bl 0x823f6060
	ctx.lr = 0x823F7B60;
	sub_823F6060(ctx, base);
	// 823F7B60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7B64: 40820014  bne 0x823f7b78
	if !ctx.cr[0].eq {
	pc = 0x823F7B78; continue 'dispatch;
	}
	// 823F7B68: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 823F7B6C: 4BFFE4F5  bl 0x823f6060
	ctx.lr = 0x823F7B70;
	sub_823F6060(ctx, base);
	// 823F7B70: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 823F7B74: 40990180  ble cr6, 0x823f7cf4
	if !ctx.cr[6].gt {
	pc = 0x823F7CF4; continue 'dispatch;
	}
	pc = 0x823F7B78; continue 'dispatch;
            }
            0x823F7B78 => {
    //   block [0x823F7B78..0x823F7B94)
	// 823F7B78: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7B7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7B80: 41820020  beq 0x823f7ba0
	if ctx.cr[0].eq {
	pc = 0x823F7BA0; continue 'dispatch;
	}
	// 823F7B84: 81570004  lwz r10, 4(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7B88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F7B8C: 409A0008  bne cr6, 0x823f7b94
	if !ctx.cr[6].eq {
	pc = 0x823F7B94; continue 'dispatch;
	}
	// 823F7B90: 93570004  stw r26, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7B94; continue 'dispatch;
            }
            0x823F7B94 => {
    //   block [0x823F7B94..0x823F7BA0)
	// 823F7B94: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7B98: 91570000  stw r10, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F7B9C: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7BA0; continue 'dispatch;
            }
            0x823F7BA0 => {
    //   block [0x823F7BA0..0x823F7BC4)
	// 823F7BA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F7BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F7BA8: 48315AC5  bl 0x8270d66c
	ctx.lr = 0x823F7BAC;
	// extern call 0x8270D66C  crate::xboxkrnl::KfReleaseSpinLock
	crate::xboxkrnl::KfReleaseSpinLock(ctx, base);
	// 823F7BAC: 935B0004  stw r26, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 823F7BB0: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7BB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7BB8: 4182000C  beq 0x823f7bc4
	if ctx.cr[0].eq {
	pc = 0x823F7BC4; continue 'dispatch;
	}
	// 823F7BBC: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823F7BC0: 48000008  b 0x823f7bc8
	pc = 0x823F7BC8; continue 'dispatch;
            }
            0x823F7BC4 => {
    //   block [0x823F7BC4..0x823F7BC8)
	// 823F7BC4: 93780000  stw r27, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x823F7BC8; continue 'dispatch;
            }
            0x823F7BC8 => {
    //   block [0x823F7BC8..0x823F7BF4)
	// 823F7BC8: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823F7BCC: 3B990054  addi r28, r25, 0x54
	ctx.r[28].s64 = ctx.r[25].s64 + 84;
	// 823F7BD0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7BD4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7BD8: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7BDC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 823F7BE0: 554BF87F  rlwinm. r11, r10, 0x1f, 1, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F7BE4: 408100CC  ble 0x823f7cb0
	if !ctx.cr[0].gt {
	pc = 0x823F7CB0; continue 'dispatch;
	}
	// 823F7BE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F7BEC: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F7BF0: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	pc = 0x823F7BF4; continue 'dispatch;
            }
            0x823F7BF4 => {
    //   block [0x823F7BF4..0x823F7CB0)
	// 823F7BF4: A97F0000  lha r11, 0(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823F7BF8: 3980E138  li r12, -0x1ec8
	ctx.r[12].s64 = -7880;
	// 823F7BFC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823F7C00: B3410052  sth r26, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[26].u16 ) };
	// 823F7C04: 394BE138  addi r10, r11, -0x1ec8
	ctx.r[10].s64 = ctx.r[11].s64 + -7880;
	// 823F7C08: B3410050  sth r26, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u16 ) };
	// 823F7C0C: 38A10052  addi r5, r1, 0x52
	ctx.r[5].s64 = ctx.r[1].s64 + 82;
	// 823F7C10: 7D4A8670  srawi r10, r10, 0x10
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 16) as i64;
	// 823F7C14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F7C18: 7D4950F8  nor r9, r10, r10
	ctx.r[9].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 823F7C1C: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 823F7C20: 71291EC8  andi. r9, r9, 0x1ec8
	ctx.r[9].u64 = ctx.r[9].u64 & 7880;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F7C24: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 823F7C28: 394B1EC8  addi r10, r11, 0x1ec8
	ctx.r[10].s64 = ctx.r[11].s64 + 7880;
	// 823F7C2C: 7D4A8670  srawi r10, r10, 0x10
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 16) as i64;
	// 823F7C30: 7D496038  and r9, r10, r12
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 823F7C34: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823F7C38: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 823F7C3C: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 823F7C40: 48001351  bl 0x823f8f90
	ctx.lr = 0x823F7C44;
	sub_823F8F90(ctx, base);
	// 823F7C44: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 823F7C48: 3980E138  li r12, -0x1ec8
	ctx.r[12].s64 = -7880;
	// 823F7C4C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823F7C50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F7C54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F7C58: A97F0000  lha r11, 0(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823F7C5C: 394BE138  addi r10, r11, -0x1ec8
	ctx.r[10].s64 = ctx.r[11].s64 + -7880;
	// 823F7C60: 7D4A8670  srawi r10, r10, 0x10
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 16) as i64;
	// 823F7C64: 7D4950F8  nor r9, r10, r10
	ctx.r[9].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 823F7C68: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 823F7C6C: 712A1EC8  andi. r10, r9, 0x1ec8
	ctx.r[10].u64 = ctx.r[9].u64 & 7880;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F7C70: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823F7C74: 394B1EC8  addi r10, r11, 0x1ec8
	ctx.r[10].s64 = ctx.r[11].s64 + 7880;
	// 823F7C78: 7D4A8670  srawi r10, r10, 0x10
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 16) as i64;
	// 823F7C7C: 7D496038  and r9, r10, r12
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 823F7C80: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823F7C84: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 823F7C88: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 823F7C8C: 48001305  bl 0x823f8f90
	ctx.lr = 0x823F7C90;
	sub_823F8F90(ctx, base);
	// 823F7C90: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F7C94: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 823F7C98: A9610050  lha r11, 0x50(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as i16) as i64;
	// 823F7C9C: A9410052  lha r10, 0x52(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as i16) as i64;
	// 823F7CA0: 516A2036  rlwimi r10, r11, 4, 0, 0x1b
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(4) as u64) & 0x00000000FFFFFFF0) | (ctx.r[10].u64 & 0xFFFFFFFF0000000F);
	// 823F7CA4: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823F7CA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F7CAC: 4082FF48  bne 0x823f7bf4
	if !ctx.cr[0].eq {
	pc = 0x823F7BF4; continue 'dispatch;
	}
	pc = 0x823F7CB0; continue 'dispatch;
            }
            0x823F7CB0 => {
    //   block [0x823F7CB0..0x823F7CE8)
	// 823F7CB0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7CB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F7CB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F7CBC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7CC0: 5529F0BE  srwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F7CC4: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 823F7CC8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7CCC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 823F7CD0: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7CD4: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7CD8: 48315F55  bl 0x8270dc2c
	ctx.lr = 0x823F7CDC;
	// extern call 0x8270DC2C  crate::xam::XamVoiceSubmitPacket
	crate::xam::XamVoiceSubmitPacket(ctx, base);
	// 823F7CDC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823F7CE0: 41800024  blt 0x823f7d04
	if ctx.cr[0].lt {
	pc = 0x823F7D04; continue 'dispatch;
	}
	// 823F7CE4: 83770000  lwz r27, 0(r23)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823F7CE8; continue 'dispatch;
            }
            0x823F7CE8 => {
    //   block [0x823F7CE8..0x823F7CF4)
	// 823F7CE8: 281B0000  cmplwi r27, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7CEC: 4082FE48  bne 0x823f7b34
	if !ctx.cr[0].eq {
	pc = 0x823F7B34; continue 'dispatch;
	}
	// 823F7CF0: 4800001C  b 0x823f7d0c
	pc = 0x823F7D0C; continue 'dispatch;
            }
            0x823F7CF4 => {
    //   block [0x823F7CF4..0x823F7D04)
	// 823F7CF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F7CF8: 38790044  addi r3, r25, 0x44
	ctx.r[3].s64 = ctx.r[25].s64 + 68;
	// 823F7CFC: 48315971  bl 0x8270d66c
	ctx.lr = 0x823F7D00;
	// extern call 0x8270D66C  crate::xboxkrnl::KfReleaseSpinLock
	crate::xboxkrnl::KfReleaseSpinLock(ctx, base);
	// 823F7D00: 4800000C  b 0x823f7d0c
	pc = 0x823F7D0C; continue 'dispatch;
            }
            0x823F7D04 => {
    //   block [0x823F7D04..0x823F7D0C)
	// 823F7D04: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7D08: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x823F7D0C; continue 'dispatch;
            }
            0x823F7D0C => {
    //   block [0x823F7D0C..0x823F7D30)
	// 823F7D0C: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7D10: 480029C9  bl 0x823fa6d8
	ctx.lr = 0x823F7D14;
	sub_823FA6D8(ctx, base);
	// 823F7D14: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F7D18: 41800040  blt 0x823f7d58
	if ctx.cr[0].lt {
	pc = 0x823F7D58; continue 'dispatch;
	}
	// 823F7D1C: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7D20: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 823F7D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7D28: 40990030  ble cr6, 0x823f7d58
	if !ctx.cr[6].gt {
	pc = 0x823F7D58; continue 'dispatch;
	}
	// 823F7D2C: 3BF9000C  addi r31, r25, 0xc
	ctx.r[31].s64 = ctx.r[25].s64 + 12;
	pc = 0x823F7D30; continue 'dispatch;
            }
            0x823F7D30 => {
    //   block [0x823F7D30..0x823F7D58)
	// 823F7D30: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7D34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7D38: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F7D3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F7D40: 4E800421  bctrl
	ctx.lr = 0x823F7D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F7D44: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7D48: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F7D4C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F7D50: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7D54: 4198FFDC  blt cr6, 0x823f7d30
	if ctx.cr[6].lt {
	pc = 0x823F7D30; continue 'dispatch;
	}
            }
            0x823F7D58 => {
    //   block [0x823F7D58..0x823F7D64)
	// 823F7D58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F7D5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823F7D60: 4813D394  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7D68 size=88
    let mut pc: u32 = 0x823F7D68;
    'dispatch: loop {
        match pc {
            0x823F7D68 => {
    //   block [0x823F7D68..0x823F7DB4)
	// 823F7D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7D6C: 4813D34D  bl 0x825350b8
	ctx.lr = 0x823F7D70;
	sub_82535080(ctx, base);
	// 823F7D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7D74: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 823F7D78: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823F7D7C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823F7D80: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823F7D84: 63FF0057  ori r31, r31, 0x57
	ctx.r[31].u64 = ctx.r[31].u64 | 87;
	// 823F7D88: 4BFFF451  bl 0x823f71d8
	ctx.lr = 0x823F7D8C;
	sub_823F71D8(ctx, base);
	// 823F7D8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7D90: 41820024  beq 0x823f7db4
	if ctx.cr[0].eq {
	pc = 0x823F7DB4; continue 'dispatch;
	}
	// 823F7D94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7D98: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 823F7D9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823F7DA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F7DA4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823F7DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F7DAC: 4E800421  bctrl
	ctx.lr = 0x823F7DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F7DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            0x823F7DB4 => {
    //   block [0x823F7DB4..0x823F7DC0)
	// 823F7DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F7DB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F7DBC: 4813D34C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7DC0 size=172
    let mut pc: u32 = 0x823F7DC0;
    'dispatch: loop {
        match pc {
            0x823F7DC0 => {
    //   block [0x823F7DC0..0x823F7DF8)
	// 823F7DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7DC4: 4813D2F1  bl 0x825350b4
	ctx.lr = 0x823F7DC8;
	sub_82535080(ctx, base);
	// 823F7DC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7DCC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823F7DD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F7DD4: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823F7DD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F7DDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F7DE0: 4BFC9781  bl 0x823c1560
	ctx.lr = 0x823F7DE4;
	sub_823C1560(ctx, base);
	// 823F7DE4: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F7DE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F7DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7DF0: 40990064  ble cr6, 0x823f7e54
	if !ctx.cr[6].gt {
	pc = 0x823F7E54; continue 'dispatch;
	}
	// 823F7DF4: 3BFC0024  addi r31, r28, 0x24
	ctx.r[31].s64 = ctx.r[28].s64 + 36;
	pc = 0x823F7DF8; continue 'dispatch;
            }
            0x823F7DF8 => {
    //   block [0x823F7DF8..0x823F7E0C)
	// 823F7DF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7DFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F7E00: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F7E04: 83AA000C  lwz r29, 0xc(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F7E08: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	pc = 0x823F7E0C; continue 'dispatch;
            }
            0x823F7E0C => {
    //   block [0x823F7E0C..0x823F7E24)
	// 823F7E0C: 810AFFF8  lwz r8, -8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F7E10: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F7E14: 419A0010  beq cr6, 0x823f7e24
	if ctx.cr[6].eq {
	pc = 0x823F7E24; continue 'dispatch;
	}
	// 823F7E18: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7E1C: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 823F7E20: 419A003C  beq cr6, 0x823f7e5c
	if ctx.cr[6].eq {
	pc = 0x823F7E5C; continue 'dispatch;
	}
	pc = 0x823F7E24; continue 'dispatch;
            }
            0x823F7E24 => {
    //   block [0x823F7E24..0x823F7E38)
	// 823F7E24: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823F7E28: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F7E2C: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 823F7E30: 4198FFDC  blt cr6, 0x823f7e0c
	if ctx.cr[6].lt {
	pc = 0x823F7E0C; continue 'dispatch;
	}
	// 823F7E34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823F7E38; continue 'dispatch;
            }
            0x823F7E38 => {
    //   block [0x823F7E38..0x823F7E54)
	// 823F7E38: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F7E3C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823F7E40: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F7E44: 7C6BD92E  stwx r3, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[3].u32) };
	// 823F7E48: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F7E4C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7E50: 4198FFA8  blt cr6, 0x823f7df8
	if ctx.cr[6].lt {
	pc = 0x823F7DF8; continue 'dispatch;
	}
	pc = 0x823F7E54; continue 'dispatch;
            }
            0x823F7E54 => {
    //   block [0x823F7E54..0x823F7E5C)
	// 823F7E54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F7E58: 4813D2AC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x823F7E5C => {
    //   block [0x823F7E5C..0x823F7E6C)
	// 823F7E5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7E60: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 823F7E64: 4BFFE1FD  bl 0x823f6060
	ctx.lr = 0x823F7E68;
	sub_823F6060(ctx, base);
	// 823F7E68: 4BFFFFD0  b 0x823f7e38
	pc = 0x823F7E38; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7E70 size=248
    let mut pc: u32 = 0x823F7E70;
    'dispatch: loop {
        match pc {
            0x823F7E70 => {
    //   block [0x823F7E70..0x823F7EA0)
	// 823F7E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7E74: 4813D245  bl 0x825350b8
	ctx.lr = 0x823F7E78;
	sub_82535080(ctx, base);
	// 823F7E78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7E7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F7E80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F7E84: 419A00DC  beq cr6, 0x823f7f60
	if ctx.cr[6].eq {
	pc = 0x823F7F60; continue 'dispatch;
	}
	// 823F7E88: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F7E8C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823F7E90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7E94: 4182000C  beq 0x823f7ea0
	if ctx.cr[0].eq {
	pc = 0x823F7EA0; continue 'dispatch;
	}
	// 823F7E98: 48315D85  bl 0x8270dc1c
	ctx.lr = 0x823F7E9C;
	// extern call 0x8270DC1C  crate::xam::XamVoiceClose
	crate::xam::XamVoiceClose(ctx, base);
	// 823F7E9C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x823F7EA0; continue 'dispatch;
            }
            0x823F7EA0 => {
    //   block [0x823F7EA0..0x823F7EC0)
	// 823F7EA0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7EA4: 48002D6D  bl 0x823fac10
	ctx.lr = 0x823F7EA8;
	sub_823FAC10(ctx, base);
	// 823F7EA8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F7EAC: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823F7EB0: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 823F7EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7EB8: 40990028  ble cr6, 0x823f7ee0
	if !ctx.cr[6].gt {
	pc = 0x823F7EE0; continue 'dispatch;
	}
	// 823F7EBC: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	pc = 0x823F7EC0; continue 'dispatch;
            }
            0x823F7EC0 => {
    //   block [0x823F7EC0..0x823F7EE0)
	// 823F7EC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7EC4: 4BFFCA95  bl 0x823f4958
	ctx.lr = 0x823F7EC8;
	sub_823F4958(ctx, base);
	// 823F7EC8: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F7ECC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F7ED0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F7ED4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F7ED8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7EDC: 4198FFE4  blt cr6, 0x823f7ec0
	if ctx.cr[6].lt {
	pc = 0x823F7EC0; continue 'dispatch;
	}
	pc = 0x823F7EE0; continue 'dispatch;
            }
            0x823F7EE0 => {
    //   block [0x823F7EE0..0x823F7EF4)
	// 823F7EE0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7EE4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 823F7EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F7EEC: 40990034  ble cr6, 0x823f7f20
	if !ctx.cr[6].gt {
	pc = 0x823F7F20; continue 'dispatch;
	}
	// 823F7EF0: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x823F7EF4; continue 'dispatch;
            }
            0x823F7EF4 => {
    //   block [0x823F7EF4..0x823F7F20)
	// 823F7EF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7EF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7EFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7F00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F7F04: 4E800421  bctrl
	ctx.lr = 0x823F7F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F7F08: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823F7F0C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F7F10: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F7F14: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823F7F18: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F7F1C: 4198FFD8  blt cr6, 0x823f7ef4
	if ctx.cr[6].lt {
	pc = 0x823F7EF4; continue 'dispatch;
	}
            }
            0x823F7F20 => {
    //   block [0x823F7F20..0x823F7F50)
	// 823F7F20: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 823F7F24: 4BFFE2DD  bl 0x823f6200
	ctx.lr = 0x823F7F28;
	sub_823F6200(ctx, base);
	// 823F7F28: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823F7F2C: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 823F7F30: 4831525D  bl 0x8270d18c
	ctx.lr = 0x823F7F34;
	// extern call 0x8270D18C  crate::xboxkrnl::XMsgCancelIORequest
	crate::xboxkrnl::XMsgCancelIORequest(ctx, base);
	// 823F7F34: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 823F7F38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F7F3C: 41820014  beq 0x823f7f50
	if ctx.cr[0].eq {
	pc = 0x823F7F50; continue 'dispatch;
	}
	// 823F7F40: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823F7F44: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823F7F48: 4BFD2311  bl 0x823ca258
	ctx.lr = 0x823F7F4C;
	sub_823CA258(ctx, base);
	// 823F7F4C: 939F00B0  stw r28, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[28].u32 ) };
	pc = 0x823F7F50; continue 'dispatch;
            }
            0x823F7F50 => {
    //   block [0x823F7F50..0x823F7F60)
	// 823F7F50: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F7F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F7F58: 6084800B  ori r4, r4, 0x800b
	ctx.r[4].u64 = ctx.r[4].u64 | 32779;
	// 823F7F5C: 4BFD22FD  bl 0x823ca258
	ctx.lr = 0x823F7F60;
	sub_823CA258(ctx, base);
	pc = 0x823F7F60; continue 'dispatch;
            }
            0x823F7F60 => {
    //   block [0x823F7F60..0x823F7F68)
	// 823F7F60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F7F64: 4813D1A4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F7F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F7F68 size=180
    let mut pc: u32 = 0x823F7F68;
    'dispatch: loop {
        match pc {
            0x823F7F68 => {
    //   block [0x823F7F68..0x823F7FC4)
	// 823F7F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F7F6C: 4813D14D  bl 0x825350b8
	ctx.lr = 0x823F7F70;
	sub_82535080(ctx, base);
	// 823F7F70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F7F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F7F78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F7F7C: 4BFFF8D5  bl 0x823f7850
	ctx.lr = 0x823F7F80;
	sub_823F7850(ctx, base);
	// 823F7F80: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 823F7F84: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 823F7F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F7F8C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F7F90: 48315CAD  bl 0x8270dc3c
	ctx.lr = 0x823F7F94;
	// extern call 0x8270DC3C  crate::xam::XamVoiceCreate
	crate::xam::XamVoiceCreate(ctx, base);
	// 823F7F94: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F7F98: 41800060  blt 0x823f7ff8
	if ctx.cr[0].lt {
	pc = 0x823F7FF8; continue 'dispatch;
	}
	// 823F7F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F7FA0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F7FA4: 48002D6D  bl 0x823fad10
	ctx.lr = 0x823F7FA8;
	sub_823FAD10(ctx, base);
	// 823F7FA8: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823F7FAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F7FB0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823F7FB4: 616B6404  ori r11, r11, 0x6404
	ctx.r[11].u64 = ctx.r[11].u64 | 25604;
	// 823F7FB8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 823F7FBC: 38FF0048  addi r7, r31, 0x48
	ctx.r[7].s64 = ctx.r[31].s64 + 72;
	// 823F7FC0: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	pc = 0x823F7FC4; continue 'dispatch;
            }
            0x823F7FC4 => {
    //   block [0x823F7FC4..0x823F7FF8)
	// 823F7FC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 823F7FC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F7FCC: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 823F7FD0: 7D00392D  stwcx. r8, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 823F7FD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 823F7FD8: 4082FFEC  bne 0x823f7fc4
	if !ctx.cr[0].eq {
	pc = 0x823F7FC4; continue 'dispatch;
	}
	// 823F7FDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823F7FE0: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 823F7FE4: 388B72D8  addi r4, r11, 0x72d8
	ctx.r[4].s64 = ctx.r[11].s64 + 29400;
	// 823F7FE8: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 823F7FEC: 4813CB65  bl 0x82534b50
	ctx.lr = 0x823F7FF0;
	sub_82534B50(ctx, base);
	// 823F7FF0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F7FF4: 4098001C  bge cr6, 0x823f8010
	if !ctx.cr[6].lt {
	pc = 0x823F8010; continue 'dispatch;
	}
	pc = 0x823F7FF8; continue 'dispatch;
            }
            0x823F7FF8 => {
    //   block [0x823F7FF8..0x823F8010)
	// 823F7FF8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F7FFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8000: 41820010  beq 0x823f8010
	if ctx.cr[0].eq {
	pc = 0x823F8010; continue 'dispatch;
	}
	// 823F8004: 48315C19  bl 0x8270dc1c
	ctx.lr = 0x823F8008;
	// extern call 0x8270DC1C  crate::xam::XamVoiceClose
	crate::xam::XamVoiceClose(ctx, base);
	// 823F8008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F800C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F8010; continue 'dispatch;
            }
            0x823F8010 => {
    //   block [0x823F8010..0x823F801C)
	// 823F8010: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823F8014: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F8018: 4813D0F0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F8020 size=892
    let mut pc: u32 = 0x823F8020;
    'dispatch: loop {
        match pc {
            0x823F8020 => {
    //   block [0x823F8020..0x823F8058)
	// 823F8020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F8024: 4813D06D  bl 0x82535090
	ctx.lr = 0x823F8028;
	sub_82535080(ctx, base);
	// 823F8028: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F802C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823F8030: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823F8034: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 823F8038: 6084800B  ori r4, r4, 0x800b
	ctx.r[4].u64 = ctx.r[4].u64 | 32779;
	// 823F803C: 386001D0  li r3, 0x1d0
	ctx.r[3].s64 = 464;
	// 823F8040: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823F8044: 7CD23378  mr r18, r6
	ctx.r[18].u64 = ctx.r[6].u64;
	// 823F8048: 4BFD2179  bl 0x823ca1c0
	ctx.lr = 0x823F804C;
	sub_823CA1C0(ctx, base);
	// 823F804C: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 823F8050: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823F8054: 40820010  bne 0x823f8064
	if !ctx.cr[0].eq {
	pc = 0x823F8064; continue 'dispatch;
	}
	pc = 0x823F8058; continue 'dispatch;
            }
            0x823F8058 => {
    //   block [0x823F8058..0x823F8064)
	// 823F8058: 3EC08007  lis r22, -0x7ff9
	ctx.r[22].s64 = -2147024896;
	// 823F805C: 62D6000E  ori r22, r22, 0xe
	ctx.r[22].u64 = ctx.r[22].u64 | 14;
	// 823F8060: 48000320  b 0x823f8380
	pc = 0x823F8380; continue 'dispatch;
            }
            0x823F8064 => {
    //   block [0x823F8064..0x823F80E4)
	// 823F8064: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 823F8068: 929E0044  stw r20, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[20].u32 ) };
	// 823F806C: 3BFE00B4  addi r31, r30, 0xb4
	ctx.r[31].s64 = ctx.r[30].s64 + 180;
	// 823F8070: 927E0090  stw r19, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[19].u32 ) };
	// 823F8074: 616B6404  ori r11, r11, 0x6404
	ctx.r[11].u64 = ctx.r[11].u64 | 25604;
	// 823F8078: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 823F807C: 3C60FFFE  lis r3, -2
	ctx.r[3].s64 = -131072;
	// 823F8080: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F8084: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 823F8088: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F808C: 917E00C4  stw r11, 0xc4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 823F8090: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F8094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F8098: 390BD1F0  addi r8, r11, -0x2e10
	ctx.r[8].s64 = ctx.r[11].s64 + -11792;
	// 823F809C: 897E00C6  lbz r11, 0xc6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(198 as u32) ) } as u64;
	// 823F80A0: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 823F80A4: 606307D1  ori r3, r3, 0x7d1
	ctx.r[3].u64 = ctx.r[3].u64 | 2001;
	// 823F80A8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 823F80AC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 823F80B0: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 823F80B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823F80B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823F80BC: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823F80C0: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F80C4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823F80C8: D01E00B8  stfs f0, 0xb8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 823F80CC: 48315B31  bl 0x8270dbfc
	ctx.lr = 0x823F80D0;
	// extern call 0x8270DBFC  crate::xam::XamUserReadProfileSettings
	crate::xam::XamUserReadProfileSettings(ctx, base);
	// 823F80D0: 2B03007A  cmplwi cr6, r3, 0x7a
	ctx.cr[6].compare_u32(ctx.r[3].u32, 122 as u32, &mut ctx.xer);
	// 823F80D4: 419A0010  beq cr6, 0x823f80e4
	if ctx.cr[6].eq {
	pc = 0x823F80E4; continue 'dispatch;
	}
	// 823F80D8: 3EC08000  lis r22, -0x8000
	ctx.r[22].s64 = -2147483648;
	// 823F80DC: 62D64005  ori r22, r22, 0x4005
	ctx.r[22].u64 = ctx.r[22].u64 | 16389;
	// 823F80E0: 480002A0  b 0x823f8380
	pc = 0x823F8380; continue 'dispatch;
            }
            0x823F80E4 => {
    //   block [0x823F80E4..0x823F812C)
	// 823F80E4: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823F80E8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F80EC: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823F80F0: 4BFD20D1  bl 0x823ca1c0
	ctx.lr = 0x823F80F4;
	sub_823CA1C0(ctx, base);
	// 823F80F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F80F8: 907E00B0  stw r3, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 823F80FC: 4182FF5C  beq 0x823f8058
	if ctx.cr[0].eq {
	pc = 0x823F8058; continue 'dispatch;
	}
	// 823F8100: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 823F8104: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823F8108: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 823F810C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 823F8110: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 823F8114: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823F8118: 4BFFE231  bl 0x823f6348
	ctx.lr = 0x823F811C;
	sub_823F6348(ctx, base);
	// 823F811C: 7C761B79  or. r22, r3, r3
	ctx.r[22].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F8120: 41800260  blt 0x823f8380
	if ctx.cr[0].lt {
	pc = 0x823F8380; continue 'dispatch;
	}
	// 823F8124: 391E0034  addi r8, r30, 0x34
	ctx.r[8].s64 = ctx.r[30].s64 + 52;
	// 823F8128: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	pc = 0x823F812C; continue 'dispatch;
            }
            0x823F812C => {
    //   block [0x823F812C..0x823F8160)
	// 823F812C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8130: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8134: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F8138: 7D6749D6  mullw r11, r7, r9
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F813C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F8140: 396A0018  addi r11, r10, 0x18
	ctx.r[11].s64 = ctx.r[10].s64 + 24;
	// 823F8144: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823F8148: 928B0004  stw r20, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 823F814C: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F8150: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8154: 4182000C  beq 0x823f8160
	if ctx.cr[0].eq {
	pc = 0x823F8160; continue 'dispatch;
	}
	// 823F8158: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F815C: 48000008  b 0x823f8164
	pc = 0x823F8164; continue 'dispatch;
            }
            0x823F8160 => {
    //   block [0x823F8160..0x823F8164)
	// 823F8160: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823F8164; continue 'dispatch;
            }
            0x823F8164 => {
    //   block [0x823F8164..0x823F81A4)
	// 823F8164: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823F8168: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823F816C: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 823F8170: 4198FFBC  blt cr6, 0x823f812c
	if ctx.cr[6].lt {
	pc = 0x823F812C; continue 'dispatch;
	}
	// 823F8174: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 823F8178: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F817C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823F8180: 4BFC93E1  bl 0x823c1560
	ctx.lr = 0x823F8184;
	sub_823C1560(ctx, base);
	// 823F8184: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823F8188: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F818C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823F8190: 4BFC93D1  bl 0x823c1560
	ctx.lr = 0x823F8194;
	sub_823C1560(ctx, base);
	// 823F8194: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 823F8198: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F819C: 419A008C  beq cr6, 0x823f8228
	if ctx.cr[6].eq {
	pc = 0x823F8228; continue 'dispatch;
	}
	// 823F81A0: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	pc = 0x823F81A4; continue 'dispatch;
            }
            0x823F81A4 => {
    //   block [0x823F81A4..0x823F8228)
	// 823F81A4: 2B1D0002  cmplwi cr6, r29, 2
	ctx.cr[6].compare_u32(ctx.r[29].u32, 2 as u32, &mut ctx.xer);
	// 823F81A8: 40980080  bge cr6, 0x823f8228
	if !ctx.cr[6].lt {
	pc = 0x823F8228; continue 'dispatch;
	}
	// 823F81AC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F81B0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823F81B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823F81B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F81BC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 823F81C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F81C4: 4E800421  bctrl
	ctx.lr = 0x823F81C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F81C8: 7C761B79  or. r22, r3, r3
	ctx.r[22].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F81CC: 4180005C  blt 0x823f8228
	if ctx.cr[0].lt {
	pc = 0x823F8228; continue 'dispatch;
	}
	// 823F81D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F81D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823F81D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F81DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F81E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F81E4: 4E800421  bctrl
	ctx.lr = 0x823F81E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F81E8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823F81EC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 823F81F0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 823F81F4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823F81F8: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F81FC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F8200: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F8204: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 823F8208: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 823F820C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F8210: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 823F8214: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 823F8218: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F821C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F8220: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 823F8224: 4198FF80  blt cr6, 0x823f81a4
	if ctx.cr[6].lt {
	pc = 0x823F81A4; continue 'dispatch;
	}
            }
            0x823F8228 => {
    //   block [0x823F8228..0x823F824C)
	// 823F8228: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 823F822C: 93BE0020  stw r29, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 823F8230: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F8234: 4198014C  blt cr6, 0x823f8380
	if ctx.cr[6].lt {
	pc = 0x823F8380; continue 'dispatch;
	}
	// 823F8238: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 823F823C: 7E95A378  mr r21, r20
	ctx.r[21].u64 = ctx.r[20].u64;
	// 823F8240: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 823F8244: 3AE10070  addi r23, r1, 0x70
	ctx.r[23].s64 = ctx.r[1].s64 + 112;
	// 823F8248: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	pc = 0x823F824C; continue 'dispatch;
            }
            0x823F824C => {
    //   block [0x823F824C..0x823F826C)
	// 823F824C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823F8250: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F8254: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 823F8258: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 823F825C: 4BFC9305  bl 0x823c1560
	ctx.lr = 0x823F8260;
	sub_823C1560(ctx, base);
	// 823F8260: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 823F8264: 7FF8FB78  mr r24, r31
	ctx.r[24].u64 = ctx.r[31].u64;
	// 823F8268: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	pc = 0x823F826C; continue 'dispatch;
            }
            0x823F826C => {
    //   block [0x823F826C..0x823F829C)
	// 823F826C: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8270: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8274: 41820028  beq 0x823f829c
	if ctx.cr[0].eq {
	pc = 0x823F829C; continue 'dispatch;
	}
	// 823F8278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F827C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823F8280: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F8284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8288: 4E800421  bctrl
	ctx.lr = 0x823F828C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F828C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823F8290: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 823F8294: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F8298: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
            }
            0x823F829C => {
    //   block [0x823F829C..0x823F82E0)
	// 823F829C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F82A0: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 823F82A4: 4082FFC8  bne 0x823f826c
	if !ctx.cr[0].eq {
	pc = 0x823F826C; continue 'dispatch;
	}
	// 823F82A8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823F82AC: 419A0080  beq cr6, 0x823f832c
	if ctx.cr[6].eq {
	pc = 0x823F832C; continue 'dispatch;
	}
	// 823F82B0: 38FB0004  addi r7, r27, 4
	ctx.r[7].s64 = ctx.r[27].s64 + 4;
	// 823F82B4: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F82B8: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 823F82BC: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 823F82C0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 823F82C4: 4BFFC73D  bl 0x823f4a00
	ctx.lr = 0x823F82C8;
	sub_823F4A00(ctx, base);
	// 823F82C8: 7C761B79  or. r22, r3, r3
	ctx.r[22].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F82CC: 41800074  blt 0x823f8340
	if ctx.cr[0].lt {
	pc = 0x823F8340; continue 'dispatch;
	}
	// 823F82D0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 823F82D4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 823F82D8: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 823F82DC: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	pc = 0x823F82E0; continue 'dispatch;
            }
            0x823F82E0 => {
    //   block [0x823F82E0..0x823F8314)
	// 823F82E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F82E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F82E8: 4182002C  beq 0x823f8314
	if ctx.cr[0].eq {
	pc = 0x823F8314; continue 'dispatch;
	}
	// 823F82EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F82F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823F82F4: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F82F8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 823F82FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8304: 4E800421  bctrl
	ctx.lr = 0x823F8308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8308: 7C761B79  or. r22, r3, r3
	ctx.r[22].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F830C: 41800034  blt 0x823f8340
	if ctx.cr[0].lt {
	pc = 0x823F8340; continue 'dispatch;
	}
	// 823F8310: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
            }
            0x823F8314 => {
    //   block [0x823F8314..0x823F832C)
	// 823F8314: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 823F8318: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823F831C: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 823F8320: 4198FFC0  blt cr6, 0x823f82e0
	if ctx.cr[6].lt {
	pc = 0x823F82E0; continue 'dispatch;
	}
	// 823F8324: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F8328: 41980018  blt cr6, 0x823f8340
	if ctx.cr[6].lt {
	pc = 0x823F8340; continue 'dispatch;
	}
	pc = 0x823F832C; continue 'dispatch;
            }
            0x823F832C => {
    //   block [0x823F832C..0x823F8340)
	// 823F832C: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 823F8330: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 823F8334: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 823F8338: 2B150003  cmplwi cr6, r21, 3
	ctx.cr[6].compare_u32(ctx.r[21].u32, 3 as u32, &mut ctx.xer);
	// 823F833C: 4198FF10  blt cr6, 0x823f824c
	if ctx.cr[6].lt {
	pc = 0x823F824C; continue 'dispatch;
	}
	pc = 0x823F8340; continue 'dispatch;
            }
            0x823F8340 => {
    //   block [0x823F8340..0x823F8380)
	// 823F8340: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F8344: 933E002C  stw r25, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 823F8348: 41980038  blt cr6, 0x823f8380
	if ctx.cr[6].lt {
	pc = 0x823F8380; continue 'dispatch;
	}
	// 823F834C: 391E0004  addi r8, r30, 4
	ctx.r[8].s64 = ctx.r[30].s64 + 4;
	// 823F8350: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 823F8354: 38DE0024  addi r6, r30, 0x24
	ctx.r[6].s64 = ctx.r[30].s64 + 36;
	// 823F8358: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 823F835C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823F8360: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 823F8364: 48002A45  bl 0x823fada8
	ctx.lr = 0x823F8368;
	sub_823FADA8(ctx, base);
	// 823F8368: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F836C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823F8370: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F8374: 915E008C  stw r10, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 823F8378: 7C761B79  or. r22, r3, r3
	ctx.r[22].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823F837C: 40800010  bge 0x823f838c
	if !ctx.cr[0].lt {
	pc = 0x823F838C; continue 'dispatch;
	}
	pc = 0x823F8380; continue 'dispatch;
            }
            0x823F8380 => {
    //   block [0x823F8380..0x823F838C)
	// 823F8380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823F8384: 4BFFFAED  bl 0x823f7e70
	ctx.lr = 0x823F8388;
	sub_823F7E70(ctx, base);
	// 823F8388: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x823F838C; continue 'dispatch;
            }
            0x823F838C => {
    //   block [0x823F838C..0x823F839C)
	// 823F838C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 823F8390: 93D20000  stw r30, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823F8394: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823F8398: 4813CD48  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F83A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823F83A0 size=392
    let mut pc: u32 = 0x823F83A0;
    'dispatch: loop {
        match pc {
            0x823F83A0 => {
    //   block [0x823F83A0..0x823F83D0)
	// 823F83A0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 823F83A4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823F83A8: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 823F83AC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 823F83B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F83B4: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 823F83B8: 41980064  blt cr6, 0x823f841c
	if ctx.cr[6].lt {
	pc = 0x823F841C; continue 'dispatch;
	}
	// 823F83BC: 419A0024  beq cr6, 0x823f83e0
	if ctx.cr[6].eq {
	pc = 0x823F83E0; continue 'dispatch;
	}
	// 823F83C0: 2B070003  cmplwi cr6, r7, 3
	ctx.cr[6].compare_u32(ctx.r[7].u32, 3 as u32, &mut ctx.xer);
	// 823F83C4: 4198000C  blt cr6, 0x823f83d0
	if ctx.cr[6].lt {
	pc = 0x823F83D0; continue 'dispatch;
	}
	// 823F83C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F83CC: 48000150  b 0x823f851c
	pc = 0x823F851C; continue 'dispatch;
            }
            0x823F83D0 => {
    //   block [0x823F83D0..0x823F83E0)
	// 823F83D0: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F83D4: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 823F83D8: 38ABD300  addi r5, r11, -0x2d00
	ctx.r[5].s64 = ctx.r[11].s64 + -11520;
	// 823F83DC: 4800004C  b 0x823f8428
	pc = 0x823F8428; continue 'dispatch;
            }
            0x823F83E0 => {
    //   block [0x823F83E0..0x823F83F0)
	// 823F83E0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823F83E4: 419A002C  beq cr6, 0x823f8410
	if ctx.cr[6].eq {
	pc = 0x823F8410; continue 'dispatch;
	}
	// 823F83E8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 823F83EC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x823F83F0; continue 'dispatch;
            }
            0x823F83F0 => {
    //   block [0x823F83F0..0x823F8410)
	// 823F83F0: A0EA0000  lhz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F83F4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F83F8: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823F83FC: B0E90000  sth r7, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 823F8400: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 823F8404: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823F8408: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 823F840C: 4082FFE4  bne 0x823f83f0
	if !ctx.cr[0].eq {
	pc = 0x823F83F0; continue 'dispatch;
	}
	pc = 0x823F8410; continue 'dispatch;
            }
            0x823F8410 => {
    //   block [0x823F8410..0x823F841C)
	// 823F8410: 54C6083C  slwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823F8414: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 823F8418: 48000008  b 0x823f8420
	pc = 0x823F8420; continue 'dispatch;
            }
            0x823F841C => {
    //   block [0x823F841C..0x823F8420)
	// 823F841C: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	pc = 0x823F8420; continue 'dispatch;
            }
            0x823F8420 => {
    //   block [0x823F8420..0x823F8428)
	// 823F8420: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F8424: 38ABD200  addi r5, r11, -0x2e00
	ctx.r[5].s64 = ctx.r[11].s64 + -11776;
	pc = 0x823F8428; continue 'dispatch;
            }
            0x823F8428 => {
    //   block [0x823F8428..0x823F8444)
	// 823F8428: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 823F842C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 823F8430: 419A00E4  beq cr6, 0x823f8514
	if ctx.cr[6].eq {
	pc = 0x823F8514; continue 'dispatch;
	}
	// 823F8434: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823F8438: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823F843C: C98A72D0  lfd f12, 0x72d0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(29392 as u32) ) };
	// 823F8440: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	pc = 0x823F8444; continue 'dispatch;
            }
            0x823F8444 => {
    //   block [0x823F8444..0x823F8458)
	// 823F8444: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823F8448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F844C: 419A0048  beq cr6, 0x823f8494
	if ctx.cr[6].eq {
	pc = 0x823F8494; continue 'dispatch;
	}
	// 823F8450: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823F8454: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	pc = 0x823F8458; continue 'dispatch;
            }
            0x823F8458 => {
    //   block [0x823F8458..0x823F8494)
	// 823F8458: A9470000  lha r10, 0(r7)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823F845C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F8460: 81230100  lwz r9, 0x100(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) } as u64;
	// 823F8464: 38E70002  addi r7, r7, 2
	ctx.r[7].s64 = ctx.r[7].s64 + 2;
	// 823F8468: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823F846C: F941FFE8  std r10, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[10].u64 ) };
	// 823F8470: C961FFE8  lfd f11, -0x18(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F8474: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 823F8478: FD6B0332  fmul f11, f11, f12
	ctx.f[11].f64 = ctx.f[11].f64 * ctx.f[12].f64;
	// 823F847C: 7D691DAE  stfdx f11, r9, r3
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.f[11].u64) };
	// 823F8480: 81430100  lwz r10, 0x100(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) } as u64;
	// 823F8484: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F8488: 554A06FE  clrlwi r10, r10, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823F848C: 91430100  stw r10, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 823F8490: 4082FFC8  bne 0x823f8458
	if !ctx.cr[0].eq {
	pc = 0x823F8458; continue 'dispatch;
	}
	pc = 0x823F8494; continue 'dispatch;
            }
            0x823F8494 => {
    //   block [0x823F8494..0x823F84A0)
	// 823F8494: 81430100  lwz r10, 0x100(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) } as u64;
	// 823F8498: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 823F849C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	pc = 0x823F84A0; continue 'dispatch;
            }
            0x823F84A0 => {
    //   block [0x823F84A0..0x823F8514)
	// 823F84A0: 555E1E38  rlwinm r30, r10, 3, 0x18, 0x1c
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F84A4: C9690000  lfd f11, 0(r9)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 823F84A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F84AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F84B0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 823F84B4: 7D5E1CAE  lfdx f10, r30, r3
	ctx.f[10].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) };
	// 823F84B8: FC0A02FA  fmadd f0, f10, f11, f0
	ctx.f[0].f64 = ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64;
	// 823F84BC: 4082FFE4  bne 0x823f84a0
	if !ctx.cr[0].eq {
	pc = 0x823F84A0; continue 'dispatch;
	}
	// 823F84C0: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
	// 823F84C4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823F84C8: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823F84CC: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823F84D0: 8141FFE0  lwz r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 823F84D4: 396A8001  addi r11, r10, -0x7fff
	ctx.r[11].s64 = ctx.r[10].s64 + -32767;
	// 823F84D8: 7D6B8670  srawi r11, r11, 0x10
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 16) as i64;
	// 823F84DC: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 823F84E0: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 823F84E4: 552A047E  clrlwi r10, r9, 0x11
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	// 823F84E8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823F84EC: 3D4B0001  addis r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 65536;
	// 823F84F0: 394A8000  addi r10, r10, -0x8000
	ctx.r[10].s64 = ctx.r[10].s64 + -32768;
	// 823F84F4: 9161FFE0  stw r11, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u32 ) };
	// 823F84F8: 7D4A8670  srawi r10, r10, 0x10
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 16) as i64;
	// 823F84FC: 55490020  rlwinm r9, r10, 0, 0, 0x10
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823F8500: 7D6B5078  andc r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823F8504: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 823F8508: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823F850C: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	// 823F8510: 4198FF34  blt cr6, 0x823f8444
	if ctx.cr[6].lt {
	pc = 0x823F8444; continue 'dispatch;
	}
	pc = 0x823F8514; continue 'dispatch;
            }
            0x823F8514 => {
    //   block [0x823F8514..0x823F851C)
	// 823F8514: 7C68FB96  divwu r3, r8, r31
	ctx.r[3].u32 = ctx.r[8].u32 / ctx.r[31].u32;
	// 823F8518: 0CDF0000  twi 6, r31, 0
	pc = 0x823F851C; continue 'dispatch;
            }
            0x823F851C => {
    //   block [0x823F851C..0x823F8528)
	// 823F851C: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F8520: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823F8524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F8528 size=508
    let mut pc: u32 = 0x823F8528;
    'dispatch: loop {
        match pc {
            0x823F8528 => {
    //   block [0x823F8528..0x823F8560)
	// 823F8528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F852C: 4813CB71  bl 0x8253509c
	ctx.lr = 0x823F8530;
	sub_82535080(ctx, base);
	// 823F8530: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F8534: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823F8538: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823F853C: 3B190008  addi r24, r25, 8
	ctx.r[24].s64 = ctx.r[25].s64 + 8;
	// 823F8540: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 823F8544: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 823F8548: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F854C: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 823F8550: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823F8554: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823F8558: 836A0008  lwz r27, 8(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F855C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x823F8560; continue 'dispatch;
            }
            0x823F8560 => {
    //   block [0x823F8560..0x823F8584)
	// 823F8560: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8564: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8568: 41820034  beq 0x823f859c
	if ctx.cr[0].eq {
	pc = 0x823F859C; continue 'dispatch;
	}
	// 823F856C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8570: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 823F8574: 409A0010  bne cr6, 0x823f8584
	if !ctx.cr[6].eq {
	pc = 0x823F8584; continue 'dispatch;
	}
	// 823F8578: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F857C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 823F8580: 48000008  b 0x823f8588
	pc = 0x823F8588; continue 'dispatch;
            }
            0x823F8584 => {
    //   block [0x823F8584..0x823F8588)
	// 823F8584: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x823F8588; continue 'dispatch;
            }
            0x823F8588 => {
    //   block [0x823F8588..0x823F859C)
	// 823F8588: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F858C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F8590: 419A0010  beq cr6, 0x823f85a0
	if ctx.cr[6].eq {
	pc = 0x823F85A0; continue 'dispatch;
	}
	// 823F8594: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 823F8598: 48000008  b 0x823f85a0
	pc = 0x823F85A0; continue 'dispatch;
            }
            0x823F859C => {
    //   block [0x823F859C..0x823F85A0)
	// 823F859C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x823F85A0; continue 'dispatch;
            }
            0x823F85A0 => {
    //   block [0x823F85A0..0x823F85C8)
	// 823F85A0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F85A4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F85A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F85AC: 4082FFB4  bne 0x823f8560
	if !ctx.cr[0].eq {
	pc = 0x823F8560; continue 'dispatch;
	}
	// 823F85B0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F85B4: 419A0164  beq cr6, 0x823f8718
	if ctx.cr[6].eq {
	pc = 0x823F8718; continue 'dispatch;
	}
	// 823F85B8: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823F85BC: 419A015C  beq cr6, 0x823f8718
	if ctx.cr[6].eq {
	pc = 0x823F8718; continue 'dispatch;
	}
	// 823F85C0: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 823F85C4: 4800014C  b 0x823f8710
	pc = 0x823F8710; continue 'dispatch;
            }
            0x823F85C8 => {
    //   block [0x823F85C8..0x823F85F4)
	// 823F85C8: 3AF7FFFF  addi r23, r23, -1
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	// 823F85CC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 823F85D0: 419A0148  beq cr6, 0x823f8718
	if ctx.cr[6].eq {
	pc = 0x823F8718; continue 'dispatch;
	}
	// 823F85D4: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 823F85D8: 419A0140  beq cr6, 0x823f8718
	if ctx.cr[6].eq {
	pc = 0x823F8718; continue 'dispatch;
	}
	// 823F85DC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F85E0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823F85E4: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823F85E8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F85EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F85F0: 7FCB5050  subf r30, r11, r10
	ctx.r[30].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x823F85F4; continue 'dispatch;
            }
            0x823F85F4 => {
    //   block [0x823F85F4..0x823F8628)
	// 823F85F4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F85F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F85FC: 4182002C  beq 0x823f8628
	if ctx.cr[0].eq {
	pc = 0x823F8628; continue 'dispatch;
	}
	// 823F8600: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8604: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8608: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F860C: 7D4A3850  subf r10, r10, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 823F8610: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F8614: 41980014  blt cr6, 0x823f8628
	if ctx.cr[6].lt {
	pc = 0x823F8628; continue 'dispatch;
	}
	// 823F8618: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F861C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8620: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F8624: 7FCB5050  subf r30, r11, r10
	ctx.r[30].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x823F8628; continue 'dispatch;
            }
            0x823F8628 => {
    //   block [0x823F8628..0x823F8640)
	// 823F8628: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F862C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823F8630: 4082FFC4  bne 0x823f85f4
	if !ctx.cr[0].eq {
	pc = 0x823F85F4; continue 'dispatch;
	}
	// 823F8634: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 823F8638: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 823F863C: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	pc = 0x823F8640; continue 'dispatch;
            }
            0x823F8640 => {
    //   block [0x823F8640..0x823F8690)
	// 823F8640: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8644: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8648: 41820078  beq 0x823f86c0
	if ctx.cr[0].eq {
	pc = 0x823F86C0; continue 'dispatch;
	}
	// 823F864C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8650: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823F8654: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8658: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F865C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F8660: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823F8664: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8668: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F866C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F8670: 4813C4E1  bl 0x82534b50
	ctx.lr = 0x823F8674;
	sub_82534B50(ctx, base);
	// 823F8674: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8678: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F867C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8680: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 823F8684: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F8688: 40980008  bge cr6, 0x823f8690
	if !ctx.cr[6].lt {
	pc = 0x823F8690; continue 'dispatch;
	}
	// 823F868C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F8690; continue 'dispatch;
            }
            0x823F8690 => {
    //   block [0x823F8690..0x823F86C0)
	// 823F8690: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F8694: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8698: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F869C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F86A0: 409A0020  bne cr6, 0x823f86c0
	if !ctx.cr[6].eq {
	pc = 0x823F86C0; continue 'dispatch;
	}
	// 823F86A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823F86A8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F86AC: 4BFFD9D5  bl 0x823f6080
	ctx.lr = 0x823F86B0;
	sub_823F6080(ctx, base);
	// 823F86B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F86B4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823F86B8: 40820008  bne 0x823f86c0
	if !ctx.cr[0].eq {
	pc = 0x823F86C0; continue 'dispatch;
	}
	// 823F86BC: 3AD6FFFF  addi r22, r22, -1
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	pc = 0x823F86C0; continue 'dispatch;
            }
            0x823F86C0 => {
    //   block [0x823F86C0..0x823F86EC)
	// 823F86C0: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823F86C4: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823F86C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823F86CC: 4082FF74  bne 0x823f8640
	if !ctx.cr[0].eq {
	pc = 0x823F8640; continue 'dispatch;
	}
	// 823F86D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F86D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F86D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F86DC: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 823F86E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823F86E4: 40980008  bge cr6, 0x823f86ec
	if !ctx.cr[6].lt {
	pc = 0x823F86EC; continue 'dispatch;
	}
	// 823F86E8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823F86EC; continue 'dispatch;
            }
            0x823F86EC => {
    //   block [0x823F86EC..0x823F8710)
	// 823F86EC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823F86F0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F86F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F86F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F86FC: 409A0014  bne cr6, 0x823f8710
	if !ctx.cr[6].eq {
	pc = 0x823F8710; continue 'dispatch;
	}
	// 823F8700: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823F8704: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F8708: 4BFFD979  bl 0x823f6080
	ctx.lr = 0x823F870C;
	sub_823F6080(ctx, base);
	// 823F870C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x823F8710; continue 'dispatch;
            }
            0x823F8710 => {
    //   block [0x823F8710..0x823F8718)
	// 823F8710: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 823F8714: 409AFEB4  bne cr6, 0x823f85c8
	if !ctx.cr[6].eq {
	pc = 0x823F85C8; continue 'dispatch;
	}
	pc = 0x823F8718; continue 'dispatch;
            }
            0x823F8718 => {
    //   block [0x823F8718..0x823F8724)
	// 823F8718: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 823F871C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823F8720: 4813C9CC  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F8728 size=284
    let mut pc: u32 = 0x823F8728;
    'dispatch: loop {
        match pc {
            0x823F8728 => {
    //   block [0x823F8728..0x823F874C)
	// 823F8728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F872C: 4813C98D  bl 0x825350b8
	ctx.lr = 0x823F8730;
	sub_82535080(ctx, base);
	// 823F8730: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F8734: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823F8738: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823F873C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F8740: 409A000C  bne cr6, 0x823f874c
	if !ctx.cr[6].eq {
	pc = 0x823F874C; continue 'dispatch;
	}
	// 823F8744: 3860181A  li r3, 0x181a
	ctx.r[3].s64 = 6170;
	// 823F8748: 480000F4  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F874C => {
    //   block [0x823F874C..0x823F8760)
	// 823F874C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8754: 409A000C  bne cr6, 0x823f8760
	if !ctx.cr[6].eq {
	pc = 0x823F8760; continue 'dispatch;
	}
	// 823F8758: 386017F2  li r3, 0x17f2
	ctx.r[3].s64 = 6130;
	// 823F875C: 480000E0  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F8760 => {
    //   block [0x823F8760..0x823F8774)
	// 823F8760: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8764: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8768: 4082000C  bne 0x823f8774
	if !ctx.cr[0].eq {
	pc = 0x823F8774; continue 'dispatch;
	}
	// 823F876C: 386017ED  li r3, 0x17ed
	ctx.r[3].s64 = 6125;
	// 823F8770: 480000CC  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F8774 => {
    //   block [0x823F8774..0x823F878C)
	// 823F8774: A17F000C  lhz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8778: A15F000E  lhz r10, 0xe(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 823F877C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F8780: 4198000C  blt cr6, 0x823f878c
	if ctx.cr[6].lt {
	pc = 0x823F878C; continue 'dispatch;
	}
	// 823F8784: 38601801  li r3, 0x1801
	ctx.r[3].s64 = 6145;
	// 823F8788: 480000B4  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F878C => {
    //   block [0x823F878C..0x823F87A4)
	// 823F878C: A15F0012  lhz r10, 0x12(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 823F8790: 3B9F0012  addi r28, r31, 0x12
	ctx.r[28].s64 = ctx.r[31].s64 + 18;
	// 823F8794: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F8798: 4198000C  blt cr6, 0x823f87a4
	if ctx.cr[6].lt {
	pc = 0x823F87A4; continue 'dispatch;
	}
	// 823F879C: 38601806  li r3, 0x1806
	ctx.r[3].s64 = 6150;
	// 823F87A0: 4800009C  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F87A4 => {
    //   block [0x823F87A4..0x823F87B8)
	// 823F87A4: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F87A8: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 823F87AC: 4099000C  ble cr6, 0x823f87b8
	if !ctx.cr[6].gt {
	pc = 0x823F87B8; continue 'dispatch;
	}
	// 823F87B0: 386017F7  li r3, 0x17f7
	ctx.r[3].s64 = 6135;
	// 823F87B4: 48000088  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F87B8 => {
    //   block [0x823F87B8..0x823F87D0)
	// 823F87B8: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F87BC: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 823F87C0: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 823F87C4: 4099000C  ble cr6, 0x823f87d0
	if !ctx.cr[6].gt {
	pc = 0x823F87D0; continue 'dispatch;
	}
	// 823F87C8: 386017FC  li r3, 0x17fc
	ctx.r[3].s64 = 6140;
	// 823F87CC: 48000070  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F87D0 => {
    //   block [0x823F87D0..0x823F87F8)
	// 823F87D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823F87D4: 419A0064  beq cr6, 0x823f8838
	if ctx.cr[6].eq {
	pc = 0x823F8838; continue 'dispatch;
	}
	// 823F87D8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F87DC: 2B0BFACE  cmplwi cr6, r11, 0xface
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64206 as u32, &mut ctx.xer);
	// 823F87E0: 409A0058  bne cr6, 0x823f8838
	if !ctx.cr[6].eq {
	pc = 0x823F8838; continue 'dispatch;
	}
	// 823F87E4: 897D000C  lbz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F87E8: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 823F87EC: 419A000C  beq cr6, 0x823f87f8
	if ctx.cr[6].eq {
	pc = 0x823F87F8; continue 'dispatch;
	}
	// 823F87F0: 386017DE  li r3, 0x17de
	ctx.r[3].s64 = 6110;
	// 823F87F4: 48000048  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F87F8 => {
    //   block [0x823F87F8..0x823F8838)
	// 823F87F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F87FC: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F8800: 48002EB9  bl 0x823fb6b8
	ctx.lr = 0x823F8804;
	sub_823FB6B8(ctx, base);
	// 823F8804: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823F8808: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823F880C: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F8810: 48002731  bl 0x823faf40
	ctx.lr = 0x823F8814;
	sub_823FAF40(ctx, base);
	// 823F8814: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823F8818: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823F881C: A0FF000C  lhz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8820: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823F8824: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8828: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823F882C: 480026A5  bl 0x823faed0
	ctx.lr = 0x823F8830;
	sub_823FAED0(ctx, base);
	// 823F8830: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8834: 48000008  b 0x823f883c
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F8838 => {
    //   block [0x823F8838..0x823F883C)
	// 823F8838: 386017D4  li r3, 0x17d4
	ctx.r[3].s64 = 6100;
	pc = 0x823F883C; continue 'dispatch;
            }
            0x823F883C => {
    //   block [0x823F883C..0x823F8844)
	// 823F883C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 823F8840: 4813C8C8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F8848 size=164
    let mut pc: u32 = 0x823F8848;
    'dispatch: loop {
        match pc {
            0x823F8848 => {
    //   block [0x823F8848..0x823F88A8)
	// 823F8848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F884C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F8850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F8854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F8858: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F885C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F8860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F8864: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F8868: 4BFD1A11  bl 0x823ca278
	ctx.lr = 0x823F886C;
	sub_823CA278(ctx, base);
	// 823F886C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8870: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8874: 4BFFFEB5  bl 0x823f8728
	ctx.lr = 0x823F8878;
	sub_823F8728(ctx, base);
	// 823F8878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F887C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F8880: 4BFD19F9  bl 0x823ca278
	ctx.lr = 0x823F8884;
	sub_823CA278(ctx, base);
	// 823F8884: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F8888: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823F888C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823F8890: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823F8894: 396B4560  addi r11, r11, 0x4560
	ctx.r[11].s64 = ctx.r[11].s64 + 17760;
	// 823F8898: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823F889C: 7F2A4800  cmpd cr6, r10, r9
	ctx.cr[6].compare_i64(ctx.r[10].s64, ctx.r[9].s64, &mut ctx.xer);
	// 823F88A0: 40980008  bge cr6, 0x823f88a8
	if !ctx.cr[6].lt {
	pc = 0x823F88A8; continue 'dispatch;
	}
	// 823F88A4: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x823F88A8; continue 'dispatch;
            }
            0x823F88A8 => {
    //   block [0x823F88A8..0x823F88B8)
	// 823F88A8: E92B0010  ld r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 823F88AC: 7F2A4800  cmpd cr6, r10, r9
	ctx.cr[6].compare_i64(ctx.r[10].s64, ctx.r[9].s64, &mut ctx.xer);
	// 823F88B0: 40990008  ble cr6, 0x823f88b8
	if !ctx.cr[6].gt {
	pc = 0x823F88B8; continue 'dispatch;
	}
	// 823F88B4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	pc = 0x823F88B8; continue 'dispatch;
            }
            0x823F88B8 => {
    //   block [0x823F88B8..0x823F88EC)
	// 823F88B8: E92B0018  ld r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823F88BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F88C0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823F88C4: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823F88C8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F88CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F88D0: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823F88D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F88D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F88DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F88E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F88E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F88E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F88F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F88F0 size=192
    let mut pc: u32 = 0x823F88F0;
    'dispatch: loop {
        match pc {
            0x823F88F0 => {
    //   block [0x823F88F0..0x823F8910)
	// 823F88F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F88F4: 4813C7C5  bl 0x825350b8
	ctx.lr = 0x823F88F8;
	sub_82535080(ctx, base);
	// 823F88F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F88FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823F8900: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823F8904: 409A000C  bne cr6, 0x823f8910
	if !ctx.cr[6].eq {
	pc = 0x823F8910; continue 'dispatch;
	}
	// 823F8908: 3860181A  li r3, 0x181a
	ctx.r[3].s64 = 6170;
	// 823F890C: 4800009C  b 0x823f89a8
	pc = 0x823F89A8; continue 'dispatch;
            }
            0x823F8910 => {
    //   block [0x823F8910..0x823F893C)
	// 823F8910: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8914: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8918: 4182008C  beq 0x823f89a4
	if ctx.cr[0].eq {
	pc = 0x823F89A4; continue 'dispatch;
	}
	// 823F891C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8920: 2B0BFACE  cmplwi cr6, r11, 0xface
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64206 as u32, &mut ctx.xer);
	// 823F8924: 409A0080  bne cr6, 0x823f89a4
	if !ctx.cr[6].eq {
	pc = 0x823F89A4; continue 'dispatch;
	}
	// 823F8928: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F892C: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 823F8930: 419A000C  beq cr6, 0x823f893c
	if ctx.cr[6].eq {
	pc = 0x823F893C; continue 'dispatch;
	}
	// 823F8934: 386017E3  li r3, 0x17e3
	ctx.r[3].s64 = 6115;
	// 823F8938: 48000070  b 0x823f89a8
	pc = 0x823F89A8; continue 'dispatch;
            }
            0x823F893C => {
    //   block [0x823F893C..0x823F896C)
	// 823F893C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F8940: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823F8944: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F8948: 480027C1  bl 0x823fb108
	ctx.lr = 0x823F894C;
	sub_823FB108(ctx, base);
	// 823F894C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F8950: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823F8954: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8958: 41820014  beq 0x823f896c
	if ctx.cr[0].eq {
	pc = 0x823F896C; continue 'dispatch;
	}
	// 823F895C: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F8960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8964: 4E800421  bctrl
	ctx.lr = 0x823F8968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8968: 93BF0024  stw r29, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
            }
            0x823F896C => {
    //   block [0x823F896C..0x823F8988)
	// 823F896C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F8970: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8974: 41820014  beq 0x823f8988
	if ctx.cr[0].eq {
	pc = 0x823F8988; continue 'dispatch;
	}
	// 823F8978: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F897C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8980: 4E800421  bctrl
	ctx.lr = 0x823F8984;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8984: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
            }
            0x823F8988 => {
    //   block [0x823F8988..0x823F89A4)
	// 823F8988: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F898C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F8990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8994: 4E800421  bctrl
	ctx.lr = 0x823F8998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8998: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F899C: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F89A0: 48000008  b 0x823f89a8
	pc = 0x823F89A8; continue 'dispatch;
            }
            0x823F89A4 => {
    //   block [0x823F89A4..0x823F89A8)
	// 823F89A4: 386017D4  li r3, 0x17d4
	ctx.r[3].s64 = 6100;
	pc = 0x823F89A8; continue 'dispatch;
            }
            0x823F89A8 => {
    //   block [0x823F89A8..0x823F89B0)
	// 823F89A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F89AC: 4813C75C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F89B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F89B0 size=4
    let mut pc: u32 = 0x823F89B0;
    'dispatch: loop {
        match pc {
            0x823F89B0 => {
    //   block [0x823F89B0..0x823F89B4)
	// 823F89B0: 4BFFFF40  b 0x823f88f0
	sub_823F88F0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F89B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F89B8 size=280
    let mut pc: u32 = 0x823F89B8;
    'dispatch: loop {
        match pc {
            0x823F89B8 => {
    //   block [0x823F89B8..0x823F89DC)
	// 823F89B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F89BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F89C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F89C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F89C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F89CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F89D0: 409A000C  bne cr6, 0x823f89dc
	if !ctx.cr[6].eq {
	pc = 0x823F89DC; continue 'dispatch;
	}
	// 823F89D4: 3860181A  li r3, 0x181a
	ctx.r[3].s64 = 6170;
	// 823F89D8: 480000E4  b 0x823f8abc
	pc = 0x823F8ABC; continue 'dispatch;
            }
            0x823F89DC => {
    //   block [0x823F89DC..0x823F8A60)
	// 823F89DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823F89E0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823F89E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F89E8: 816A37A8  lwz r11, 0x37a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823F89EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F89F0: 419A00C8  beq cr6, 0x823f8ab8
	if ctx.cr[6].eq {
	pc = 0x823F8AB8; continue 'dispatch;
	}
	// 823F89F4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F89F8: 816B37AC  lwz r11, 0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F89FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8A00: 419A00B8  beq cr6, 0x823f8ab8
	if ctx.cr[6].eq {
	pc = 0x823F8AB8; continue 'dispatch;
	}
	// 823F8A04: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8A08: 816B37B0  lwz r11, 0x37b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823F8A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8A10: 419A00A8  beq cr6, 0x823f8ab8
	if ctx.cr[6].eq {
	pc = 0x823F8AB8; continue 'dispatch;
	}
	// 823F8A14: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8A18: 816B37B4  lwz r11, 0x37b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823F8A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8A20: 419A0098  beq cr6, 0x823f8ab8
	if ctx.cr[6].eq {
	pc = 0x823F8AB8; continue 'dispatch;
	}
	// 823F8A24: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8A28: 816B37B8  lwz r11, 0x37b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14264 as u32) ) } as u64;
	// 823F8A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8A30: 419A0088  beq cr6, 0x823f8ab8
	if ctx.cr[6].eq {
	pc = 0x823F8AB8; continue 'dispatch;
	}
	// 823F8A34: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8A38: 816B37BC  lwz r11, 0x37bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14268 as u32) ) } as u64;
	// 823F8A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8A40: 419A0078  beq cr6, 0x823f8ab8
	if ctx.cr[6].eq {
	pc = 0x823F8AB8; continue 'dispatch;
	}
	// 823F8A44: 816A37A8  lwz r11, 0x37a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823F8A48: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 823F8A4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823F8A50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8A54: 4E800421  bctrl
	ctx.lr = 0x823F8A58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8A58: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F8A5C: 4082000C  bne 0x823f8a68
	if !ctx.cr[0].eq {
	pc = 0x823F8A68; continue 'dispatch;
	}
            }
            0x823F8A60 => {
    //   block [0x823F8A60..0x823F8A68)
	// 823F8A60: 38601770  li r3, 0x1770
	ctx.r[3].s64 = 6000;
	// 823F8A64: 48000058  b 0x823f8abc
	pc = 0x823F8ABC; continue 'dispatch;
            }
            0x823F8A68 => {
    //   block [0x823F8A68..0x823F8AB0)
	// 823F8A68: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 823F8A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F8A70: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 823F8A74: 808B0018  lwz r4, 0x18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823F8A78: 6129FACE  ori r9, r9, 0xface
	ctx.r[9].u64 = ctx.r[9].u64 | 64206;
	// 823F8A7C: 39000064  li r8, 0x64
	ctx.r[8].s64 = 100;
	// 823F8A80: 38E00BB8  li r7, 0xbb8
	ctx.r[7].s64 = 3000;
	// 823F8A84: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 823F8A88: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 823F8A8C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823F8A90: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 823F8A94: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 823F8A98: 48002541  bl 0x823fafd8
	ctx.lr = 0x823F8A9C;
	sub_823FAFD8(ctx, base);
	// 823F8A9C: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F8AA0: 41820010  beq 0x823f8ab0
	if ctx.cr[0].eq {
	pc = 0x823F8AB0; continue 'dispatch;
	}
	// 823F8AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F8AA8: 4BFFFE49  bl 0x823f88f0
	ctx.lr = 0x823F8AAC;
	sub_823F88F0(ctx, base);
	// 823F8AAC: 4BFFFFB4  b 0x823f8a60
	pc = 0x823F8A60; continue 'dispatch;
            }
            0x823F8AB0 => {
    //   block [0x823F8AB0..0x823F8AB8)
	// 823F8AB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8AB4: 48000008  b 0x823f8abc
	pc = 0x823F8ABC; continue 'dispatch;
            }
            0x823F8AB8 => {
    //   block [0x823F8AB8..0x823F8ABC)
	// 823F8AB8: 38601771  li r3, 0x1771
	ctx.r[3].s64 = 6001;
	pc = 0x823F8ABC; continue 'dispatch;
            }
            0x823F8ABC => {
    //   block [0x823F8ABC..0x823F8AD0)
	// 823F8ABC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823F8AC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F8AC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F8AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F8ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8AD0 size=48
    let mut pc: u32 = 0x823F8AD0;
    'dispatch: loop {
        match pc {
            0x823F8AD0 => {
    //   block [0x823F8AD0..0x823F8B00)
	// 823F8AD0: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 823F8AD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F8AD8: 396B4560  addi r11, r11, 0x4560
	ctx.r[11].s64 = ctx.r[11].s64 + 17760;
	// 823F8ADC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823F8AE0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 823F8AE4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 823F8AE8: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823F8AEC: F94B0020  std r10, 0x20(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u64 ) };
	// 823F8AF0: 3D403B9A  lis r10, 0x3b9a
	ctx.r[10].s64 = 999948288;
	// 823F8AF4: 614ACA00  ori r10, r10, 0xca00
	ctx.r[10].u64 = ctx.r[10].u64 | 51712;
	// 823F8AF8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 823F8AFC: 4BFFFEBC  b 0x823f89b8
	sub_823F89B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823F8B00 size=364
    let mut pc: u32 = 0x823F8B00;
    'dispatch: loop {
        match pc {
            0x823F8B00 => {
    //   block [0x823F8B00..0x823F8B44)
	// 823F8B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F8B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F8B08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F8B0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F8B10: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F8B14: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 823F8B18: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823F8B1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 823F8B20: 419A0130  beq cr6, 0x823f8c50
	if ctx.cr[6].eq {
	pc = 0x823F8C50; continue 'dispatch;
	}
	// 823F8B24: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8B28: 2B0BFACE  cmplwi cr6, r11, 0xface
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64206 as u32, &mut ctx.xer);
	// 823F8B2C: 409A0124  bne cr6, 0x823f8c50
	if !ctx.cr[6].eq {
	pc = 0x823F8C50; continue 'dispatch;
	}
	// 823F8B30: 8967000C  lbz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8B34: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 823F8B38: 419A000C  beq cr6, 0x823f8b44
	if ctx.cr[6].eq {
	pc = 0x823F8B44; continue 'dispatch;
	}
	// 823F8B3C: 386017E3  li r3, 0x17e3
	ctx.r[3].s64 = 6115;
	// 823F8B40: 48000114  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8B44 => {
    //   block [0x823F8B44..0x823F8B54)
	// 823F8B44: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F8B48: 409A000C  bne cr6, 0x823f8b54
	if !ctx.cr[6].eq {
	pc = 0x823F8B54; continue 'dispatch;
	}
	// 823F8B4C: 3860181A  li r3, 0x181a
	ctx.r[3].s64 = 6170;
	// 823F8B50: 48000104  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8B54 => {
    //   block [0x823F8B54..0x823F8B68)
	// 823F8B54: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8B5C: 409A000C  bne cr6, 0x823f8b68
	if !ctx.cr[6].eq {
	pc = 0x823F8B68; continue 'dispatch;
	}
	// 823F8B60: 386017F2  li r3, 0x17f2
	ctx.r[3].s64 = 6130;
	// 823F8B64: 480000F0  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8B68 => {
    //   block [0x823F8B68..0x823F8B7C)
	// 823F8B68: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8B70: 409A000C  bne cr6, 0x823f8b7c
	if !ctx.cr[6].eq {
	pc = 0x823F8B7C; continue 'dispatch;
	}
	// 823F8B74: 386017ED  li r3, 0x17ed
	ctx.r[3].s64 = 6125;
	// 823F8B78: 480000DC  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8B7C => {
    //   block [0x823F8B7C..0x823F8B98)
	// 823F8B7C: A164000C  lhz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8B80: 3904000E  addi r8, r4, 0xe
	ctx.r[8].s64 = ctx.r[4].s64 + 14;
	// 823F8B84: A144000E  lhz r10, 0xe(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(14 as u32) ) } as u64;
	// 823F8B88: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F8B8C: 4198000C  blt cr6, 0x823f8b98
	if ctx.cr[6].lt {
	pc = 0x823F8B98; continue 'dispatch;
	}
	// 823F8B90: 38601801  li r3, 0x1801
	ctx.r[3].s64 = 6145;
	// 823F8B94: 480000C0  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8B98 => {
    //   block [0x823F8B98..0x823F8BAC)
	// 823F8B98: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 823F8B9C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823F8BA0: 4198000C  blt cr6, 0x823f8bac
	if ctx.cr[6].lt {
	pc = 0x823F8BAC; continue 'dispatch;
	}
	// 823F8BA4: 38601806  li r3, 0x1806
	ctx.r[3].s64 = 6150;
	// 823F8BA8: 480000AC  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8BAC => {
    //   block [0x823F8BAC..0x823F8BC4)
	// 823F8BAC: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F8BB0: 39240010  addi r9, r4, 0x10
	ctx.r[9].s64 = ctx.r[4].s64 + 16;
	// 823F8BB4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 823F8BB8: 4099000C  ble cr6, 0x823f8bc4
	if !ctx.cr[6].gt {
	pc = 0x823F8BC4; continue 'dispatch;
	}
	// 823F8BBC: 386017F7  li r3, 0x17f7
	ctx.r[3].s64 = 6135;
	// 823F8BC0: 48000094  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8BC4 => {
    //   block [0x823F8BC4..0x823F8BD8)
	// 823F8BC4: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 823F8BC8: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 823F8BCC: 4099000C  ble cr6, 0x823f8bd8
	if !ctx.cr[6].gt {
	pc = 0x823F8BD8; continue 'dispatch;
	}
	// 823F8BD0: 386017FC  li r3, 0x17fc
	ctx.r[3].s64 = 6140;
	// 823F8BD4: 48000080  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8BD8 => {
    //   block [0x823F8BD8..0x823F8C20)
	// 823F8BD8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823F8BDC: 80670010  lwz r3, 0x10(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F8BE0: 3BC100A0  addi r30, r1, 0xa0
	ctx.r[30].s64 = ctx.r[1].s64 + 160;
	// 823F8BE4: 9087001C  stw r4, 0x1c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 823F8BE8: 38A40004  addi r5, r4, 4
	ctx.r[5].s64 = ctx.r[4].s64 + 4;
	// 823F8BEC: A0E4000C  lhz r7, 0xc(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8BF0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823F8BF4: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8BF8: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8BFC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 823F8C00: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823F8C04: 48002EB5  bl 0x823fbab8
	ctx.lr = 0x823F8C08;
	sub_823FBAB8(ctx, base);
	// 823F8C08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F8C0C: 419A003C  beq cr6, 0x823f8c48
	if ctx.cr[6].eq {
	pc = 0x823F8C48; continue 'dispatch;
	}
	// 823F8C10: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F8C14: 395F0034  addi r10, r31, 0x34
	ctx.r[10].s64 = ctx.r[31].s64 + 52;
	// 823F8C18: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823F8C1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823F8C20; continue 'dispatch;
            }
            0x823F8C20 => {
    //   block [0x823F8C20..0x823F8C48)
	// 823F8C20: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 823F8C24: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 823F8C28: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823F8C2C: 7DAB442E  lfsx f13, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823F8C30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823F8C34: D00AFFD0  stfs f0, -0x30(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 823F8C38: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823F8C3C: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 823F8C40: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823F8C44: 4198FFDC  blt cr6, 0x823f8c20
	if ctx.cr[6].lt {
	pc = 0x823F8C20; continue 'dispatch;
	}
	pc = 0x823F8C48; continue 'dispatch;
            }
            0x823F8C48 => {
    //   block [0x823F8C48..0x823F8C50)
	// 823F8C48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8C4C: 48000008  b 0x823f8c54
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8C50 => {
    //   block [0x823F8C50..0x823F8C54)
	// 823F8C50: 386017D4  li r3, 0x17d4
	ctx.r[3].s64 = 6100;
	pc = 0x823F8C54; continue 'dispatch;
            }
            0x823F8C54 => {
    //   block [0x823F8C54..0x823F8C6C)
	// 823F8C54: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 823F8C58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F8C5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F8C60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F8C64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F8C68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F8C70 size=148
    let mut pc: u32 = 0x823F8C70;
    'dispatch: loop {
        match pc {
            0x823F8C70 => {
    //   block [0x823F8C70..0x823F8CD0)
	// 823F8C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F8C74: 4813C449  bl 0x825350bc
	ctx.lr = 0x823F8C78;
	sub_82535080(ctx, base);
	// 823F8C78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F8C7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F8C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F8C84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823F8C88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823F8C8C: 4BFD15ED  bl 0x823ca278
	ctx.lr = 0x823F8C90;
	sub_823CA278(ctx, base);
	// 823F8C90: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8C94: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8C98: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8C9C: 4BFFFE65  bl 0x823f8b00
	ctx.lr = 0x823F8CA0;
	sub_823F8B00(ctx, base);
	// 823F8CA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F8CA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 823F8CA8: 4BFD15D1  bl 0x823ca278
	ctx.lr = 0x823F8CAC;
	sub_823CA278(ctx, base);
	// 823F8CAC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F8CB0: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823F8CB4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823F8CB8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8CBC: 396B3780  addi r11, r11, 0x3780
	ctx.r[11].s64 = ctx.r[11].s64 + 14208;
	// 823F8CC0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 823F8CC4: 7F2A4800  cmpd cr6, r10, r9
	ctx.cr[6].compare_i64(ctx.r[10].s64, ctx.r[9].s64, &mut ctx.xer);
	// 823F8CC8: 40980008  bge cr6, 0x823f8cd0
	if !ctx.cr[6].lt {
	pc = 0x823F8CD0; continue 'dispatch;
	}
	// 823F8CCC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x823F8CD0; continue 'dispatch;
            }
            0x823F8CD0 => {
    //   block [0x823F8CD0..0x823F8CE0)
	// 823F8CD0: E92B0010  ld r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 823F8CD4: 7F2A4800  cmpd cr6, r10, r9
	ctx.cr[6].compare_i64(ctx.r[10].s64, ctx.r[9].s64, &mut ctx.xer);
	// 823F8CD8: 40990008  ble cr6, 0x823f8ce0
	if !ctx.cr[6].gt {
	pc = 0x823F8CE0; continue 'dispatch;
	}
	// 823F8CDC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	pc = 0x823F8CE0; continue 'dispatch;
            }
            0x823F8CE0 => {
    //   block [0x823F8CE0..0x823F8D04)
	// 823F8CE0: E92B0018  ld r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 823F8CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F8CE8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823F8CEC: F94B0018  std r10, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u64 ) };
	// 823F8CF0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F8CF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823F8CF8: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 823F8CFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823F8D00: 4813C40C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8D08 size=20
    let mut pc: u32 = 0x823F8D08;
    'dispatch: loop {
        match pc {
            0x823F8D08 => {
    //   block [0x823F8D08..0x823F8D1C)
	// 823F8D08: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F8D0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8D10: A16B005C  lhz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 823F8D14: 99640000  stb r11, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 823F8D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F8D20 size=184
    let mut pc: u32 = 0x823F8D20;
    'dispatch: loop {
        match pc {
            0x823F8D20 => {
    //   block [0x823F8D20..0x823F8D3C)
	// 823F8D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F8D24: 4813C399  bl 0x825350bc
	ctx.lr = 0x823F8D28;
	sub_82535080(ctx, base);
	// 823F8D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F8D2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823F8D30: 409A000C  bne cr6, 0x823f8d3c
	if !ctx.cr[6].eq {
	pc = 0x823F8D3C; continue 'dispatch;
	}
	// 823F8D34: 3860181A  li r3, 0x181a
	ctx.r[3].s64 = 6170;
	// 823F8D38: 48000098  b 0x823f8dd0
	pc = 0x823F8DD0; continue 'dispatch;
            }
            0x823F8D3C => {
    //   block [0x823F8D3C..0x823F8D68)
	// 823F8D3C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8D40: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8D44: 41820088  beq 0x823f8dcc
	if ctx.cr[0].eq {
	pc = 0x823F8DCC; continue 'dispatch;
	}
	// 823F8D48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F8D4C: 2B0BFACE  cmplwi cr6, r11, 0xface
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64206 as u32, &mut ctx.xer);
	// 823F8D50: 409A007C  bne cr6, 0x823f8dcc
	if !ctx.cr[6].eq {
	pc = 0x823F8DCC; continue 'dispatch;
	}
	// 823F8D54: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F8D58: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 823F8D5C: 419A000C  beq cr6, 0x823f8d68
	if ctx.cr[6].eq {
	pc = 0x823F8D68; continue 'dispatch;
	}
	// 823F8D60: 386017E3  li r3, 0x17e3
	ctx.r[3].s64 = 6115;
	// 823F8D64: 4800006C  b 0x823f8dd0
	pc = 0x823F8DD0; continue 'dispatch;
            }
            0x823F8D68 => {
    //   block [0x823F8D68..0x823F8D98)
	// 823F8D68: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823F8D6C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823F8D70: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823F8D74: 4800310D  bl 0x823fbe80
	ctx.lr = 0x823F8D78;
	sub_823FBE80(ctx, base);
	// 823F8D78: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F8D7C: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823F8D80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8D84: 41820014  beq 0x823f8d98
	if ctx.cr[0].eq {
	pc = 0x823F8D98; continue 'dispatch;
	}
	// 823F8D88: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F8D8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8D90: 4E800421  bctrl
	ctx.lr = 0x823F8D94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8D94: 93BF0024  stw r29, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
            }
            0x823F8D98 => {
    //   block [0x823F8D98..0x823F8DB4)
	// 823F8D98: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F8D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823F8DA0: 41820014  beq 0x823f8db4
	if ctx.cr[0].eq {
	pc = 0x823F8DB4; continue 'dispatch;
	}
	// 823F8DA4: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F8DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8DAC: 4E800421  bctrl
	ctx.lr = 0x823F8DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8DB0: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
            }
            0x823F8DB4 => {
    //   block [0x823F8DB4..0x823F8DCC)
	// 823F8DB4: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F8DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F8DBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8DC0: 4E800421  bctrl
	ctx.lr = 0x823F8DC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8DC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8DC8: 48000008  b 0x823f8dd0
	pc = 0x823F8DD0; continue 'dispatch;
            }
            0x823F8DCC => {
    //   block [0x823F8DCC..0x823F8DD0)
	// 823F8DCC: 386017D4  li r3, 0x17d4
	ctx.r[3].s64 = 6100;
	pc = 0x823F8DD0; continue 'dispatch;
            }
            0x823F8DD0 => {
    //   block [0x823F8DD0..0x823F8DD8)
	// 823F8DD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F8DD4: 4813C338  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8DD8 size=4
    let mut pc: u32 = 0x823F8DD8;
    'dispatch: loop {
        match pc {
            0x823F8DD8 => {
    //   block [0x823F8DD8..0x823F8DDC)
	// 823F8DD8: 4BFFFF48  b 0x823f8d20
	sub_823F8D20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823F8DE0 size=324
    let mut pc: u32 = 0x823F8DE0;
    'dispatch: loop {
        match pc {
            0x823F8DE0 => {
    //   block [0x823F8DE0..0x823F8E08)
	// 823F8DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F8DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823F8DE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823F8DEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823F8DF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823F8DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823F8DF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823F8DFC: 409A000C  bne cr6, 0x823f8e08
	if !ctx.cr[6].eq {
	pc = 0x823F8E08; continue 'dispatch;
	}
	// 823F8E00: 3860181A  li r3, 0x181a
	ctx.r[3].s64 = 6170;
	// 823F8E04: 48000108  b 0x823f8f0c
	pc = 0x823F8F0C; continue 'dispatch;
            }
            0x823F8E08 => {
    //   block [0x823F8E08..0x823F8E8C)
	// 823F8E08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823F8E0C: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823F8E10: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823F8E14: 816A37A8  lwz r11, 0x37a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823F8E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8E1C: 419A00EC  beq cr6, 0x823f8f08
	if ctx.cr[6].eq {
	pc = 0x823F8F08; continue 'dispatch;
	}
	// 823F8E20: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8E24: 816B37AC  lwz r11, 0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823F8E28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8E2C: 419A00DC  beq cr6, 0x823f8f08
	if ctx.cr[6].eq {
	pc = 0x823F8F08; continue 'dispatch;
	}
	// 823F8E30: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8E34: 816B37B0  lwz r11, 0x37b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823F8E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8E3C: 419A00CC  beq cr6, 0x823f8f08
	if ctx.cr[6].eq {
	pc = 0x823F8F08; continue 'dispatch;
	}
	// 823F8E40: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8E44: 816B37B4  lwz r11, 0x37b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823F8E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8E4C: 419A00BC  beq cr6, 0x823f8f08
	if ctx.cr[6].eq {
	pc = 0x823F8F08; continue 'dispatch;
	}
	// 823F8E50: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8E54: 816B37B8  lwz r11, 0x37b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14264 as u32) ) } as u64;
	// 823F8E58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8E5C: 419A00AC  beq cr6, 0x823f8f08
	if ctx.cr[6].eq {
	pc = 0x823F8F08; continue 'dispatch;
	}
	// 823F8E60: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8E64: 816B37BC  lwz r11, 0x37bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14268 as u32) ) } as u64;
	// 823F8E68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F8E6C: 419A009C  beq cr6, 0x823f8f08
	if ctx.cr[6].eq {
	pc = 0x823F8F08; continue 'dispatch;
	}
	// 823F8E70: 816A37A8  lwz r11, 0x37a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823F8E74: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 823F8E78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823F8E7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823F8E80: 4E800421  bctrl
	ctx.lr = 0x823F8E84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823F8E84: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F8E88: 4082000C  bne 0x823f8e94
	if !ctx.cr[0].eq {
	pc = 0x823F8E94; continue 'dispatch;
	}
            }
            0x823F8E8C => {
    //   block [0x823F8E8C..0x823F8E94)
	// 823F8E8C: 38601770  li r3, 0x1770
	ctx.r[3].s64 = 6000;
	// 823F8E90: 4800007C  b 0x823f8f0c
	pc = 0x823F8F0C; continue 'dispatch;
            }
            0x823F8E94 => {
    //   block [0x823F8E94..0x823F8EC8)
	// 823F8E94: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 823F8E98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823F8E9C: 3940000B  li r10, 0xb
	ctx.r[10].s64 = 11;
	// 823F8EA0: 6129FACE  ori r9, r9, 0xface
	ctx.r[9].u64 = ctx.r[9].u64 | 64206;
	// 823F8EA4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 823F8EA8: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 823F8EAC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823F8EB0: 48002E01  bl 0x823fbcb0
	ctx.lr = 0x823F8EB4;
	sub_823FBCB0(ctx, base);
	// 823F8EB4: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F8EB8: 41820010  beq 0x823f8ec8
	if ctx.cr[0].eq {
	pc = 0x823F8EC8; continue 'dispatch;
	}
	// 823F8EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823F8EC0: 4BFFFE61  bl 0x823f8d20
	ctx.lr = 0x823F8EC4;
	sub_823F8D20(ctx, base);
	// 823F8EC4: 4BFFFFC8  b 0x823f8e8c
	pc = 0x823F8E8C; continue 'dispatch;
            }
            0x823F8EC8 => {
    //   block [0x823F8EC8..0x823F8F08)
	// 823F8EC8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823F8ED0: 3BEB3780  addi r31, r11, 0x3780
	ctx.r[31].s64 = ctx.r[11].s64 + 14208;
	// 823F8ED4: 3D603B9A  lis r11, 0x3b9a
	ctx.r[11].s64 = 999948288;
	// 823F8ED8: 616BCA00  ori r11, r11, 0xca00
	ctx.r[11].u64 = ctx.r[11].u64 | 51712;
	// 823F8EDC: FBDF0000  std r30, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 823F8EE0: FBDF0008  std r30, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 823F8EE4: FBDF0010  std r30, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
	// 823F8EE8: FBDF0018  std r30, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u64 ) };
	// 823F8EEC: FBDF0020  std r30, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u64 ) };
	// 823F8EF0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 823F8EF4: 4814D15D  bl 0x82546050
	ctx.lr = 0x823F8EF8;
	sub_82546050(ctx, base);
	// 823F8EF8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823F8EFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F00: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 823F8F04: 48000008  b 0x823f8f0c
	pc = 0x823F8F0C; continue 'dispatch;
            }
            0x823F8F08 => {
    //   block [0x823F8F08..0x823F8F0C)
	// 823F8F08: 38601771  li r3, 0x1771
	ctx.r[3].s64 = 6001;
	pc = 0x823F8F0C; continue 'dispatch;
            }
            0x823F8F0C => {
    //   block [0x823F8F0C..0x823F8F24)
	// 823F8F0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823F8F10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823F8F14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823F8F18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823F8F1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823F8F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F28 size=4
    let mut pc: u32 = 0x823F8F28;
    'dispatch: loop {
        match pc {
            0x823F8F28 => {
    //   block [0x823F8F28..0x823F8F2C)
	// 823F8F28: 4BFFFEB8  b 0x823f8de0
	sub_823F8DE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F30 size=16
    let mut pc: u32 = 0x823F8F30;
    'dispatch: loop {
        match pc {
            0x823F8F30 => {
    //   block [0x823F8F30..0x823F8F40)
	// 823F8F30: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8F34: 906B37A8  stw r3, 0x37a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14248 as u32), ctx.r[3].u32 ) };
	// 823F8F38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F40 size=16
    let mut pc: u32 = 0x823F8F40;
    'dispatch: loop {
        match pc {
            0x823F8F40 => {
    //   block [0x823F8F40..0x823F8F50)
	// 823F8F40: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8F44: 906B37AC  stw r3, 0x37ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14252 as u32), ctx.r[3].u32 ) };
	// 823F8F48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F50 size=16
    let mut pc: u32 = 0x823F8F50;
    'dispatch: loop {
        match pc {
            0x823F8F50 => {
    //   block [0x823F8F50..0x823F8F60)
	// 823F8F50: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8F54: 906B37B0  stw r3, 0x37b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14256 as u32), ctx.r[3].u32 ) };
	// 823F8F58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F60 size=16
    let mut pc: u32 = 0x823F8F60;
    'dispatch: loop {
        match pc {
            0x823F8F60 => {
    //   block [0x823F8F60..0x823F8F70)
	// 823F8F60: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8F64: 906B37B4  stw r3, 0x37b4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14260 as u32), ctx.r[3].u32 ) };
	// 823F8F68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F70 size=16
    let mut pc: u32 = 0x823F8F70;
    'dispatch: loop {
        match pc {
            0x823F8F70 => {
    //   block [0x823F8F70..0x823F8F80)
	// 823F8F70: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8F74: 906B37B8  stw r3, 0x37b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14264 as u32), ctx.r[3].u32 ) };
	// 823F8F78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823F8F80 size=16
    let mut pc: u32 = 0x823F8F80;
    'dispatch: loop {
        match pc {
            0x823F8F80 => {
    //   block [0x823F8F80..0x823F8F90)
	// 823F8F80: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823F8F84: 906B37BC  stw r3, 0x37bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(14268 as u32), ctx.r[3].u32 ) };
	// 823F8F88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823F8F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823F8F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823F8F90 size=4448
    let mut pc: u32 = 0x823F8F90;
    'dispatch: loop {
        match pc {
            0x823F8F90 => {
    //   block [0x823F8F90..0x823F8FC8)
	// 823F8F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823F8F94: 4813C109  bl 0x8253509c
	ctx.lr = 0x823F8F98;
	sub_82535080(ctx, base);
	// 823F8F98: A1660008  lhz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 823F8F9C: 3AA60008  addi r21, r6, 8
	ctx.r[21].s64 = ctx.r[6].s64 + 8;
	// 823F8FA0: A126001A  lhz r9, 0x1a(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(26 as u32) ) } as u64;
	// 823F8FA4: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F8FA8: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 823F8FAC: 7D497E70  srawi r9, r10, 0xf
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 15) as i64;
	// 823F8FB0: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 823F8FB4: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 823F8FB8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F8FBC: 419A000C  beq cr6, 0x823f8fc8
	if ctx.cr[6].eq {
	pc = 0x823F8FC8; continue 'dispatch;
	}
	// 823F8FC0: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 823F8FC4: 554A04FE  clrlwi r10, r10, 0x13
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F8FC8; continue 'dispatch;
            }
            0x823F8FC8 => {
    //   block [0x823F8FC8..0x823F8FE0)
	// 823F8FC8: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823F8FCC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F8FD0: 21290020  subfic r9, r9, 0x20
	ctx.xer.ca = ctx.r[9].u32 <= 32 as u32;
	ctx.r[9].s64 = (32 as i64) - ctx.r[9].s64;
	// 823F8FD4: 409A000C  bne cr6, 0x823f8fe0
	if !ctx.cr[6].eq {
	pc = 0x823F8FE0; continue 'dispatch;
	}
	// 823F8FD8: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 823F8FDC: 4800000C  b 0x823f8fe8
	pc = 0x823F8FE8; continue 'dispatch;
            }
            0x823F8FE0 => {
    //   block [0x823F8FE0..0x823F8FE8)
	// 823F8FE0: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F8FE4: 7D4A4E30  sraw r10, r10, r9
	tmp.u32 = ctx.r[9].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	pc = 0x823F8FE8; continue 'dispatch;
            }
            0x823F8FE8 => {
    //   block [0x823F8FE8..0x823F9024)
	// 823F8FE8: 7D675670  srawi r7, r11, 0xa
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 10) as i64;
	// 823F8FEC: 7D7F3670  srawi r31, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 823F8FF0: 557E06BE  clrlwi r30, r11, 0x1a
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 823F8FF4: 57EB073E  clrlwi r11, r31, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 823F8FF8: 7D5E51D6  mullw r10, r30, r10
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F8FFC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F9000: 54E907FE  clrlwi r9, r7, 0x1f
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 823F9004: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823F9008: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F900C: 7D284278  xor r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 ^ ctx.r[8].u64;
	// 823F9010: 554A1830  rlwinm r10, r10, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F9014: 41990010  bgt cr6, 0x823f9024
	if ctx.cr[6].gt {
	pc = 0x823F9024; continue 'dispatch;
	}
	// 823F9018: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F901C: 7D495E30  sraw r9, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9020: 48000010  b 0x823f9030
	pc = 0x823F9030; continue 'dispatch;
            }
            0x823F9024 => {
    //   block [0x823F9024..0x823F9030)
	// 823F9024: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F9028: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F902C: 5569047E  clrlwi r9, r11, 0x11
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F9030; continue 'dispatch;
            }
            0x823F9030 => {
    //   block [0x823F9030..0x823F9078)
	// 823F9030: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 823F9034: A146000A  lhz r10, 0xa(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(10 as u32) ) } as u64;
	// 823F9038: A3E6001C  lhz r31, 0x1c(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 823F903C: 7CE900D0  neg r7, r9
	ctx.r[7].s64 = -ctx.r[9].s64;
	// 823F9040: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F9044: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F9048: 7D3E5878  andc r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F904C: 7CEB5838  and r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 823F9050: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 823F9054: 7D1F7E70  srawi r31, r8, 0xf
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 15) as i64;
	// 823F9058: 7FCB5B78  or r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 | ctx.r[11].u64;
	// 823F905C: 57E907FE  clrlwi r9, r31, 0x1f
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9060: 7D790734  extsh r25, r11
	ctx.r[25].s64 = ctx.r[11].s16 as i64;
	// 823F9064: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F9068: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 823F906C: 419A000C  beq cr6, 0x823f9078
	if ctx.cr[6].eq {
	pc = 0x823F9078; continue 'dispatch;
	}
	// 823F9070: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F9074: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F9078; continue 'dispatch;
            }
            0x823F9078 => {
    //   block [0x823F9078..0x823F9090)
	// 823F9078: 7D680034  cntlzw r8, r11
	ctx.r[8].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F907C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9080: 20E80020  subfic r7, r8, 0x20
	ctx.xer.ca = ctx.r[8].u32 <= 32 as u32;
	ctx.r[7].s64 = (32 as i64) - ctx.r[8].s64;
	// 823F9084: 409A000C  bne cr6, 0x823f9090
	if !ctx.cr[6].eq {
	pc = 0x823F9090; continue 'dispatch;
	}
	// 823F9088: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823F908C: 4800000C  b 0x823f9098
	pc = 0x823F9098; continue 'dispatch;
            }
            0x823F9090 => {
    //   block [0x823F9090..0x823F9098)
	// 823F9090: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F9094: 7D683E30  sraw r8, r11, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F9098; continue 'dispatch;
            }
            0x823F9098 => {
    //   block [0x823F9098..0x823F90D4)
	// 823F9098: 7D5F5670  srawi r31, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 823F909C: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F90A0: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F90A4: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F90A8: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F90AC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823F90B0: 57E807FE  clrlwi r8, r31, 0x1f
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F90B4: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823F90B8: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F90BC: 7D084A78  xor r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[9].u64;
	// 823F90C0: 554A1830  rlwinm r10, r10, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F90C4: 41990010  bgt cr6, 0x823f90d4
	if ctx.cr[6].gt {
	pc = 0x823F90D4; continue 'dispatch;
	}
	// 823F90C8: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F90CC: 7D495E30  sraw r9, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F90D0: 48000010  b 0x823f90e0
	pc = 0x823F90E0; continue 'dispatch;
            }
            0x823F90D4 => {
    //   block [0x823F90D4..0x823F90E0)
	// 823F90D4: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F90D8: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F90DC: 5569047E  clrlwi r9, r11, 0x11
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F90E0; continue 'dispatch;
            }
            0x823F90E0 => {
    //   block [0x823F90E0..0x823F9128)
	// 823F90E0: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 823F90E4: A146000C  lhz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 823F90E8: A3E6001E  lhz r31, 0x1e(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(30 as u32) ) } as u64;
	// 823F90EC: 7CE900D0  neg r7, r9
	ctx.r[7].s64 = -ctx.r[9].s64;
	// 823F90F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F90F4: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F90F8: 7D3E5878  andc r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F90FC: 7CEB5838  and r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 823F9100: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 823F9104: 7D1F7E70  srawi r31, r8, 0xf
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 15) as i64;
	// 823F9108: 7FCB5B78  or r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 | ctx.r[11].u64;
	// 823F910C: 57E907FE  clrlwi r9, r31, 0x1f
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9110: 7D7A0734  extsh r26, r11
	ctx.r[26].s64 = ctx.r[11].s16 as i64;
	// 823F9114: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F9118: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 823F911C: 419A000C  beq cr6, 0x823f9128
	if ctx.cr[6].eq {
	pc = 0x823F9128; continue 'dispatch;
	}
	// 823F9120: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F9124: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F9128; continue 'dispatch;
            }
            0x823F9128 => {
    //   block [0x823F9128..0x823F9140)
	// 823F9128: 7D680034  cntlzw r8, r11
	ctx.r[8].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F912C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9130: 20E80020  subfic r7, r8, 0x20
	ctx.xer.ca = ctx.r[8].u32 <= 32 as u32;
	ctx.r[7].s64 = (32 as i64) - ctx.r[8].s64;
	// 823F9134: 409A000C  bne cr6, 0x823f9140
	if !ctx.cr[6].eq {
	pc = 0x823F9140; continue 'dispatch;
	}
	// 823F9138: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823F913C: 4800000C  b 0x823f9148
	pc = 0x823F9148; continue 'dispatch;
            }
            0x823F9140 => {
    //   block [0x823F9140..0x823F9148)
	// 823F9140: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F9144: 7D683E30  sraw r8, r11, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F9148; continue 'dispatch;
            }
            0x823F9148 => {
    //   block [0x823F9148..0x823F9184)
	// 823F9148: 7D5F5670  srawi r31, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 823F914C: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F9150: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F9154: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F9158: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F915C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823F9160: 57E807FE  clrlwi r8, r31, 0x1f
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9164: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823F9168: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F916C: 7D084A78  xor r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[9].u64;
	// 823F9170: 554A1830  rlwinm r10, r10, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F9174: 41990010  bgt cr6, 0x823f9184
	if ctx.cr[6].gt {
	pc = 0x823F9184; continue 'dispatch;
	}
	// 823F9178: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F917C: 7D495E30  sraw r9, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9180: 48000010  b 0x823f9190
	pc = 0x823F9190; continue 'dispatch;
            }
            0x823F9184 => {
    //   block [0x823F9184..0x823F9190)
	// 823F9184: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F9188: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F918C: 5569047E  clrlwi r9, r11, 0x11
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F9190; continue 'dispatch;
            }
            0x823F9190 => {
    //   block [0x823F9190..0x823F91D8)
	// 823F9190: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 823F9194: A146000E  lhz r10, 0xe(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(14 as u32) ) } as u64;
	// 823F9198: A3E60020  lhz r31, 0x20(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F919C: 7CE900D0  neg r7, r9
	ctx.r[7].s64 = -ctx.r[9].s64;
	// 823F91A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F91A4: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F91A8: 7D3E5878  andc r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F91AC: 7CEB5838  and r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 823F91B0: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 823F91B4: 7D1F7E70  srawi r31, r8, 0xf
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 15) as i64;
	// 823F91B8: 7FCB5B78  or r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 | ctx.r[11].u64;
	// 823F91BC: 57E907FE  clrlwi r9, r31, 0x1f
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F91C0: 7D7C0734  extsh r28, r11
	ctx.r[28].s64 = ctx.r[11].s16 as i64;
	// 823F91C4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F91C8: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 823F91CC: 419A000C  beq cr6, 0x823f91d8
	if ctx.cr[6].eq {
	pc = 0x823F91D8; continue 'dispatch;
	}
	// 823F91D0: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F91D4: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F91D8; continue 'dispatch;
            }
            0x823F91D8 => {
    //   block [0x823F91D8..0x823F91F0)
	// 823F91D8: 7D680034  cntlzw r8, r11
	ctx.r[8].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F91DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F91E0: 20E80020  subfic r7, r8, 0x20
	ctx.xer.ca = ctx.r[8].u32 <= 32 as u32;
	ctx.r[7].s64 = (32 as i64) - ctx.r[8].s64;
	// 823F91E4: 409A000C  bne cr6, 0x823f91f0
	if !ctx.cr[6].eq {
	pc = 0x823F91F0; continue 'dispatch;
	}
	// 823F91E8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823F91EC: 4800000C  b 0x823f91f8
	pc = 0x823F91F8; continue 'dispatch;
            }
            0x823F91F0 => {
    //   block [0x823F91F0..0x823F91F8)
	// 823F91F0: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F91F4: 7D683E30  sraw r8, r11, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F91F8; continue 'dispatch;
            }
            0x823F91F8 => {
    //   block [0x823F91F8..0x823F9234)
	// 823F91F8: 7D5F5670  srawi r31, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 823F91FC: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F9200: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F9204: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F9208: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F920C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823F9210: 57E807FE  clrlwi r8, r31, 0x1f
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9214: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823F9218: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F921C: 7D084A78  xor r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[9].u64;
	// 823F9220: 554A1830  rlwinm r10, r10, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F9224: 41990010  bgt cr6, 0x823f9234
	if ctx.cr[6].gt {
	pc = 0x823F9234; continue 'dispatch;
	}
	// 823F9228: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F922C: 7D495E30  sraw r9, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9230: 48000010  b 0x823f9240
	pc = 0x823F9240; continue 'dispatch;
            }
            0x823F9234 => {
    //   block [0x823F9234..0x823F9240)
	// 823F9234: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F9238: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F923C: 5569047E  clrlwi r9, r11, 0x11
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F9240; continue 'dispatch;
            }
            0x823F9240 => {
    //   block [0x823F9240..0x823F9288)
	// 823F9240: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 823F9244: A1460010  lhz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 823F9248: A3E60022  lhz r31, 0x22(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(34 as u32) ) } as u64;
	// 823F924C: 7CE900D0  neg r7, r9
	ctx.r[7].s64 = -ctx.r[9].s64;
	// 823F9250: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F9254: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F9258: 7D3E5878  andc r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F925C: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 823F9260: 7CEB5838  and r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 823F9264: 7D1F7E70  srawi r31, r8, 0xf
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 15) as i64;
	// 823F9268: 7FCB5B78  or r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 | ctx.r[11].u64;
	// 823F926C: 57E907FE  clrlwi r9, r31, 0x1f
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9270: 7D7F0734  extsh r31, r11
	ctx.r[31].s64 = ctx.r[11].s16 as i64;
	// 823F9274: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F9278: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 823F927C: 419A000C  beq cr6, 0x823f9288
	if ctx.cr[6].eq {
	pc = 0x823F9288; continue 'dispatch;
	}
	// 823F9280: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F9284: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F9288; continue 'dispatch;
            }
            0x823F9288 => {
    //   block [0x823F9288..0x823F92A0)
	// 823F9288: 7D680034  cntlzw r8, r11
	ctx.r[8].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F928C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9290: 20E80020  subfic r7, r8, 0x20
	ctx.xer.ca = ctx.r[8].u32 <= 32 as u32;
	ctx.r[7].s64 = (32 as i64) - ctx.r[8].s64;
	// 823F9294: 409A000C  bne cr6, 0x823f92a0
	if !ctx.cr[6].eq {
	pc = 0x823F92A0; continue 'dispatch;
	}
	// 823F9298: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 823F929C: 4800000C  b 0x823f92a8
	pc = 0x823F92A8; continue 'dispatch;
            }
            0x823F92A0 => {
    //   block [0x823F92A0..0x823F92A8)
	// 823F92A0: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F92A4: 7D683E30  sraw r8, r11, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F92A8; continue 'dispatch;
            }
            0x823F92A8 => {
    //   block [0x823F92A8..0x823F92E4)
	// 823F92A8: 7D5E5670  srawi r30, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 823F92AC: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F92B0: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F92B4: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F92B8: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F92BC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823F92C0: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 823F92C4: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823F92C8: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F92CC: 7D084A78  xor r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[9].u64;
	// 823F92D0: 554A1830  rlwinm r10, r10, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F92D4: 41990010  bgt cr6, 0x823f92e4
	if ctx.cr[6].gt {
	pc = 0x823F92E4; continue 'dispatch;
	}
	// 823F92D8: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F92DC: 7D495E30  sraw r9, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F92E0: 48000010  b 0x823f92f0
	pc = 0x823F92F0; continue 'dispatch;
            }
            0x823F92E4 => {
    //   block [0x823F92E4..0x823F92F0)
	// 823F92E4: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F92E8: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F92EC: 5569047E  clrlwi r9, r11, 0x11
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F92F0; continue 'dispatch;
            }
            0x823F92F0 => {
    //   block [0x823F92F0..0x823F9338)
	// 823F92F0: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 823F92F4: A1460012  lhz r10, 0x12(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 823F92F8: A3C60024  lhz r30, 0x24(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 823F92FC: 7CE900D0  neg r7, r9
	ctx.r[7].s64 = -ctx.r[9].s64;
	// 823F9300: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F9304: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F9308: 7D3D5878  andc r29, r9, r11
	ctx.r[29].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F930C: 7CEB5838  and r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 823F9310: 7FCA0734  extsh r10, r30
	ctx.r[10].s64 = ctx.r[30].s16 as i64;
	// 823F9314: 7D1E7E70  srawi r30, r8, 0xf
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[8].s32 >> 15) as i64;
	// 823F9318: 7FAB5B78  or r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 | ctx.r[11].u64;
	// 823F931C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 823F9320: 7D670734  extsh r7, r11
	ctx.r[7].s64 = ctx.r[11].s16 as i64;
	// 823F9324: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823F9328: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 823F932C: 419A000C  beq cr6, 0x823f9338
	if ctx.cr[6].eq {
	pc = 0x823F9338; continue 'dispatch;
	}
	// 823F9330: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F9334: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F9338; continue 'dispatch;
            }
            0x823F9338 => {
    //   block [0x823F9338..0x823F9350)
	// 823F9338: 7D680034  cntlzw r8, r11
	ctx.r[8].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F933C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9340: 21080020  subfic r8, r8, 0x20
	ctx.xer.ca = ctx.r[8].u32 <= 32 as u32;
	ctx.r[8].s64 = (32 as i64) - ctx.r[8].s64;
	// 823F9344: 409A000C  bne cr6, 0x823f9350
	if !ctx.cr[6].eq {
	pc = 0x823F9350; continue 'dispatch;
	}
	// 823F9348: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 823F934C: 4800000C  b 0x823f9358
	pc = 0x823F9358; continue 'dispatch;
            }
            0x823F9350 => {
    //   block [0x823F9350..0x823F9358)
	// 823F9350: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F9354: 7D6B4630  sraw r11, r11, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F9358; continue 'dispatch;
            }
            0x823F9358 => {
    //   block [0x823F9358..0x823F9394)
	// 823F9358: 7D5E5670  srawi r30, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 823F935C: 7D5D3670  srawi r29, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F9360: 555B06BE  clrlwi r27, r10, 0x1a
	ctx.r[27].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F9364: 57AA073E  clrlwi r10, r29, 0x1c
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x0000000Fu64;
	// 823F9368: 7D7B59D6  mullw r11, r27, r11
	ctx.r[11].s32 = ((ctx.r[27].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F936C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823F9370: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 823F9374: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 823F9378: 7D0B4A78  xor r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 ^ ctx.r[9].u64;
	// 823F937C: 2F0A001A  cmpwi cr6, r10, 0x1a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 26, &mut ctx.xer);
	// 823F9380: 57C91830  rlwinm r9, r30, 3, 0, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 823F9384: 41990010  bgt cr6, 0x823f9394
	if ctx.cr[6].gt {
	pc = 0x823F9394; continue 'dispatch;
	}
	// 823F9388: 214A001A  subfic r10, r10, 0x1a
	ctx.xer.ca = ctx.r[10].u32 <= 26 as u32;
	ctx.r[10].s64 = (26 as i64) - ctx.r[10].s64;
	// 823F938C: 7D2A5630  sraw r10, r9, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 823F9390: 48000010  b 0x823f93a0
	pc = 0x823F93A0; continue 'dispatch;
            }
            0x823F9394 => {
    //   block [0x823F9394..0x823F93A0)
	// 823F9394: 394AFFE6  addi r10, r10, -0x1a
	ctx.r[10].s64 = ctx.r[10].s64 + -26;
	// 823F9398: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823F939C: 554A047E  clrlwi r10, r10, 0x11
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F93A0; continue 'dispatch;
            }
            0x823F93A0 => {
    //   block [0x823F93A0..0x823F9410)
	// 823F93A0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 823F93A4: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F93A8: 7F0A00D0  neg r24, r10
	ctx.r[24].s64 = -ctx.r[10].s64;
	// 823F93AC: A366002A  lhz r27, 0x2a(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(42 as u32) ) } as u64;
	// 823F93B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F93B4: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 823F93B8: 7D595878  andc r25, r10, r11
	ctx.r[25].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 823F93BC: 7F0B5838  and r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 & ctx.r[11].u64;
	// 823F93C0: 7CFD0734  extsh r29, r7
	ctx.r[29].s64 = ctx.r[7].s16 as i64;
	// 823F93C4: 7F2B5B78  or r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 | ctx.r[11].u64;
	// 823F93C8: 7FFE0734  extsh r30, r31
	ctx.r[30].s64 = ctx.r[31].s16 as i64;
	// 823F93CC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823F93D0: 7F9F0734  extsh r31, r28
	ctx.r[31].s64 = ctx.r[28].s16 as i64;
	// 823F93D4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823F93D8: 7F470734  extsh r7, r26
	ctx.r[7].s64 = ctx.r[26].s16 as i64;
	// 823F93DC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823F93E0: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823F93E4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823F93E8: 7D3A7E70  srawi r26, r9, 0xf
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[9].s32 >> 15) as i64;
	// 823F93EC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823F93F0: 574A07FE  clrlwi r10, r26, 0x1f
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 823F93F4: 7D7E0734  extsh r30, r11
	ctx.r[30].s64 = ctx.r[11].s16 as i64;
	// 823F93F8: 7F7C0734  extsh r28, r27
	ctx.r[28].s64 = ctx.r[27].s16 as i64;
	// 823F93FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F9400: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 823F9404: 419A000C  beq cr6, 0x823f9410
	if ctx.cr[6].eq {
	pc = 0x823F9410; continue 'dispatch;
	}
	// 823F9408: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F940C: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F9410; continue 'dispatch;
            }
            0x823F9410 => {
    //   block [0x823F9410..0x823F9428)
	// 823F9410: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F9414: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9418: 21090020  subfic r8, r9, 0x20
	ctx.xer.ca = ctx.r[9].u32 <= 32 as u32;
	ctx.r[8].s64 = (32 as i64) - ctx.r[9].s64;
	// 823F941C: 409A000C  bne cr6, 0x823f9428
	if !ctx.cr[6].eq {
	pc = 0x823F9428; continue 'dispatch;
	}
	// 823F9420: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 823F9424: 4800000C  b 0x823f9430
	pc = 0x823F9430; continue 'dispatch;
            }
            0x823F9428 => {
    //   block [0x823F9428..0x823F9430)
	// 823F9428: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F942C: 7D694630  sraw r9, r11, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F9430; continue 'dispatch;
            }
            0x823F9430 => {
    //   block [0x823F9430..0x823F946C)
	// 823F9430: 7F875670  srawi r7, r28, 0xa
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[28].s32 >> 10) as i64;
	// 823F9434: 7F8B3670  srawi r11, r28, 6
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 6) as i64;
	// 823F9438: 579F06BE  clrlwi r31, r28, 0x1a
	ctx.r[31].u64 = ctx.r[28].u32 as u64 & 0x0000003Fu64;
	// 823F943C: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F9440: 7D3F49D6  mullw r9, r31, r9
	ctx.r[9].s32 = ((ctx.r[31].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823F9444: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823F9448: 54E807FE  clrlwi r8, r7, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 823F944C: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 823F9450: 7D085278  xor r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[10].u64;
	// 823F9454: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F9458: 552A1830  rlwinm r10, r9, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 823F945C: 41990010  bgt cr6, 0x823f946c
	if ctx.cr[6].gt {
	pc = 0x823F946C; continue 'dispatch;
	}
	// 823F9460: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F9464: 7D495E30  sraw r9, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9468: 48000010  b 0x823f9478
	pc = 0x823F9478; continue 'dispatch;
            }
            0x823F946C => {
    //   block [0x823F946C..0x823F9478)
	// 823F946C: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F9470: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F9474: 5569047E  clrlwi r9, r11, 0x11
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F9478; continue 'dispatch;
            }
            0x823F9478 => {
    //   block [0x823F9478..0x823F94C0)
	// 823F9478: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 823F947C: A1460002  lhz r10, 2(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 823F9480: 7CE900D0  neg r7, r9
	ctx.r[7].s64 = -ctx.r[9].s64;
	// 823F9484: A3E6002C  lhz r31, 0x2c(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(44 as u32) ) } as u64;
	// 823F9488: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F948C: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F9490: 7CFD5838  and r29, r7, r11
	ctx.r[29].u64 = ctx.r[7].u64 & ctx.r[11].u64;
	// 823F9494: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 823F9498: 7D2B5878  andc r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 823F949C: 7D1F7E70  srawi r31, r8, 0xf
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 15) as i64;
	// 823F94A0: 7FAB5B78  or r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 | ctx.r[11].u64;
	// 823F94A4: 57E707FE  clrlwi r7, r31, 0x1f
	ctx.r[7].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F94A8: 7D7F0734  extsh r31, r11
	ctx.r[31].s64 = ctx.r[11].s16 as i64;
	// 823F94AC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823F94B0: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 823F94B4: 419A000C  beq cr6, 0x823f94c0
	if ctx.cr[6].eq {
	pc = 0x823F94C0; continue 'dispatch;
	}
	// 823F94B8: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F94BC: 556B04FE  clrlwi r11, r11, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	pc = 0x823F94C0; continue 'dispatch;
            }
            0x823F94C0 => {
    //   block [0x823F94C0..0x823F94D8)
	// 823F94C0: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F94C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F94C8: 21090020  subfic r8, r9, 0x20
	ctx.xer.ca = ctx.r[9].u32 <= 32 as u32;
	ctx.r[8].s64 = (32 as i64) - ctx.r[9].s64;
	// 823F94CC: 409A000C  bne cr6, 0x823f94d8
	if !ctx.cr[6].eq {
	pc = 0x823F94D8; continue 'dispatch;
	}
	// 823F94D0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 823F94D4: 4800000C  b 0x823f94e0
	pc = 0x823F94E0; continue 'dispatch;
            }
            0x823F94D8 => {
    //   block [0x823F94D8..0x823F94E0)
	// 823F94D8: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F94DC: 7D694630  sraw r9, r11, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> tmp.u32) as i64;
	pc = 0x823F94E0; continue 'dispatch;
            }
            0x823F94E0 => {
    //   block [0x823F94E0..0x823F951C)
	// 823F94E0: 7D5D5670  srawi r29, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 823F94E4: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F94E8: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F94EC: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F94F0: 7D4A49D6  mullw r10, r10, r9
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823F94F4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823F94F8: 57A907FE  clrlwi r9, r29, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 823F94FC: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 823F9500: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 823F9504: 7D293A78  xor r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[7].u64;
	// 823F9508: 554A1830  rlwinm r10, r10, 3, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 823F950C: 41990010  bgt cr6, 0x823f951c
	if ctx.cr[6].gt {
	pc = 0x823F951C; continue 'dispatch;
	}
	// 823F9510: 216B001A  subfic r11, r11, 0x1a
	ctx.xer.ca = ctx.r[11].u32 <= 26 as u32;
	ctx.r[11].s64 = (26 as i64) - ctx.r[11].s64;
	// 823F9514: 7D4A5E30  sraw r10, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9518: 48000010  b 0x823f9528
	pc = 0x823F9528; continue 'dispatch;
            }
            0x823F951C => {
    //   block [0x823F951C..0x823F9528)
	// 823F951C: 396BFFE6  addi r11, r11, -0x1a
	ctx.r[11].s64 = ctx.r[11].s64 + -26;
	// 823F9520: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F9524: 556A047E  clrlwi r10, r11, 0x11
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	pc = 0x823F9528; continue 'dispatch;
            }
            0x823F9528 => {
    //   block [0x823F9528..0x823F957C)
	// 823F9528: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 823F952C: A0E60004  lhz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823F9530: 7FAA00D0  neg r29, r10
	ctx.r[29].s64 = -ctx.r[10].s64;
	// 823F9534: B366002C  sth r27, 0x2c(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(44 as u32), ctx.r[27].u16 ) };
	// 823F9538: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F953C: 7FE80734  extsh r8, r31
	ctx.r[8].s64 = ctx.r[31].s16 as i64;
	// 823F9540: 7FDF0734  extsh r31, r30
	ctx.r[31].s64 = ctx.r[30].s16 as i64;
	// 823F9544: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 823F9548: 7FBE5838  and r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 & ctx.r[11].u64;
	// 823F954C: 7D4B5878  andc r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 823F9550: 7FF80E70  srawi r24, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 823F9554: 7D6BF378  or r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[30].u64;
	// 823F9558: 7CFF0734  extsh r31, r7
	ctx.r[31].s64 = ctx.r[7].s16 as i64;
	// 823F955C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823F9560: 2F1F0100  cmpwi cr6, r31, 0x100
	ctx.cr[6].compare_i32(ctx.r[31].s32, 256, &mut ctx.xer);
	// 823F9564: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F9568: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F956C: 7D790E70  srawi r25, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[25].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 823F9570: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823F9574: 41980008  blt cr6, 0x823f957c
	if ctx.cr[6].lt {
	pc = 0x823F957C; continue 'dispatch;
	}
	// 823F9578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823F957C; continue 'dispatch;
            }
            0x823F957C => {
    //   block [0x823F957C..0x823F9594)
	// 823F957C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F9580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823F9584: 419A0010  beq cr6, 0x823f9594
	if ctx.cr[6].eq {
	pc = 0x823F9594; continue 'dispatch;
	}
	// 823F9588: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 823F958C: 7D691670  srawi r9, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 823F9590: 48000008  b 0x823f9598
	pc = 0x823F9598; continue 'dispatch;
            }
            0x823F9594 => {
    //   block [0x823F9594..0x823F9598)
	// 823F9594: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	pc = 0x823F9598; continue 'dispatch;
            }
            0x823F9598 => {
    //   block [0x823F9598..0x823F95BC)
	// 823F9598: A3860032  lhz r28, 0x32(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(50 as u32) ) } as u64;
	// 823F959C: A1660034  lhz r11, 0x34(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(52 as u32) ) } as u64;
	// 823F95A0: 7D7C5850  subf r11, r28, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 823F95A4: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F95A8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823F95AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F95B0: 4098000C  bge cr6, 0x823f95bc
	if !ctx.cr[6].lt {
	pc = 0x823F95BC; continue 'dispatch;
	}
	// 823F95B4: 7D4B00D0  neg r10, r11
	ctx.r[10].s64 = -ctx.r[11].s64;
	// 823F95B8: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	pc = 0x823F95BC; continue 'dispatch;
            }
            0x823F95BC => {
    //   block [0x823F95BC..0x823F95DC)
	// 823F95BC: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F95C0: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823F95C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F95C8: 7D6A49D6  mullw r11, r10, r9
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823F95CC: 7D6B3670  srawi r11, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 823F95D0: 4098000C  bge cr6, 0x823f95dc
	if !ctx.cr[6].lt {
	pc = 0x823F95DC; continue 'dispatch;
	}
	// 823F95D4: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 823F95D8: 48000008  b 0x823f95e0
	pc = 0x823F95E0; continue 'dispatch;
            }
            0x823F95DC => {
    //   block [0x823F95DC..0x823F95E0)
	// 823F95DC: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	pc = 0x823F95E0; continue 'dispatch;
            }
            0x823F95E0 => {
    //   block [0x823F95E0..0x823F95F4)
	// 823F95E0: 7D7E0734  extsh r30, r11
	ctx.r[30].s64 = ctx.r[11].s16 as i64;
	// 823F95E4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823F95E8: 419A000C  beq cr6, 0x823f95f4
	if ctx.cr[6].eq {
	pc = 0x823F95F4; continue 'dispatch;
	}
	// 823F95EC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823F95F0: 4800028C  b 0x823f987c
	pc = 0x823F987C; continue 'dispatch;
            }
            0x823F95F4 => {
    //   block [0x823F95F4..0x823F9614)
	// 823F95F4: 7D792050  subf r11, r25, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[25].s64;
	// 823F95F8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F95FC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823F9600: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823F9604: 40980010  bge cr6, 0x823f9614
	if !ctx.cr[6].lt {
	pc = 0x823F9614; continue 'dispatch;
	}
	// 823F9608: 7D6700D0  neg r11, r7
	ctx.r[11].s64 = -ctx.r[7].s64;
	// 823F960C: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 823F9610: 48000008  b 0x823f9618
	pc = 0x823F9618; continue 'dispatch;
            }
            0x823F9614 => {
    //   block [0x823F9614..0x823F9618)
	// 823F9614: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x823F9618; continue 'dispatch;
            }
            0x823F9618 => {
    //   block [0x823F9618..0x823F9644)
	// 823F9618: 7D090734  extsh r9, r8
	ctx.r[9].s64 = ctx.r[8].s16 as i64;
	// 823F961C: 612B0001  ori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 | 1;
	// 823F9620: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F9624: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823F9628: 554A8FFE  rlwinm r10, r10, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 823F962C: 556497FE  rlwinm r4, r11, 0x12, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 823F9630: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F9634: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9638: 419A000C  beq cr6, 0x823f9644
	if ctx.cr[6].eq {
	pc = 0x823F9644; continue 'dispatch;
	}
	// 823F963C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 823F9640: 48000150  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F9644 => {
    //   block [0x823F9644..0x823F965C)
	// 823F9644: 55649FFE  rlwinm r4, r11, 0x13, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00001FFFu64;
	// 823F9648: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F964C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9650: 419A000C  beq cr6, 0x823f965c
	if ctx.cr[6].eq {
	pc = 0x823F965C; continue 'dispatch;
	}
	// 823F9654: 3960000E  li r11, 0xe
	ctx.r[11].s64 = 14;
	// 823F9658: 48000138  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F965C => {
    //   block [0x823F965C..0x823F9674)
	// 823F965C: 5564A7FE  rlwinm r4, r11, 0x14, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 823F9660: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F9664: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9668: 419A000C  beq cr6, 0x823f9674
	if ctx.cr[6].eq {
	pc = 0x823F9674; continue 'dispatch;
	}
	// 823F966C: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 823F9670: 48000120  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F9674 => {
    //   block [0x823F9674..0x823F968C)
	// 823F9674: 5564AFFE  rlwinm r4, r11, 0x15, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000007FFu64;
	// 823F9678: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F967C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9680: 419A000C  beq cr6, 0x823f968c
	if ctx.cr[6].eq {
	pc = 0x823F968C; continue 'dispatch;
	}
	// 823F9684: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 823F9688: 48000108  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F968C => {
    //   block [0x823F968C..0x823F96A4)
	// 823F968C: 5564B7FE  rlwinm r4, r11, 0x16, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 823F9690: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F9694: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9698: 419A000C  beq cr6, 0x823f96a4
	if ctx.cr[6].eq {
	pc = 0x823F96A4; continue 'dispatch;
	}
	// 823F969C: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 823F96A0: 480000F0  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F96A4 => {
    //   block [0x823F96A4..0x823F96BC)
	// 823F96A4: 5564BFFE  rlwinm r4, r11, 0x17, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 823F96A8: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F96AC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F96B0: 419A000C  beq cr6, 0x823f96bc
	if ctx.cr[6].eq {
	pc = 0x823F96BC; continue 'dispatch;
	}
	// 823F96B4: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 823F96B8: 480000D8  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F96BC => {
    //   block [0x823F96BC..0x823F96D4)
	// 823F96BC: 5564C7FE  rlwinm r4, r11, 0x18, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823F96C0: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F96C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F96C8: 419A000C  beq cr6, 0x823f96d4
	if ctx.cr[6].eq {
	pc = 0x823F96D4; continue 'dispatch;
	}
	// 823F96CC: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 823F96D0: 480000C0  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F96D4 => {
    //   block [0x823F96D4..0x823F96EC)
	// 823F96D4: 5564CFFE  rlwinm r4, r11, 0x19, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 823F96D8: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F96DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F96E0: 419A000C  beq cr6, 0x823f96ec
	if ctx.cr[6].eq {
	pc = 0x823F96EC; continue 'dispatch;
	}
	// 823F96E4: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 823F96E8: 480000A8  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F96EC => {
    //   block [0x823F96EC..0x823F9704)
	// 823F96EC: 5564D7FE  rlwinm r4, r11, 0x1a, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 823F96F0: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F96F4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F96F8: 419A000C  beq cr6, 0x823f9704
	if ctx.cr[6].eq {
	pc = 0x823F9704; continue 'dispatch;
	}
	// 823F96FC: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 823F9700: 48000090  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F9704 => {
    //   block [0x823F9704..0x823F971C)
	// 823F9704: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F9708: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F970C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9710: 419A000C  beq cr6, 0x823f971c
	if ctx.cr[6].eq {
	pc = 0x823F971C; continue 'dispatch;
	}
	// 823F9714: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 823F9718: 48000078  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F971C => {
    //   block [0x823F971C..0x823F9734)
	// 823F971C: 5564E7FE  rlwinm r4, r11, 0x1c, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823F9720: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F9724: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9728: 419A000C  beq cr6, 0x823f9734
	if ctx.cr[6].eq {
	pc = 0x823F9734; continue 'dispatch;
	}
	// 823F972C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823F9730: 48000060  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F9734 => {
    //   block [0x823F9734..0x823F974C)
	// 823F9734: 5564EFFE  rlwinm r4, r11, 0x1d, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 823F9738: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F973C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9740: 419A000C  beq cr6, 0x823f974c
	if ctx.cr[6].eq {
	pc = 0x823F974C; continue 'dispatch;
	}
	// 823F9744: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F9748: 48000048  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F974C => {
    //   block [0x823F974C..0x823F9764)
	// 823F974C: 5564F7FE  rlwinm r4, r11, 0x1e, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 823F9750: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F9754: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9758: 419A000C  beq cr6, 0x823f9764
	if ctx.cr[6].eq {
	pc = 0x823F9764; continue 'dispatch;
	}
	// 823F975C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F9760: 48000030  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F9764 => {
    //   block [0x823F9764..0x823F977C)
	// 823F9764: 5564FFFE  rlwinm r4, r11, 0x1f, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 823F9768: 7C845278  xor r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 ^ ctx.r[10].u64;
	// 823F976C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 823F9770: 419A000C  beq cr6, 0x823f977c
	if ctx.cr[6].eq {
	pc = 0x823F977C; continue 'dispatch;
	}
	// 823F9774: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F9778: 48000018  b 0x823f9790
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F977C => {
    //   block [0x823F977C..0x823F9790)
	// 823F977C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 823F9780: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 823F9784: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F9788: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F978C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823F9790; continue 'dispatch;
            }
            0x823F9790 => {
    //   block [0x823F9790..0x823F97BC)
	// 823F9790: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F9794: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F9798: 216A0007  subfic r11, r10, 7
	ctx.xer.ca = ctx.r[10].u32 <= 7 as u32;
	ctx.r[11].s64 = (7 as i64) - ctx.r[10].s64;
	// 823F979C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F97A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F97A4: 40980018  bge cr6, 0x823f97bc
	if !ctx.cr[6].lt {
	pc = 0x823F97BC; continue 'dispatch;
	}
	// 823F97A8: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F97AC: 7D090734  extsh r9, r8
	ctx.r[9].s64 = ctx.r[8].s16 as i64;
	// 823F97B0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F97B4: 7D2B5E30  sraw r11, r9, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 823F97B8: 4800000C  b 0x823f97c4
	pc = 0x823F97C4; continue 'dispatch;
            }
            0x823F97BC => {
    //   block [0x823F97BC..0x823F97C4)
	// 823F97BC: 7D2B5830  slw r11, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F97C0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	pc = 0x823F97C4; continue 'dispatch;
            }
            0x823F97C4 => {
    //   block [0x823F97C4..0x823F97F8)
	// 823F97C4: 554A3830  slwi r10, r10, 7
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(7);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F97C8: 7FC90734  extsh r9, r30
	ctx.r[9].s64 = ctx.r[30].s16 as i64;
	// 823F97CC: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F97D0: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 823F97D4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823F97D8: 7D695050  subf r11, r9, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 823F97DC: 550A067E  clrlwi r10, r8, 0x19
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x0000007Fu64;
	// 823F97E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F97E4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F97E8: 2F0BFF84  cmpwi cr6, r11, -0x7c
	ctx.cr[6].compare_i32(ctx.r[11].s32, -124, &mut ctx.xer);
	// 823F97EC: 4098000C  bge cr6, 0x823f97f8
	if !ctx.cr[6].lt {
	pc = 0x823F97F8; continue 'dispatch;
	}
	// 823F97F0: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 823F97F4: 4800006C  b 0x823f9860
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F97F8 => {
    //   block [0x823F97F8..0x823F9810)
	// 823F97F8: 2F0B0050  cmpwi cr6, r11, 0x50
	ctx.cr[6].compare_i32(ctx.r[11].s32, 80, &mut ctx.xer);
	// 823F97FC: 41980060  blt cr6, 0x823f985c
	if ctx.cr[6].lt {
	pc = 0x823F985C; continue 'dispatch;
	}
	// 823F9800: 2F0B00B2  cmpwi cr6, r11, 0xb2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 178, &mut ctx.xer);
	// 823F9804: 4098000C  bge cr6, 0x823f9810
	if !ctx.cr[6].lt {
	pc = 0x823F9810; continue 'dispatch;
	}
	// 823F9808: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F980C: 48000054  b 0x823f9860
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F9810 => {
    //   block [0x823F9810..0x823F9820)
	// 823F9810: 2F0B00F6  cmpwi cr6, r11, 0xf6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 246, &mut ctx.xer);
	// 823F9814: 4098000C  bge cr6, 0x823f9820
	if !ctx.cr[6].lt {
	pc = 0x823F9820; continue 'dispatch;
	}
	// 823F9818: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F981C: 48000044  b 0x823f9860
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F9820 => {
    //   block [0x823F9820..0x823F9830)
	// 823F9820: 2F0B012C  cmpwi cr6, r11, 0x12c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 300, &mut ctx.xer);
	// 823F9824: 4098000C  bge cr6, 0x823f9830
	if !ctx.cr[6].lt {
	pc = 0x823F9830; continue 'dispatch;
	}
	// 823F9828: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F982C: 48000034  b 0x823f9860
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F9830 => {
    //   block [0x823F9830..0x823F9840)
	// 823F9830: 2F0B015D  cmpwi cr6, r11, 0x15d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 349, &mut ctx.xer);
	// 823F9834: 4098000C  bge cr6, 0x823f9840
	if !ctx.cr[6].lt {
	pc = 0x823F9840; continue 'dispatch;
	}
	// 823F9838: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823F983C: 48000024  b 0x823f9860
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F9840 => {
    //   block [0x823F9840..0x823F9850)
	// 823F9840: 2F0B0190  cmpwi cr6, r11, 0x190
	ctx.cr[6].compare_i32(ctx.r[11].s32, 400, &mut ctx.xer);
	// 823F9844: 4098000C  bge cr6, 0x823f9850
	if !ctx.cr[6].lt {
	pc = 0x823F9850; continue 'dispatch;
	}
	// 823F9848: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 823F984C: 48000014  b 0x823f9860
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F9850 => {
    //   block [0x823F9850..0x823F985C)
	// 823F9850: 2F0B0800  cmpwi cr6, r11, 0x800
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2048, &mut ctx.xer);
	// 823F9854: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 823F9858: 41980008  blt cr6, 0x823f9860
	if ctx.cr[6].lt {
	pc = 0x823F9860; continue 'dispatch;
	}
	pc = 0x823F985C; continue 'dispatch;
            }
            0x823F985C => {
    //   block [0x823F985C..0x823F9860)
	// 823F985C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x823F9860; continue 'dispatch;
            }
            0x823F9860 => {
    //   block [0x823F9860..0x823F987C)
	// 823F9860: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823F9864: 40980018  bge cr6, 0x823f987c
	if !ctx.cr[6].lt {
	pc = 0x823F987C; continue 'dispatch;
	}
	// 823F9868: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F986C: 2F0A000F  cmpwi cr6, r10, 0xf
	ctx.cr[6].compare_i32(ctx.r[10].s32, 15, &mut ctx.xer);
	// 823F9870: 419A000C  beq cr6, 0x823f987c
	if ctx.cr[6].eq {
	pc = 0x823F987C; continue 'dispatch;
	}
	// 823F9874: 7D4B50F8  nor r11, r10, r10
	ctx.r[11].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 823F9878: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	pc = 0x823F987C; continue 'dispatch;
            }
            0x823F987C => {
    //   block [0x823F987C..0x823F9890)
	// 823F987C: 7D7B0734  extsh r27, r11
	ctx.r[27].s64 = ctx.r[11].s16 as i64;
	// 823F9880: 7F7D1E71  srawi. r29, r27, 3
	ctx.xer.ca = (ctx.r[27].s32 < 0) && ((ctx.r[27].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[27].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F9884: 4182000C  beq 0x823f9890
	if ctx.cr[0].eq {
	pc = 0x823F9890; continue 'dispatch;
	}
	// 823F9888: 6B6B000F  xori r11, r27, 0xf
	ctx.r[11].u64 = ctx.r[27].u64 ^ 15;
	// 823F988C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	pc = 0x823F9890; continue 'dispatch;
            }
            0x823F9890 => {
    //   block [0x823F9890..0x823F98EC)
	// 823F9890: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F9894: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F9898: 5557083C  slwi r23, r10, 1
	ctx.r[23].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 823F989C: 396BD430  addi r11, r11, -0x2bd0
	ctx.r[11].s64 = ctx.r[11].s64 + -11216;
	// 823F98A0: 7FCA0734  extsh r10, r30
	ctx.r[10].s64 = ctx.r[30].s16 as i64;
	// 823F98A4: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 823F98A8: 7D775A2E  lhzx r11, r23, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F98AC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F98B0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F98B4: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 823F98B8: 55690570  rlwinm r9, r11, 0, 0x15, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823F98BC: 390A0080  addi r8, r10, 0x80
	ctx.r[8].s64 = ctx.r[10].s64 + 128;
	// 823F98C0: 7D2A3E70  srawi r10, r9, 7
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 7) as i64;
	// 823F98C4: 7D090734  extsh r9, r8
	ctx.r[9].s64 = ctx.r[8].s16 as i64;
	// 823F98C8: 394AFFF9  addi r10, r10, -7
	ctx.r[10].s64 = ctx.r[10].s64 + -7;
	// 823F98CC: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F98D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F98D4: 40980018  bge cr6, 0x823f98ec
	if !ctx.cr[6].lt {
	pc = 0x823F98EC; continue 'dispatch;
	}
	// 823F98D8: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 823F98DC: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823F98E0: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F98E4: 7D2A5630  sraw r10, r9, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 823F98E8: 48000010  b 0x823f98f8
	pc = 0x823F98F8; continue 'dispatch;
            }
            0x823F98EC => {
    //   block [0x823F98EC..0x823F98F8)
	// 823F98EC: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823F98F0: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823F98F4: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	pc = 0x823F98F8; continue 'dispatch;
            }
            0x823F98F8 => {
    //   block [0x823F98F8..0x823F9908)
	// 823F98F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F98FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823F9900: 41980008  blt cr6, 0x823f9908
	if ctx.cr[6].lt {
	pc = 0x823F9908; continue 'dispatch;
	}
	// 823F9904: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	pc = 0x823F9908; continue 'dispatch;
            }
            0x823F9908 => {
    //   block [0x823F9908..0x823F993C)
	// 823F9908: 7F8A0734  extsh r10, r28
	ctx.r[10].s64 = ctx.r[28].s16 as i64;
	// 823F990C: 578905F6  rlwinm r9, r28, 0, 0x17, 0x1b
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 823F9910: 7D4B4E70  srawi r11, r10, 9
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 9) as i64;
	// 823F9914: 7D2A2670  srawi r10, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 823F9918: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F991C: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 823F9920: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9924: 40980018  bge cr6, 0x823f993c
	if !ctx.cr[6].lt {
	pc = 0x823F993C; continue 'dispatch;
	}
	// 823F9928: 7D2B00D0  neg r9, r11
	ctx.r[9].s64 = -ctx.r[11].s64;
	// 823F992C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F9930: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823F9934: 7D4A4E30  sraw r10, r10, r9
	tmp.u32 = ctx.r[9].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9938: 48000010  b 0x823f9948
	pc = 0x823F9948; continue 'dispatch;
            }
            0x823F993C => {
    //   block [0x823F993C..0x823F9948)
	// 823F993C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F9940: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F9944: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	pc = 0x823F9948; continue 'dispatch;
            }
            0x823F9948 => {
    //   block [0x823F9948..0x823F9958)
	// 823F9948: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 823F994C: 39603E00  li r11, 0x3e00
	ctx.r[11].s64 = 15872;
	// 823F9950: 41990008  bgt cr6, 0x823f9958
	if ctx.cr[6].gt {
	pc = 0x823F9958; continue 'dispatch;
	}
	// 823F9954: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x823F9958; continue 'dispatch;
            }
            0x823F9958 => {
    //   block [0x823F9958..0x823F9988)
	// 823F9958: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F995C: 7C9F0734  extsh r31, r4
	ctx.r[31].s64 = ctx.r[4].s16 as i64;
	// 823F9960: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 823F9964: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823F9968: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 823F996C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9970: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823F9974: 40990014  ble cr6, 0x823f9988
	if !ctx.cr[6].gt {
	pc = 0x823F9988; continue 'dispatch;
	}
	// 823F9978: A166002E  lhz r11, 0x2e(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(46 as u32) ) } as u64;
	// 823F997C: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 823F9980: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823F9984: 419A0008  beq cr6, 0x823f998c
	if ctx.cr[6].eq {
	pc = 0x823F998C; continue 'dispatch;
	}
	pc = 0x823F9988; continue 'dispatch;
            }
            0x823F9988 => {
    //   block [0x823F9988..0x823F998C)
	// 823F9988: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x823F998C; continue 'dispatch;
            }
            0x823F998C => {
    //   block [0x823F998C..0x823F99C8)
	// 823F998C: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823F9990: 7FD60734  extsh r22, r30
	ctx.r[22].s64 = ctx.r[30].s16 as i64;
	// 823F9994: 396BD460  addi r11, r11, -0x2ba0
	ctx.r[11].s64 = ctx.r[11].s64 + -11168;
	// 823F9998: 7D775A2E  lhzx r11, r23, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823F999C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F99A0: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823F99A4: 7D765850  subf r11, r22, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[22].s64;
	// 823F99A8: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 823F99AC: 7D6BB214  add r11, r11, r22
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 823F99B0: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 823F99B4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823F99B8: 2F0B0220  cmpwi cr6, r11, 0x220
	ctx.cr[6].compare_i32(ctx.r[11].s32, 544, &mut ctx.xer);
	// 823F99BC: 4098000C  bge cr6, 0x823f99c8
	if !ctx.cr[6].lt {
	pc = 0x823F99C8; continue 'dispatch;
	}
	// 823F99C0: 39200220  li r9, 0x220
	ctx.r[9].s64 = 544;
	// 823F99C4: 48000010  b 0x823f99d4
	pc = 0x823F99D4; continue 'dispatch;
            }
            0x823F99C8 => {
    //   block [0x823F99C8..0x823F99D4)
	// 823F99C8: 2F0B1400  cmpwi cr6, r11, 0x1400
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5120, &mut ctx.xer);
	// 823F99CC: 41980008  blt cr6, 0x823f99d4
	if ctx.cr[6].lt {
	pc = 0x823F99D4; continue 'dispatch;
	}
	// 823F99D0: 39201400  li r9, 0x1400
	ctx.r[9].s64 = 5120;
	pc = 0x823F99D4; continue 'dispatch;
            }
            0x823F99D4 => {
    //   block [0x823F99D4..0x823F9A34)
	// 823F99D4: A1060030  lhz r8, 0x30(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 823F99D8: 7F8B0734  extsh r11, r28
	ctx.r[11].s64 = ctx.r[28].s16 as i64;
	// 823F99DC: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 823F99E0: B1260034  sth r9, 0x34(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(52 as u32), ctx.r[9].u16 ) };
	// 823F99E4: 7D090734  extsh r9, r8
	ctx.r[9].s64 = ctx.r[8].s16 as i64;
	// 823F99E8: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F99EC: 548B8FFE  rlwinm r11, r4, 0x11, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00007FFFu64;
	// 823F99F0: 57E897FE  rlwinm r8, r31, 0x12, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x00003FFFu64;
	// 823F99F4: 7D085A78  xor r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[11].u64;
	// 823F99F8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823F99FC: 7D095214  add r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823F9A00: 7D0800D0  neg r8, r8
	ctx.r[8].s64 = -ctx.r[8].s64;
	// 823F9A04: 7D083670  srawi r8, r8, 6
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 6) as i64;
	// 823F9A08: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823F9A0C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 823F9A10: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 823F9A14: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823F9A18: 554906BE  clrlwi r9, r10, 0x1a
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F9A1C: 7D4A3670  srawi r10, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 823F9A20: B1260030  sth r9, 0x30(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(48 as u32), ctx.r[9].u16 ) };
	// 823F9A24: B1460032  sth r10, 0x32(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(50 as u32), ctx.r[10].u16 ) };
	// 823F9A28: 419A000C  beq cr6, 0x823f9a34
	if ctx.cr[6].eq {
	pc = 0x823F9A34; continue 'dispatch;
	}
	// 823F9A2C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 823F9A30: 48000150  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9A34 => {
    //   block [0x823F9A34..0x823F9A4C)
	// 823F9A34: 57EA9FFE  rlwinm r10, r31, 0x13, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00001FFFu64;
	// 823F9A38: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9A3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9A40: 419A000C  beq cr6, 0x823f9a4c
	if ctx.cr[6].eq {
	pc = 0x823F9A4C; continue 'dispatch;
	}
	// 823F9A44: 3960000E  li r11, 0xe
	ctx.r[11].s64 = 14;
	// 823F9A48: 48000138  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9A4C => {
    //   block [0x823F9A4C..0x823F9A64)
	// 823F9A4C: 57EAA7FE  rlwinm r10, r31, 0x14, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000FFFu64;
	// 823F9A50: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9A54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9A58: 419A000C  beq cr6, 0x823f9a64
	if ctx.cr[6].eq {
	pc = 0x823F9A64; continue 'dispatch;
	}
	// 823F9A5C: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 823F9A60: 48000120  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9A64 => {
    //   block [0x823F9A64..0x823F9A7C)
	// 823F9A64: 57EAAFFE  rlwinm r10, r31, 0x15, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000007FFu64;
	// 823F9A68: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9A6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9A70: 419A000C  beq cr6, 0x823f9a7c
	if ctx.cr[6].eq {
	pc = 0x823F9A7C; continue 'dispatch;
	}
	// 823F9A74: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 823F9A78: 48000108  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9A7C => {
    //   block [0x823F9A7C..0x823F9A94)
	// 823F9A7C: 57EAB7FE  rlwinm r10, r31, 0x16, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000003FFu64;
	// 823F9A80: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9A88: 419A000C  beq cr6, 0x823f9a94
	if ctx.cr[6].eq {
	pc = 0x823F9A94; continue 'dispatch;
	}
	// 823F9A8C: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 823F9A90: 480000F0  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9A94 => {
    //   block [0x823F9A94..0x823F9AAC)
	// 823F9A94: 57EABFFE  rlwinm r10, r31, 0x17, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000001FFu64;
	// 823F9A98: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9A9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9AA0: 419A000C  beq cr6, 0x823f9aac
	if ctx.cr[6].eq {
	pc = 0x823F9AAC; continue 'dispatch;
	}
	// 823F9AA4: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 823F9AA8: 480000D8  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9AAC => {
    //   block [0x823F9AAC..0x823F9AC4)
	// 823F9AAC: 57EAC7FE  rlwinm r10, r31, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 823F9AB0: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9AB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9AB8: 419A000C  beq cr6, 0x823f9ac4
	if ctx.cr[6].eq {
	pc = 0x823F9AC4; continue 'dispatch;
	}
	// 823F9ABC: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 823F9AC0: 480000C0  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9AC4 => {
    //   block [0x823F9AC4..0x823F9ADC)
	// 823F9AC4: 57EACFFE  rlwinm r10, r31, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000007Fu64;
	// 823F9AC8: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9ACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9AD0: 419A000C  beq cr6, 0x823f9adc
	if ctx.cr[6].eq {
	pc = 0x823F9ADC; continue 'dispatch;
	}
	// 823F9AD4: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 823F9AD8: 480000A8  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9ADC => {
    //   block [0x823F9ADC..0x823F9AF4)
	// 823F9ADC: 57EAD7FE  rlwinm r10, r31, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 823F9AE0: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9AE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9AE8: 419A000C  beq cr6, 0x823f9af4
	if ctx.cr[6].eq {
	pc = 0x823F9AF4; continue 'dispatch;
	}
	// 823F9AEC: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 823F9AF0: 48000090  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9AF4 => {
    //   block [0x823F9AF4..0x823F9B0C)
	// 823F9AF4: 57EADFFE  rlwinm r10, r31, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000001Fu64;
	// 823F9AF8: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9AFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9B00: 419A000C  beq cr6, 0x823f9b0c
	if ctx.cr[6].eq {
	pc = 0x823F9B0C; continue 'dispatch;
	}
	// 823F9B04: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 823F9B08: 48000078  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9B0C => {
    //   block [0x823F9B0C..0x823F9B24)
	// 823F9B0C: 57EAE7FE  rlwinm r10, r31, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 823F9B10: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9B14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9B18: 419A000C  beq cr6, 0x823f9b24
	if ctx.cr[6].eq {
	pc = 0x823F9B24; continue 'dispatch;
	}
	// 823F9B1C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823F9B20: 48000060  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9B24 => {
    //   block [0x823F9B24..0x823F9B3C)
	// 823F9B24: 57EAEFFE  rlwinm r10, r31, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 823F9B28: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9B2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9B30: 419A000C  beq cr6, 0x823f9b3c
	if ctx.cr[6].eq {
	pc = 0x823F9B3C; continue 'dispatch;
	}
	// 823F9B34: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F9B38: 48000048  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9B3C => {
    //   block [0x823F9B3C..0x823F9B54)
	// 823F9B3C: 57EAF7FE  rlwinm r10, r31, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000003u64;
	// 823F9B40: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9B44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9B48: 419A000C  beq cr6, 0x823f9b54
	if ctx.cr[6].eq {
	pc = 0x823F9B54; continue 'dispatch;
	}
	// 823F9B4C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F9B50: 48000030  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9B54 => {
    //   block [0x823F9B54..0x823F9B6C)
	// 823F9B54: 57EAFFFE  rlwinm r10, r31, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9B58: 7D4A5A78  xor r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9B5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823F9B60: 419A000C  beq cr6, 0x823f9b6c
	if ctx.cr[6].eq {
	pc = 0x823F9B6C; continue 'dispatch;
	}
	// 823F9B64: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F9B68: 48000018  b 0x823f9b80
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9B6C => {
    //   block [0x823F9B6C..0x823F9B80)
	// 823F9B6C: 57EA07FE  clrlwi r10, r31, 0x1f
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 823F9B70: 7D4B5A78  xor r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 823F9B74: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F9B78: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F9B7C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823F9B80; continue 'dispatch;
            }
            0x823F9B80 => {
    //   block [0x823F9B80..0x823F9BA8)
	// 823F9B80: 7D670734  extsh r7, r11
	ctx.r[7].s64 = ctx.r[11].s16 as i64;
	// 823F9B84: 21670006  subfic r11, r7, 6
	ctx.xer.ca = ctx.r[7].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[7].s64;
	// 823F9B88: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9B8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9B90: 40980018  bge cr6, 0x823f9ba8
	if !ctx.cr[6].lt {
	pc = 0x823F9BA8; continue 'dispatch;
	}
	// 823F9B94: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F9B98: 7C8A0734  extsh r10, r4
	ctx.r[10].s64 = ctx.r[4].s16 as i64;
	// 823F9B9C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9BA0: 7D4B5E30  sraw r11, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9BA4: 4800000C  b 0x823f9bb0
	pc = 0x823F9BB0; continue 'dispatch;
            }
            0x823F9BA8 => {
    //   block [0x823F9BA8..0x823F9BB0)
	// 823F9BA8: 7FEB5830  slw r11, r31, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[31].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F9BAC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	pc = 0x823F9BB0; continue 'dispatch;
            }
            0x823F9BB0 => {
    //   block [0x823F9BB0..0x823F9BD8)
	// 823F9BB0: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 823F9BB4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823F9BB8: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 823F9BBC: 419A001C  beq cr6, 0x823f9bd8
	if ctx.cr[6].eq {
	pc = 0x823F9BD8; continue 'dispatch;
	}
	// 823F9BC0: 7D7FC050  subf r11, r31, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 823F9BC4: 7D1FC850  subf r8, r31, r25
	ctx.r[8].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 823F9BC8: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 823F9BCC: 7D7D0734  extsh r29, r11
	ctx.r[29].s64 = ctx.r[11].s16 as i64;
	// 823F9BD0: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 823F9BD4: 48000018  b 0x823f9bec
	pc = 0x823F9BEC; continue 'dispatch;
            }
            0x823F9BD8 => {
    //   block [0x823F9BD8..0x823F9BEC)
	// 823F9BD8: 7D18FA14  add r8, r24, r31
	ctx.r[8].u64 = ctx.r[24].u64 + ctx.r[31].u64;
	// 823F9BDC: 7D79FA14  add r11, r25, r31
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[31].u64;
	// 823F9BE0: 7D1D0734  extsh r29, r8
	ctx.r[29].s64 = ctx.r[8].s16 as i64;
	// 823F9BE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F9BE8: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	pc = 0x823F9BEC; continue 'dispatch;
            }
            0x823F9BEC => {
    //   block [0x823F9BEC..0x823F9C5C)
	// 823F9BEC: 7D5E0734  extsh r30, r10
	ctx.r[30].s64 = ctx.r[10].s16 as i64;
	// 823F9BF0: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823F9BF4: 54EA3032  slwi r10, r7, 6
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823F9BF8: 7D040734  extsh r4, r8
	ctx.r[4].s64 = ctx.r[8].s16 as i64;
	// 823F9BFC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823F9C00: 686B0001  xori r11, r3, 1
	ctx.r[11].u64 = ctx.r[3].u64 ^ 1;
	// 823F9C04: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 823F9C08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823F9C0C: 7D5C0734  extsh r28, r10
	ctx.r[28].s64 = ctx.r[10].s16 as i64;
	// 823F9C10: 3944E001  addi r10, r4, -0x1fff
	ctx.r[10].s64 = ctx.r[4].s64 + -8191;
	// 823F9C14: 7F675878  andc r7, r27, r11
	ctx.r[7].u64 = ctx.r[27].u64 & !ctx.r[11].u64;
	// 823F9C18: 7D4A8670  srawi r10, r10, 0x10
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 16) as i64;
	// 823F9C1C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823F9C20: 7D4950F8  nor r9, r10, r10
	ctx.r[9].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 823F9C24: 7D4A2038  and r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	// 823F9C28: 552904FE  clrlwi r9, r9, 0x13
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00001FFFu64;
	// 823F9C2C: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 823F9C30: 392A2000  addi r9, r10, 0x2000
	ctx.r[9].s64 = ctx.r[10].s64 + 8192;
	// 823F9C34: 7D298670  srawi r9, r9, 0x10
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 16) as i64;
	// 823F9C38: 55230024  rlwinm r3, r9, 0, 0, 0x12
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823F9C3C: 7D4A4878  andc r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	// 823F9C40: 7D4A1B78  or r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[3].u64;
	// 823F9C44: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 823F9C48: 7D6B3B78  or r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 823F9C4C: B1650000  sth r11, 0(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823F9C50: 4098000C  bge cr6, 0x823f9c5c
	if !ctx.cr[6].lt {
	pc = 0x823F9C5C; continue 'dispatch;
	}
	// 823F9C54: 7D6400D0  neg r11, r4
	ctx.r[11].s64 = -ctx.r[4].s64;
	// 823F9C58: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	pc = 0x823F9C5C; continue 'dispatch;
            }
            0x823F9C5C => {
    //   block [0x823F9C5C..0x823F9C7C)
	// 823F9C5C: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 823F9C60: 550B8FFE  rlwinm r11, r8, 0x11, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00007FFFu64;
	// 823F9C64: 554997FE  rlwinm r9, r10, 0x12, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 823F9C68: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9C6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9C70: 419A000C  beq cr6, 0x823f9c7c
	if ctx.cr[6].eq {
	pc = 0x823F9C7C; continue 'dispatch;
	}
	// 823F9C74: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 823F9C78: 48000150  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9C7C => {
    //   block [0x823F9C7C..0x823F9C94)
	// 823F9C7C: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 823F9C80: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9C84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9C88: 419A000C  beq cr6, 0x823f9c94
	if ctx.cr[6].eq {
	pc = 0x823F9C94; continue 'dispatch;
	}
	// 823F9C8C: 3960000E  li r11, 0xe
	ctx.r[11].s64 = 14;
	// 823F9C90: 48000138  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9C94 => {
    //   block [0x823F9C94..0x823F9CAC)
	// 823F9C94: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 823F9C98: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9C9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9CA0: 419A000C  beq cr6, 0x823f9cac
	if ctx.cr[6].eq {
	pc = 0x823F9CAC; continue 'dispatch;
	}
	// 823F9CA4: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 823F9CA8: 48000120  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9CAC => {
    //   block [0x823F9CAC..0x823F9CC4)
	// 823F9CAC: 5549AFFE  rlwinm r9, r10, 0x15, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000007FFu64;
	// 823F9CB0: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9CB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9CB8: 419A000C  beq cr6, 0x823f9cc4
	if ctx.cr[6].eq {
	pc = 0x823F9CC4; continue 'dispatch;
	}
	// 823F9CBC: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 823F9CC0: 48000108  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9CC4 => {
    //   block [0x823F9CC4..0x823F9CDC)
	// 823F9CC4: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 823F9CC8: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9CCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9CD0: 419A000C  beq cr6, 0x823f9cdc
	if ctx.cr[6].eq {
	pc = 0x823F9CDC; continue 'dispatch;
	}
	// 823F9CD4: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 823F9CD8: 480000F0  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9CDC => {
    //   block [0x823F9CDC..0x823F9CF4)
	// 823F9CDC: 5549BFFE  rlwinm r9, r10, 0x17, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000001FFu64;
	// 823F9CE0: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9CE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9CE8: 419A000C  beq cr6, 0x823f9cf4
	if ctx.cr[6].eq {
	pc = 0x823F9CF4; continue 'dispatch;
	}
	// 823F9CEC: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 823F9CF0: 480000D8  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9CF4 => {
    //   block [0x823F9CF4..0x823F9D0C)
	// 823F9CF4: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823F9CF8: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9CFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D00: 419A000C  beq cr6, 0x823f9d0c
	if ctx.cr[6].eq {
	pc = 0x823F9D0C; continue 'dispatch;
	}
	// 823F9D04: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 823F9D08: 480000C0  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D0C => {
    //   block [0x823F9D0C..0x823F9D24)
	// 823F9D0C: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 823F9D10: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9D14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D18: 419A000C  beq cr6, 0x823f9d24
	if ctx.cr[6].eq {
	pc = 0x823F9D24; continue 'dispatch;
	}
	// 823F9D1C: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 823F9D20: 480000A8  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D24 => {
    //   block [0x823F9D24..0x823F9D3C)
	// 823F9D24: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 823F9D28: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9D2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D30: 419A000C  beq cr6, 0x823f9d3c
	if ctx.cr[6].eq {
	pc = 0x823F9D3C; continue 'dispatch;
	}
	// 823F9D34: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 823F9D38: 48000090  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D3C => {
    //   block [0x823F9D3C..0x823F9D54)
	// 823F9D3C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823F9D40: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9D44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D48: 419A000C  beq cr6, 0x823f9d54
	if ctx.cr[6].eq {
	pc = 0x823F9D54; continue 'dispatch;
	}
	// 823F9D4C: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 823F9D50: 48000078  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D54 => {
    //   block [0x823F9D54..0x823F9D6C)
	// 823F9D54: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 823F9D58: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9D5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D60: 419A000C  beq cr6, 0x823f9d6c
	if ctx.cr[6].eq {
	pc = 0x823F9D6C; continue 'dispatch;
	}
	// 823F9D64: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 823F9D68: 48000060  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D6C => {
    //   block [0x823F9D6C..0x823F9D84)
	// 823F9D6C: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 823F9D70: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9D74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D78: 419A000C  beq cr6, 0x823f9d84
	if ctx.cr[6].eq {
	pc = 0x823F9D84; continue 'dispatch;
	}
	// 823F9D7C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 823F9D80: 48000048  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D84 => {
    //   block [0x823F9D84..0x823F9D9C)
	// 823F9D84: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 823F9D88: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9D8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9D90: 419A000C  beq cr6, 0x823f9d9c
	if ctx.cr[6].eq {
	pc = 0x823F9D9C; continue 'dispatch;
	}
	// 823F9D94: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 823F9D98: 48000030  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9D9C => {
    //   block [0x823F9D9C..0x823F9DB4)
	// 823F9D9C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 823F9DA0: 7D295A78  xor r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9DA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9DA8: 419A000C  beq cr6, 0x823f9db4
	if ctx.cr[6].eq {
	pc = 0x823F9DB4; continue 'dispatch;
	}
	// 823F9DAC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 823F9DB0: 48000018  b 0x823f9dc8
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9DB4 => {
    //   block [0x823F9DB4..0x823F9DC8)
	// 823F9DB4: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 823F9DB8: 7D2B5A78  xor r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 823F9DBC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823F9DC0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823F9DC4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x823F9DC8; continue 'dispatch;
            }
            0x823F9DC8 => {
    //   block [0x823F9DC8..0x823F9DF0)
	// 823F9DC8: 7D670734  extsh r7, r11
	ctx.r[7].s64 = ctx.r[11].s16 as i64;
	// 823F9DCC: 21670006  subfic r11, r7, 6
	ctx.xer.ca = ctx.r[7].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[7].s64;
	// 823F9DD0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9DD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823F9DD8: 40980018  bge cr6, 0x823f9df0
	if !ctx.cr[6].lt {
	pc = 0x823F9DF0; continue 'dispatch;
	}
	// 823F9DDC: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 823F9DE0: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 823F9DE4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9DE8: 7D4B5E30  sraw r11, r10, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 823F9DEC: 4800000C  b 0x823f9df8
	pc = 0x823F9DF8; continue 'dispatch;
            }
            0x823F9DF0 => {
    //   block [0x823F9DF0..0x823F9DF8)
	// 823F9DF0: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 823F9DF4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	pc = 0x823F9DF8; continue 'dispatch;
            }
            0x823F9DF8 => {
    //   block [0x823F9DF8..0x823F9E54)
	// 823F9DF8: 7C8A0034  cntlzw r10, r4
	ctx.r[10].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 823F9DFC: 7F490734  extsh r9, r26
	ctx.r[9].s64 = ctx.r[26].s16 as i64;
	// 823F9E00: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 823F9E04: 7D2948F8  nor r9, r9, r9
	ctx.r[9].u64 = !(ctx.r[9].u64 | ctx.r[9].u64);
	// 823F9E08: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 823F9E0C: 7D3B0734  extsh r27, r9
	ctx.r[27].s64 = ctx.r[9].s16 as i64;
	// 823F9E10: 214A0000  subfic r10, r10, 0
	ctx.xer.ca = ctx.r[10].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[10].s64;
	// 823F9E14: 61680020  ori r8, r11, 0x20
	ctx.r[8].u64 = ctx.r[11].u64 | 32;
	// 823F9E18: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823F9E1C: 213F0000  subfic r9, r31, 0
	ctx.xer.ca = ctx.r[31].u32 <= 0 as u32;
	ctx.r[9].s64 = (0 as i64) - ctx.r[31].s64;
	// 823F9E20: 554B002A  rlwinm r11, r10, 0, 0, 0x15
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 823F9E24: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823F9E28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823F9E2C: 552A0630  rlwinm r10, r9, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823F9E30: 7D090734  extsh r9, r8
	ctx.r[9].s64 = ctx.r[8].s16 as i64;
	// 823F9E34: 54E83032  slwi r8, r7, 6
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823F9E38: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F9E3C: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 823F9E40: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 823F9E44: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823F9E48: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 823F9E4C: B106002A  sth r8, 0x2a(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(42 as u32), ctx.r[8].u16 ) };
	// 823F9E50: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	pc = 0x823F9E54; continue 'dispatch;
            }
            0x823F9E54 => {
    //   block [0x823F9E54..0x823F9E7C)
	// 823F9E54: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 823F9E58: A0EB0000  lhz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F9E5C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F9E60: 7D4AF278  xor r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[30].u64;
	// 823F9E64: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823F9E68: 7CEA0734  extsh r10, r7
	ctx.r[10].s64 = ctx.r[7].s16 as i64;
	// 823F9E6C: 7D4A4670  srawi r10, r10, 8
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 8) as i64;
	// 823F9E70: 4098000C  bge cr6, 0x823f9e7c
	if !ctx.cr[6].lt {
	pc = 0x823F9E7C; continue 'dispatch;
	}
	// 823F9E74: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823F9E78: 48000008  b 0x823f9e80
	pc = 0x823F9E80; continue 'dispatch;
            }
            0x823F9E7C => {
    //   block [0x823F9E7C..0x823F9E80)
	// 823F9E7C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	pc = 0x823F9E80; continue 'dispatch;
            }
            0x823F9E80 => {
    //   block [0x823F9E80..0x823F9F08)
	// 823F9E80: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F9E84: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 823F9E88: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F9E8C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823F9E90: 7D4A3850  subf r10, r10, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 823F9E94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823F9E98: 7D4A1838  and r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[3].u64;
	// 823F9E9C: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823F9EA0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 823F9EA4: 409AFFB0  bne cr6, 0x823f9e54
	if !ctx.cr[6].eq {
	pc = 0x823F9E54; continue 'dispatch;
	}
	// 823F9EA8: A3E6001A  lhz r31, 0x1a(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(26 as u32) ) } as u64;
	// 823F9EAC: 7FA40734  extsh r4, r29
	ctx.r[4].s64 = ctx.r[29].s16 as i64;
	// 823F9EB0: A0A60028  lhz r5, 0x28(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 823F9EB4: A146001C  lhz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 823F9EB8: A126001E  lhz r9, 0x1e(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(30 as u32) ) } as u64;
	// 823F9EBC: 7CA5EA78  xor r5, r5, r29
	ctx.r[5].u64 = ctx.r[5].u64 ^ ctx.r[29].u64;
	// 823F9EC0: A1660026  lhz r11, 0x26(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(38 as u32) ) } as u64;
	// 823F9EC4: A1060020  lhz r8, 0x20(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 823F9EC8: 7CA50734  extsh r5, r5
	ctx.r[5].s64 = ctx.r[5].s16 as i64;
	// 823F9ECC: A0E60022  lhz r7, 0x22(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(34 as u32) ) } as u64;
	// 823F9ED0: B3E6001C  sth r31, 0x1c(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[31].u16 ) };
	// 823F9ED4: 7D7F2278  xor r31, r11, r4
	ctx.r[31].u64 = ctx.r[11].u64 ^ ctx.r[4].u64;
	// 823F9ED8: B146001E  sth r10, 0x1e(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(30 as u32), ctx.r[10].u16 ) };
	// 823F9EDC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823F9EE0: B1260020  sth r9, 0x20(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), ctx.r[9].u16 ) };
	// 823F9EE4: 7FEA0734  extsh r10, r31
	ctx.r[10].s64 = ctx.r[31].s16 as i64;
	// 823F9EE8: B386001A  sth r28, 0x1a(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(26 as u32), ctx.r[28].u16 ) };
	// 823F9EEC: 3920F000  li r9, -0x1000
	ctx.r[9].s64 = -4096;
	// 823F9EF0: B3A60026  sth r29, 0x26(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(38 as u32), ctx.r[29].u16 ) };
	// 823F9EF4: B1060022  sth r8, 0x22(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(34 as u32), ctx.r[8].u16 ) };
	// 823F9EF8: B0E60024  sth r7, 0x24(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[7].u16 ) };
	// 823F9EFC: B1660028  sth r11, 0x28(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(40 as u32), ctx.r[11].u16 ) };
	// 823F9F00: 41980008  blt cr6, 0x823f9f08
	if ctx.cr[6].lt {
	pc = 0x823F9F08; continue 'dispatch;
	}
	// 823F9F04: 39201000  li r9, 0x1000
	ctx.r[9].s64 = 4096;
	pc = 0x823F9F08; continue 'dispatch;
            }
            0x823F9F08 => {
    //   block [0x823F9F08..0x823F9F20)
	// 823F9F08: A0A60000  lhz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823F9F0C: 7CAB0734  extsh r11, r5
	ctx.r[11].s64 = ctx.r[5].s16 as i64;
	// 823F9F10: 2F0BE001  cmpwi cr6, r11, -0x1fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, -8191, &mut ctx.xer);
	// 823F9F14: 3960E001  li r11, -0x1fff
	ctx.r[11].s64 = -8191;
	// 823F9F18: 41980008  blt cr6, 0x823f9f20
	if ctx.cr[6].lt {
	pc = 0x823F9F20; continue 'dispatch;
	}
	// 823F9F1C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x823F9F20; continue 'dispatch;
            }
            0x823F9F20 => {
    //   block [0x823F9F20..0x823F9F30)
	// 823F9F20: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 823F9F24: 2F081FFF  cmpwi cr6, r8, 0x1fff
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8191, &mut ctx.xer);
	// 823F9F28: 41980008  blt cr6, 0x823f9f30
	if ctx.cr[6].lt {
	pc = 0x823F9F30; continue 'dispatch;
	}
	// 823F9F2C: 39601FFF  li r11, 0x1fff
	ctx.r[11].s64 = 8191;
	pc = 0x823F9F30; continue 'dispatch;
            }
            0x823F9F30 => {
    //   block [0x823F9F30..0x823F9F44)
	// 823F9F30: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F9F34: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F9F38: 4098000C  bge cr6, 0x823f9f44
	if !ctx.cr[6].lt {
	pc = 0x823F9F44; continue 'dispatch;
	}
	// 823F9F3C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F9F40: 48000008  b 0x823f9f48
	pc = 0x823F9F48; continue 'dispatch;
            }
            0x823F9F44 => {
    //   block [0x823F9F44..0x823F9F48)
	// 823F9F44: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x823F9F48; continue 'dispatch;
            }
            0x823F9F48 => {
    //   block [0x823F9F48..0x823F9F60)
	// 823F9F48: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9F4C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823F9F50: 409A0010  bne cr6, 0x823f9f60
	if !ctx.cr[6].eq {
	pc = 0x823F9F60; continue 'dispatch;
	}
	// 823F9F54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823F9F58: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823F9F5C: 48000010  b 0x823f9f6c
	pc = 0x823F9F6C; continue 'dispatch;
            }
            0x823F9F60 => {
    //   block [0x823F9F60..0x823F9F6C)
	// 823F9F60: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9F64: 392000C0  li r9, 0xc0
	ctx.r[9].s64 = 192;
	// 823F9F68: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	pc = 0x823F9F6C; continue 'dispatch;
            }
            0x823F9F6C => {
    //   block [0x823F9F6C..0x823F9F90)
	// 823F9F6C: A1660002  lhz r11, 2(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 823F9F70: 7D670734  extsh r7, r11
	ctx.r[7].s64 = ctx.r[11].s16 as i64;
	// 823F9F74: 7CE73E70  srawi r7, r7, 7
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[7].s32 >> 7) as i64;
	// 823F9F78: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 823F9F7C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823F9F80: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F9F84: 2F0AD000  cmpwi cr6, r10, -0x3000
	ctx.cr[6].compare_i32(ctx.r[10].s32, -12288, &mut ctx.xer);
	// 823F9F88: 40980008  bge cr6, 0x823f9f90
	if !ctx.cr[6].lt {
	pc = 0x823F9F90; continue 'dispatch;
	}
	// 823F9F8C: 3960D000  li r11, -0x3000
	ctx.r[11].s64 = -12288;
	pc = 0x823F9F90; continue 'dispatch;
            }
            0x823F9F90 => {
    //   block [0x823F9F90..0x823F9FA0)
	// 823F9F90: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823F9F94: 2F0A3000  cmpwi cr6, r10, 0x3000
	ctx.cr[6].compare_i32(ctx.r[10].s32, 12288, &mut ctx.xer);
	// 823F9F98: 41980008  blt cr6, 0x823f9fa0
	if ctx.cr[6].lt {
	pc = 0x823F9FA0; continue 'dispatch;
	}
	// 823F9F9C: 39603000  li r11, 0x3000
	ctx.r[11].s64 = 12288;
	pc = 0x823F9FA0; continue 'dispatch;
            }
            0x823F9FA0 => {
    //   block [0x823F9FA0..0x823F9FC4)
	// 823F9FA0: 7D670734  extsh r7, r11
	ctx.r[7].s64 = ctx.r[11].s16 as i64;
	// 823F9FA4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823F9FA8: 7CE81838  and r8, r7, r3
	ctx.r[8].u64 = ctx.r[7].u64 & ctx.r[3].u64;
	// 823F9FAC: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 823F9FB0: 7D4B4670  srawi r11, r10, 8
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 8) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 8) as i64;
	// 823F9FB4: B1060002  sth r8, 2(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 823F9FB8: 4098000C  bge cr6, 0x823f9fc4
	if !ctx.cr[6].lt {
	pc = 0x823F9FC4; continue 'dispatch;
	}
	// 823F9FBC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 823F9FC0: 48000008  b 0x823f9fc8
	pc = 0x823F9FC8; continue 'dispatch;
            }
            0x823F9FC4 => {
    //   block [0x823F9FC4..0x823F9FC8)
	// 823F9FC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x823F9FC8; continue 'dispatch;
            }
            0x823F9FC8 => {
    //   block [0x823F9FC8..0x823F9FFC)
	// 823F9FC8: 21473C00  subfic r10, r7, 0x3c00
	ctx.xer.ca = ctx.r[7].u32 <= 15360 as u32;
	ctx.r[10].s64 = (15360 as i64) - ctx.r[7].s64;
	// 823F9FCC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9FD0: 7D480734  extsh r8, r10
	ctx.r[8].s64 = ctx.r[10].s16 as i64;
	// 823F9FD4: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 823F9FD8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 823F9FDC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823F9FE0: 7D4900D0  neg r10, r9
	ctx.r[10].s64 = -ctx.r[9].s64;
	// 823F9FE4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 823F9FE8: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823F9FEC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 823F9FF0: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823F9FF4: 40980008  bge cr6, 0x823f9ffc
	if !ctx.cr[6].lt {
	pc = 0x823F9FFC; continue 'dispatch;
	}
	// 823F9FF8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x823F9FFC; continue 'dispatch;
            }
            0x823F9FFC => {
    //   block [0x823F9FFC..0x823FA00C)
	// 823F9FFC: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 823FA000: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FA004: 40980008  bge cr6, 0x823fa00c
	if !ctx.cr[6].lt {
	pc = 0x823FA00C; continue 'dispatch;
	}
	// 823FA008: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x823FA00C; continue 'dispatch;
            }
            0x823FA00C => {
    //   block [0x823FA00C..0x823FA024)
	// 823FA00C: 7D0B1838  and r11, r8, r3
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[3].u64;
	// 823FA010: 2F07D200  cmpwi cr6, r7, -0x2e00
	ctx.cr[6].compare_i32(ctx.r[7].s32, -11776, &mut ctx.xer);
	// 823FA014: B1660000  sth r11, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FA018: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FA01C: 41980008  blt cr6, 0x823fa024
	if ctx.cr[6].lt {
	pc = 0x823FA024; continue 'dispatch;
	}
	// 823FA020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823FA024; continue 'dispatch;
            }
            0x823FA024 => {
    //   block [0x823FA024..0x823FA098)
	// 823FA024: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 823FA028: A1660016  lhz r11, 0x16(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(22 as u32) ) } as u64;
	// 823FA02C: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823FA030: 7D051838  and r5, r8, r3
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[3].u64;
	// 823FA034: 392AD450  addi r9, r10, -0x2bb0
	ctx.r[9].s64 = ctx.r[10].s64 + -11184;
	// 823FA038: A1460014  lhz r10, 0x14(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FA03C: B0A6002E  sth r5, 0x2e(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(46 as u32), ctx.r[5].u16 ) };
	// 823FA040: 7D374A2E  lhzx r9, r23, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 823FA044: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 823FA048: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823FA04C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FA050: 7CE70734  extsh r7, r7
	ctx.r[7].s64 = ctx.r[7].s16 as i64;
	// 823FA054: 7CAA4850  subf r5, r10, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823FA058: 7CE92E70  srawi r9, r7, 5
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 5) as i64;
	// 823FA05C: 7CA70734  extsh r7, r5
	ctx.r[7].s64 = ctx.r[5].s16 as i64;
	// 823FA060: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823FA064: 7CE93E70  srawi r9, r7, 7
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 7) as i64;
	// 823FA068: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 823FA06C: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 823FA070: B1660016  sth r11, 0x16(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	// 823FA074: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FA078: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823FA07C: B1460014  sth r10, 0x14(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 823FA080: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 823FA084: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FA088: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FA08C: 4098000C  bge cr6, 0x823fa098
	if !ctx.cr[6].lt {
	pc = 0x823FA098; continue 'dispatch;
	}
	// 823FA090: 7D6900D0  neg r11, r9
	ctx.r[11].s64 = -ctx.r[9].s64;
	// 823FA094: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	pc = 0x823FA098; continue 'dispatch;
            }
            0x823FA098 => {
    //   block [0x823FA098..0x823FA0B0)
	// 823FA098: 554AECFE  rlwinm r10, r10, 0x1d, 0x13, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 823FA09C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 823FA0A0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FA0A4: 4098000C  bge cr6, 0x823fa0b0
	if !ctx.cr[6].lt {
	pc = 0x823FA0B0; continue 'dispatch;
	}
	// 823FA0A8: 2F160600  cmpwi cr6, r22, 0x600
	ctx.cr[6].compare_i32(ctx.r[22].s32, 1536, &mut ctx.xer);
	// 823FA0AC: 4098000C  bge cr6, 0x823fa0b8
	if !ctx.cr[6].lt {
	pc = 0x823FA0B8; continue 'dispatch;
	}
	pc = 0x823FA0B0; continue 'dispatch;
            }
            0x823FA0B0 => {
    //   block [0x823FA0B0..0x823FA0B8)
	// 823FA0B0: 39400200  li r10, 0x200
	ctx.r[10].s64 = 512;
	// 823FA0B4: 48000010  b 0x823fa0c4
	pc = 0x823FA0C4; continue 'dispatch;
            }
            0x823FA0B8 => {
    //   block [0x823FA0B8..0x823FA0C4)
	// 823FA0B8: 21680000  subfic r11, r8, 0
	ctx.xer.ca = ctx.r[8].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[8].s64;
	// 823FA0BC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823FA0C0: 556A05AC  rlwinm r10, r11, 0, 0x16, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x823FA0C4; continue 'dispatch;
            }
            0x823FA0C4 => {
    //   block [0x823FA0C4..0x823FA0F0)
	// 823FA0C4: A1660004  lhz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA0C8: 7C6918F8  nor r9, r3, r3
	ctx.r[9].u64 = !(ctx.r[3].u64 | ctx.r[3].u64);
	// 823FA0CC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FA0D0: 552905EE  rlwinm r9, r9, 0, 0x17, 0x17
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 823FA0D4: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823FA0D8: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 823FA0DC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FA0E0: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 823FA0E4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 823FA0E8: B1660004  sth r11, 4(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 823FA0EC: 4813B000  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FA0F0 size=496
    let mut pc: u32 = 0x823FA0F0;
    'dispatch: loop {
        match pc {
            0x823FA0F0 => {
    //   block [0x823FA0F0..0x823FA124)
	// 823FA0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FA0F4: 4813AFB9  bl 0x825350ac
	ctx.lr = 0x823FA0F8;
	sub_82535080(ctx, base);
	// 823FA0F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FA0FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FA100: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FA104: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 823FA108: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	// 823FA10C: 811F0088  lwz r8, 0x88(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FA110: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA114: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA118: 41820030  beq 0x823fa148
	if ctx.cr[0].eq {
	pc = 0x823FA148; continue 'dispatch;
	}
	// 823FA11C: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FA120: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	pc = 0x823FA124; continue 'dispatch;
            }
            0x823FA124 => {
    //   block [0x823FA124..0x823FA13C)
	// 823FA124: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA128: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FA12C: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FA130: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FA134: 41990008  bgt cr6, 0x823fa13c
	if ctx.cr[6].gt {
	pc = 0x823FA13C; continue 'dispatch;
	}
	// 823FA138: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	pc = 0x823FA13C; continue 'dispatch;
            }
            0x823FA13C => {
    //   block [0x823FA13C..0x823FA148)
	// 823FA13C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FA140: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FA144: 4082FFE0  bne 0x823fa124
	if !ctx.cr[0].eq {
	pc = 0x823FA124; continue 'dispatch;
	}
	pc = 0x823FA148; continue 'dispatch;
            }
            0x823FA148 => {
    //   block [0x823FA148..0x823FA158)
	// 823FA148: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 823FA14C: 419A003C  beq cr6, 0x823fa188
	if ctx.cr[6].eq {
	pc = 0x823FA188; continue 'dispatch;
	}
	// 823FA150: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FA154: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	pc = 0x823FA158; continue 'dispatch;
            }
            0x823FA158 => {
    //   block [0x823FA158..0x823FA17C)
	// 823FA158: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA15C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FA160: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FA164: 7D1A5B96  divwu r8, r26, r11
	ctx.r[8].u32 = ctx.r[26].u32 / ctx.r[11].u32;
	// 823FA168: 0CCB0000  twi 6, r11, 0
	// 823FA16C: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 823FA170: 7D08D051  subf. r8, r8, r26
	ctx.r[8].s64 = ctx.r[26].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FA174: 41820008  beq 0x823fa17c
	if ctx.cr[0].eq {
	pc = 0x823FA17C; continue 'dispatch;
	}
	// 823FA178: 7F4BD1D6  mullw r26, r11, r26
	ctx.r[26].s32 = ((ctx.r[11].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	pc = 0x823FA17C; continue 'dispatch;
            }
            0x823FA17C => {
    //   block [0x823FA17C..0x823FA188)
	// 823FA17C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FA180: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FA184: 4082FFD4  bne 0x823fa158
	if !ctx.cr[0].eq {
	pc = 0x823FA158; continue 'dispatch;
	}
	pc = 0x823FA188; continue 'dispatch;
            }
            0x823FA188 => {
    //   block [0x823FA188..0x823FA1FC)
	// 823FA188: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA18C: 7F7AF1D6  mullw r27, r26, r30
	ctx.r[27].s32 = ((ctx.r[26].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[27].s64 = ctx.r[27].s32 as i64;
	// 823FA190: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA194: 408200D0  bne 0x823fa264
	if !ctx.cr[0].eq {
	pc = 0x823FA264; continue 'dispatch;
	}
	// 823FA198: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823FA19C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FA1A0: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823FA1A4: 4BFD001D  bl 0x823ca1c0
	ctx.lr = 0x823FA1A8;
	sub_823CA1C0(ctx, base);
	// 823FA1A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FA1AC: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FA1B0: 1C7E001C  mulli r3, r30, 0x1c
	ctx.r[3].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 823FA1B4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823FA1B8: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823FA1BC: 4BFD0005  bl 0x823ca1c0
	ctx.lr = 0x823FA1C0;
	sub_823CA1C0(ctx, base);
	// 823FA1C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FA1C4: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FA1C8: 57C31838  slwi r3, r30, 3
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 823FA1CC: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823FA1D0: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 823FA1D4: 4BFCFFED  bl 0x823ca1c0
	ctx.lr = 0x823FA1D8;
	sub_823CA1C0(ctx, base);
	// 823FA1D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA1DC: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 823FA1E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA1E4: 41820018  beq 0x823fa1fc
	if ctx.cr[0].eq {
	pc = 0x823FA1FC; continue 'dispatch;
	}
	// 823FA1E8: 815F0084  lwz r10, 0x84(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FA1EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823FA1F0: 419A000C  beq cr6, 0x823fa1fc
	if ctx.cr[6].eq {
	pc = 0x823FA1FC; continue 'dispatch;
	}
	// 823FA1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 823FA1F8: 409A006C  bne cr6, 0x823fa264
	if !ctx.cr[6].eq {
	pc = 0x823FA264; continue 'dispatch;
	}
	pc = 0x823FA1FC; continue 'dispatch;
            }
            0x823FA1FC => {
    //   block [0x823FA1FC..0x823FA220)
	// 823FA1FC: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FA200: 3F208007  lis r25, -0x7ff9
	ctx.r[25].s64 = -2147024896;
	// 823FA204: 6339000E  ori r25, r25, 0xe
	ctx.r[25].u64 = ctx.r[25].u64 | 14;
	// 823FA208: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA20C: 41820014  beq 0x823fa220
	if ctx.cr[0].eq {
	pc = 0x823FA220; continue 'dispatch;
	}
	// 823FA210: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FA214: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823FA218: 4BFD0041  bl 0x823ca258
	ctx.lr = 0x823FA21C;
	sub_823CA258(ctx, base);
	// 823FA21C: 93BF0060  stw r29, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	pc = 0x823FA220; continue 'dispatch;
            }
            0x823FA220 => {
    //   block [0x823FA220..0x823FA23C)
	// 823FA220: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FA224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA228: 41820014  beq 0x823fa23c
	if ctx.cr[0].eq {
	pc = 0x823FA23C; continue 'dispatch;
	}
	// 823FA22C: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FA230: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823FA234: 4BFD0025  bl 0x823ca258
	ctx.lr = 0x823FA238;
	sub_823CA258(ctx, base);
	// 823FA238: 93BF0084  stw r29, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	pc = 0x823FA23C; continue 'dispatch;
            }
            0x823FA23C => {
    //   block [0x823FA23C..0x823FA258)
	// 823FA23C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA240: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA244: 41820014  beq 0x823fa258
	if ctx.cr[0].eq {
	pc = 0x823FA258; continue 'dispatch;
	}
	// 823FA248: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823FA24C: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823FA250: 4BFD0009  bl 0x823ca258
	ctx.lr = 0x823FA254;
	sub_823CA258(ctx, base);
	// 823FA254: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x823FA258; continue 'dispatch;
            }
            0x823FA258 => {
    //   block [0x823FA258..0x823FA264)
	// 823FA258: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823FA25C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FA260: 4813AE9C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x823FA264 => {
    //   block [0x823FA264..0x823FA2BC)
	// 823FA264: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823FA268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA26C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823FA270: 4BFC72F1  bl 0x823c1560
	ctx.lr = 0x823FA274;
	sub_823C1560(ctx, base);
	// 823FA274: 1FBE001C  mulli r29, r30, 0x1c
	ctx.r[29].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 823FA278: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FA27C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA280: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FA284: 4BFC72DD  bl 0x823c1560
	ctx.lr = 0x823FA288;
	sub_823C1560(ctx, base);
	// 823FA288: 57DC1838  slwi r28, r30, 3
	ctx.r[28].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 823FA28C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA290: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FA294: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823FA298: 4BFC72C9  bl 0x823c1560
	ctx.lr = 0x823FA29C;
	sub_823C1560(ctx, base);
	// 823FA29C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA2A0: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FA2A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FA2A8: 813F0060  lwz r9, 0x60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FA2AC: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 823FA2B0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 823FA2B4: 7D29E214  add r9, r9, r28
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[28].u64;
	// 823FA2B8: 419AFFA0  beq cr6, 0x823fa258
	if ctx.cr[6].eq {
	pc = 0x823FA258; continue 'dispatch;
	}
	pc = 0x823FA2BC; continue 'dispatch;
            }
            0x823FA2BC => {
    //   block [0x823FA2BC..0x823FA2E0)
	// 823FA2BC: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 823FA2C0: 7D5A5050  subf r10, r26, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[26].s64;
	// 823FA2C4: 3929FFF8  addi r9, r9, -8
	ctx.r[9].s64 = ctx.r[9].s64 + -8;
	// 823FA2C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FA2CC: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 823FA2D0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 823FA2D4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FA2D8: 4082FFE4  bne 0x823fa2bc
	if !ctx.cr[0].eq {
	pc = 0x823FA2BC; continue 'dispatch;
	}
	// 823FA2DC: 4BFFFF7C  b 0x823fa258
	pc = 0x823FA258; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FA2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FA2E0 size=488
    let mut pc: u32 = 0x823FA2E0;
    'dispatch: loop {
        match pc {
            0x823FA2E0 => {
    //   block [0x823FA2E0..0x823FA344)
	// 823FA2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FA2E4: 4813ADBD  bl 0x825350a0
	ctx.lr = 0x823FA2E8;
	sub_82535080(ctx, base);
	// 823FA2E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FA2EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FA2F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FA2F4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 823FA2F8: 3B7F0090  addi r27, r31, 0x90
	ctx.r[27].s64 = ctx.r[31].s64 + 144;
	// 823FA2FC: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 823FA300: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA304: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA308: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA30C: 82DF0090  lwz r22, 0x90(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 823FA310: 5579F87E  srwi r25, r11, 1
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 823FA314: 835F0094  lwz r26, 0x94(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 823FA318: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FA31C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823FA320: 419A004C  beq cr6, 0x823fa36c
	if ctx.cr[6].eq {
	pc = 0x823FA36C; continue 'dispatch;
	}
	// 823FA324: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA328: 814A00C4  lwz r10, 0xc4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 823FA32C: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FA330: 41820014  beq 0x823fa344
	if ctx.cr[0].eq {
	pc = 0x823FA344; continue 'dispatch;
	}
	// 823FA334: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 823FA338: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA33C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FA340: 4BFC7221  bl 0x823c1560
	ctx.lr = 0x823FA344;
	sub_823C1560(ctx, base);
	pc = 0x823FA344; continue 'dispatch;
            }
            0x823FA344 => {
    //   block [0x823FA344..0x823FA36C)
	// 823FA344: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA348: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823FA34C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA350: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA354: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA358: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FA35C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA360: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FA364: 4E800421  bctrl
	ctx.lr = 0x823FA368;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FA368: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
            }
            0x823FA36C => {
    //   block [0x823FA36C..0x823FA3A4)
	// 823FA36C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA370: 3B003E80  li r24, 0x3e80
	ctx.r[24].s64 = 16000;
	// 823FA374: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 823FA378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA37C: 409A00E0  bne cr6, 0x823fa45c
	if !ctx.cr[6].eq {
	pc = 0x823FA45C; continue 'dispatch;
	}
	// 823FA380: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FA384: 3D404000  lis r10, 0x4000
	ctx.r[10].s64 = 1073741824;
	// 823FA388: 55690006  rlwinm r9, r11, 0, 0, 3
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823FA38C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823FA390: 409A0014  bne cr6, 0x823fa3a4
	if !ctx.cr[6].eq {
	pc = 0x823FA3A4; continue 'dispatch;
	}
	// 823FA394: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823FA398: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 823FA39C: 41980008  blt cr6, 0x823fa3a4
	if ctx.cr[6].lt {
	pc = 0x823FA3A4; continue 'dispatch;
	}
	// 823FA3A0: 3B5A00C8  addi r26, r26, 0xc8
	ctx.r[26].s64 = ctx.r[26].s64 + 200;
	pc = 0x823FA3A4; continue 'dispatch;
            }
            0x823FA3A4 => {
    //   block [0x823FA3A4..0x823FA3CC)
	// 823FA3A4: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 823FA3A8: 419A0060  beq cr6, 0x823fa408
	if ctx.cr[6].eq {
	pc = 0x823FA408; continue 'dispatch;
	}
	// 823FA3AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA3B0: 816B00C4  lwz r11, 0xc4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 823FA3B4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA3B8: 40820050  bne 0x823fa408
	if !ctx.cr[0].eq {
	pc = 0x823FA408; continue 'dispatch;
	}
	// 823FA3BC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 823FA3C0: 419A002C  beq cr6, 0x823fa3ec
	if ctx.cr[6].eq {
	pc = 0x823FA3EC; continue 'dispatch;
	}
	// 823FA3C4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 823FA3C8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x823FA3CC; continue 'dispatch;
            }
            0x823FA3CC => {
    //   block [0x823FA3CC..0x823FA3EC)
	// 823FA3CC: A92A0000  lha r9, 0(r10)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FA3D0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA3D4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823FA3D8: 7D28FE70  srawi r8, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 823FA3DC: 7D294278  xor r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[8].u64;
	// 823FA3E0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 823FA3E4: 7FA9EA14  add r29, r9, r29
	ctx.r[29].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 823FA3E8: 4082FFE4  bne 0x823fa3cc
	if !ctx.cr[0].eq {
	pc = 0x823FA3CC; continue 'dispatch;
	}
	pc = 0x823FA3EC; continue 'dispatch;
            }
            0x823FA3EC => {
    //   block [0x823FA3EC..0x823FA408)
	// 823FA3EC: 7D7DCB96  divwu r11, r29, r25
	ctx.r[11].u32 = ctx.r[29].u32 / ctx.r[25].u32;
	// 823FA3F0: 0CD90000  twi 6, r25, 0
	// 823FA3F4: 7D6BD010  subfc r11, r11, r26
	ctx.xer.ca = ctx.r[26].u32 >= ctx.r[11].u32;
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 823FA3F8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 823FA3FC: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 823FA400: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FA404: 48000008  b 0x823fa40c
	pc = 0x823FA40C; continue 'dispatch;
            }
            0x823FA408 => {
    //   block [0x823FA408..0x823FA40C)
	// 823FA408: 92FB0000  stw r23, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x823FA40C; continue 'dispatch;
            }
            0x823FA40C => {
    //   block [0x823FA40C..0x823FA42C)
	// 823FA40C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA410: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FA414: 409A0018  bne cr6, 0x823fa42c
	if !ctx.cr[6].eq {
	pc = 0x823FA42C; continue 'dispatch;
	}
	// 823FA418: 396001F4  li r11, 0x1f4
	ctx.r[11].s64 = 500;
	// 823FA41C: 3940012C  li r10, 0x12c
	ctx.r[10].s64 = 300;
	// 823FA420: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 823FA424: 915F0094  stw r10, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 823FA428: 48000034  b 0x823fa45c
	pc = 0x823FA45C; continue 'dispatch;
            }
            0x823FA42C => {
    //   block [0x823FA42C..0x823FA454)
	// 823FA42C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 823FA430: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FA434: 40810020  ble 0x823fa454
	if !ctx.cr[0].gt {
	pc = 0x823FA454; continue 'dispatch;
	}
	// 823FA438: 1D5903E8  mulli r10, r25, 0x3e8
	ctx.r[10].s32 = ((ctx.r[25].s32 as i64 * 1000 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823FA43C: 7D4AC396  divwu r10, r10, r24
	ctx.r[10].u32 = ctx.r[10].u32 / ctx.r[24].u32;
	// 823FA440: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823FA444: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823FA448: 913B0000  stw r9, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FA44C: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 823FA450: 4800000C  b 0x823fa45c
	pc = 0x823FA45C; continue 'dispatch;
            }
            0x823FA454 => {
    //   block [0x823FA454..0x823FA45C)
	// 823FA454: 39600258  li r11, 0x258
	ctx.r[11].s64 = 600;
	// 823FA458: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA45C; continue 'dispatch;
            }
            0x823FA45C => {
    //   block [0x823FA45C..0x823FA470)
	// 823FA45C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA460: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FA464: 409A000C  bne cr6, 0x823fa470
	if !ctx.cr[6].eq {
	pc = 0x823FA470; continue 'dispatch;
	}
	// 823FA468: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823FA46C: 419A0010  beq cr6, 0x823fa47c
	if ctx.cr[6].eq {
	pc = 0x823FA47C; continue 'dispatch;
	}
	pc = 0x823FA470; continue 'dispatch;
            }
            0x823FA470 => {
    //   block [0x823FA470..0x823FA47C)
	// 823FA470: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 823FA474: 2B0B7530  cmplwi cr6, r11, 0x7530
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30000 as u32, &mut ctx.xer);
	// 823FA478: 40990028  ble cr6, 0x823fa4a0
	if !ctx.cr[6].gt {
	pc = 0x823FA4A0; continue 'dispatch;
	}
	pc = 0x823FA47C; continue 'dispatch;
            }
            0x823FA47C => {
    //   block [0x823FA47C..0x823FA4A0)
	// 823FA47C: 895F008C  lbz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 823FA480: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FA484: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823FA488: 92FF009C  stw r23, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 823FA48C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FA490: 388B72D8  addi r4, r11, 0x72d8
	ctx.r[4].s64 = ctx.r[11].s64 + 29400;
	// 823FA494: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 823FA498: 995F008C  stb r10, 0x8c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 823FA49C: 4813A6B5  bl 0x82534b50
	ctx.lr = 0x823FA4A0;
	sub_82534B50(ctx, base);
	pc = 0x823FA4A0; continue 'dispatch;
            }
            0x823FA4A0 => {
    //   block [0x823FA4A0..0x823FA4C0)
	// 823FA4A0: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA4A4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 823FA4A8: 409A0018  bne cr6, 0x823fa4c0
	if !ctx.cr[6].eq {
	pc = 0x823FA4C0; continue 'dispatch;
	}
	// 823FA4AC: 1D7903E8  mulli r11, r25, 0x3e8
	ctx.r[11].s32 = ((ctx.r[25].s32 as i64 * 1000 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FA4B0: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 823FA4B4: 7D6BC396  divwu r11, r11, r24
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[24].u32;
	// 823FA4B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823FA4BC: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA4C0; continue 'dispatch;
            }
            0x823FA4C0 => {
    //   block [0x823FA4C0..0x823FA4C8)
	// 823FA4C0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823FA4C4: 4813AC2C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FA4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FA4C8 size=208
    let mut pc: u32 = 0x823FA4C8;
    'dispatch: loop {
        match pc {
            0x823FA4C8 => {
    //   block [0x823FA4C8..0x823FA500)
	// 823FA4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FA4CC: 4813ABF1  bl 0x825350bc
	ctx.lr = 0x823FA4D0;
	sub_82535080(ctx, base);
	// 823FA4D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FA4D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823FA4D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FA4DC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 823FA4E0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 823FA4E4: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA4E8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FA4EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA4F0: 409A0010  bne cr6, 0x823fa500
	if !ctx.cr[6].eq {
	pc = 0x823FA500; continue 'dispatch;
	}
	// 823FA4F4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA4F8: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA4FC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA500; continue 'dispatch;
            }
            0x823FA500 => {
    //   block [0x823FA500..0x823FA53C)
	// 823FA500: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA504: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 823FA508: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823FA50C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA510: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA514: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA518: 419A0024  beq cr6, 0x823fa53c
	if ctx.cr[6].eq {
	pc = 0x823FA53C; continue 'dispatch;
	}
	// 823FA51C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA520: 814B00C4  lwz r10, 0xc4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 823FA524: 554A031F  rlwinm. r10, r10, 0, 0xc, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FA528: 41820014  beq 0x823fa53c
	if ctx.cr[0].eq {
	pc = 0x823FA53C; continue 'dispatch;
	}
	// 823FA52C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FA530: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA534: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 823FA538: 483136F5  bl 0x8270dc2c
	ctx.lr = 0x823FA53C;
	// extern call 0x8270DC2C  crate::xam::XamVoiceSubmitPacket
	crate::xam::XamVoiceSubmitPacket(ctx, base);
	pc = 0x823FA53C; continue 'dispatch;
            }
            0x823FA53C => {
    //   block [0x823FA53C..0x823FA554)
	// 823FA53C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA540: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA544: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA548: 419A000C  beq cr6, 0x823fa554
	if ctx.cr[6].eq {
	pc = 0x823FA554; continue 'dispatch;
	}
	// 823FA54C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823FA550: 40980018  bge cr6, 0x823fa568
	if !ctx.cr[6].lt {
	pc = 0x823FA568; continue 'dispatch;
	}
	pc = 0x823FA554; continue 'dispatch;
            }
            0x823FA554 => {
    //   block [0x823FA554..0x823FA568)
	// 823FA554: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 823FA558: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA55C: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 823FA560: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823FA564: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x823FA568; continue 'dispatch;
            }
            0x823FA568 => {
    //   block [0x823FA568..0x823FA588)
	// 823FA568: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FA56C: 397E0074  addi r11, r30, 0x74
	ctx.r[11].s64 = ctx.r[30].s64 + 116;
	// 823FA570: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FA574: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA578: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA57C: 4182000C  beq 0x823fa588
	if ctx.cr[0].eq {
	pc = 0x823FA588; continue 'dispatch;
	}
	// 823FA580: 93AA0004  stw r29, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823FA584: 48000008  b 0x823fa58c
	pc = 0x823FA58C; continue 'dispatch;
            }
            0x823FA588 => {
    //   block [0x823FA588..0x823FA58C)
	// 823FA588: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x823FA58C; continue 'dispatch;
            }
            0x823FA58C => {
    //   block [0x823FA58C..0x823FA598)
	// 823FA58C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 823FA590: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FA594: 4813AB78  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FA598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FA598 size=128
    let mut pc: u32 = 0x823FA598;
    'dispatch: loop {
        match pc {
            0x823FA598 => {
    //   block [0x823FA598..0x823FA5E4)
	// 823FA598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FA59C: 4813AB1D  bl 0x825350b8
	ctx.lr = 0x823FA5A0;
	sub_82535080(ctx, base);
	// 823FA5A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FA5A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823FA5A8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823FA5AC: 397D0014  addi r11, r29, 0x14
	ctx.r[11].s64 = ctx.r[29].s64 + 20;
	// 823FA5B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FA5B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA5B8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 823FA5BC: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA5C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823FA5C4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 823FA5C8: 4BFFA111  bl 0x823f46d8
	ctx.lr = 0x823FA5CC;
	sub_823F46D8(ctx, base);
	// 823FA5CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FA5D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FA5D4: 40800010  bge 0x823fa5e4
	if !ctx.cr[0].lt {
	pc = 0x823FA5E4; continue 'dispatch;
	}
	// 823FA5D8: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA5DC: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FA5E0: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA5E4; continue 'dispatch;
            }
            0x823FA5E4 => {
    //   block [0x823FA5E4..0x823FA608)
	// 823FA5E4: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA5E8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FA5EC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823FA5F0: 396B0064  addi r11, r11, 0x64
	ctx.r[11].s64 = ctx.r[11].s64 + 100;
	// 823FA5F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA5F8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA5FC: 4182000C  beq 0x823fa608
	if ctx.cr[0].eq {
	pc = 0x823FA608; continue 'dispatch;
	}
	// 823FA600: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823FA604: 48000008  b 0x823fa60c
	pc = 0x823FA60C; continue 'dispatch;
            }
            0x823FA608 => {
    //   block [0x823FA608..0x823FA60C)
	// 823FA608: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x823FA60C; continue 'dispatch;
            }
            0x823FA60C => {
    //   block [0x823FA60C..0x823FA618)
	// 823FA60C: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 823FA610: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FA614: 4813AAF4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FA618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FA618 size=188
    let mut pc: u32 = 0x823FA618;
    'dispatch: loop {
        match pc {
            0x823FA618 => {
    //   block [0x823FA618..0x823FA644)
	// 823FA618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FA61C: 4813AA99  bl 0x825350b4
	ctx.lr = 0x823FA620;
	sub_82535080(ctx, base);
	// 823FA620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FA624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FA628: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FA62C: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823FA630: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FA634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FA638: 40990064  ble cr6, 0x823fa69c
	if !ctx.cr[6].gt {
	pc = 0x823FA69C; continue 'dispatch;
	}
	// 823FA63C: 3BFE0064  addi r31, r30, 0x64
	ctx.r[31].s64 = ctx.r[30].s64 + 100;
	// 823FA640: 3BBE0050  addi r29, r30, 0x50
	ctx.r[29].s64 = ctx.r[30].s64 + 80;
	pc = 0x823FA644; continue 'dispatch;
            }
            0x823FA644 => {
    //   block [0x823FA644..0x823FA658)
	// 823FA644: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823FA648: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA64C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823FA650: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA654: 4BFFA1D5  bl 0x823f4828
	ctx.lr = 0x823FA658;
	sub_823F4828(ctx, base);
	pc = 0x823FA658; continue 'dispatch;
            }
            0x823FA658 => {
    //   block [0x823FA658..0x823FA674)
	// 823FA658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA65C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA660: 41820024  beq 0x823fa684
	if ctx.cr[0].eq {
	pc = 0x823FA684; continue 'dispatch;
	}
	// 823FA664: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA668: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823FA66C: 409A0008  bne cr6, 0x823fa674
	if !ctx.cr[6].eq {
	pc = 0x823FA674; continue 'dispatch;
	}
	// 823FA670: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823FA674; continue 'dispatch;
            }
            0x823FA674 => {
    //   block [0x823FA674..0x823FA684)
	// 823FA674: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA678: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FA67C: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823FA680: 4BFFFFD8  b 0x823fa658
	pc = 0x823FA658; continue 'dispatch;
            }
            0x823FA684 => {
    //   block [0x823FA684..0x823FA69C)
	// 823FA684: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FA688: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 823FA68C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FA690: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 823FA694: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FA698: 4198FFAC  blt cr6, 0x823fa644
	if ctx.cr[6].lt {
	pc = 0x823FA644; continue 'dispatch;
	}
	pc = 0x823FA69C; continue 'dispatch;
            }
            0x823FA69C => {
    //   block [0x823FA69C..0x823FA6A0)
	// 823FA69C: 397E0074  addi r11, r30, 0x74
	ctx.r[11].s64 = ctx.r[30].s64 + 116;
	pc = 0x823FA6A0; continue 'dispatch;
            }
            0x823FA6A0 => {
    //   block [0x823FA6A0..0x823FA6BC)
	// 823FA6A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA6A4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA6A8: 41820024  beq 0x823fa6cc
	if ctx.cr[0].eq {
	pc = 0x823FA6CC; continue 'dispatch;
	}
	// 823FA6AC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA6B0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FA6B4: 409A0008  bne cr6, 0x823fa6bc
	if !ctx.cr[6].eq {
	pc = 0x823FA6BC; continue 'dispatch;
	}
	// 823FA6B8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	pc = 0x823FA6BC; continue 'dispatch;
            }
            0x823FA6BC => {
    //   block [0x823FA6BC..0x823FA6CC)
	// 823FA6BC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FA6C0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FA6C4: 936A0004  stw r27, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823FA6C8: 4BFFFFD8  b 0x823fa6a0
	pc = 0x823FA6A0; continue 'dispatch;
            }
            0x823FA6CC => {
    //   block [0x823FA6CC..0x823FA6D4)
	// 823FA6CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FA6D0: 4813AA34  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FA6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FA6D8 size=1332
    let mut pc: u32 = 0x823FA6D8;
    'dispatch: loop {
        match pc {
            0x823FA6D8 => {
    //   block [0x823FA6D8..0x823FA730)
	// 823FA6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FA6DC: 4813A9A5  bl 0x82535080
	ctx.lr = 0x823FA6E0;
	sub_82535080(ctx, base);
	// 823FA6E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FA6E4: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 823FA6E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823FA6EC: 7DEE7B78  mr r14, r15
	ctx.r[14].u64 = ctx.r[15].u64;
	// 823FA6F0: 7DF17B78  mr r17, r15
	ctx.r[17].u64 = ctx.r[15].u64;
	// 823FA6F4: 7DF07B78  mr r16, r15
	ctx.r[16].u64 = ctx.r[15].u64;
	// 823FA6F8: 4BFC54E1  bl 0x823bfbd8
	ctx.lr = 0x823FA6FC;
	sub_823BFBD8(ctx, base);
	// 823FA6FC: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FA700: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 823FA704: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FA708: 3A9C0074  addi r20, r28, 0x74
	ctx.r[20].s64 = ctx.r[28].s64 + 116;
	// 823FA70C: 7F125840  cmplw cr6, r18, r11
	ctx.cr[6].compare_u32(ctx.r[18].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FA710: 82BC0074  lwz r21, 0x74(r28)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) } as u64;
	// 823FA714: 7D6B9050  subf r11, r11, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[11].s64;
	// 823FA718: 28150000  cmplwi r21, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA71C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FA720: 917C0014  stw r11, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823FA724: 41820340  beq 0x823faa64
	if ctx.cr[0].eq {
	pc = 0x823FAA64; continue 'dispatch;
	}
	// 823FA728: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 823FA72C: 3A6BD470  addi r19, r11, -0x2b90
	ctx.r[19].s64 = ctx.r[11].s64 + -11152;
	pc = 0x823FA730; continue 'dispatch;
            }
            0x823FA730 => {
    //   block [0x823FA730..0x823FA780)
	// 823FA730: 83B50000  lwz r29, 0(r21)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA734: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA738: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823FA73C: 419A0328  beq cr6, 0x823faa64
	if ctx.cr[6].eq {
	pc = 0x823FAA64; continue 'dispatch;
	}
	// 823FA740: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FA744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 823FA748: 409A031C  bne cr6, 0x823faa64
	if !ctx.cr[6].eq {
	pc = 0x823FAA64; continue 'dispatch;
	}
	// 823FA74C: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA750: 7F115040  cmplw cr6, r17, r10
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823FA754: 40980310  bge cr6, 0x823faa64
	if !ctx.cr[6].lt {
	pc = 0x823FAA64; continue 'dispatch;
	}
	// 823FA758: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FA75C: 2F0A0014  cmpwi cr6, r10, 0x14
	ctx.cr[6].compare_i32(ctx.r[10].s32, 20, &mut ctx.xer);
	// 823FA760: 41980304  blt cr6, 0x823faa64
	if ctx.cr[6].lt {
	pc = 0x823FAA64; continue 'dispatch;
	}
	// 823FA764: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA768: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FA76C: 419A0044  beq cr6, 0x823fa7b0
	if ctx.cr[6].eq {
	pc = 0x823FA7B0; continue 'dispatch;
	}
	// 823FA770: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FA774: 419A000C  beq cr6, 0x823fa780
	if ctx.cr[6].eq {
	pc = 0x823FA780; continue 'dispatch;
	}
	// 823FA778: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 823FA77C: 409A0014  bne cr6, 0x823fa790
	if !ctx.cr[6].eq {
	pc = 0x823FA790; continue 'dispatch;
	}
	pc = 0x823FA780; continue 'dispatch;
            }
            0x823FA780 => {
    //   block [0x823FA780..0x823FA790)
	// 823FA780: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA784: 91FD0014  stw r15, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[15].u32 ) };
	// 823FA788: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA78C: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA790; continue 'dispatch;
            }
            0x823FA790 => {
    //   block [0x823FA790..0x823FA7B0)
	// 823FA790: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA794: 80BD000C  lwz r5, 0xc(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA798: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA79C: 4BFC6DC5  bl 0x823c1560
	ctx.lr = 0x823FA7A0;
	sub_823C1560(ctx, base);
	// 823FA7A0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA7A4: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 823FA7A8: 91FD0000  stw r15, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 823FA7AC: 480001A4  b 0x823fa950
	pc = 0x823FA950; continue 'dispatch;
            }
            0x823FA7B0 => {
    //   block [0x823FA7B0..0x823FA818)
	// 823FA7B0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FA7B4: 409A0140  bne cr6, 0x823fa8f4
	if !ctx.cr[6].eq {
	pc = 0x823FA8F4; continue 'dispatch;
	}
	// 823FA7B8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA7BC: 3AFC0018  addi r23, r28, 0x18
	ctx.r[23].s64 = ctx.r[28].s64 + 24;
	// 823FA7C0: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA7C4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA7C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FA7CC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 823FA7D0: 7FEB0194  addze r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	// 823FA7D4: 1D7F0003  mulli r11, r31, 3
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 3 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FA7D8: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823FA7DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FA7E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FA7E4: 4813A36D  bl 0x82534b50
	ctx.lr = 0x823FA7E8;
	sub_82534B50(ctx, base);
	// 823FA7E8: 1D7F0007  mulli r11, r31, 7
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 7 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FA7EC: 7F0BF214  add r24, r11, r30
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823FA7F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FA7F4: 7C9FF214  add r4, r31, r30
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 823FA7F8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 823FA7FC: 4813A355  bl 0x82534b50
	ctx.lr = 0x823FA800;
	sub_82534B50(ctx, base);
	// 823FA800: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 823FA804: 57F9083D  rlwinm. r25, r31, 1, 0, 0x1e
	ctx.r[25].u64 = ctx.r[31].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823FA808: 4081006C  ble 0x823fa874
	if !ctx.cr[0].gt {
	pc = 0x823FA874; continue 'dispatch;
	}
	// 823FA80C: 3979FFFF  addi r11, r25, -1
	ctx.r[11].s64 = ctx.r[25].s64 + -1;
	// 823FA810: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA814: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	pc = 0x823FA818; continue 'dispatch;
            }
            0x823FA818 => {
    //   block [0x823FA818..0x823FA874)
	// 823FA818: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA81C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823FA820: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823FA824: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FA828: 5564073E  clrlwi r4, r11, 0x1c
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823FA82C: 4BFFE765  bl 0x823f8f90
	ctx.lr = 0x823FA830;
	sub_823F8F90(ctx, base);
	// 823FA830: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823FA834: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FA838: A97A0000  lha r11, 0(r26)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FA83C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA840: B17A0000  sth r11, 0(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FA844: 3B5A0002  addi r26, r26, 2
	ctx.r[26].s64 = ctx.r[26].s64 + 2;
	// 823FA848: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA84C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 823FA850: 5564E13E  srwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823FA854: 4BFFE73D  bl 0x823f8f90
	ctx.lr = 0x823FA858;
	sub_823F8F90(ctx, base);
	// 823FA858: 36D6FFFF  addic. r22, r22, -1
	ctx.xer.ca = (ctx.r[22].u32 > (!(-1 as u32)));
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 823FA85C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823FA860: A97A0000  lha r11, 0(r26)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FA864: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA868: B17A0000  sth r11, 0(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FA86C: 3B5A0002  addi r26, r26, 2
	ctx.r[26].s64 = ctx.r[26].s64 + 2;
	// 823FA870: 4082FFA8  bne 0x823fa818
	if !ctx.cr[0].eq {
	pc = 0x823FA818; continue 'dispatch;
	}
	pc = 0x823FA874; continue 'dispatch;
            }
            0x823FA874 => {
    //   block [0x823FA874..0x823FA894)
	// 823FA874: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA878: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 823FA87C: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823FA880: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823FA884: 409900BC  ble cr6, 0x823fa940
	if !ctx.cr[6].gt {
	pc = 0x823FA940; continue 'dispatch;
	}
	// 823FA888: 3979FFFF  addi r11, r25, -1
	ctx.r[11].s64 = ctx.r[25].s64 + -1;
	// 823FA88C: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA890: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	pc = 0x823FA894; continue 'dispatch;
            }
            0x823FA894 => {
    //   block [0x823FA894..0x823FA8F4)
	// 823FA894: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA898: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823FA89C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FA8A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FA8A4: 5564073E  clrlwi r4, r11, 0x1c
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 823FA8A8: 4BFFE6E9  bl 0x823f8f90
	ctx.lr = 0x823FA8AC;
	sub_823F8F90(ctx, base);
	// 823FA8AC: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 823FA8B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FA8B4: A97F0000  lha r11, 0(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FA8B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA8BC: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FA8C0: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 823FA8C4: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA8C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FA8CC: 5564E13E  srwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 823FA8D0: 4BFFE6C1  bl 0x823f8f90
	ctx.lr = 0x823FA8D4;
	sub_823F8F90(ctx, base);
	// 823FA8D4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FA8D8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823FA8DC: A97F0000  lha r11, 0(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FA8E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA8E4: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FA8E8: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 823FA8EC: 4082FFA8  bne 0x823fa894
	if !ctx.cr[0].eq {
	pc = 0x823FA894; continue 'dispatch;
	}
	// 823FA8F0: 48000050  b 0x823fa940
	pc = 0x823FA940; continue 'dispatch;
            }
            0x823FA8F4 => {
    //   block [0x823FA8F4..0x823FA918)
	// 823FA8F4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 823FA8F8: 409A005C  bne cr6, 0x823fa954
	if !ctx.cr[6].eq {
	pc = 0x823FA954; continue 'dispatch;
	}
	// 823FA8FC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA900: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA904: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FA908: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 823FA90C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 823FA910: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FA914: 4182002C  beq 0x823fa940
	if ctx.cr[0].eq {
	pc = 0x823FA940; continue 'dispatch;
	}
	pc = 0x823FA918; continue 'dispatch;
            }
            0x823FA918 => {
    //   block [0x823FA918..0x823FA940)
	// 823FA918: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FA91C: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 823FA920: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FA924: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA928: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 823FA92C: 7D089A2E  lhzx r8, r8, r19
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 823FA930: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823FA934: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 823FA938: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823FA93C: 4082FFDC  bne 0x823fa918
	if !ctx.cr[0].eq {
	pc = 0x823FA918; continue 'dispatch;
	}
	pc = 0x823FA940; continue 'dispatch;
            }
            0x823FA940 => {
    //   block [0x823FA940..0x823FA950)
	// 823FA940: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA944: 91FD0014  stw r15, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[15].u32 ) };
	// 823FA948: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA94C: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA950; continue 'dispatch;
            }
            0x823FA950 => {
    //   block [0x823FA950..0x823FA954)
	// 823FA950: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x823FA954; continue 'dispatch;
            }
            0x823FA954 => {
    //   block [0x823FA954..0x823FA984)
	// 823FA954: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 823FA958: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FA95C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FA960: 4BFFF981  bl 0x823fa2e0
	ctx.lr = 0x823FA964;
	sub_823FA2E0(ctx, base);
	// 823FA964: 817C0090  lwz r11, 0x90(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(144 as u32) ) } as u64;
	// 823FA968: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FA96C: 409A009C  bne cr6, 0x823faa08
	if !ctx.cr[6].eq {
	pc = 0x823FAA08; continue 'dispatch;
	}
	// 823FA970: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FA974: 7DFB7B78  mr r27, r15
	ctx.r[27].u64 = ctx.r[15].u64;
	// 823FA978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FA97C: 4099008C  ble cr6, 0x823faa08
	if !ctx.cr[6].gt {
	pc = 0x823FAA08; continue 'dispatch;
	}
	// 823FA980: 3B5C0058  addi r26, r28, 0x58
	ctx.r[26].s64 = ctx.r[28].s64 + 88;
	pc = 0x823FA984; continue 'dispatch;
            }
            0x823FA984 => {
    //   block [0x823FA984..0x823FA9A8)
	// 823FA984: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FA988: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 823FA98C: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA990: 7D6BE850  subf r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 823FA994: 7D6B4BD6  divw r11, r11, r9
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 823FA998: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823FA99C: 4198000C  blt cr6, 0x823fa9a8
	if ctx.cr[6].lt {
	pc = 0x823FA9A8; continue 'dispatch;
	}
	// 823FA9A0: 7DFE7B78  mr r30, r15
	ctx.r[30].u64 = ctx.r[15].u64;
	// 823FA9A4: 48000010  b 0x823fa9b4
	pc = 0x823FA9B4; continue 'dispatch;
            }
            0x823FA9A8 => {
    //   block [0x823FA9A8..0x823FA9B4)
	// 823FA9A8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA9AC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FA9B0: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x823FA9B4; continue 'dispatch;
            }
            0x823FA9B4 => {
    //   block [0x823FA9B4..0x823FAA08)
	// 823FA9B4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FA9B8: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 823FA9BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FA9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FA9C4: 4BFC6B9D  bl 0x823c1560
	ctx.lr = 0x823FA9C8;
	sub_823C1560(ctx, base);
	// 823FA9C8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FA9CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FA9D0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FA9D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FA9D8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 823FA9DC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FA9E0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 823FA9E4: 4BFFFBB5  bl 0x823fa598
	ctx.lr = 0x823FA9E8;
	sub_823FA598(ctx, base);
	// 823FA9E8: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FA9EC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 823FA9F0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 823FA9F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FA9F8: 917D0018  stw r11, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 823FA9FC: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FAA00: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FAA04: 4198FF80  blt cr6, 0x823fa984
	if ctx.cr[6].lt {
	pc = 0x823FA984; continue 'dispatch;
	}
	pc = 0x823FAA08; continue 'dispatch;
            }
            0x823FAA08 => {
    //   block [0x823FAA08..0x823FAA24)
	// 823FAA08: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAA0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAA10: 41820020  beq 0x823faa30
	if ctx.cr[0].eq {
	pc = 0x823FAA30; continue 'dispatch;
	}
	// 823FAA14: 81540004  lwz r10, 4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FAA18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823FAA1C: 409A0008  bne cr6, 0x823faa24
	if !ctx.cr[6].eq {
	pc = 0x823FAA24; continue 'dispatch;
	}
	// 823FAA20: 91F40004  stw r15, 4(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(4 as u32), ctx.r[15].u32 ) };
	pc = 0x823FAA24; continue 'dispatch;
            }
            0x823FAA24 => {
    //   block [0x823FAA24..0x823FAA30)
	// 823FAA24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FAA28: 91540000  stw r10, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FAA2C: 91EB0004  stw r15, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[15].u32 ) };
	pc = 0x823FAA30; continue 'dispatch;
            }
            0x823FAA30 => {
    //   block [0x823FAA30..0x823FAA48)
	// 823FAA30: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FAA34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FAA38: 409A0010  bne cr6, 0x823faa48
	if !ctx.cr[6].eq {
	pc = 0x823FAA48; continue 'dispatch;
	}
	// 823FAA3C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 823FAA40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FAA44: 4BFFFA85  bl 0x823fa4c8
	ctx.lr = 0x823FAA48;
	sub_823FA4C8(ctx, base);
	pc = 0x823FAA48; continue 'dispatch;
            }
            0x823FAA48 => {
    //   block [0x823FAA48..0x823FAA64)
	// 823FAA48: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FAA4C: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 823FAA50: 82B40000  lwz r21, 0(r20)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAA54: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 823FAA58: 28150000  cmplwi r21, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAA5C: 917C0014  stw r11, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 823FAA60: 4082FCD0  bne 0x823fa730
	if !ctx.cr[0].eq {
	pc = 0x823FA730; continue 'dispatch;
	}
	pc = 0x823FAA64; continue 'dispatch;
            }
            0x823FAA64 => {
    //   block [0x823FAA64..0x823FAA7C)
	// 823FAA64: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FAA68: 7DFE7B78  mr r30, r15
	ctx.r[30].u64 = ctx.r[15].u64;
	// 823FAA6C: 925C0010  stw r18, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[18].u32 ) };
	// 823FAA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FAA74: 4099009C  ble cr6, 0x823fab10
	if !ctx.cr[6].gt {
	pc = 0x823FAB10; continue 'dispatch;
	}
	// 823FAA78: 3BFC0050  addi r31, r28, 0x50
	ctx.r[31].s64 = ctx.r[28].s64 + 80;
	pc = 0x823FAA7C; continue 'dispatch;
            }
            0x823FAA7C => {
    //   block [0x823FAA7C..0x823FAAC8)
	// 823FAA7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAA80: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FAA84: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAA88: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FAA8C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAA90: 1D4A0003  mulli r10, r10, 3
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 3 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823FAA94: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FAA98: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FAA9C: 392A0158  addi r9, r10, 0x158
	ctx.r[9].s64 = ctx.r[10].s64 + 344;
	// 823FAAA0: 394A014C  addi r10, r10, 0x14c
	ctx.r[10].s64 = ctx.r[10].s64 + 332;
	// 823FAAA4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FAAA8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FAAAC: 7C89582E  lwzx r4, r9, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823FAAB0: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823FAAB4: 4BFF9C4D  bl 0x823f4700
	ctx.lr = 0x823FAAB8;
	sub_823F4700(ctx, base);
	// 823FAAB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAABC: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 823FAAC0: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	// 823FAAC4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	pc = 0x823FAAC8; continue 'dispatch;
            }
            0x823FAAC8 => {
    //   block [0x823FAAC8..0x823FAAE0)
	// 823FAAC8: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FAACC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 823FAAD0: 419A0010  beq cr6, 0x823faae0
	if ctx.cr[6].eq {
	pc = 0x823FAAE0; continue 'dispatch;
	}
	// 823FAAD4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAAD8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 823FAADC: 419A0018  beq cr6, 0x823faaf4
	if ctx.cr[6].eq {
	pc = 0x823FAAF4; continue 'dispatch;
	}
	pc = 0x823FAAE0; continue 'dispatch;
            }
            0x823FAAE0 => {
    //   block [0x823FAAE0..0x823FAAF4)
	// 823FAAE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FAAE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FAAE8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 823FAAEC: 4198FFDC  blt cr6, 0x823faac8
	if ctx.cr[6].lt {
	pc = 0x823FAAC8; continue 'dispatch;
	}
	// 823FAAF0: 91FC0090  stw r15, 0x90(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(144 as u32), ctx.r[15].u32 ) };
	pc = 0x823FAAF4; continue 'dispatch;
            }
            0x823FAAF4 => {
    //   block [0x823FAAF4..0x823FAB10)
	// 823FAAF4: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FAAF8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 823FAAFC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FAB00: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FAB04: 4198FF78  blt cr6, 0x823faa7c
	if ctx.cr[6].lt {
	pc = 0x823FAA7C; continue 'dispatch;
	}
	// 823FAB08: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 823FAB0C: 419800F4  blt cr6, 0x823fac00
	if ctx.cr[6].lt {
	pc = 0x823FAC00; continue 'dispatch;
	}
	pc = 0x823FAB10; continue 'dispatch;
            }
            0x823FAB10 => {
    //   block [0x823FAB10..0x823FAB28)
	// 823FAB10: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FAB14: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 823FAB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FAB1C: 409900E4  ble cr6, 0x823fac00
	if !ctx.cr[6].gt {
	pc = 0x823FAC00; continue 'dispatch;
	}
	// 823FAB20: 3BA00018  li r29, 0x18
	ctx.r[29].s64 = 24;
	// 823FAB24: 3B60001C  li r27, 0x1c
	ctx.r[27].s64 = 28;
	pc = 0x823FAB28; continue 'dispatch;
            }
            0x823FAB28 => {
    //   block [0x823FAB28..0x823FAB34)
	// 823FAB28: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FAB2C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823FAB30: 3BCB0064  addi r30, r11, 0x64
	ctx.r[30].s64 = ctx.r[11].s64 + 100;
	pc = 0x823FAB34; continue 'dispatch;
            }
            0x823FAB34 => {
    //   block [0x823FAB34..0x823FAB5C)
	// 823FAB34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAB38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAB3C: 418200B4  beq 0x823fabf0
	if ctx.cr[0].eq {
	pc = 0x823FABF0; continue 'dispatch;
	}
	// 823FAB40: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAB44: 2B1F0002  cmplwi cr6, r31, 2
	ctx.cr[6].compare_u32(ctx.r[31].u32, 2 as u32, &mut ctx.xer);
	// 823FAB48: 409A0014  bne cr6, 0x823fab5c
	if !ctx.cr[6].eq {
	pc = 0x823FAB5C; continue 'dispatch;
	}
	// 823FAB4C: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FAB50: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823FAB54: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 823FAB58: 48000018  b 0x823fab70
	pc = 0x823FAB70; continue 'dispatch;
            }
            0x823FAB5C => {
    //   block [0x823FAB5C..0x823FAB70)
	// 823FAB5C: 397F001F  addi r11, r31, 0x1f
	ctx.r[11].s64 = ctx.r[31].s64 + 31;
	// 823FAB60: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FAB64: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 823FAB68: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823FAB6C: 7D6BEBD6  divw r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	pc = 0x823FAB70; continue 'dispatch;
            }
            0x823FAB70 => {
    //   block [0x823FAB70..0x823FAB84)
	// 823FAB70: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FAB74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 823FAB78: 4198000C  blt cr6, 0x823fab84
	if ctx.cr[6].lt {
	pc = 0x823FAB84; continue 'dispatch;
	}
	// 823FAB7C: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 823FAB80: 48000010  b 0x823fab90
	pc = 0x823FAB90; continue 'dispatch;
            }
            0x823FAB84 => {
    //   block [0x823FAB84..0x823FAB90)
	// 823FAB84: 815C0060  lwz r10, 0x60(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FAB88: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FAB8C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x823FAB90; continue 'dispatch;
            }
            0x823FAB90 => {
    //   block [0x823FAB90..0x823FABC8)
	// 823FAB90: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAB94: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAB98: 2F0B0103  cmpwi cr6, r11, 0x103
	ctx.cr[6].compare_i32(ctx.r[11].s32, 259, &mut ctx.xer);
	// 823FAB9C: 419A0054  beq cr6, 0x823fabf0
	if ctx.cr[6].eq {
	pc = 0x823FABF0; continue 'dispatch;
	}
	// 823FABA0: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FABA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FABA8: 419A0048  beq cr6, 0x823fabf0
	if ctx.cr[6].eq {
	pc = 0x823FABF0; continue 'dispatch;
	}
	// 823FABAC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FABB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FABB4: 41820020  beq 0x823fabd4
	if ctx.cr[0].eq {
	pc = 0x823FABD4; continue 'dispatch;
	}
	// 823FABB8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FABBC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FABC0: 409A0008  bne cr6, 0x823fabc8
	if !ctx.cr[6].eq {
	pc = 0x823FABC8; continue 'dispatch;
	}
	// 823FABC4: 91FE0004  stw r15, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[15].u32 ) };
	pc = 0x823FABC8; continue 'dispatch;
            }
            0x823FABC8 => {
    //   block [0x823FABC8..0x823FABD4)
	// 823FABC8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FABCC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FABD0: 91EB0004  stw r15, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[15].u32 ) };
	pc = 0x823FABD4; continue 'dispatch;
            }
            0x823FABD4 => {
    //   block [0x823FABD4..0x823FABF0)
	// 823FABD4: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FABD8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FABDC: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 823FABE0: 4082FF54  bne 0x823fab34
	if !ctx.cr[0].eq {
	pc = 0x823FAB34; continue 'dispatch;
	}
	// 823FABE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FABE8: 4BFFF8E1  bl 0x823fa4c8
	ctx.lr = 0x823FABEC;
	sub_823FA4C8(ctx, base);
	// 823FABEC: 4BFFFF48  b 0x823fab34
	pc = 0x823FAB34; continue 'dispatch;
            }
            0x823FABF0 => {
    //   block [0x823FABF0..0x823FAC00)
	// 823FABF0: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FABF4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823FABF8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FABFC: 4198FF2C  blt cr6, 0x823fab28
	if ctx.cr[6].lt {
	pc = 0x823FAB28; continue 'dispatch;
	}
	pc = 0x823FAC00; continue 'dispatch;
            }
            0x823FAC00 => {
    //   block [0x823FAC00..0x823FAC0C)
	// 823FAC00: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 823FAC04: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 823FAC08: 4813A4C8  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FAC10 size=252
    let mut pc: u32 = 0x823FAC10;
    'dispatch: loop {
        match pc {
            0x823FAC10 => {
    //   block [0x823FAC10..0x823FAC40)
	// 823FAC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAC14: 4813A4A5  bl 0x825350b8
	ctx.lr = 0x823FAC18;
	sub_82535080(ctx, base);
	// 823FAC18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAC1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FAC20: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FAC24: 419A00E0  beq cr6, 0x823fad04
	if ctx.cr[6].eq {
	pc = 0x823FAD04; continue 'dispatch;
	}
	// 823FAC28: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FAC2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FAC30: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 823FAC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FAC38: 40990068  ble cr6, 0x823faca0
	if !ctx.cr[6].gt {
	pc = 0x823FACA0; continue 'dispatch;
	}
	// 823FAC3C: 3BFE007C  addi r31, r30, 0x7c
	ctx.r[31].s64 = ctx.r[30].s64 + 124;
	pc = 0x823FAC40; continue 'dispatch;
            }
            0x823FAC40 => {
    //   block [0x823FAC40..0x823FAC70)
	// 823FAC40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 823FAC44: 807FFFD4  lwz r3, -0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-44 as u32) ) } as u64;
	// 823FAC48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823FAC4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FAC50: 4BFF9BD9  bl 0x823f4828
	ctx.lr = 0x823FAC54;
	sub_823F4828(ctx, base);
	// 823FAC54: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAC58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAC5C: 41820014  beq 0x823fac70
	if ctx.cr[0].eq {
	pc = 0x823FAC70; continue 'dispatch;
	}
	// 823FAC60: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FAC64: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823FAC68: 4BFCF5F1  bl 0x823ca258
	ctx.lr = 0x823FAC6C;
	sub_823CA258(ctx, base);
	// 823FAC6C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x823FAC70; continue 'dispatch;
            }
            0x823FAC70 => {
    //   block [0x823FAC70..0x823FAC8C)
	// 823FAC70: 807FFFDC  lwz r3, -0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-36 as u32) ) } as u64;
	// 823FAC74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAC78: 41820014  beq 0x823fac8c
	if ctx.cr[0].eq {
	pc = 0x823FAC8C; continue 'dispatch;
	}
	// 823FAC7C: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FAC80: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823FAC84: 4BFCF5D5  bl 0x823ca258
	ctx.lr = 0x823FAC88;
	sub_823CA258(ctx, base);
	// 823FAC88: 93BFFFDC  stw r29, -0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-36 as u32), ctx.r[29].u32 ) };
	pc = 0x823FAC8C; continue 'dispatch;
            }
            0x823FAC8C => {
    //   block [0x823FAC8C..0x823FACA0)
	// 823FAC8C: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 823FAC90: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 823FAC94: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FAC98: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FAC9C: 4198FFA4  blt cr6, 0x823fac40
	if ctx.cr[6].lt {
	pc = 0x823FAC40; continue 'dispatch;
	}
	pc = 0x823FACA0; continue 'dispatch;
            }
            0x823FACA0 => {
    //   block [0x823FACA0..0x823FACBC)
	// 823FACA0: 807E0060  lwz r3, 0x60(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FACA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FACA8: 41820014  beq 0x823facbc
	if ctx.cr[0].eq {
	pc = 0x823FACBC; continue 'dispatch;
	}
	// 823FACAC: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FACB0: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823FACB4: 4BFCF5A5  bl 0x823ca258
	ctx.lr = 0x823FACB8;
	sub_823CA258(ctx, base);
	// 823FACB8: 93BE0060  stw r29, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	pc = 0x823FACBC; continue 'dispatch;
            }
            0x823FACBC => {
    //   block [0x823FACBC..0x823FACD8)
	// 823FACBC: 807E0084  lwz r3, 0x84(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 823FACC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FACC4: 41820014  beq 0x823facd8
	if ctx.cr[0].eq {
	pc = 0x823FACD8; continue 'dispatch;
	}
	// 823FACC8: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FACCC: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823FACD0: 4BFCF589  bl 0x823ca258
	ctx.lr = 0x823FACD4;
	sub_823CA258(ctx, base);
	// 823FACD4: 93BE0084  stw r29, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	pc = 0x823FACD8; continue 'dispatch;
            }
            0x823FACD8 => {
    //   block [0x823FACD8..0x823FACF4)
	// 823FACD8: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FACDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FACE0: 41820014  beq 0x823facf4
	if ctx.cr[0].eq {
	pc = 0x823FACF4; continue 'dispatch;
	}
	// 823FACE4: 3C80608A  lis r4, 0x608a
	ctx.r[4].s64 = 1619656704;
	// 823FACE8: 60842002  ori r4, r4, 0x2002
	ctx.r[4].u64 = ctx.r[4].u64 | 8194;
	// 823FACEC: 4BFCF56D  bl 0x823ca258
	ctx.lr = 0x823FACF0;
	sub_823CA258(ctx, base);
	// 823FACF0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x823FACF4; continue 'dispatch;
            }
            0x823FACF4 => {
    //   block [0x823FACF4..0x823FAD04)
	// 823FACF4: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FACF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FACFC: 6084800D  ori r4, r4, 0x800d
	ctx.r[4].u64 = ctx.r[4].u64 | 32781;
	// 823FAD00: 4BFCF559  bl 0x823ca258
	ctx.lr = 0x823FAD04;
	sub_823CA258(ctx, base);
	pc = 0x823FAD04; continue 'dispatch;
            }
            0x823FAD04 => {
    //   block [0x823FAD04..0x823FAD0C)
	// 823FAD04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FAD08: 4813A400  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FAD10 size=148
    let mut pc: u32 = 0x823FAD10;
    'dispatch: loop {
        match pc {
            0x823FAD10 => {
    //   block [0x823FAD10..0x823FAD38)
	// 823FAD10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAD14: 4813A3A9  bl 0x825350bc
	ctx.lr = 0x823FAD18;
	sub_82535080(ctx, base);
	// 823FAD18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAD1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FAD20: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FAD24: 4BFFF8F5  bl 0x823fa618
	ctx.lr = 0x823FAD28;
	sub_823FA618(ctx, base);
	// 823FAD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FAD2C: 4BFFF3C5  bl 0x823fa0f0
	ctx.lr = 0x823FAD30;
	sub_823FA0F0(ctx, base);
	// 823FAD30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FAD34: 48000038  b 0x823fad6c
	pc = 0x823FAD6C; continue 'dispatch;
            }
            0x823FAD38 => {
    //   block [0x823FAD38..0x823FAD58)
	// 823FAD38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FAD3C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 823FAD40: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 823FAD44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FAD48: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 823FAD4C: 4198000C  blt cr6, 0x823fad58
	if ctx.cr[6].lt {
	pc = 0x823FAD58; continue 'dispatch;
	}
	// 823FAD50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FAD54: 48000010  b 0x823fad64
	pc = 0x823FAD64; continue 'dispatch;
            }
            0x823FAD58 => {
    //   block [0x823FAD58..0x823FAD64)
	// 823FAD58: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FAD5C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FAD60: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x823FAD64; continue 'dispatch;
            }
            0x823FAD64 => {
    //   block [0x823FAD64..0x823FAD6C)
	// 823FAD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FAD68: 4BFFF761  bl 0x823fa4c8
	ctx.lr = 0x823FAD6C;
	sub_823FA4C8(ctx, base);
	pc = 0x823FAD6C; continue 'dispatch;
            }
            0x823FAD6C => {
    //   block [0x823FAD6C..0x823FADA4)
	// 823FAD6C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FAD70: 409AFFC8  bne cr6, 0x823fad38
	if !ctx.cr[6].eq {
	pc = 0x823FAD38; continue 'dispatch;
	}
	// 823FAD74: 39600258  li r11, 0x258
	ctx.r[11].s64 = 600;
	// 823FAD78: 9BBF008C  stb r29, 0x8c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[29].u8 ) };
	// 823FAD7C: 93BF0090  stw r29, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 823FAD80: 93BF0098  stw r29, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 823FAD84: 93BF009C  stw r29, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 823FAD88: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 823FAD8C: 4BFC4E4D  bl 0x823bfbd8
	ctx.lr = 0x823FAD90;
	sub_823BFBD8(ctx, base);
	// 823FAD90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FAD94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FAD98: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 823FAD9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FADA0: 4813A36C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FADA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FADA8 size=296
    let mut pc: u32 = 0x823FADA8;
    'dispatch: loop {
        match pc {
            0x823FADA8 => {
    //   block [0x823FADA8..0x823FAE1C)
	// 823FADA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FADAC: 4813A301  bl 0x825350ac
	ctx.lr = 0x823FADB0;
	sub_82535080(ctx, base);
	// 823FADB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FADB4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823FADB8: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FADBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FADC0: 6084800D  ori r4, r4, 0x800d
	ctx.r[4].u64 = ctx.r[4].u64 | 32781;
	// 823FADC4: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 823FADC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 823FADCC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 823FADD0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 823FADD4: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 823FADD8: 4BFCF3E9  bl 0x823ca1c0
	ctx.lr = 0x823FADDC;
	sub_823CA1C0(ctx, base);
	// 823FADDC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FADE0: 418200E4  beq 0x823faec4
	if ctx.cr[0].eq {
	pc = 0x823FAEC4; continue 'dispatch;
	}
	// 823FADE4: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FADE8: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 823FADEC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823FADF0: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 823FADF4: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 823FADF8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823FADFC: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 823FAE00: 48139D51  bl 0x82534b50
	ctx.lr = 0x823FAE04;
	sub_82534B50(ctx, base);
	// 823FAE04: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FAE08: 419A0090  beq cr6, 0x823fae98
	if ctx.cr[6].eq {
	pc = 0x823FAE98; continue 'dispatch;
	}
	// 823FAE0C: 397E0016  addi r11, r30, 0x16
	ctx.r[11].s64 = ctx.r[30].s64 + 22;
	// 823FAE10: 1F7C0018  mulli r27, r28, 0x18
	ctx.r[27].s32 = ((ctx.r[28].s32 as i64 * 24 as i64) as i32);
	ctx.r[27].s64 = ctx.r[27].s32 as i64;
	// 823FAE14: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FAE18: 7FABFA14  add r29, r11, r31
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x823FAE1C; continue 'dispatch;
            }
            0x823FAE1C => {
    //   block [0x823FAE1C..0x823FAE70)
	// 823FAE1C: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FAE20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FAE24: 60840009  ori r4, r4, 9
	ctx.r[4].u64 = ctx.r[4].u64 | 9;
	// 823FAE28: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 823FAE2C: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 823FAE30: 4BFCF391  bl 0x823ca1c0
	ctx.lr = 0x823FAE34;
	sub_823CA1C0(ctx, base);
	// 823FAE34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAE38: 907D0024  stw r3, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 823FAE3C: 41820088  beq 0x823faec4
	if ctx.cr[0].eq {
	pc = 0x823FAEC4; continue 'dispatch;
	}
	// 823FAE40: 3C80618A  lis r4, 0x618a
	ctx.r[4].s64 = 1636433920;
	// 823FAE44: 57831838  slwi r3, r28, 3
	ctx.r[3].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 823FAE48: 60840003  ori r4, r4, 3
	ctx.r[4].u64 = ctx.r[4].u64 | 3;
	// 823FAE4C: 4BFCF375  bl 0x823ca1c0
	ctx.lr = 0x823FAE50;
	sub_823CA1C0(ctx, base);
	// 823FAE50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FAE54: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FAE58: 4182006C  beq 0x823faec4
	if ctx.cr[0].eq {
	pc = 0x823FAEC4; continue 'dispatch;
	}
	// 823FAE5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823FAE60: 419A0030  beq cr6, 0x823fae90
	if ctx.cr[6].eq {
	pc = 0x823FAE90; continue 'dispatch;
	}
	// 823FAE64: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FAE68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FAE6C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x823FAE70; continue 'dispatch;
            }
            0x823FAE70 => {
    //   block [0x823FAE70..0x823FAE90)
	// 823FAE70: 811D0024  lwz r8, 0x24(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 823FAE74: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FAE78: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAE7C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FAE80: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 823FAE84: 7D07492E  stwx r8, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 823FAE88: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 823FAE8C: 4082FFE4  bne 0x823fae70
	if !ctx.cr[0].eq {
	pc = 0x823FAE70; continue 'dispatch;
	}
	pc = 0x823FAE90; continue 'dispatch;
            }
            0x823FAE90 => {
    //   block [0x823FAE90..0x823FAE98)
	// 823FAE90: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FAE94: 409AFF88  bne cr6, 0x823fae1c
	if !ctx.cr[6].eq {
	pc = 0x823FAE1C; continue 'dispatch;
	}
	pc = 0x823FAE98; continue 'dispatch;
            }
            0x823FAE98 => {
    //   block [0x823FAE98..0x823FAEA8)
	// 823FAE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FAE9C: 4BFFF255  bl 0x823fa0f0
	ctx.lr = 0x823FAEA0;
	sub_823FA0F0(ctx, base);
	// 823FAEA0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FAEA4: 40800010  bge 0x823faeb4
	if !ctx.cr[0].lt {
	pc = 0x823FAEB4; continue 'dispatch;
	}
	pc = 0x823FAEA8; continue 'dispatch;
            }
            0x823FAEA8 => {
    //   block [0x823FAEA8..0x823FAEB4)
	// 823FAEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FAEAC: 4BFFFD65  bl 0x823fac10
	ctx.lr = 0x823FAEB0;
	sub_823FAC10(ctx, base);
	// 823FAEB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x823FAEB4; continue 'dispatch;
            }
            0x823FAEB4 => {
    //   block [0x823FAEB4..0x823FAEC4)
	// 823FAEB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FAEB8: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FAEBC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FAEC0: 4813A23C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x823FAEC4 => {
    //   block [0x823FAEC4..0x823FAED0)
	// 823FAEC4: 3FC08007  lis r30, -0x7ff9
	ctx.r[30].s64 = -2147024896;
	// 823FAEC8: 63DE000E  ori r30, r30, 0xe
	ctx.r[30].u64 = ctx.r[30].u64 | 14;
	// 823FAECC: 4BFFFFDC  b 0x823faea8
	pc = 0x823FAEA8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FAED0 size=108
    let mut pc: u32 = 0x823FAED0;
    'dispatch: loop {
        match pc {
            0x823FAED0 => {
    //   block [0x823FAED0..0x823FAF0C)
	// 823FAED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAED4: 4813A1E9  bl 0x825350bc
	ctx.lr = 0x823FAED8;
	sub_82535080(ctx, base);
	// 823FAED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAEDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FAEE0: B0E10054  sth r7, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u16 ) };
	// 823FAEE4: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 823FAEE8: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 823FAEEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FAEF0: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 823FAEF4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 823FAEF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FAEFC: 3BEB7310  addi r31, r11, 0x7310
	ctx.r[31].s64 = ctx.r[11].s64 + 29456;
	// 823FAF00: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 823FAF04: 91230040  stw r9, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 823FAF08: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x823FAF0C; continue 'dispatch;
            }
            0x823FAF0C => {
    //   block [0x823FAF0C..0x823FAF3C)
	// 823FAF0C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FAF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823FAF14: A8BE0000  lha r5, 0(r30)
	ctx.r[5].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FAF18: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823FAF1C: 480013AD  bl 0x823fc2c8
	ctx.lr = 0x823FAF20;
	sub_823FC2C8(ctx, base);
	// 823FAF20: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 823FAF24: 397F0022  addi r11, r31, 0x22
	ctx.r[11].s64 = ctx.r[31].s64 + 34;
	// 823FAF28: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FAF2C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FAF30: 4198FFDC  blt cr6, 0x823faf0c
	if ctx.cr[6].lt {
	pc = 0x823FAF0C; continue 'dispatch;
	}
	// 823FAF34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FAF38: 4813A1D4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FAF40 size=152
    let mut pc: u32 = 0x823FAF40;
    'dispatch: loop {
        match pc {
            0x823FAF40 => {
    //   block [0x823FAF40..0x823FAFD8)
	// 823FAF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAF44: 4813A16D  bl 0x825350b0
	ctx.lr = 0x823FAF48;
	sub_82535080(ctx, base);
	// 823FAF48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAF4C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FAF50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823FAF54: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 823FAF58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FAF5C: 3B7E0004  addi r27, r30, 4
	ctx.r[27].s64 = ctx.r[30].s64 + 4;
	// 823FAF60: C05E0004  lfs f2, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FAF64: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 823FAF68: C03C0038  lfs f1, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAF6C: C07F0004  lfs f3, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FAF70: 48001B49  bl 0x823fcab8
	ctx.lr = 0x823FAF74;
	sub_823FCAB8(ctx, base);
	// 823FAF74: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823FAF78: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823FAF7C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823FAF80: C03C0038  lfs f1, 0x38(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAF84: 48001BB5  bl 0x823fcb38
	ctx.lr = 0x823FAF88;
	sub_823FCB38(ctx, base);
	// 823FAF88: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAF8C: 48001A45  bl 0x823fc9d0
	ctx.lr = 0x823FAF90;
	sub_823FC9D0(ctx, base);
	// 823FAF90: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823FAF94: 48001AD5  bl 0x823fca68
	ctx.lr = 0x823FAF98;
	sub_823FCA68(ctx, base);
	// 823FAF98: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FAF9C: C03E0010  lfs f1, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAFA0: 480019D9  bl 0x823fc978
	ctx.lr = 0x823FAFA4;
	sub_823FC978(ctx, base);
	// 823FAFA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FAFA8: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823FAFAC: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 823FAFB0: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 823FAFB4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FAFB8: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FAFBC: 48001725  bl 0x823fc6e0
	ctx.lr = 0x823FAFC0;
	sub_823FC6E0(ctx, base);
	// 823FAFC0: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FAFC4: D01C0038  stfs f0, 0x38(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 823FAFC8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FAFCC: D01C003C  stfs f0, 0x3c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 823FAFD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FAFD4: 4813A12C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FAFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FAFD8 size=300
    let mut pc: u32 = 0x823FAFD8;
    'dispatch: loop {
        match pc {
            0x823FAFD8 => {
    //   block [0x823FAFD8..0x823FAFF8)
	// 823FAFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FAFDC: 4813A0D5  bl 0x825350b0
	ctx.lr = 0x823FAFE0;
	sub_82535080(ctx, base);
	// 823FAFE0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823FAFE4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FAFE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FAFEC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823FAFF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 823FAFF4: 409A000C  bne cr6, 0x823fb000
	if !ctx.cr[6].eq {
	pc = 0x823FB000; continue 'dispatch;
	}
	pc = 0x823FAFF8; continue 'dispatch;
            }
            0x823FAFF8 => {
    //   block [0x823FAFF8..0x823FB000)
	// 823FAFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FAFFC: 480000FC  b 0x823fb0f8
	pc = 0x823FB0F8; continue 'dispatch;
            }
            0x823FB000 => {
    //   block [0x823FB000..0x823FB0F8)
	// 823FB000: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 823FB004: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 823FB008: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 823FB00C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FB010: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 823FB014: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FB018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB01C: 4E800421  bctrl
	ctx.lr = 0x823FB020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB020: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FB024: 4182FFD4  beq 0x823faff8
	if ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB028: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 823FB02C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FB030: 935F0040  stw r26, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[26].u32 ) };
	// 823FB034: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 823FB038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FB03C: 937F0044  stw r27, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[27].u32 ) };
	// 823FB040: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FB044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB048: 4E800421  bctrl
	ctx.lr = 0x823FB04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB04C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB050: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 823FB054: 4182FFA4  beq 0x823faff8
	if ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB058: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FB05C: B38B001C  sth r28, 0x1c(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[28].u16 ) };
	// 823FB060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FB064: B38B0024  sth r28, 0x24(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[28].u16 ) };
	// 823FB068: 38600173  li r3, 0x173
	ctx.r[3].s64 = 371;
	// 823FB06C: C00A1850  lfs f0, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB070: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FB074: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823FB078: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823FB07C: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 823FB080: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FB084: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB088: D3EB0018  stfs f31, 0x18(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 823FB08C: 48002745  bl 0x823fd7d0
	ctx.lr = 0x823FB090;
	sub_823FD7D0(ctx, base);
	// 823FB090: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FB094: 4082FF64  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB098: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823FB09C: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 823FB0A0: 48002669  bl 0x823fd708
	ctx.lr = 0x823FB0A4;
	sub_823FD708(ctx, base);
	// 823FB0A4: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB0A8: 4082FF50  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB0AC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 823FB0B0: 48001DA1  bl 0x823fce50
	ctx.lr = 0x823FB0B4;
	sub_823FCE50(ctx, base);
	// 823FB0B4: 546B043F  clrlwi. r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB0B8: 4082FF40  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB0BC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823FB0C0: 48001CE1  bl 0x823fcda0
	ctx.lr = 0x823FB0C4;
	sub_823FCDA0(ctx, base);
	// 823FB0C4: 7C6B0735  extsh. r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB0C8: 4082FF30  bne 0x823faff8
	if !ctx.cr[0].eq {
	pc = 0x823FAFF8; continue 'dispatch;
	}
	// 823FB0CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB0D0: D3FF001C  stfs f31, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FB0D4: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823FB0D8: 937F0020  stw r27, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 823FB0DC: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 823FB0E0: 937F0028  stw r27, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[27].u32 ) };
	// 823FB0E4: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 823FB0E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FB0EC: C00B2094  lfs f0, 0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB0F0: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823FB0F4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
            }
            0x823FB0F8 => {
    //   block [0x823FB0F8..0x823FB104)
	// 823FB0F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FB0FC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 823FB100: 4813A000  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FB108 size=144
    let mut pc: u32 = 0x823FB108;
    'dispatch: loop {
        match pc {
            0x823FB108 => {
    //   block [0x823FB108..0x823FB16C)
	// 823FB108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FB110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FB114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FB118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB11C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FB120: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FB124: 41820058  beq 0x823fb17c
	if ctx.cr[0].eq {
	pc = 0x823FB17C; continue 'dispatch;
	}
	// 823FB128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FB12C: 48004E3D  bl 0x823fff68
	ctx.lr = 0x823FB130;
	sub_823FFF68(ctx, base);
	// 823FB130: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823FB134: 4800264D  bl 0x823fd780
	ctx.lr = 0x823FB138;
	sub_823FD780(ctx, base);
	// 823FB138: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 823FB13C: 48001DBD  bl 0x823fcef8
	ctx.lr = 0x823FB140;
	sub_823FCEF8(ctx, base);
	// 823FB140: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 823FB144: 4800263D  bl 0x823fd780
	ctx.lr = 0x823FB148;
	sub_823FD780(ctx, base);
	// 823FB148: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823FB14C: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FB150: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FB154: 41820018  beq 0x823fb16c
	if ctx.cr[0].eq {
	pc = 0x823FB16C; continue 'dispatch;
	}
	// 823FB158: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FB15C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB160: 4E800421  bctrl
	ctx.lr = 0x823FB164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FB164: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FB168: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
            }
            0x823FB16C => {
    //   block [0x823FB16C..0x823FB17C)
	// 823FB16C: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FB170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FB174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB178: 4E800421  bctrl
	ctx.lr = 0x823FB17C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823FB17C => {
    //   block [0x823FB17C..0x823FB198)
	// 823FB17C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FB180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FB184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FB188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FB18C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FB190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FB194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB198 size=232
    let mut pc: u32 = 0x823FB198;
    'dispatch: loop {
        match pc {
            0x823FB198 => {
    //   block [0x823FB198..0x823FB1DC)
	// 823FB198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FB1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FB1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FB1A8: 9421F2F0  stwu r1, -0xd10(r1)
	ea = ctx.r[1].u32.wrapping_add(-3344 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB1AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823FB1B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FB1B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823FB1B8: 38A00123  li r5, 0x123
	ctx.r[5].s64 = 291;
	// 823FB1BC: 38800091  li r4, 0x91
	ctx.r[4].s64 = 145;
	// 823FB1C0: 480027A1  bl 0x823fd960
	ctx.lr = 0x823FB1C4;
	sub_823FD960(ctx, base);
	// 823FB1C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB1C8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FB1CC: 396B7338  addi r11, r11, 0x7338
	ctx.r[11].s64 = ctx.r[11].s64 + 29496;
	// 823FB1D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FB1D4: 38E00091  li r7, 0x91
	ctx.r[7].s64 = 145;
	// 823FB1D8: 390104D8  addi r8, r1, 0x4d8
	ctx.r[8].s64 = ctx.r[1].s64 + 1240;
	pc = 0x823FB1DC; continue 'dispatch;
            }
            0x823FB1DC => {
    //   block [0x823FB1DC..0x823FB280)
	// 823FB1DC: C1AA0000  lfs f13, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB1E0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FB1E4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB1E8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FB1EC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB1F0: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB1F4: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB1F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FB1FC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB200: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB204: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FB208: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 823FB20C: 4181FFD0  bgt 0x823fb1dc
	if ctx.cr[0].gt {
	pc = 0x823FB1DC; continue 'dispatch;
	}
	// 823FB210: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB214: 38A00123  li r5, 0x123
	ctx.r[5].s64 = 291;
	// 823FB218: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB21C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823FB220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823FB224: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FB228: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB22C: 480029ED  bl 0x823fdc18
	ctx.lr = 0x823FB230;
	sub_823FDC18(ctx, base);
	// 823FB230: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB234: 38E108F0  addi r7, r1, 0x8f0
	ctx.r[7].s64 = ctx.r[1].s64 + 2288;
	// 823FB238: 38C104E0  addi r6, r1, 0x4e0
	ctx.r[6].s64 = ctx.r[1].s64 + 1248;
	// 823FB23C: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 823FB240: 38800123  li r4, 0x123
	ctx.r[4].s64 = 291;
	// 823FB244: C00B7584  lfs f0, 0x7584(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 823FB24C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB250: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB254: 4800286D  bl 0x823fdac0
	ctx.lr = 0x823FB258;
	sub_823FDAC0(ctx, base);
	// 823FB258: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FB25C: 388108F0  addi r4, r1, 0x8f0
	ctx.r[4].s64 = ctx.r[1].s64 + 2288;
	// 823FB260: 386104E0  addi r3, r1, 0x4e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1248;
	// 823FB264: 48002275  bl 0x823fd4d8
	ctx.lr = 0x823FB268;
	sub_823FD4D8(ctx, base);
	// 823FB268: 38210D10  addi r1, r1, 0xd10
	ctx.r[1].s64 = ctx.r[1].s64 + 3344;
	// 823FB26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FB270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FB274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FB278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FB27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB280 size=444
    let mut pc: u32 = 0x823FB280;
    'dispatch: loop {
        match pc {
            0x823FB280 => {
    //   block [0x823FB280..0x823FB2DC)
	// 823FB280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB284: 48139E19  bl 0x8253509c
	ctx.lr = 0x823FB288;
	sub_82535080(ctx, base);
	// 823FB288: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 823FB28C: 4813AD5D  bl 0x82535fe8
	ctx.lr = 0x823FB290;
	sub_82535FB0(ctx, base);
	// 823FB290: 9421FA00  stwu r1, -0x600(r1)
	ea = ctx.r[1].u32.wrapping_add(-1536 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB294: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 823FB298: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FB29C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FB2A0: 3976FFFF  addi r11, r22, -1
	ctx.r[11].s64 = ctx.r[22].s64 + -1;
	// 823FB2A4: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 823FB2A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FB2AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FB2B0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FB2B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FB2B8: FF800018  frsp f28, f0
	ctx.f[28].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FB2BC: EC1CF024  fdivs f0, f28, f30
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[30].f64) as f32) as f64;
	// 823FB2C0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FB2C4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FB2C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB2CC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 823FB2D0: 2F1D0050  cmpwi cr6, r29, 0x50
	ctx.cr[6].compare_i32(ctx.r[29].s32, 80, &mut ctx.xer);
	// 823FB2D4: 40990008  ble cr6, 0x823fb2dc
	if !ctx.cr[6].gt {
	pc = 0x823FB2DC; continue 'dispatch;
	}
	// 823FB2D8: 3BA00050  li r29, 0x50
	ctx.r[29].s64 = 80;
	pc = 0x823FB2DC; continue 'dispatch;
            }
            0x823FB2DC => {
    //   block [0x823FB2DC..0x823FB320)
	// 823FB2DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB2E0: 57BB103A  slwi r27, r29, 2
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 823FB2E4: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FB2E8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 823FB2EC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823FB2F0: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB2F4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 823FB2F8: 7FCA4A14  add r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FB2FC: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 823FB300: 4099005C  ble cr6, 0x823fb35c
	if !ctx.cr[6].gt {
	pc = 0x823FB35C; continue 'dispatch;
	}
	// 823FB304: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FB308: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 823FB30C: 7F1E5850  subf r24, r30, r11
	ctx.r[24].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 823FB310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB314: 7EFEF850  subf r23, r30, r31
	ctx.r[23].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 823FB318: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 823FB31C: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x823FB320; continue 'dispatch;
            }
            0x823FB320 => {
    //   block [0x823FB320..0x823FB35C)
	// 823FB320: EC1FE82A  fadds f0, f31, f29
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 823FB324: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FB328: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FB32C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FB330: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB334: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FB338: 7C2BAC2E  lfsx f1, r11, r21
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[21].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB33C: 48002E2D  bl 0x823fe168
	ctx.lr = 0x823FB340;
	sub_823FE168(ctx, base);
	// 823FB340: 7C38E52E  stfsx f1, r24, r28
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 823FB344: 933C0000  stw r25, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 823FB348: 7FF7E52E  stfsx f31, r23, r28
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[23].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 823FB34C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 823FB350: EFFFF02A  fadds f31, f31, f30
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 823FB354: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FB358: 4082FFC8  bne 0x823fb320
	if !ctx.cr[0].eq {
	pc = 0x823FB320; continue 'dispatch;
	}
	pc = 0x823FB35C; continue 'dispatch;
            }
            0x823FB35C => {
    //   block [0x823FB35C..0x823FB3B0)
	// 823FB35C: 56CB103A  slwi r11, r22, 2
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FB360: 7D6BAA14  add r11, r11, r21
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 823FB364: C02BFFFC  lfs f1, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB368: 48002E01  bl 0x823fe168
	ctx.lr = 0x823FB36C;
	sub_823FE168(ctx, base);
	// 823FB36C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FB370: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 823FB374: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 823FB378: 7C3B5D2E  stfsx f1, r27, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FB37C: 7EDBF12E  stwx r22, r27, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[30].u32), ctx.r[22].u32) };
	// 823FB380: 7F9BFD2E  stfsx f28, r27, r31
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FB384: 409900A8  ble cr6, 0x823fb42c
	if !ctx.cr[6].gt {
	pc = 0x823FB42C; continue 'dispatch;
	}
	// 823FB388: 38CAFFFF  addi r6, r10, -1
	ctx.r[6].s64 = ctx.r[10].s64 + -1;
	// 823FB38C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FB390: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 823FB394: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 823FB398: 391E0004  addi r8, r30, 4
	ctx.r[8].s64 = ctx.r[30].s64 + 4;
	// 823FB39C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FB3A0: C14A1850  lfs f10, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FB3A4: 7FDFF050  subf r30, r31, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 823FB3A8: 7CBF4850  subf r5, r31, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[31].s64;
	// 823FB3AC: 7C9F3850  subf r4, r31, r7
	ctx.r[4].s64 = ctx.r[7].s64 - ctx.r[31].s64;
	pc = 0x823FB3B0; continue 'dispatch;
            }
            0x823FB3B0 => {
    //   block [0x823FB3B0..0x823FB3E8)
	// 823FB3B0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB3B4: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823FB3B8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB3BC: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FB3C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FB3C4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 823FB3C8: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FB3CC: ED6A0024  fdivs f11, f10, f0
	ctx.f[11].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FB3D0: 4098004C  bge cr6, 0x823fb41c
	if !ctx.cr[6].lt {
	pc = 0x823FB41C; continue 'dispatch;
	}
	// 823FB3D4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FB3D8: 7C055C2E  lfsx f0, r5, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB3DC: 7D845C2E  lfsx f12, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB3E0: 7D69AA14  add r11, r9, r21
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[21].u64;
	// 823FB3E4: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x823FB3E8; continue 'dispatch;
            }
            0x823FB3E8 => {
    //   block [0x823FB3E8..0x823FB41C)
	// 823FB3E8: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 823FB3EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FB3F0: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FB3F4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 823FB3F8: C9210050  lfd f9, 0x50(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FB3FC: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 823FB400: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 823FB404: ED296828  fsubs f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FB408: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FB40C: ED2902FA  fmadds f9, f9, f11, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FB410: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB414: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FB418: 4198FFD0  blt cr6, 0x823fb3e8
	if ctx.cr[6].lt {
	pc = 0x823FB3E8; continue 'dispatch;
	}
	pc = 0x823FB41C; continue 'dispatch;
            }
            0x823FB41C => {
    //   block [0x823FB41C..0x823FB42C)
	// 823FB41C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823FB420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FB424: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FB428: 4082FF88  bne 0x823fb3b0
	if !ctx.cr[0].eq {
	pc = 0x823FB3B0; continue 'dispatch;
	}
	pc = 0x823FB42C; continue 'dispatch;
            }
            0x823FB42C => {
    //   block [0x823FB42C..0x823FB43C)
	// 823FB42C: 38210600  addi r1, r1, 0x600
	ctx.r[1].s64 = ctx.r[1].s64 + 1536;
	// 823FB430: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 823FB434: 4813AC01  bl 0x82536034
	ctx.lr = 0x823FB438;
	sub_82535FFC(ctx, base);
	// 823FB438: 48139CB4  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB440 size=632
    let mut pc: u32 = 0x823FB440;
    'dispatch: loop {
        match pc {
            0x823FB440 => {
    //   block [0x823FB440..0x823FB51C)
	// 823FB440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB444: 48139C65  bl 0x825350a8
	ctx.lr = 0x823FB448;
	sub_82535080(ctx, base);
	// 823FB448: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 823FB44C: 9421F390  stwu r1, -0xc70(r1)
	ea = ctx.r[1].u32.wrapping_add(-3184 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB450: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823FB454: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 823FB458: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823FB45C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823FB460: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823FB464: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 823FB468: 83FD0048  lwz r31, 0x48(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 823FB46C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 823FB470: 39200064  li r9, 0x64
	ctx.r[9].s64 = 100;
	// 823FB474: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823FB478: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FB47C: 38C10600  addi r6, r1, 0x600
	ctx.r[6].s64 = ctx.r[1].s64 + 1536;
	// 823FB480: 38A10200  addi r5, r1, 0x200
	ctx.r[5].s64 = ctx.r[1].s64 + 512;
	// 823FB484: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 823FB488: 48003BB9  bl 0x823ff040
	ctx.lr = 0x823FB48C;
	sub_823FF040(ctx, base);
	// 823FB48C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB490: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB494: 39200064  li r9, 0x64
	ctx.r[9].s64 = 100;
	// 823FB498: 38E10200  addi r7, r1, 0x200
	ctx.r[7].s64 = ctx.r[1].s64 + 512;
	// 823FB49C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB4A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 823FB4A4: 38810600  addi r4, r1, 0x600
	ctx.r[4].s64 = ctx.r[1].s64 + 1536;
	// 823FB4A8: C00B7588  lfs f0, 0x7588(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB4AC: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 823FB4B0: EFE06824  fdivs f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FB4B4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FB4B8: 48003901  bl 0x823fedb8
	ctx.lr = 0x823FB4BC;
	sub_823FEDB8(ctx, base);
	// 823FB4BC: 3B5E0004  addi r26, r30, 4
	ctx.r[26].s64 = ctx.r[30].s64 + 4;
	// 823FB4C0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FB4C4: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 823FB4C8: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 823FB4CC: 38E10600  addi r7, r1, 0x600
	ctx.r[7].s64 = ctx.r[1].s64 + 1536;
	// 823FB4D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FB4D4: 38810200  addi r4, r1, 0x200
	ctx.r[4].s64 = ctx.r[1].s64 + 512;
	// 823FB4D8: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 823FB4DC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823FB4E0: 48002EA1  bl 0x823fe380
	ctx.lr = 0x823FB4E4;
	sub_823FE380(ctx, base);
	// 823FB4E4: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FB4E8: 38810200  addi r4, r1, 0x200
	ctx.r[4].s64 = ctx.r[1].s64 + 512;
	// 823FB4EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FB4F0: 4BFFFD91  bl 0x823fb280
	ctx.lr = 0x823FB4F4;
	sub_823FB280(ctx, base);
	// 823FB4F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB4F8: C19F0020  lfs f12, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB4FC: A0FF001C  lhz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 823FB500: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB504: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB508: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 823FB50C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB510: 409A000C  bne cr6, 0x823fb51c
	if !ctx.cr[6].eq {
	pc = 0x823FB51C; continue 'dispatch;
	}
	// 823FB514: 7CEB0735  extsh. r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB518: 418200FC  beq 0x823fb614
	if ctx.cr[0].eq {
	pc = 0x823FB614; continue 'dispatch;
	}
	pc = 0x823FB51C; continue 'dispatch;
            }
            0x823FB51C => {
    //   block [0x823FB51C..0x823FB530)
	// 823FB51C: A8DF0024  lha r6, 0x24(r31)
	ctx.r[6].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as i16) as i64;
	// 823FB520: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 823FB524: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FB528: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FB52C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x823FB530; continue 'dispatch;
            }
            0x823FB530 => {
    //   block [0x823FB530..0x823FB588)
	// 823FB530: 7D0B07B4  extsw r11, r8
	ctx.r[11].s64 = ctx.r[8].s32 as i64;
	// 823FB534: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FB538: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FB53C: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FB540: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 823FB544: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 823FB548: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FB54C: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 823FB550: D9610060  stfd f11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[11].u64 ) };
	// 823FB554: A1610066  lhz r11, 0x66(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 823FB558: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823FB55C: 41980038  blt cr6, 0x823fb594
	if ctx.cr[6].lt {
	pc = 0x823FB594; continue 'dispatch;
	}
	// 823FB560: 7D6B0735  extsh. r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB564: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 823FB568: 41800020  blt 0x823fb588
	if ctx.cr[0].lt {
	pc = 0x823FB588; continue 'dispatch;
	}
	// 823FB56C: 40980020  bge cr6, 0x823fb58c
	if !ctx.cr[6].lt {
	pc = 0x823FB58C; continue 'dispatch;
	}
	// 823FB570: 39210790  addi r9, r1, 0x790
	ctx.r[9].s64 = ctx.r[1].s64 + 1936;
	// 823FB574: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FB578: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FB57C: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 823FB580: 7D654C2E  lfsx f11, r5, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB584: 48000020  b 0x823fb5a4
	pc = 0x823FB5A4; continue 'dispatch;
            }
            0x823FB588 => {
    //   block [0x823FB588..0x823FB58C)
	// 823FB588: 4198000C  blt cr6, 0x823fb594
	if ctx.cr[6].lt {
	pc = 0x823FB594; continue 'dispatch;
	}
	pc = 0x823FB58C; continue 'dispatch;
            }
            0x823FB58C => {
    //   block [0x823FB58C..0x823FB594)
	// 823FB58C: C16105FC  lfs f11, 0x5fc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1532 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB590: 4800000C  b 0x823fb59c
	pc = 0x823FB59C; continue 'dispatch;
            }
            0x823FB594 => {
    //   block [0x823FB594..0x823FB59C)
	// 823FB594: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 823FB598: 7D6A4C2E  lfsx f11, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x823FB59C; continue 'dispatch;
            }
            0x823FB59C => {
    //   block [0x823FB59C..0x823FB5A4)
	// 823FB59C: 39610790  addi r11, r1, 0x790
	ctx.r[11].s64 = ctx.r[1].s64 + 1936;
	// 823FB5A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x823FB5A4; continue 'dispatch;
            }
            0x823FB5A4 => {
    //   block [0x823FB5A4..0x823FB5E0)
	// 823FB5A4: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 823FB5A8: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB5AC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FB5B0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FB5B4: 7D6A4C2E  lfsx f11, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB5B8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FB5BC: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FB5C0: 2F0A0400  cmpwi cr6, r10, 0x400
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1024, &mut ctx.xer);
	// 823FB5C4: 4198FF6C  blt cr6, 0x823fb530
	if ctx.cr[6].lt {
	pc = 0x823FB530; continue 'dispatch;
	}
	// 823FB5C8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FB5CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FB5D0: 39610790  addi r11, r1, 0x790
	ctx.r[11].s64 = ctx.r[1].s64 + 1936;
	// 823FB5D4: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 823FB5D8: C00929A4  lfs f0, 0x29a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10660 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB5DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x823FB5E0; continue 'dispatch;
            }
            0x823FB5E0 => {
    //   block [0x823FB5E0..0x823FB614)
	// 823FB5E0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB5E4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FB5E8: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FB5EC: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB5F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FB5F4: 4082FFEC  bne 0x823fb5e0
	if !ctx.cr[0].eq {
	pc = 0x823FB5E0; continue 'dispatch;
	}
	// 823FB5F8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FB5FC: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FB600: 38810790  addi r4, r1, 0x790
	ctx.r[4].s64 = ctx.r[1].s64 + 1936;
	// 823FB604: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 823FB608: 816B37B4  lwz r11, 0x37b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FB60C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FB610: 4E800421  bctrl
	ctx.lr = 0x823FB614;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823FB614 => {
    //   block [0x823FB614..0x823FB6B8)
	// 823FB614: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FB618: 38C10600  addi r6, r1, 0x600
	ctx.r[6].s64 = ctx.r[1].s64 + 1536;
	// 823FB61C: 38BB0010  addi r5, r27, 0x10
	ctx.r[5].s64 = ctx.r[27].s64 + 16;
	// 823FB620: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 823FB624: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 823FB628: 48003321  bl 0x823fe948
	ctx.lr = 0x823FB62C;
	sub_823FE948(ctx, base);
	// 823FB62C: 38BB0014  addi r5, r27, 0x14
	ctx.r[5].s64 = ctx.r[27].s64 + 20;
	// 823FB630: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 823FB634: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 823FB638: 480032C9  bl 0x823fe900
	ctx.lr = 0x823FB63C;
	sub_823FE900(ctx, base);
	// 823FB63C: 38C10790  addi r6, r1, 0x790
	ctx.r[6].s64 = ctx.r[1].s64 + 1936;
	// 823FB640: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823FB644: 38980091  addi r4, r24, 0x91
	ctx.r[4].s64 = ctx.r[24].s64 + 145;
	// 823FB648: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 823FB64C: 48002315  bl 0x823fd960
	ctx.lr = 0x823FB650;
	sub_823FD960(ctx, base);
	// 823FB650: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB654: 38C10790  addi r6, r1, 0x790
	ctx.r[6].s64 = ctx.r[1].s64 + 1936;
	// 823FB658: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FB65C: 38610790  addi r3, r1, 0x790
	ctx.r[3].s64 = ctx.r[1].s64 + 1936;
	// 823FB660: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB664: 4800261D  bl 0x823fdc80
	ctx.lr = 0x823FB668;
	sub_823FDC80(ctx, base);
	// 823FB668: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FB66C: 38610790  addi r3, r1, 0x790
	ctx.r[3].s64 = ctx.r[1].s64 + 1936;
	// 823FB670: 48002841  bl 0x823fdeb0
	ctx.lr = 0x823FB674;
	sub_823FDEB0(ctx, base);
	// 823FB674: 83E10CC4  lwz r31, 0xcc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(3268 as u32) ) } as u64;
	// 823FB678: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FB67C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB680: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823FB684: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823FB688: 38610790  addi r3, r1, 0x790
	ctx.r[3].s64 = ctx.r[1].s64 + 1936;
	// 823FB68C: 48003095  bl 0x823fe720
	ctx.lr = 0x823FB690;
	sub_823FE720(ctx, base);
	// 823FB690: C0BD0034  lfs f5, 0x34(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FB694: C09E0000  lfs f4, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FB698: C07D0030  lfs f3, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FB69C: C05A0000  lfs f2, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FB6A0: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB6A4: 48002C0D  bl 0x823fe2b0
	ctx.lr = 0x823FB6A8;
	sub_823FE2B0(ctx, base);
	// 823FB6A8: D03A0000  stfs f1, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB6AC: 38210C70  addi r1, r1, 0xc70
	ctx.r[1].s64 = ctx.r[1].s64 + 3184;
	// 823FB6B0: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823FB6B4: 48139A44  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB6B8 size=528
    let mut pc: u32 = 0x823FB6B8;
    'dispatch: loop {
        match pc {
            0x823FB6B8 => {
    //   block [0x823FB6B8..0x823FB6FC)
	// 823FB6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB6BC: 481399ED  bl 0x825350a8
	ctx.lr = 0x823FB6C0;
	sub_82535080(ctx, base);
	// 823FB6C0: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 823FB6C4: 9421EF00  stwu r1, -0x1100(r1)
	ea = ctx.r[1].u32.wrapping_add(-4352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB6C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FB6CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 823FB6D0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823FB6D4: 3B9A0008  addi r28, r26, 8
	ctx.r[28].s64 = ctx.r[26].s64 + 8;
	// 823FB6D8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 823FB6DC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 823FB6E0: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FB6E4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FB6E8: 831F0048  lwz r24, 0x48(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 823FB6EC: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB6F0: 4082000C  bne 0x823fb6fc
	if !ctx.cr[0].eq {
	pc = 0x823FB6FC; continue 'dispatch;
	}
	// 823FB6F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FB6F8: 480001C8  b 0x823fb8c0
	pc = 0x823FB8C0; continue 'dispatch;
            }
            0x823FB6FC => {
    //   block [0x823FB6FC..0x823FB704)
	// 823FB6FC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 823FB700: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	pc = 0x823FB704; continue 'dispatch;
            }
            0x823FB704 => {
    //   block [0x823FB704..0x823FB84C)
	// 823FB704: A9230000  lha r9, 0(r3)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FB708: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB70C: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 823FB710: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 823FB714: C8010068  lfd f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 823FB718: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FB71C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FB720: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB724: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FB728: 4181FFDC  bgt 0x823fb704
	if ctx.cr[0].gt {
	pc = 0x823FB704; continue 'dispatch;
	}
	// 823FB72C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823FB730: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 823FB734: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FB738: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB73C: 48002105  bl 0x823fd840
	ctx.lr = 0x823FB740;
	sub_823FD840(ctx, base);
	// 823FB740: 3B3F002C  addi r25, r31, 0x2c
	ctx.r[25].s64 = ctx.r[31].s64 + 44;
	// 823FB744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB748: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FB74C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823FB750: 4BFFFA49  bl 0x823fb198
	ctx.lr = 0x823FB754;
	sub_823FB198(ctx, base);
	// 823FB754: D03C0000  stfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB758: 837F0018  lwz r27, 0x18(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FB75C: 48002965  bl 0x823fe0c0
	ctx.lr = 0x823FB760;
	sub_823FE0C0(ctx, base);
	// 823FB760: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FB764: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FB768: 38A00091  li r5, 0x91
	ctx.r[5].s64 = 145;
	// 823FB76C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FB770: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FB774: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FB778: 48001421  bl 0x823fcb98
	ctx.lr = 0x823FB77C;
	sub_823FCB98(ctx, base);
	// 823FB77C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823FB780: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823FB784: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FB788: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB78C: 389B0091  addi r4, r27, 0x91
	ctx.r[4].s64 = ctx.r[27].s64 + 145;
	// 823FB790: 480021D1  bl 0x823fd960
	ctx.lr = 0x823FB794;
	sub_823FD960(ctx, base);
	// 823FB794: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB798: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 823FB79C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FB7A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FB7A4: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB7A8: 480024D9  bl 0x823fdc80
	ctx.lr = 0x823FB7AC;
	sub_823FDC80(ctx, base);
	// 823FB7AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FB7B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FB7B4: 480026FD  bl 0x823fdeb0
	ctx.lr = 0x823FB7B8;
	sub_823FDEB0(ctx, base);
	// 823FB7B8: 38E10490  addi r7, r1, 0x490
	ctx.r[7].s64 = ctx.r[1].s64 + 1168;
	// 823FB7BC: 38C108A0  addi r6, r1, 0x8a0
	ctx.r[6].s64 = ctx.r[1].s64 + 2208;
	// 823FB7C0: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 823FB7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FB7C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FB7CC: 480022F5  bl 0x823fdac0
	ctx.lr = 0x823FB7D0;
	sub_823FDAC0(ctx, base);
	// 823FB7D0: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 823FB7D4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823FB7D8: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 823FB7DC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 823FB7E0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 823FB7E4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 823FB7E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823FB7EC: 38A10490  addi r5, r1, 0x490
	ctx.r[5].s64 = ctx.r[1].s64 + 1168;
	// 823FB7F0: 388108A0  addi r4, r1, 0x8a0
	ctx.r[4].s64 = ctx.r[1].s64 + 2208;
	// 823FB7F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FB7F8: 4BFFFC49  bl 0x823fb440
	ctx.lr = 0x823FB7FC;
	sub_823FB440(ctx, base);
	// 823FB7FC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FB800: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FB804: C0210068  lfs f1, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB808: 38A000E1  li r5, 0xe1
	ctx.r[5].s64 = 225;
	// 823FB80C: 7D660734  extsh r6, r11
	ctx.r[6].s64 = ctx.r[11].s16 as i64;
	// 823FB810: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 823FB814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FB818: 48003CA1  bl 0x823ff4b8
	ctx.lr = 0x823FB81C;
	sub_823FF4B8(ctx, base);
	// 823FB81C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FB820: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB824: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 823FB828: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823FB82C: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB830: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FB834: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823FB838: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 823FB83C: 41820010  beq 0x823fb84c
	if ctx.cr[0].eq {
	pc = 0x823FB84C; continue 'dispatch;
	}
	// 823FB840: C05C0004  lfs f2, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FB844: C0390000  lfs f1, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FB848: 48003B09  bl 0x823ff350
	ctx.lr = 0x823FB84C;
	sub_823FF350(ctx, base);
	pc = 0x823FB84C; continue 'dispatch;
            }
            0x823FB84C => {
    //   block [0x823FB84C..0x823FB89C)
	// 823FB84C: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 823FB850: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FB854: 419A0068  beq cr6, 0x823fb8bc
	if ctx.cr[6].eq {
	pc = 0x823FB8BC; continue 'dispatch;
	}
	// 823FB858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB85C: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB860: C1B80014  lfs f13, 0x14(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB864: C1580010  lfs f10, 0x10(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FB868: C1380018  lfs f9, 0x18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FB86C: C178000C  lfs f11, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FB870: C18B2C00  lfs f12, 0x2c00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB874: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB878: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FB87C: C11C0004  lfs f8, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FB880: ED6B0232  fmuls f11, f11, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[8].f64) as f32) as f64);
	// 823FB884: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FB888: C1AB7580  lfs f13, 0x7580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30080 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB88C: EC004ABA  fmadds f0, f0, f10, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64);
	// 823FB890: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FB894: 40980008  bge cr6, 0x823fb89c
	if !ctx.cr[6].lt {
	pc = 0x823FB89C; continue 'dispatch;
	}
	// 823FB898: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FB89C; continue 'dispatch;
            }
            0x823FB89C => {
    //   block [0x823FB89C..0x823FB8B0)
	// 823FB89C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB8A0: C1AB204C  lfs f13, 0x204c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB8A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FB8A8: 40990008  ble cr6, 0x823fb8b0
	if !ctx.cr[6].gt {
	pc = 0x823FB8B0; continue 'dispatch;
	}
	// 823FB8AC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FB8B0; continue 'dispatch;
            }
            0x823FB8B0 => {
    //   block [0x823FB8B0..0x823FB8BC)
	// 823FB8B0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FB8B4: D17C0004  stfs f11, 4(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB8B8: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FB8BC; continue 'dispatch;
            }
            0x823FB8BC => {
    //   block [0x823FB8BC..0x823FB8C0)
	// 823FB8BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x823FB8C0; continue 'dispatch;
            }
            0x823FB8C0 => {
    //   block [0x823FB8C0..0x823FB8C8)
	// 823FB8C0: 38211100  addi r1, r1, 0x1100
	ctx.r[1].s64 = ctx.r[1].s64 + 4352;
	// 823FB8C4: 48139834  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FB8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FB8C8 size=496
    let mut pc: u32 = 0x823FB8C8;
    'dispatch: loop {
        match pc {
            0x823FB8C8 => {
    //   block [0x823FB8C8..0x823FB91C)
	// 823FB8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FB8CC: 481397E9  bl 0x825350b4
	ctx.lr = 0x823FB8D0;
	sub_82535080(ctx, base);
	// 823FB8D0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 823FB8D4: 4813A70D  bl 0x82535fe0
	ctx.lr = 0x823FB8D8;
	sub_82535FB0(ctx, base);
	// 823FB8D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FB8DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FB8E0: C3630070  lfs f27, 0x70(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 823FB8E4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823FB8E8: C383006C  lfs f28, 0x6c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823FB8EC: C3E3002C  lfs f31, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FB8F0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FB8F4: C3C3003C  lfs f30, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FB8F8: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 823FB8FC: C3A30030  lfs f29, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FB900: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FB904: C3430040  lfs f26, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 823FB908: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823FB90C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823FB910: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 823FB914: 41980008  blt cr6, 0x823fb91c
	if ctx.cr[6].lt {
	pc = 0x823FB91C; continue 'dispatch;
	}
	// 823FB918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823FB91C; continue 'dispatch;
            }
            0x823FB91C => {
    //   block [0x823FB91C..0x823FB940)
	// 823FB91C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823FB920: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FB924: 3B897590  addi r28, r9, 0x7590
	ctx.r[28].s64 = ctx.r[9].s64 + 30096;
	// 823FB928: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FB92C: 7C0BE42E  lfsx f0, r11, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB930: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB934: 409A000C  bne cr6, 0x823fb940
	if !ctx.cr[6].eq {
	pc = 0x823FB940; continue 'dispatch;
	}
	// 823FB938: D37D0004  stfs f27, 4(r29)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FB93C: 48000008  b 0x823fb944
	pc = 0x823FB944; continue 'dispatch;
            }
            0x823FB940 => {
    //   block [0x823FB940..0x823FB944)
	// 823FB940: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x823FB944; continue 'dispatch;
            }
            0x823FB944 => {
    //   block [0x823FB944..0x823FB9A8)
	// 823FB944: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB948: E95E000A  lwa r10, 8(r30)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as i32) as i64;
	// 823FB94C: C00B76FC  lfs f0, 0x76fc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB950: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 823FB954: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FB958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB95C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FB960: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FB964: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FB968: C1AB76F8  lfs f13, 0x76f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30456 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB96C: EC2C683C  fnmsubs f1, f12, f0, f13
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FB970: 48137B29  bl 0x82533498
	ctx.lr = 0x823FB974;
	sub_82533498(ctx, base);
	// 823FB974: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FB978: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB97C: C00B2C00  lfs f0, 0x2c00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB980: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FB984: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FB988: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 823FB98C: EDADEFFA  fmadds f13, f13, f31, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 823FB990: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FB994: C1AB1848  lfs f13, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB998: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FB99C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FB9A0: 40980008  bge cr6, 0x823fb9a8
	if !ctx.cr[6].lt {
	pc = 0x823FB9A8; continue 'dispatch;
	}
	// 823FB9A4: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FB9A8; continue 'dispatch;
            }
            0x823FB9A8 => {
    //   block [0x823FB9A8..0x823FB9C0)
	// 823FB9A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9AC: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB9B0: C00B2ECC  lfs f0, 0x2ecc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FB9B8: 40990008  ble cr6, 0x823fb9c0
	if !ctx.cr[6].gt {
	pc = 0x823FB9C0; continue 'dispatch;
	}
	// 823FB9BC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FB9C0; continue 'dispatch;
            }
            0x823FB9C0 => {
    //   block [0x823FB9C0..0x823FBA04)
	// 823FB9C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9C4: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FB9C8: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FB9CC: C00B22E8  lfs f0, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9D0: EC1C0032  fmuls f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB9D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FB9D8: 4199002C  bgt cr6, 0x823fba04
	if ctx.cr[6].gt {
	pc = 0x823FBA04; continue 'dispatch;
	}
	// 823FB9DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9E0: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9E4: EC1C0032  fmuls f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FB9E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FB9EC: 41980018  blt cr6, 0x823fba04
	if ctx.cr[6].lt {
	pc = 0x823FBA04; continue 'dispatch;
	}
	// 823FB9F0: EDADE02A  fadds f13, f13, f28
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 823FB9F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FB9F8: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FB9FC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FBA00: 48000060  b 0x823fba60
	pc = 0x823FBA60; continue 'dispatch;
            }
            0x823FBA04 => {
    //   block [0x823FBA04..0x823FBA18)
	// 823FBA04: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 823FBA08: 40990010  ble cr6, 0x823fba18
	if !ctx.cr[6].gt {
	pc = 0x823FBA18; continue 'dispatch;
	}
	// 823FBA0C: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 823FBA10: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 823FBA14: 48000008  b 0x823fba1c
	pc = 0x823FBA1C; continue 'dispatch;
            }
            0x823FBA18 => {
    //   block [0x823FBA18..0x823FBA1C)
	// 823FBA18: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FBA1C; continue 'dispatch;
            }
            0x823FBA1C => {
    //   block [0x823FBA1C..0x823FBA5C)
	// 823FBA1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBA20: C16B76F4  lfs f11, 0x76f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30452 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FBA24: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 823FBA28: 40980038  bge cr6, 0x823fba60
	if !ctx.cr[6].lt {
	pc = 0x823FBA60; continue 'dispatch;
	}
	// 823FBA2C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FBA30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FBA34: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FBA38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBA3C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FBA40: C18B1850  lfs f12, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FBA44: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 823FBA48: 40980018  bge cr6, 0x823fba60
	if !ctx.cr[6].lt {
	pc = 0x823FBA60; continue 'dispatch;
	}
	// 823FBA4C: FF0DE000  fcmpu cr6, f13, f28
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[28].f64);
	// 823FBA50: 4099000C  ble cr6, 0x823fba5c
	if !ctx.cr[6].gt {
	pc = 0x823FBA5C; continue 'dispatch;
	}
	// 823FBA54: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FBA58: 48000008  b 0x823fba60
	pc = 0x823FBA60; continue 'dispatch;
            }
            0x823FBA5C => {
    //   block [0x823FBA5C..0x823FBA60)
	// 823FBA5C: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	pc = 0x823FBA60; continue 'dispatch;
            }
            0x823FBA60 => {
    //   block [0x823FBA60..0x823FBA74)
	// 823FBA60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBA64: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FBA68: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 823FBA6C: 41980008  blt cr6, 0x823fba74
	if ctx.cr[6].lt {
	pc = 0x823FBA74; continue 'dispatch;
	}
	// 823FBA70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823FBA74; continue 'dispatch;
            }
            0x823FBA74 => {
    //   block [0x823FBA74..0x823FBAB8)
	// 823FBA74: 395C0020  addi r10, r28, 0x20
	ctx.r[10].s64 = ctx.r[28].s64 + 32;
	// 823FBA78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FBA7C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823FBA80: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 823FBA84: 389D0014  addi r4, r29, 0x14
	ctx.r[4].s64 = ctx.r[29].s64 + 20;
	// 823FBA88: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 823FBA8C: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBA90: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823FBA94: C03F0004  lfs f1, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FBA98: 48003BB1  bl 0x823ff648
	ctx.lr = 0x823FBA9C;
	sub_823FF648(ctx, base);
	// 823FBA9C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBAA0: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 823FBAA4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FBAA8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823FBAAC: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 823FBAB0: 4813A57D  bl 0x8253602c
	ctx.lr = 0x823FBAB4;
	sub_82535FFC(ctx, base);
	// 823FBAB4: 48139650  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FBAB8 size=504
    let mut pc: u32 = 0x823FBAB8;
    'dispatch: loop {
        match pc {
            0x823FBAB8 => {
    //   block [0x823FBAB8..0x823FBB0C)
	// 823FBAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBABC: 481395DD  bl 0x82535098
	ctx.lr = 0x823FBAC0;
	sub_82535080(ctx, base);
	// 823FBAC0: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBAC4: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 823FBAC8: B0E10074  sth r7, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[7].u16 ) };
	// 823FBACC: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 823FBAD0: 90C10070  stw r6, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u32 ) };
	// 823FBAD4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FBAD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FBADC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBAE0: A31E0000  lhz r24, 0(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBAE4: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 823FBAE8: 8AFD0000  lbz r23, 0(r29)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBAEC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 823FBAF0: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 823FBAF4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 823FBAF8: 829F0004  lwz r20, 4(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FBAFC: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 823FBB00: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 823FBB04: 3ACB76B0  addi r22, r11, 0x76b0
	ctx.r[22].s64 = ctx.r[11].s64 + 30384;
	// 823FBB08: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	pc = 0x823FBB0C; continue 'dispatch;
            }
            0x823FBB0C => {
    //   block [0x823FBB0C..0x823FBB78)
	// 823FBB0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 823FBB10: 7CBCB02E  lwzx r5, r28, r22
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 823FBB14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 823FBB18: 480042D1  bl 0x823ffde8
	ctx.lr = 0x823FBB1C;
	sub_823FFDE8(ctx, base);
	// 823FBB1C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FBB20: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 823FBB24: 7D7C512E  stwx r11, r28, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 823FBB28: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FBB2C: 2F1C0044  cmpwi cr6, r28, 0x44
	ctx.cr[6].compare_i32(ctx.r[28].s32, 68, &mut ctx.xer);
	// 823FBB30: 4198FFDC  blt cr6, 0x823fbb0c
	if ctx.cr[6].lt {
	pc = 0x823FBB0C; continue 'dispatch;
	}
	// 823FBB34: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 823FBB38: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 823FBB3C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 823FBB40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBB44: 4BFFFD85  bl 0x823fb8c8
	ctx.lr = 0x823FBB48;
	sub_823FB8C8(ctx, base);
	// 823FBB48: A17F005C  lhz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 823FBB4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823FBB50: 409A0028  bne cr6, 0x823fbb78
	if !ctx.cr[6].eq {
	pc = 0x823FBB78; continue 'dispatch;
	}
	// 823FBB54: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823FBB58: 814101E4  lwz r10, 0x1e4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(484 as u32) ) } as u64;
	// 823FBB5C: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 823FBB60: A11F003A  lhz r8, 0x3a(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(58 as u32) ) } as u64;
	// 823FBB64: A0FF0038  lhz r7, 0x38(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 823FBB68: C05F0034  lfs f2, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FBB6C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FBB70: C02100A0  lfs f1, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FBB74: 48003DFD  bl 0x823ff970
	ctx.lr = 0x823FBB78;
	sub_823FF970(ctx, base);
	pc = 0x823FBB78; continue 'dispatch;
            }
            0x823FBB78 => {
    //   block [0x823FBB78..0x823FBBD4)
	// 823FBB78: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 823FBB7C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 823FBB80: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 823FBB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBB88: 48003D41  bl 0x823ff8c8
	ctx.lr = 0x823FBB8C;
	sub_823FF8C8(ctx, base);
	// 823FBB8C: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 823FBB90: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBB94: 3F808288  lis r28, -0x7d78
	ctx.r[28].s64 = -2105016320;
	// 823FBB98: B17A0000  sth r11, 0(r26)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FBB9C: 816101EC  lwz r11, 0x1ec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 823FBBA0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FBBA4: A17F005C  lhz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 823FBBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 823FBBAC: 409A0028  bne cr6, 0x823fbbd4
	if !ctx.cr[6].eq {
	pc = 0x823FBBD4; continue 'dispatch;
	}
	// 823FBBB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FBBB4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 823FBBB8: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 823FBBBC: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 823FBBC0: B17F005C  sth r11, 0x5c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 823FBBC4: 817C37B4  lwz r11, 0x37b4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FBBC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBBCC: 4E800421  bctrl
	ctx.lr = 0x823FBBD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBBD0: 480000A8  b 0x823fbc78
	pc = 0x823FBC78; continue 'dispatch;
            }
            0x823FBBD4 => {
    //   block [0x823FBBD4..0x823FBC28)
	// 823FBBD4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823FBBD8: B37F005C  sth r27, 0x5c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[27].u16 ) };
	// 823FBBDC: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 823FBBE0: B31E0000  sth r24, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[24].u16 ) };
	// 823FBBE4: 9AFD0000  stb r23, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	// 823FBBE8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FBBEC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FBBF0: A17F005E  lhz r11, 0x5e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(94 as u32) ) } as u64;
	// 823FBBF4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 823FBBF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBBFC: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FBC00: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FBC04: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FBC08: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBC0C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FBC10: 409A0068  bne cr6, 0x823fbc78
	if !ctx.cr[6].eq {
	pc = 0x823FBC78; continue 'dispatch;
	}
	// 823FBC14: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 823FBC18: B37F005E  sth r27, 0x5e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(94 as u32), ctx.r[27].u16 ) };
	// 823FBC1C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FBC20: 40990058  ble cr6, 0x823fbc78
	if !ctx.cr[6].gt {
	pc = 0x823FBC78; continue 'dispatch;
	}
	// 823FBC24: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	pc = 0x823FBC28; continue 'dispatch;
            }
            0x823FBC28 => {
    //   block [0x823FBC28..0x823FBC78)
	// 823FBC28: A90A0000  lha r8, 0(r10)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 823FBC2C: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 823FBC30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FBC34: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FBC38: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 823FBC3C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 823FBC40: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 823FBC44: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FBC48: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FBC4C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FBC50: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FBC54: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FBC58: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FBC5C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FBC60: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FBC64: D9A10068  stfd f13, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[13].u64 ) };
	// 823FBC68: A101006E  lhz r8, 0x6e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 823FBC6C: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 823FBC70: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823FBC74: 4198FFB4  blt cr6, 0x823fbc28
	if ctx.cr[6].lt {
	pc = 0x823FBC28; continue 'dispatch;
	}
	pc = 0x823FBC78; continue 'dispatch;
            }
            0x823FBC78 => {
    //   block [0x823FBC78..0x823FBCB0)
	// 823FBC78: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FBC7C: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FBC80: 817C37B4  lwz r11, 0x37b4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FBC84: 38940808  addi r4, r20, 0x808
	ctx.r[4].s64 = ctx.r[20].s64 + 2056;
	// 823FBC88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBC8C: 4E800421  bctrl
	ctx.lr = 0x823FBC90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBC90: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FBC94: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FBC98: 817C37B4  lwz r11, 0x37b4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FBC9C: 3894090C  addi r4, r20, 0x90c
	ctx.r[4].s64 = ctx.r[20].s64 + 2316;
	// 823FBCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBCA4: 4E800421  bctrl
	ctx.lr = 0x823FBCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBCA8: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 823FBCAC: 4813943C  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FBCB0 size=464
    let mut pc: u32 = 0x823FBCB0;
    'dispatch: loop {
        match pc {
            0x823FBCB0 => {
    //   block [0x823FBCB0..0x823FBCC8)
	// 823FBCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBCB4: 48139405  bl 0x825350b8
	ctx.lr = 0x823FBCB8;
	sub_82535080(ctx, base);
	// 823FBCB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBCBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823FBCC0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 823FBCC4: 409A000C  bne cr6, 0x823fbcd0
	if !ctx.cr[6].eq {
	pc = 0x823FBCD0; continue 'dispatch;
	}
	pc = 0x823FBCC8; continue 'dispatch;
            }
            0x823FBCC8 => {
    //   block [0x823FBCC8..0x823FBCD0)
	// 823FBCC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FBCCC: 480001AC  b 0x823fbe78
	pc = 0x823FBE78; continue 'dispatch;
            }
            0x823FBCD0 => {
    //   block [0x823FBCD0..0x823FBE78)
	// 823FBCD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823FBCD4: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 823FBCD8: 38800074  li r4, 0x74
	ctx.r[4].s64 = 116;
	// 823FBCDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FBCE0: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823FBCE4: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBCE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBCEC: 4E800421  bctrl
	ctx.lr = 0x823FBCF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBCF0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FBCF4: 4182FFD4  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBCF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FBCFC: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FBD00: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FBD04: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823FBD08: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 823FBD0C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBD10: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 823FBD14: 38600284  li r3, 0x284
	ctx.r[3].s64 = 644;
	// 823FBD18: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 823FBD1C: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FBD20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FBD24: C16A7700  lfs f11, 0x7700(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30464 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FBD28: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FBD2C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FBD30: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 823FBD34: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 823FBD38: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 823FBD3C: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 823FBD40: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 823FBD44: C18B2808  lfs f12, 0x2808(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FBD48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FBD4C: C14A2094  lfs f10, 0x2094(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8340 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FBD50: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 823FBD54: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FBD58: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 823FBD5C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 823FBD60: B3DF0038  sth r30, 0x38(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u16 ) };
	// 823FBD64: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 823FBD68: B3DF003A  sth r30, 0x3a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[30].u16 ) };
	// 823FBD6C: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FBD70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FBD74: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823FBD78: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823FBD7C: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 823FBD80: B3DF005E  sth r30, 0x5e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(94 as u32), ctx.r[30].u16 ) };
	// 823FBD84: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 823FBD88: B15F0060  sth r10, 0x60(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u16 ) };
	// 823FBD8C: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 823FBD90: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 823FBD94: B17F005C  sth r11, 0x5c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 823FBD98: D17F004C  stfs f11, 0x4c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 823FBD9C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 823FBDA0: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FBDA4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 823FBDA8: D15F006C  stfs f10, 0x6c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 823FBDAC: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBDB4: 4E800421  bctrl
	ctx.lr = 0x823FBDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBDB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBDBC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 823FBDC0: 4182FF08  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBDC4: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBDC8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBDCC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 823FBDD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBDD4: 4E800421  bctrl
	ctx.lr = 0x823FBDD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBDD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBDDC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823FBDE0: 4182FEE8  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBDE4: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBDE8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBDEC: 38600041  li r3, 0x41
	ctx.r[3].s64 = 65;
	// 823FBDF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBDF4: 4E800421  bctrl
	ctx.lr = 0x823FBDF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBDF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBDFC: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 823FBE00: 4182FEC8  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE04: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBE08: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBE0C: 38600041  li r3, 0x41
	ctx.r[3].s64 = 65;
	// 823FBE10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBE14: 4E800421  bctrl
	ctx.lr = 0x823FBE18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBE18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE1C: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 823FBE20: 4182FEA8  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE24: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBE28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBE2C: 38600066  li r3, 0x66
	ctx.r[3].s64 = 102;
	// 823FBE30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBE34: 4E800421  bctrl
	ctx.lr = 0x823FBE38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBE38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE3C: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 823FBE40: 4182FE88  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE44: 817D37A8  lwz r11, 0x37a8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FBE48: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FBE4C: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 823FBE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBE54: 4E800421  bctrl
	ctx.lr = 0x823FBE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBE58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE5C: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 823FBE60: 4182FE68  beq 0x823fbcc8
	if ctx.cr[0].eq {
	pc = 0x823FBCC8; continue 'dispatch;
	}
	// 823FBE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBE68: 48004081  bl 0x823ffee8
	ctx.lr = 0x823FBE6C;
	sub_823FFEE8(ctx, base);
	// 823FBE6C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 823FBE70: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823FBE74: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
            }
            0x823FBE78 => {
    //   block [0x823FBE78..0x823FBE80)
	// 823FBE78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FBE7C: 4813928C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FBE80 size=236
    let mut pc: u32 = 0x823FBE80;
    'dispatch: loop {
        match pc {
            0x823FBE80 => {
    //   block [0x823FBE80..0x823FBEBC)
	// 823FBE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBE84: 48139239  bl 0x825350bc
	ctx.lr = 0x823FBE88;
	sub_82535080(ctx, base);
	// 823FBE88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBE8C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FBE90: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBE94: 418200CC  beq 0x823fbf60
	if ctx.cr[0].eq {
	pc = 0x823FBF60; continue 'dispatch;
	}
	// 823FBE98: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FBE9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FBEA0: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FBEA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBEA8: 41820014  beq 0x823fbebc
	if ctx.cr[0].eq {
	pc = 0x823FBEBC; continue 'dispatch;
	}
	// 823FBEAC: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBEB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBEB4: 4E800421  bctrl
	ctx.lr = 0x823FBEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBEB8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
            }
            0x823FBEBC => {
    //   block [0x823FBEBC..0x823FBEE0)
	// 823FBEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBEC0: 480040A9  bl 0x823fff68
	ctx.lr = 0x823FBEC4;
	sub_823FFF68(ctx, base);
	// 823FBEC4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FBEC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBECC: 41820014  beq 0x823fbee0
	if ctx.cr[0].eq {
	pc = 0x823FBEE0; continue 'dispatch;
	}
	// 823FBED0: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBED8: 4E800421  bctrl
	ctx.lr = 0x823FBEDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBEDC: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
            }
            0x823FBEE0 => {
    //   block [0x823FBEE0..0x823FBEFC)
	// 823FBEE0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FBEE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBEE8: 41820014  beq 0x823fbefc
	if ctx.cr[0].eq {
	pc = 0x823FBEFC; continue 'dispatch;
	}
	// 823FBEEC: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBEF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBEF4: 4E800421  bctrl
	ctx.lr = 0x823FBEF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBEF8: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
            }
            0x823FBEFC => {
    //   block [0x823FBEFC..0x823FBF18)
	// 823FBEFC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FBF00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBF04: 41820014  beq 0x823fbf18
	if ctx.cr[0].eq {
	pc = 0x823FBF18; continue 'dispatch;
	}
	// 823FBF08: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF10: 4E800421  bctrl
	ctx.lr = 0x823FBF14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF14: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
            }
            0x823FBF18 => {
    //   block [0x823FBF18..0x823FBF34)
	// 823FBF18: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FBF1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBF20: 41820014  beq 0x823fbf34
	if ctx.cr[0].eq {
	pc = 0x823FBF34; continue 'dispatch;
	}
	// 823FBF24: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF2C: 4E800421  bctrl
	ctx.lr = 0x823FBF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF30: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
            }
            0x823FBF34 => {
    //   block [0x823FBF34..0x823FBF50)
	// 823FBF34: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FBF38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FBF3C: 41820014  beq 0x823fbf50
	if ctx.cr[0].eq {
	pc = 0x823FBF50; continue 'dispatch;
	}
	// 823FBF40: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF48: 4E800421  bctrl
	ctx.lr = 0x823FBF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBF4C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
            }
            0x823FBF50 => {
    //   block [0x823FBF50..0x823FBF60)
	// 823FBF50: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FBF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FBF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBF5C: 4E800421  bctrl
	ctx.lr = 0x823FBF60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823FBF60 => {
    //   block [0x823FBF60..0x823FBF6C)
	// 823FBF60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FBF64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FBF68: 481391A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FBF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FBF70 size=856
    let mut pc: u32 = 0x823FBF70;
    'dispatch: loop {
        match pc {
            0x823FBF70 => {
    //   block [0x823FBF70..0x823FC01C)
	// 823FBF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FBF74: 48139139  bl 0x825350ac
	ctx.lr = 0x823FBF78;
	sub_82535080(ctx, base);
	// 823FBF78: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 823FBF7C: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 823FBF80: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 823FBF84: 9421F5F0  stwu r1, -0xa10(r1)
	ea = ctx.r[1].u32.wrapping_add(-2576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FBF88: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FBF8C: 3FE08288  lis r31, -0x7d78
	ctx.r[31].s64 = -2105016320;
	// 823FBF90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FBF94: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 823FBF98: 7CBB0E70  srawi r27, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FBF9C: D0410A64  stfs f2, 0xa64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2660 as u32), tmp.u32 ) };
	// 823FBFA0: D3A10A6C  stfs f29, 0xa6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2668 as u32), tmp.u32 ) };
	// 823FBFA4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 823FBFA8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 823FBFAC: 817F37B0  lwz r11, 0x37b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FBFB0: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 823FBFB4: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 823FBFB8: 38A00404  li r5, 0x404
	ctx.r[5].s64 = 1028;
	// 823FBFBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FBFC0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 823FBFC4: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 823FBFC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBFCC: 4E800421  bctrl
	ctx.lr = 0x823FBFD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBFD0: 817F37B0  lwz r11, 0x37b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FBFD4: 38A00404  li r5, 0x404
	ctx.r[5].s64 = 1028;
	// 823FBFD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FBFDC: 386105B0  addi r3, r1, 0x5b0
	ctx.r[3].s64 = ctx.r[1].s64 + 1456;
	// 823FBFE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FBFE4: 4E800421  bctrl
	ctx.lr = 0x823FBFE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FBFE8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FBFEC: 4099009C  ble cr6, 0x823fc088
	if !ctx.cr[6].gt {
	pc = 0x823FC088; continue 'dispatch;
	}
	// 823FBFF0: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 823FBFF4: 3CC08273  lis r6, -0x7d8d
	ctx.r[6].s64 = -2106392576;
	// 823FBFF8: 3D008273  lis r8, -0x7d8d
	ctx.r[8].s64 = -2106392576;
	// 823FBFFC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FC000: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FC004: C005BFFC  lfs f0, -0x4004(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC008: 7C9DE050  subf r4, r29, r28
	ctx.r[4].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 823FC00C: 80C6D6E4  lwz r6, -0x291c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10524 as u32) ) } as u64;
	// 823FC010: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FC014: 80E8D6E8  lwz r7, -0x2918(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 823FC018: C189AC38  lfs f12, -0x53c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-21448 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
            }
            0x823FC01C => {
    //   block [0x823FC01C..0x823FC088)
	// 823FC01C: ED5F002A  fadds f10, f31, f0
	ctx.f[10].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC020: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC024: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 823FC028: ED6B033A  fmadds f11, f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FC02C: 7DA45C2E  lfsx f13, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC030: 38A101A0  addi r5, r1, 0x1a0
	ctx.r[5].s64 = ctx.r[1].s64 + 416;
	// 823FC034: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC038: 386105B0  addi r3, r1, 0x5b0
	ctx.r[3].s64 = ctx.r[1].s64 + 1456;
	// 823FC03C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC040: EFFFF02A  fadds f31, f31, f30
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 823FC044: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC048: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 823FC04C: 7D404FAE  stfiwx f10, 0, r9
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FC050: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823FC054: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 823FC058: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823FC05C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FC060: 7D6047AE  stfiwx f11, 0, r8
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823FC064: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FC068: 550815BA  rlwinm r8, r8, 2, 0x16, 0x1d
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 823FC06C: 7D683C2E  lfsx f11, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC070: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC074: 7D692D2E  stfsx f11, r9, r5
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 823FC078: 7D68342E  lfsx f11, r8, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC07C: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC080: 7DA91D2E  stfsx f13, r9, r3
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 823FC084: 4082FF98  bne 0x823fc01c
	if !ctx.cr[0].eq {
	pc = 0x823FC01C; continue 'dispatch;
	}
	pc = 0x823FC088; continue 'dispatch;
            }
            0x823FC088 => {
    //   block [0x823FC088..0x823FC0CC)
	// 823FC088: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 823FC08C: 388105B0  addi r4, r1, 0x5b0
	ctx.r[4].s64 = ctx.r[1].s64 + 1456;
	// 823FC090: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 823FC094: 480019ED  bl 0x823fda80
	ctx.lr = 0x823FC098;
	sub_823FDA80(ctx, base);
	// 823FC098: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FC09C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC0A0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823FC0A4: C18A1850  lfs f12, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC0A8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC0AC: 40990020  ble cr6, 0x823fc0cc
	if !ctx.cr[6].gt {
	pc = 0x823FC0CC; continue 'dispatch;
	}
	// 823FC0B0: 7F6B07B4  extsw r11, r27
	ctx.r[11].s64 = ctx.r[27].s32 as i64;
	// 823FC0B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FC0B8: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FC0BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FC0C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FC0C4: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FC0C8: 48000008  b 0x823fc0d0
	pc = 0x823FC0D0; continue 'dispatch;
            }
            0x823FC0CC => {
    //   block [0x823FC0CC..0x823FC0D0)
	// 823FC0CC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FC0D0; continue 'dispatch;
            }
            0x823FC0D0 => {
    //   block [0x823FC0D0..0x823FC0E4)
	// 823FC0D0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 823FC0D4: 39410500  addi r10, r1, 0x500
	ctx.r[10].s64 = ctx.r[1].s64 + 1280;
	// 823FC0D8: 39210910  addi r9, r1, 0x910
	ctx.r[9].s64 = ctx.r[1].s64 + 2320;
	// 823FC0DC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 823FC0E0: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	pc = 0x823FC0E4; continue 'dispatch;
            }
            0x823FC0E4 => {
    //   block [0x823FC0E4..0x823FC240)
	// 823FC0E4: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC0E8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC0EC: ED6D02F2  fmuls f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FC0F0: C1480000  lfs f10, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC0F4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC0F8: C1290000  lfs f9, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FC0FC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FC100: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FC104: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FC108: ED6A5B3A  fmadds f11, f10, f12, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC10C: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC110: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC114: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FC118: ED690372  fmuls f11, f9, f13
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC11C: C1480000  lfs f10, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC120: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FC124: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC128: ED6A5B3A  fmadds f11, f10, f12, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC12C: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC130: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FC134: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC138: 4082FFAC  bne 0x823fc0e4
	if !ctx.cr[0].eq {
	pc = 0x823FC0E4; continue 'dispatch;
	}
	// 823FC13C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC140: C00B2808  lfs f0, 0x2808(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC144: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 823FC148: 419A00F8  beq cr6, 0x823fc240
	if ctx.cr[6].eq {
	pc = 0x823FC240; continue 'dispatch;
	}
	// 823FC14C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC150: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FC154: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FC158: 38E10A64  addi r7, r1, 0xa64
	ctx.r[7].s64 = ctx.r[1].s64 + 2660;
	// 823FC15C: 38C10A64  addi r6, r1, 0xa64
	ctx.r[6].s64 = ctx.r[1].s64 + 2660;
	// 823FC160: C00B2078  lfs f0, 0x2078(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC164: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 823FC168: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FC16C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	pc = 0x823FC240; continue 'dispatch;
            }
            0x823FC240 => {
    //   block [0x823FC240..0x823FC2C8)
	// 823FC240: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 823FC244: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823FC248: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC2C8 size=256
    let mut pc: u32 = 0x823FC2C8;
    'dispatch: loop {
        match pc {
            0x823FC2C8 => {
    //   block [0x823FC2C8..0x823FC2FC)
	// 823FC2C8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823FC2CC: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FC2D0: 7C860734  extsh r6, r4
	ctx.r[6].s64 = ctx.r[4].s16 as i64;
	// 823FC2D4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FC2D8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC2DC: A0E30004  lhz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC2E0: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC2E4: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC2E8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FC2EC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FC2F0: 4082000C  bne 0x823fc2fc
	if !ctx.cr[0].eq {
	pc = 0x823FC2FC; continue 'dispatch;
	}
	// 823FC2F4: 98C90000  stb r6, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 823FC2F8: 4800001C  b 0x823fc314
	pc = 0x823FC314; continue 'dispatch;
            }
            0x823FC2FC => {
    //   block [0x823FC2FC..0x823FC314)
	// 823FC2FC: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC300: 7CC40734  extsh r4, r6
	ctx.r[4].s64 = ctx.r[6].s16 as i64;
	// 823FC304: 8BE90000  lbz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC308: 7C884030  slw r8, r4, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[4].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 823FC30C: 7D08FB78  or r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[31].u64;
	// 823FC310: 99090000  stb r8, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	pc = 0x823FC314; continue 'dispatch;
            }
            0x823FC314 => {
    //   block [0x823FC314..0x823FC35C)
	// 823FC314: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC318: 7D082A14  add r8, r8, r5
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 823FC31C: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 823FC320: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 823FC324: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 823FC328: 40990060  ble cr6, 0x823fc388
	if !ctx.cr[6].gt {
	pc = 0x823FC388; continue 'dispatch;
	}
	// 823FC32C: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC330: 54E7043E  clrlwi r7, r7, 0x10
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 823FC334: 38880001  addi r4, r8, 1
	ctx.r[4].s64 = ctx.r[8].s64 + 1;
	// 823FC338: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 823FC33C: 5489043E  clrlwi r9, r4, 0x10
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 823FC340: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 823FC344: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 823FC348: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 823FC34C: 41980010  blt cr6, 0x823fc35c
	if ctx.cr[6].lt {
	pc = 0x823FC35C; continue 'dispatch;
	}
	// 823FC350: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC354: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 823FC358: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823FC35C; continue 'dispatch;
            }
            0x823FC35C => {
    //   block [0x823FC35C..0x823FC388)
	// 823FC35C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC360: 7CC90734  extsh r9, r6
	ctx.r[9].s64 = ctx.r[6].s16 as i64;
	// 823FC364: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 823FC368: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 823FC36C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 823FC370: 7D2A5630  sraw r10, r9, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 823FC374: 99480000  stb r10, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FC378: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC37C: 394A00F8  addi r10, r10, 0xf8
	ctx.r[10].s64 = ctx.r[10].s64 + 248;
	// 823FC380: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FC384: 4800003C  b 0x823fc3c0
	pc = 0x823FC3C0; continue 'dispatch;
            }
            0x823FC388 => {
    //   block [0x823FC388..0x823FC3C0)
	// 823FC388: 5509063E  clrlwi r9, r8, 0x18
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 823FC38C: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 823FC390: 409A0030  bne cr6, 0x823fc3c0
	if !ctx.cr[6].eq {
	pc = 0x823FC3C0; continue 'dispatch;
	}
	// 823FC394: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC398: 54E8043E  clrlwi r8, r7, 0x10
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 823FC39C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 823FC3A0: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC3A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FC3A8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 823FC3AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 823FC3B0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 823FC3B4: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 823FC3B8: 41980008  blt cr6, 0x823fc3c0
	if ctx.cr[6].lt {
	pc = 0x823FC3C0; continue 'dispatch;
	}
	// 823FC3BC: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	pc = 0x823FC3C0; continue 'dispatch;
            }
            0x823FC3C0 => {
    //   block [0x823FC3C0..0x823FC3C8)
	// 823FC3C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823FC3C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC3C8 size=24
    let mut pc: u32 = 0x823FC3C8;
    'dispatch: loop {
        match pc {
            0x823FC3C8 => {
    //   block [0x823FC3C8..0x823FC3D4)
	// 823FC3C8: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FC3CC: 41980008  blt cr6, 0x823fc3d4
	if ctx.cr[6].lt {
	pc = 0x823FC3D4; continue 'dispatch;
	}
	// 823FC3D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x823FC3D4; continue 'dispatch;
            }
            0x823FC3D4 => {
    //   block [0x823FC3D4..0x823FC3E0)
	// 823FC3D4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC3D8: 7C2B1C2E  lfsx f1, r11, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FC3DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC3E0 size=116
    let mut pc: u32 = 0x823FC3E0;
    'dispatch: loop {
        match pc {
            0x823FC3E0 => {
    //   block [0x823FC3E0..0x823FC40C)
	// 823FC3E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FC3E4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823FC3E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FC3EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FC3F0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FC3F4: C00B8CB0  lfs f0, -0x7350(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC3F8: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823FC3FC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 823FC400: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC404: C1690004  lfs f11, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC408: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	pc = 0x823FC40C; continue 'dispatch;
            }
            0x823FC40C => {
    //   block [0x823FC40C..0x823FC444)
	// 823FC40C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC410: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 823FC414: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FC418: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 823FC41C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC420: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC424: EC0A5828  fsubs f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 823FC428: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FC42C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823FC430: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FC434: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FC438: 4098000C  bge cr6, 0x823fc444
	if !ctx.cr[6].lt {
	pc = 0x823FC444; continue 'dispatch;
	}
	// 823FC43C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FC440: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	pc = 0x823FC444; continue 'dispatch;
            }
            0x823FC444 => {
    //   block [0x823FC444..0x823FC454)
	// 823FC444: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FC448: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823FC44C: 4198FFC0  blt cr6, 0x823fc40c
	if ctx.cr[6].lt {
	pc = 0x823FC40C; continue 'dispatch;
	}
	// 823FC450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FC458 size=648
    let mut pc: u32 = 0x823FC458;
    'dispatch: loop {
        match pc {
            0x823FC458 => {
    //   block [0x823FC458..0x823FC4A4)
	// 823FC458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FC45C: 48138C45  bl 0x825350a0
	ctx.lr = 0x823FC460;
	sub_82535080(ctx, base);
	// 823FC460: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FC464: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FC468: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 823FC46C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 823FC470: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 823FC474: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 823FC478: C08B8CB4  lfs f4, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FC47C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 823FC480: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FC484: 4099004C  ble cr6, 0x823fc4d0
	if !ctx.cr[6].gt {
	pc = 0x823FC4D0; continue 'dispatch;
	}
	// 823FC488: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC48C: 3C807F7F  lis r4, 0x7f7f
	ctx.r[4].s64 = 2139029504;
	// 823FC490: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FC494: 6084FFEE  ori r4, r4, 0xffee
	ctx.r[4].u64 = ctx.r[4].u64 | 65518;
	// 823FC498: 556AF0BF  rlwinm. r10, r11, 0x1e, 2, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC49C: 41820014  beq 0x823fc4b0
	if ctx.cr[0].eq {
	pc = 0x823FC4B0; continue 'dispatch;
	}
	// 823FC4A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x823FC4A4; continue 'dispatch;
            }
            0x823FC4A4 => {
    //   block [0x823FC4A4..0x823FC4B0)
	// 823FC4A4: 90890000  stw r4, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 823FC4A8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FC4AC: 4200FFF8  bdnz 0x823fc4a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FC4A4; continue 'dispatch;
	}
	pc = 0x823FC4B0; continue 'dispatch;
            }
            0x823FC4B0 => {
    //   block [0x823FC4B0..0x823FC4C4)
	// 823FC4B0: 556BF0BF  rlwinm. r11, r11, 0x1e, 2, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC4B4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823FC4B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC4BC: 41820014  beq 0x823fc4d0
	if ctx.cr[0].eq {
	pc = 0x823FC4D0; continue 'dispatch;
	}
	// 823FC4C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x823FC4C4; continue 'dispatch;
            }
            0x823FC4C4 => {
    //   block [0x823FC4C4..0x823FC4D0)
	// 823FC4C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FC4C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FC4CC: 4200FFF8  bdnz 0x823fc4c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FC4C4; continue 'dispatch;
	}
	pc = 0x823FC4D0; continue 'dispatch;
            }
            0x823FC4D0 => {
    //   block [0x823FC4D0..0x823FC4F0)
	// 823FC4D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FC4D4: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823FC4D8: 409900A4  ble cr6, 0x823fc57c
	if !ctx.cr[6].gt {
	pc = 0x823FC57C; continue 'dispatch;
	}
	// 823FC4DC: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC4E0: C19B0000  lfs f12, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC4E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FC4E8: C17B0004  lfs f11, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC4EC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x823FC4F0; continue 'dispatch;
            }
            0x823FC4F0 => {
    //   block [0x823FC4F0..0x823FC528)
	// 823FC4F0: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC4F4: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC4F8: C1430004  lfs f10, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FC4FC: C124FFFC  lfs f9, -4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FC500: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 823FC504: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC508: EC0B5028  fsubs f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 823FC50C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FC510: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 823FC514: 4098005C  bge cr6, 0x823fc570
	if !ctx.cr[6].lt {
	pc = 0x823FC570; continue 'dispatch;
	}
	// 823FC518: 3565FFFF  addic. r11, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC51C: 40810040  ble 0x823fc55c
	if !ctx.cr[0].gt {
	pc = 0x823FC55C; continue 'dispatch;
	}
	// 823FC520: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC524: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	pc = 0x823FC528; continue 'dispatch;
            }
            0x823FC528 => {
    //   block [0x823FC528..0x823FC55C)
	// 823FC528: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 823FC52C: 7DAAFC2E  lfsx f13, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC530: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FC534: 41990028  bgt cr6, 0x823fc55c
	if ctx.cr[6].gt {
	pc = 0x823FC55C; continue 'dispatch;
	}
	// 823FC538: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 823FC53C: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 823FC540: 3BA1005C  addi r29, r1, 0x5c
	ctx.r[29].s64 = ctx.r[1].s64 + 92;
	// 823FC544: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FC548: 7FEAF82E  lwzx r31, r10, r31
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 823FC54C: 7DAAF52E  stfsx f13, r10, r30
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 823FC550: 7FEAE92E  stwx r31, r10, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32), ctx.r[31].u32) };
	// 823FC554: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FC558: 4181FFD0  bgt 0x823fc528
	if ctx.cr[0].gt {
	pc = 0x823FC528; continue 'dispatch;
	}
	pc = 0x823FC55C; continue 'dispatch;
            }
            0x823FC55C => {
    //   block [0x823FC55C..0x823FC570)
	// 823FC55C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC560: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FC564: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 823FC568: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 823FC56C: 7D2BF92E  stwx r9, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	pc = 0x823FC570; continue 'dispatch;
            }
            0x823FC570 => {
    //   block [0x823FC570..0x823FC57C)
	// 823FC570: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FC574: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FC578: 4198FF78  blt cr6, 0x823fc4f0
	if ctx.cr[6].lt {
	pc = 0x823FC4F0; continue 'dispatch;
	}
	pc = 0x823FC57C; continue 'dispatch;
            }
            0x823FC57C => {
    //   block [0x823FC57C..0x823FC598)
	// 823FC57C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FC580: 40990140  ble cr6, 0x823fc6c0
	if !ctx.cr[6].gt {
	pc = 0x823FC6C0; continue 'dispatch;
	}
	// 823FC584: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FC588: 8381011C  lwz r28, 0x11c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 823FC58C: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 823FC590: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823FC594: C0AB1850  lfs f5, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	pc = 0x823FC598; continue 'dispatch;
            }
            0x823FC598 => {
    //   block [0x823FC598..0x823FC5AC)
	// 823FC598: 83BA0000  lwz r29, 0(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC59C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FC5A0: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823FC5A4: 41980008  blt cr6, 0x823fc5ac
	if ctx.cr[6].lt {
	pc = 0x823FC5AC; continue 'dispatch;
	}
	// 823FC5A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823FC5AC; continue 'dispatch;
            }
            0x823FC5AC => {
    //   block [0x823FC5AC..0x823FC604)
	// 823FC5AC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC5B0: C11B0004  lfs f8, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FC5B4: C13B0000  lfs f9, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FC5B8: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC5BC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 823FC5C0: 7FEA4214  add r31, r10, r8
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FC5C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FC5C8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 823FC5CC: C0CB0004  lfs f6, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FC5D0: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FC5D4: EDA83028  fsubs f13, f8, f6
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[6].f64) as f32) as f64);
	// 823FC5D8: EC093828  fsubs f0, f9, f7
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 823FC5DC: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC5E0: C17F0000  lfs f11, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC5E4: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC5E8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC5EC: EC0B503A  fmadds f0, f11, f0, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 823FC5F0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FC5F4: EC0B6378  fmsubs f0, f11, f13, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FC5F8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823FC5FC: 40990024  ble cr6, 0x823fc620
	if !ctx.cr[6].gt {
	pc = 0x823FC620; continue 'dispatch;
	}
	// 823FC600: 81610124  lwz r11, 0x124(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	pc = 0x823FC604; continue 'dispatch;
            }
            0x823FC604 => {
    //   block [0x823FC604..0x823FC620)
	// 823FC604: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC608: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 823FC60C: 419A00CC  beq cr6, 0x823fc6d8
	if ctx.cr[6].eq {
	pc = 0x823FC6D8; continue 'dispatch;
	}
	// 823FC610: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FC614: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC618: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FC61C: 4198FFE8  blt cr6, 0x823fc604
	if ctx.cr[6].lt {
	pc = 0x823FC604; continue 'dispatch;
	}
	pc = 0x823FC620; continue 'dispatch;
            }
            0x823FC620 => {
    //   block [0x823FC620..0x823FC624)
	// 823FC620: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x823FC624; continue 'dispatch;
            }
            0x823FC624 => {
    //   block [0x823FC624..0x823FC644)
	// 823FC624: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 823FC628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FC62C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FC630: 4BFFFDB1  bl 0x823fc3e0
	ctx.lr = 0x823FC634;
	sub_823FC3E0(ctx, base);
	// 823FC634: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FC638: 7F03C040  cmplw cr6, r3, r24
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[24].u32, &mut ctx.xer);
	// 823FC63C: 41980008  blt cr6, 0x823fc644
	if ctx.cr[6].lt {
	pc = 0x823FC644; continue 'dispatch;
	}
	// 823FC640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x823FC644; continue 'dispatch;
            }
            0x823FC644 => {
    //   block [0x823FC644..0x823FC6B4)
	// 823FC644: C1BF0004  lfs f13, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC648: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FC64C: ED4D0372  fmuls f10, f13, f13
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FC650: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC654: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 823FC658: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FC65C: EC6D02F2  fmuls f3, f13, f11
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FC660: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC664: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FC668: ED40503A  fmadds f10, f0, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 823FC66C: EC601B38  fmsubs f3, f0, f12, f3
	ctx.f[3].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[3].f64) as f32) as f64);
	// 823FC670: ED8D5B3A  fmadds f12, f13, f12, f11
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC674: EC055024  fdivs f0, f5, f10
	ctx.f[0].f64 = ((ctx.f[5].f64 / ctx.f[10].f64) as f32) as f64;
	// 823FC678: EDA30032  fmuls f13, f3, f0
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC67C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC680: EDAD382A  fadds f13, f13, f7
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 823FC684: ED8C302A  fadds f12, f12, f6
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 823FC688: EC096828  fsubs f0, f9, f13
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FC68C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC690: EC086028  fsubs f0, f8, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FC694: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FC698: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 823FC69C: 40980018  bge cr6, 0x823fc6b4
	if !ctx.cr[6].lt {
	pc = 0x823FC6B4; continue 'dispatch;
	}
	// 823FC6A0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FC6A4: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	// 823FC6A8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823FC6AC: 93B70000  stw r29, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 823FC6B0: 90770004  stw r3, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x823FC6B4; continue 'dispatch;
            }
            0x823FC6B4 => {
    //   block [0x823FC6B4..0x823FC6C0)
	// 823FC6B4: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 823FC6B8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 823FC6BC: 4082FEDC  bne 0x823fc598
	if !ctx.cr[0].eq {
	pc = 0x823FC598; continue 'dispatch;
	}
	pc = 0x823FC6C0; continue 'dispatch;
            }
            0x823FC6C0 => {
    //   block [0x823FC6C0..0x823FC6D8)
	// 823FC6C0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC6C4: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC6C8: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC6CC: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FC6D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 823FC6D4: 48138A1C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x823FC6D8 => {
    //   block [0x823FC6D8..0x823FC6E0)
	// 823FC6D8: 83C10114  lwz r30, 0x114(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 823FC6DC: 4BFFFF48  b 0x823fc624
	pc = 0x823FC624; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FC6E0 size=660
    let mut pc: u32 = 0x823FC6E0;
    'dispatch: loop {
        match pc {
            0x823FC6E0 => {
    //   block [0x823FC6E0..0x823FC728)
	// 823FC6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FC6E4: 481389A5  bl 0x82535088
	ctx.lr = 0x823FC6E8;
	sub_82535080(ctx, base);
	// 823FC6E8: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 823FC6EC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FC6F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC6F4: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823FC6F8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 823FC6FC: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 823FC700: 3AEAD670  addi r23, r10, -0x2990
	ctx.r[23].s64 = ctx.r[10].s64 + -10640;
	// 823FC704: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FC70C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FC710: 396B7708  addi r11, r11, 0x7708
	ctx.r[11].s64 = ctx.r[11].s64 + 30472;
	// 823FC714: 40990014  ble cr6, 0x823fc728
	if !ctx.cr[6].gt {
	pc = 0x823FC728; continue 'dispatch;
	}
	// 823FC718: 394B066C  addi r10, r11, 0x66c
	ctx.r[10].s64 = ctx.r[11].s64 + 1644;
	// 823FC71C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 823FC720: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 823FC724: 48000010  b 0x823fc734
	pc = 0x823FC734; continue 'dispatch;
            }
            0x823FC728 => {
    //   block [0x823FC728..0x823FC734)
	// 823FC728: 3AAB0030  addi r21, r11, 0x30
	ctx.r[21].s64 = ctx.r[11].s64 + 48;
	// 823FC72C: 39370018  addi r9, r23, 0x18
	ctx.r[9].s64 = ctx.r[23].s64 + 24;
	// 823FC730: 394B0AB8  addi r10, r11, 0xab8
	ctx.r[10].s64 = ctx.r[11].s64 + 2744;
	pc = 0x823FC734; continue 'dispatch;
            }
            0x823FC734 => {
    //   block [0x823FC734..0x823FC76C)
	// 823FC734: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 823FC738: 390B10E4  addi r8, r11, 0x10e4
	ctx.r[8].s64 = ctx.r[11].s64 + 4324;
	// 823FC73C: 394B0E10  addi r10, r11, 0xe10
	ctx.r[10].s64 = ctx.r[11].s64 + 3600;
	// 823FC740: 396B1378  addi r11, r11, 0x1378
	ctx.r[11].s64 = ctx.r[11].s64 + 4984;
	// 823FC744: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 823FC748: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 823FC74C: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 823FC750: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 823FC754: 40990034  ble cr6, 0x823fc788
	if !ctx.cr[6].gt {
	pc = 0x823FC788; continue 'dispatch;
	}
	// 823FC758: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823FC75C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 823FC760: 7CF55050  subf r7, r21, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[21].s64;
	// 823FC764: 7D159850  subf r8, r21, r19
	ctx.r[8].s64 = ctx.r[19].s64 - ctx.r[21].s64;
	// 823FC768: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	pc = 0x823FC76C; continue 'dispatch;
            }
            0x823FC76C => {
    //   block [0x823FC76C..0x823FC788)
	// 823FC76C: 7C085C2E  lfsx f0, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC770: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC774: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC778: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FC77C: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FC780: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC784: 4082FFE8  bne 0x823fc76c
	if !ctx.cr[0].eq {
	pc = 0x823FC76C; continue 'dispatch;
	}
	pc = 0x823FC788; continue 'dispatch;
            }
            0x823FC788 => {
    //   block [0x823FC788..0x823FC7BC)
	// 823FC788: 39770030  addi r11, r23, 0x30
	ctx.r[11].s64 = ctx.r[23].s64 + 48;
	// 823FC78C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FC790: 3BABFFF0  addi r29, r11, -0x10
	ctx.r[29].s64 = ctx.r[11].s64 + -16;
	// 823FC794: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC798: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 823FC79C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 823FC7A0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FC7A4: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 823FC7A8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FC7AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FC7B0: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 823FC7B4: 3B410094  addi r26, r1, 0x94
	ctx.r[26].s64 = ctx.r[1].s64 + 148;
	// 823FC7B8: 7ECA4850  subf r22, r10, r9
	ctx.r[22].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	pc = 0x823FC7BC; continue 'dispatch;
            }
            0x823FC7BC => {
    //   block [0x823FC7BC..0x823FC7D0)
	// 823FC7BC: 7D76E02E  lwzx r11, r22, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 823FC7C0: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823FC7C4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FC7C8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823FC7CC: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x823FC7D0; continue 'dispatch;
            }
            0x823FC7D0 => {
    //   block [0x823FC7D0..0x823FC7E4)
	// 823FC7D0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FC7D4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 823FC7D8: 40990024  ble cr6, 0x823fc7fc
	if !ctx.cr[6].gt {
	pc = 0x823FC7FC; continue 'dispatch;
	}
	// 823FC7DC: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 823FC7E0: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	pc = 0x823FC7E4; continue 'dispatch;
            }
            0x823FC7E4 => {
    //   block [0x823FC7E4..0x823FC7FC)
	// 823FC7E4: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC7E8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FC7EC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FC7F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC7F4: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FC7F8: 4082FFEC  bne 0x823fc7e4
	if !ctx.cr[0].eq {
	pc = 0x823FC7E4; continue 'dispatch;
	}
	pc = 0x823FC7FC; continue 'dispatch;
            }
            0x823FC7FC => {
    //   block [0x823FC7FC..0x823FC87C)
	// 823FC7FC: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC800: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FC804: 7D5B5214  add r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 823FC808: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FC80C: 4082FFC4  bne 0x823fc7d0
	if !ctx.cr[0].eq {
	pc = 0x823FC7D0; continue 'dispatch;
	}
	// 823FC810: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC814: 2F190004  cmpwi cr6, r25, 4
	ctx.cr[6].compare_i32(ctx.r[25].s32, 4, &mut ctx.xer);
	// 823FC818: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC81C: C0410070  lfs f2, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FC820: C0210074  lfs f1, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FC824: EC001028  fsubs f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FC828: EDAD0828  fsubs f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 823FC82C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC830: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC834: 40980048  bge cr6, 0x823fc87c
	if !ctx.cr[6].lt {
	pc = 0x823FC87C; continue 'dispatch;
	}
	// 823FC838: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC83C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 823FC840: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FC844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FC848: 824B001C  lwz r18, 0x1c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 823FC84C: 822B0018  lwz r17, 0x18(r11)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FC850: 820B0014  lwz r16, 0x14(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FC854: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FC858: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FC85C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FC860: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC864: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC868: 92410064  stw r18, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[18].u32 ) };
	// 823FC86C: 9221005C  stw r17, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[17].u32 ) };
	// 823FC870: 92010054  stw r16, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[16].u32 ) };
	// 823FC874: 4BFFFBE5  bl 0x823fc458
	ctx.lr = 0x823FC878;
	sub_823FC458(ctx, base);
	// 823FC878: 48000058  b 0x823fc8d0
	pc = 0x823FC8D0; continue 'dispatch;
            }
            0x823FC87C => {
    //   block [0x823FC87C..0x823FC8B8)
	// 823FC87C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FC884: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC888: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC88C: 4BFFFB55  bl 0x823fc3e0
	ctx.lr = 0x823FC890;
	sub_823FC3E0(ctx, base);
	// 823FC890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FC894: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FC898: 546A003E  slwi r10, r3, 0
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC89C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 823FC8A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC8A4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FC8A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FC8AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FC8B0: 41980008  blt cr6, 0x823fc8b8
	if ctx.cr[6].lt {
	pc = 0x823FC8B8; continue 'dispatch;
	}
	// 823FC8B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x823FC8B8; continue 'dispatch;
            }
            0x823FC8B8 => {
    //   block [0x823FC8B8..0x823FC8D0)
	// 823FC8B8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FC8BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FC8C0: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC8C4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC8C8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC8CC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x823FC8D0; continue 'dispatch;
            }
            0x823FC8D0 => {
    //   block [0x823FC8D0..0x823FC94C)
	// 823FC8D0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823FC8D4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC8D8: 38D70030  addi r6, r23, 0x30
	ctx.r[6].s64 = ctx.r[23].s64 + 48;
	// 823FC8DC: EC02002A  fadds f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC8E0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC8E4: 39580001  addi r10, r24, 1
	ctx.r[10].s64 = ctx.r[24].s64 + 1;
	// 823FC8E8: 393B0004  addi r9, r27, 4
	ctx.r[9].s64 = ctx.r[27].s64 + 4;
	// 823FC8EC: 391A0004  addi r8, r26, 4
	ctx.r[8].s64 = ctx.r[26].s64 + 4;
	// 823FC8F0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC8F4: 38FE0004  addi r7, r30, 4
	ctx.r[7].s64 = ctx.r[30].s64 + 4;
	// 823FC8F8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FC8FC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FC900: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 823FC904: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FC908: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 823FC90C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FC910: 3B0A0001  addi r24, r10, 1
	ctx.r[24].s64 = ctx.r[10].s64 + 1;
	// 823FC914: 3B690004  addi r27, r9, 4
	ctx.r[27].s64 = ctx.r[9].s64 + 4;
	// 823FC918: 3B480004  addi r26, r8, 4
	ctx.r[26].s64 = ctx.r[8].s64 + 4;
	// 823FC91C: 3BC70004  addi r30, r7, 4
	ctx.r[30].s64 = ctx.r[7].s64 + 4;
	// 823FC920: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 823FC924: 7F1D3000  cmpw cr6, r29, r6
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FC928: 4198FE94  blt cr6, 0x823fc7bc
	if ctx.cr[6].lt {
	pc = 0x823FC7BC; continue 'dispatch;
	}
	// 823FC92C: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 823FC930: 40990038  ble cr6, 0x823fc968
	if !ctx.cr[6].gt {
	pc = 0x823FC968; continue 'dispatch;
	}
	// 823FC934: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 823FC938: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 823FC93C: 7D2AA850  subf r9, r10, r21
	ctx.r[9].s64 = ctx.r[21].s64 - ctx.r[10].s64;
	// 823FC940: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 823FC944: 7D089850  subf r8, r8, r19
	ctx.r[8].s64 = ctx.r[19].s64 - ctx.r[8].s64;
	// 823FC948: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	pc = 0x823FC94C; continue 'dispatch;
            }
            0x823FC94C => {
    //   block [0x823FC94C..0x823FC968)
	// 823FC94C: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC950: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FC954: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FC958: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FC95C: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FC960: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FC964: 4082FFE8  bne 0x823fc94c
	if !ctx.cr[0].eq {
	pc = 0x823FC94C; continue 'dispatch;
	}
	pc = 0x823FC968; continue 'dispatch;
            }
            0x823FC968 => {
    //   block [0x823FC968..0x823FC974)
	// 823FC968: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 823FC96C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 823FC970: 48138768  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FC978 size=84
    let mut pc: u32 = 0x823FC978;
    'dispatch: loop {
        match pc {
            0x823FC978 => {
    //   block [0x823FC978..0x823FC998)
	// 823FC978: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FC97C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FC980: 396B8CB8  addi r11, r11, -0x7348
	ctx.r[11].s64 = ctx.r[11].s64 + -29512;
	// 823FC984: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823FC988: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 823FC98C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC990: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC994: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x823FC998; continue 'dispatch;
            }
            0x823FC998 => {
    //   block [0x823FC998..0x823FC9B4)
	// 823FC998: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC99C: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FC9A0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FC9A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FC9A8: 4098000C  bge cr6, 0x823fc9b4
	if !ctx.cr[6].lt {
	pc = 0x823FC9B4; continue 'dispatch;
	}
	// 823FC9AC: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 823FC9B0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	pc = 0x823FC9B4; continue 'dispatch;
            }
            0x823FC9B4 => {
    //   block [0x823FC9B4..0x823FC9CC)
	// 823FC9B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FC9B8: 390B0100  addi r8, r11, 0x100
	ctx.r[8].s64 = ctx.r[11].s64 + 256;
	// 823FC9BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FC9C0: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 823FC9C4: 4198FFD4  blt cr6, 0x823fc998
	if ctx.cr[6].lt {
	pc = 0x823FC998; continue 'dispatch;
	}
	// 823FC9C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FC9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FC9D0 size=152
    let mut pc: u32 = 0x823FC9D0;
    'dispatch: loop {
        match pc {
            0x823FC9D0 => {
    //   block [0x823FC9D0..0x823FC9F0)
	// 823FC9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FC9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FC9D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FC9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FC9E0: C00B1848  lfs f0, 0x1848(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC9E4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FC9E8: 41990008  bgt cr6, 0x823fc9f0
	if ctx.cr[6].gt {
	pc = 0x823FC9F0; continue 'dispatch;
	}
	// 823FC9EC: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x823FC9F0; continue 'dispatch;
            }
            0x823FC9F0 => {
    //   block [0x823FC9F0..0x823FCA04)
	// 823FC9F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FC9F4: C00B2ECC  lfs f0, 0x2ecc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FC9F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FC9FC: 40990008  ble cr6, 0x823fca04
	if !ctx.cr[6].gt {
	pc = 0x823FCA04; continue 'dispatch;
	}
	// 823FCA00: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x823FCA04; continue 'dispatch;
            }
            0x823FCA04 => {
    //   block [0x823FCA04..0x823FCA48)
	// 823FCA04: 481365D5  bl 0x82532fd8
	ctx.lr = 0x823FCA08;
	sub_82532FD8(ctx, base);
	// 823FCA08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCA0C: C80B8DC0  lfd f0, -0x7240(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-29248 as u32) ) };
	// 823FCA10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCA14: FC000828  fsub f0, f0, f1
	ctx.f[0].f64 = ctx.f[0].f64 - ctx.f[1].f64;
	// 823FCA18: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FCA1C: C00B8DB8  lfs f0, -0x7248(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCA20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCA24: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FCA28: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCA2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCA30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FCA34: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCA38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FCA3C: 4099000C  ble cr6, 0x823fca48
	if !ctx.cr[6].gt {
	pc = 0x823FCA48; continue 'dispatch;
	}
	// 823FCA40: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FCA44: 48000008  b 0x823fca4c
	pc = 0x823FCA4C; continue 'dispatch;
            }
            0x823FCA48 => {
    //   block [0x823FCA48..0x823FCA4C)
	// 823FCA48: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x823FCA4C; continue 'dispatch;
            }
            0x823FCA4C => {
    //   block [0x823FCA4C..0x823FCA68)
	// 823FCA4C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FCA50: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FCA54: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FCA58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FCA5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCA60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCA64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCA68 size=76
    let mut pc: u32 = 0x823FCA68;
    'dispatch: loop {
        match pc {
            0x823FCA68 => {
    //   block [0x823FCA68..0x823FCAB4)
	// 823FCA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FCA70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCA74: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 823FCA78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FCA7C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823FCA80: C00B76FC  lfs f0, 0x76fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCA84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FCA88: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FCA8C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FCA90: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FCA94: C1AB76F8  lfs f13, 0x76f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30456 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCA98: EC2C683C  fnmsubs f1, f12, f0, f13
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FCA9C: 481369FD  bl 0x82533498
	ctx.lr = 0x823FCAA0;
	sub_82533498(ctx, base);
	// 823FCAA0: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FCAA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FCAA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCAAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCAB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FCAB8 size=124
    let mut pc: u32 = 0x823FCAB8;
    'dispatch: loop {
        match pc {
            0x823FCAB8 => {
    //   block [0x823FCAB8..0x823FCAD4)
	// 823FCAB8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCABC: EDA300F2  fmuls f13, f3, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[3].f64) as f32) as f64);
	// 823FCAC0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FCAC4: 396B8DC8  addi r11, r11, -0x7238
	ctx.r[11].s64 = ctx.r[11].s64 + -29240;
	// 823FCAC8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FCACC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 823FCAD0: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	pc = 0x823FCAD4; continue 'dispatch;
            }
            0x823FCAD4 => {
    //   block [0x823FCAD4..0x823FCAF0)
	// 823FCAD4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCAD8: EC030028  fsubs f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FCADC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FCAE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FCAE4: 4098000C  bge cr6, 0x823fcaf0
	if !ctx.cr[6].lt {
	pc = 0x823FCAF0; continue 'dispatch;
	}
	// 823FCAE8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 823FCAEC: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x823FCAF0; continue 'dispatch;
            }
            0x823FCAF0 => {
    //   block [0x823FCAF0..0x823FCB28)
	// 823FCAF0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FCAF4: 38CB0020  addi r6, r11, 0x20
	ctx.r[6].s64 = ctx.r[11].s64 + 32;
	// 823FCAF8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FCAFC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FCB00: 4198FFD4  blt cr6, 0x823fcad4
	if ctx.cr[6].lt {
	pc = 0x823FCAD4; continue 'dispatch;
	}
	// 823FCB04: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FCB08: EC011028  fsubs f0, f1, f2
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FCB0C: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCB10: EDAD1028  fsubs f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FCB14: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FCB18: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FCB1C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FCB20: 40980008  bge cr6, 0x823fcb28
	if !ctx.cr[6].lt {
	pc = 0x823FCB28; continue 'dispatch;
	}
	// 823FCB24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x823FCB28; continue 'dispatch;
            }
            0x823FCB28 => {
    //   block [0x823FCB28..0x823FCB34)
	// 823FCB28: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCB2C: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 823FCB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCB38 size=92
    let mut pc: u32 = 0x823FCB38;
    'dispatch: loop {
        match pc {
            0x823FCB38 => {
    //   block [0x823FCB38..0x823FCB84)
	// 823FCB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCB3C: 48138581  bl 0x825350bc
	ctx.lr = 0x823FCB40;
	sub_82535080(ctx, base);
	// 823FCB40: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 823FCB44: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCB48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FCB4C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FCB50: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FCB54: 557F0738  rlwinm r31, r11, 0, 0x1c, 0x1c
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 823FCB58: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FCB5C: 386A8DC8  addi r3, r10, -0x7238
	ctx.r[3].s64 = ctx.r[10].s64 + -29240;
	// 823FCB60: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 823FCB64: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 823FCB68: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823FCB6C: 4BFFF85D  bl 0x823fc3c8
	ctx.lr = 0x823FCB70;
	sub_823FC3C8(ctx, base);
	// 823FCB70: D03E0000  stfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCB74: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FCB78: 409A000C  bne cr6, 0x823fcb84
	if !ctx.cr[6].eq {
	pc = 0x823FCB84; continue 'dispatch;
	}
	// 823FCB7C: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCB80: 48000008  b 0x823fcb88
	pc = 0x823FCB88; continue 'dispatch;
            }
            0x823FCB84 => {
    //   block [0x823FCB84..0x823FCB88)
	// 823FCB84: D03D0000  stfs f1, 0(r29)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FCB88; continue 'dispatch;
            }
            0x823FCB88 => {
    //   block [0x823FCB88..0x823FCB94)
	// 823FCB88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 823FCB8C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823FCB90: 4813857C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCB98 size=516
    let mut pc: u32 = 0x823FCB98;
    'dispatch: loop {
        match pc {
            0x823FCB98 => {
    //   block [0x823FCB98..0x823FCC1C)
	// 823FCB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCB9C: 4813850D  bl 0x825350a8
	ctx.lr = 0x823FCBA0;
	sub_82535080(ctx, base);
	// 823FCBA0: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 823FCBA4: 4813943D  bl 0x82535fe0
	ctx.lr = 0x823FCBA8;
	sub_82535FB0(ctx, base);
	// 823FCBA8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCBAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FCBB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FCBB4: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 823FCBB8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FCBBC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823FCBC0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 823FCBC4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823FCBC8: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 823FCBCC: C36A1850  lfs f27, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 823FCBD0: 3B2BFF6A  addi r25, r11, -0x96
	ctx.r[25].s64 = ctx.r[11].s64 + -150;
	// 823FCBD4: C3BF0020  lfs f29, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FCBD8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCBDC: C39F0024  lfs f28, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823FCBE0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FCBE4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823FCBE8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823FCBEC: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 823FCBF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FCBF4: 7FEBFC2E  lfsx f31, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FCBF8: C34A2850  lfs f26, 0x2850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10320 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 823FCBFC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823FCC00: 7FCBE42E  lfsx f30, r11, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FCC04: 48000D5D  bl 0x823fd960
	ctx.lr = 0x823FCC08;
	sub_823FD960(ctx, base);
	// 823FCC08: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FCC0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCC10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FCC14: C1898DF0  lfs f12, -0x7210(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FCC18: C16B8DEC  lfs f11, -0x7214(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29204 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x823FCC1C; continue 'dispatch;
            }
            0x823FCC1C => {
    //   block [0x823FCC1C..0x823FCCB4)
	// 823FCC1C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCC20: ED5F0332  fmuls f10, f31, f12
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FCC24: EDA002F2  fmuls f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FCC28: C13D0004  lfs f9, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FCC2C: ED1E0332  fmuls f8, f30, f12
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FCC30: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 823FCC34: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 823FCC38: 7D691670  srawi r9, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 823FCC3C: 7D290194  addze r9, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[9].s64 = tmp.s64;
	// 823FCC40: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FCC44: 7FC95850  subf r30, r9, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823FCC48: EFE0537A  fmadds f31, f0, f13, f10
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 823FCC4C: EFC9437A  fmadds f30, f9, f13, f8
	ctx.f[30].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 823FCC50: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCC54: 7CEBFC2E  lfsx f7, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FCC58: 7CCBE42E  lfsx f6, r11, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FCC5C: 7FEBFD2E  stfsx f31, r11, r31
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FCC60: 7FCBE52E  stfsx f30, r11, r28
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 823FCC64: EDBC07F2  fmuls f13, f28, f31
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 823FCC68: ED5DF82A  fadds f10, f29, f31
	ctx.f[10].f64 = ((ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64;
	// 823FCC6C: ED3CF02A  fadds f9, f28, f30
	ctx.f[9].f64 = ((ctx.f[28].f64 + ctx.f[30].f64) as f32) as f64;
	// 823FCC70: EC1D07F2  fmuls f0, f29, f31
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 823FCC74: EDBD6FB8  fmsubs f13, f29, f30, f13
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FCC78: EFAA3828  fsubs f29, f10, f7
	ctx.f[29].f64 = (((ctx.f[10].f64 - ctx.f[7].f64) as f32) as f64);
	// 823FCC7C: EF893028  fsubs f28, f9, f6
	ctx.f[28].f64 = (((ctx.f[9].f64 - ctx.f[6].f64) as f32) as f64);
	// 823FCC80: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 823FCC84: 41980030  blt cr6, 0x823fccb4
	if ctx.cr[6].lt {
	pc = 0x823FCCB4; continue 'dispatch;
	}
	// 823FCC88: ED4D06F2  fmuls f10, f13, f27
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 823FCC8C: D1410050  stfs f10, 0x50(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FCC90: ED4006B2  fmuls f10, f0, f26
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 823FCC94: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 823FCC98: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823FCC9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FCCA0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FCCA4: 40990010  ble cr6, 0x823fccb4
	if !ctx.cr[6].gt {
	pc = 0x823FCCB4; continue 'dispatch;
	}
	// 823FCCA8: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 823FCCAC: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 823FCCB0: FF406890  fmr f26, f13
	ctx.f[26].f64 = ctx.f[13].f64;
	pc = 0x823FCCB4; continue 'dispatch;
            }
            0x823FCCB4 => {
    //   block [0x823FCCB4..0x823FCD48)
	// 823FCCB4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 823FCCB8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 823FCCBC: 2F0A00A0  cmpwi cr6, r10, 0xa0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 160, &mut ctx.xer);
	// 823FCCC0: 4198FF5C  blt cr6, 0x823fcc1c
	if ctx.cr[6].lt {
	pc = 0x823FCC1C; continue 'dispatch;
	}
	// 823FCCC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FCCC8: D3BF0020  stfs f29, 0x20(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FCCCC: D39F0024  stfs f28, 0x24(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823FCCD0: 2F1A0050  cmpwi cr6, r26, 0x50
	ctx.cr[6].compare_i32(ctx.r[26].s32, 80, &mut ctx.xer);
	// 823FCCD4: 935F002C  stw r26, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 823FCCD8: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 823FCCDC: C00B8DE8  lfs f0, -0x7218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCCE0: 7F0B0E70  srawi r11, r24, 1
	ctx.xer.ca = (ctx.r[24].s32 < 0) && ((ctx.r[24].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[24].s32 >> 1) as i64;
	// 823FCCE4: 7D6BD850  subf r11, r11, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 823FCCE8: 40990060  ble cr6, 0x823fcd48
	if !ctx.cr[6].gt {
	pc = 0x823FCD48; continue 'dispatch;
	}
	// 823FCCEC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FCCF0: 213A00A0  subfic r9, r26, 0xa0
	ctx.xer.ca = ctx.r[26].u32 <= 160 as u32;
	ctx.r[9].s64 = (160 as i64) - ctx.r[26].s64;
	// 823FCCF4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 823FCCF8: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823FCCFC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FCD00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCD04: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 823FCD08: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FCD0C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FCD10: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FCD14: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FCD18: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FCD1C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FCD20: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FCD24: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCD28: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FCD2C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FCD30: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FCD34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 823FCD38: 2F030028  cmpwi cr6, r3, 0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, 40, &mut ctx.xer);
	// 823FCD3C: 40990050  ble cr6, 0x823fcd8c
	if !ctx.cr[6].gt {
	pc = 0x823FCD8C; continue 'dispatch;
	}
	// 823FCD40: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 823FCD44: 48000048  b 0x823fcd8c
	pc = 0x823FCD8C; continue 'dispatch;
            }
            0x823FCD48 => {
    //   block [0x823FCD48..0x823FCD8C)
	// 823FCD48: 7D6BD1D6  mullw r11, r11, r26
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FCD4C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FCD50: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FCD54: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 823FCD58: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FCD5C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FCD60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCD64: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FCD68: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCD6C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FCD70: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FCD74: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FCD78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FCD7C: 7C6B00D0  neg r3, r11
	ctx.r[3].s64 = -ctx.r[11].s64;
	// 823FCD80: 2F03FFD8  cmpwi cr6, r3, -0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, -40, &mut ctx.xer);
	// 823FCD84: 40980008  bge cr6, 0x823fcd8c
	if !ctx.cr[6].lt {
	pc = 0x823FCD8C; continue 'dispatch;
	}
	// 823FCD88: 3860FFD8  li r3, -0x28
	ctx.r[3].s64 = -40;
	pc = 0x823FCD8C; continue 'dispatch;
            }
            0x823FCD8C => {
    //   block [0x823FCD8C..0x823FCD9C)
	// 823FCD8C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 823FCD90: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 823FCD94: 48139299  bl 0x8253602c
	ctx.lr = 0x823FCD98;
	sub_82535FFC(ctx, base);
	// 823FCD98: 48138360  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCDA0 size=176
    let mut pc: u32 = 0x823FCDA0;
    'dispatch: loop {
        match pc {
            0x823FCDA0 => {
    //   block [0x823FCDA0..0x823FCDE4)
	// 823FCDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCDA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FCDA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FCDAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FCDB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCDB4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FCDB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FCDBC: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 823FCDC0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCDC4: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FCDC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCDCC: 4E800421  bctrl
	ctx.lr = 0x823FCDD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCDD0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FCDD4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FCDD8: 4082000C  bne 0x823fcde4
	if !ctx.cr[0].eq {
	pc = 0x823FCDE4; continue 'dispatch;
	}
	// 823FCDDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCDE0: 48000058  b 0x823fce38
	pc = 0x823FCE38; continue 'dispatch;
            }
            0x823FCDE4 => {
    //   block [0x823FCDE4..0x823FCE38)
	// 823FCDE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCDE8: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FCDEC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 823FCDF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FCDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FCDF8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCDFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FCE00: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 823FCE04: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 823FCE08: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 823FCE0C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 823FCE10: 817E37B0  lwz r11, 0x37b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FCE14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCE18: 4E800421  bctrl
	ctx.lr = 0x823FCE1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCE1C: 817E37B0  lwz r11, 0x37b0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FCE20: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 823FCE24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FCE28: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 823FCE2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCE30: 4E800421  bctrl
	ctx.lr = 0x823FCE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCE34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            0x823FCE38 => {
    //   block [0x823FCE38..0x823FCE50)
	// 823FCE38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FCE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCE44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FCE48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FCE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCE50 size=168
    let mut pc: u32 = 0x823FCE50;
    'dispatch: loop {
        match pc {
            0x823FCE50 => {
    //   block [0x823FCE50..0x823FCE68)
	// 823FCE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCE54: 48138269  bl 0x825350bc
	ctx.lr = 0x823FCE58;
	sub_82535080(ctx, base);
	// 823FCE58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCE5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FCE60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 823FCE64: 409A000C  bne cr6, 0x823fce70
	if !ctx.cr[6].eq {
	pc = 0x823FCE70; continue 'dispatch;
	}
	pc = 0x823FCE68; continue 'dispatch;
            }
            0x823FCE68 => {
    //   block [0x823FCE68..0x823FCE70)
	// 823FCE68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCE6C: 48000084  b 0x823fcef0
	pc = 0x823FCEF0; continue 'dispatch;
            }
            0x823FCE70 => {
    //   block [0x823FCE70..0x823FCEF0)
	// 823FCE70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FCE74: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FCE78: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 823FCE7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FCE80: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FCE84: 817E37A8  lwz r11, 0x37a8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FCE88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCE8C: 4E800421  bctrl
	ctx.lr = 0x823FCE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCE90: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FCE94: 4182FFD4  beq 0x823fce68
	if ctx.cr[0].eq {
	pc = 0x823FCE68; continue 'dispatch;
	}
	// 823FCE98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FCE9C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 823FCEA0: 817E37A8  lwz r11, 0x37a8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FCEA4: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 823FCEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCEAC: 4E800421  bctrl
	ctx.lr = 0x823FCEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCEB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FCEB4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 823FCEB8: 4182FFB0  beq 0x823fce68
	if ctx.cr[0].eq {
	pc = 0x823FCE68; continue 'dispatch;
	}
	// 823FCEBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCEC0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FCEC4: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 823FCEC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FCECC: C00B204C  lfs f0, 0x204c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCED0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FCED4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FCED8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCEDC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FCEE0: 816A37B0  lwz r11, 0x37b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FCEE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCEE8: 4E800421  bctrl
	ctx.lr = 0x823FCEEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCEEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            0x823FCEF0 => {
    //   block [0x823FCEF0..0x823FCEF8)
	// 823FCEF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FCEF4: 48138218  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FCEF8 size=112
    let mut pc: u32 = 0x823FCEF8;
    'dispatch: loop {
        match pc {
            0x823FCEF8 => {
    //   block [0x823FCEF8..0x823FCF3C)
	// 823FCEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FCF00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FCF04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FCF08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FCF0C: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FCF10: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FCF14: 41820038  beq 0x823fcf4c
	if ctx.cr[0].eq {
	pc = 0x823FCF4C; continue 'dispatch;
	}
	// 823FCF18: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FCF1C: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 823FCF20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FCF24: 41820018  beq 0x823fcf3c
	if ctx.cr[0].eq {
	pc = 0x823FCF3C; continue 'dispatch;
	}
	// 823FCF28: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FCF2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCF30: 4E800421  bctrl
	ctx.lr = 0x823FCF34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FCF34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FCF38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
            }
            0x823FCF3C => {
    //   block [0x823FCF3C..0x823FCF4C)
	// 823FCF3C: 817E37AC  lwz r11, 0x37ac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FCF40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FCF44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FCF48: 4E800421  bctrl
	ctx.lr = 0x823FCF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x823FCF4C => {
    //   block [0x823FCF4C..0x823FCF68)
	// 823FCF4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FCF50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FCF54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FCF58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FCF5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FCF60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FCF64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FCF68 size=132
    let mut pc: u32 = 0x823FCF68;
    'dispatch: loop {
        match pc {
            0x823FCF68 => {
    //   block [0x823FCF68..0x823FCF88)
	// 823FCF68: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FCF6C: 3564FFFF  addic. r11, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FCF70: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FCF74: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FCF78: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 823FCF7C: 41800020  blt 0x823fcf9c
	if ctx.cr[0].lt {
	pc = 0x823FCF9C; continue 'dispatch;
	}
	// 823FCF80: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FCF84: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	pc = 0x823FCF88; continue 'dispatch;
            }
            0x823FCF88 => {
    //   block [0x823FCF88..0x823FCF9C)
	// 823FCF88: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCF8C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FCF90: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 823FCF94: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FCF98: 4080FFF0  bge 0x823fcf88
	if !ctx.cr[0].lt {
	pc = 0x823FCF88; continue 'dispatch;
	}
	pc = 0x823FCF9C; continue 'dispatch;
            }
            0x823FCF9C => {
    //   block [0x823FCF9C..0x823FCFBC)
	// 823FCF9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FCFA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FCFA4: C1AA2954  lfs f13, 0x2954(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FCFA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823FCFAC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FCFB0: 41980028  blt cr6, 0x823fcfd8
	if ctx.cr[6].lt {
	pc = 0x823FCFD8; continue 'dispatch;
	}
	// 823FCFB4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FCFB8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x823FCFBC; continue 'dispatch;
            }
            0x823FCFBC => {
    //   block [0x823FCFBC..0x823FCFD8)
	// 823FCFBC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FCFC0: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FCFC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FCFC8: 40980010  bge cr6, 0x823fcfd8
	if !ctx.cr[6].lt {
	pc = 0x823FCFD8; continue 'dispatch;
	}
	// 823FCFCC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FCFD0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 823FCFD4: 4080FFE8  bge 0x823fcfbc
	if !ctx.cr[0].lt {
	pc = 0x823FCFBC; continue 'dispatch;
	}
	pc = 0x823FCFD8; continue 'dispatch;
            }
            0x823FCFD8 => {
    //   block [0x823FCFD8..0x823FCFEC)
	// 823FCFD8: 386A0002  addi r3, r10, 2
	ctx.r[3].s64 = ctx.r[10].s64 + 2;
	// 823FCFDC: 2F03004C  cmpwi cr6, r3, 0x4c
	ctx.cr[6].compare_i32(ctx.r[3].s32, 76, &mut ctx.xer);
	// 823FCFE0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 823FCFE4: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 823FCFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FCFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FCFF0 size=472
    let mut pc: u32 = 0x823FCFF0;
    'dispatch: loop {
        match pc {
            0x823FCFF0 => {
    //   block [0x823FCFF0..0x823FD02C)
	// 823FCFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FCFF4: 481380C1  bl 0x825350b4
	ctx.lr = 0x823FCFF8;
	sub_82535080(ctx, base);
	// 823FCFF8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 823FCFFC: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD000: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823FD004: 38C40001  addi r6, r4, 1
	ctx.r[6].s64 = ctx.r[4].s64 + 1;
	// 823FD008: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FD00C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FD010: 3BE10170  addi r31, r1, 0x170
	ctx.r[31].s64 = ctx.r[1].s64 + 368;
	// 823FD014: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FD018: 7CCA0E71  srawi. r10, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FD01C: 40810034  ble 0x823fd050
	if !ctx.cr[0].gt {
	pc = 0x823FD050; continue 'dispatch;
	}
	// 823FD020: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 823FD024: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 823FD028: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x823FD02C; continue 'dispatch;
            }
            0x823FD02C => {
    //   block [0x823FD02C..0x823FD050)
	// 823FD02C: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD030: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FD034: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD038: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 823FD03C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD040: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD044: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD048: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FD04C: 4082FFE0  bne 0x823fd02c
	if !ctx.cr[0].eq {
	pc = 0x823FD02C; continue 'dispatch;
	}
	pc = 0x823FD050; continue 'dispatch;
            }
            0x823FD050 => {
    //   block [0x823FD050..0x823FD080)
	// 823FD050: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD054: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FD058: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FD05C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FD060: 419A0020  beq cr6, 0x823fd080
	if ctx.cr[6].eq {
	pc = 0x823FD080; continue 'dispatch;
	}
	// 823FD064: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD068: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD06C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FD070: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FD074: 7C0A1C2E  lfsx f0, r10, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD078: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD07C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x823FD080; continue 'dispatch;
            }
            0x823FD080 => {
    //   block [0x823FD080..0x823FD114)
	// 823FD080: 21490041  subfic r10, r9, 0x41
	ctx.xer.ca = ctx.r[9].u32 <= 65 as u32;
	ctx.r[10].s64 = (65 as i64) - ctx.r[9].s64;
	// 823FD084: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 823FD088: 555E103A  slwi r30, r10, 2
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 823FD08C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 823FD090: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD094: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FD098: 817D37B0  lwz r11, 0x37b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FD09C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD0A0: 4E800421  bctrl
	ctx.lr = 0x823FD0A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD0A4: 817D37B0  lwz r11, 0x37b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FD0A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FD0AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FD0B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD0B8: 4E800421  bctrl
	ctx.lr = 0x823FD0BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD0BC: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 823FD0C0: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 823FD0C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD0C8: 48000979  bl 0x823fda40
	ctx.lr = 0x823FD0CC;
	sub_823FDA40(ctx, base);
	// 823FD0CC: 7F8B07B4  extsw r11, r28
	ctx.r[11].s64 = ctx.r[28].s32 as i64;
	// 823FD0D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FD0D4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FD0D8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FD0DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD0E0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FD0E4: C00B2148  lfs f0, 0x2148(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD0E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FD0EC: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FD0F0: C00B72B8  lfs f0, 0x72b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD0F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD0F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD0FC: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD100: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FD104: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823FD108: 4099000C  ble cr6, 0x823fd114
	if !ctx.cr[6].gt {
	pc = 0x823FD114; continue 'dispatch;
	}
	// 823FD10C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FD110: 48000008  b 0x823fd118
	pc = 0x823FD118; continue 'dispatch;
            }
            0x823FD114 => {
    //   block [0x823FD114..0x823FD118)
	// 823FD114: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x823FD118; continue 'dispatch;
            }
            0x823FD118 => {
    //   block [0x823FD118..0x823FD13C)
	// 823FD118: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FD11C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FD120: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FD124: 357CFFFF  addic. r11, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD128: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FD12C: 40810044  ble 0x823fd170
	if !ctx.cr[0].gt {
	pc = 0x823FD170; continue 'dispatch;
	}
	// 823FD130: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 823FD134: 39404000  li r10, 0x4000
	ctx.r[10].s64 = 16384;
	// 823FD138: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	pc = 0x823FD13C; continue 'dispatch;
            }
            0x823FD13C => {
    //   block [0x823FD13C..0x823FD170)
	// 823FD13C: 7D487E70  srawi r8, r10, 0xf
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 15) as i64;
	// 823FD140: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823FD144: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD148: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 823FD14C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD150: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 823FD154: 7DA82C2E  lfsx f13, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD158: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FD15C: 7C08242E  lfsx f0, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD160: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FD164: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD168: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FD16C: 4082FFD0  bne 0x823fd13c
	if !ctx.cr[0].eq {
	pc = 0x823FD13C; continue 'dispatch;
	}
	pc = 0x823FD170; continue 'dispatch;
            }
            0x823FD170 => {
    //   block [0x823FD170..0x823FD198)
	// 823FD170: 7D6639D6  mullw r11, r6, r7
	ctx.r[11].s32 = ((ctx.r[6].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FD174: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 823FD178: 7D6B7E70  srawi r11, r11, 0xf
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 15) as i64;
	// 823FD17C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 823FD180: 41980018  blt cr6, 0x823fd198
	if ctx.cr[6].lt {
	pc = 0x823FD198; continue 'dispatch;
	}
	// 823FD184: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD188: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823FD18C: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD190: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD194: 48000028  b 0x823fd1bc
	pc = 0x823FD1BC; continue 'dispatch;
            }
            0x823FD198 => {
    //   block [0x823FD198..0x823FD1BC)
	// 823FD198: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD19C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823FD1A0: 39210170  addi r9, r1, 0x170
	ctx.r[9].s64 = ctx.r[1].s64 + 368;
	// 823FD1A4: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD1A8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD1AC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FD1B0: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD1B4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FD1B8: 7C08DD2E  stfsx f0, r8, r27
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	pc = 0x823FD1BC; continue 'dispatch;
            }
            0x823FD1BC => {
    //   block [0x823FD1BC..0x823FD1C8)
	// 823FD1BC: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 823FD1C0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 823FD1C4: 48137F40  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD1C8 size=348
    let mut pc: u32 = 0x823FD1C8;
    'dispatch: loop {
        match pc {
            0x823FD1C8 => {
    //   block [0x823FD1C8..0x823FD234)
	// 823FD1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD1D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FD1D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD1D8: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD1DC: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 823FD1E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FD1E4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823FD1E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FD1EC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FD1F0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FD1F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD1F8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FD1FC: C00B260C  lfs f0, 0x260c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD200: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FD204: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD208: C00B72B8  lfs f0, 0x72b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD20C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD210: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD214: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD21C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FD220: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FD224: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FD228: 4099000C  ble cr6, 0x823fd234
	if !ctx.cr[6].gt {
	pc = 0x823FD234; continue 'dispatch;
	}
	// 823FD22C: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 823FD230: 48000008  b 0x823fd238
	pc = 0x823FD238; continue 'dispatch;
            }
            0x823FD234 => {
    //   block [0x823FD234..0x823FD238)
	// 823FD234: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x823FD238; continue 'dispatch;
            }
            0x823FD238 => {
    //   block [0x823FD238..0x823FD254)
	// 823FD238: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FD23C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FD240: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FD244: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FD248: 39610064  addi r11, r1, 0x64
	ctx.r[11].s64 = ctx.r[1].s64 + 100;
	// 823FD24C: 39284000  addi r9, r8, 0x4000
	ctx.r[9].s64 = ctx.r[8].s64 + 16384;
	// 823FD250: 3940003F  li r10, 0x3f
	ctx.r[10].s64 = 63;
	pc = 0x823FD254; continue 'dispatch;
            }
            0x823FD254 => {
    //   block [0x823FD254..0x823FD2C4)
	// 823FD254: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FD258: 7D277E70  srawi r7, r9, 0xf
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[9].s32 >> 15) as i64;
	// 823FD25C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FD260: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FD264: 7C071C2E  lfsx f0, r7, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD268: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD26C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD270: 4082FFE4  bne 0x823fd254
	if !ctx.cr[0].eq {
	pc = 0x823FD254; continue 'dispatch;
	}
	// 823FD274: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FD278: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD27C: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FD280: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD284: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 823FD288: 816A37B0  lwz r11, 0x37b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FD28C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD290: 4E800421  bctrl
	ctx.lr = 0x823FD294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD294: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 823FD298: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 823FD29C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD2A0: 480007E1  bl 0x823fda80
	ctx.lr = 0x823FD2A4;
	sub_823FDA80(ctx, base);
	// 823FD2A4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FD2A8: 38DF0001  addi r6, r31, 1
	ctx.r[6].s64 = ctx.r[31].s64 + 1;
	// 823FD2AC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FD2B0: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 823FD2B4: 7CC70E71  srawi. r7, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[6].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FD2B8: C0092384  lfs f0, 0x2384(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD2BC: 40810038  ble 0x823fd2f4
	if !ctx.cr[0].gt {
	pc = 0x823FD2F4; continue 'dispatch;
	}
	// 823FD2C0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
            }
            0x823FD2C4 => {
    //   block [0x823FD2C4..0x823FD2F4)
	// 823FD2C4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD2C8: 391E0004  addi r8, r30, 4
	ctx.r[8].s64 = ctx.r[30].s64 + 4;
	// 823FD2CC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD2D0: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD2D4: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD2D8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FD2DC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD2E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FD2E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FD2E8: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD2EC: 3BC80004  addi r30, r8, 4
	ctx.r[30].s64 = ctx.r[8].s64 + 4;
	// 823FD2F0: 4082FFD4  bne 0x823fd2c4
	if !ctx.cr[0].eq {
	pc = 0x823FD2C4; continue 'dispatch;
	}
	pc = 0x823FD2F4; continue 'dispatch;
            }
            0x823FD2F4 => {
    //   block [0x823FD2F4..0x823FD30C)
	// 823FD2F4: 54EA083C  slwi r10, r7, 1
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD2F8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FD2FC: 419A0010  beq cr6, 0x823fd30c
	if ctx.cr[6].eq {
	pc = 0x823FD30C; continue 'dispatch;
	}
	// 823FD300: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD304: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD308: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FD30C; continue 'dispatch;
            }
            0x823FD30C => {
    //   block [0x823FD30C..0x823FD324)
	// 823FD30C: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 823FD310: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD314: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD318: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FD31C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD328 size=428
    let mut pc: u32 = 0x823FD328;
    'dispatch: loop {
        match pc {
            0x823FD328 => {
    //   block [0x823FD328..0x823FD3A4)
	// 823FD328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD32C: 48137D89  bl 0x825350b4
	ctx.lr = 0x823FD330;
	sub_82535080(ctx, base);
	// 823FD330: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 823FD334: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD338: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FD33C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FD340: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823FD344: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FD348: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 823FD34C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 823FD350: 38C0002B  li r6, 0x2b
	ctx.r[6].s64 = 43;
	// 823FD354: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 823FD358: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FD35C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 823FD360: 48001C21  bl 0x823fef80
	ctx.lr = 0x823FD364;
	sub_823FEF80(ctx, base);
	// 823FD364: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 823FD368: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FD36C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FD370: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FD374: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FD378: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FD37C: C00B9034  lfs f0, -0x6fcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28620 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD380: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD384: 481375C5  bl 0x82534948
	ctx.lr = 0x823FD388;
	sub_82534948(ctx, base);
	// 823FD388: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FD38C: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 823FD390: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FD394: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FD398: 2F1F0007  cmpwi cr6, r31, 7
	ctx.cr[6].compare_i32(ctx.r[31].s32, 7, &mut ctx.xer);
	// 823FD39C: 40990008  ble cr6, 0x823fd3a4
	if !ctx.cr[6].gt {
	pc = 0x823FD3A4; continue 'dispatch;
	}
	// 823FD3A0: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	pc = 0x823FD3A4; continue 'dispatch;
            }
            0x823FD3A4 => {
    //   block [0x823FD3A4..0x823FD448)
	// 823FD3A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823FD3A8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 823FD3AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FD3B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FD3B4: 4BFFFE15  bl 0x823fd1c8
	ctx.lr = 0x823FD3B8;
	sub_823FD1C8(ctx, base);
	// 823FD3B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD3BC: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD3C0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 823FD3C4: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 823FD3C8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823FD3CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FD3D0: C00B2494  lfs f0, 0x2494(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD3D4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 823FD3D8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD3DC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 823FD3E0: 48001709  bl 0x823feae8
	ctx.lr = 0x823FD3E4;
	sub_823FEAE8(ctx, base);
	// 823FD3E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD3E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FD3EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 823FD3F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD3F4: C02B2420  lfs f1, 0x2420(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9248 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD3F8: 48001D99  bl 0x823ff190
	ctx.lr = 0x823FD3FC;
	sub_823FF190(ctx, base);
	// 823FD3FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FD400: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 823FD404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FD408: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FD40C: 4BFFFBE5  bl 0x823fcff0
	ctx.lr = 0x823FD410;
	sub_823FCFF0(ctx, base);
	// 823FD410: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD414: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FD418: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD41C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD420: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FD424: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FD428: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD42C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FD430: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD434: C00A9030  lfs f0, -0x6fd0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD438: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD43C: 4099005C  ble cr6, 0x823fd498
	if !ctx.cr[6].gt {
	pc = 0x823FD498; continue 'dispatch;
	}
	// 823FD440: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 823FD444: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x823FD448; continue 'dispatch;
            }
            0x823FD448 => {
    //   block [0x823FD448..0x823FD484)
	// 823FD448: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD44C: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FD450: 40980034  bge cr6, 0x823fd484
	if !ctx.cr[6].lt {
	pc = 0x823FD484; continue 'dispatch;
	}
	// 823FD454: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FD458: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 823FD45C: 7D89E42E  lfsx f12, r9, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FD460: 7D692C2E  lfsx f11, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FD464: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FD468: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 823FD46C: 41980018  blt cr6, 0x823fd484
	if ctx.cr[6].lt {
	pc = 0x823FD484; continue 'dispatch;
	}
	// 823FD470: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 823FD474: 40990010  ble cr6, 0x823fd484
	if !ctx.cr[6].gt {
	pc = 0x823FD484; continue 'dispatch;
	}
	// 823FD478: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FD47C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FD480: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	pc = 0x823FD484; continue 'dispatch;
            }
            0x823FD484 => {
    //   block [0x823FD484..0x823FD498)
	// 823FD484: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD488: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FD48C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FD490: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FD494: 4198FFB4  blt cr6, 0x823fd448
	if ctx.cr[6].lt {
	pc = 0x823FD448; continue 'dispatch;
	}
	pc = 0x823FD498; continue 'dispatch;
            }
            0x823FD498 => {
    //   block [0x823FD498..0x823FD4D4)
	// 823FD498: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD49C: 390B0002  addi r8, r11, 2
	ctx.r[8].s64 = ctx.r[11].s64 + 2;
	// 823FD4A0: 38EB0003  addi r7, r11, 3
	ctx.r[7].s64 = ctx.r[11].s64 + 3;
	// 823FD4A4: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 823FD4A8: 39407FFF  li r10, 0x7fff
	ctx.r[10].s64 = 32767;
	// 823FD4AC: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD4B0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FD4B4: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FD4B8: 7D48D92E  stwx r10, r8, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u32) };
	// 823FD4BC: 7D47D92E  stwx r10, r7, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u32) };
	// 823FD4C0: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FD4C4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD4C8: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 823FD4CC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 823FD4D0: 48137C34  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD4D8 size=532
    let mut pc: u32 = 0x823FD4D8;
    'dispatch: loop {
        match pc {
            0x823FD4D8 => {
    //   block [0x823FD4D8..0x823FD55C)
	// 823FD4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD4DC: 48137BD9  bl 0x825350b4
	ctx.lr = 0x823FD4E0;
	sub_82535080(ctx, base);
	// 823FD4E0: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD4E4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FD4E8: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 823FD4EC: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 823FD4F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FD4F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823FD4F8: 48000751  bl 0x823fdc48
	ctx.lr = 0x823FD4FC;
	sub_823FDC48(ctx, base);
	// 823FD4FC: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 823FD500: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 823FD504: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 823FD508: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD50C: 4800079D  bl 0x823fdca8
	ctx.lr = 0x823FD510;
	sub_823FDCA8(ctx, base);
	// 823FD510: 38800056  li r4, 0x56
	ctx.r[4].s64 = 86;
	// 823FD514: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD518: 4BFFFA51  bl 0x823fcf68
	ctx.lr = 0x823FD51C;
	sub_823FCF68(ctx, base);
	// 823FD51C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FD520: 38C10078  addi r6, r1, 0x78
	ctx.r[6].s64 = ctx.r[1].s64 + 120;
	// 823FD524: C0210064  lfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD528: 38A10210  addi r5, r1, 0x210
	ctx.r[5].s64 = ctx.r[1].s64 + 528;
	// 823FD52C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD530: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FD534: 4BFFFDF5  bl 0x823fd328
	ctx.lr = 0x823FD538;
	sub_823FD328(ctx, base);
	// 823FD538: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD53C: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD540: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD544: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FD548: 40990014  ble cr6, 0x823fd55c
	if !ctx.cr[6].gt {
	pc = 0x823FD55C; continue 'dispatch;
	}
	// 823FD54C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FD550: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD554: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FD558: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x823FD55C; continue 'dispatch;
            }
            0x823FD55C => {
    //   block [0x823FD55C..0x823FD574)
	// 823FD55C: 357EFFFF  addic. r11, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD560: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823FD564: 41800038  blt 0x823fd59c
	if ctx.cr[0].lt {
	pc = 0x823FD59C; continue 'dispatch;
	}
	// 823FD568: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD56C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 823FD570: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x823FD574; continue 'dispatch;
            }
            0x823FD574 => {
    //   block [0x823FD574..0x823FD59C)
	// 823FD574: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD578: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD57C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD580: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 823FD584: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 823FD588: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 823FD58C: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD590: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FD594: 4080FFE0  bge 0x823fd574
	if !ctx.cr[0].lt {
	pc = 0x823FD574; continue 'dispatch;
	}
	// 823FD598: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x823FD59C; continue 'dispatch;
            }
            0x823FD59C => {
    //   block [0x823FD59C..0x823FD5F4)
	// 823FD59C: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 823FD5A0: C05B0004  lfs f2, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FD5A4: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 823FD5A8: C03B0000  lfs f1, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD5AC: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 823FD5B0: 80C10078  lwz r6, 0x78(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 823FD5B4: 38A10210  addi r5, r1, 0x210
	ctx.r[5].s64 = ctx.r[1].s64 + 528;
	// 823FD5B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FD5BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 823FD5C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 823FD5C4: 48003365  bl 0x82400928
	ctx.lr = 0x823FD5C8;
	sub_82400928(ctx, base);
	// 823FD5C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD5CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FD5D0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD5D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FD5D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 823FD5DC: C02BFFFC  lfs f1, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD5E0: 48003099  bl 0x82400678
	ctx.lr = 0x823FD5E4;
	sub_82400678(ctx, base);
	// 823FD5E4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 823FD5E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FD5EC: 7FEBFB79  or. r11, r31, r31
	ctx.r[11].u64 = ctx.r[31].u64 | ctx.r[31].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD5F0: 48000034  b 0x823fd624
	pc = 0x823FD624; continue 'dispatch;
            }
            0x823FD5F4 => {
    //   block [0x823FD5F4..0x823FD624)
	// 823FD5F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD5F8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FD5FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FD600: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 823FD604: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FD608: 7C2B542E  lfsx f1, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD60C: 48002E7D  bl 0x82400488
	ctx.lr = 0x823FD610;
	sub_82400488(ctx, base);
	// 823FD610: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 823FD614: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 823FD618: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FD61C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD620: 7C2A4D2E  stfsx f1, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	pc = 0x823FD624; continue 'dispatch;
            }
            0x823FD624 => {
    //   block [0x823FD624..0x823FD66C)
	// 823FD624: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 823FD628: 4080FFCC  bge 0x823fd5f4
	if !ctx.cr[0].lt {
	pc = 0x823FD5F4; continue 'dispatch;
	}
	// 823FD62C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 823FD630: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FD634: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 823FD638: 40980064  bge cr6, 0x823fd69c
	if !ctx.cr[6].lt {
	pc = 0x823FD69C; continue 'dispatch;
	}
	// 823FD63C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FD640: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD644: 394A8F94  addi r10, r10, -0x706c
	ctx.r[10].s64 = ctx.r[10].s64 + -28780;
	// 823FD648: 419A0024  beq cr6, 0x823fd66c
	if ctx.cr[6].eq {
	pc = 0x823FD66C; continue 'dispatch;
	}
	// 823FD64C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD650: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FD654: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD658: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 823FD65C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD660: 7DA83C2E  lfsx f13, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD664: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FD668: 41980060  blt cr6, 0x823fd6c8
	if ctx.cr[6].lt {
	pc = 0x823FD6C8; continue 'dispatch;
	}
	pc = 0x823FD66C; continue 'dispatch;
            }
            0x823FD66C => {
    //   block [0x823FD66C..0x823FD69C)
	// 823FD66C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FD670: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD674: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 823FD678: 57E7103A  slwi r7, r31, 2
	ctx.r[7].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FD67C: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 823FD680: 7DA9442E  lfsx f13, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD684: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD688: 7DA7342E  lfsx f13, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD68C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FD690: 40980034  bge cr6, 0x823fd6c4
	if !ctx.cr[6].lt {
	pc = 0x823FD6C4; continue 'dispatch;
	}
	// 823FD694: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FD698: 48000030  b 0x823fd6c8
	pc = 0x823FD6C8; continue 'dispatch;
            }
            0x823FD69C => {
    //   block [0x823FD69C..0x823FD6C4)
	// 823FD69C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FD6A0: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD6A4: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 823FD6A8: 396B8F94  addi r11, r11, -0x706c
	ctx.r[11].s64 = ctx.r[11].s64 + -28780;
	// 823FD6AC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD6B0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD6B4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FD6B8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FD6BC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FD6C0: 41980008  blt cr6, 0x823fd6c8
	if ctx.cr[6].lt {
	pc = 0x823FD6C8; continue 'dispatch;
	}
	pc = 0x823FD6C4; continue 'dispatch;
            }
            0x823FD6C4 => {
    //   block [0x823FD6C4..0x823FD6C8)
	// 823FD6C4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x823FD6C8; continue 'dispatch;
            }
            0x823FD6C8 => {
    //   block [0x823FD6C8..0x823FD6EC)
	// 823FD6C8: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD6CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 823FD6D0: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 823FD6D4: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FD6D8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD6DC: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FD6E0: D03B0000  stfs f1, 0(r27)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD6E4: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 823FD6E8: 48137A1C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x823FD6F0 size=24
    let mut pc: u32 = 0x823FD6F0;
    'dispatch: loop {
        match pc {
            0x823FD6F0 => {
    //   block [0x823FD6F0..0x823FD708)
	// 823FD6F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FD6F4: 3940004A  li r10, 0x4a
	ctx.r[10].s64 = 74;
	// 823FD6F8: 396B8E38  addi r11, r11, -0x71c8
	ctx.r[11].s64 = ctx.r[11].s64 + -29128;
	// 823FD6FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD700: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 823FD704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FD708 size=116
    let mut pc: u32 = 0x823FD708;
    'dispatch: loop {
        match pc {
            0x823FD708 => {
    //   block [0x823FD708..0x823FD748)
	// 823FD708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD714: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD718: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FD71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD720: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 823FD724: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD728: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FD72C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD730: 4E800421  bctrl
	ctx.lr = 0x823FD734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FD738: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FD73C: 4082000C  bne 0x823fd748
	if !ctx.cr[0].eq {
	pc = 0x823FD748; continue 'dispatch;
	}
	// 823FD740: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD744: 48000024  b 0x823fd768
	pc = 0x823FD768; continue 'dispatch;
            }
            0x823FD748 => {
    //   block [0x823FD748..0x823FD768)
	// 823FD748: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD74C: C00B2094  lfs f0, 0x2094(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD750: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FD754: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FD758: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD75C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FD760: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FD764: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x823FD768; continue 'dispatch;
            }
            0x823FD768 => {
    //   block [0x823FD768..0x823FD77C)
	// 823FD768: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FD76C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD780 size=80
    let mut pc: u32 = 0x823FD780;
    'dispatch: loop {
        match pc {
            0x823FD780 => {
    //   block [0x823FD780..0x823FD7B8)
	// 823FD780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD78C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD794: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD798: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FD79C: 4182001C  beq 0x823fd7b8
	if ctx.cr[0].eq {
	pc = 0x823FD7B8; continue 'dispatch;
	}
	// 823FD7A0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FD7A4: 816B37AC  lwz r11, 0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FD7A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD7AC: 4E800421  bctrl
	ctx.lr = 0x823FD7B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD7B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FD7B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x823FD7B8 => {
    //   block [0x823FD7B8..0x823FD7D0)
	// 823FD7B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FD7BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FD7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD7C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD7D0 size=112
    let mut pc: u32 = 0x823FD7D0;
    'dispatch: loop {
        match pc {
            0x823FD7D0 => {
    //   block [0x823FD7D0..0x823FD814)
	// 823FD7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FD7D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FD7DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FD7E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD7E4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FD7E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FD7EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FD7F0: 388005D4  li r4, 0x5d4
	ctx.r[4].s64 = 1492;
	// 823FD7F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD7F8: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FD7FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD800: 4E800421  bctrl
	ctx.lr = 0x823FD804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD804: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FD808: 4082000C  bne 0x823fd814
	if !ctx.cr[0].eq {
	pc = 0x823FD814; continue 'dispatch;
	}
	// 823FD80C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FD810: 48000018  b 0x823fd828
	pc = 0x823FD828; continue 'dispatch;
            }
            0x823FD814 => {
    //   block [0x823FD814..0x823FD828)
	// 823FD814: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FD818: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FD81C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FD820: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 823FD824: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x823FD828; continue 'dispatch;
            }
            0x823FD828 => {
    //   block [0x823FD828..0x823FD840)
	// 823FD828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FD82C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FD830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FD834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FD838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FD83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD840 size=284
    let mut pc: u32 = 0x823FD840;
    'dispatch: loop {
        match pc {
            0x823FD840 => {
    //   block [0x823FD840..0x823FD8D4)
	// 823FD840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD844: 48137861  bl 0x825350a4
	ctx.lr = 0x823FD848;
	sub_82535080(ctx, base);
	// 823FD848: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD84C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FD850: 548B083E  rotlwi r11, r4, 1
	ctx.r[11].u64 = ((ctx.r[4].u32).rotate_left(1)) as u64;
	// 823FD854: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FD858: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823FD85C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 823FD860: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD864: 3B5D0008  addi r26, r29, 8
	ctx.r[26].s64 = ctx.r[29].s64 + 8;
	// 823FD868: 82FD0004  lwz r23, 4(r29)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FD86C: 7D44FBD6  divw r10, r4, r31
	ctx.r[10].s32 = ctx.r[4].s32 / ctx.r[31].s32;
	// 823FD870: 7FE95878  andc r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 & !ctx.r[11].u64;
	// 823FD874: 7D6AF9D6  mullw r11, r10, r31
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FD878: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 823FD87C: 0CA9FFFF  twi 5, r9, -1
	// 823FD880: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 823FD884: 0CDF0000  twi 6, r31, 0
	// 823FD888: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823FD88C: 0CDF0000  twi 6, r31, 0
	// 823FD890: 7D2BFBD6  divw r9, r11, r31
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[31].s32;
	// 823FD894: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 823FD898: 7D29F9D6  mullw r9, r9, r31
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 823FD89C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 823FD8A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FD8A4: 7F8BF850  subf r28, r11, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 823FD8A8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD8AC: 7FEA5078  andc r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 & !ctx.r[10].u64;
	// 823FD8B0: 7F1CF000  cmpw cr6, r28, r30
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FD8B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FD8B8: 0CAAFFFF  twi 5, r10, -1
	// 823FD8BC: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 823FD8C0: 41980014  blt cr6, 0x823fd8d4
	if ctx.cr[6].lt {
	pc = 0x823FD8D4; continue 'dispatch;
	}
	// 823FD8C4: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FD8C8: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FD8CC: 816A37B4  lwz r11, 0x37b4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD8D0: 48000030  b 0x823fd900
	pc = 0x823FD900; continue 'dispatch;
            }
            0x823FD8D4 => {
    //   block [0x823FD8D4..0x823FD900)
	// 823FD8D4: 3F008288  lis r24, -0x7d78
	ctx.r[24].s64 = -2105016320;
	// 823FD8D8: 5799103A  slwi r25, r28, 2
	ctx.r[25].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 823FD8DC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 823FD8E0: 817837B4  lwz r11, 0x37b4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD8E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD8E8: 4E800421  bctrl
	ctx.lr = 0x823FD8EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD8EC: 7D7CF050  subf r11, r28, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 823FD8F0: 7C99DA14  add r4, r25, r27
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[27].u64;
	// 823FD8F4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FD8F8: 817837B4  lwz r11, 0x37b4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD8FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
            }
            0x823FD900 => {
    //   block [0x823FD900..0x823FD95C)
	// 823FD900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FD904: 4E800421  bctrl
	ctx.lr = 0x823FD908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FD908: 7D7EFBD6  divw r11, r30, r31
	ctx.r[11].s32 = ctx.r[30].s32 / ctx.r[31].s32;
	// 823FD90C: 57CA083E  rotlwi r10, r30, 1
	ctx.r[10].u64 = ((ctx.r[30].u32).rotate_left(1)) as u64;
	// 823FD910: 7D6BF9D6  mullw r11, r11, r31
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FD914: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 823FD918: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FD91C: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 823FD920: 7FEA5078  andc r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 & !ctx.r[10].u64;
	// 823FD924: 7D2BFA14  add r9, r11, r31
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823FD928: 0CAAFFFF  twi 5, r10, -1
	// 823FD92C: 7D49FBD6  divw r10, r9, r31
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[31].s32;
	// 823FD930: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 823FD934: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823FD938: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823FD93C: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 823FD940: 7FEB5878  andc r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 & !ctx.r[11].u64;
	// 823FD944: 0CDF0000  twi 6, r31, 0
	// 823FD948: 0CDF0000  twi 6, r31, 0
	// 823FD94C: 0CABFFFF  twi 5, r11, -1
	// 823FD950: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 823FD954: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823FD958: 4813779C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FD960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FD960 size=220
    let mut pc: u32 = 0x823FD960;
    'dispatch: loop {
        match pc {
            0x823FD960 => {
    //   block [0x823FD960..0x823FDA00)
	// 823FD960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FD964: 4813774D  bl 0x825350b0
	ctx.lr = 0x823FD968;
	sub_82535080(ctx, base);
	// 823FD968: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FD96C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 823FD970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FD974: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 823FD978: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FD97C: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 823FD980: 0CCB0000  twi 6, r11, 0
	// 823FD984: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 823FD988: 0CCB0000  twi 6, r11, 0
	// 823FD98C: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 823FD990: 3B830008  addi r28, r3, 8
	ctx.r[28].s64 = ctx.r[3].s64 + 8;
	// 823FD994: 7D0A00D0  neg r8, r10
	ctx.r[8].s64 = -ctx.r[10].s64;
	// 823FD998: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 823FD99C: 550A083E  rotlwi r10, r8, 1
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 823FD9A0: 7CE85BD6  divw r7, r8, r11
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	// 823FD9A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 823FD9A8: 7D665078  andc r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 823FD9AC: 7D4759D6  mullw r10, r7, r11
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 823FD9B0: 7D4A4050  subf r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 823FD9B4: 0CA6FFFF  twi 5, r6, -1
	// 823FD9B8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FD9BC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FD9C0: 7D0A5BD6  divw r8, r10, r11
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	// 823FD9C4: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 823FD9C8: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 823FD9CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 823FD9D0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 823FD9D4: 7FCA5850  subf r30, r10, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 823FD9D8: 7D694878  andc r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 & !ctx.r[9].u64;
	// 823FD9DC: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FD9E0: 7F1EF800  cmpw cr6, r30, r31
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[31].s32, &mut ctx.xer);
	// 823FD9E4: 0CA9FFFF  twi 5, r9, -1
	// 823FD9E8: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 823FD9EC: 41980014  blt cr6, 0x823fda00
	if ctx.cr[6].lt {
	pc = 0x823FDA00; continue 'dispatch;
	}
	// 823FD9F0: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 823FD9F4: 57E5103A  slwi r5, r31, 2
	ctx.r[5].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FD9F8: 816937B4  lwz r11, 0x37b4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FD9FC: 48000030  b 0x823fda2c
	pc = 0x823FDA2C; continue 'dispatch;
            }
            0x823FDA00 => {
    //   block [0x823FDA00..0x823FDA2C)
	// 823FDA00: 3F408288  lis r26, -0x7d78
	ctx.r[26].s64 = -2105016320;
	// 823FDA04: 57DB103A  slwi r27, r30, 2
	ctx.r[27].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 823FDA08: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 823FDA0C: 817A37B4  lwz r11, 0x37b4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FDA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FDA14: 4E800421  bctrl
	ctx.lr = 0x823FDA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FDA18: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 823FDA1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FDA20: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 823FDA24: 817A37B4  lwz r11, 0x37b4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(14260 as u32) ) } as u64;
	// 823FDA28: 7C7BEA14  add r3, r27, r29
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[29].u64;
            }
            0x823FDA2C => {
    //   block [0x823FDA2C..0x823FDA3C)
	// 823FDA2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FDA30: 4E800421  bctrl
	ctx.lr = 0x823FDA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FDA34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FDA38: 481376C8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDA40 size=60
    let mut pc: u32 = 0x823FDA40;
    'dispatch: loop {
        match pc {
            0x823FDA40 => {
    //   block [0x823FDA40..0x823FDA7C)
	// 823FDA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDA44: 48137679  bl 0x825350bc
	ctx.lr = 0x823FDA48;
	sub_82535080(ctx, base);
	// 823FDA48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDA4C: 7CAB0E70  srawi r11, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FDA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FDA54: 7FAB0194  addze r29, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[29].s64 = tmp.s64;
	// 823FDA58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FDA5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDA60: 480034E1  bl 0x82400f40
	ctx.lr = 0x823FDA64;
	sub_82400F40(ctx, base);
	// 823FDA64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDA68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FDA6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FDA70: 48003289  bl 0x82400cf8
	ctx.lr = 0x823FDA74;
	sub_82400CF8(ctx, base);
	// 823FDA74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FDA78: 48137694  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDA80 size=60
    let mut pc: u32 = 0x823FDA80;
    'dispatch: loop {
        match pc {
            0x823FDA80 => {
    //   block [0x823FDA80..0x823FDABC)
	// 823FDA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDA84: 48137639  bl 0x825350bc
	ctx.lr = 0x823FDA88;
	sub_82535080(ctx, base);
	// 823FDA88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDA8C: 7CAB0E70  srawi r11, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FDA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FDA94: 7FAB0194  addze r29, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[29].s64 = tmp.s64;
	// 823FDA98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FDA9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDAA0: 48003379  bl 0x82400e18
	ctx.lr = 0x823FDAA4;
	sub_82400E18(ctx, base);
	// 823FDAA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FDAA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FDAAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FDAB0: 48003491  bl 0x82400f40
	ctx.lr = 0x823FDAB4;
	sub_82400F40(ctx, base);
	// 823FDAB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FDAB8: 48137654  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDAC0 size=340
    let mut pc: u32 = 0x823FDAC0;
    'dispatch: loop {
        match pc {
            0x823FDAC0 => {
    //   block [0x823FDAC0..0x823FDB00)
	// 823FDAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDAC4: 481375F9  bl 0x825350bc
	ctx.lr = 0x823FDAC8;
	sub_82535080(ctx, base);
	// 823FDAC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDACC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823FDAD0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 823FDAD4: 7C830E70  srawi r3, r4, 1
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 1) as i64;
	// 823FDAD8: 7C8B1671  srawi. r11, r4, 2
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDADC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 823FDAE0: 20CB0100  subfic r6, r11, 0x100
	ctx.xer.ca = ctx.r[11].u32 <= 256 as u32;
	ctx.r[6].s64 = (256 as i64) - ctx.r[11].s64;
	// 823FDAE4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 823FDAE8: 7D452830  slw r5, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823FDAEC: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FDAF0: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 823FDAF4: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 823FDAF8: 40810030  ble 0x823fdb28
	if !ctx.cr[0].gt {
	pc = 0x823FDB28; continue 'dispatch;
	}
	// 823FDAFC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	pc = 0x823FDB00; continue 'dispatch;
            }
            0x823FDB00 => {
    //   block [0x823FDB00..0x823FDB28)
	// 823FDB00: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB04: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB08: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB0C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FDB10: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDB14: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB1C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB20: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDB24: 4082FFDC  bne 0x823fdb00
	if !ctx.cr[0].eq {
	pc = 0x823FDB00; continue 'dispatch;
	}
	pc = 0x823FDB28; continue 'dispatch;
            }
            0x823FDB28 => {
    //   block [0x823FDB28..0x823FDB48)
	// 823FDB28: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FDB2C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FDB30: 7D0B2050  subf r8, r11, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 823FDB34: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FDB38: 7D070E71  srawi. r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FDB3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 823FDB40: 40810030  ble 0x823fdb70
	if !ctx.cr[0].gt {
	pc = 0x823FDB70; continue 'dispatch;
	}
	// 823FDB44: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	pc = 0x823FDB48; continue 'dispatch;
            }
            0x823FDB48 => {
    //   block [0x823FDB48..0x823FDB70)
	// 823FDB48: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB4C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB50: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB54: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FDB58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDB5C: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FDB64: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDB6C: 4082FFDC  bne 0x823fdb48
	if !ctx.cr[0].eq {
	pc = 0x823FDB48; continue 'dispatch;
	}
	pc = 0x823FDB70; continue 'dispatch;
            }
            0x823FDB70 => {
    //   block [0x823FDB70..0x823FDB9C)
	// 823FDB70: 5467083C  slwi r7, r3, 1
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FDB74: 7F043800  cmpw cr6, r4, r7
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FDB78: 419A0024  beq cr6, 0x823fdb9c
	if ctx.cr[6].eq {
	pc = 0x823FDB9C; continue 'dispatch;
	}
	// 823FDB7C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDB80: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FDB84: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB88: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FDB8C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDB90: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDB94: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDB98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x823FDB9C; continue 'dispatch;
            }
            0x823FDB9C => {
    //   block [0x823FDB9C..0x823FDBBC)
	// 823FDB9C: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FDBA0: 40980044  bge cr6, 0x823fdbe4
	if !ctx.cr[6].lt {
	pc = 0x823FDBE4; continue 'dispatch;
	}
	// 823FDBA4: 7D283050  subf r9, r8, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 823FDBA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FDBAC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDBB0: 5528F0BF  rlwinm. r8, r9, 0x1e, 2, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FDBB4: 41820014  beq 0x823fdbc8
	if ctx.cr[0].eq {
	pc = 0x823FDBC8; continue 'dispatch;
	}
	// 823FDBB8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x823FDBBC; continue 'dispatch;
            }
            0x823FDBBC => {
    //   block [0x823FDBBC..0x823FDBC8)
	// 823FDBBC: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 823FDBC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDBC4: 4200FFF8  bdnz 0x823fdbbc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FDBBC; continue 'dispatch;
	}
	pc = 0x823FDBC8; continue 'dispatch;
            }
            0x823FDBC8 => {
    //   block [0x823FDBC8..0x823FDBD8)
	// 823FDBC8: 552BF0BF  rlwinm. r11, r9, 0x1e, 2, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDBCC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FDBD0: 41820014  beq 0x823fdbe4
	if ctx.cr[0].eq {
	pc = 0x823FDBE4; continue 'dispatch;
	}
	// 823FDBD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x823FDBD8; continue 'dispatch;
            }
            0x823FDBD8 => {
    //   block [0x823FDBD8..0x823FDBE4)
	// 823FDBD8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FDBDC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDBE0: 4200FFF8  bdnz 0x823fdbd8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x823FDBD8; continue 'dispatch;
	}
	pc = 0x823FDBE4; continue 'dispatch;
            }
            0x823FDBE4 => {
    //   block [0x823FDBE4..0x823FDC14)
	// 823FDBE4: 7CAB0E70  srawi r11, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 823FDBE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FDBEC: 7FEB0194  addze r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	// 823FDBF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FDBF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FDBF8: 48003349  bl 0x82400f40
	ctx.lr = 0x823FDBFC;
	sub_82400F40(ctx, base);
	// 823FDBFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FDC00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FDC04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FDC08: 480030F1  bl 0x82400cf8
	ctx.lr = 0x823FDC0C;
	sub_82400CF8(ctx, base);
	// 823FDC0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FDC10: 481374FC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC18 size=48
    let mut pc: u32 = 0x823FDC18;
    'dispatch: loop {
        match pc {
            0x823FDC18 => {
    //   block [0x823FDC18..0x823FDC28)
	// 823FDC18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FDC1C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC20: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FDC24: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x823FDC28; continue 'dispatch;
            }
            0x823FDC28 => {
    //   block [0x823FDC28..0x823FDC48)
	// 823FDC28: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDC2C: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC30: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDC34: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FDC38: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 823FDC3C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823FDC40: 4181FFE8  bgt 0x823fdc28
	if ctx.cr[0].gt {
	pc = 0x823FDC28; continue 'dispatch;
	}
	// 823FDC44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC48 size=52
    let mut pc: u32 = 0x823FDC48;
    'dispatch: loop {
        match pc {
            0x823FDC48 => {
    //   block [0x823FDC48..0x823FDC50)
	// 823FDC48: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC4C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x823FDC50; continue 'dispatch;
            }
            0x823FDC50 => {
    //   block [0x823FDC50..0x823FDC7C)
	// 823FDC50: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDC54: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FDC58: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FDC5C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDC60: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823FDC64: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FDC68: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FDC6C: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDC70: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FDC74: 4181FFDC  bgt 0x823fdc50
	if ctx.cr[0].gt {
	pc = 0x823FDC50; continue 'dispatch;
	}
	// 823FDC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDC80 size=40
    let mut pc: u32 = 0x823FDC80;
    'dispatch: loop {
        match pc {
            0x823FDC80 => {
    //   block [0x823FDC80..0x823FDC88)
	// 823FDC80: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FDC84: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x823FDC88; continue 'dispatch;
            }
            0x823FDC88 => {
    //   block [0x823FDC88..0x823FDCA8)
	// 823FDC88: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDC8C: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FDC90: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FDC94: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDC98: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FDC9C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FDCA0: 4181FFE8  bgt 0x823fdc88
	if ctx.cr[0].gt {
	pc = 0x823FDC88; continue 'dispatch;
	}
	// 823FDCA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FDCA8 size=520
    let mut pc: u32 = 0x823FDCA8;
    'dispatch: loop {
        match pc {
            0x823FDCA8 => {
    //   block [0x823FDCA8..0x823FDCD4)
	// 823FDCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDCAC: 48137411  bl 0x825350bc
	ctx.lr = 0x823FDCB0;
	sub_82535080(ctx, base);
	// 823FDCB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDCB4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FDCB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823FDCBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823FDCC0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 823FDCC4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FDCC8: 40800108  bge 0x823fddd0
	if !ctx.cr[0].lt {
	pc = 0x823FDDD0; continue 'dispatch;
	}
	// 823FDCCC: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 823FDCD0: 38E3000C  addi r7, r3, 0xc
	ctx.r[7].s64 = ctx.r[3].s64 + 12;
	pc = 0x823FDCD4; continue 'dispatch;
            }
            0x823FDCD4 => {
    //   block [0x823FDCD4..0x823FDCF4)
	// 823FDCD4: 39280003  addi r9, r8, 3
	ctx.r[9].s64 = ctx.r[8].s64 + 3;
	// 823FDCD8: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDCDC: 419900A8  bgt cr6, 0x823fdd84
	if ctx.cr[6].gt {
	pc = 0x823FDD84; continue 'dispatch;
	}
	// 823FDCE0: 8127FFF8  lwz r9, -8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FDCE4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDCE8: 4099000C  ble cr6, 0x823fdcf4
	if !ctx.cr[6].gt {
	pc = 0x823FDCF4; continue 'dispatch;
	}
	// 823FDCEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDCF0: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x823FDCF4; continue 'dispatch;
            }
            0x823FDCF4 => {
    //   block [0x823FDCF4..0x823FDD04)
	// 823FDCF4: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDCF8: 4098000C  bge cr6, 0x823fdd04
	if !ctx.cr[6].lt {
	pc = 0x823FDD04; continue 'dispatch;
	}
	// 823FDCFC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD00: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	pc = 0x823FDD04; continue 'dispatch;
            }
            0x823FDD04 => {
    //   block [0x823FDD04..0x823FDD18)
	// 823FDD04: 8127FFFC  lwz r9, -4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823FDD08: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDD0C: 4099000C  ble cr6, 0x823fdd18
	if !ctx.cr[6].gt {
	pc = 0x823FDD18; continue 'dispatch;
	}
	// 823FDD10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDD14: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	pc = 0x823FDD18; continue 'dispatch;
            }
            0x823FDD18 => {
    //   block [0x823FDD18..0x823FDD28)
	// 823FDD18: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDD1C: 4098000C  bge cr6, 0x823fdd28
	if !ctx.cr[6].lt {
	pc = 0x823FDD28; continue 'dispatch;
	}
	// 823FDD20: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD24: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x823FDD28; continue 'dispatch;
            }
            0x823FDD28 => {
    //   block [0x823FDD28..0x823FDD3C)
	// 823FDD28: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDD2C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDD30: 4099000C  ble cr6, 0x823fdd3c
	if !ctx.cr[6].gt {
	pc = 0x823FDD3C; continue 'dispatch;
	}
	// 823FDD34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDD38: 3BE80001  addi r31, r8, 1
	ctx.r[31].s64 = ctx.r[8].s64 + 1;
	pc = 0x823FDD3C; continue 'dispatch;
            }
            0x823FDD3C => {
    //   block [0x823FDD3C..0x823FDD4C)
	// 823FDD3C: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDD40: 4098000C  bge cr6, 0x823fdd4c
	if !ctx.cr[6].lt {
	pc = 0x823FDD4C; continue 'dispatch;
	}
	// 823FDD44: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD48: 3BA80001  addi r29, r8, 1
	ctx.r[29].s64 = ctx.r[8].s64 + 1;
	pc = 0x823FDD4C; continue 'dispatch;
            }
            0x823FDD4C => {
    //   block [0x823FDD4C..0x823FDD60)
	// 823FDD4C: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FDD50: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDD54: 4099000C  ble cr6, 0x823fdd60
	if !ctx.cr[6].gt {
	pc = 0x823FDD60; continue 'dispatch;
	}
	// 823FDD58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDD5C: 3BE80002  addi r31, r8, 2
	ctx.r[31].s64 = ctx.r[8].s64 + 2;
	pc = 0x823FDD60; continue 'dispatch;
            }
            0x823FDD60 => {
    //   block [0x823FDD60..0x823FDD70)
	// 823FDD60: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDD64: 4098000C  bge cr6, 0x823fdd70
	if !ctx.cr[6].lt {
	pc = 0x823FDD70; continue 'dispatch;
	}
	// 823FDD68: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDD6C: 3BA80002  addi r29, r8, 2
	ctx.r[29].s64 = ctx.r[8].s64 + 2;
	pc = 0x823FDD70; continue 'dispatch;
            }
            0x823FDD70 => {
    //   block [0x823FDD70..0x823FDD84)
	// 823FDD70: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FDD74: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 823FDD78: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDD7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDD80: 4198FF54  blt cr6, 0x823fdcd4
	if ctx.cr[6].lt {
	pc = 0x823FDCD4; continue 'dispatch;
	}
	pc = 0x823FDD84; continue 'dispatch;
            }
            0x823FDD84 => {
    //   block [0x823FDD84..0x823FDD94)
	// 823FDD84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDD88: 40980048  bge cr6, 0x823fddd0
	if !ctx.cr[6].lt {
	pc = 0x823FDDD0; continue 'dispatch;
	}
	// 823FDD8C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDD90: 7D091A14  add r8, r9, r3
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	pc = 0x823FDD94; continue 'dispatch;
            }
            0x823FDD94 => {
    //   block [0x823FDD94..0x823FDDB0)
	// 823FDD94: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDD98: 40980038  bge cr6, 0x823fddd0
	if !ctx.cr[6].lt {
	pc = 0x823FDDD0; continue 'dispatch;
	}
	// 823FDD9C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDDA0: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDDA4: 4099000C  ble cr6, 0x823fddb0
	if !ctx.cr[6].gt {
	pc = 0x823FDDB0; continue 'dispatch;
	}
	// 823FDDA8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDDAC: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x823FDDB0; continue 'dispatch;
            }
            0x823FDDB0 => {
    //   block [0x823FDDB0..0x823FDDC0)
	// 823FDDB0: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FDDB4: 4098000C  bge cr6, 0x823fddc0
	if !ctx.cr[6].lt {
	pc = 0x823FDDC0; continue 'dispatch;
	}
	// 823FDDB8: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 823FDDBC: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	pc = 0x823FDDC0; continue 'dispatch;
            }
            0x823FDDC0 => {
    //   block [0x823FDDC0..0x823FDDD0)
	// 823FDDC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FDDC4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDDC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDDCC: 4198FFC8  blt cr6, 0x823fdd94
	if ctx.cr[6].lt {
	pc = 0x823FDD94; continue 'dispatch;
	}
	pc = 0x823FDDD0; continue 'dispatch;
            }
            0x823FDDD0 => {
    //   block [0x823FDDD0..0x823FDDE8)
	// 823FDDD0: 38EA0004  addi r7, r10, 4
	ctx.r[7].s64 = ctx.r[10].s64 + 4;
	// 823FDDD4: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDDD8: 41990074  bgt cr6, 0x823fde4c
	if ctx.cr[6].gt {
	pc = 0x823FDE4C; continue 'dispatch;
	}
	// 823FDDDC: 392A0002  addi r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 2;
	// 823FDDE0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDDE4: 7D091A14  add r8, r9, r3
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	pc = 0x823FDDE8; continue 'dispatch;
            }
            0x823FDDE8 => {
    //   block [0x823FDDE8..0x823FDDFC)
	// 823FDDE8: 8128FFF8  lwz r9, -8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FDDEC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDDF0: 4099000C  ble cr6, 0x823fddfc
	if !ctx.cr[6].gt {
	pc = 0x823FDDFC; continue 'dispatch;
	}
	// 823FDDF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDDF8: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x823FDDFC; continue 'dispatch;
            }
            0x823FDDFC => {
    //   block [0x823FDDFC..0x823FDE10)
	// 823FDDFC: 8128FFFC  lwz r9, -4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) } as u64;
	// 823FDE00: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE04: 4099000C  ble cr6, 0x823fde10
	if !ctx.cr[6].gt {
	pc = 0x823FDE10; continue 'dispatch;
	}
	// 823FDE08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE0C: 3BEA0001  addi r31, r10, 1
	ctx.r[31].s64 = ctx.r[10].s64 + 1;
	pc = 0x823FDE10; continue 'dispatch;
            }
            0x823FDE10 => {
    //   block [0x823FDE10..0x823FDE24)
	// 823FDE10: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDE14: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE18: 4099000C  ble cr6, 0x823fde24
	if !ctx.cr[6].gt {
	pc = 0x823FDE24; continue 'dispatch;
	}
	// 823FDE1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE20: 3BEA0002  addi r31, r10, 2
	ctx.r[31].s64 = ctx.r[10].s64 + 2;
	pc = 0x823FDE24; continue 'dispatch;
            }
            0x823FDE24 => {
    //   block [0x823FDE24..0x823FDE38)
	// 823FDE24: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FDE28: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE2C: 4099000C  ble cr6, 0x823fde38
	if !ctx.cr[6].gt {
	pc = 0x823FDE38; continue 'dispatch;
	}
	// 823FDE30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE34: 3BEA0003  addi r31, r10, 3
	ctx.r[31].s64 = ctx.r[10].s64 + 3;
	pc = 0x823FDE38; continue 'dispatch;
            }
            0x823FDE38 => {
    //   block [0x823FDE38..0x823FDE4C)
	// 823FDE38: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 823FDE3C: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 823FDE40: 38EA0004  addi r7, r10, 4
	ctx.r[7].s64 = ctx.r[10].s64 + 4;
	// 823FDE44: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDE48: 4099FFA0  ble cr6, 0x823fdde8
	if !ctx.cr[6].gt {
	pc = 0x823FDDE8; continue 'dispatch;
	}
	pc = 0x823FDE4C; continue 'dispatch;
            }
            0x823FDE4C => {
    //   block [0x823FDE4C..0x823FDE5C)
	// 823FDE4C: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDE50: 40980030  bge cr6, 0x823fde80
	if !ctx.cr[6].lt {
	pc = 0x823FDE80; continue 'dispatch;
	}
	// 823FDE54: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FDE58: 7D091A14  add r8, r9, r3
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	pc = 0x823FDE5C; continue 'dispatch;
            }
            0x823FDE5C => {
    //   block [0x823FDE5C..0x823FDE70)
	// 823FDE5C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FDE60: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FDE64: 4099000C  ble cr6, 0x823fde70
	if !ctx.cr[6].gt {
	pc = 0x823FDE70; continue 'dispatch;
	}
	// 823FDE68: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 823FDE6C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x823FDE70; continue 'dispatch;
            }
            0x823FDE70 => {
    //   block [0x823FDE70..0x823FDE80)
	// 823FDE70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FDE74: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FDE78: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FDE7C: 4198FFE0  blt cr6, 0x823fde5c
	if ctx.cr[6].lt {
	pc = 0x823FDE5C; continue 'dispatch;
	}
	pc = 0x823FDE80; continue 'dispatch;
            }
            0x823FDE80 => {
    //   block [0x823FDE80..0x823FDE94)
	// 823FDE80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FDE84: 9161FFD0  stw r11, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	// 823FDE88: 4098000C  bge cr6, 0x823fde94
	if !ctx.cr[6].lt {
	pc = 0x823FDE94; continue 'dispatch;
	}
	// 823FDE8C: 93C1FFD0  stw r30, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[30].u32 ) };
	// 823FDE90: 4198000C  blt cr6, 0x823fde9c
	if ctx.cr[6].lt {
	pc = 0x823FDE9C; continue 'dispatch;
	}
	pc = 0x823FDE94; continue 'dispatch;
            }
            0x823FDE94 => {
    //   block [0x823FDE94..0x823FDE9C)
	// 823FDE94: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FDE98: 48000008  b 0x823fdea0
	pc = 0x823FDEA0; continue 'dispatch;
            }
            0x823FDE9C => {
    //   block [0x823FDE9C..0x823FDEA0)
	// 823FDE9C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x823FDEA0; continue 'dispatch;
            }
            0x823FDEA0 => {
    //   block [0x823FDEA0..0x823FDEB0)
	// 823FDEA0: C001FFD0  lfs f0, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDEA4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FDEA8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDEAC: 48137260  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FDEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FDEB0 size=524
    let mut pc: u32 = 0x823FDEB0;
    'dispatch: loop {
        match pc {
            0x823FDEB0 => {
    //   block [0x823FDEB0..0x823FDFB0)
	// 823FDEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FDEB4: 48137205  bl 0x825350b8
	ctx.lr = 0x823FDEB8;
	sub_82535080(ctx, base);
	// 823FDEB8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 823FDEBC: 4813812D  bl 0x82535fe8
	ctx.lr = 0x823FDEC0;
	sub_82535FB0(ctx, base);
	// 823FDEC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FDEC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 823FDEC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FDECC: 7FA907B4  extsw r9, r29
	ctx.r[9].s64 = ctx.r[29].s32 as i64;
	// 823FDED0: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 823FDED4: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 823FDED8: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 823FDEDC: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FDEE0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 823FDEE4: 7FBC0E70  srawi r28, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 823FDEE8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 823FDEEC: 814A37B8  lwz r10, 0x37b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14264 as u32) ) } as u64;
	// 823FDEF0: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 823FDEF4: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 823FDEF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FDEFC: C3AB2068  lfs f29, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FDF00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FDF04: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FDF08: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FDF0C: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FDF10: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FDF14: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FDF18: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FDF1C: C1AB2204  lfs f13, 0x2204(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDF20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FDF24: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FDF28: EC2D6024  fdivs f1, f13, f12
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 823FDF2C: C1AB903C  lfs f13, -0x6fc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDF30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FDF34: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FDF38: C1AB9038  lfs f13, -0x6fc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28616 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FDF3C: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FDF40: FFC0E090  fmr f30, f28
	ctx.f[30].f64 = ctx.f[28].f64;
	// 823FDF44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 823FDF48: 4E800421  bctrl
	ctx.lr = 0x823FDF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FDF4C: EC1FE028  fsubs f0, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[28].f64) as f32) as f64);
	// 823FDF50: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FDF54: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FDF58: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 823FDF5C: 395EFFFC  addi r10, r30, -4
	ctx.r[10].s64 = ctx.r[30].s64 + -4;
	// 823FDF60: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 823FDF64: 2F1C0004  cmpwi cr6, r28, 4
	ctx.cr[6].compare_i32(ctx.r[28].s32, 4, &mut ctx.xer);
	// 823FDF68: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FDF6C: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDF70: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FDF74: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FDF78: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDF7C: EC0D0732  fmuls f0, f13, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 823FDF80: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FDF84: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 823FDF88: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FDF8C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FDF90: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDF94: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FDF98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDF9C: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FDFA0: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFA4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FDFA8: 40990090  ble cr6, 0x823fe038
	if !ctx.cr[6].gt {
	pc = 0x823FE038; continue 'dispatch;
	}
	// 823FDFAC: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
            }
            0x823FDFB0 => {
    //   block [0x823FDFB0..0x823FE038)
	// 823FDFB0: ED80F378  fmsubs f12, f0, f13, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 823FDFB4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FDFB8: 39080003  addi r8, r8, 3
	ctx.r[8].s64 = ctx.r[8].s64 + 3;
	// 823FDFBC: 39290003  addi r9, r9, 3
	ctx.r[9].s64 = ctx.r[9].s64 + 3;
	// 823FDFC0: 7F08E000  cmpw cr6, r8, r28
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FDFC4: ED7F6028  fsubs f11, f31, f12
	ctx.f[11].f64 = (((ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FDFC8: EFCC0378  fmsubs f30, f12, f13, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FDFCC: EC0A02F2  fmuls f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FDFD0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFD4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FDFD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FDFDC: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FDFE0: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFE4: ED7FF028  fsubs f11, f31, f30
	ctx.f[11].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 823FDFE8: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FDFEC: EC0D67B8  fmsubs f0, f13, f30, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FDFF0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FDFF4: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FDFF8: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FDFFC: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE000: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE004: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FE008: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE00C: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE010: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FE014: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FE018: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE01C: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE020: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FE024: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE028: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE02C: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE030: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FE034: 4198FF7C  blt cr6, 0x823fdfb0
	if ctx.cr[6].lt {
	pc = 0x823FDFB0; continue 'dispatch;
	}
	pc = 0x823FE038; continue 'dispatch;
            }
            0x823FE038 => {
    //   block [0x823FE038..0x823FE094)
	// 823FE038: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FE03C: 40980058  bge cr6, 0x823fe094
	if !ctx.cr[6].lt {
	pc = 0x823FE094; continue 'dispatch;
	}
	// 823FE040: ED60F378  fmsubs f11, f0, f13, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	// 823FE044: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FE048: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FE04C: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 823FE050: ED9F5828  fsubs f12, f31, f11
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 823FE054: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE058: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE05C: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FE060: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE064: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FE068: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE06C: 40980028  bge cr6, 0x823fe094
	if !ctx.cr[6].lt {
	pc = 0x823FE094; continue 'dispatch;
	}
	// 823FE070: EC0B0378  fmsubs f0, f11, f13, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE074: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE078: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE07C: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE080: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE084: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE088: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE08C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE090: D00AFFFC  stfs f0, -4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	pc = 0x823FE094; continue 'dispatch;
            }
            0x823FE094 => {
    //   block [0x823FE094..0x823FE0AC)
	// 823FE094: 57AA07FF  clrlwi. r10, r29, 0x1f
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FE098: 41820014  beq 0x823fe0ac
	if ctx.cr[0].eq {
	pc = 0x823FE0AC; continue 'dispatch;
	}
	// 823FE09C: EC1FE02A  fadds f0, f31, f28
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64;
	// 823FE0A0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE0A4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE0A8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FE0AC; continue 'dispatch;
            }
            0x823FE0AC => {
    //   block [0x823FE0AC..0x823FE0BC)
	// 823FE0AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 823FE0B0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 823FE0B4: 48137F81  bl 0x82536034
	ctx.lr = 0x823FE0B8;
	sub_82535FFC(ctx, base);
	// 823FE0B8: 48137050  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE0C0 size=24
    let mut pc: u32 = 0x823FE0C0;
    'dispatch: loop {
        match pc {
            0x823FE0C0 => {
    //   block [0x823FE0C0..0x823FE0D8)
	// 823FE0C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE0C4: C00B2A24  lfs f0, 0x2a24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE0C8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE0CC: 4099000C  ble cr6, 0x823fe0d8
	if !ctx.cr[6].gt {
		sub_823FE0D8(ctx, base);
		return;
	}
	// 823FE0D0: 38600105  li r3, 0x105
	ctx.r[3].s64 = 261;
	// 823FE0D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE0D8 size=24
    let mut pc: u32 = 0x823FE0D8;
    'dispatch: loop {
        match pc {
            0x823FE0D8 => {
    //   block [0x823FE0D8..0x823FE0F0)
	// 823FE0D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE0DC: C00B2AA4  lfs f0, 0x2aa4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE0E0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE0E4: 4099000C  ble cr6, 0x823fe0f0
	if !ctx.cr[6].gt {
		sub_823FE0F0(ctx, base);
		return;
	}
	// 823FE0E8: 386000F1  li r3, 0xf1
	ctx.r[3].s64 = 241;
	// 823FE0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE0F0 size=24
    let mut pc: u32 = 0x823FE0F0;
    'dispatch: loop {
        match pc {
            0x823FE0F0 => {
    //   block [0x823FE0F0..0x823FE108)
	// 823FE0F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE0F4: C00B7700  lfs f0, 0x7700(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE0F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE0FC: 4099000C  ble cr6, 0x823fe108
	if !ctx.cr[6].gt {
		sub_823FE108(ctx, base);
		return;
	}
	// 823FE100: 386000DD  li r3, 0xdd
	ctx.r[3].s64 = 221;
	// 823FE104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE108 size=24
    let mut pc: u32 = 0x823FE108;
    'dispatch: loop {
        match pc {
            0x823FE108 => {
    //   block [0x823FE108..0x823FE120)
	// 823FE108: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE10C: C00B25E8  lfs f0, 0x25e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE110: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE114: 4099000C  ble cr6, 0x823fe120
	if !ctx.cr[6].gt {
		sub_823FE120(ctx, base);
		return;
	}
	// 823FE118: 386000C9  li r3, 0xc9
	ctx.r[3].s64 = 201;
	// 823FE11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE120 size=24
    let mut pc: u32 = 0x823FE120;
    'dispatch: loop {
        match pc {
            0x823FE120 => {
    //   block [0x823FE120..0x823FE138)
	// 823FE120: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE124: C00B2148  lfs f0, 0x2148(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE128: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE12C: 4099000C  ble cr6, 0x823fe138
	if !ctx.cr[6].gt {
		sub_823FE138(ctx, base);
		return;
	}
	// 823FE130: 386000B5  li r3, 0xb5
	ctx.r[3].s64 = 181;
	// 823FE134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE138 size=48
    let mut pc: u32 = 0x823FE138;
    'dispatch: loop {
        match pc {
            0x823FE138 => {
    //   block [0x823FE138..0x823FE160)
	// 823FE138: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE13C: C00B2D90  lfs f0, 0x2d90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE140: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE144: 4199001C  bgt cr6, 0x823fe160
	if ctx.cr[6].gt {
	pc = 0x823FE160; continue 'dispatch;
	}
	// 823FE148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE14C: C00B478C  lfs f0, 0x478c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE150: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FE154: 4199000C  bgt cr6, 0x823fe160
	if ctx.cr[6].gt {
	pc = 0x823FE160; continue 'dispatch;
	}
	// 823FE158: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE15C: C00B20F0  lfs f0, 0x20f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823FE160; continue 'dispatch;
            }
            0x823FE160 => {
    //   block [0x823FE160..0x823FE168)
	// 823FE160: 386000A1  li r3, 0xa1
	ctx.r[3].s64 = 161;
	// 823FE164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE168 size=96
    let mut pc: u32 = 0x823FE168;
    'dispatch: loop {
        match pc {
            0x823FE168 => {
    //   block [0x823FE168..0x823FE1C8)
	// 823FE168: D021FFF0  stfs f1, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 823FE16C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE170: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE174: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE178: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE17C: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FE180: 556A027E  clrlwi r10, r11, 9
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 823FE184: 7D6BBE70  srawi r11, r11, 0x17
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 23) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 23) as i64;
	// 823FE188: 654A3F80  oris r10, r10, 0x3f80
	ctx.r[10].u64 = ctx.r[10].u64 | 1065353216;
	// 823FE18C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 823FE190: 396BFF81  addi r11, r11, -0x7f
	ctx.r[11].s64 = ctx.r[11].s64 + -127;
	// 823FE194: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 823FE198: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FE19C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FE1A0: C161FFF0  lfs f11, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FE1A4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 823FE1A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE1AC: C18B1850  lfs f12, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE1B0: EC0B6038  fmsubs f0, f11, f0, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FE1B4: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FE1B8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FE1BC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FE1C0: EC20637A  fmadds f1, f0, f13, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 823FE1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE1C8 size=228
    let mut pc: u32 = 0x823FE1C8;
    'dispatch: loop {
        match pc {
            0x823FE1C8 => {
    //   block [0x823FE1C8..0x823FE208)
	// 823FE1C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE1CC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE1D0: ED600072  fmuls f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FE1D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE1D8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 823FE1DC: C0CB1850  lfs f6, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FE1E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE1E4: C06A9050  lfs f3, -0x6fb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28592 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FE1E8: FDA03090  fmr f13, f6
	ctx.f[13].f64 = ctx.f[6].f64;
	// 823FE1EC: C0AB277C  lfs f5, 0x277c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10108 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FE1F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE1F4: EC0B282A  fadds f0, f11, f5
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[5].f64) as f32) as f64;
	// 823FE1F8: C18B8E30  lfs f12, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE1FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE200: C08B2934  lfs f4, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FE204: 4800000C  b 0x823fe210
	pc = 0x823FE210; continue 'dispatch;
            }
            0x823FE208 => {
    //   block [0x823FE208..0x823FE210)
	// 823FE208: EC000132  fmuls f0, f0, f4
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64) as f32) as f64);
	// 823FE20C: EDAD00F2  fmuls f13, f13, f3
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[3].f64) as f32) as f64);
	pc = 0x823FE210; continue 'dispatch;
            }
            0x823FE210 => {
    //   block [0x823FE210..0x823FE24C)
	// 823FE210: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FE214: 4198FFF4  blt cr6, 0x823fe208
	if ctx.cr[6].lt {
	pc = 0x823FE208; continue 'dispatch;
	}
	// 823FE218: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE21C: 3564FFFF  addic. r11, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FE220: C12A904C  lfs f9, -0x6fb4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28596 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FE224: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE228: C10A9048  lfs f8, -0x6fb8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28600 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FE22C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE230: ED40427C  fnmsubs f10, f0, f9, f8
	ctx.f[10].f64 = -(((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 823FE234: C0EA9044  lfs f7, -0x6fbc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FE238: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 823FE23C: EC0A383A  fmadds f0, f10, f0, f7
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 823FE240: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE244: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE248: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
	pc = 0x823FE24C; continue 'dispatch;
            }
            0x823FE24C => {
    //   block [0x823FE24C..0x823FE270)
	// 823FE24C: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE250: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 823FE254: ED400072  fmuls f10, f0, f1
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FE258: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FE25C: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 823FE260: 419A0030  beq cr6, 0x823fe290
	if ctx.cr[6].eq {
	pc = 0x823FE290; continue 'dispatch;
	}
	// 823FE264: EC0A282A  fadds f0, f10, f5
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64;
	// 823FE268: FDA03090  fmr f13, f6
	ctx.f[13].f64 = ctx.f[6].f64;
	// 823FE26C: 4800000C  b 0x823fe278
	pc = 0x823FE278; continue 'dispatch;
            }
            0x823FE270 => {
    //   block [0x823FE270..0x823FE278)
	// 823FE270: EC000132  fmuls f0, f0, f4
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64) as f32) as f64);
	// 823FE274: EDAD00F2  fmuls f13, f13, f3
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[3].f64) as f32) as f64);
	pc = 0x823FE278; continue 'dispatch;
            }
            0x823FE278 => {
    //   block [0x823FE278..0x823FE290)
	// 823FE278: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FE27C: 4198FFF4  blt cr6, 0x823fe270
	if ctx.cr[6].lt {
	pc = 0x823FE270; continue 'dispatch;
	}
	// 823FE280: ED60427C  fnmsubs f11, f0, f9, f8
	ctx.f[11].f64 = -(((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 823FE284: EC0B383A  fmadds f0, f11, f0, f7
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 823FE288: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE28C: 48000008  b 0x823fe294
	pc = 0x823FE294; continue 'dispatch;
            }
            0x823FE290 => {
    //   block [0x823FE290..0x823FE294)
	// 823FE290: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823FE294; continue 'dispatch;
            }
            0x823FE294 => {
    //   block [0x823FE294..0x823FE2AC)
	// 823FE294: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE298: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 823FE29C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FE2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FE2A4: 4199FFA8  bgt cr6, 0x823fe24c
	if ctx.cr[6].gt {
	pc = 0x823FE24C; continue 'dispatch;
	}
	// 823FE2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE2B0 size=204
    let mut pc: u32 = 0x823FE2B0;
    'dispatch: loop {
        match pc {
            0x823FE2B0 => {
    //   block [0x823FE2B0..0x823FE2CC)
	// 823FE2B0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE2B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2B8: C1AB20B0  lfs f13, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE2BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE2C0: 4199000C  bgt cr6, 0x823fe2cc
	if ctx.cr[6].gt {
	pc = 0x823FE2CC; continue 'dispatch;
	}
	// 823FE2C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2C8: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	pc = 0x823FE2CC; continue 'dispatch;
            }
            0x823FE2CC => {
    //   block [0x823FE2CC..0x823FE30C)
	// 823FE2CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2D0: C1AB2284  lfs f13, 0x2284(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8836 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE2D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE2D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE2DC: C18B9054  lfs f12, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE2E0: 41980038  blt cr6, 0x823fe318
	if ctx.cr[6].lt {
	pc = 0x823FE318; continue 'dispatch;
	}
	// 823FE2E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE2E8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FE2EC: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE2F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE2F4: EDA40372  fmuls f13, f4, f13
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE2F8: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE2FC: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE300: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 823FE304: 40980008  bge cr6, 0x823fe30c
	if !ctx.cr[6].lt {
	pc = 0x823FE30C; continue 'dispatch;
	}
	// 823FE308: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	pc = 0x823FE30C; continue 'dispatch;
            }
            0x823FE30C => {
    //   block [0x823FE30C..0x823FE318)
	// 823FE30C: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 823FE310: 40990008  ble cr6, 0x823fe318
	if !ctx.cr[6].gt {
	pc = 0x823FE318; continue 'dispatch;
	}
	// 823FE314: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	pc = 0x823FE318; continue 'dispatch;
            }
            0x823FE318 => {
    //   block [0x823FE318..0x823FE368)
	// 823FE318: FF031000  fcmpu cr6, f3, f2
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[2].f64);
	// 823FE31C: 40990058  ble cr6, 0x823fe374
	if !ctx.cr[6].gt {
	pc = 0x823FE374; continue 'dispatch;
	}
	// 823FE320: FF036000  fcmpu cr6, f3, f12
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[12].f64);
	// 823FE324: 41980050  blt cr6, 0x823fe374
	if ctx.cr[6].lt {
	pc = 0x823FE374; continue 'dispatch;
	}
	// 823FE328: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE32C: C00B22E8  lfs f0, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE330: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE334: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 823FE338: 40980030  bge cr6, 0x823fe368
	if !ctx.cr[6].lt {
	pc = 0x823FE368; continue 'dispatch;
	}
	// 823FE33C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE340: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE344: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE348: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 823FE34C: 4099001C  ble cr6, 0x823fe368
	if !ctx.cr[6].gt {
	pc = 0x823FE368; continue 'dispatch;
	}
	// 823FE350: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE354: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE358: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE35C: C1AB8E28  lfs f13, -0x71d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE360: EDA30372  fmuls f13, f3, f13
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE364: EC42683A  fmadds f2, f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[2].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	pc = 0x823FE368; continue 'dispatch;
            }
            0x823FE368 => {
    //   block [0x823FE368..0x823FE374)
	// 823FE368: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 823FE36C: 40980008  bge cr6, 0x823fe374
	if !ctx.cr[6].lt {
	pc = 0x823FE374; continue 'dispatch;
	}
	// 823FE370: EC42602A  fadds f2, f2, f12
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[12].f64) as f32) as f64;
	pc = 0x823FE374; continue 'dispatch;
            }
            0x823FE374 => {
    //   block [0x823FE374..0x823FE37C)
	// 823FE374: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 823FE378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FE380 size=760
    let mut pc: u32 = 0x823FE380;
    'dispatch: loop {
        match pc {
            0x823FE380 => {
    //   block [0x823FE380..0x823FE3F8)
	// 823FE380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE384: 48136D21  bl 0x825350a4
	ctx.lr = 0x823FE388;
	sub_82535080(ctx, base);
	// 823FE388: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE38C: 48137C5D  bl 0x82535fe8
	ctx.lr = 0x823FE390;
	sub_82535FB0(ctx, base);
	// 823FE390: 9421F7F0  stwu r1, -0x810(r1)
	ea = ctx.r[1].u32.wrapping_add(-2064 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE394: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE398: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 823FE39C: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 823FE3A0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 823FE3A4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 823FE3A8: C00B905C  lfs f0, -0x6fa4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE3AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE3B0: C3F90000  lfs f31, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FE3B4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 823FE3B8: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE3BC: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 823FE3C0: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 823FE3C4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 823FE3C8: C1AB7588  lfs f13, 0x7588(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE3CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE3D0: EDADF824  fdivs f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[31].f64) as f32) as f64;
	// 823FE3D4: C38B1850  lfs f28, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 823FE3D8: ED80E028  fsubs f12, f0, f28
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 823FE3DC: FC00602E  fsel f0, f0, f0, f12
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 823FE3E0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FE3E4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FE3E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 823FE3EC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 823FE3F0: 40980008  bge cr6, 0x823fe3f8
	if !ctx.cr[6].lt {
	pc = 0x823FE3F8; continue 'dispatch;
	}
	// 823FE3F4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	pc = 0x823FE3F8; continue 'dispatch;
            }
            0x823FE3F8 => {
    //   block [0x823FE3F8..0x823FE430)
	// 823FE3F8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FE3FC: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 823FE400: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 823FE404: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FE408: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE40C: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FE410: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE414: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE418: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE41C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE420: C1AB9040  lfs f13, -0x6fc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE424: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE428: 40990008  ble cr6, 0x823fe430
	if !ctx.cr[6].gt {
	pc = 0x823FE430; continue 'dispatch;
	}
	// 823FE42C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FE430; continue 'dispatch;
            }
            0x823FE430 => {
    //   block [0x823FE430..0x823FE460)
	// 823FE430: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE434: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FE438: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FE43C: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 823FE440: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 823FE444: EDA0E82A  fadds f13, f0, f29
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 823FE448: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 823FE44C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FE450: 7DA05FAE  stfiwx f13, 0, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 823FE454: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE458: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 823FE45C: 40990024  ble cr6, 0x823fe480
	if !ctx.cr[6].gt {
	pc = 0x823FE480; continue 'dispatch;
	}
	pc = 0x823FE460; continue 'dispatch;
            }
            0x823FE460 => {
    //   block [0x823FE460..0x823FE480)
	// 823FE460: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FE464: 7DABDC2E  lfsx f13, r11, r27
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE468: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FE46C: 41990014  bgt cr6, 0x823fe480
	if ctx.cr[6].gt {
	pc = 0x823FE480; continue 'dispatch;
	}
	// 823FE470: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 823FE474: 7F044800  cmpw cr6, r4, r9
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[9].s32, &mut ctx.xer);
	// 823FE478: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 823FE47C: 4198FFE4  blt cr6, 0x823fe460
	if ctx.cr[6].lt {
	pc = 0x823FE460; continue 'dispatch;
	}
	pc = 0x823FE480; continue 'dispatch;
            }
            0x823FE480 => {
    //   block [0x823FE480..0x823FE4C8)
	// 823FE480: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FE484: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FE488: 4099013C  ble cr6, 0x823fe5c4
	if !ctx.cr[6].gt {
	pc = 0x823FE5C4; continue 'dispatch;
	}
	// 823FE48C: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 823FE490: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823FE494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FE498: 4BFFF811  bl 0x823fdca8
	ctx.lr = 0x823FE49C;
	sub_823FDCA8(ctx, base);
	// 823FE49C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823FE4A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 823FE4A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FE4A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FE4AC: 4BFFF7FD  bl 0x823fdca8
	ctx.lr = 0x823FE4B0;
	sub_823FDCA8(ctx, base);
	// 823FE4B0: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE4B4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE4B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE4BC: 4199000C  bgt cr6, 0x823fe4c8
	if ctx.cr[6].gt {
	pc = 0x823FE4C8; continue 'dispatch;
	}
	// 823FE4C0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 823FE4C4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	pc = 0x823FE4C8; continue 'dispatch;
            }
            0x823FE4C8 => {
    //   block [0x823FE4C8..0x823FE4E4)
	// 823FE4C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE4CC: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 823FE4D0: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FE4D4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 823FE4D8: 409A000C  bne cr6, 0x823fe4e4
	if !ctx.cr[6].eq {
	pc = 0x823FE4E4; continue 'dispatch;
	}
	// 823FE4DC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 823FE4E0: 48000008  b 0x823fe4e8
	pc = 0x823FE4E8; continue 'dispatch;
            }
            0x823FE4E4 => {
    //   block [0x823FE4E4..0x823FE4E8)
	// 823FE4E4: EC3C0024  fdivs f1, f28, f0
	ctx.f[1].f64 = ((ctx.f[28].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x823FE4E8; continue 'dispatch;
            }
            0x823FE4E8 => {
    //   block [0x823FE4E8..0x823FE51C)
	// 823FE4E8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 823FE4EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FE4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FE4F4: 4BFFFCD5  bl 0x823fe1c8
	ctx.lr = 0x823FE4F8;
	sub_823FE1C8(ctx, base);
	// 823FE4F8: 38C103A0  addi r6, r1, 0x3a0
	ctx.r[6].s64 = ctx.r[1].s64 + 928;
	// 823FE4FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 823FE500: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FE504: 4BFFFCC5  bl 0x823fe1c8
	ctx.lr = 0x823FE508;
	sub_823FE1C8(ctx, base);
	// 823FE508: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FE50C: 40990068  ble cr6, 0x823fe574
	if !ctx.cr[6].gt {
	pc = 0x823FE574; continue 'dispatch;
	}
	// 823FE510: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FE514: 7D3FD850  subf r9, r31, r27
	ctx.r[9].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 823FE518: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x823FE51C; continue 'dispatch;
            }
            0x823FE51C => {
    //   block [0x823FE51C..0x823FE568)
	// 823FE51C: 7C095C2E  lfsx f0, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE520: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 823FE524: EDA0E82A  fadds f13, f0, f29
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 823FE528: 38E103A0  addi r7, r1, 0x3a0
	ctx.r[7].s64 = ctx.r[1].s64 + 928;
	// 823FE52C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FE530: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE534: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FE538: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823FE53C: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 823FE540: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FE544: 7DA83C2E  lfsx f13, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE548: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE54C: 4098001C  bge cr6, 0x823fe568
	if !ctx.cr[6].lt {
	pc = 0x823FE568; continue 'dispatch;
	}
	// 823FE550: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FE554: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE558: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 823FE55C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE560: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE564: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FE568; continue 'dispatch;
            }
            0x823FE568 => {
    //   block [0x823FE568..0x823FE574)
	// 823FE568: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FE56C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FE570: 4082FFAC  bne 0x823fe51c
	if !ctx.cr[0].eq {
	pc = 0x823FE51C; continue 'dispatch;
	}
	pc = 0x823FE574; continue 'dispatch;
            }
            0x823FE574 => {
    //   block [0x823FE574..0x823FE5C4)
	// 823FE574: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FE578: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 823FE57C: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 823FE580: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 823FE584: 38E10210  addi r7, r1, 0x210
	ctx.r[7].s64 = ctx.r[1].s64 + 528;
	// 823FE588: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FE58C: C02B9058  lfs f1, -0x6fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28584 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FE590: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FE594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 823FE598: 48000C31  bl 0x823ff1c8
	ctx.lr = 0x823FE59C;
	sub_823FF1C8(ctx, base);
	// 823FE59C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 823FE5A0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 823FE5A4: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 823FE5A8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 823FE5AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FE5B0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 823FE5B4: 38810210  addi r4, r1, 0x210
	ctx.r[4].s64 = ctx.r[1].s64 + 528;
	// 823FE5B8: 48002C81  bl 0x82401238
	ctx.lr = 0x823FE5BC;
	sub_82401238(ctx, base);
	// 823FE5BC: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE5C0: 4800001C  b 0x823fe5dc
	pc = 0x823FE5DC; continue 'dispatch;
            }
            0x823FE5C4 => {
    //   block [0x823FE5C4..0x823FE5DC)
	// 823FE5C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE5C8: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 823FE5CC: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 823FE5D0: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FE5D4: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 823FE5D8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x823FE5DC; continue 'dispatch;
            }
            0x823FE5DC => {
    //   block [0x823FE5DC..0x823FE5FC)
	// 823FE5DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE5E0: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE5E4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 823FE5E8: C1AB29D4  lfs f13, 0x29d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE5EC: EFEC6F7C  fnmsubs f31, f12, f29, f13
	ctx.f[31].f64 = -(((ctx.f[12].f64 * ctx.f[29].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FE5F0: 4199000C  bgt cr6, 0x823fe5fc
	if ctx.cr[6].gt {
	pc = 0x823FE5FC; continue 'dispatch;
	}
	// 823FE5F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE5F8: C00B2150  lfs f0, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823FE5FC; continue 'dispatch;
            }
            0x823FE5FC => {
    //   block [0x823FE5FC..0x823FE60C)
	// 823FE5FC: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 823FE600: 4198000C  blt cr6, 0x823fe60c
	if ctx.cr[6].lt {
	pc = 0x823FE60C; continue 'dispatch;
	}
	// 823FE604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE608: C00B2498  lfs f0, 0x2498(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823FE60C; continue 'dispatch;
            }
            0x823FE60C => {
    //   block [0x823FE60C..0x823FE634)
	// 823FE60C: EC3C0028  fsubs f1, f28, f0
	ctx.f[1].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FE610: 48134B49  bl 0x82533158
	ctx.lr = 0x823FE614;
	sub_82533158(ctx, base);
	// 823FE614: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FE618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE61C: C00B2398  lfs f0, 0x2398(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE620: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE624: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 823FE628: 4098000C  bge cr6, 0x823fe634
	if !ctx.cr[6].lt {
	pc = 0x823FE634; continue 'dispatch;
	}
	// 823FE62C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 823FE630: 48000028  b 0x823fe658
	pc = 0x823FE658; continue 'dispatch;
            }
            0x823FE634 => {
    //   block [0x823FE634..0x823FE64C)
	// 823FE634: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE638: C1AB3070  lfs f13, 0x3070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE63C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FE640: 4099000C  ble cr6, 0x823fe64c
	if !ctx.cr[6].gt {
	pc = 0x823FE64C; continue 'dispatch;
	}
	// 823FE644: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 823FE648: 48000010  b 0x823fe658
	pc = 0x823FE658; continue 'dispatch;
            }
            0x823FE64C => {
    //   block [0x823FE64C..0x823FE658)
	// 823FE64C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 823FE650: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 823FE654: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x823FE658; continue 'dispatch;
            }
            0x823FE658 => {
    //   block [0x823FE658..0x823FE678)
	// 823FE658: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE65C: D0180000  stfs f0, 0(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE660: D1B90000  stfs f13, 0(r25)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE664: D0170000  stfs f0, 0(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE668: 38210810  addi r1, r1, 0x810
	ctx.r[1].s64 = ctx.r[1].s64 + 2064;
	// 823FE66C: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE670: 481379C5  bl 0x82536034
	ctx.lr = 0x823FE674;
	sub_82535FFC(ctx, base);
	// 823FE674: 48136A80  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FE678 size=164
    let mut pc: u32 = 0x823FE678;
    'dispatch: loop {
        match pc {
            0x823FE678 => {
    //   block [0x823FE678..0x823FE6B8)
	// 823FE678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE67C: FDA02090  fmr f13, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[4].f64;
	// 823FE680: C00B22E8  lfs f0, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE684: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE688: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 823FE68C: 4199002C  bgt cr6, 0x823fe6b8
	if ctx.cr[6].gt {
	pc = 0x823FE6B8; continue 'dispatch;
	}
	// 823FE690: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE694: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE698: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE69C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 823FE6A0: 41980018  blt cr6, 0x823fe6b8
	if ctx.cr[6].lt {
	pc = 0x823FE6B8; continue 'dispatch;
	}
	// 823FE6A4: EDA1102A  fadds f13, f1, f2
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 823FE6A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE6AC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE6B0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE6B4: 48000060  b 0x823fe714
	pc = 0x823FE714; continue 'dispatch;
            }
            0x823FE6B8 => {
    //   block [0x823FE6B8..0x823FE6CC)
	// 823FE6B8: FF036800  fcmpu cr6, f3, f13
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[13].f64);
	// 823FE6BC: 40990010  ble cr6, 0x823fe6cc
	if !ctx.cr[6].gt {
	pc = 0x823FE6CC; continue 'dispatch;
	}
	// 823FE6C0: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE6C4: FDA01890  fmr f13, f3
	ctx.f[13].f64 = ctx.f[3].f64;
	// 823FE6C8: 48000008  b 0x823fe6d0
	pc = 0x823FE6D0; continue 'dispatch;
            }
            0x823FE6CC => {
    //   block [0x823FE6CC..0x823FE6D0)
	// 823FE6CC: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	pc = 0x823FE6D0; continue 'dispatch;
            }
            0x823FE6D0 => {
    //   block [0x823FE6D0..0x823FE710)
	// 823FE6D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE6D4: C18B76F4  lfs f12, 0x76f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE6D8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FE6DC: 40980038  bge cr6, 0x823fe714
	if !ctx.cr[6].lt {
	pc = 0x823FE714; continue 'dispatch;
	}
	// 823FE6E0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FE6E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE6E8: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE6EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FE6F0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FE6F4: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE6F8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 823FE6FC: 40980018  bge cr6, 0x823fe714
	if !ctx.cr[6].lt {
	pc = 0x823FE714; continue 'dispatch;
	}
	// 823FE700: FF020800  fcmpu cr6, f2, f1
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[1].f64);
	// 823FE704: 4099000C  ble cr6, 0x823fe710
	if !ctx.cr[6].gt {
	pc = 0x823FE710; continue 'dispatch;
	}
	// 823FE708: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	// 823FE70C: 48000008  b 0x823fe714
	pc = 0x823FE714; continue 'dispatch;
            }
            0x823FE710 => {
    //   block [0x823FE710..0x823FE714)
	// 823FE710: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x823FE714; continue 'dispatch;
            }
            0x823FE714 => {
    //   block [0x823FE714..0x823FE71C)
	// 823FE714: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 823FE718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FE720 size=480
    let mut pc: u32 = 0x823FE720;
    'dispatch: loop {
        match pc {
            0x823FE720 => {
    //   block [0x823FE720..0x823FE768)
	// 823FE720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE724: 48136981  bl 0x825350a4
	ctx.lr = 0x823FE728;
	sub_82535080(ctx, base);
	// 823FE728: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE72C: 481378BD  bl 0x82535fe8
	ctx.lr = 0x823FE730;
	sub_82535FB0(ctx, base);
	// 823FE730: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE734: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE738: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FE73C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 823FE740: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 823FE744: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 823FE748: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FE74C: EDA100BA  fmadds f13, f1, f2, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FE750: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FE754: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FE758: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE75C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 823FE760: 40990008  ble cr6, 0x823fe768
	if !ctx.cr[6].gt {
	pc = 0x823FE768; continue 'dispatch;
	}
	// 823FE764: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	pc = 0x823FE768; continue 'dispatch;
            }
            0x823FE768 => {
    //   block [0x823FE768..0x823FE7B4)
	// 823FE768: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 823FE76C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 823FE770: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FE774: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FE778: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FE77C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FE780: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FE784: ED816828  fsubs f12, f1, f13
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FE788: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 823FE78C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE790: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE794: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 823FE798: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 823FE79C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE7A0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FE7A4: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FE7A8: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 823FE7AC: 40980008  bge cr6, 0x823fe7b4
	if !ctx.cr[6].lt {
	pc = 0x823FE7B4; continue 'dispatch;
	}
	// 823FE7B0: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	pc = 0x823FE7B4; continue 'dispatch;
            }
            0x823FE7B4 => {
    //   block [0x823FE7B4..0x823FE7C4)
	// 823FE7B4: 82E10050  lwz r23, 0x50(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FE7B8: 2F1700A0  cmpwi cr6, r23, 0xa0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 160, &mut ctx.xer);
	// 823FE7BC: 40990008  ble cr6, 0x823fe7c4
	if !ctx.cr[6].gt {
	pc = 0x823FE7C4; continue 'dispatch;
	}
	// 823FE7C0: 3AE000A0  li r23, 0xa0
	ctx.r[23].s64 = 160;
	pc = 0x823FE7C4; continue 'dispatch;
            }
            0x823FE7C4 => {
    //   block [0x823FE7C4..0x823FE7F0)
	// 823FE7C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 823FE7C8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FE7CC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823FE7D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823FE7D4: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823FE7D8: C3EA9060  lfs f31, -0x6fa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28576 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FE7DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FE7E0: 7FBEC850  subf r29, r30, r25
	ctx.r[29].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 823FE7E4: C3CA1FF8  lfs f30, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FE7E8: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 823FE7EC: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	pc = 0x823FE7F0; continue 'dispatch;
            }
            0x823FE7F0 => {
    //   block [0x823FE7F0..0x823FE818)
	// 823FE7F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 823FE7F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 823FE7F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FE7FC: 4BFFF41D  bl 0x823fdc18
	ctx.lr = 0x823FE800;
	sub_823FDC18(ctx, base);
	// 823FE800: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 823FE804: 40990014  ble cr6, 0x823fe818
	if !ctx.cr[6].gt {
	pc = 0x823FE818; continue 'dispatch;
	}
	// 823FE808: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FE80C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 823FE810: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	// 823FE814: 48000014  b 0x823fe828
	pc = 0x823FE828; continue 'dispatch;
            }
            0x823FE818 => {
    //   block [0x823FE818..0x823FE828)
	// 823FE818: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 823FE81C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 823FE820: 409A0008  bne cr6, 0x823fe828
	if !ctx.cr[6].eq {
	pc = 0x823FE828; continue 'dispatch;
	}
	// 823FE824: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x823FE828; continue 'dispatch;
            }
            0x823FE828 => {
    //   block [0x823FE828..0x823FE888)
	// 823FE828: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 823FE82C: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FE830: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 823FE834: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 823FE838: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 823FE83C: 7F0BB800  cmpw cr6, r11, r23
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[23].s32, &mut ctx.xer);
	// 823FE840: 4099FFB0  ble cr6, 0x823fe7f0
	if !ctx.cr[6].gt {
	pc = 0x823FE7F0; continue 'dispatch;
	}
	// 823FE844: 7FFAF214  add r31, r26, r30
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[30].u64;
	// 823FE848: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 823FE84C: 4099003C  ble cr6, 0x823fe888
	if !ctx.cr[6].gt {
	pc = 0x823FE888; continue 'dispatch;
	}
	// 823FE850: 7F1FB800  cmpw cr6, r31, r23
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[23].s32, &mut ctx.xer);
	// 823FE854: 40980034  bge cr6, 0x823fe888
	if !ctx.cr[6].lt {
	pc = 0x823FE888; continue 'dispatch;
	}
	// 823FE858: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 823FE85C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 823FE860: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823FE864: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 823FE868: 48000789  bl 0x823feff0
	ctx.lr = 0x823FE86C;
	sub_823FEFF0(ctx, base);
	// 823FE86C: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 823FE870: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FE874: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FE878: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FE87C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FE880: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FE884: 4800001C  b 0x823fe8a0
	pc = 0x823FE8A0; continue 'dispatch;
            }
            0x823FE888 => {
    //   block [0x823FE888..0x823FE8A0)
	// 823FE888: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 823FE88C: D3F80000  stfs f31, 0(r24)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE890: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 823FE894: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FE898: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FE89C: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x823FE8A0; continue 'dispatch;
            }
            0x823FE8A0 => {
    //   block [0x823FE8A0..0x823FE900)
	// 823FE8A0: 7FDFC850  subf r30, r31, r25
	ctx.r[30].s64 = ctx.r[25].s64 - ctx.r[31].s64;
	// 823FE8A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FE8A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 823FE8AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FE8B0: 4BFFF369  bl 0x823fdc18
	ctx.lr = 0x823FE8B4;
	sub_823FDC18(ctx, base);
	// 823FE8B4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 823FE8B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FE8BC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FE8C0: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 823FE8C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 823FE8C8: 4BFFF351  bl 0x823fdc18
	ctx.lr = 0x823FE8CC;
	sub_823FDC18(ctx, base);
	// 823FE8CC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FE8D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FE8D4: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FE8D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FE8DC: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FE8E0: EC006FBA  fmadds f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FE8E4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 823FE8E8: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 823FE8EC: D0180000  stfs f0, 0(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE8F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 823FE8F4: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FE8F8: 4813773D  bl 0x82536034
	ctx.lr = 0x823FE8FC;
	sub_82535FFC(ctx, base);
	// 823FE8FC: 481367F8  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FE900 size=72
    let mut pc: u32 = 0x823FE900;
    'dispatch: loop {
        match pc {
            0x823FE900 => {
    //   block [0x823FE900..0x823FE920)
	// 823FE900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE904: 481367B9  bl 0x825350bc
	ctx.lr = 0x823FE908;
	sub_82535080(ctx, base);
	// 823FE908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE90C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FE910: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FE914: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FE918: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FE91C: 419A0024  beq cr6, 0x823fe940
	if ctx.cr[6].eq {
	pc = 0x823FE940; continue 'dispatch;
	}
	pc = 0x823FE920; continue 'dispatch;
            }
            0x823FE920 => {
    //   block [0x823FE920..0x823FE940)
	// 823FE920: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FE924: 48137BD5  bl 0x825364f8
	ctx.lr = 0x823FE928;
	sub_825364F8(ctx, base);
	// 823FE928: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 823FE92C: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FE930: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FE934: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823FE938: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FE93C: 4082FFE4  bne 0x823fe920
	if !ctx.cr[0].eq {
	pc = 0x823FE920; continue 'dispatch;
	}
	pc = 0x823FE940; continue 'dispatch;
            }
            0x823FE940 => {
    //   block [0x823FE940..0x823FE948)
	// 823FE940: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FE944: 481367C8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FE948 size=412
    let mut pc: u32 = 0x823FE948;
    'dispatch: loop {
        match pc {
            0x823FE948 => {
    //   block [0x823FE948..0x823FEAE4)
	// 823FE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FE94C: 48136769  bl 0x825350b4
	ctx.lr = 0x823FE950;
	sub_82535080(ctx, base);
	// 823FE950: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FE954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FE958: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 823FE95C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FE960: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FE964: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 823FE968: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 823FE96C: 48002B25  bl 0x82401490
	ctx.lr = 0x823FE970;
	sub_82401490(ctx, base);
	// 823FE970: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 823FE974: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 823FE978: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 823FE97C: 3900FFF0  li r8, -0x10
	ctx.r[8].s64 = -16;
	// 823FE980: 38E0FFE0  li r7, -0x20
	ctx.r[7].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEAE8 size=320
    let mut pc: u32 = 0x823FEAE8;
    'dispatch: loop {
        match pc {
            0x823FEAE8 => {
    //   block [0x823FEAE8..0x823FEB0C)
	// 823FEAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FEAEC: 481365D1  bl 0x825350bc
	ctx.lr = 0x823FEAF0;
	sub_82535080(ctx, base);
	// 823FEAF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEAF4: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEAF8: C12B1FF8  lfs f9, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FEAFC: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 823FEB00: 409A000C  bne cr6, 0x823feb0c
	if !ctx.cr[6].eq {
	pc = 0x823FEB0C; continue 'dispatch;
	}
	// 823FEB04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FEB08: C1AB9068  lfs f13, -0x6f98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x823FEB0C; continue 'dispatch;
            }
            0x823FEB0C => {
    //   block [0x823FEB0C..0x823FEB20)
	// 823FEB0C: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FEB10: 41820010  beq 0x823feb20
	if ctx.cr[0].eq {
	pc = 0x823FEB20; continue 'dispatch;
	}
	// 823FEB14: 3961FF90  addi r11, r1, -0x70
	ctx.r[11].s64 = ctx.r[1].s64 + -112;
	// 823FEB18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 823FEB1C: 4800000C  b 0x823feb28
	pc = 0x823FEB28; continue 'dispatch;
            }
            0x823FEB20 => {
    //   block [0x823FEB20..0x823FEB28)
	// 823FEB20: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823FEB24: 3BA1FF90  addi r29, r1, -0x70
	ctx.r[29].s64 = ctx.r[1].s64 + -112;
	pc = 0x823FEB28; continue 'dispatch;
            }
            0x823FEB28 => {
    //   block [0x823FEB28..0x823FEB5C)
	// 823FEB28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FEB2C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FEB30: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FEB34: C14A1850  lfs f10, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FEB38: D15D0000  stfs f10, 0(r29)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEB3C: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEB40: 409900E0  ble cr6, 0x823fec20
	if !ctx.cr[6].gt {
	pc = 0x823FEC20; continue 'dispatch;
	}
	// 823FEB44: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823FEB48: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FEB4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 823FEB50: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 823FEB54: C1682964  lfs f11, 0x2964(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10596 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FEB58: C18A2968  lfs f12, 0x2968(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10600 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x823FEB5C; continue 'dispatch;
            }
            0x823FEB5C => {
    //   block [0x823FEB5C..0x823FEB74)
	// 823FEB5C: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 823FEB60: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FEB64: 4198002C  blt cr6, 0x823feb90
	if ctx.cr[6].lt {
	pc = 0x823FEB90; continue 'dispatch;
	}
	// 823FEB68: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823FEB6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FEB70: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	pc = 0x823FEB74; continue 'dispatch;
            }
            0x823FEB74 => {
    //   block [0x823FEB74..0x823FEB90)
	// 823FEB74: C1080000  lfs f8, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FEB78: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FEB7C: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FEB80: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FEB84: EC0801FA  fmadds f0, f8, f7, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FEB88: 38A5FFFC  addi r5, r5, -4
	ctx.r[5].s64 = ctx.r[5].s64 + -4;
	// 823FEB8C: 4082FFE8  bne 0x823feb74
	if !ctx.cr[0].eq {
	pc = 0x823FEB74; continue 'dispatch;
	}
	pc = 0x823FEB90; continue 'dispatch;
            }
            0x823FEB90 => {
    //   block [0x823FEB90..0x823FEBA0)
	// 823FEB90: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FEB94: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 823FEB98: 40990008  ble cr6, 0x823feba0
	if !ctx.cr[6].gt {
	pc = 0x823FEBA0; continue 'dispatch;
	}
	// 823FEB9C: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x823FEBA0; continue 'dispatch;
            }
            0x823FEBA0 => {
    //   block [0x823FEBA0..0x823FEBAC)
	// 823FEBA0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 823FEBA4: 40980008  bge cr6, 0x823febac
	if !ctx.cr[6].lt {
	pc = 0x823FEBAC; continue 'dispatch;
	}
	// 823FEBA8: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	pc = 0x823FEBAC; continue 'dispatch;
            }
            0x823FEBAC => {
    //   block [0x823FEBAC..0x823FEBE4)
	// 823FEBAC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 823FEBB0: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEBB4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FEBB8: FD000050  fneg f8, f0
	ctx.f[8].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FEBBC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FEBC0: 7D1F5A14  add r8, r31, r11
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 823FEBC4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 823FEBC8: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823FEBCC: D1080004  stfs f8, 4(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FEBD0: 41980034  blt cr6, 0x823fec04
	if ctx.cr[6].lt {
	pc = 0x823FEC04; continue 'dispatch;
	}
	// 823FEBD4: 7CBF5214  add r5, r31, r10
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 823FEBD8: 7C6B5050  subf r3, r11, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FEBDC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 823FEBE0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x823FEBE4; continue 'dispatch;
            }
            0x823FEBE4 => {
    //   block [0x823FEBE4..0x823FEC04)
	// 823FEBE4: C1050000  lfs f8, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FEBE8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FEBEC: 7CE3442E  lfsx f7, r3, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FEBF0: 38A5FFFC  addi r5, r5, -4
	ctx.r[5].s64 = ctx.r[5].s64 + -4;
	// 823FEBF4: ED08383C  fnmsubs f8, f8, f0, f7
	ctx.f[8].f64 = -(((ctx.f[8].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 823FEBF8: D1080000  stfs f8, 0(r8)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEBFC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FEC00: 4082FFE4  bne 0x823febe4
	if !ctx.cr[0].eq {
	pc = 0x823FEBE4; continue 'dispatch;
	}
	pc = 0x823FEC04; continue 'dispatch;
            }
            0x823FEC04 => {
    //   block [0x823FEC04..0x823FEC20)
	// 823FEC04: EC00503C  fnmsubs f0, f0, f0, f10
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 823FEC08: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FEC0C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FEC10: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823FEC14: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 823FEC18: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FEC1C: 4198FF40  blt cr6, 0x823feb5c
	if ctx.cr[6].lt {
	pc = 0x823FEB5C; continue 'dispatch;
	}
	pc = 0x823FEC20; continue 'dispatch;
            }
            0x823FEC20 => {
    //   block [0x823FEC20..0x823FEC28)
	// 823FEC20: D1A70000  stfs f13, 0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FEC24: 481364E8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEC28 size=400
    let mut pc: u32 = 0x823FEC28;
    'dispatch: loop {
        match pc {
            0x823FEC28 => {
    //   block [0x823FEC28..0x823FEC60)
	// 823FEC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FEC2C: 48136491  bl 0x825350bc
	ctx.lr = 0x823FEC30;
	sub_82535080(ctx, base);
	// 823FEC30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEC34: C1A50000  lfs f13, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEC38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FEC3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FEC40: C10BBFFC  lfs f8, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FEC44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FEC48: EC010232  fmuls f0, f1, f8
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[8].f64) as f32) as f64);
	// 823FEC4C: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 823FEC50: ED60082A  fadds f11, f0, f1
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 823FEC54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FEC58: 40980024  bge cr6, 0x823fec7c
	if !ctx.cr[6].lt {
	pc = 0x823FEC7C; continue 'dispatch;
	}
	// 823FEC5C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	pc = 0x823FEC60; continue 'dispatch;
            }
            0x823FEC60 => {
    //   block [0x823FEC60..0x823FEC7C)
	// 823FEC60: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FEC64: 40980018  bge cr6, 0x823fec7c
	if !ctx.cr[6].lt {
	pc = 0x823FEC7C; continue 'dispatch;
	}
	// 823FEC68: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FEC6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEC70: C1A70000  lfs f13, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEC74: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 823FEC78: 4198FFE8  blt cr6, 0x823fec60
	if ctx.cr[6].lt {
	pc = 0x823FEC60; continue 'dispatch;
	}
	pc = 0x823FEC7C; continue 'dispatch;
            }
            0x823FEC7C => {
    //   block [0x823FEC7C..0x823FECA8)
	// 823FEC7C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 823FEC80: C127227C  lfs f9, 0x227c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8828 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FEC84: ECA90028  fsubs f5, f9, f0
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FEC88: FF002800  fcmpu cr6, f0, f5
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[5].f64);
	// 823FEC8C: 40980128  bge cr6, 0x823fedb4
	if !ctx.cr[6].lt {
	pc = 0x823FEDB4; continue 'dispatch;
	}
	// 823FEC90: 7FC94050  subf r30, r9, r8
	ctx.r[30].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 823FEC94: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 823FEC98: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823FEC9C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FECA0: C0C82150  lfs f6, 0x2150(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8528 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 823FECA4: C0E91FF8  lfs f7, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	pc = 0x823FECA8; continue 'dispatch;
            }
            0x823FECA8 => {
    //   block [0x823FECA8..0x823FECDC)
	// 823FECA8: 7F035000  cmpw cr6, r3, r10
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FECAC: 40980108  bge cr6, 0x823fedb4
	if !ctx.cr[6].lt {
	pc = 0x823FEDB4; continue 'dispatch;
	}
	// 823FECB0: FDA03890  fmr f13, f7
	ctx.f[13].f64 = ctx.f[7].f64;
	// 823FECB4: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FECB8: 40980070  bge cr6, 0x823fed28
	if !ctx.cr[6].lt {
	pc = 0x823FED28; continue 'dispatch;
	}
	// 823FECBC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FECC0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 823FECC4: 7D892C2E  lfsx f12, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FECC8: 9101FFD0  stw r8, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u32 ) };
	// 823FECCC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823FECD0: 40980058  bge cr6, 0x823fed28
	if !ctx.cr[6].lt {
	pc = 0x823FED28; continue 'dispatch;
	}
	// 823FECD4: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 823FECD8: 7FE42850  subf r31, r4, r5
	ctx.r[31].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	pc = 0x823FECDC; continue 'dispatch;
            }
            0x823FECDC => {
    //   block [0x823FECDC..0x823FECF8)
	// 823FECDC: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FECE0: 40980030  bge cr6, 0x823fed10
	if !ctx.cr[6].lt {
	pc = 0x823FED10; continue 'dispatch;
	}
	// 823FECE4: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FECE8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 823FECEC: 4098000C  bge cr6, 0x823fecf8
	if !ctx.cr[6].lt {
	pc = 0x823FECF8; continue 'dispatch;
	}
	// 823FECF0: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 823FECF4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x823FECF8; continue 'dispatch;
            }
            0x823FECF8 => {
    //   block [0x823FECF8..0x823FED10)
	// 823FECF8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FECFC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 823FED00: 7D9F4C2E  lfsx f12, r31, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FED04: 9101FFD0  stw r8, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u32 ) };
	// 823FED08: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823FED0C: 4198FFD0  blt cr6, 0x823fecdc
	if ctx.cr[6].lt {
	pc = 0x823FECDC; continue 'dispatch;
	}
	pc = 0x823FED10; continue 'dispatch;
            }
            0x823FED10 => {
    //   block [0x823FED10..0x823FED28)
	// 823FED10: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 823FED14: 40990014  ble cr6, 0x823fed28
	if !ctx.cr[6].gt {
	pc = 0x823FED28; continue 'dispatch;
	}
	// 823FED18: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FED1C: 7DBE3D2E  stfsx f13, r30, r7
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 823FED20: 7DA92C2E  lfsx f13, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FED24: 48000040  b 0x823fed64
	pc = 0x823FED64; continue 'dispatch;
            }
            0x823FED28 => {
    //   block [0x823FED28..0x823FED64)
	// 823FED28: EDAB502A  fadds f13, f11, f10
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 823FED2C: 3921FFD0  addi r9, r1, -0x30
	ctx.r[9].s64 = ctx.r[1].s64 + -48;
	// 823FED30: EDAD423A  fmadds f13, f13, f8, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 + ctx.f[8].f64) as f32) as f64);
	// 823FED34: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 823FED38: 7DA04FAE  stfiwx f13, 0, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FED3C: 8121FFD0  lwz r9, -0x30(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 823FED40: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 823FED44: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FED48: F901FFD8  std r8, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[8].u64 ) };
	// 823FED4C: 7DA9EC2E  lfsx f13, r9, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FED50: EDAD302A  fadds f13, f13, f6
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64;
	// 823FED54: 7DBE3D2E  stfsx f13, r30, r7
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 823FED58: C9A1FFD8  lfd f13, -0x28(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 823FED5C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FED60: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	pc = 0x823FED64; continue 'dispatch;
            }
            0x823FED64 => {
    //   block [0x823FED64..0x823FED7C)
	// 823FED64: ED40682A  fadds f10, f0, f13
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FED68: D1A70000  stfs f13, 0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FED6C: ED6A082A  fadds f11, f10, f1
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[1].f64) as f32) as f64;
	// 823FED70: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 823FED74: 40990008  ble cr6, 0x823fed7c
	if !ctx.cr[6].gt {
	pc = 0x823FED7C; continue 'dispatch;
	}
	// 823FED78: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	pc = 0x823FED7C; continue 'dispatch;
            }
            0x823FED7C => {
    //   block [0x823FED7C..0x823FED90)
	// 823FED7C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FED80: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 823FED84: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 823FED88: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FED8C: 48000014  b 0x823feda0
	pc = 0x823FEDA0; continue 'dispatch;
            }
            0x823FED90 => {
    //   block [0x823FED90..0x823FEDA0)
	// 823FED90: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FED94: 40980018  bge cr6, 0x823fedac
	if !ctx.cr[6].lt {
	pc = 0x823FEDAC; continue 'dispatch;
	}
	// 823FED98: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FED9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x823FEDA0; continue 'dispatch;
            }
            0x823FEDA0 => {
    //   block [0x823FEDA0..0x823FEDAC)
	// 823FEDA0: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEDA4: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 823FEDA8: 4198FFE8  blt cr6, 0x823fed90
	if ctx.cr[6].lt {
	pc = 0x823FED90; continue 'dispatch;
	}
	pc = 0x823FEDAC; continue 'dispatch;
            }
            0x823FEDAC => {
    //   block [0x823FEDAC..0x823FEDB4)
	// 823FEDAC: FF0A2800  fcmpu cr6, f10, f5
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[5].f64);
	// 823FEDB0: 4198FEF8  blt cr6, 0x823feca8
	if ctx.cr[6].lt {
	pc = 0x823FECA8; continue 'dispatch;
	}
	pc = 0x823FEDB4; continue 'dispatch;
            }
            0x823FEDB4 => {
    //   block [0x823FEDB4..0x823FEDB8)
	// 823FEDB4: 48136358  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FEDB8 size=452
    let mut pc: u32 = 0x823FEDB8;
    'dispatch: loop {
        match pc {
            0x823FEDB8 => {
    //   block [0x823FEDB8..0x823FEF7C)
	// 823FEDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FEDBC: 481362F5  bl 0x825350b0
	ctx.lr = 0x823FEDC0;
	sub_82535080(ctx, base);
	// 823FEDC0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 823FEDC4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 823FEDC8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 823FEDCC: 9421F9A0  stwu r1, -0x660(r1)
	ea = ctx.r[1].u32.wrapping_add(-1632 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FEDD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FEDD4: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FEDD8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 823FEDDC: 39210210  addi r9, r1, 0x210
	ctx.r[9].s64 = ctx.r[1].s64 + 528;
	// 823FEDE0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 823FEDE4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823FEDE8: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FEDEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEDF0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FEDF4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 823FEDF8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 823FEDFC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 823FEE00: C00B2520  lfs f0, 0x2520(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FEE04: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 823FEE08: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 823FEE0C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 823FEE10: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 823FEE14: 4BFFFE15  bl 0x823fec28
	ctx.lr = 0x823FEE18;
	sub_823FEC28(ctx, base);
	// 823FEE18: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 823FEE1C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 823FEE20: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FEE24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823FEE28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEF80 size=108
    let mut pc: u32 = 0x823FEF80;
    'dispatch: loop {
        match pc {
            0x823FEF80 => {
    //   block [0x823FEF80..0x823FEF9C)
	// 823FEF80: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 823FEF84: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 823FEF88: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FEF8C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823FEF90: 40980054  bge cr6, 0x823fefe4
	if !ctx.cr[6].lt {
	pc = 0x823FEFE4; continue 'dispatch;
	}
	// 823FEF94: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FEF98: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	pc = 0x823FEF9C; continue 'dispatch;
            }
            0x823FEF9C => {
    //   block [0x823FEF9C..0x823FEFD4)
	// 823FEF9C: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FEFA0: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEFA4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FEFA8: 4198002C  blt cr6, 0x823fefd4
	if ctx.cr[6].lt {
	pc = 0x823FEFD4; continue 'dispatch;
	}
	// 823FEFAC: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FEFB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FEFB4: 40990020  ble cr6, 0x823fefd4
	if !ctx.cr[6].gt {
	pc = 0x823FEFD4; continue 'dispatch;
	}
	// 823FEFB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FEFBC: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FEFC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FEFC4: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FEFC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEFCC: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FEFD0: 419A0014  beq cr6, 0x823fefe4
	if ctx.cr[6].eq {
	pc = 0x823FEFE4; continue 'dispatch;
	}
	pc = 0x823FEFD4; continue 'dispatch;
            }
            0x823FEFD4 => {
    //   block [0x823FEFD4..0x823FEFE4)
	// 823FEFD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FEFD8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FEFDC: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 823FEFE0: 4198FFBC  blt cr6, 0x823fef9c
	if ctx.cr[6].lt {
	pc = 0x823FEF9C; continue 'dispatch;
	}
	pc = 0x823FEFE4; continue 'dispatch;
            }
            0x823FEFE4 => {
    //   block [0x823FEFE4..0x823FEFEC)
	// 823FEFE4: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 823FEFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FEFF0 size=76
    let mut pc: u32 = 0x823FEFF0;
    'dispatch: loop {
        match pc {
            0x823FEFF0 => {
    //   block [0x823FEFF0..0x823FF02C)
	// 823FEFF0: EDA1182A  fadds f13, f1, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[3].f64) as f32) as f64;
	// 823FEFF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FEFF8: ED830828  fsubs f12, f3, f1
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[1].f64) as f32) as f64);
	// 823FEFFC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF000: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF004: EDAD1038  fmsubs f13, f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 823FF008: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FF00C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF010: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 823FF014: 419A0018  beq cr6, 0x823ff02c
	if ctx.cr[6].eq {
	pc = 0x823FF02C; continue 'dispatch;
	}
	// 823FF018: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF01C: C18B2068  lfs f12, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF020: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FF024: ED806024  fdivs f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 823FF028: FC206050  fneg f1, f12
	ctx.f[1].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x823FF02C; continue 'dispatch;
            }
            0x823FF02C => {
    //   block [0x823FF02C..0x823FF03C)
	// 823FF02C: EC01037A  fmadds f0, f1, f13, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FF030: EC00107A  fmadds f0, f0, f1, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64);
	// 823FF034: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF040 size=332
    let mut pc: u32 = 0x823FF040;
    'dispatch: loop {
        match pc {
            0x823FF040 => {
    //   block [0x823FF040..0x823FF0C0)
	// 823FF040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF044: 48136071  bl 0x825350b4
	ctx.lr = 0x823FF048;
	sub_82535080(ctx, base);
	// 823FF048: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF04C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FF050: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823FF054: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 823FF058: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FF05C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 823FF060: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 823FF064: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 823FF068: 4BFFEBE1  bl 0x823fdc48
	ctx.lr = 0x823FF06C;
	sub_823FDC48(ctx, base);
	// 823FF06C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 823FF070: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 823FF074: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 823FF078: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 823FF07C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FF080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FF084: 4BFFFEFD  bl 0x823fef80
	ctx.lr = 0x823FF088;
	sub_823FEF80(ctx, base);
	// 823FF088: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF08C: 2C040000  cmpwi r4, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FF090: 408100A8  ble 0x823ff138
	if !ctx.cr[0].gt {
	pc = 0x823FF138; continue 'dispatch;
	}
	// 823FF094: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 823FF098: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 823FF09C: 7CFF5050  subf r7, r31, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 823FF0A0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FF0A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FF0A8: 5488003E  slwi r8, r4, 0
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FF0AC: C1062068  lfs f8, 0x2068(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8296 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FF0B0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FF0B4: 7CBFE050  subf r5, r31, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 823FF0B8: C1291FF8  lfs f9, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FF0BC: C14ABFFC  lfs f10, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x823FF0C0; continue 'dispatch;
            }
            0x823FF0C0 => {
    //   block [0x823FF0C0..0x823FF100)
	// 823FF0C0: 7D27582E  lwzx r9, r7, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 823FF0C4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FF0C8: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 823FF0CC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF0D0: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF0D4: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF0D8: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF0DC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF0E0: EC0C5AB8  fmsubs f0, f12, f10, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 823FF0E4: ED8D02B2  fmuls f12, f13, f10
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 823FF0E8: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 823FF0EC: 419A0014  beq cr6, 0x823ff100
	if ctx.cr[6].eq {
	pc = 0x823FF100; continue 'dispatch;
	}
	// 823FF0F0: EDA00232  fmuls f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 823FF0F4: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 823FF0F8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FF0FC: 48000008  b 0x823ff104
	pc = 0x823FF104; continue 'dispatch;
            }
            0x823FF100 => {
    //   block [0x823FF100..0x823FF104)
	// 823FF100: FDA04890  fmr f13, f9
	ctx.f[13].f64 = ctx.f[9].f64;
	pc = 0x823FF104; continue 'dispatch;
            }
            0x823FF104 => {
    //   block [0x823FF104..0x823FF138)
	// 823FF104: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 823FF108: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 823FF10C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FF110: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 823FF114: EC005B7A  fmadds f0, f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 823FF118: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF11C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FF120: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 823FF124: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FF128: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FF12C: 7C055D2E  stfsx f0, r5, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FF130: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF134: 4082FF8C  bne 0x823ff0c0
	if !ctx.cr[0].eq {
	pc = 0x823FF0C0; continue 'dispatch;
	}
	pc = 0x823FF138; continue 'dispatch;
            }
            0x823FF138 => {
    //   block [0x823FF138..0x823FF15C)
	// 823FF138: 2F040003  cmpwi cr6, r4, 3
	ctx.cr[6].compare_i32(ctx.r[4].s32, 3, &mut ctx.xer);
	// 823FF13C: 41990048  bgt cr6, 0x823ff184
	if ctx.cr[6].gt {
	pc = 0x823FF184; continue 'dispatch;
	}
	// 823FF140: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF144: 393E001C  addi r9, r30, 0x1c
	ctx.r[9].s64 = ctx.r[30].s64 + 28;
	// 823FF148: 7D1FE050  subf r8, r31, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 823FF14C: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 823FF150: C1AB228C  lfs f13, 0x228c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8844 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF154: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 823FF158: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FF15C; continue 'dispatch;
            }
            0x823FF15C => {
    //   block [0x823FF15C..0x823FF184)
	// 823FF15C: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF160: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FF164: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 823FF168: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 823FF16C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF170: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FF174: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF178: 4082FFE4  bne 0x823ff15c
	if !ctx.cr[0].eq {
	pc = 0x823FF15C; continue 'dispatch;
	}
	// 823FF17C: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	// 823FF180: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x823FF184; continue 'dispatch;
            }
            0x823FF184 => {
    //   block [0x823FF184..0x823FF18C)
	// 823FF184: 38210220  addi r1, r1, 0x220
	ctx.r[1].s64 = ctx.r[1].s64 + 544;
	// 823FF188: 48135F7C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF190 size=56
    let mut pc: u32 = 0x823FF190;
    'dispatch: loop {
        match pc {
            0x823FF190 => {
    //   block [0x823FF190..0x823FF1A4)
	// 823FF190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF194: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF198: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF19C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 823FF1A0: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	pc = 0x823FF1A4; continue 'dispatch;
            }
            0x823FF1A4 => {
    //   block [0x823FF1A4..0x823FF1C8)
	// 823FF1A4: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF1A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF1AC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF1B0: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF1B4: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 823FF1B8: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 823FF1BC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FF1C0: 4082FFE4  bne 0x823ff1a4
	if !ctx.cr[0].eq {
	pc = 0x823FF1A4; continue 'dispatch;
	}
	// 823FF1C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF1C8 size=392
    let mut pc: u32 = 0x823FF1C8;
    'dispatch: loop {
        match pc {
            0x823FF1C8 => {
    //   block [0x823FF1C8..0x823FF1E4)
	// 823FF1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF1CC: 48135EE9  bl 0x825350b4
	ctx.lr = 0x823FF1D0;
	sub_82535080(ctx, base);
	// 823FF1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FF1D4: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FF1D8: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 823FF1DC: 41990008  bgt cr6, 0x823ff1e4
	if ctx.cr[6].gt {
	pc = 0x823FF1E4; continue 'dispatch;
	}
	// 823FF1E0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	pc = 0x823FF1E4; continue 'dispatch;
            }
            0x823FF1E4 => {
    //   block [0x823FF1E4..0x823FF200)
	// 823FF1E4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FF1E8: 40990034  ble cr6, 0x823ff21c
	if !ctx.cr[6].gt {
	pc = 0x823FF21C; continue 'dispatch;
	}
	// 823FF1EC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 823FF1F0: 7FC71850  subf r30, r7, r3
	ctx.r[30].s64 = ctx.r[3].s64 - ctx.r[7].s64;
	// 823FF1F4: 7FA72050  subf r29, r7, r4
	ctx.r[29].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 823FF1F8: 7F874050  subf r28, r7, r8
	ctx.r[28].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 823FF1FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x823FF200; continue 'dispatch;
            }
            0x823FF200 => {
    //   block [0x823FF200..0x823FF21C)
	// 823FF200: 7C1E342E  lfsx f0, r30, r6
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF204: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 823FF208: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF20C: 7C1D342E  lfsx f0, r29, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF210: 7C1C352E  stfsx f0, r28, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 823FF214: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF218: 4082FFE8  bne 0x823ff200
	if !ctx.cr[0].eq {
	pc = 0x823FF200; continue 'dispatch;
	}
	pc = 0x823FF21C; continue 'dispatch;
            }
            0x823FF21C => {
    //   block [0x823FF21C..0x823FF230)
	// 823FF21C: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FF220: 3BC5FFFF  addi r30, r5, -1
	ctx.r[30].s64 = ctx.r[5].s64 + -1;
	// 823FF224: 7F1E3000  cmpw cr6, r30, r6
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FF228: 40990008  ble cr6, 0x823ff230
	if !ctx.cr[6].gt {
	pc = 0x823FF230; continue 'dispatch;
	}
	// 823FF22C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	pc = 0x823FF230; continue 'dispatch;
            }
            0x823FF230 => {
    //   block [0x823FF230..0x823FF254)
	// 823FF230: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FF234: 40990054  ble cr6, 0x823ff288
	if !ctx.cr[6].gt {
	pc = 0x823FF288; continue 'dispatch;
	}
	// 823FF238: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 823FF23C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 823FF240: 7FE64214  add r31, r6, r8
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 823FF244: 38C40004  addi r6, r4, 4
	ctx.r[6].s64 = ctx.r[4].s64 + 4;
	// 823FF248: 7F841850  subf r28, r4, r3
	ctx.r[28].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 823FF24C: 7F683850  subf r27, r8, r7
	ctx.r[27].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 823FF250: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	pc = 0x823FF254; continue 'dispatch;
            }
            0x823FF254 => {
    //   block [0x823FF254..0x823FF288)
	// 823FF254: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF258: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 823FF25C: 7C1C342E  lfsx f0, r28, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF260: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 823FF264: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FF268: 7C1BFD2E  stfsx f0, r27, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FF26C: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF270: C1A6FFFC  lfs f13, -4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF274: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF278: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF27C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF280: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FF284: 4082FFD0  bne 0x823ff254
	if !ctx.cr[0].eq {
	pc = 0x823FF254; continue 'dispatch;
	}
	pc = 0x823FF288; continue 'dispatch;
            }
            0x823FF288 => {
    //   block [0x823FF288..0x823FF29C)
	// 823FF288: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 823FF28C: 38A5FFFE  addi r5, r5, -2
	ctx.r[5].s64 = ctx.r[5].s64 + -2;
	// 823FF290: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 823FF294: 40990008  ble cr6, 0x823ff29c
	if !ctx.cr[6].gt {
	pc = 0x823FF29C; continue 'dispatch;
	}
	// 823FF298: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	pc = 0x823FF29C; continue 'dispatch;
            }
            0x823FF29C => {
    //   block [0x823FF29C..0x823FF2BC)
	// 823FF29C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF2A0: 40990050  ble cr6, 0x823ff2f0
	if !ctx.cr[6].gt {
	pc = 0x823FF2F0; continue 'dispatch;
	}
	// 823FF2A4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FF2A8: 7FE83850  subf r31, r8, r7
	ctx.r[31].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 823FF2AC: 7CCA4214  add r6, r10, r8
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FF2B0: 39440008  addi r10, r4, 8
	ctx.r[10].s64 = ctx.r[4].s64 + 8;
	// 823FF2B4: 7C841850  subf r4, r4, r3
	ctx.r[4].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 823FF2B8: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	pc = 0x823FF2BC; continue 'dispatch;
            }
            0x823FF2BC => {
    //   block [0x823FF2BC..0x823FF2F0)
	// 823FF2BC: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF2C0: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF2C4: 7C0A242E  lfsx f0, r10, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF2C8: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 823FF2CC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FF2D0: 7C06FD2E  stfsx f0, r6, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 823FF2D4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF2D8: C1AAFFF8  lfs f13, -8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF2DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF2E0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF2E4: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF2E8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF2EC: 4082FFD0  bne 0x823ff2bc
	if !ctx.cr[0].eq {
	pc = 0x823FF2BC; continue 'dispatch;
	}
	pc = 0x823FF2F0; continue 'dispatch;
            }
            0x823FF2F0 => {
    //   block [0x823FF2F0..0x823FF31C)
	// 823FF2F0: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 823FF2F4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FF2F8: 41980054  blt cr6, 0x823ff34c
	if ctx.cr[6].lt {
	pc = 0x823FF34C; continue 'dispatch;
	}
	// 823FF2FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 823FF300: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF304: 40990044  ble cr6, 0x823ff348
	if !ctx.cr[6].gt {
	pc = 0x823FF348; continue 'dispatch;
	}
	// 823FF308: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 823FF30C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 823FF310: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 823FF314: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 823FF318: C1A42954  lfs f13, 0x2954(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(10580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x823FF31C; continue 'dispatch;
            }
            0x823FF31C => {
    //   block [0x823FF31C..0x823FF33C)
	// 823FF31C: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF320: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF324: 40990018  ble cr6, 0x823ff33c
	if !ctx.cr[6].gt {
	pc = 0x823FF33C; continue 'dispatch;
	}
	// 823FF328: 7C0A452E  stfsx f0, r10, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 823FF32C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 823FF330: 7C07342E  lfsx f0, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF334: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF338: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x823FF33C; continue 'dispatch;
            }
            0x823FF33C => {
    //   block [0x823FF33C..0x823FF348)
	// 823FF33C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF340: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FF344: 4082FFD8  bne 0x823ff31c
	if !ctx.cr[0].eq {
	pc = 0x823FF31C; continue 'dispatch;
	}
	pc = 0x823FF348; continue 'dispatch;
            }
            0x823FF348 => {
    //   block [0x823FF348..0x823FF34C)
	// 823FF348: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	pc = 0x823FF34C; continue 'dispatch;
            }
            0x823FF34C => {
    //   block [0x823FF34C..0x823FF350)
	// 823FF34C: 48135DB8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF350 size=360
    let mut pc: u32 = 0x823FF350;
    'dispatch: loop {
        match pc {
            0x823FF350 => {
    //   block [0x823FF350..0x823FF3B4)
	// 823FF350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FF358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FF35C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FF360: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 823FF364: 48136C85  bl 0x82535fe8
	ctx.lr = 0x823FF368;
	sub_82535FB0(ctx, base);
	// 823FF368: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF36C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FF370: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 823FF374: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 823FF378: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF37C: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 823FF380: D3BF0010  stfs f29, 0x10(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 823FF384: 4BF8147D  bl 0x82380800
	ctx.lr = 0x823FF388;
	sub_82380800(ctx, base);
	// 823FF388: A15F0018  lhz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF38C: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 823FF390: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FF394: A97F0016  lha r11, 0x16(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as i16) as i64;
	// 823FF398: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823FF39C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 823FF3A0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 823FF3A4: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 823FF3A8: 4082000C  bne 0x823ff3b4
	if !ctx.cr[0].eq {
	pc = 0x823FF3B4; continue 'dispatch;
	}
	// 823FF3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FF3B0: B17F0018  sth r11, 0x18(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u16 ) };
	pc = 0x823FF3B4; continue 'dispatch;
            }
            0x823FF3B4 => {
    //   block [0x823FF3B4..0x823FF3C8)
	// 823FF3B4: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 823FF3B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FF3BC: 4082000C  bne 0x823ff3c8
	if !ctx.cr[0].eq {
	pc = 0x823FF3C8; continue 'dispatch;
	}
	// 823FF3C0: 3960005A  li r11, 0x5a
	ctx.r[11].s64 = 90;
	// 823FF3C4: B17F001A  sth r11, 0x1a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(26 as u32), ctx.r[11].u16 ) };
	pc = 0x823FF3C8; continue 'dispatch;
            }
            0x823FF3C8 => {
    //   block [0x823FF3C8..0x823FF48C)
	// 823FF3C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF3CC: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF3D0: EC3F002A  fadds f1, f31, f0
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF3D4: 48133D85  bl 0x82533158
	ctx.lr = 0x823FF3D8;
	sub_82533158(ctx, base);
	// 823FF3D8: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 823FF3DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF3E0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF3E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FF3E8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 823FF3EC: C00B906C  lfs f0, -0x6f94(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF3F0: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FF3F4: 480023BD  bl 0x824017b0
	ctx.lr = 0x823FF3F8;
	sub_824017B0(ctx, base);
	// 823FF3F8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF3FC: FC40E090  fmr f2, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[28].f64;
	// 823FF400: A0BF0018  lhz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF404: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF408: 48002419  bl 0x82401820
	ctx.lr = 0x823FF40C;
	sub_82401820(ctx, base);
	// 823FF40C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF410: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 823FF414: 48002495  bl 0x824018a8
	ctx.lr = 0x823FF418;
	sub_824018A8(ctx, base);
	// 823FF418: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF41C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF420: A0BF001A  lhz r5, 0x1a(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 823FF424: A09F0018  lhz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF428: 48002639  bl 0x82401a60
	ctx.lr = 0x823FF42C;
	sub_82401A60(ctx, base);
	// 823FF42C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FF430: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF434: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 823FF438: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 823FF43C: B17F001C  sth r11, 0x1c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u16 ) };
	// 823FF440: 480026F1  bl 0x82401b30
	ctx.lr = 0x823FF444;
	sub_82401B30(ctx, base);
	// 823FF444: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FF448: 41820044  beq 0x823ff48c
	if ctx.cr[0].eq {
	pc = 0x823FF48C; continue 'dispatch;
	}
	// 823FF44C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF450: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF454: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF458: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF45C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 823FF460: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 823FF464: 88610057  lbz r3, 0x57(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 823FF468: 480021E1  bl 0x82401648
	ctx.lr = 0x823FF46C;
	sub_82401648(ctx, base);
	// 823FF46C: 897F001E  lbz r11, 0x1e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(30 as u32) ) } as u64;
	// 823FF470: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FF474: 41820020  beq 0x823ff494
	if ctx.cr[0].eq {
	pc = 0x823FF494; continue 'dispatch;
	}
	// 823FF478: A09F0016  lhz r4, 0x16(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 823FF47C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF480: 48002081  bl 0x82401500
	ctx.lr = 0x823FF484;
	sub_82401500(ctx, base);
	// 823FF484: B07F0014  sth r3, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u16 ) };
	// 823FF488: 4800000C  b 0x823ff494
	pc = 0x823FF494; continue 'dispatch;
            }
            0x823FF48C => {
    //   block [0x823FF48C..0x823FF494)
	// 823FF48C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF490: 480022C9  bl 0x82401758
	ctx.lr = 0x823FF494;
	sub_82401758(ctx, base);
	pc = 0x823FF494; continue 'dispatch;
            }
            0x823FF494 => {
    //   block [0x823FF494..0x823FF4B8)
	// 823FF494: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FF498: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 823FF49C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 823FF4A0: 48136B95  bl 0x82536034
	ctx.lr = 0x823FF4A4;
	sub_82535FFC(ctx, base);
	// 823FF4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FF4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FF4AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FF4B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FF4B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF4B8 size=400
    let mut pc: u32 = 0x823FF4B8;
    'dispatch: loop {
        match pc {
            0x823FF4B8 => {
    //   block [0x823FF4B8..0x823FF514)
	// 823FF4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF4BC: 48135BF1  bl 0x825350ac
	ctx.lr = 0x823FF4C0;
	sub_82535080(ctx, base);
	// 823FF4C0: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 823FF4C4: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 823FF4C8: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 823FF4CC: 9421FB30  stwu r1, -0x4d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1232 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF4D0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 823FF4D4: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FF4D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 823FF4DC: 3B3A0008  addi r25, r26, 8
	ctx.r[25].s64 = ctx.r[26].s64 + 8;
	// 823FF4E0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 823FF4E4: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 823FF4E8: C07E0030  lfs f3, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FF4EC: C03E0034  lfs f1, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FF4F0: C0990004  lfs f4, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FF4F4: C0590000  lfs f2, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FF4F8: 4BFFF181  bl 0x823fe678
	ctx.lr = 0x823FF4FC;
	sub_823FE678(ctx, base);
	// 823FF4FC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 823FF500: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 823FF504: 409A0010  bne cr6, 0x823ff514
	if !ctx.cr[6].eq {
	pc = 0x823FF514; continue 'dispatch;
	}
	// 823FF508: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF50C: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF510: EFDE0032  fmuls f30, f30, f0
	ctx.f[30].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x823FF514; continue 'dispatch;
            }
            0x823FF514 => {
    //   block [0x823FF514..0x823FF580)
	// 823FF514: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF518: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF51C: 4BFFEBA5  bl 0x823fe0c0
	ctx.lr = 0x823FF520;
	sub_823FE0C0(ctx, base);
	// 823FF520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FF524: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 823FF528: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 823FF52C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 823FF530: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 823FF534: 4BFFE42D  bl 0x823fd960
	ctx.lr = 0x823FF538;
	sub_823FD960(ctx, base);
	// 823FF538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FF53C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FF540: 4BFFE971  bl 0x823fdeb0
	ctx.lr = 0x823FF544;
	sub_823FDEB0(ctx, base);
	// 823FF544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF548: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 823FF54C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 823FF550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 823FF554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FF558: C3EB8E30  lfs f31, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FF55C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 823FF560: 4BFFF1C1  bl 0x823fe720
	ctx.lr = 0x823FF564;
	sub_823FE720(ctx, base);
	// 823FF564: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF568: D03A0000  stfs f1, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF56C: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 823FF570: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF574: 409A000C  bne cr6, 0x823ff580
	if !ctx.cr[6].eq {
	pc = 0x823FF580; continue 'dispatch;
	}
	// 823FF578: EC0102F2  fmuls f0, f1, f11
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FF57C: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FF580; continue 'dispatch;
            }
            0x823FF580 => {
    //   block [0x823FF580..0x823FF59C)
	// 823FF580: C19E001C  lfs f12, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF584: FD40E890  fmr f10, f29
	ctx.f[10].f64 = ctx.f[29].f64;
	// 823FF588: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF58C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 823FF590: C1BE0030  lfs f13, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF594: 40980008  bge cr6, 0x823ff59c
	if !ctx.cr[6].lt {
	pc = 0x823FF59C; continue 'dispatch;
	}
	// 823FF598: D3FE001C  stfs f31, 0x1c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x823FF59C; continue 'dispatch;
            }
            0x823FF59C => {
    //   block [0x823FF59C..0x823FF5A8)
	// 823FF59C: FF1DF800  fcmpu cr6, f29, f31
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[31].f64);
	// 823FF5A0: 40980008  bge cr6, 0x823ff5a8
	if !ctx.cr[6].lt {
	pc = 0x823FF5A8; continue 'dispatch;
	}
	// 823FF5A4: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	pc = 0x823FF5A8; continue 'dispatch;
            }
            0x823FF5A8 => {
    //   block [0x823FF5A8..0x823FF5CC)
	// 823FF5A8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF5AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF5B0: FD206210  fabs f9, f12
	ctx.f[9].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 823FF5B4: C18B9070  lfs f12, -0x6f90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28560 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF5B8: FF096000  fcmpu cr6, f9, f12
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[12].f64);
	// 823FF5BC: 40980010  bge cr6, 0x823ff5cc
	if !ctx.cr[6].lt {
	pc = 0x823FF5CC; continue 'dispatch;
	}
	// 823FF5C0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF5C4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FF5C8: 4800003C  b 0x823ff604
	pc = 0x823FF604; continue 'dispatch;
            }
            0x823FF5CC => {
    //   block [0x823FF5CC..0x823FF5E8)
	// 823FF5CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF5D0: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF5D4: C16B2980  lfs f11, 0x2980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10624 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF5D8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 823FF5DC: 40980014  bge cr6, 0x823ff5f0
	if !ctx.cr[6].lt {
	pc = 0x823FF5F0; continue 'dispatch;
	}
	// 823FF5E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF5E4: 41990014  bgt cr6, 0x823ff5f8
	if ctx.cr[6].gt {
	pc = 0x823FF5F8; continue 'dispatch;
	}
	pc = 0x823FF5E8; continue 'dispatch;
            }
            0x823FF5E8 => {
    //   block [0x823FF5E8..0x823FF5F0)
	// 823FF5E8: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 823FF5EC: 48000014  b 0x823ff600
	pc = 0x823FF600; continue 'dispatch;
            }
            0x823FF5F0 => {
    //   block [0x823FF5F0..0x823FF5F8)
	// 823FF5F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF5F4: 4199FFF4  bgt cr6, 0x823ff5e8
	if ctx.cr[6].gt {
	pc = 0x823FF5E8; continue 'dispatch;
	}
	pc = 0x823FF5F8; continue 'dispatch;
            }
            0x823FF5F8 => {
    //   block [0x823FF5F8..0x823FF600)
	// 823FF5F8: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF5FC: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x823FF600; continue 'dispatch;
            }
            0x823FF600 => {
    //   block [0x823FF600..0x823FF604)
	// 823FF600: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	pc = 0x823FF604; continue 'dispatch;
            }
            0x823FF604 => {
    //   block [0x823FF604..0x823FF618)
	// 823FF604: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF608: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF60C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF610: 40980008  bge cr6, 0x823ff618
	if !ctx.cr[6].lt {
	pc = 0x823FF618; continue 'dispatch;
	}
	// 823FF614: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FF618; continue 'dispatch;
            }
            0x823FF618 => {
    //   block [0x823FF618..0x823FF62C)
	// 823FF618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FF61C: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF620: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 823FF624: 40990008  ble cr6, 0x823ff62c
	if !ctx.cr[6].gt {
	pc = 0x823FF62C; continue 'dispatch;
	}
	// 823FF628: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x823FF62C; continue 'dispatch;
            }
            0x823FF62C => {
    //   block [0x823FF62C..0x823FF648)
	// 823FF62C: D15E001C  stfs f10, 0x1c(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 823FF630: D01A0004  stfs f0, 4(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FF634: 382104D0  addi r1, r1, 0x4d0
	ctx.r[1].s64 = ctx.r[1].s64 + 1232;
	// 823FF638: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 823FF63C: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 823FF640: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 823FF644: 48135AB8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FF648 size=636
    let mut pc: u32 = 0x823FF648;
    'dispatch: loop {
        match pc {
            0x823FF648 => {
    //   block [0x823FF648..0x823FF68C)
	// 823FF648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF64C: 48135A51  bl 0x8253509c
	ctx.lr = 0x823FF650;
	sub_82535080(ctx, base);
	// 823FF650: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FF654: 3D208273  lis r9, -0x7d8d
	ctx.r[9].s64 = -2106392576;
	// 823FF658: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 823FF65C: 3B270140  addi r25, r7, 0x140
	ctx.r[25].s64 = ctx.r[7].s64 + 320;
	// 823FF660: 3B070170  addi r24, r7, 0x170
	ctx.r[24].s64 = ctx.r[7].s64 + 368;
	// 823FF664: C00B207C  lfs f0, 0x207c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF668: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 823FF66C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 823FF670: 3B89D6A8  addi r28, r9, -0x2958
	ctx.r[28].s64 = ctx.r[9].s64 + -10584;
	// 823FF674: 396B9078  addi r11, r11, -0x6f88
	ctx.r[11].s64 = ctx.r[11].s64 + -28552;
	// 823FF678: 40990014  ble cr6, 0x823ff68c
	if !ctx.cr[6].gt {
	pc = 0x823FF68C; continue 'dispatch;
	}
	// 823FF67C: 392B066C  addi r9, r11, 0x66c
	ctx.r[9].s64 = ctx.r[11].s64 + 1644;
	// 823FF680: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	// 823FF684: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 823FF688: 48000010  b 0x823ff698
	pc = 0x823FF698; continue 'dispatch;
            }
            0x823FF68C => {
    //   block [0x823FF68C..0x823FF698)
	// 823FF68C: 3ACB0030  addi r22, r11, 0x30
	ctx.r[22].s64 = ctx.r[11].s64 + 48;
	// 823FF690: 391C0018  addi r8, r28, 0x18
	ctx.r[8].s64 = ctx.r[28].s64 + 24;
	// 823FF694: 392B0AB8  addi r9, r11, 0xab8
	ctx.r[9].s64 = ctx.r[11].s64 + 2744;
	pc = 0x823FF698; continue 'dispatch;
            }
            0x823FF698 => {
    //   block [0x823FF698..0x823FF6E8)
	// 823FF698: 9121FF90  stw r9, -0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[9].u32 ) };
	// 823FF69C: 393C0030  addi r9, r28, 0x30
	ctx.r[9].s64 = ctx.r[28].s64 + 48;
	// 823FF6A0: 3861FF90  addi r3, r1, -0x70
	ctx.r[3].s64 = ctx.r[1].s64 + -112;
	// 823FF6A4: 38CB10E4  addi r6, r11, 0x10e4
	ctx.r[6].s64 = ctx.r[11].s64 + 4324;
	// 823FF6A8: 38EB0E10  addi r7, r11, 0xe10
	ctx.r[7].s64 = ctx.r[11].s64 + 3600;
	// 823FF6AC: 396B1378  addi r11, r11, 0x1378
	ctx.r[11].s64 = ctx.r[11].s64 + 4984;
	// 823FF6B0: 3BC9FFF0  addi r30, r9, -0x10
	ctx.r[30].s64 = ctx.r[9].s64 + -16;
	// 823FF6B4: 7EE34050  subf r23, r3, r8
	ctx.r[23].s64 = ctx.r[8].s64 - ctx.r[3].s64;
	// 823FF6B8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 823FF6BC: 90C1FF98  stw r6, -0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.r[6].u32 ) };
	// 823FF6C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 823FF6C4: 90E1FF94  stw r7, -0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-108 as u32), ctx.r[7].u32 ) };
	// 823FF6C8: 9161FF9C  stw r11, -0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-100 as u32), ctx.r[11].u32 ) };
	// 823FF6CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 823FF6D0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 823FF6D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 823FF6D8: C1281FF8  lfs f9, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 823FF6DC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 823FF6E0: C1491850  lfs f10, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 823FF6E4: 38C1FF90  addi r6, r1, -0x70
	ctx.r[6].s64 = ctx.r[1].s64 + -112;
	pc = 0x823FF6E8; continue 'dispatch;
            }
            0x823FF6E8 => {
    //   block [0x823FF6E8..0x823FF72C)
	// 823FF6E8: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 823FF6EC: 409800D0  bge cr6, 0x823ff7bc
	if !ctx.cr[6].lt {
	pc = 0x823FF7BC; continue 'dispatch;
	}
	// 823FF6F0: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF6F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 823FF6F8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF6FC: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 823FF700: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF704: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823FF708: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF70C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF710: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF714: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FF718: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF71C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 823FF720: 40810028  ble 0x823ff748
	if !ctx.cr[0].gt {
	pc = 0x823FF748; continue 'dispatch;
	}
	// 823FF724: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF728: 80E9001C  lwz r7, 0x1c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x823FF72C; continue 'dispatch;
            }
            0x823FF72C => {
    //   block [0x823FF72C..0x823FF748)
	// 823FF72C: 82A70000  lwz r21, 0(r7)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF730: 7F15F800  cmpw cr6, r21, r31
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[31].s32, &mut ctx.xer);
	// 823FF734: 419A0080  beq cr6, 0x823ff7b4
	if ctx.cr[6].eq {
	pc = 0x823FF7B4; continue 'dispatch;
	}
	// 823FF738: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 823FF73C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FF740: 7F034000  cmpw cr6, r3, r8
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[8].s32, &mut ctx.xer);
	// 823FF744: 4198FFE8  blt cr6, 0x823ff72c
	if ctx.cr[6].lt {
	pc = 0x823FF72C; continue 'dispatch;
	}
	pc = 0x823FF748; continue 'dispatch;
            }
            0x823FF748 => {
    //   block [0x823FF748..0x823FF74C)
	// 823FF748: 80E90010  lwz r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x823FF74C; continue 'dispatch;
            }
            0x823FF74C => {
    //   block [0x823FF74C..0x823FF7B4)
	// 823FF74C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF750: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 823FF754: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF758: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 823FF75C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FF760: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF764: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FF768: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FF76C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 823FF770: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF774: ECCD0372  fmuls f6, f13, f13
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FF778: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF77C: C1680004  lfs f11, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FF780: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 823FF784: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF788: ECC0303A  fmadds f6, f0, f0, f6
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 823FF78C: EDA06B38  fmsubs f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FF790: EC0A3024  fdivs f0, f10, f6
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[6].f64) as f32) as f64;
	// 823FF794: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 823FF798: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF79C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF7A0: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 823FF7A4: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF7A8: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FF7AC: EC0D383A  fmadds f0, f13, f0, f7
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 823FF7B0: 4800002C  b 0x823ff7dc
	pc = 0x823FF7DC; continue 'dispatch;
            }
            0x823FF7B4 => {
    //   block [0x823FF7B4..0x823FF7BC)
	// 823FF7B4: 80E90014  lwz r7, 0x14(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FF7B8: 4BFFFF94  b 0x823ff74c
	pc = 0x823FF74C; continue 'dispatch;
            }
            0x823FF7BC => {
    //   block [0x823FF7BC..0x823FF7DC)
	// 823FF7BC: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF7C0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF7C4: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 823FF7C8: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF7CC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FF7D0: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF7D4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF7D8: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x823FF7DC; continue 'dispatch;
            }
            0x823FF7DC => {
    //   block [0x823FF7DC..0x823FF7F0)
	// 823FF7DC: 7D37302E  lwzx r9, r23, r6
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 823FF7E0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FF7E4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 823FF7E8: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 823FF7EC: 7D194850  subf r8, r25, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[25].s64;
	pc = 0x823FF7F0; continue 'dispatch;
            }
            0x823FF7F0 => {
    //   block [0x823FF7F0..0x823FF804)
	// 823FF7F0: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 823FF7F4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 823FF7F8: 40990024  ble cr6, 0x823ff81c
	if !ctx.cr[6].gt {
	pc = 0x823FF81C; continue 'dispatch;
	}
	// 823FF7FC: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 823FF800: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x823FF804; continue 'dispatch;
            }
            0x823FF804 => {
    //   block [0x823FF804..0x823FF81C)
	// 823FF804: 7DA84C2E  lfsx f13, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF808: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 823FF80C: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF810: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FF814: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 823FF818: 4082FFEC  bne 0x823ff804
	if !ctx.cr[0].eq {
	pc = 0x823FF804; continue 'dispatch;
	}
	pc = 0x823FF81C; continue 'dispatch;
            }
            0x823FF81C => {
    //   block [0x823FF81C..0x823FF8A4)
	// 823FF81C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF820: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 823FF824: 7D1D4214  add r8, r29, r8
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[8].u64;
	// 823FF828: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FF82C: 4082FFC4  bne 0x823ff7f0
	if !ctx.cr[0].eq {
	pc = 0x823FF7F0; continue 'dispatch;
	}
	// 823FF830: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF834: 38FC0030  addi r7, r28, 0x30
	ctx.r[7].s64 = ctx.r[28].s64 + 48;
	// 823FF838: C1B80000  lfs f13, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF83C: 393B0001  addi r9, r27, 1
	ctx.r[9].s64 = ctx.r[27].s64 + 1;
	// 823FF840: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF844: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF848: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF84C: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF850: 391D0004  addi r8, r29, 4
	ctx.r[8].s64 = ctx.r[29].s64 + 4;
	// 823FF854: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF858: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 823FF85C: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 823FF860: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF864: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 823FF868: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FF86C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FF870: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 823FF874: 3B690001  addi r27, r9, 1
	ctx.r[27].s64 = ctx.r[9].s64 + 1;
	// 823FF878: 3BA80004  addi r29, r8, 4
	ctx.r[29].s64 = ctx.r[8].s64 + 4;
	// 823FF87C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FF880: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF884: 7F1E3800  cmpw cr6, r30, r7
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[7].s32, &mut ctx.xer);
	// 823FF888: 4198FE60  blt cr6, 0x823ff6e8
	if ctx.cr[6].lt {
	pc = 0x823FF6E8; continue 'dispatch;
	}
	// 823FF88C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FF890: 40990030  ble cr6, 0x823ff8c0
	if !ctx.cr[6].gt {
	pc = 0x823FF8C0; continue 'dispatch;
	}
	// 823FF894: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 823FF898: 7D39B050  subf r9, r25, r22
	ctx.r[9].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	// 823FF89C: 7D192050  subf r8, r25, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[25].s64;
	// 823FF8A0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	pc = 0x823FF8A4; continue 'dispatch;
            }
            0x823FF8A4 => {
    //   block [0x823FF8A4..0x823FF8C0)
	// 823FF8A4: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF8A8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FF8AC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FF8B0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 823FF8B4: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 823FF8B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FF8BC: 4082FFE8  bne 0x823ff8a4
	if !ctx.cr[0].eq {
	pc = 0x823FF8A4; continue 'dispatch;
	}
	pc = 0x823FF8C0; continue 'dispatch;
            }
            0x823FF8C0 => {
    //   block [0x823FF8C0..0x823FF8C4)
	// 823FF8C0: 4813582C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF8C8 size=168
    let mut pc: u32 = 0x823FF8C8;
    'dispatch: loop {
        match pc {
            0x823FF8C8 => {
    //   block [0x823FF8C8..0x823FF8FC)
	// 823FF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FF8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FF8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FF8D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF8DC: A143005C  lhz r10, 0x5c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 823FF8E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 823FF8E4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 823FF8E8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 823FF8EC: 409A0010  bne cr6, 0x823ff8fc
	if !ctx.cr[6].eq {
	pc = 0x823FF8FC; continue 'dispatch;
	}
	// 823FF8F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FF8F4: C0AABFFC  lfs f5, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 823FF8F8: 48000010  b 0x823ff908
	pc = 0x823FF908; continue 'dispatch;
            }
            0x823FF8FC => {
    //   block [0x823FF8FC..0x823FF908)
	// 823FF8FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 823FF900: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 823FF904: C0AA1850  lfs f5, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	pc = 0x823FF908; continue 'dispatch;
            }
            0x823FF908 => {
    //   block [0x823FF908..0x823FF970)
	// 823FF908: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 823FF90C: 38E30068  addi r7, r3, 0x68
	ctx.r[7].s64 = ctx.r[3].s64 + 104;
	// 823FF910: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 823FF914: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 823FF918: C0830020  lfs f4, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 823FF91C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 823FF920: C063001C  lfs f3, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 823FF924: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FF928: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FF92C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 823FF930: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FF934: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 823FF938: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF93C: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 823FF940: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 823FF944: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 823FF948: 48000721  bl 0x82400068
	ctx.lr = 0x823FF94C;
	sub_82400068(ctx, base);
	// 823FF94C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FF950: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 823FF954: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 823FF958: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 823FF95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FF960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FF964: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FF968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FF96C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FF970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FF970 size=1140
    let mut pc: u32 = 0x823FF970;
    'dispatch: loop {
        match pc {
            0x823FF970 => {
    //   block [0x823FF970..0x823FF9E0)
	// 823FF970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FF974: 48135731  bl 0x825350a4
	ctx.lr = 0x823FF978;
	sub_82535080(ctx, base);
	// 823FF978: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FF97C: 4813666D  bl 0x82535fe8
	ctx.lr = 0x823FF980;
	sub_82535FB0(ctx, base);
	// 823FF980: 9421FCD0  stwu r1, -0x330(r1)
	ea = ctx.r[1].u32.wrapping_add(-816 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FF984: 3F608288  lis r27, -0x7d78
	ctx.r[27].s64 = -2105016320;
	// 823FF988: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 823FF98C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 823FF990: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 823FF994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FF998: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 823FF99C: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 823FF9A0: 817B37B0  lwz r11, 0x37b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FF9A4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 823FF9A8: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 823FF9AC: 3B3E090C  addi r25, r30, 0x90c
	ctx.r[25].s64 = ctx.r[30].s64 + 2316;
	// 823FF9B0: 3B5E0808  addi r26, r30, 0x808
	ctx.r[26].s64 = ctx.r[30].s64 + 2056;
	// 823FF9B4: 38A0090C  li r5, 0x90c
	ctx.r[5].s64 = 2316;
	// 823FF9B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FF9BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 823FF9C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FF9C4: 4E800421  bctrl
	ctx.lr = 0x823FF9C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FF9C8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FF9CC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 823FF9D0: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 823FF9D4: 3CE08273  lis r7, -0x7d8d
	ctx.r[7].s64 = -2106392576;
	// 823FF9D8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 823FF9DC: C1A9BFFC  lfs f13, -0x4004(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            0x823FF9E0 => {
    //   block [0x823FF9E0..0x823FFA3C)
	// 823FF9E0: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FF9E4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 823FF9E8: C008AC38  lfs f0, -0x53c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-21448 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FF9EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FF9F0: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 823FF9F4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 823FF9F8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 823FF9FC: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 823FFA00: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FFA04: 552615BA  rlwinm r6, r9, 2, 0x16, 0x1d
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 823FFA08: 8127D6E0  lwz r9, -0x2920(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10528 as u32) ) } as u64;
	// 823FFA0C: 7C064C2E  lfsx f0, r6, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFA10: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFA14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFA18: 4082FFC8  bne 0x823ff9e0
	if !ctx.cr[0].eq {
	pc = 0x823FF9E0; continue 'dispatch;
	}
	// 823FFA1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FFA20: 38BE00E0  addi r5, r30, 0xe0
	ctx.r[5].s64 = ctx.r[30].s64 + 224;
	// 823FFA24: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 823FFA28: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FFA2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FFA30: C3CB1850  lfs f30, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 823FFA34: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 823FFA38: D3C50000  stfs f30, 0(r5)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FFA3C; continue 'dispatch;
            }
            0x823FFA3C => {
    //   block [0x823FFA3C..0x823FFA70)
	// 823FFA3C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 823FFA40: 7C0AF42E  lfsx f0, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFA44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 823FFA48: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FFA4C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 823FFA50: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 823FFA54: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 823FFA58: D1A80004  stfs f13, 4(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 823FFA5C: 41980034  blt cr6, 0x823ffa90
	if ctx.cr[6].lt {
	pc = 0x823FFA90; continue 'dispatch;
	}
	// 823FFA60: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 823FFA64: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 823FFA68: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 823FFA6C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x823FFA70; continue 'dispatch;
            }
            0x823FFA70 => {
    //   block [0x823FFA70..0x823FFA90)
	// 823FFA70: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFA74: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FFA78: 7D84442E  lfsx f12, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFA7C: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 823FFA80: EDAD603C  fnmsubs f13, f13, f0, f12
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 823FFA84: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFA88: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FFA8C: 4082FFE4  bne 0x823ffa70
	if !ctx.cr[0].eq {
	pc = 0x823FFA70; continue 'dispatch;
	}
	pc = 0x823FFA90; continue 'dispatch;
            }
            0x823FFA90 => {
    //   block [0x823FFA90..0x823FFAB4)
	// 823FFA90: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFA94: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 823FFA98: 2F0A0030  cmpwi cr6, r10, 0x30
	ctx.cr[6].compare_i32(ctx.r[10].s32, 48, &mut ctx.xer);
	// 823FFA9C: 4198FFA0  blt cr6, 0x823ffa3c
	if ctx.cr[6].lt {
	pc = 0x823FFA3C; continue 'dispatch;
	}
	// 823FFAA0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FFAA4: 7D3D2850  subf r9, r29, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 823FFAA8: 7D1DF050  subf r8, r29, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 823FFAAC: 7CFDE050  subf r7, r29, r28
	ctx.r[7].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 823FFAB0: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	pc = 0x823FFAB4; continue 'dispatch;
            }
            0x823FFAB4 => {
    //   block [0x823FFAB4..0x823FFAE8)
	// 823FFAB4: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFAB8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFABC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFAC0: 7C085C2E  lfsx f0, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFAC4: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 823FFAC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFACC: 4082FFE8  bne 0x823ffab4
	if !ctx.cr[0].eq {
	pc = 0x823FFAB4; continue 'dispatch;
	}
	// 823FFAD0: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 823FFAD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 823FFAD8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 823FFADC: 7CDF2850  subf r6, r31, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 823FFAE0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 823FFAE4: D3BF0000  stfs f29, 0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x823FFAE8; continue 'dispatch;
            }
            0x823FFAE8 => {
    //   block [0x823FFAE8..0x823FFB1C)
	// 823FFAE8: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 823FFAEC: 7C0A342E  lfsx f0, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFAF0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 823FFAF4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 823FFAF8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 823FFAFC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 823FFB00: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 823FFB04: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFB08: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 823FFB0C: 4099002C  ble cr6, 0x823ffb38
	if !ctx.cr[6].gt {
	pc = 0x823FFB38; continue 'dispatch;
	}
	// 823FFB10: 39050004  addi r8, r5, 4
	ctx.r[8].s64 = ctx.r[5].s64 + 4;
	// 823FFB14: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 823FFB18: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	pc = 0x823FFB1C; continue 'dispatch;
            }
            0x823FFB1C => {
    //   block [0x823FFB1C..0x823FFB38)
	// 823FFB1C: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFB20: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 823FFB24: C1870000  lfs f12, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFB28: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 823FFB2C: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FFB30: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 823FFB34: 4082FFE8  bne 0x823ffb1c
	if !ctx.cr[0].eq {
	pc = 0x823FFB1C; continue 'dispatch;
	}
	pc = 0x823FFB38; continue 'dispatch;
            }
            0x823FFB38 => {
    //   block [0x823FFB38..0x823FFB6C)
	// 823FFB38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 823FFB3C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFB40: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFB44: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 823FFB48: 4099FFA0  ble cr6, 0x823ffae8
	if !ctx.cr[6].gt {
	pc = 0x823FFAE8; continue 'dispatch;
	}
	// 823FFB4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 823FFB50: 2F0B002B  cmpwi cr6, r11, 0x2b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 43, &mut ctx.xer);
	// 823FFB54: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 823FFB58: 41990050  bgt cr6, 0x823ffba8
	if ctx.cr[6].gt {
	pc = 0x823FFBA8; continue 'dispatch;
	}
	// 823FFB5C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 823FFB60: 38E50004  addi r7, r5, 4
	ctx.r[7].s64 = ctx.r[5].s64 + 4;
	// 823FFB64: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 823FFB68: 20CB002C  subfic r6, r11, 0x2c
	ctx.xer.ca = ctx.r[11].u32 <= 44 as u32;
	ctx.r[6].s64 = (44 as i64) - ctx.r[11].s64;
	pc = 0x823FFB6C; continue 'dispatch;
            }
            0x823FFB6C => {
    //   block [0x823FFB6C..0x823FFB7C)
	// 823FFB6C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FFB70: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 823FFB74: 390AFFFC  addi r8, r10, -4
	ctx.r[8].s64 = ctx.r[10].s64 + -4;
	// 823FFB78: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	pc = 0x823FFB7C; continue 'dispatch;
            }
            0x823FFB7C => {
    //   block [0x823FFB7C..0x823FFBA8)
	// 823FFB7C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFB80: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FFB84: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFB88: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FFB8C: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 823FFB90: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 823FFB94: 4082FFE8  bne 0x823ffb7c
	if !ctx.cr[0].eq {
	pc = 0x823FFB7C; continue 'dispatch;
	}
	// 823FFB98: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFB9C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 823FFBA0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 823FFBA4: 4082FFC8  bne 0x823ffb6c
	if !ctx.cr[0].eq {
	pc = 0x823FFB6C; continue 'dispatch;
	}
	pc = 0x823FFBA8; continue 'dispatch;
            }
            0x823FFBA8 => {
    //   block [0x823FFBA8..0x823FFBBC)
	// 823FFBA8: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 823FFBAC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 823FFBB0: 814AD6EC  lwz r10, -0x2914(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10516 as u32) ) } as u64;
	// 823FFBB4: 7D3F5050  subf r9, r31, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[31].s64;
	// 823FFBB8: 3940002B  li r10, 0x2b
	ctx.r[10].s64 = 43;
	pc = 0x823FFBBC; continue 'dispatch;
            }
            0x823FFBBC => {
    //   block [0x823FFBBC..0x823FFC38)
	// 823FFBBC: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFBC0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFBC4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFBC8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFBCC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFBD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFBD4: 4082FFE8  bne 0x823ffbbc
	if !ctx.cr[0].eq {
	pc = 0x823FFBBC; continue 'dispatch;
	}
	// 823FFBD8: 817B37B0  lwz r11, 0x37b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FFBDC: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FFBE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FFBE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FFBE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFBEC: 4E800421  bctrl
	ctx.lr = 0x823FFBF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFBF0: 817B37B0  lwz r11, 0x37b0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14256 as u32) ) } as u64;
	// 823FFBF4: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 823FFBF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 823FFBFC: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 823FFC00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFC04: 4E800421  bctrl
	ctx.lr = 0x823FFC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFC08: 3C808201  lis r4, -0x7dff
	ctx.r[4].s64 = -2113863680;
	// 823FFC0C: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 823FFC10: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFC14: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 823FFC18: 396101B0  addi r11, r1, 0x1b0
	ctx.r[11].s64 = ctx.r[1].s64 + 432;
	// 823FFC1C: 38C1015C  addi r6, r1, 0x15c
	ctx.r[6].s64 = ctx.r[1].s64 + 348;
	// 823FFC20: 394102AC  addi r10, r1, 0x2ac
	ctx.r[10].s64 = ctx.r[1].s64 + 684;
	// 823FFC24: C1A4A624  lfs f13, -0x59dc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-23004 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFC28: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 823FFC2C: C005A620  lfs f0, -0x59e0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-23008 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFC30: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 823FFC34: 39000015  li r8, 0x15
	ctx.r[8].s64 = 21;
            }
            0x823FFC38 => {
    //   block [0x823FFC38..0x823FFCB4)
	// 823FFC38: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFC3C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FFC40: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFC44: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC48: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFC4C: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC50: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 823FFC54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFC58: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFC5C: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 823FFC60: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFC64: D1670000  stfs f11, 0(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC68: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFC6C: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 823FFC74: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 823FFC78: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 823FFC7C: 4082FFBC  bne 0x823ffc38
	if !ctx.cr[0].eq {
	pc = 0x823FFC38; continue 'dispatch;
	}
	// 823FFC80: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFC84: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 823FFC88: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFC8C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFC90: 388101B0  addi r4, r1, 0x1b0
	ctx.r[4].s64 = ctx.r[1].s64 + 432;
	// 823FFC94: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 823FFC98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 823FFC9C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFCA0: 4BFFDDA1  bl 0x823fda40
	ctx.lr = 0x823FFCA4;
	sub_823FDA40(ctx, base);
	// 823FFCA4: 7D7EC850  subf r11, r30, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 823FFCA8: 39400041  li r10, 0x41
	ctx.r[10].s64 = 65;
	// 823FFCAC: 396BF6F4  addi r11, r11, -0x90c
	ctx.r[11].s64 = ctx.r[11].s64 + -2316;
	// 823FFCB0: 7D39D050  subf r9, r25, r26
	ctx.r[9].s64 = ctx.r[26].s64 - ctx.r[25].s64;
	pc = 0x823FFCB4; continue 'dispatch;
            }
            0x823FFCB4 => {
    //   block [0x823FFCB4..0x823FFD0C)
	// 823FFCB4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 823FFCB8: 38E101B0  addi r7, r1, 0x1b0
	ctx.r[7].s64 = ctx.r[1].s64 + 432;
	// 823FFCBC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFCC0: 7C0B442E  lfsx f0, r11, r8
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFCC4: 7DAB3C2E  lfsx f13, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFCC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFCCC: 7C09CD2E  stfsx f0, r9, r25
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 823FFCD0: D1B90000  stfs f13, 0(r25)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFCD4: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 823FFCD8: 4181FFDC  bgt 0x823ffcb4
	if ctx.cr[0].gt {
	pc = 0x823FFCB4; continue 'dispatch;
	}
	// 823FFCDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 823FFCE0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 823FFCE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 823FFCE8: 48001E89  bl 0x82401b70
	ctx.lr = 0x823FFCEC;
	sub_82401B70(ctx, base);
	// 823FFCEC: FC00F890  fmr f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64;
	// 823FFCF0: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 823FFCF4: FF1CF000  fcmpu cr6, f28, f30
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[30].f64);
	// 823FFCF8: 409A0014  bne cr6, 0x823ffd0c
	if !ctx.cr[6].eq {
	pc = 0x823FFD0C; continue 'dispatch;
	}
	// 823FFCFC: 7EEB0735  extsh. r11, r23
	ctx.r[11].s64 = ctx.r[23].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FFD00: 4082000C  bne 0x823ffd0c
	if !ctx.cr[0].eq {
	pc = 0x823FFD0C; continue 'dispatch;
	}
	// 823FFD04: 7F0B0735  extsh. r11, r24
	ctx.r[11].s64 = ctx.r[24].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 823FFD08: 418200CC  beq 0x823ffdd4
	if ctx.cr[0].eq {
	pc = 0x823FFDD4; continue 'dispatch;
	}
	pc = 0x823FFD0C; continue 'dispatch;
            }
            0x823FFD0C => {
    //   block [0x823FFD0C..0x823FFD1C)
	// 823FFD0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 823FFD10: 7F060734  extsh r6, r24
	ctx.r[6].s64 = ctx.r[24].s16 as i64;
	// 823FFD14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 823FFD18: 7CFED050  subf r7, r30, r26
	ctx.r[7].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	pc = 0x823FFD1C; continue 'dispatch;
            }
            0x823FFD1C => {
    //   block [0x823FFD1C..0x823FFD70)
	// 823FFD1C: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 823FFD20: 41980058  blt cr6, 0x823ffd78
	if ctx.cr[6].lt {
	pc = 0x823FFD78; continue 'dispatch;
	}
	// 823FFD24: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 823FFD28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 823FFD2C: 7EE80734  extsh r8, r23
	ctx.r[8].s64 = ctx.r[23].s16 as i64;
	// 823FFD30: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 823FFD34: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 823FFD38: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 823FFD3C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 823FFD40: ED8C0732  fmuls f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 823FFD44: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 823FFD48: 7D802FAE  stfiwx f12, 0, r5
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32, tmp.u32) };
	// 823FFD4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 823FFD50: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 823FFD54: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 823FFD58: 2F0A0040  cmpwi cr6, r10, 0x40
	ctx.cr[6].compare_i32(ctx.r[10].s32, 64, &mut ctx.xer);
	// 823FFD5C: 7D88D42E  lfsx f12, r8, r26
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD60: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFD64: 4199000C  bgt cr6, 0x823ffd70
	if ctx.cr[6].gt {
	pc = 0x823FFD70; continue 'dispatch;
	}
	// 823FFD68: 7D88D42E  lfsx f12, r8, r26
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD6C: 48000010  b 0x823ffd7c
	pc = 0x823FFD7C; continue 'dispatch;
            }
            0x823FFD70 => {
    //   block [0x823FFD70..0x823FFD78)
	// 823FFD70: C19A0100  lfs f12, 0x100(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD74: 48000008  b 0x823ffd7c
	pc = 0x823FFD7C; continue 'dispatch;
            }
            0x823FFD78 => {
    //   block [0x823FFD78..0x823FFD7C)
	// 823FFD78: 7D875C2E  lfsx f12, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x823FFD7C; continue 'dispatch;
            }
            0x823FFD7C => {
    //   block [0x823FFD7C..0x823FFDBC)
	// 823FFD7C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFD80: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FFD84: 7D875C2E  lfsx f12, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 823FFD88: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FFD8C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FFD90: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 823FFD94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFD98: 2F090041  cmpwi cr6, r9, 0x41
	ctx.cr[6].compare_i32(ctx.r[9].s32, 65, &mut ctx.xer);
	// 823FFD9C: 4198FF80  blt cr6, 0x823ffd1c
	if ctx.cr[6].lt {
	pc = 0x823FFD1C; continue 'dispatch;
	}
	// 823FFDA0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 823FFDA4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 823FFDA8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 823FFDAC: 7D1AF050  subf r8, r26, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 823FFDB0: 39400041  li r10, 0x41
	ctx.r[10].s64 = 65;
	// 823FFDB4: C0092454  lfs f0, 0x2454(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFDB8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x823FFDBC; continue 'dispatch;
            }
            0x823FFDBC => {
    //   block [0x823FFDBC..0x823FFDD4)
	// 823FFDBC: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 823FFDC0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 823FFDC4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 823FFDC8: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 823FFDCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 823FFDD0: 4082FFEC  bne 0x823ffdbc
	if !ctx.cr[0].eq {
	pc = 0x823FFDBC; continue 'dispatch;
	}
	pc = 0x823FFDD4; continue 'dispatch;
            }
            0x823FFDD4 => {
    //   block [0x823FFDD4..0x823FFDE4)
	// 823FFDD4: 38210330  addi r1, r1, 0x330
	ctx.r[1].s64 = ctx.r[1].s64 + 816;
	// 823FFDD8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 823FFDDC: 48136259  bl 0x82536034
	ctx.lr = 0x823FFDE0;
	sub_82535FFC(ctx, base);
	// 823FFDE0: 48135314  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FFDE8 size=252
    let mut pc: u32 = 0x823FFDE8;
    'dispatch: loop {
        match pc {
            0x823FFDE8 => {
    //   block [0x823FFDE8..0x823FFE6C)
	// 823FFDE8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 823FFDEC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 823FFDF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 823FFDF4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 823FFDF8: 83C3000C  lwz r30, 0xc(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 823FFDFC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE00: A0C30004  lhz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 823FFE04: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE08: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 823FFE0C: 7D4A2830  slw r10, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFE10: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 823FFE14: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE18: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 823FFE1C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 823FFE20: 7CE82A14  add r7, r8, r5
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 823FFE24: 54E50039  rlwinm. r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 823FFE28: 41820068  beq 0x823ffe90
	if ctx.cr[0].eq {
	pc = 0x823FFE90; continue 'dispatch;
	}
	// 823FFE2C: 88A90000  lbz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE30: 54C6043E  clrlwi r6, r6, 0x10
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 823FFE34: 21080008  subfic r8, r8, 8
	ctx.xer.ca = ctx.r[8].u32 <= 8 as u32;
	ctx.r[8].s64 = (8 as i64) - ctx.r[8].s64;
	// 823FFE38: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 823FFE3C: 7CAA5430  srw r10, r5, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[5].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFE40: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FFE44: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FFE4C: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823FFE50: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 823FFE54: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 823FFE58: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823FFE5C: 41980010  blt cr6, 0x823ffe6c
	if ctx.cr[6].lt {
	pc = 0x823FFE6C; continue 'dispatch;
	}
	// 823FFE60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 823FFE64: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823FFE68: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x823FFE6C; continue 'dispatch;
            }
            0x823FFE6C => {
    //   block [0x823FFE6C..0x823FFE90)
	// 823FFE6C: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE70: 7FE94630  sraw r9, r31, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[31].s32 >> tmp.u32) as i64;
	// 823FFE74: 89440000  lbz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE78: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 823FFE7C: 7D2B5838  and r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 823FFE80: 7D6B4030  slw r11, r11, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFE84: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 823FFE88: 99640000  stb r11, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 823FFE8C: 48000048  b 0x823ffed4
	pc = 0x823FFED4; continue 'dispatch;
            }
            0x823FFE90 => {
    //   block [0x823FFE90..0x823FFED4)
	// 823FFE90: 89290000  lbz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFE94: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 823FFE98: 2F070008  cmpwi cr6, r7, 8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 8, &mut ctx.xer);
	// 823FFE9C: 7D2A5430  srw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) >> ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 823FFEA0: 7D4A4038  and r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 823FFEA4: 99440000  stb r10, 0(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 823FFEA8: 409A002C  bne cr6, 0x823ffed4
	if !ctx.cr[6].eq {
	pc = 0x823FFED4; continue 'dispatch;
	}
	// 823FFEAC: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFEB0: 54C9043E  clrlwi r9, r6, 0x10
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 823FFEB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 823FFEB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 823FFEBC: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 823FFEC0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 823FFEC4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 823FFEC8: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 823FFECC: 41980008  blt cr6, 0x823ffed4
	if ctx.cr[6].lt {
	pc = 0x823FFED4; continue 'dispatch;
	}
	// 823FFED0: B0EB0000  sth r7, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	pc = 0x823FFED4; continue 'dispatch;
            }
            0x823FFED4 => {
    //   block [0x823FFED4..0x823FFEE4)
	// 823FFED4: 98FE0000  stb r7, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 823FFED8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FFEDC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 823FFEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x823FFEE8 size=124
    let mut pc: u32 = 0x823FFEE8;
    'dispatch: loop {
        match pc {
            0x823FFEE8 => {
    //   block [0x823FFEE8..0x823FFF38)
	// 823FFEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FFEEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FFEF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 823FFEF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FFEF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FFEFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FFF00: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 823FFF04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 823FFF08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 823FFF0C: 419A0040  beq cr6, 0x823fff4c
	if ctx.cr[6].eq {
	pc = 0x823FFF4C; continue 'dispatch;
	}
	// 823FFF10: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FFF14: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 823FFF18: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 823FFF1C: 816B37A8  lwz r11, 0x37a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14248 as u32) ) } as u64;
	// 823FFF20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFF24: 4E800421  bctrl
	ctx.lr = 0x823FFF28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFF28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FFF2C: 4082000C  bne 0x823fff38
	if !ctx.cr[0].eq {
	pc = 0x823FFF38; continue 'dispatch;
	}
	// 823FFF30: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 823FFF34: 48000014  b 0x823fff48
	pc = 0x823FFF48; continue 'dispatch;
            }
            0x823FFF38 => {
    //   block [0x823FFF38..0x823FFF48)
	// 823FFF38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 823FFF3C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 823FFF40: C00B0828  lfs f0, 0x828(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFF44: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x823FFF48; continue 'dispatch;
            }
            0x823FFF48 => {
    //   block [0x823FFF48..0x823FFF4C)
	// 823FFF48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x823FFF4C; continue 'dispatch;
            }
            0x823FFF4C => {
    //   block [0x823FFF4C..0x823FFF64)
	// 823FFF4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 823FFF50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FFF54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FFF58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 823FFF5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FFF60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x823FFF68 size=76
    let mut pc: u32 = 0x823FFF68;
    'dispatch: loop {
        match pc {
            0x823FFF68 => {
    //   block [0x823FFF68..0x823FFFA0)
	// 823FFF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 823FFF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 823FFF70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 823FFF74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 823FFF78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 823FFF7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 823FFF80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 823FFF84: 4182001C  beq 0x823fffa0
	if ctx.cr[0].eq {
	pc = 0x823FFFA0; continue 'dispatch;
	}
	// 823FFF88: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 823FFF8C: 816B37AC  lwz r11, 0x37ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14252 as u32) ) } as u64;
	// 823FFF90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 823FFF94: 4E800421  bctrl
	ctx.lr = 0x823FFF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 823FFF98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FFF9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x823FFFA0 => {
    //   block [0x823FFFA0..0x823FFFB4)
	// 823FFFA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 823FFFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 823FFFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 823FFFAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 823FFFB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_823FFFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x823FFFB8 size=172
    let mut pc: u32 = 0x823FFFB8;
    'dispatch: loop {
        match pc {
            0x823FFFB8 => {
    //   block [0x823FFFB8..0x823FFFF4)
	// 823FFFB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 823FFFBC: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 823FFFC0: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 823FFFC4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FFFC8: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 823FFFCC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 823FFFD0: C00B246C  lfs f0, 0x246c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFFD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 823FFFD8: ED820032  fmuls f12, f2, f0
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 823FFFDC: C009A660  lfs f0, -0x59a0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 823FFFE0: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 823FFFE4: 7D8047AE  stfiwx f12, 0, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 823FFFE8: 40990050  ble cr6, 0x82400038
	if !ctx.cr[6].gt {
	pc = 0x82400038; continue 'dispatch;
	}
	// 823FFFEC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 823FFFF0: C189A65C  lfs f12, -0x59a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22948 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x823FFFF4; continue 'dispatch;
            }
            0x823FFFF4 => {
    //   block [0x823FFFF4..0x82400014)
	// 823FFFF4: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 823FFFF8: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 823FFFFC: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400000: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400004: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82400008: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 8240000C: 41980008  blt cr6, 0x82400014
	if ctx.cr[6].lt {
	pc = 0x82400014; continue 'dispatch;
	}
	// 82400010: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	pc = 0x82400014; continue 'dispatch;
            }
            0x82400014 => {
    //   block [0x82400014..0x82400028)
	// 82400014: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82400018: 40820010  bne 0x82400028
	if !ctx.cr[0].eq {
	pc = 0x82400028; continue 'dispatch;
	}
	// 8240001C: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400020: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400024: D16A0000  stfs f11, 0(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82400028; continue 'dispatch;
            }
            0x82400028 => {
    //   block [0x82400028..0x82400038)
	// 82400028: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8240002C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400030: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82400034: 4198FFC0  blt cr6, 0x823ffff4
	if ctx.cr[6].lt {
	pc = 0x823FFFF4; continue 'dispatch;
	}
	pc = 0x82400038; continue 'dispatch;
            }
            0x82400038 => {
    //   block [0x82400038..0x82400064)
	// 82400038: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 8240003C: 7D6A1671  srawi. r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82400040: 4C810020  blelr
	if !ctx.cr[0].gt { return; }
	// 82400044: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


