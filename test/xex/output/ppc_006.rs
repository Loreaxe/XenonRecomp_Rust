pub fn sub_821A1B64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1B64 size=200
    let mut pc: u32 = 0x821A1B64;
    'dispatch: loop {
        match pc {
            0x821A1B64 => {
    //   block [0x821A1B64..0x821A1B8C)
	// 821A1B64: 3943180B  addi r10, r3, 0x180b
	ctx.r[10].s64 = ctx.r[3].s64 + 6155;
	// 821A1B68: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 821A1B6C: 55490028  rlwinm r9, r10, 0, 0, 0x14
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1B70: 7CC32A14  add r6, r3, r5
	ctx.r[6].u64 = ctx.r[3].u64 + ctx.r[5].u64;
	// 821A1B74: 7D092A14  add r8, r9, r5
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 821A1B78: 39400400  li r10, 0x400
	ctx.r[10].s64 = 1024;
	// 821A1B7C: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A1B80: 41980030  blt cr6, 0x821a1bb0
	if ctx.cr[6].lt {
	pc = 0x821A1BB0; continue 'dispatch;
	}
	// 821A1B84: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821A1B88: 3903180B  addi r8, r3, 0x180b
	ctx.r[8].s64 = ctx.r[3].s64 + 6155;
	pc = 0x821A1B8C; continue 'dispatch;
            }
            0x821A1B8C => {
    //   block [0x821A1B8C..0x821A1BB0)
	// 821A1B8C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 821A1B90: 38E7F800  addi r7, r7, -0x800
	ctx.r[7].s64 = ctx.r[7].s64 + -2048;
	// 821A1B94: 55090028  rlwinm r9, r8, 0, 0, 0x14
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1B98: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1B9C: 7C874A14  add r4, r7, r9
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A1BA0: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821A1BA4: 4098FFE8  bge cr6, 0x821a1b8c
	if !ctx.cr[6].lt {
	pc = 0x821A1B8C; continue 'dispatch;
	}
	// 821A1BA8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821A1BAC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	pc = 0x821A1BB0; continue 'dispatch;
            }
            0x821A1BB0 => {
    //   block [0x821A1BB0..0x821A1C1C)
	// 821A1BB0: 38E00800  li r7, 0x800
	ctx.r[7].s64 = 2048;
	// 821A1BB4: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 821A1BB8: 38C3000C  addi r6, r3, 0xc
	ctx.r[6].s64 = ctx.r[3].s64 + 12;
	// 821A1BBC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821A1BC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A1BC4: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 821A1BC8: 906B0020  stw r3, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 821A1BCC: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821A1BD0: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A1BD4: 90CB002C  stw r6, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 821A1BD8: 3CC07379  lis r6, 0x7379
	ctx.r[6].s64 = 1937309696;
	// 821A1BDC: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A1BE0: 3CE0656D  lis r7, 0x656d
	ctx.r[7].s64 = 1701642240;
	// 821A1BE4: 60C6736D  ori r6, r6, 0x736d
	ctx.r[6].u64 = ctx.r[6].u64 | 29549;
	// 821A1BE8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1BEC: 60E75F6F  ori r7, r7, 0x5f6f
	ctx.r[7].u64 = ctx.r[7].u64 | 24431;
	// 821A1BF0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A1BF4: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821A1BF8: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A1BFC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A1C00: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A1C04: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 821A1C08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1C0C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821A1C10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A1C14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821A1C18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821A1C1C; continue 'dispatch;
            }
            0x821A1C1C => {
    //   block [0x821A1C1C..0x821A1C2C)
	// 821A1C1C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1C20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A1C24: 4200FFF8  bdnz 0x821a1c1c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A1C1C; continue 'dispatch;
	}
	// 821A1C28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1C30 size=1100
    let mut pc: u32 = 0x821A1C30;
    'dispatch: loop {
        match pc {
            0x821A1C30 => {
    //   block [0x821A1C30..0x821A1C5C)
	// 821A1C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1C34: 4839347D  bl 0x825350b0
	ctx.lr = 0x821A1C38;
	sub_82535080(ctx, base);
	// 821A1C38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A1C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A1C44: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A1C48: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821A1C4C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A1C50: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A1C54: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821A1C58: 409A0010  bne cr6, 0x821a1c68
	if !ctx.cr[6].eq {
	pc = 0x821A1C68; continue 'dispatch;
	}
	pc = 0x821A1C5C; continue 'dispatch;
            }
            0x821A1C5C => {
    //   block [0x821A1C5C..0x821A1C68)
	// 821A1C5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A1C60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1C64: 4839349C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1C68 => {
    //   block [0x821A1C68..0x821A1CB4)
	// 821A1C68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1C6C: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1C70: 4199FFEC  bgt cr6, 0x821a1c5c
	if ctx.cr[6].gt {
	pc = 0x821A1C5C; continue 'dispatch;
	}
	// 821A1C74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1C78: 3946FFFF  addi r10, r6, -1
	ctx.r[10].s64 = ctx.r[6].s64 + -1;
	// 821A1C7C: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821A1C80: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A1C84: 7D2B41D6  mullw r9, r11, r8
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A1C88: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821A1C8C: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821A1C90: 7CFE5078  andc r30, r7, r10
	ctx.r[30].u64 = ctx.r[7].u64 & !ctx.r[10].u64;
	// 821A1C94: 7D49F050  subf r10, r9, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 821A1C98: 7FAA2214  add r29, r10, r4
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821A1C9C: 7D5D5B96  divwu r10, r29, r11
	ctx.r[10].u32 = ctx.r[29].u32 / ctx.r[11].u32;
	// 821A1CA0: 7D3D5B96  divwu r9, r29, r11
	ctx.r[9].u32 = ctx.r[29].u32 / ctx.r[11].u32;
	// 821A1CA4: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A1CA8: 7D6BE851  subf. r11, r11, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1CAC: 41820008  beq 0x821a1cb4
	if ctx.cr[0].eq {
	pc = 0x821A1CB4; continue 'dispatch;
	}
	// 821A1CB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	pc = 0x821A1CB4; continue 'dispatch;
            }
            0x821A1CB4 => {
    //   block [0x821A1CB4..0x821A1D28)
	// 821A1CB4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1CB8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1CBC: 409901EC  ble cr6, 0x821a1ea8
	if !ctx.cr[6].gt {
	pc = 0x821A1EA8; continue 'dispatch;
	}
	// 821A1CC0: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821A1CC4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A1CC8: 3BCB0C40  addi r30, r11, 0xc40
	ctx.r[30].s64 = ctx.r[11].s64 + 3136;
	// 821A1CCC: 817E0688  lwz r11, 0x688(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821A1CD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A1CD4: 419A0054  beq cr6, 0x821a1d28
	if ctx.cr[6].eq {
	pc = 0x821A1D28; continue 'dispatch;
	}
	// 821A1CD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1CDC: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1CE4: 409A0044  bne cr6, 0x821a1d28
	if !ctx.cr[6].eq {
	pc = 0x821A1D28; continue 'dispatch;
	}
	// 821A1CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1CEC: 4800051D  bl 0x821a2208
	ctx.lr = 0x821A1CF0;
	sub_821A2208(ctx, base);
	// 821A1CF0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1CF4: 817E0688  lwz r11, 0x688(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821A1CF8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821A1CFC: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821A1D00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A1D04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821A1D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1D0C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821A1D10: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A1D14: 4BFFFF1D  bl 0x821a1c30
	ctx.lr = 0x821A1D18;
	sub_821A1C30(ctx, base);
	// 821A1D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1D1C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821A1D20: 6D6B8000  xoris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 ^ 2147483648;
	// 821A1D24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821A1D28; continue 'dispatch;
            }
            0x821A1D28 => {
    //   block [0x821A1D28..0x821A1D48)
	// 821A1D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1D2C: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A1D30: 419A0344  beq cr6, 0x821a2074
	if ctx.cr[6].eq {
	pc = 0x821A2074; continue 'dispatch;
	}
	// 821A1D34: 2B1D0100  cmplwi cr6, r29, 0x100
	ctx.cr[6].compare_u32(ctx.r[29].u32, 256 as u32, &mut ctx.xer);
	// 821A1D38: 40980010  bge cr6, 0x821a1d48
	if !ctx.cr[6].lt {
	pc = 0x821A1D48; continue 'dispatch;
	}
	// 821A1D3C: 7C001A2C  dcbt 0, r3
	// 821A1D40: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1D44: 483933BC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1D48 => {
    //   block [0x821A1D48..0x821A1D58)
	// 821A1D48: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 821A1D4C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1D50: 41980008  blt cr6, 0x821a1d58
	if ctx.cr[6].lt {
	pc = 0x821A1D58; continue 'dispatch;
	}
	// 821A1D54: 3FA00004  lis r29, 4
	ctx.r[29].s64 = 262144;
	pc = 0x821A1D58; continue 'dispatch;
            }
            0x821A1D58 => {
    //   block [0x821A1D58..0x821A1D7C)
	// 821A1D58: 3963007F  addi r11, r3, 0x7f
	ctx.r[11].s64 = ctx.r[3].s64 + 127;
	// 821A1D5C: 7D5D1A14  add r10, r29, r3
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[3].u64;
	// 821A1D60: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1D64: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1D68: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A1D6C: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1D70: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A1D74: 419A0008  beq cr6, 0x821a1d7c
	if ctx.cr[6].eq {
	pc = 0x821A1D7C; continue 'dispatch;
	}
	// 821A1D78: 7C001A2C  dcbt 0, r3
	pc = 0x821A1D7C; continue 'dispatch;
            }
            0x821A1D7C => {
    //   block [0x821A1D7C..0x821A1D88)
	// 821A1D7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A1D80: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1D84: 41980084  blt cr6, 0x821a1e08
	if ctx.cr[6].lt {
	pc = 0x821A1E08; continue 'dispatch;
	}
	pc = 0x821A1D88; continue 'dispatch;
            }
            0x821A1D88 => {
    //   block [0x821A1D88..0x821A1E08)
	// 821A1D88: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A1D8C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1D90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1D94: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A1D98: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1D9C: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A1DA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DA4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DA8: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A1DAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DB0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DB4: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A1DB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DBC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DC0: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A1DC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DC8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DCC: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A1DD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DD4: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DD8: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 821A1DDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DE0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1DE4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A1DE8: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 821A1DEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1DF0: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 821A1DF4: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1DF8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A1DFC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821A1E00: 4098FF88  bge cr6, 0x821a1d88
	if !ctx.cr[6].lt {
	pc = 0x821A1D88; continue 'dispatch;
	}
	// 821A1E04: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x821A1E08; continue 'dispatch;
            }
            0x821A1E08 => {
    //   block [0x821A1E08..0x821A1E4C)
	// 821A1E08: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821A1E0C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1E10: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 821A1E14: 41990260  bgt cr6, 0x821a2074
	if ctx.cr[6].gt {
	pc = 0x821A2074; continue 'dispatch;
	}
	// 821A1E18: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A1E1C: 398C1E30  addi r12, r12, 0x1e30
	ctx.r[12].s64 = ctx.r[12].s64 + 7728;
	// 821A1E20: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A1E24: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A1E28: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A1E2C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821A2068; continue 'dispatch;
		},
		1 => {
	pc = 0x821A1E88; continue 'dispatch;
		},
		2 => {
	pc = 0x821A1E7C; continue 'dispatch;
		},
		3 => {
	pc = 0x821A1E70; continue 'dispatch;
		},
		4 => {
	pc = 0x821A1E64; continue 'dispatch;
		},
		5 => {
	pc = 0x821A1E58; continue 'dispatch;
		},
		6 => {
	pc = 0x821A1E4C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A1E30: 821A2068  lwz r16, 0x2068(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8296 as u32) ) } as u64;
	// 821A1E34: 821A1E88  lwz r16, 0x1e88(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7816 as u32) ) } as u64;
	// 821A1E38: 821A1E7C  lwz r16, 0x1e7c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7804 as u32) ) } as u64;
	// 821A1E3C: 821A1E70  lwz r16, 0x1e70(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7792 as u32) ) } as u64;
	// 821A1E40: 821A1E64  lwz r16, 0x1e64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7780 as u32) ) } as u64;
	// 821A1E44: 821A1E58  lwz r16, 0x1e58(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7768 as u32) ) } as u64;
	// 821A1E48: 821A1E4C  lwz r16, 0x1e4c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(7756 as u32) ) } as u64;
            }
            0x821A1E4C => {
    //   block [0x821A1E4C..0x821A1E58)
	// 821A1E4C: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A1E50: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E58; continue 'dispatch;
            }
            0x821A1E58 => {
    //   block [0x821A1E58..0x821A1E64)
	// 821A1E58: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A1E5C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E64; continue 'dispatch;
            }
            0x821A1E64 => {
    //   block [0x821A1E64..0x821A1E70)
	// 821A1E64: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A1E68: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E70; continue 'dispatch;
            }
            0x821A1E70 => {
    //   block [0x821A1E70..0x821A1E7C)
	// 821A1E70: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A1E74: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E7C; continue 'dispatch;
            }
            0x821A1E7C => {
    //   block [0x821A1E7C..0x821A1E88)
	// 821A1E7C: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A1E80: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A1E88; continue 'dispatch;
            }
            0x821A1E88 => {
    //   block [0x821A1E88..0x821A1EA8)
	// 821A1E88: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A1E8C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1E94: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A1E98: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1E9C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A1EA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1EA4: 4839325C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1EA8 => {
    //   block [0x821A1EA8..0x821A1EE0)
	// 821A1EA8: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1EAC: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A1EB0: 811F002C  lwz r8, 0x2c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A1EB4: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 821A1EB8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821A1EBC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821A1EC0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A1EC4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821A1EC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A1ECC: 40990020  ble cr6, 0x821a1eec
	if !ctx.cr[6].gt {
	pc = 0x821A1EEC; continue 'dispatch;
	}
	// 821A1ED0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 821A1ED4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A1ED8: 419A0014  beq cr6, 0x821a1eec
	if ctx.cr[6].eq {
	pc = 0x821A1EEC; continue 'dispatch;
	}
	// 821A1EDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821A1EE0; continue 'dispatch;
            }
            0x821A1EE0 => {
    //   block [0x821A1EE0..0x821A1EEC)
	// 821A1EE0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1EE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A1EE8: 4200FFF8  bdnz 0x821a1ee0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A1EE0; continue 'dispatch;
	}
	pc = 0x821A1EEC; continue 'dispatch;
            }
            0x821A1EEC => {
    //   block [0x821A1EEC..0x821A1F20)
	// 821A1EEC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A1EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1EF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1EF8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821A1EFC: 4800025D  bl 0x821a2158
	ctx.lr = 0x821A1F00;
	sub_821A2158(ctx, base);
	// 821A1F00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A1F04: 419A016C  beq cr6, 0x821a2070
	if ctx.cr[6].eq {
	pc = 0x821A2070; continue 'dispatch;
	}
	// 821A1F08: 2B1D0100  cmplwi cr6, r29, 0x100
	ctx.cr[6].compare_u32(ctx.r[29].u32, 256 as u32, &mut ctx.xer);
	// 821A1F0C: 40980014  bge cr6, 0x821a1f20
	if !ctx.cr[6].lt {
	pc = 0x821A1F20; continue 'dispatch;
	}
	// 821A1F10: 7C00F22C  dcbt 0, r30
	// 821A1F14: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A1F18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A1F1C: 483931E4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1F20 => {
    //   block [0x821A1F20..0x821A1F30)
	// 821A1F20: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 821A1F24: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A1F28: 41980008  blt cr6, 0x821a1f30
	if ctx.cr[6].lt {
	pc = 0x821A1F30; continue 'dispatch;
	}
	// 821A1F2C: 3FA00004  lis r29, 4
	ctx.r[29].s64 = 262144;
	pc = 0x821A1F30; continue 'dispatch;
            }
            0x821A1F30 => {
    //   block [0x821A1F30..0x821A1F54)
	// 821A1F30: 397E007F  addi r11, r30, 0x7f
	ctx.r[11].s64 = ctx.r[30].s64 + 127;
	// 821A1F34: 7D5DF214  add r10, r29, r30
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 821A1F38: 55690030  rlwinm r9, r11, 0, 0, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1F3C: 554B0030  rlwinm r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821A1F40: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821A1F44: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821A1F48: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821A1F4C: 419A0008  beq cr6, 0x821a1f54
	if ctx.cr[6].eq {
	pc = 0x821A1F54; continue 'dispatch;
	}
	// 821A1F50: 7C00F22C  dcbt 0, r30
	pc = 0x821A1F54; continue 'dispatch;
            }
            0x821A1F54 => {
    //   block [0x821A1F54..0x821A1F60)
	// 821A1F54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A1F58: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1F5C: 41980080  blt cr6, 0x821a1fdc
	if ctx.cr[6].lt {
	pc = 0x821A1FDC; continue 'dispatch;
	}
	pc = 0x821A1F60; continue 'dispatch;
            }
            0x821A1F60 => {
    //   block [0x821A1F60..0x821A1FDC)
	// 821A1F60: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A1F64: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F68: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F6C: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A1F70: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F74: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A1F78: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F7C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F80: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A1F84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F88: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F8C: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A1F90: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1F94: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1F98: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A1F9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FA0: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1FA4: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A1FA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FAC: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1FB0: 3940FC00  li r10, -0x400
	ctx.r[10].s64 = -1024;
	// 821A1FB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FB8: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A1FBC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A1FC0: 394BFC00  addi r10, r11, -0x400
	ctx.r[10].s64 = ctx.r[11].s64 + -1024;
	// 821A1FC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1FC8: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 821A1FCC: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 821A1FD0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821A1FD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821A1FD8: 4098FF88  bge cr6, 0x821a1f60
	if !ctx.cr[6].lt {
	pc = 0x821A1F60; continue 'dispatch;
	}
	pc = 0x821A1FDC; continue 'dispatch;
            }
            0x821A1FDC => {
    //   block [0x821A1FDC..0x821A2020)
	// 821A1FDC: 554ACF7E  rlwinm r10, r10, 0x19, 0x1d, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821A1FE0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1FE4: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 821A1FE8: 41990088  bgt cr6, 0x821a2070
	if ctx.cr[6].gt {
	pc = 0x821A2070; continue 'dispatch;
	}
	// 821A1FEC: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A1FF0: 398C2004  addi r12, r12, 0x2004
	ctx.r[12].s64 = ctx.r[12].s64 + 8196;
	// 821A1FF4: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A1FF8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A1FFC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A2000: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821A2068; continue 'dispatch;
		},
		1 => {
	pc = 0x821A205C; continue 'dispatch;
		},
		2 => {
	pc = 0x821A2050; continue 'dispatch;
		},
		3 => {
	pc = 0x821A2044; continue 'dispatch;
		},
		4 => {
	pc = 0x821A2038; continue 'dispatch;
		},
		5 => {
	pc = 0x821A202C; continue 'dispatch;
		},
		6 => {
	pc = 0x821A2020; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A2004: 821A2068  lwz r16, 0x2068(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8296 as u32) ) } as u64;
	// 821A2008: 821A205C  lwz r16, 0x205c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8284 as u32) ) } as u64;
	// 821A200C: 821A2050  lwz r16, 0x2050(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8272 as u32) ) } as u64;
	// 821A2010: 821A2044  lwz r16, 0x2044(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8260 as u32) ) } as u64;
	// 821A2014: 821A2038  lwz r16, 0x2038(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8248 as u32) ) } as u64;
	// 821A2018: 821A202C  lwz r16, 0x202c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8236 as u32) ) } as u64;
	// 821A201C: 821A2020  lwz r16, 0x2020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8224 as u32) ) } as u64;
            }
            0x821A2020 => {
    //   block [0x821A2020..0x821A202C)
	// 821A2020: 3940FC80  li r10, -0x380
	ctx.r[10].s64 = -896;
	// 821A2024: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2028: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A202C; continue 'dispatch;
            }
            0x821A202C => {
    //   block [0x821A202C..0x821A2038)
	// 821A202C: 3940FD00  li r10, -0x300
	ctx.r[10].s64 = -768;
	// 821A2030: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2034: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2038; continue 'dispatch;
            }
            0x821A2038 => {
    //   block [0x821A2038..0x821A2044)
	// 821A2038: 3940FD80  li r10, -0x280
	ctx.r[10].s64 = -640;
	// 821A203C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2040: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2044; continue 'dispatch;
            }
            0x821A2044 => {
    //   block [0x821A2044..0x821A2050)
	// 821A2044: 3940FE00  li r10, -0x200
	ctx.r[10].s64 = -512;
	// 821A2048: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A204C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2050; continue 'dispatch;
            }
            0x821A2050 => {
    //   block [0x821A2050..0x821A205C)
	// 821A2050: 3940FE80  li r10, -0x180
	ctx.r[10].s64 = -384;
	// 821A2054: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2058: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A205C; continue 'dispatch;
            }
            0x821A205C => {
    //   block [0x821A205C..0x821A2068)
	// 821A205C: 3940FF00  li r10, -0x100
	ctx.r[10].s64 = -256;
	// 821A2060: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	// 821A2064: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A2068; continue 'dispatch;
            }
            0x821A2068 => {
    //   block [0x821A2068..0x821A2070)
	// 821A2068: 3940FF80  li r10, -0x80
	ctx.r[10].s64 = -128;
	// 821A206C: 7C0A5FEC  dcbz r10, r11
	ea.u32 = ctx.r[10].u32.wrapping_add(ctx.r[11].u32);
	ea.u32 &= !31;
	unsafe { crate::rt::memset_ea(ea.u32, 0, 32) };
	pc = 0x821A2070; continue 'dispatch;
            }
            0x821A2070 => {
    //   block [0x821A2070..0x821A2074)
	// 821A2070: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x821A2074; continue 'dispatch;
            }
            0x821A2074 => {
    //   block [0x821A2074..0x821A207C)
	// 821A2074: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A2078: 48393088  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2080 size=212
    let mut pc: u32 = 0x821A2080;
    'dispatch: loop {
        match pc {
            0x821A2080 => {
    //   block [0x821A2080..0x821A20E4)
	// 821A2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A208C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A2098: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A209C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A20A0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A20A4: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A20A8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821A20AC: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A20B0: 93C40000  stw r30, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A20B4: 7D6B4396  divwu r11, r11, r8
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[8].u32;
	// 821A20B8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A20BC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821A20C0: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821A20C4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A20C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A20CC: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A20D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A20D4: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 821A20D8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A20DC: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 821A20E0: 409A0034  bne cr6, 0x821a2114
	if !ctx.cr[6].eq {
	pc = 0x821A2114; continue 'dispatch;
	}
	pc = 0x821A20E4; continue 'dispatch;
            }
            0x821A20E4 => {
    //   block [0x821A20E4..0x821A2114)
	// 821A20E4: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A20E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A20EC: 40980028  bge cr6, 0x821a2114
	if !ctx.cr[6].lt {
	pc = 0x821A2114; continue 'dispatch;
	}
	// 821A20F0: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821A20F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A20F8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A20FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A2100: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A2104: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 821A2108: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A210C: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 821A2110: 419AFFD4  beq cr6, 0x821a20e4
	if ctx.cr[6].eq {
	pc = 0x821A20E4; continue 'dispatch;
	}
	pc = 0x821A2114; continue 'dispatch;
            }
            0x821A2114 => {
    //   block [0x821A2114..0x821A2130)
	// 821A2114: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A211C: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A2120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2124: 419A000C  beq cr6, 0x821a2130
	if ctx.cr[6].eq {
	pc = 0x821A2130; continue 'dispatch;
	}
	// 821A2128: 480000E1  bl 0x821a2208
	ctx.lr = 0x821A212C;
	sub_821A2208(ctx, base);
	// 821A212C: 48000008  b 0x821a2134
	pc = 0x821A2134; continue 'dispatch;
            }
            0x821A2130 => {
    //   block [0x821A2130..0x821A2134)
	// 821A2130: 48000029  bl 0x821a2158
	ctx.lr = 0x821A2134;
	sub_821A2158(ctx, base);
	pc = 0x821A2134; continue 'dispatch;
            }
            0x821A2134 => {
    //   block [0x821A2134..0x821A2154)
	// 821A2134: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A2138: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821A213C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A214C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A2150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2158 size=172
    let mut pc: u32 = 0x821A2158;
    'dispatch: loop {
        match pc {
            0x821A2158 => {
    //   block [0x821A2158..0x821A2188)
	// 821A2158: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A215C: 80830028  lwz r4, 0x28(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2164: 80C3002C  lwz r6, 0x2c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A2168: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A216C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A2170: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A2174: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A2178: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A217C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A2180: 40990074  ble cr6, 0x821a21f4
	if !ctx.cr[6].gt {
	pc = 0x821A21F4; continue 'dispatch;
	}
	// 821A2184: 5484003E  slwi r4, r4, 0
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	pc = 0x821A2188; continue 'dispatch;
            }
            0x821A2188 => {
    //   block [0x821A2188..0x821A21A4)
	// 821A2188: 83E60000  lwz r31, 0(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A218C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2190: 409A001C  bne cr6, 0x821a21ac
	if !ctx.cr[6].eq {
	pc = 0x821A21AC; continue 'dispatch;
	}
	// 821A2194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2198: 409A000C  bne cr6, 0x821a21a4
	if !ctx.cr[6].eq {
	pc = 0x821A21A4; continue 'dispatch;
	}
	// 821A219C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 821A21A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821A21A4; continue 'dispatch;
            }
            0x821A21A4 => {
    //   block [0x821A21A4..0x821A21AC)
	// 821A21A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A21A8: 48000024  b 0x821a21cc
	pc = 0x821A21CC; continue 'dispatch;
            }
            0x821A21AC => {
    //   block [0x821A21AC..0x821A21C4)
	// 821A21AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A21B0: 419A001C  beq cr6, 0x821a21cc
	if ctx.cr[6].eq {
	pc = 0x821A21CC; continue 'dispatch;
	}
	// 821A21B4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A21B8: 4099000C  ble cr6, 0x821a21c4
	if !ctx.cr[6].gt {
	pc = 0x821A21C4; continue 'dispatch;
	}
	// 821A21BC: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821A21C0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	pc = 0x821A21C4; continue 'dispatch;
            }
            0x821A21C4 => {
    //   block [0x821A21C4..0x821A21CC)
	// 821A21C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A21C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A21CC; continue 'dispatch;
            }
            0x821A21CC => {
    //   block [0x821A21CC..0x821A21F4)
	// 821A21CC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A21D0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821A21D4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821A21D8: 4198FFB0  blt cr6, 0x821a2188
	if ctx.cr[6].lt {
	pc = 0x821A2188; continue 'dispatch;
	}
	// 821A21DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A21E0: 419A0014  beq cr6, 0x821a21f4
	if ctx.cr[6].eq {
	pc = 0x821A21F4; continue 'dispatch;
	}
	// 821A21E4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A21E8: 4099000C  ble cr6, 0x821a21f4
	if !ctx.cr[6].gt {
	pc = 0x821A21F4; continue 'dispatch;
	}
	// 821A21EC: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821A21F0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	pc = 0x821A21F4; continue 'dispatch;
            }
            0x821A21F4 => {
    //   block [0x821A21F4..0x821A2204)
	// 821A21F4: 90E30014  stw r7, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 821A21F8: 90A30018  stw r5, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 821A21FC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A2200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2208 size=192
    let mut pc: u32 = 0x821A2208;
    'dispatch: loop {
        match pc {
            0x821A2208 => {
    //   block [0x821A2208..0x821A224C)
	// 821A2208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A220C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A2214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A221C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A2220: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A2224: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2228: 7D4A59D6  mullw r10, r10, r11
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821A222C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A2230: 7FEA5B96  divwu r31, r10, r11
	ctx.r[31].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 821A2234: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2238: 419A0070  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A223C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A2240: 48000201  bl 0x821a2440
	ctx.lr = 0x821A2244;
	sub_821A2440(ctx, base);
	// 821A2244: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A2248: 40990024  ble cr6, 0x821a226c
	if !ctx.cr[6].gt {
	pc = 0x821A226C; continue 'dispatch;
	}
	pc = 0x821A224C; continue 'dispatch;
            }
            0x821A224C => {
    //   block [0x821A224C..0x821A226C)
	// 821A224C: 7FE3F850  subf r31, r3, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 821A2250: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2254: 419A0054  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2258: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A225C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A2260: 480001E1  bl 0x821a2440
	ctx.lr = 0x821A2264;
	sub_821A2440(ctx, base);
	// 821A2264: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A2268: 4199FFE4  bgt cr6, 0x821a224c
	if ctx.cr[6].gt {
	pc = 0x821A224C; continue 'dispatch;
	}
	pc = 0x821A226C; continue 'dispatch;
            }
            0x821A226C => {
    //   block [0x821A226C..0x821A2288)
	// 821A226C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2270: 419A0038  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2274: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A2278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A227C: 480002BD  bl 0x821a2538
	ctx.lr = 0x821A2280;
	sub_821A2538(ctx, base);
	// 821A2280: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A2284: 40990024  ble cr6, 0x821a22a8
	if !ctx.cr[6].gt {
	pc = 0x821A22A8; continue 'dispatch;
	}
	pc = 0x821A2288; continue 'dispatch;
            }
            0x821A2288 => {
    //   block [0x821A2288..0x821A22A8)
	// 821A2288: 7FE3F850  subf r31, r3, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 821A228C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2290: 419A0018  beq cr6, 0x821a22a8
	if ctx.cr[6].eq {
	pc = 0x821A22A8; continue 'dispatch;
	}
	// 821A2294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A2298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A229C: 4800029D  bl 0x821a2538
	ctx.lr = 0x821A22A0;
	sub_821A2538(ctx, base);
	// 821A22A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A22A4: 4199FFE4  bgt cr6, 0x821a2288
	if ctx.cr[6].gt {
	pc = 0x821A2288; continue 'dispatch;
	}
	pc = 0x821A22A8; continue 'dispatch;
            }
            0x821A22A8 => {
    //   block [0x821A22A8..0x821A22C8)
	// 821A22A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A22AC: 4BFFFEAD  bl 0x821a2158
	ctx.lr = 0x821A22B0;
	sub_821A2158(ctx, base);
	// 821A22B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A22B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A22B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A22BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A22C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A22C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A22C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A22C8 size=196
    let mut pc: u32 = 0x821A22C8;
    'dispatch: loop {
        match pc {
            0x821A22C8 => {
    //   block [0x821A22C8..0x821A2348)
	// 821A22C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A22CC: 48392DE9  bl 0x825350b4
	ctx.lr = 0x821A22D0;
	sub_82535080(ctx, base);
	// 821A22D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A22D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A22D8: 3D40656D  lis r10, 0x656d
	ctx.r[10].s64 = 1701642240;
	// 821A22DC: 614A5F6F  ori r10, r10, 0x5f6f
	ctx.r[10].u64 = ctx.r[10].u64 | 24431;
	// 821A22E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A22E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A22E8: 409A009C  bne cr6, 0x821a2384
	if !ctx.cr[6].eq {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A22EC: 3D407379  lis r10, 0x7379
	ctx.r[10].s64 = 1937309696;
	// 821A22F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A22F4: 614A736D  ori r10, r10, 0x736d
	ctx.r[10].u64 = ctx.r[10].u64 | 29549;
	// 821A22F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A22FC: 409A0088  bne cr6, 0x821a2384
	if !ctx.cr[6].eq {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A2300: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A2304: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2308: 419A007C  beq cr6, 0x821a2384
	if ctx.cr[6].eq {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A230C: 83BF0020  lwz r29, 0x20(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A2310: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A2314: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A2318: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A231C: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 821A2320: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2324: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 821A2328: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 821A232C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821A2330: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821A2334: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A2338: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821A233C: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821A2340: 40990044  ble cr6, 0x821a2384
	if !ctx.cr[6].gt {
	pc = 0x821A2384; continue 'dispatch;
	}
	// 821A2344: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	pc = 0x821A2348; continue 'dispatch;
            }
            0x821A2348 => {
    //   block [0x821A2348..0x821A2370)
	// 821A2348: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A234C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2350: 419A0020  beq cr6, 0x821a2370
	if ctx.cr[6].eq {
	pc = 0x821A2370; continue 'dispatch;
	}
	// 821A2354: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A2358: 419A0018  beq cr6, 0x821a2370
	if ctx.cr[6].eq {
	pc = 0x821A2370; continue 'dispatch;
	}
	// 821A235C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2360: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 821A2364: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821A2368: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A236C: 4BFFFF5D  bl 0x821a22c8
	ctx.lr = 0x821A2370;
	sub_821A22C8(ctx, base);
	pc = 0x821A2370; continue 'dispatch;
            }
            0x821A2370 => {
    //   block [0x821A2370..0x821A2384)
	// 821A2370: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2374: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821A2378: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821A237C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A2380: 4198FFC8  blt cr6, 0x821a2348
	if ctx.cr[6].lt {
	pc = 0x821A2348; continue 'dispatch;
	}
	pc = 0x821A2384; continue 'dispatch;
            }
            0x821A2384 => {
    //   block [0x821A2384..0x821A238C)
	// 821A2384: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A2388: 48392D7C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2390 size=176
    let mut pc: u32 = 0x821A2390;
    'dispatch: loop {
        match pc {
            0x821A2390 => {
    //   block [0x821A2390..0x821A23E8)
	// 821A2390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2394: 48392D21  bl 0x825350b4
	ctx.lr = 0x821A2398;
	sub_82535080(ctx, base);
	// 821A2398: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A239C: 8363000C  lwz r27, 0xc(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A23A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A23A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A23A8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A23AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821A23B0: 8383002C  lwz r28, 0x2c(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A23B4: 7D3BF1D6  mullw r9, r27, r30
	ctx.r[9].s32 = ((ctx.r[27].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A23B8: 7D5BF9D6  mullw r10, r27, r31
	ctx.r[10].s32 = ((ctx.r[27].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821A23BC: 7CBBE9D6  mullw r5, r27, r29
	ctx.r[5].s32 = ((ctx.r[27].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 821A23C0: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A23C4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A23C8: 48392789  bl 0x82534b50
	ctx.lr = 0x821A23CC;
	sub_82534B50(ctx, base);
	// 821A23CC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821A23D0: 40990068  ble cr6, 0x821a2438
	if !ctx.cr[6].gt {
	pc = 0x821A2438; continue 'dispatch;
	}
	// 821A23D4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A23D8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A23DC: 7CEAE214  add r7, r10, r28
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821A23E0: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A23E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x821A23E8; continue 'dispatch;
            }
            0x821A23E8 => {
    //   block [0x821A23E8..0x821A2414)
	// 821A23E8: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A23EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A23F0: 419A0024  beq cr6, 0x821a2414
	if ctx.cr[6].eq {
	pc = 0x821A2414; continue 'dispatch;
	}
	// 821A23F4: 2B080002  cmplwi cr6, r8, 2
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2 as u32, &mut ctx.xer);
	// 821A23F8: 419A001C  beq cr6, 0x821a2414
	if ctx.cr[6].eq {
	pc = 0x821A2414; continue 'dispatch;
	}
	// 821A23FC: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 821A2400: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2404: 7D6BD9D6  mullw r11, r11, r27
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A2408: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A240C: 90680000  stw r3, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821A2410: 4BFFFEB9  bl 0x821a22c8
	ctx.lr = 0x821A2414;
	sub_821A22C8(ctx, base);
	pc = 0x821A2414; continue 'dispatch;
            }
            0x821A2414 => {
    //   block [0x821A2414..0x821A2438)
	// 821A2414: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821A2418: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A241C: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821A2420: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821A2424: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821A2428: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821A242C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 821A2430: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A2434: 409AFFB4  bne cr6, 0x821a23e8
	if !ctx.cr[6].eq {
	pc = 0x821A23E8; continue 'dispatch;
	}
	pc = 0x821A2438; continue 'dispatch;
            }
            0x821A2438 => {
    //   block [0x821A2438..0x821A2440)
	// 821A2438: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A243C: 48392CC8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2440 size=244
    let mut pc: u32 = 0x821A2440;
    'dispatch: loop {
        match pc {
            0x821A2440 => {
    //   block [0x821A2440..0x821A2474)
	// 821A2440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2448: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A244C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2450: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A2454: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821A2458: 80C3002C  lwz r6, 0x2c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A245C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A2460: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821A2464: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2468: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A246C: 40990040  ble cr6, 0x821a24ac
	if !ctx.cr[6].gt {
	pc = 0x821A24AC; continue 'dispatch;
	}
	// 821A2470: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x821A2474; continue 'dispatch;
            }
            0x821A2474 => {
    //   block [0x821A2474..0x821A2494)
	// 821A2474: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2478: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A247C: 409A0018  bne cr6, 0x821a2494
	if !ctx.cr[6].eq {
	pc = 0x821A2494; continue 'dispatch;
	}
	// 821A2480: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821A2484: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2488: 40980014  bge cr6, 0x821a249c
	if !ctx.cr[6].lt {
	pc = 0x821A249C; continue 'dispatch;
	}
	// 821A248C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821A2490: 4800000C  b 0x821a249c
	pc = 0x821A249C; continue 'dispatch;
            }
            0x821A2494 => {
    //   block [0x821A2494..0x821A249C)
	// 821A2494: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2498: 40980014  bge cr6, 0x821a24ac
	if !ctx.cr[6].lt {
	pc = 0x821A24AC; continue 'dispatch;
	}
	pc = 0x821A249C; continue 'dispatch;
            }
            0x821A249C => {
    //   block [0x821A249C..0x821A24AC)
	// 821A249C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A24A0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821A24A4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A24A8: 4198FFCC  blt cr6, 0x821a2474
	if ctx.cr[6].lt {
	pc = 0x821A2474; continue 'dispatch;
	}
	pc = 0x821A24AC; continue 'dispatch;
            }
            0x821A24AC => {
    //   block [0x821A24AC..0x821A24B8)
	// 821A24AC: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A24B0: 40990008  ble cr6, 0x821a24b8
	if !ctx.cr[6].gt {
	pc = 0x821A24B8; continue 'dispatch;
	}
	// 821A24B4: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	pc = 0x821A24B8; continue 'dispatch;
            }
            0x821A24B8 => {
    //   block [0x821A24B8..0x821A24DC)
	// 821A24B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A24BC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821A24C0: 419A005C  beq cr6, 0x821a251c
	if ctx.cr[6].eq {
	pc = 0x821A251C; continue 'dispatch;
	}
	// 821A24C4: 38A9FFFF  addi r5, r9, -1
	ctx.r[5].s64 = ctx.r[9].s64 + -1;
	// 821A24C8: 7D244214  add r9, r4, r8
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[8].u64;
	// 821A24CC: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A24D0: 4198004C  blt cr6, 0x821a251c
	if ctx.cr[6].lt {
	pc = 0x821A251C; continue 'dispatch;
	}
	// 821A24D4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A24D8: 7D4B3214  add r10, r11, r6
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	pc = 0x821A24DC; continue 'dispatch;
            }
            0x821A24DC => {
    //   block [0x821A24DC..0x821A2500)
	// 821A24DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A24E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A24E4: 419A001C  beq cr6, 0x821a2500
	if ctx.cr[6].eq {
	pc = 0x821A2500; continue 'dispatch;
	}
	// 821A24E8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821A24EC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A24F0: 419A0010  beq cr6, 0x821a2500
	if ctx.cr[6].eq {
	pc = 0x821A2500; continue 'dispatch;
	}
	// 821A24F4: 7F1F4000  cmpw cr6, r31, r8
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821A24F8: 4099001C  ble cr6, 0x821a2514
	if !ctx.cr[6].gt {
	pc = 0x821A2514; continue 'dispatch;
	}
	// 821A24FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821A2500; continue 'dispatch;
            }
            0x821A2500 => {
    //   block [0x821A2500..0x821A2514)
	// 821A2500: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 821A2504: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 821A2508: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A250C: 4098FFD0  bge cr6, 0x821a24dc
	if !ctx.cr[6].lt {
	pc = 0x821A24DC; continue 'dispatch;
	}
	// 821A2510: 4800000C  b 0x821a251c
	pc = 0x821A251C; continue 'dispatch;
            }
            0x821A2514 => {
    //   block [0x821A2514..0x821A251C)
	// 821A2514: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821A2518: 4BFFFE79  bl 0x821a2390
	ctx.lr = 0x821A251C;
	sub_821A2390(ctx, base);
	pc = 0x821A251C; continue 'dispatch;
            }
            0x821A251C => {
    //   block [0x821A251C..0x821A2534)
	// 821A251C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A2520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A2524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A252C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A2530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A2538 size=308
    let mut pc: u32 = 0x821A2538;
    'dispatch: loop {
        match pc {
            0x821A2538 => {
    //   block [0x821A2538..0x821A256C)
	// 821A2538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A253C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A2544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2548: 80E30028  lwz r7, 0x28(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821A254C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821A2550: 8103002C  lwz r8, 0x2c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A2554: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A2558: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821A255C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2560: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821A2564: 40990040  ble cr6, 0x821a25a4
	if !ctx.cr[6].gt {
	pc = 0x821A25A4; continue 'dispatch;
	}
	// 821A2568: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	pc = 0x821A256C; continue 'dispatch;
            }
            0x821A256C => {
    //   block [0x821A256C..0x821A258C)
	// 821A256C: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2570: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A2574: 409A0018  bne cr6, 0x821a258c
	if !ctx.cr[6].eq {
	pc = 0x821A258C; continue 'dispatch;
	}
	// 821A2578: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A257C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2580: 40980014  bge cr6, 0x821a2594
	if !ctx.cr[6].lt {
	pc = 0x821A2594; continue 'dispatch;
	}
	// 821A2584: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821A2588: 4800000C  b 0x821a2594
	pc = 0x821A2594; continue 'dispatch;
            }
            0x821A258C => {
    //   block [0x821A258C..0x821A2594)
	// 821A258C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A2590: 40980014  bge cr6, 0x821a25a4
	if !ctx.cr[6].lt {
	pc = 0x821A25A4; continue 'dispatch;
	}
	pc = 0x821A2594; continue 'dispatch;
            }
            0x821A2594 => {
    //   block [0x821A2594..0x821A25A4)
	// 821A2594: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A2598: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821A259C: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A25A0: 4198FFCC  blt cr6, 0x821a256c
	if ctx.cr[6].lt {
	pc = 0x821A256C; continue 'dispatch;
	}
	pc = 0x821A25A4; continue 'dispatch;
            }
            0x821A25A4 => {
    //   block [0x821A25A4..0x821A25CC)
	// 821A25A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A25A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A25AC: 419A00A8  beq cr6, 0x821a2654
	if ctx.cr[6].eq {
	pc = 0x821A2654; continue 'dispatch;
	}
	// 821A25B0: 7D245214  add r9, r4, r10
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 821A25B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A25B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821A25BC: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A25C0: 40980094  bge cr6, 0x821a2654
	if !ctx.cr[6].lt {
	pc = 0x821A2654; continue 'dispatch;
	}
	// 821A25C4: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A25C8: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	pc = 0x821A25CC; continue 'dispatch;
            }
            0x821A25CC => {
    //   block [0x821A25CC..0x821A25EC)
	// 821A25CC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A25D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A25D4: 419A0060  beq cr6, 0x821a2634
	if ctx.cr[6].eq {
	pc = 0x821A2634; continue 'dispatch;
	}
	// 821A25D8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 821A25DC: 419A0024  beq cr6, 0x821a2600
	if ctx.cr[6].eq {
	pc = 0x821A2600; continue 'dispatch;
	}
	// 821A25E0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821A25E4: 40980008  bge cr6, 0x821a25ec
	if !ctx.cr[6].lt {
	pc = 0x821A25EC; continue 'dispatch;
	}
	// 821A25E8: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	pc = 0x821A25EC; continue 'dispatch;
            }
            0x821A25EC => {
    //   block [0x821A25EC..0x821A2600)
	// 821A25EC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A25F0: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A25F4: 41990050  bgt cr6, 0x821a2644
	if ctx.cr[6].gt {
	pc = 0x821A2644; continue 'dispatch;
	}
	// 821A25F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A25FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A2600; continue 'dispatch;
            }
            0x821A2600 => {
    //   block [0x821A2600..0x821A2620)
	// 821A2600: 3947FFFF  addi r10, r7, -1
	ctx.r[10].s64 = ctx.r[7].s64 + -1;
	// 821A2604: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A2608: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A260C: 409A0014  bne cr6, 0x821a2620
	if !ctx.cr[6].eq {
	pc = 0x821A2620; continue 'dispatch;
	}
	// 821A2610: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A2614: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A2618: 41990008  bgt cr6, 0x821a2620
	if ctx.cr[6].gt {
	pc = 0x821A2620; continue 'dispatch;
	}
	// 821A261C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x821A2620; continue 'dispatch;
            }
            0x821A2620 => {
    //   block [0x821A2620..0x821A2634)
	// 821A2620: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A2624: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821A2628: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821A262C: 4198FFA0  blt cr6, 0x821a25cc
	if ctx.cr[6].lt {
	pc = 0x821A25CC; continue 'dispatch;
	}
	// 821A2630: 48000014  b 0x821a2644
	pc = 0x821A2644; continue 'dispatch;
            }
            0x821A2634 => {
    //   block [0x821A2634..0x821A2644)
	// 821A2634: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A2638: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A263C: 41990008  bgt cr6, 0x821a2644
	if ctx.cr[6].gt {
	pc = 0x821A2644; continue 'dispatch;
	}
	// 821A2640: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x821A2644; continue 'dispatch;
            }
            0x821A2644 => {
    //   block [0x821A2644..0x821A2654)
	// 821A2644: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821A2648: 419A000C  beq cr6, 0x821a2654
	if ctx.cr[6].eq {
	pc = 0x821A2654; continue 'dispatch;
	}
	// 821A264C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821A2650: 4BFFFD41  bl 0x821a2390
	ctx.lr = 0x821A2654;
	sub_821A2390(ctx, base);
	pc = 0x821A2654; continue 'dispatch;
            }
            0x821A2654 => {
    //   block [0x821A2654..0x821A266C)
	// 821A2654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A2658: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A265C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A2668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2670 size=240
    let mut pc: u32 = 0x821A2670;
    'dispatch: loop {
        match pc {
            0x821A2670 => {
    //   block [0x821A2670..0x821A2760)
	// 821A2670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A267C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2680: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A2684: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 821A2688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A268C: 396B33D0  addi r11, r11, 0x33d0
	ctx.r[11].s64 = ctx.r[11].s64 + 13264;
	// 821A2690: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2694: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2698: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A269C: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A26A0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A26A4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A26A8: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A26AC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A26B0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A26B4: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A26B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A26BC: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A26C0: 481C4A79  bl 0x82367138
	ctx.lr = 0x821A26C4;
	sub_82367138(ctx, base);
	// 821A26C4: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A26C8: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A26CC: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821A26D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A26D4: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A26D8: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A26DC: C15F0008  lfs f10, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A26E0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A26E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A26E8: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A26EC: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A2760 size=144
    let mut pc: u32 = 0x821A2760;
    'dispatch: loop {
        match pc {
            0x821A2760 => {
    //   block [0x821A2760..0x821A27A4)
	// 821A2760: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A2764: 419A0040  beq cr6, 0x821a27a4
	if ctx.cr[6].eq {
	pc = 0x821A27A4; continue 'dispatch;
	}
	pc = 0x821A27A4; continue 'dispatch;
            }
            0x821A27A4 => {
    //   block [0x821A27A4..0x821A27F0)
	// 821A27A4: C1A70004  lfs f13, 4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A27A8: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A27AC: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A27B0: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A27B4: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821A27B8: C1A7000C  lfs f13, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A27BC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821A27C0: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A27C4: D1A1FFFC  stfs f13, -4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821A27C8: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A27CC: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821A27D0: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A27F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A27F0 size=140
    let mut pc: u32 = 0x821A27F0;
    'dispatch: loop {
        match pc {
            0x821A27F0 => {
    //   block [0x821A27F0..0x821A2818)
	// 821A27F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A27F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A27F8: 396B0D6C  addi r11, r11, 0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + 3436;
	// 821A27FC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2800: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A2804: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2808: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 821A280C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2810: 41990008  bgt cr6, 0x821a2818
	if ctx.cr[6].gt {
	pc = 0x821A2818; continue 'dispatch;
	}
	// 821A2814: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	pc = 0x821A2818; continue 'dispatch;
            }
            0x821A2818 => {
    //   block [0x821A2818..0x821A2824)
	// 821A2818: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 821A281C: 41990008  bgt cr6, 0x821a2824
	if ctx.cr[6].gt {
	pc = 0x821A2824; continue 'dispatch;
	}
	// 821A2820: FC406890  fmr f2, f13
	ctx.f[2].f64 = ctx.f[13].f64;
	pc = 0x821A2824; continue 'dispatch;
            }
            0x821A2824 => {
    //   block [0x821A2824..0x821A2830)
	// 821A2824: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 821A2828: 41990008  bgt cr6, 0x821a2830
	if ctx.cr[6].gt {
	pc = 0x821A2830; continue 'dispatch;
	}
	// 821A282C: FCC06890  fmr f6, f13
	ctx.f[6].f64 = ctx.f[13].f64;
	pc = 0x821A2830; continue 'dispatch;
            }
            0x821A2830 => {
    //   block [0x821A2830..0x821A2874)
	// 821A2830: EDA11828  fsubs f13, f1, f3
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[3].f64) as f32) as f64);
	// 821A2834: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A2838: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 821A283C: D063008C  stfs f3, 0x8c(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A2840: D0630088  stfs f3, 0x88(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A2844: D0230090  stfs f1, 0x90(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A2848: D0A30094  stfs f5, 0x94(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A284C: D08300A0  stfs f4, 0xa0(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 821A2850: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 821A2854: D04300A4  stfs f2, 0xa4(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A2858: D0C300A8  stfs f6, 0xa8(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A285C: D0E300AC  stfs f7, 0xac(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A2860: EC0D2024  fdivs f0, f13, f4
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[4].f64) as f32) as f64;
	// 821A2864: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A2868: 419A000C  beq cr6, 0x821a2874
	if ctx.cr[6].eq {
	pc = 0x821A2874; continue 'dispatch;
	}
	// 821A286C: D0E3009C  stfs f7, 0x9c(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A2870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A2874; continue 'dispatch;
            }
            0x821A2874 => {
    //   block [0x821A2874..0x821A287C)
	// 821A2874: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A2878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A2880 size=360
    let mut pc: u32 = 0x821A2880;
    'dispatch: loop {
        match pc {
            0x821A2880 => {
    //   block [0x821A2880..0x821A28B8)
	// 821A2880: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A2884: C1A30088  lfs f13, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2888: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 821A288C: 419900A0  bgt cr6, 0x821a292c
	if ctx.cr[6].gt {
	pc = 0x821A292C; continue 'dispatch;
	}
	// 821A2890: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A2894: 398C28A8  addi r12, r12, 0x28a8
	ctx.r[12].s64 = ctx.r[12].s64 + 10408;
	// 821A2898: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A289C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A28A0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A28A4: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821A2930; continue 'dispatch;
		},
		1 => {
	pc = 0x821A28B8; continue 'dispatch;
		},
		2 => {
	pc = 0x821A2930; continue 'dispatch;
		},
		3 => {
	pc = 0x821A2978; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A28A8: 821A2930  lwz r16, 0x2930(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10544 as u32) ) } as u64;
	// 821A28AC: 821A28B8  lwz r16, 0x28b8(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10424 as u32) ) } as u64;
	// 821A28B0: 821A2930  lwz r16, 0x2930(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10544 as u32) ) } as u64;
	// 821A28B4: 821A2978  lwz r16, 0x2978(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10616 as u32) ) } as u64;
            }
            0x821A28B8 => {
    //   block [0x821A28B8..0x821A28F0)
	// 821A28B8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A28BC: C0030098  lfs f0, 0x98(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A28C0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A28C4: C1630090  lfs f11, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A28C8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A28CC: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A28D0: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A28D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A28D8: EDA06B3A  fmadds f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A28DC: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A28E0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821A28E4: 4098000C  bge cr6, 0x821a28f0
	if !ctx.cr[6].lt {
	pc = 0x821A28F0; continue 'dispatch;
	}
	// 821A28E8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 821A28EC: 40990014  ble cr6, 0x821a2900
	if !ctx.cr[6].gt {
	pc = 0x821A2900; continue 'dispatch;
	}
	pc = 0x821A28F0; continue 'dispatch;
            }
            0x821A28F0 => {
    //   block [0x821A28F0..0x821A2900)
	// 821A28F0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821A28F4: 41980034  blt cr6, 0x821a2928
	if ctx.cr[6].lt {
	pc = 0x821A2928; continue 'dispatch;
	}
	// 821A28F8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 821A28FC: 4198002C  blt cr6, 0x821a2928
	if ctx.cr[6].lt {
	pc = 0x821A2928; continue 'dispatch;
	}
	pc = 0x821A2900; continue 'dispatch;
            }
            0x821A2900 => {
    //   block [0x821A2900..0x821A2928)
	// 821A2900: C0030094  lfs f0, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2904: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821A2908: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821A290C: C18300A8  lfs f12, 0xa8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2910: C14300A4  lfs f10, 0xa4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2914: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	// 821A2918: D143009C  stfs f10, 0x9c(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A291C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A2920: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 821A2924: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	pc = 0x821A2928; continue 'dispatch;
            }
            0x821A2928 => {
    //   block [0x821A2928..0x821A292C)
	// 821A2928: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x821A292C; continue 'dispatch;
            }
            0x821A292C => {
    //   block [0x821A292C..0x821A2930)
	// 821A292C: 4E800020  blr
	return;
            }
            0x821A2930 => {
    //   block [0x821A2930..0x821A296C)
	// 821A2930: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A2934: C1A3009C  lfs f13, 0x9c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2938: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821A293C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A2940: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821A2944: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2948: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A294C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A2950: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2954: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A2958: 41990018  bgt cr6, 0x821a2970
	if ctx.cr[6].gt {
	pc = 0x821A2970; continue 'dispatch;
	}
	// 821A295C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821A2960: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821A2964: 419A0008  beq cr6, 0x821a296c
	if ctx.cr[6].eq {
	pc = 0x821A296C; continue 'dispatch;
	}
	// 821A2968: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821A296C; continue 'dispatch;
            }
            0x821A296C => {
    //   block [0x821A296C..0x821A2970)
	// 821A296C: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x821A2970; continue 'dispatch;
            }
            0x821A2970 => {
    //   block [0x821A2970..0x821A2978)
	// 821A2970: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821A2974: 4E800020  blr
	return;
            }
            0x821A2978 => {
    //   block [0x821A2978..0x821A29B0)
	// 821A2978: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A297C: C0030098  lfs f0, 0x98(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2980: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A2984: C1430094  lfs f10, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2988: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A298C: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A2990: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2994: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2998: EDA06B3A  fmadds f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A299C: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A29A0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821A29A4: 4198000C  blt cr6, 0x821a29b0
	if ctx.cr[6].lt {
	pc = 0x821A29B0; continue 'dispatch;
	}
	// 821A29A8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 821A29AC: 40980014  bge cr6, 0x821a29c0
	if !ctx.cr[6].lt {
	pc = 0x821A29C0; continue 'dispatch;
	}
	pc = 0x821A29B0; continue 'dispatch;
            }
            0x821A29B0 => {
    //   block [0x821A29B0..0x821A29C0)
	// 821A29B0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821A29B4: 4098FF74  bge cr6, 0x821a2928
	if !ctx.cr[6].lt {
	pc = 0x821A2928; continue 'dispatch;
	}
	// 821A29B8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 821A29BC: 4199FF6C  bgt cr6, 0x821a2928
	if ctx.cr[6].gt {
	pc = 0x821A2928; continue 'dispatch;
	}
	pc = 0x821A29C0; continue 'dispatch;
            }
            0x821A29C0 => {
    //   block [0x821A29C0..0x821A29E8)
	// 821A29C0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A29C4: D1430088  stfs f10, 0x88(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A29C8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A29CC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A29D0: 409AFF5C  bne cr6, 0x821a292c
	if !ctx.cr[6].eq {
	pc = 0x821A292C; continue 'dispatch;
	}
	// 821A29D4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821A29D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A29DC: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821A29E0: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821A29E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A29E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A29E8 size=356
    let mut pc: u32 = 0x821A29E8;
    'dispatch: loop {
        match pc {
            0x821A29E8 => {
    //   block [0x821A29E8..0x821A2A58)
	// 821A29E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A29EC: 483926D1  bl 0x825350bc
	ctx.lr = 0x821A29F0;
	sub_82535080(ctx, base);
	// 821A29F0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A29F4: 483935F5  bl 0x82535fe8
	ctx.lr = 0x821A29F8;
	sub_82535FB0(ctx, base);
	// 821A29F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A29FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A2A00: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A2A04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A2A08: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821A2A0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A2A10: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821A2A14: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 821A2A18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2A1C: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A2A20: 419A0114  beq cr6, 0x821a2b34
	if ctx.cr[6].eq {
	pc = 0x821A2B34; continue 'dispatch;
	}
	// 821A2A24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A2A28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A2A2C: 38EB0D44  addi r7, r11, 0xd44
	ctx.r[7].s64 = ctx.r[11].s64 + 3396;
	// 821A2A30: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2A34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A2A38: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A2A3C: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821A2A40: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A2A44: 481C7A4D  bl 0x8236a490
	ctx.lr = 0x821A2A48;
	sub_8236A490(ctx, base);
	// 821A2A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2A4C: 419A000C  beq cr6, 0x821a2a58
	if ctx.cr[6].eq {
	pc = 0x821A2A58; continue 'dispatch;
	}
	// 821A2A50: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2A54: 48000008  b 0x821a2a5c
	pc = 0x821A2A5C; continue 'dispatch;
            }
            0x821A2A58 => {
    //   block [0x821A2A58..0x821A2A5C)
	// 821A2A58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A2A5C; continue 'dispatch;
            }
            0x821A2A5C => {
    //   block [0x821A2A5C..0x821A2AD4)
	// 821A2A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2A60: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A2A64: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A2A68: 419A006C  beq cr6, 0x821a2ad4
	if ctx.cr[6].eq {
	pc = 0x821A2AD4; continue 'dispatch;
	}
	// 821A2A6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2A70: FCC0F090  fmr f6, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[30].f64;
	// 821A2A74: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 821A2A78: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A2A7C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A2A80: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A2A84: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 821A2A88: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 821A2A8C: 4BFFFD65  bl 0x821a27f0
	ctx.lr = 0x821A2A90;
	sub_821A27F0(ctx, base);
	// 821A2A90: 3D6082D0  lis r11, -0x7d30
	ctx.r[11].s64 = -2100297728;
	// 821A2A94: 38E300C0  addi r7, r3, 0xc0
	ctx.r[7].s64 = ctx.r[3].s64 + 192;
	// 821A2A98: 392BBFC0  addi r9, r11, -0x4040
	ctx.r[9].s64 = ctx.r[11].s64 + -16448;
	// 821A2A9C: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
	// 821A2AA0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821A2AA4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 821A2AA8: 39090D8C  addi r8, r9, 0xd8c
	ctx.r[8].s64 = ctx.r[9].s64 + 3468;
	// 821A2AAC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 821A2AB0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A2AB4: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A2AB8: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821A2ABC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821A2AC0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A2AC4: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821A2AC8: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A2ACC: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 821A2AD0: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821A2AD4; continue 'dispatch;
            }
            0x821A2AD4 => {
    //   block [0x821A2AD4..0x821A2B18)
	// 821A2AD4: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A2AD8: E96ACB20  ld r11, -0x34e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-13536 as u32) ) };
	// 821A2ADC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A2AE0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A2AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2AE8: 419A0030  beq cr6, 0x821a2b18
	if ctx.cr[6].eq {
	pc = 0x821A2B18; continue 'dispatch;
	}
	// 821A2AEC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2AF0: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A2AF4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2AF8: 409A0020  bne cr6, 0x821a2b18
	if !ctx.cr[6].eq {
	pc = 0x821A2B18; continue 'dispatch;
	}
	// 821A2AFC: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A2B00: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 821A2B04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A2B08: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821A2B0C: 990B0019  stb r8, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[8].u8 ) };
	// 821A2B10: 98EB0025  stb r7, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821A2B14: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	pc = 0x821A2B18; continue 'dispatch;
            }
            0x821A2B18 => {
    //   block [0x821A2B18..0x821A2B34)
	// 821A2B18: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821A2B1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A2B20: F96ACB20  std r11, -0x34e0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-13536 as u32), ctx.r[11].u64 ) };
	// 821A2B24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A2B28: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A2B2C: 48393509  bl 0x82536034
	ctx.lr = 0x821A2B30;
	sub_82535FFC(ctx, base);
	// 821A2B30: 483925DC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821A2B34 => {
    //   block [0x821A2B34..0x821A2B4C)
	// 821A2B34: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A2B38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A2B3C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A2B40: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821A2B44: 483934F1  bl 0x82536034
	ctx.lr = 0x821A2B48;
	sub_82535FFC(ctx, base);
	// 821A2B48: 483925C4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2B50 size=236
    let mut pc: u32 = 0x821A2B50;
    'dispatch: loop {
        match pc {
            0x821A2B50 => {
    //   block [0x821A2B50..0x821A2C20)
	// 821A2B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2B5C: 4BFFFD25  bl 0x821a2880
	ctx.lr = 0x821A2B60;
	sub_821A2880(ctx, base);
	// 821A2B60: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A2B64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A2B68: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A2B6C: 419900C0  bgt cr6, 0x821a2c2c
	if ctx.cr[6].gt {
	pc = 0x821A2C2C; continue 'dispatch;
	}
	// 821A2B70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2B74: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2B78: C16300CC  lfs f11, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A2B7C: C14300C0  lfs f10, 0xc0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2B80: C12300C4  lfs f9, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A2B84: C10300C8  lfs f8, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A2B88: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2B8C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821A2B90: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A2B94: 396BB900  addi r11, r11, -0x4700
	ctx.r[11].s64 = ctx.r[11].s64 + -18176;
	// 821A2B98: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2B9C: ECEC0372  fmuls f7, f12, f13
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BA0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2BA4: ECCC0372  fmuls f6, f12, f13
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BA8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2BAC: ECAC0372  fmuls f5, f12, f13
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BB0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2BB4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2BB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2BBC: EDAB383A  fmadds f13, f11, f0, f7
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 821A2BC0: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821A2BC4: ED6A303A  fmadds f11, f10, f0, f6
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 821A2BC8: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A2BCC: ED69283A  fmadds f11, f9, f0, f5
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[5].f64) as f32) as f64);
	// 821A2BD0: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A2BD4: EC08603A  fmadds f0, f8, f0, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A2BD8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A2BDC: C00B2150  lfs f0, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2BE0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821A2BE4: 4198003C  blt cr6, 0x821a2c20
	if ctx.cr[6].lt {
	pc = 0x821A2C20; continue 'dispatch;
	}
	// 821A2BE8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A2BEC: 3D0082C0  lis r8, -0x7d40
	ctx.r[8].s64 = -2101346304;
	// 821A2BF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821A2BF4: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 821A2BF8: 394ABFC0  addi r10, r10, -0x4040
	ctx.r[10].s64 = ctx.r[10].s64 + -16448;
	// 821A2BFC: 9128BA9C  stw r9, -0x4564(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-17764 as u32), ctx.r[9].u32 ) };
	// 821A2C00: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2C04: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2C08: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2C0C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2C10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2C14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2C18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2C1C: 4E800020  blr
	return;
            }
            0x821A2C20 => {
    //   block [0x821A2C20..0x821A2C2C)
	// 821A2C20: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A2C24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A2C28: 916ABA9C  stw r11, -0x4564(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17764 as u32), ctx.r[11].u32 ) };
	pc = 0x821A2C2C; continue 'dispatch;
            }
            0x821A2C2C => {
    //   block [0x821A2C2C..0x821A2C3C)
	// 821A2C2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2C40 size=96
    let mut pc: u32 = 0x821A2C40;
    'dispatch: loop {
        match pc {
            0x821A2C40 => {
    //   block [0x821A2C40..0x821A2CA0)
	// 821A2C40: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2C44: E96BCB20  ld r11, -0x34e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-13536 as u32) ) };
	// 821A2C48: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A2C4C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821A2C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2C54: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A2C58: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2C5C: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821A2C60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A2C64: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821A2C68: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A2C6C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821A2C70: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821A2C74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A2C78: 3D0082C0  lis r8, -0x7d40
	ctx.r[8].s64 = -2101346304;
	// 821A2C7C: 396BB900  addi r11, r11, -0x4700
	ctx.r[11].s64 = ctx.r[11].s64 + -18176;
	// 821A2C80: 3D4082D0  lis r10, -0x7d30
	ctx.r[10].s64 = -2100297728;
	// 821A2C84: 394ABFC0  addi r10, r10, -0x4040
	ctx.r[10].s64 = ctx.r[10].s64 + -16448;
	// 821A2C88: 9128BA9C  stw r9, -0x4564(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-17764 as u32), ctx.r[9].u32 ) };
	// 821A2C8C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2C90: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2C94: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2C98: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2CA0 size=524
    let mut pc: u32 = 0x821A2CA0;
    'dispatch: loop {
        match pc {
            0x821A2CA0 => {
    //   block [0x821A2CA0..0x821A2D3C)
	// 821A2CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2CA4: 4839240D  bl 0x825350b0
	ctx.lr = 0x821A2CA8;
	sub_82535080(ctx, base);
	// 821A2CA8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821A2CAC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821A2CB0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821A2CB4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2CB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A2CBC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A2CC0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A2CC4: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821A2CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A2CCC: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821A2CD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A2CD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A2CD8: FB5C0000  std r26, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 821A2CDC: 419A01B4  beq cr6, 0x821a2e90
	if ctx.cr[6].eq {
	pc = 0x821A2E90; continue 'dispatch;
	}
	// 821A2CE0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A2CE4: 419A01AC  beq cr6, 0x821a2e90
	if ctx.cr[6].eq {
	pc = 0x821A2E90; continue 'dispatch;
	}
	// 821A2CE8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A2CEC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A2CF0: 396B4A00  addi r11, r11, 0x4a00
	ctx.r[11].s64 = ctx.r[11].s64 + 18944;
	// 821A2CF4: 38EA0D4C  addi r7, r10, 0xd4c
	ctx.r[7].s64 = ctx.r[10].s64 + 3404;
	// 821A2CF8: 394B0470  addi r10, r11, 0x470
	ctx.r[10].s64 = ctx.r[11].s64 + 1136;
	// 821A2CFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2D00: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 821A2D04: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A2D08: 3BBDBE64  addi r29, r29, -0x419c
	ctx.r[29].s64 = ctx.r[29].s64 + -16796;
	// 821A2D0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A2D10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A2D14: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 821A2D18: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A2D1C: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2D20: 1D6B03C0  mulli r11, r11, 0x3c0
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 960 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A2D24: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A2D28: 481C7769  bl 0x8236a490
	ctx.lr = 0x821A2D2C;
	sub_8236A490(ctx, base);
	// 821A2D2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2D30: 419A000C  beq cr6, 0x821a2d3c
	if ctx.cr[6].eq {
	pc = 0x821A2D3C; continue 'dispatch;
	}
	// 821A2D34: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2D38: 48000008  b 0x821a2d40
	pc = 0x821A2D40; continue 'dispatch;
            }
            0x821A2D3C => {
    //   block [0x821A2D3C..0x821A2D40)
	// 821A2D3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821A2D40; continue 'dispatch;
            }
            0x821A2D40 => {
    //   block [0x821A2D40..0x821A2DA8)
	// 821A2D40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A2D44: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A2D48: 907C0004  stw r3, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A2D4C: 419A005C  beq cr6, 0x821a2da8
	if ctx.cr[6].eq {
	pc = 0x821A2DA8; continue 'dispatch;
	}
	// 821A2D50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A2D54: FCC0F090  fmr f6, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[30].f64;
	// 821A2D58: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 821A2D5C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A2D60: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A2D64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2D68: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 821A2D6C: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 821A2D70: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A2D74: 4BFFFA7D  bl 0x821a27f0
	ctx.lr = 0x821A2D78;
	sub_821A27F0(ctx, base);
	// 821A2D78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A2D7C: 93E300E0  stw r31, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[31].u32 ) };
	// 821A2D80: 392300C0  addi r9, r3, 0xc0
	ctx.r[9].s64 = ctx.r[3].s64 + 192;
	// 821A2D84: 394B0DAC  addi r10, r11, 0xdac
	ctx.r[10].s64 = ctx.r[11].s64 + 3500;
	// 821A2D88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821A2D8C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821A2D90: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A2D94: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821A2D98: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821A2D9C: E95E0008  ld r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821A2DA0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A2DA4: 48000008  b 0x821a2dac
	pc = 0x821A2DAC; continue 'dispatch;
            }
            0x821A2DA8 => {
    //   block [0x821A2DA8..0x821A2DAC)
	// 821A2DA8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x821A2DAC; continue 'dispatch;
            }
            0x821A2DAC => {
    //   block [0x821A2DAC..0x821A2E24)
	// 821A2DAC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2DB0: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2DB4: 38EBCA00  addi r7, r11, -0x3600
	ctx.r[7].s64 = ctx.r[11].s64 + -13824;
	// 821A2DB8: 554B183E  rotlwi r11, r10, 3
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A2DBC: 7D6B382A  ldx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	// 821A2DC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A2DC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A2DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2DCC: 419A0058  beq cr6, 0x821a2e24
	if ctx.cr[6].eq {
	pc = 0x821A2E24; continue 'dispatch;
	}
	// 821A2DD0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2DD4: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A2DD8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2DDC: 409A0048  bne cr6, 0x821a2e24
	if !ctx.cr[6].eq {
	pc = 0x821A2E24; continue 'dispatch;
	}
	// 821A2DE0: 394B00D0  addi r10, r11, 0xd0
	ctx.r[10].s64 = ctx.r[11].s64 + 208;
	// 821A2DE4: 392900D0  addi r9, r9, 0xd0
	ctx.r[9].s64 = ctx.r[9].s64 + 208;
	// 821A2DE8: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A2DEC: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821A2DF0: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821A2DF4: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A2DF8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2DFC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2E00: 409A003C  bne cr6, 0x821a2e3c
	if !ctx.cr[6].eq {
	pc = 0x821A2E3C; continue 'dispatch;
	}
	// 821A2E04: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A2E08: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821A2E0C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A2E10: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 821A2E14: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 821A2E18: 990B0025  stb r8, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[8].u8 ) };
	// 821A2E1C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A2E20: 4800001C  b 0x821a2e3c
	pc = 0x821A2E3C; continue 'dispatch;
            }
            0x821A2E24 => {
    //   block [0x821A2E24..0x821A2E3C)
	// 821A2E24: 397B0050  addi r11, r27, 0x50
	ctx.r[11].s64 = ctx.r[27].s64 + 80;
	// 821A2E28: 394900D0  addi r10, r9, 0xd0
	ctx.r[10].s64 = ctx.r[9].s64 + 208;
	// 821A2E2C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2E30: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2E34: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2E38: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821A2E3C; continue 'dispatch;
            }
            0x821A2E3C => {
    //   block [0x821A2E3C..0x821A2E58)
	// 821A2E3C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A2E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2E44: 419A0014  beq cr6, 0x821a2e58
	if ctx.cr[6].eq {
	pc = 0x821A2E58; continue 'dispatch;
	}
	// 821A2E48: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2E4C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2E50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A2E54: 419A0008  beq cr6, 0x821a2e5c
	if ctx.cr[6].eq {
	pc = 0x821A2E5C; continue 'dispatch;
	}
	pc = 0x821A2E58; continue 'dispatch;
            }
            0x821A2E58 => {
    //   block [0x821A2E58..0x821A2E5C)
	// 821A2E58: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821A2E5C; continue 'dispatch;
            }
            0x821A2E5C => {
    //   block [0x821A2E5C..0x821A2E90)
	// 821A2E5C: 395B0050  addi r10, r27, 0x50
	ctx.r[10].s64 = ctx.r[27].s64 + 80;
	// 821A2E60: E93C0000  ld r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821A2E64: 390B00B0  addi r8, r11, 0xb0
	ctx.r[8].s64 = ctx.r[11].s64 + 176;
	// 821A2E68: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821A2E6C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821A2E70: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2E74: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821A2E78: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2E7C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2E80: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A2E84: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A2E88: 7D2B392A  stdx r9, r11, r7
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[9].u64) };
	// 821A2E8C: 48000008  b 0x821a2e94
	pc = 0x821A2E94; continue 'dispatch;
            }
            0x821A2E90 => {
    //   block [0x821A2E90..0x821A2E94)
	// 821A2E90: FB5C0000  std r26, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	pc = 0x821A2E94; continue 'dispatch;
            }
            0x821A2E94 => {
    //   block [0x821A2E94..0x821A2EAC)
	// 821A2E94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A2E98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A2E9C: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821A2EA0: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A2EA4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821A2EA8: 48392258  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2EB0 size=184
    let mut pc: u32 = 0x821A2EB0;
    'dispatch: loop {
        match pc {
            0x821A2EB0 => {
    //   block [0x821A2EB0..0x821A2F58)
	// 821A2EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A2EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2EBC: 4BFFF9C5  bl 0x821a2880
	ctx.lr = 0x821A2EC0;
	sub_821A2880(ctx, base);
	// 821A2EC0: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A2EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A2EC8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A2ECC: 4199008C  bgt cr6, 0x821a2f58
	if ctx.cr[6].gt {
	pc = 0x821A2F58; continue 'dispatch;
	}
	// 821A2ED0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A2ED4: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A2ED8: C18300D0  lfs f12, 0xd0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A2EDC: 812300E0  lwz r9, 0xe0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A2EE0: 6168BE64  ori r8, r11, 0xbe64
	ctx.r[8].u64 = ctx.r[11].u64 | 48740;
	// 821A2EE4: C16300D4  lfs f11, 0xd4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A2EE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A2EEC: C14300D8  lfs f10, 0xd8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A2EF0: C12300C0  lfs f9, 0xc0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A2EF4: C10300C4  lfs f8, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A2EF8: C0E300C8  lfs f7, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A2EFC: 7D0940AE  lbzx r8, r9, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A2F00: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A2F04: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A2F08: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821A2F0C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A2F10: 394B4A00  addi r10, r11, 0x4a00
	ctx.r[10].s64 = ctx.r[11].s64 + 18944;
	// 821A2F14: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821A2F18: 392A04C0  addi r9, r10, 0x4c0
	ctx.r[9].s64 = ctx.r[10].s64 + 1216;
	// 821A2F1C: 1D4803C0  mulli r10, r8, 0x3c0
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 960 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821A2F20: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A2F24: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2F28: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A2F2C: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A2F30: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A2F34: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A2F38: ED88583A  fmadds f12, f8, f0, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A2F3C: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A2F40: EC07683A  fmadds f0, f7, f0, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A2F44: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A2F48: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2F4C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2F50: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2F54: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821A2F58; continue 'dispatch;
            }
            0x821A2F58 => {
    //   block [0x821A2F58..0x821A2F68)
	// 821A2F58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A2F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A2F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A2F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A2F68 size=116
    let mut pc: u32 = 0x821A2F68;
    'dispatch: loop {
        match pc {
            0x821A2F68 => {
    //   block [0x821A2F68..0x821A2FDC)
	// 821A2F68: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A2F6C: 814300E0  lwz r10, 0xe0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A2F70: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821A2F74: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A2F78: 396BCA00  addi r11, r11, -0x3600
	ctx.r[11].s64 = ctx.r[11].s64 + -13824;
	// 821A2F7C: 7D2A48AE  lbzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A2F80: 552A183E  rotlwi r10, r9, 3
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A2F84: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A2F88: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A2F8C: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821A2F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A2F94: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A2F98: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A2F9C: 8101FFF0  lwz r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821A2FA0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A2FA4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821A2FA8: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821A2FAC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821A2FB0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A2FB4: 1D2903C0  mulli r9, r9, 0x3c0
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 960 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A2FB8: 394B4A00  addi r10, r11, 0x4a00
	ctx.r[10].s64 = ctx.r[11].s64 + 18944;
	// 821A2FBC: 396300D0  addi r11, r3, 0xd0
	ctx.r[11].s64 = ctx.r[3].s64 + 208;
	// 821A2FC0: 394A04C0  addi r10, r10, 0x4c0
	ctx.r[10].s64 = ctx.r[10].s64 + 1216;
	// 821A2FC4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821A2FC8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A2FCC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A2FD0: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A2FD4: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A2FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A2FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A2FE0 size=696
    let mut pc: u32 = 0x821A2FE0;
    'dispatch: loop {
        match pc {
            0x821A2FE0 => {
    //   block [0x821A2FE0..0x821A306C)
	// 821A2FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A2FE4: 483920CD  bl 0x825350b0
	ctx.lr = 0x821A2FE8;
	sub_82535080(ctx, base);
	// 821A2FE8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821A2FEC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821A2FF0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821A2FF4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A2FF8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A2FFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821A3000: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821A3004: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821A3008: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A300C: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821A3010: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821A3014: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821A3018: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A301C: FB7A0000  std r27, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821A3020: 419A025C  beq cr6, 0x821a327c
	if ctx.cr[6].eq {
	pc = 0x821A327C; continue 'dispatch;
	}
	// 821A3024: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A3028: 419A0254  beq cr6, 0x821a327c
	if ctx.cr[6].eq {
	pc = 0x821A327C; continue 'dispatch;
	}
	// 821A302C: 2B1C0007  cmplwi cr6, r28, 7
	ctx.cr[6].compare_u32(ctx.r[28].u32, 7 as u32, &mut ctx.xer);
	// 821A3030: 4199024C  bgt cr6, 0x821a327c
	if ctx.cr[6].gt {
	pc = 0x821A327C; continue 'dispatch;
	}
	// 821A3034: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A3038: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A303C: 38EB0D54  addi r7, r11, 0xd54
	ctx.r[7].s64 = ctx.r[11].s64 + 3412;
	// 821A3040: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A3044: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3048: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A304C: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 821A3050: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3054: 481C743D  bl 0x8236a490
	ctx.lr = 0x821A3058;
	sub_8236A490(ctx, base);
	// 821A3058: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A305C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A3060: 419A000C  beq cr6, 0x821a306c
	if ctx.cr[6].eq {
	pc = 0x821A306C; continue 'dispatch;
	}
	// 821A3064: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3068: 48000008  b 0x821a3070
	pc = 0x821A3070; continue 'dispatch;
            }
            0x821A306C => {
    //   block [0x821A306C..0x821A3070)
	// 821A306C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821A3070; continue 'dispatch;
            }
            0x821A3070 => {
    //   block [0x821A3070..0x821A3118)
	// 821A3070: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A3074: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A3078: 93DA0004  stw r30, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A307C: 419A0204  beq cr6, 0x821a3280
	if ctx.cr[6].eq {
	pc = 0x821A3280; continue 'dispatch;
	}
	// 821A3080: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3084: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A3088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A308C: FCC0F090  fmr f6, f30
	ctx.f[6].f64 = ctx.f[30].f64;
	// 821A3090: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 821A3094: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A3098: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A309C: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 821A30A0: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 821A30A4: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A30A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A30AC: 4BFFF745  bl 0x821a27f0
	ctx.lr = 0x821A30B0;
	sub_821A27F0(ctx, base);
	// 821A30B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A30B4: 397E00C4  addi r11, r30, 0xc4
	ctx.r[11].s64 = ctx.r[30].s64 + 196;
	// 821A30B8: 394A0DCC  addi r10, r10, 0xdcc
	ctx.r[10].s64 = ctx.r[10].s64 + 3532;
	// 821A30BC: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 821A30C0: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 821A30C4: 38E90D5C  addi r7, r9, 0xd5c
	ctx.r[7].s64 = ctx.r[9].s64 + 3420;
	// 821A30C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A30CC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A30D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A30D4: FB7E00B0  std r27, 0xb0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 821A30D8: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 821A30DC: 93BE00B8  stw r29, 0xb8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[29].u32 ) };
	// 821A30E0: 939E00BC  stw r28, 0xbc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), ctx.r[28].u32 ) };
	// 821A30E4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A30E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A30EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A30F0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A30F4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A30F8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A30FC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3100: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A3104: 481C738D  bl 0x8236a490
	ctx.lr = 0x821A3108;
	sub_8236A490(ctx, base);
	// 821A3108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A310C: 419A000C  beq cr6, 0x821a3118
	if ctx.cr[6].eq {
	pc = 0x821A3118; continue 'dispatch;
	}
	// 821A3110: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3114: 48000008  b 0x821a311c
	pc = 0x821A311C; continue 'dispatch;
            }
            0x821A3118 => {
    //   block [0x821A3118..0x821A311C)
	// 821A3118: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821A311C; continue 'dispatch;
            }
            0x821A311C => {
    //   block [0x821A311C..0x821A3224)
	// 821A311C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3120: 917E00B0  stw r11, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 821A3124: 907E00B4  stw r3, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 821A3128: 419A0118  beq cr6, 0x821a3240
	if ctx.cr[6].eq {
	pc = 0x821A3240; continue 'dispatch;
	}
	// 821A312C: 4BFFDF45  bl 0x821a1070
	ctx.lr = 0x821A3130;
	sub_821A1070(ctx, base);
	// 821A3130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3134: 419A010C  beq cr6, 0x821a3240
	if ctx.cr[6].eq {
	pc = 0x821A3240; continue 'dispatch;
	}
	// 821A3138: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A313C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3140: 38830080  addi r4, r3, 0x80
	ctx.r[4].s64 = ctx.r[3].s64 + 128;
	// 821A3144: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A3148: 39640070  addi r11, r4, 0x70
	ctx.r[11].s64 = ctx.r[4].s64 + 112;
	// 821A314C: 39440080  addi r10, r4, 0x80
	ctx.r[10].s64 = ctx.r[4].s64 + 128;
	// 821A3150: 3FBD0002  addis r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 131072;
	// 821A3154: 211C0008  subfic r8, r28, 8
	ctx.xer.ca = ctx.r[28].u32 <= 8 as u32;
	ctx.r[8].s64 = (8 as i64) - ctx.r[28].s64;
	// 821A3158: 3920EFEC  li r9, -0x1014
	ctx.r[9].s64 = -4116;
	// 821A315C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A3160: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A3164: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3168: 3BBDBE64  addi r29, r29, -0x419c
	ctx.r[29].s64 = ctx.r[29].s64 + -16796;
	// 821A316C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A3170: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821A3174: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3178: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A317C: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3180: 90EB000C  stw r7, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A3184: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3188: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A318C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3190: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A3194: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3198: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821A319C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A31A0: D3E40090  stfs f31, 0x90(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A31A4: 9B640021  stb r27, 0x21(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(33 as u32), ctx.r[27].u8 ) };
	// 821A31A8: B1240022  sth r9, 0x22(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(34 as u32), ctx.r[9].u16 ) };
	// 821A31AC: 9904001F  stb r8, 0x1f(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(31 as u32), ctx.r[8].u8 ) };
	// 821A31B0: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821A31B4: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A31B8: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A31BC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A31C0: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A31C4: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 821A31C8: 481DB001  bl 0x8237e1c8
	ctx.lr = 0x821A31CC;
	sub_8237E1C8(ctx, base);
	// 821A31CC: 907E00C0  stw r3, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[3].u32 ) };
	// 821A31D0: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A31D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A31D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A31DC: 396BCA20  addi r11, r11, -0x35e0
	ctx.r[11].s64 = ctx.r[11].s64 + -13792;
	// 821A31E0: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821A31E4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A31E8: 7D4A582A  ldx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A31EC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A31F0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A31F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A31F8: 419A002C  beq cr6, 0x821a3224
	if ctx.cr[6].eq {
	pc = 0x821A3224; continue 'dispatch;
	}
	// 821A31FC: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3200: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A3204: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A3208: 409A001C  bne cr6, 0x821a3224
	if !ctx.cr[6].eq {
	pc = 0x821A3224; continue 'dispatch;
	}
	// 821A320C: A12A0014  lhz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A3210: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 821A3214: 9B6A0025  stb r27, 0x25(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A3218: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821A321C: 990A0019  stb r8, 0x19(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25 as u32), ctx.r[8].u8 ) };
	// 821A3220: B12A0014  sth r9, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	pc = 0x821A3224; continue 'dispatch;
            }
            0x821A3224 => {
    //   block [0x821A3224..0x821A3240)
	// 821A3224: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3228: E93A0000  ld r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 821A322C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A3230: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821A3234: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3238: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 821A323C: 48000044  b 0x821a3280
	pc = 0x821A3280; continue 'dispatch;
            }
            0x821A3240 => {
    //   block [0x821A3240..0x821A327C)
	// 821A3240: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A3244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3248: 419A0038  beq cr6, 0x821a3280
	if ctx.cr[6].eq {
	pc = 0x821A3280; continue 'dispatch;
	}
	// 821A324C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3250: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3254: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3258: 409A0028  bne cr6, 0x821a3280
	if !ctx.cr[6].eq {
	pc = 0x821A3280; continue 'dispatch;
	}
	// 821A325C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A3260: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A3264: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A3268: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A326C: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 821A3270: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 821A3274: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821A3278: 48000008  b 0x821a3280
	pc = 0x821A3280; continue 'dispatch;
            }
            0x821A327C => {
    //   block [0x821A327C..0x821A3280)
	// 821A327C: FB7A0000  std r27, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	pc = 0x821A3280; continue 'dispatch;
            }
            0x821A3280 => {
    //   block [0x821A3280..0x821A3298)
	// 821A3280: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821A3284: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A3288: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821A328C: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A3290: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821A3294: 48391E6C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3298 size=120
    let mut pc: u32 = 0x821A3298;
    'dispatch: loop {
        match pc {
            0x821A3298 => {
    //   block [0x821A3298..0x821A32D4)
	// 821A3298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A329C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A32A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A32A4: 4BFFF5DD  bl 0x821a2880
	ctx.lr = 0x821A32A8;
	sub_821A2880(ctx, base);
	// 821A32A8: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A32AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A32B0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A32B4: 4199004C  bgt cr6, 0x821a3300
	if ctx.cr[6].gt {
	pc = 0x821A3300; continue 'dispatch;
	}
	// 821A32B8: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A32BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A32C0: 419A0014  beq cr6, 0x821a32d4
	if ctx.cr[6].eq {
	pc = 0x821A32D4; continue 'dispatch;
	}
	// 821A32C4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A32C8: 812300B0  lwz r9, 0xb0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A32CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A32D0: 419A0008  beq cr6, 0x821a32d8
	if ctx.cr[6].eq {
	pc = 0x821A32D8; continue 'dispatch;
	}
	pc = 0x821A32D4; continue 'dispatch;
            }
            0x821A32D4 => {
    //   block [0x821A32D4..0x821A32D8)
	// 821A32D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A32D8; continue 'dispatch;
            }
            0x821A32D8 => {
    //   block [0x821A32D8..0x821A3300)
	// 821A32D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A32DC: C1A30088  lfs f13, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A32E0: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A32E4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A32E8: D00B0110  stfs f0, 0x110(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821A32EC: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A32F0: C1A30088  lfs f13, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A32F4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A32F8: D00B00F8  stfs f0, 0xf8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 821A32FC: D00B0108  stfs f0, 0x108(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	pc = 0x821A3300; continue 'dispatch;
            }
            0x821A3300 => {
    //   block [0x821A3300..0x821A3310)
	// 821A3300: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A3304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A330C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3310 size=120
    let mut pc: u32 = 0x821A3310;
    'dispatch: loop {
        match pc {
            0x821A3310 => {
    //   block [0x821A3310..0x821A3354)
	// 821A3310: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A3314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3318: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A331C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3320: 814300B0  lwz r10, 0xb0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3324: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A3328: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821A332C: 816300C0  lwz r11, 0xc0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 821A3330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3334: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3338: 814300B4  lwz r10, 0xb4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A333C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3340: 419A0014  beq cr6, 0x821a3354
	if ctx.cr[6].eq {
	pc = 0x821A3354; continue 'dispatch;
	}
	// 821A3344: 816A0030  lwz r11, 0x30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3348: 812300B0  lwz r9, 0xb0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A334C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3350: 419A0008  beq cr6, 0x821a3358
	if ctx.cr[6].eq {
	pc = 0x821A3358; continue 'dispatch;
	}
	pc = 0x821A3354; continue 'dispatch;
            }
            0x821A3354 => {
    //   block [0x821A3354..0x821A3358)
	// 821A3354: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A3358; continue 'dispatch;
            }
            0x821A3358 => {
    //   block [0x821A3358..0x821A3388)
	// 821A3358: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A335C: 812300B8  lwz r9, 0xb8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A3360: 388A0080  addi r4, r10, 0x80
	ctx.r[4].s64 = ctx.r[10].s64 + 128;
	// 821A3364: 6168BE64  ori r8, r11, 0xbe64
	ctx.r[8].u64 = ctx.r[11].u64 | 48740;
	// 821A3368: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A336C: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A3370: 7D6940AE  lbzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A3374: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A3378: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A337C: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A3380: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 821A3384: 481DB09C  b 0x8237e420
	sub_8237E420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3388 size=4
    let mut pc: u32 = 0x821A3388;
    'dispatch: loop {
        match pc {
            0x821A3388 => {
    //   block [0x821A3388..0x821A338C)
	// 821A3388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3390 size=164
    let mut pc: u32 = 0x821A3390;
    'dispatch: loop {
        match pc {
            0x821A3390 => {
    //   block [0x821A3390..0x821A33C0)
	// 821A3390: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A3394: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3398: 419A0094  beq cr6, 0x821a342c
	if ctx.cr[6].eq {
	pc = 0x821A342C; continue 'dispatch;
	}
	// 821A339C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A33A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A33A4: 419A0088  beq cr6, 0x821a342c
	if ctx.cr[6].eq {
	pc = 0x821A342C; continue 'dispatch;
	}
	// 821A33A8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A33AC: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A33B0: 390BCA20  addi r8, r11, -0x35e0
	ctx.r[8].s64 = ctx.r[11].s64 + -13792;
	// 821A33B4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A33B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A33BC: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	pc = 0x821A33C0; continue 'dispatch;
            }
            0x821A33C0 => {
    //   block [0x821A33C0..0x821A341C)
	// 821A33C0: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 821A33C4: 40980068  bge cr6, 0x821a342c
	if !ctx.cr[6].lt {
	pc = 0x821A342C; continue 'dispatch;
	}
	// 821A33C8: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 821A33CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A33D0: 419A004C  beq cr6, 0x821a341c
	if ctx.cr[6].eq {
	pc = 0x821A341C; continue 'dispatch;
	}
	// 821A33D4: 7D6348AE  lbzx r11, r3, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A33D8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A33DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A33E0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A33E4: 7D6B402A  ldx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	// 821A33E8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821A33EC: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821A33F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A33F4: 419A0028  beq cr6, 0x821a341c
	if ctx.cr[6].eq {
	pc = 0x821A341C; continue 'dispatch;
	}
	// 821A33F8: 80AB0030  lwz r5, 0x30(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A33FC: 83E1FFF0  lwz r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821A3400: 7F05F840  cmplw cr6, r5, r31
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A3404: 409A0018  bne cr6, 0x821a341c
	if !ctx.cr[6].eq {
	pc = 0x821A341C; continue 'dispatch;
	}
	// 821A3408: A0AB0014  lhz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A340C: 98CB0019  stb r6, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[6].u8 ) };
	// 821A3410: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 821A3414: 98EB0025  stb r7, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821A3418: B0AB0014  sth r5, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[5].u16 ) };
	pc = 0x821A341C; continue 'dispatch;
            }
            0x821A341C => {
    //   block [0x821A341C..0x821A342C)
	// 821A341C: 5484F87E  srwi r4, r4, 1
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shr(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A3420: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A3424: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3428: 409AFF98  bne cr6, 0x821a33c0
	if !ctx.cr[6].eq {
	pc = 0x821A33C0; continue 'dispatch;
	}
	pc = 0x821A342C; continue 'dispatch;
            }
            0x821A342C => {
    //   block [0x821A342C..0x821A3434)
	// 821A342C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A3430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3438 size=312
    let mut pc: u32 = 0x821A3438;
    'dispatch: loop {
        match pc {
            0x821A3438 => {
    //   block [0x821A3438..0x821A3490)
	// 821A3438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A343C: 48391C81  bl 0x825350bc
	ctx.lr = 0x821A3440;
	sub_82535080(ctx, base);
	// 821A3440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3444: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A3448: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A344C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821A3450: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A3454: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A3458: 419A0108  beq cr6, 0x821a3560
	if ctx.cr[6].eq {
	pc = 0x821A3560; continue 'dispatch;
	}
	// 821A345C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A3460: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A3464: 38EB0D64  addi r7, r11, 0xd64
	ctx.r[7].s64 = ctx.r[11].s64 + 3428;
	// 821A3468: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A346C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3470: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A3474: 386000B8  li r3, 0xb8
	ctx.r[3].s64 = 184;
	// 821A3478: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A347C: 481C7015  bl 0x8236a490
	ctx.lr = 0x821A3480;
	sub_8236A490(ctx, base);
	// 821A3480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3484: 419A000C  beq cr6, 0x821a3490
	if ctx.cr[6].eq {
	pc = 0x821A3490; continue 'dispatch;
	}
	// 821A3488: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A348C: 48000008  b 0x821a3494
	pc = 0x821A3494; continue 'dispatch;
            }
            0x821A3490 => {
    //   block [0x821A3490..0x821A3494)
	// 821A3490: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A3494; continue 'dispatch;
            }
            0x821A3494 => {
    //   block [0x821A3494..0x821A34EC)
	// 821A3494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3498: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A349C: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821A34A0: 419A004C  beq cr6, 0x821a34ec
	if ctx.cr[6].eq {
	pc = 0x821A34EC; continue 'dispatch;
	}
	// 821A34A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A34A8: C0EB2068  lfs f7, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A34AC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A34B0: FC403890  fmr f2, f7
	ctx.f[2].f64 = ctx.f[7].f64;
	// 821A34B4: C0CBD4CC  lfs f6, -0x2b34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821A34B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A34BC: C0ABBA38  lfs f5, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821A34C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821A34C4: FC602890  fmr f3, f5
	ctx.f[3].f64 = ctx.f[5].f64;
	// 821A34C8: C08B2934  lfs f4, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821A34CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A34D0: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A34D4: 4BFFF31D  bl 0x821a27f0
	ctx.lr = 0x821A34D8;
	sub_821A27F0(ctx, base);
	// 821A34D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A34DC: 93E300B0  stw r31, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 821A34E0: 93C300B4  stw r30, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 821A34E4: 396B0DEC  addi r11, r11, 0xdec
	ctx.r[11].s64 = ctx.r[11].s64 + 3564;
	// 821A34E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821A34EC; continue 'dispatch;
            }
            0x821A34EC => {
    //   block [0x821A34EC..0x821A3544)
	// 821A34EC: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 821A34F0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A34F4: 394ABE64  addi r10, r10, -0x419c
	ctx.r[10].s64 = ctx.r[10].s64 + -16796;
	// 821A34F8: 396BC9E0  addi r11, r11, -0x3620
	ctx.r[11].s64 = ctx.r[11].s64 + -13856;
	// 821A34FC: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3500: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A3504: 7D29582A  ldx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A3508: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821A350C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A3510: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A3514: 419A0030  beq cr6, 0x821a3544
	if ctx.cr[6].eq {
	pc = 0x821A3544; continue 'dispatch;
	}
	// 821A3518: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A351C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A3520: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821A3524: 409A0020  bne cr6, 0x821a3544
	if !ctx.cr[6].eq {
	pc = 0x821A3544; continue 'dispatch;
	}
	// 821A3528: A1090014  lhz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A352C: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 821A3530: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A3534: 61088000  ori r8, r8, 0x8000
	ctx.r[8].u64 = ctx.r[8].u64 | 32768;
	// 821A3538: 98E90019  stb r7, 0x19(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 821A353C: 98C90025  stb r6, 0x25(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(37 as u32), ctx.r[6].u8 ) };
	// 821A3540: B1090014  sth r8, 0x14(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	pc = 0x821A3544; continue 'dispatch;
            }
            0x821A3544 => {
    //   block [0x821A3544..0x821A3560)
	// 821A3544: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A354C: E93D0000  ld r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821A3550: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821A3554: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	// 821A3558: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A355C: 48391BB0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821A3560 => {
    //   block [0x821A3560..0x821A3570)
	// 821A3560: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A3564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A3568: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A356C: 48391BA0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3570 size=508
    let mut pc: u32 = 0x821A3570;
    'dispatch: loop {
        match pc {
            0x821A3570 => {
    //   block [0x821A3570..0x821A35C4)
	// 821A3570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3574: 48391B45  bl 0x825350b8
	ctx.lr = 0x821A3578;
	sub_82535080(ctx, base);
	// 821A3578: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821A357C: 48392A69  bl 0x82535fe4
	ctx.lr = 0x821A3580;
	sub_82535FB0(ctx, base);
	// 821A3580: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3588: C37F0088  lfs f27, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A358C: 4BFFF2F5  bl 0x821a2880
	ctx.lr = 0x821A3590;
	sub_821A2880(ctx, base);
	// 821A3590: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A3594: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A3598: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A359C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A35A0: C38A1FF8  lfs f28, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A35A4: 419A0020  beq cr6, 0x821a35c4
	if ctx.cr[6].eq {
	pc = 0x821A35C4; continue 'dispatch;
	}
	// 821A35A8: 409901B4  ble cr6, 0x821a375c
	if !ctx.cr[6].gt {
	pc = 0x821A375C; continue 'dispatch;
	}
	// 821A35AC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821A35B0: 409900E8  ble cr6, 0x821a3698
	if !ctx.cr[6].gt {
	pc = 0x821A3698; continue 'dispatch;
	}
	// 821A35B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A35B8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821A35BC: 48392A75  bl 0x82536030
	ctx.lr = 0x821A35C0;
	sub_82535FFC(ctx, base);
	// 821A35C0: 48391B48  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821A35C4 => {
    //   block [0x821A35C4..0x821A35F0)
	// 821A35C4: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 821A35C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A35CC: 409A00CC  bne cr6, 0x821a3698
	if !ctx.cr[6].eq {
	pc = 0x821A3698; continue 'dispatch;
	}
	// 821A35D0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A35D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A35D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A35DC: 419A0014  beq cr6, 0x821a35f0
	if ctx.cr[6].eq {
	pc = 0x821A35F0; continue 'dispatch;
	}
	// 821A35E0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A35E4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A35E8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A35EC: 419A000C  beq cr6, 0x821a35f8
	if ctx.cr[6].eq {
	pc = 0x821A35F8; continue 'dispatch;
	}
	pc = 0x821A35F0; continue 'dispatch;
            }
            0x821A35F0 => {
    //   block [0x821A35F0..0x821A35F8)
	// 821A35F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A35F4: 48000008  b 0x821a35fc
	pc = 0x821A35FC; continue 'dispatch;
            }
            0x821A35F8 => {
    //   block [0x821A35F8..0x821A35FC)
	// 821A35F8: 386A0090  addi r3, r10, 0x90
	ctx.r[3].s64 = ctx.r[10].s64 + 144;
	pc = 0x821A35FC; continue 'dispatch;
            }
            0x821A35FC => {
    //   block [0x821A35FC..0x821A3618)
	// 821A35FC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3600: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3604: 419A0014  beq cr6, 0x821a3618
	if ctx.cr[6].eq {
	pc = 0x821A3618; continue 'dispatch;
	}
	// 821A3608: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A360C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3610: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3614: 419A000C  beq cr6, 0x821a3620
	if ctx.cr[6].eq {
	pc = 0x821A3620; continue 'dispatch;
	}
	pc = 0x821A3618; continue 'dispatch;
            }
            0x821A3618 => {
    //   block [0x821A3618..0x821A3620)
	// 821A3618: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A361C: 48000028  b 0x821a3644
	pc = 0x821A3644; continue 'dispatch;
            }
            0x821A3620 => {
    //   block [0x821A3620..0x821A363C)
	// 821A3620: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3624: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3628: 419A0014  beq cr6, 0x821a363c
	if ctx.cr[6].eq {
	pc = 0x821A363C; continue 'dispatch;
	}
	// 821A362C: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3630: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3634: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A3638: 419A0008  beq cr6, 0x821a3640
	if ctx.cr[6].eq {
	pc = 0x821A3640; continue 'dispatch;
	}
	pc = 0x821A363C; continue 'dispatch;
            }
            0x821A363C => {
    //   block [0x821A363C..0x821A3640)
	// 821A363C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A3640; continue 'dispatch;
            }
            0x821A3640 => {
    //   block [0x821A3640..0x821A3644)
	// 821A3640: 3BAA0090  addi r29, r10, 0x90
	ctx.r[29].s64 = ctx.r[10].s64 + 144;
	pc = 0x821A3644; continue 'dispatch;
            }
            0x821A3644 => {
    //   block [0x821A3644..0x821A3670)
	// 821A3644: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3648: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821A364C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A3650: C14B2198  lfs f10, 0x2198(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A3654: 419A001C  beq cr6, 0x821a3670
	if ctx.cr[6].eq {
	pc = 0x821A3670; continue 'dispatch;
	}
	// 821A3658: C01F00A0  lfs f0, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A365C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A3660: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A3664: EC4002B2  fmuls f2, f0, f10
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 821A3668: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A366C: 4BFB1B8D  bl 0x821551f8
	ctx.lr = 0x821A3670;
	sub_821551F8(ctx, base);
	pc = 0x821A3670; continue 'dispatch;
            }
            0x821A3670 => {
    //   block [0x821A3670..0x821A3694)
	// 821A3670: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A3674: 419A0020  beq cr6, 0x821a3694
	if ctx.cr[6].eq {
	pc = 0x821A3694; continue 'dispatch;
	}
	// 821A3678: C01F00A0  lfs f0, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A367C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A3680: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A3684: EC4002B2  fmuls f2, f0, f10
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 821A3688: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A368C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A3690: 4BFB1B69  bl 0x821551f8
	ctx.lr = 0x821A3694;
	sub_821551F8(ctx, base);
	pc = 0x821A3694; continue 'dispatch;
            }
            0x821A3694 => {
    //   block [0x821A3694..0x821A3698)
	// 821A3694: 939F00B4  stw r28, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	pc = 0x821A3698; continue 'dispatch;
            }
            0x821A3698 => {
    //   block [0x821A3698..0x821A36C0)
	// 821A3698: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A369C: C3FF0088  lfs f31, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A36A0: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A36A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A36A8: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A36AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A36B0: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A36B4: C3AA2074  lfs f29, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A36B8: 419A0008  beq cr6, 0x821a36c0
	if ctx.cr[6].eq {
	pc = 0x821A36C0; continue 'dispatch;
	}
	// 821A36BC: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	pc = 0x821A36C0; continue 'dispatch;
            }
            0x821A36C0 => {
    //   block [0x821A36C0..0x821A36EC)
	// 821A36C0: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 821A36C4: 3863CF2C  addi r3, r3, -0x30d4
	ctx.r[3].s64 = ctx.r[3].s64 + -12500;
	// 821A36C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A36CC: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A36D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A36D4: 4E800421  bctrl
	ctx.lr = 0x821A36D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A36D8: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A36DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A36E0: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A36E4: 419A0008  beq cr6, 0x821a36ec
	if ctx.cr[6].eq {
	pc = 0x821A36EC; continue 'dispatch;
	}
	// 821A36E8: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
            }
            0x821A36EC => {
    //   block [0x821A36EC..0x821A3734)
	// 821A36EC: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 821A36F0: 3863D044  addi r3, r3, -0x2fbc
	ctx.r[3].s64 = ctx.r[3].s64 + -12220;
	// 821A36F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A36F8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A36FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A3700: 4E800421  bctrl
	ctx.lr = 0x821A3704;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A3704: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A3708: FF1FE000  fcmpu cr6, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 821A370C: 3BCBC470  addi r30, r11, -0x3b90
	ctx.r[30].s64 = ctx.r[11].s64 + -15248;
	// 821A3710: 409A0024  bne cr6, 0x821a3734
	if !ctx.cr[6].eq {
	pc = 0x821A3734; continue 'dispatch;
	}
	// 821A3714: FF1BF800  fcmpu cr6, f27, f31
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[31].f64);
	// 821A3718: 419A001C  beq cr6, 0x821a3734
	if ctx.cr[6].eq {
	pc = 0x821A3734; continue 'dispatch;
	}
	// 821A371C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A3720: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3724: 4BFFAB1D  bl 0x8219e240
	ctx.lr = 0x821A3728;
	sub_8219E240(ctx, base);
	// 821A3728: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A372C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A3730: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
            }
            0x821A3734 => {
    //   block [0x821A3734..0x821A375C)
	// 821A3734: FF1BE000  fcmpu cr6, f27, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 821A3738: 409A0024  bne cr6, 0x821a375c
	if !ctx.cr[6].eq {
	pc = 0x821A375C; continue 'dispatch;
	}
	// 821A373C: FF1BF800  fcmpu cr6, f27, f31
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[31].f64);
	// 821A3740: 419A001C  beq cr6, 0x821a375c
	if ctx.cr[6].eq {
	pc = 0x821A375C; continue 'dispatch;
	}
	// 821A3744: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A3748: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A374C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A3750: 4BFFACF1  bl 0x8219e440
	ctx.lr = 0x821A3754;
	sub_8219E440(ctx, base);
	// 821A3754: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3758: 938B0018  stw r28, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	pc = 0x821A375C; continue 'dispatch;
            }
            0x821A375C => {
    //   block [0x821A375C..0x821A376C)
	// 821A375C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A3760: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821A3764: 483928CD  bl 0x82536030
	ctx.lr = 0x821A3768;
	sub_82535FFC(ctx, base);
	// 821A3768: 483919A0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3770 size=420
    let mut pc: u32 = 0x821A3770;
    'dispatch: loop {
        match pc {
            0x821A3770 => {
    //   block [0x821A3770..0x821A3800)
	// 821A3770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A377C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A3780: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 821A3784: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 821A3788: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821A378C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3794: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A3798: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821A379C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A37A0: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A37A4: 396BC9E0  addi r11, r11, -0x3620
	ctx.r[11].s64 = ctx.r[11].s64 + -13856;
	// 821A37A8: 7D2A48AE  lbzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A37AC: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821A37B0: 7D69582A  ldx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	// 821A37B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A37B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A37BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A37C0: 419A0130  beq cr6, 0x821a38f0
	if ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A37C4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A37C8: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A37CC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A37D0: 409A0120  bne cr6, 0x821a38f0
	if !ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A37D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A37D8: 409A0118  bne cr6, 0x821a38f0
	if !ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A37DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A37E0: C3FF0094  lfs f31, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A37E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A37E8: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A37EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A37F0: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A37F4: C3AB2074  lfs f29, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A37F8: 419A0008  beq cr6, 0x821a3800
	if ctx.cr[6].eq {
	pc = 0x821A3800; continue 'dispatch;
	}
	// 821A37FC: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	pc = 0x821A3800; continue 'dispatch;
            }
            0x821A3800 => {
    //   block [0x821A3800..0x821A382C)
	// 821A3800: 3C6A0002  addis r3, r10, 2
	ctx.r[3].s64 = ctx.r[10].s64 + 131072;
	// 821A3804: 3863CF2C  addi r3, r3, -0x30d4
	ctx.r[3].s64 = ctx.r[3].s64 + -12500;
	// 821A3808: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A380C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A3810: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A3814: 4E800421  bctrl
	ctx.lr = 0x821A3818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A3818: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A381C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A3820: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 821A3824: 419A0008  beq cr6, 0x821a382c
	if ctx.cr[6].eq {
	pc = 0x821A382C; continue 'dispatch;
	}
	// 821A3828: EC3F0772  fmuls f1, f31, f29
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
            }
            0x821A382C => {
    //   block [0x821A382C..0x821A3864)
	// 821A382C: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 821A3830: 3863D044  addi r3, r3, -0x2fbc
	ctx.r[3].s64 = ctx.r[3].s64 + -12220;
	// 821A3834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3838: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821A383C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A3840: 4E800421  bctrl
	ctx.lr = 0x821A3844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A3844: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821A3848: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A384C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3850: 419A0014  beq cr6, 0x821a3864
	if ctx.cr[6].eq {
	pc = 0x821A3864; continue 'dispatch;
	}
	// 821A3854: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3858: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A385C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A3860: 419A000C  beq cr6, 0x821a386c
	if ctx.cr[6].eq {
	pc = 0x821A386C; continue 'dispatch;
	}
            }
            0x821A3864 => {
    //   block [0x821A3864..0x821A386C)
	// 821A3864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A3868: 48000008  b 0x821a3870
	pc = 0x821A3870; continue 'dispatch;
            }
            0x821A386C => {
    //   block [0x821A386C..0x821A3870)
	// 821A386C: 386A0090  addi r3, r10, 0x90
	ctx.r[3].s64 = ctx.r[10].s64 + 144;
	pc = 0x821A3870; continue 'dispatch;
            }
            0x821A3870 => {
    //   block [0x821A3870..0x821A388C)
	// 821A3870: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3878: 419A0014  beq cr6, 0x821a388c
	if ctx.cr[6].eq {
	pc = 0x821A388C; continue 'dispatch;
	}
	// 821A387C: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A3880: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3884: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A3888: 419A000C  beq cr6, 0x821a3894
	if ctx.cr[6].eq {
	pc = 0x821A3894; continue 'dispatch;
	}
	pc = 0x821A388C; continue 'dispatch;
            }
            0x821A388C => {
    //   block [0x821A388C..0x821A3894)
	// 821A388C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A3890: 48000028  b 0x821a38b8
	pc = 0x821A38B8; continue 'dispatch;
            }
            0x821A3894 => {
    //   block [0x821A3894..0x821A38B0)
	// 821A3894: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A3898: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A389C: 419A0014  beq cr6, 0x821a38b0
	if ctx.cr[6].eq {
	pc = 0x821A38B0; continue 'dispatch;
	}
	// 821A38A0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A38A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A38A8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821A38AC: 419A0008  beq cr6, 0x821a38b4
	if ctx.cr[6].eq {
	pc = 0x821A38B4; continue 'dispatch;
	}
	pc = 0x821A38B0; continue 'dispatch;
            }
            0x821A38B0 => {
    //   block [0x821A38B0..0x821A38B4)
	// 821A38B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821A38B4; continue 'dispatch;
            }
            0x821A38B4 => {
    //   block [0x821A38B4..0x821A38B8)
	// 821A38B4: 3BCA0090  addi r30, r10, 0x90
	ctx.r[30].s64 = ctx.r[10].s64 + 144;
	pc = 0x821A38B8; continue 'dispatch;
            }
            0x821A38B8 => {
    //   block [0x821A38B8..0x821A38D8)
	// 821A38B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A38BC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 821A38C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A38C4: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A38C8: 419A0010  beq cr6, 0x821a38d8
	if ctx.cr[6].eq {
	pc = 0x821A38D8; continue 'dispatch;
	}
	// 821A38CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A38D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A38D4: 4BFB189D  bl 0x82155170
	ctx.lr = 0x821A38D8;
	sub_82155170(ctx, base);
	pc = 0x821A38D8; continue 'dispatch;
            }
            0x821A38D8 => {
    //   block [0x821A38D8..0x821A38F0)
	// 821A38D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A38DC: 419A0014  beq cr6, 0x821a38f0
	if ctx.cr[6].eq {
	pc = 0x821A38F0; continue 'dispatch;
	}
	// 821A38E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A38E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A38E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A38EC: 4BFB1885  bl 0x82155170
	ctx.lr = 0x821A38F0;
	sub_82155170(ctx, base);
	pc = 0x821A38F0; continue 'dispatch;
            }
            0x821A38F0 => {
    //   block [0x821A38F0..0x821A3914)
	// 821A38F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A38F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A38F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A38FC: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821A3900: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A3904: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821A3908: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A390C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A3910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3918 size=108
    let mut pc: u32 = 0x821A3918;
    'dispatch: loop {
        match pc {
            0x821A3918 => {
    //   block [0x821A3918..0x821A396C)
	// 821A3918: 548B057E  clrlwi r11, r4, 0x15
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000007FFu64;
	// 821A391C: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821A3920: 548A0428  rlwinm r10, r4, 0, 0x10, 0x14
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821A3924: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 821A3928: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 821A392C: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 821A3930: B1030000  sth r8, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 821A3934: 41980050  blt cr6, 0x821a3984
	if ctx.cr[6].lt {
		sub_821A3984(ctx, base);
		return;
	}
	// 821A3938: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A393C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A3940: B1430002  sth r10, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 821A3944: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3948: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 821A394C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3950: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A3954: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821A3958: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821A395C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821A3960: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3964: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A3968: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821A396C; continue 'dispatch;
            }
            0x821A396C => {
    //   block [0x821A396C..0x821A3984)
	// 821A396C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3970: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821A3974: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A3978: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821A397C: 4200FFF0  bdnz 0x821a396c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A396C; continue 'dispatch;
	}
	// 821A3980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3984(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3984 size=100
    let mut pc: u32 = 0x821A3984;
    'dispatch: loop {
        match pc {
            0x821A3984 => {
    //   block [0x821A3984..0x821A39E8)
	// 821A3984: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A3988: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A398C: B1430002  sth r10, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 821A3990: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3994: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A3998: B1050002  sth r8, 2(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 821A399C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A39A0: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821A39A4: 7D682E70  srawi r8, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A39A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A39AC: 7D080194  addze r8, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[8].s64 = tmp.s64;
	// 821A39B0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A39B4: B0E50000  sth r7, 0(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 821A39B8: 55082834  slwi r8, r8, 5
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A39BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A39C0: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 821A39C4: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A39C8: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A39CC: 9145000C  stw r10, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A39D0: 91450010  stw r10, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821A39D4: 7D49282E  lwzx r10, r9, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821A39D8: 7CEB5830  slw r11, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 821A39DC: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 821A39E0: 7D69292E  stwx r11, r9, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), ctx.r[11].u32) };
	// 821A39E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A39E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A39E8 size=188
    let mut pc: u32 = 0x821A39E8;
    'dispatch: loop {
        match pc {
            0x821A39E8 => {
    //   block [0x821A39E8..0x821A3A28)
	// 821A39E8: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A39EC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A39F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A39F4: 419800B0  blt cr6, 0x821a3aa4
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x821A3AA4);
		return;
	}
	// 821A39F8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A39FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A3A00: 409A0028  bne cr6, 0x821a3a28
	if !ctx.cr[6].eq {
	pc = 0x821A3A28; continue 'dispatch;
	}
	// 821A3A04: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3A08: A1030000  lhz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3A0C: 392A47D0  addi r9, r10, 0x47d0
	ctx.r[9].s64 = ctx.r[10].s64 + 18384;
	// 821A3A10: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 821A3A14: 394AFFA8  addi r10, r10, -0x58
	ctx.r[10].s64 = ctx.r[10].s64 + -88;
	// 821A3A18: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A3A1C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821A3A20: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3A24: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x821A3A28; continue 'dispatch;
            }
            0x821A3A28 => {
    //   block [0x821A3A28..0x821A3A34)
	// 821A3A28: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 821A3A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A3A30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x821A3A34; continue 'dispatch;
            }
            0x821A3A34 => {
    //   block [0x821A3A34..0x821A3A6C)
	// 821A3A34: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A3A38: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821A3A3C: 7D652E70  srawi r5, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 821A3A40: 55442834  slwi r4, r10, 5
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A3A44: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821A3A48: 7CA45850  subf r5, r4, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 821A3A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A3A50: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3A54: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3A58: 7CE52830  slw r5, r7, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[7].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 821A3A5C: 7CAA5038  and r10, r5, r10
	ctx.r[10].u64 = ctx.r[5].u64 & ctx.r[10].u64;
	// 821A3A60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A3A64: 419A0008  beq cr6, 0x821a3a6c
	if ctx.cr[6].eq {
	pc = 0x821A3A6C; continue 'dispatch;
	}
	// 821A3A68: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x821A3A6C; continue 'dispatch;
            }
            0x821A3A6C => {
    //   block [0x821A3A6C..0x821A3A7C)
	// 821A3A6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A3A70: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 821A3A74: 41980008  blt cr6, 0x821a3a7c
	if ctx.cr[6].lt {
	pc = 0x821A3A7C; continue 'dispatch;
	}
	// 821A3A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A3A7C; continue 'dispatch;
            }
            0x821A3A7C => {
    //   block [0x821A3A7C..0x821A3A90)
	// 821A3A7C: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821A3A80: 409A0010  bne cr6, 0x821a3a90
	if !ctx.cr[6].eq {
	pc = 0x821A3A90; continue 'dispatch;
	}
	// 821A3A84: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821A3A88: 2F060061  cmpwi cr6, r6, 0x61
	ctx.cr[6].compare_i32(ctx.r[6].s32, 97, &mut ctx.xer);
	// 821A3A8C: 4198FFA8  blt cr6, 0x821a3a34
	if ctx.cr[6].lt {
	pc = 0x821A3A34; continue 'dispatch;
	}
	pc = 0x821A3A90; continue 'dispatch;
            }
            0x821A3A90 => {
    //   block [0x821A3A90..0x821A3AA4)
	// 821A3A90: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821A3A94: B1630002  sth r11, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 821A3A98: 409A0018  bne cr6, 0x821a3ab0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821A3AB0);
		return;
	}
	// 821A3A9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A3AA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3AB8 size=72
    let mut pc: u32 = 0x821A3AB8;
    'dispatch: loop {
        match pc {
            0x821A3AB8 => {
    //   block [0x821A3AB8..0x821A3AF4)
	// 821A3AB8: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A3ABC: 2B0B8000  cmplwi cr6, r11, 0x8000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32768 as u32, &mut ctx.xer);
	// 821A3AC0: 40980040  bge cr6, 0x821a3b00
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x821A3B00);
		return;
	}
	// 821A3AC4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A3ACC: 409A0028  bne cr6, 0x821a3af4
	if !ctx.cr[6].eq {
	pc = 0x821A3AF4; continue 'dispatch;
	}
	// 821A3AD0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3AD4: A1230000  lhz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3AD8: 394B47D0  addi r10, r11, 0x47d0
	ctx.r[10].s64 = ctx.r[11].s64 + 18384;
	// 821A3ADC: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 821A3AE0: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 821A3AE4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A3AE8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A3AEC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3AF0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x821A3AF4; continue 'dispatch;
            }
            0x821A3AF4 => {
    //   block [0x821A3AF4..0x821A3B00)
	// 821A3AF4: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3AF8: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3B08 size=216
    let mut pc: u32 = 0x821A3B08;
    'dispatch: loop {
        match pc {
            0x821A3B08 => {
    //   block [0x821A3B08..0x821A3B38)
	// 821A3B08: 2F040058  cmpwi cr6, r4, 0x58
	ctx.cr[6].compare_i32(ctx.r[4].s32, 88, &mut ctx.xer);
	// 821A3B0C: 4198002C  blt cr6, 0x821a3b38
	if ctx.cr[6].lt {
	pc = 0x821A3B38; continue 'dispatch;
	}
	// 821A3B10: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3B14: 3964FFA8  addi r11, r4, -0x58
	ctx.r[11].s64 = ctx.r[4].s64 + -88;
	// 821A3B18: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821A3B1C: 392A0002  addi r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 2;
	// 821A3B20: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3B24: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A3B28: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3B2C: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3B30: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3B34: 48000008  b 0x821a3b3c
	pc = 0x821A3B3C; continue 'dispatch;
            }
            0x821A3B38 => {
    //   block [0x821A3B38..0x821A3B3C)
	// 821A3B38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	pc = 0x821A3B3C; continue 'dispatch;
            }
            0x821A3B3C => {
    //   block [0x821A3B3C..0x821A3BCC)
	// 821A3B3C: 2F030017  cmpwi cr6, r3, 0x17
	ctx.cr[6].compare_i32(ctx.r[3].s32, 23, &mut ctx.xer);
	// 821A3B40: 419800A0  blt cr6, 0x821a3be0
	if ctx.cr[6].lt {
		sub_821A3BE0(ctx, base);
		return;
	}
	// 821A3B44: 2F03001F  cmpwi cr6, r3, 0x1f
	ctx.cr[6].compare_i32(ctx.r[3].s32, 31, &mut ctx.xer);
	// 821A3B48: 41990098  bgt cr6, 0x821a3be0
	if ctx.cr[6].gt {
		sub_821A3BE0(ctx, base);
		return;
	}
	// 821A3B4C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A3B50: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3B54: 6169BEBC  ori r9, r11, 0xbebc
	ctx.r[9].u64 = ctx.r[11].u64 | 48828;
	// 821A3B58: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3B5C: 394B0198  addi r10, r11, 0x198
	ctx.r[10].s64 = ctx.r[11].s64 + 408;
	// 821A3B60: 3963FFE9  addi r11, r3, -0x17
	ctx.r[11].s64 = ctx.r[3].s64 + -23;
	// 821A3B64: 7CA54A2E  lhzx r5, r5, r9
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3B68: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A3B6C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3B70: 392B1308  addi r9, r11, 0x1308
	ctx.r[9].s64 = ctx.r[11].s64 + 4872;
	// 821A3B74: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3B78: 390B1040  addi r8, r11, 0x1040
	ctx.r[8].s64 = ctx.r[11].s64 + 4160;
	// 821A3B7C: 54AB103E  rotlwi r11, r5, 2
	ctx.r[11].u64 = ((ctx.r[5].u32).rotate_left(2)) as u64;
	// 821A3B80: 3CA08286  lis r5, -0x7d7a
	ctx.r[5].s64 = -2105147392;
	// 821A3B84: 38A50540  addi r5, r5, 0x540
	ctx.r[5].s64 = ctx.r[5].s64 + 1344;
	// 821A3B88: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A3B8C: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3B90: 7D6A2214  add r11, r10, r4
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821A3B94: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3B98: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A3B9C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821A3BA0: 7D630734  extsh r3, r11
	ctx.r[3].s64 = ctx.r[11].s16 as i64;
	// 821A3BA4: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3BA8: 7D6B4A2E  lhzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3BAC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A3BB0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3BB4: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821A3BB8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A3BBC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3BC0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 821A3BC4: 419A0008  beq cr6, 0x821a3bcc
	if ctx.cr[6].eq {
	pc = 0x821A3BCC; continue 'dispatch;
	}
	// 821A3BC8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821A3BCC; continue 'dispatch;
            }
            0x821A3BCC => {
    //   block [0x821A3BCC..0x821A3BE0)
	// 821A3BCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A3BD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3BD4: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3BD8: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3BE0 size=108
    let mut pc: u32 = 0x821A3BE0;
    'dispatch: loop {
        match pc {
            0x821A3BE0 => {
    //   block [0x821A3BE0..0x821A3BFC)
	// 821A3BE0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A3BE4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A3BE8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821A3BEC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3BF0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A3BF4: 419A0008  beq cr6, 0x821a3bfc
	if ctx.cr[6].eq {
	pc = 0x821A3BFC; continue 'dispatch;
	}
	// 821A3BF8: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821A3BFC; continue 'dispatch;
            }
            0x821A3BFC => {
    //   block [0x821A3BFC..0x821A3C44)
	// 821A3BFC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A3C00: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3C04: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821A3C08: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3C0C: 6149BEB8  ori r9, r10, 0xbeb8
	ctx.r[9].u64 = ctx.r[10].u64 | 48824;
	// 821A3C10: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A3C14: 394A54C8  addi r10, r10, 0x54c8
	ctx.r[10].s64 = ctx.r[10].s64 + 21704;
	// 821A3C18: 7D654A2E  lhzx r11, r5, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A3C1C: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821A3C20: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 821A3C24: 7DA9542E  lfsx f13, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C28: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3C2C: 409A0018  bne cr6, 0x821a3c44
	if !ctx.cr[6].eq {
	pc = 0x821A3C44; continue 'dispatch;
	}
	// 821A3C30: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 821A3C34: 409A0010  bne cr6, 0x821a3c44
	if !ctx.cr[6].eq {
	pc = 0x821A3C44; continue 'dispatch;
	}
	// 821A3C38: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A3C3C: C1ABCFEC  lfs f13, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C40: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x821A3C44; continue 'dispatch;
            }
            0x821A3C44 => {
    //   block [0x821A3C44..0x821A3C4C)
	// 821A3C44: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3C50 size=124
    let mut pc: u32 = 0x821A3C50;
    'dispatch: loop {
        match pc {
            0x821A3C50 => {
    //   block [0x821A3C50..0x821A3C84)
	// 821A3C50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3C54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3C58: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3C5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A3C60: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 821A3C64: 419A0020  beq cr6, 0x821a3c84
	if ctx.cr[6].eq {
	pc = 0x821A3C84; continue 'dispatch;
	}
	// 821A3C68: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C6C: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3C70: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3C74: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3C78: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3C7C: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3C80: 48000010  b 0x821a3c90
	pc = 0x821A3C90; continue 'dispatch;
            }
            0x821A3C84 => {
    //   block [0x821A3C84..0x821A3C90)
	// 821A3C84: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3C88: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3C8C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821A3C90; continue 'dispatch;
            }
            0x821A3C90 => {
    //   block [0x821A3C90..0x821A3CCC)
	// 821A3C90: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3C94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3C98: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A3C9C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A3CA0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A3CA4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A3CA8: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A3CAC: 419A0020  beq cr6, 0x821a3ccc
	if ctx.cr[6].eq {
		sub_821A3CCC(ctx, base);
		return;
	}
	// 821A3CB0: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3CB4: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3CB8: 394A3CE8  addi r10, r10, 0x3ce8
	ctx.r[10].s64 = ctx.r[10].s64 + 15592;
	// 821A3CBC: 396B3CE8  addi r11, r11, 0x3ce8
	ctx.r[11].s64 = ctx.r[11].s64 + 15592;
	// 821A3CC0: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3CC4: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3CCC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3CCC size=28
    let mut pc: u32 = 0x821A3CCC;
    'dispatch: loop {
        match pc {
            0x821A3CCC => {
    //   block [0x821A3CCC..0x821A3CE8)
	// 821A3CCC: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3CD0: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3CD4: 394A3D08  addi r10, r10, 0x3d08
	ctx.r[10].s64 = ctx.r[10].s64 + 15624;
	// 821A3CD8: 396B3D40  addi r11, r11, 0x3d40
	ctx.r[11].s64 = ctx.r[11].s64 + 15680;
	// 821A3CDC: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3CE0: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3CE8 size=28
    let mut pc: u32 = 0x821A3CE8;
    'dispatch: loop {
        match pc {
            0x821A3CE8 => {
    //   block [0x821A3CE8..0x821A3D04)
	// 821A3CE8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3CEC: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3CF0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3CF4: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3CF8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3CFC: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3D08 size=52
    let mut pc: u32 = 0x821A3D08;
    'dispatch: loop {
        match pc {
            0x821A3D08 => {
    //   block [0x821A3D08..0x821A3D3C)
	// 821A3D08: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D0C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3D10: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D14: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3D18: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D1C: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3D20: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D24: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3D28: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D2C: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3D30: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D34: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A3D40 size=156
    let mut pc: u32 = 0x821A3D40;
    'dispatch: loop {
        match pc {
            0x821A3D40 => {
    //   block [0x821A3D40..0x821A3DDC)
	// 821A3D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A3D48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A3D4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3D50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A3D54: 481C33E5  bl 0x82367138
	ctx.lr = 0x821A3D58;
	sub_82367138(ctx, base);
	// 821A3D58: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A3D5C: C19F0014  lfs f12, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A3D60: C17F0018  lfs f11, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A3D64: C15F0010  lfs f10, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A3D68: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D6C: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A3D70: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A3D74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A3D78: C13F0004  lfs f9, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A3D7C: C11F0008  lfs f8, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A3D80: C0FF0000  lfs f7, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A3D84: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A3D88: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A3D8C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A3D90: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3D94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A3D98: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3D9C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A3DA0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A3DA4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3DA8: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3DAC: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A3DB0: ED89637A  fmadds f12, f9, f13, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A3DB4: D1840004  stfs f12, 4(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3DB8: ED685B7A  fmadds f11, f8, f13, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A3DBC: D1640008  stfs f11, 8(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3DC0: EC07037A  fmadds f0, f7, f13, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821A3DC4: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3DC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A3DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A3DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A3DD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A3DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3DE0 size=56
    let mut pc: u32 = 0x821A3DE0;
    'dispatch: loop {
        match pc {
            0x821A3DE0 => {
    //   block [0x821A3DE0..0x821A3E18)
	// 821A3DE0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A3DE4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821A3DE8: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821A3DEC: 90C3000C  stw r6, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 821A3DF0: 409A0028  bne cr6, 0x821a3e18
	if !ctx.cr[6].eq {
		sub_821A3E18(ctx, base);
		return;
	}
	// 821A3DF4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3DF8: 409A0044  bne cr6, 0x821a3e3c
	if !ctx.cr[6].eq {
		sub_821A3E3C(ctx, base);
		return;
	}
	// 821A3DFC: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E00: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E04: 394A3E78  addi r10, r10, 0x3e78
	ctx.r[10].s64 = ctx.r[10].s64 + 15992;
	// 821A3E08: 396B3E78  addi r11, r11, 0x3e78
	ctx.r[11].s64 = ctx.r[11].s64 + 15992;
	// 821A3E0C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E10: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3E18 size=36
    let mut pc: u32 = 0x821A3E18;
    'dispatch: loop {
        match pc {
            0x821A3E18 => {
    //   block [0x821A3E18..0x821A3E3C)
	// 821A3E18: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3E1C: 409A003C  bne cr6, 0x821a3e58
	if !ctx.cr[6].eq {
		sub_821A3E58(ctx, base);
		return;
	}
	// 821A3E20: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E24: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E28: 394A3EC8  addi r10, r10, 0x3ec8
	ctx.r[10].s64 = ctx.r[10].s64 + 16072;
	// 821A3E2C: 396B3F60  addi r11, r11, 0x3f60
	ctx.r[11].s64 = ctx.r[11].s64 + 16224;
	// 821A3E30: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E34: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3E3C size=28
    let mut pc: u32 = 0x821A3E3C;
    'dispatch: loop {
        match pc {
            0x821A3E3C => {
    //   block [0x821A3E3C..0x821A3E58)
	// 821A3E3C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E40: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E44: 394A4068  addi r10, r10, 0x4068
	ctx.r[10].s64 = ctx.r[10].s64 + 16488;
	// 821A3E48: 396B4100  addi r11, r11, 0x4100
	ctx.r[11].s64 = ctx.r[11].s64 + 16640;
	// 821A3E4C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E50: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A3E58 size=28
    let mut pc: u32 = 0x821A3E58;
    'dispatch: loop {
        match pc {
            0x821A3E58 => {
    //   block [0x821A3E58..0x821A3E74)
	// 821A3E58: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A3E5C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A3E60: 394A4208  addi r10, r10, 0x4208
	ctx.r[10].s64 = ctx.r[10].s64 + 16904;
	// 821A3E64: 396B43F0  addi r11, r11, 0x43f0
	ctx.r[11].s64 = ctx.r[11].s64 + 17392;
	// 821A3E68: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A3E6C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A3E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3E78 size=80
    let mut pc: u32 = 0x821A3E78;
    'dispatch: loop {
        match pc {
            0x821A3E78 => {
    //   block [0x821A3E78..0x821A3EA4)
	// 821A3E78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3E7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3E80: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3E84: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A3E88: 419A001C  beq cr6, 0x821a3ea4
	if ctx.cr[6].eq {
	pc = 0x821A3EA4; continue 'dispatch;
	}
	// 821A3E8C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3E90: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3E94: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3E98: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3E9C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EA0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A3EA4; continue 'dispatch;
            }
            0x821A3EA4 => {
    //   block [0x821A3EA4..0x821A3EC8)
	// 821A3EA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3EA8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3EAC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EB0: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3EB4: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EB8: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3EBC: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3EC0: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A3EC8 size=152
    let mut pc: u32 = 0x821A3EC8;
    'dispatch: loop {
        match pc {
            0x821A3EC8 => {
    //   block [0x821A3EC8..0x821A3F1C)
	// 821A3EC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3ECC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3ED0: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3ED4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A3ED8: 419A0044  beq cr6, 0x821a3f1c
	if ctx.cr[6].eq {
	pc = 0x821A3F1C; continue 'dispatch;
	}
	// 821A3EDC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3EE0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	pc = 0x821A3F1C; continue 'dispatch;
            }
            0x821A3F1C => {
    //   block [0x821A3F1C..0x821A3F60)
	// 821A3F1C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A3F20: 419A001C  beq cr6, 0x821a3f3c
	if ctx.cr[6].eq {
	pc = 0x821A3F3C; continue 'dispatch;
	}
	// 821A3F24: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F28: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3F2C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F30: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3F34: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F38: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3F3C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A3F40: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A3F44: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F48: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A3F4C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F50: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A3F54: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A3F58: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A3F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A3F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A3F60 size=260
    let mut pc: u32 = 0x821A3F60;
    'dispatch: loop {
        match pc {
            0x821A3F60 => {
    //   block [0x821A3F60..0x821A4064)
	// 821A3F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A3F64: 48391159  bl 0x825350bc
	ctx.lr = 0x821A3F68;
	sub_82535080(ctx, base);
	// 821A3F68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A3F6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A3F70: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821A3F74: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A3F78: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A3F7C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A3F80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A3F84: 7FEB3A14  add r31, r11, r7
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A3F88: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4068 size=152
    let mut pc: u32 = 0x821A4068;
    'dispatch: loop {
        match pc {
            0x821A4068 => {
    //   block [0x821A4068..0x821A4094)
	// 821A4068: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A406C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4070: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4074: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4078: 419A001C  beq cr6, 0x821a4094
	if ctx.cr[6].eq {
	pc = 0x821A4094; continue 'dispatch;
	}
	// 821A407C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4080: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4084: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4088: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A408C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4090: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A4094; continue 'dispatch;
            }
            0x821A4094 => {
    //   block [0x821A4094..0x821A40DC)
	// 821A4094: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4098: 419A0044  beq cr6, 0x821a40dc
	if ctx.cr[6].eq {
	pc = 0x821A40DC; continue 'dispatch;
	}
	// 821A409C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A40A0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	pc = 0x821A40DC; continue 'dispatch;
            }
            0x821A40DC => {
    //   block [0x821A40DC..0x821A4100)
	// 821A40DC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A40E0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A40E4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A40E8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A40EC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A40F0: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A40F4: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A40F8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A40FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4100 size=260
    let mut pc: u32 = 0x821A4100;
    'dispatch: loop {
        match pc {
            0x821A4100 => {
    //   block [0x821A4100..0x821A4204)
	// 821A4100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4104: 48390FB9  bl 0x825350bc
	ctx.lr = 0x821A4108;
	sub_82535080(ctx, base);
	// 821A4108: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A410C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4110: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821A4114: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4118: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A411C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4120: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4124: 7FEB3A14  add r31, r11, r7
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4128: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4208 size=180
    let mut pc: u32 = 0x821A4208;
    'dispatch: loop {
        match pc {
            0x821A4208 => {
    //   block [0x821A4208..0x821A425C)
	// 821A4208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A420C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4210: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 821A4214: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4218: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821A421C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4220: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821A4224: 419A0038  beq cr6, 0x821a425c
	if ctx.cr[6].eq {
	pc = 0x821A425C; continue 'dispatch;
	}
	// 821A4228: 80E30008  lwz r7, 8(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821A425C; continue 'dispatch;
            }
            0x821A425C => {
    //   block [0x821A425C..0x821A42BC)
	// 821A425C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4260: 419A0038  beq cr6, 0x821a4298
	if ctx.cr[6].eq {
	pc = 0x821A4298; continue 'dispatch;
	}
	// 821A4264: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A42C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A42C0 size=300
    let mut pc: u32 = 0x821A42C0;
    'dispatch: loop {
        match pc {
            0x821A42C0 => {
    //   block [0x821A42C0..0x821A42D8)
	// 821A42C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A42C4: 3941FFC0  addi r10, r1, -0x40
	ctx.r[10].s64 = ctx.r[1].s64 + -64;
	// 821A42C8: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821A42CC: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A42D0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A42D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821A42D8; continue 'dispatch;
            }
            0x821A42D8 => {
    //   block [0x821A42D8..0x821A43EC)
	// 821A42D8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A42DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A42E0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A42E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A42E8: 4200FFF0  bdnz 0x821a42d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A42D8; continue 'dispatch;
	}
	// 821A42EC: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A42F0: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 821A42F4: C181FFC0  lfs f12, -0x40(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A42F8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A42FC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4300: D181FFC0  stfs f12, -0x40(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 821A4304: C181FFC4  lfs f12, -0x3c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4308: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A430C: D181FFC4  stfs f12, -0x3c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 821A4310: C1A1FFE0  lfs f13, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4314: C181FFC8  lfs f12, -0x38(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4318: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A431C: C141FFE4  lfs f10, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4320: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4324: D1A1FFE0  stfs f13, -0x20(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 821A4328: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A432C: D181FFC8  stfs f12, -0x38(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), tmp.u32 ) };
	// 821A4330: D141FFE4  stfs f10, -0x1c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 821A4334: C1A1FFD0  lfs f13, -0x30(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4338: C181FFD4  lfs f12, -0x2c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A433C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4340: C161FFD8  lfs f11, -0x28(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4344: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4348: C141FFE8  lfs f10, -0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A434C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4350: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4354: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 821A4358: D181FFD4  stfs f12, -0x2c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 821A435C: D161FFD8  stfs f11, -0x28(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 821A4360: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A43F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A43F0 size=300
    let mut pc: u32 = 0x821A43F0;
    'dispatch: loop {
        match pc {
            0x821A43F0 => {
    //   block [0x821A43F0..0x821A451C)
	// 821A43F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A43F4: 48390CC9  bl 0x825350bc
	ctx.lr = 0x821A43F8;
	sub_82535080(ctx, base);
	// 821A43F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A43FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4400: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821A4404: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4408: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821A440C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4410: 80C3000C  lwz r6, 0xc(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4414: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 821A4418: 7FEB3A14  add r31, r11, r7
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A441C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4520 size=452
    let mut pc: u32 = 0x821A4520;
    'dispatch: loop {
        match pc {
            0x821A4520 => {
    //   block [0x821A4520..0x821A454C)
	// 821A4520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A452C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4534: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821A4538: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821A453C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4540: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821A4544: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4548: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821A454C; continue 'dispatch;
            }
            0x821A454C => {
    //   block [0x821A454C..0x821A46E4)
	// 821A454C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A4550: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A4554: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A4558: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821A455C: 4200FFF0  bdnz 0x821a454c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821A454C; continue 'dispatch;
	}
	// 821A4560: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 821A4564: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4568: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A456C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4570: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4574: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A46E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A46E8 size=60
    let mut pc: u32 = 0x821A46E8;
    'dispatch: loop {
        match pc {
            0x821A46E8 => {
    //   block [0x821A46E8..0x821A4724)
	// 821A46E8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A46EC: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821A46F0: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821A46F4: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821A46F8: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 821A46FC: 409A0028  bne cr6, 0x821a4724
	if !ctx.cr[6].eq {
		sub_821A4724(ctx, base);
		return;
	}
	// 821A4700: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A4704: 409A0044  bne cr6, 0x821a4748
	if !ctx.cr[6].eq {
		sub_821A4748(ctx, base);
		return;
	}
	// 821A4708: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A470C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A4710: 394A4780  addi r10, r10, 0x4780
	ctx.r[10].s64 = ctx.r[10].s64 + 18304;
	// 821A4714: 396B4780  addi r11, r11, 0x4780
	ctx.r[11].s64 = ctx.r[11].s64 + 18304;
	// 821A4718: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A471C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A4720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4724(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4724 size=36
    let mut pc: u32 = 0x821A4724;
    'dispatch: loop {
        match pc {
            0x821A4724 => {
    //   block [0x821A4724..0x821A4748)
	// 821A4724: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821A4728: 409A003C  bne cr6, 0x821a4764
	if !ctx.cr[6].eq {
		sub_821A4764(ctx, base);
		return;
	}
	// 821A472C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A4730: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A4734: 394A4830  addi r10, r10, 0x4830
	ctx.r[10].s64 = ctx.r[10].s64 + 18480;
	// 821A4738: 396B4908  addi r11, r11, 0x4908
	ctx.r[11].s64 = ctx.r[11].s64 + 18696;
	// 821A473C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A4740: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A4744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4748 size=28
    let mut pc: u32 = 0x821A4748;
    'dispatch: loop {
        match pc {
            0x821A4748 => {
    //   block [0x821A4748..0x821A4764)
	// 821A4748: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A474C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A4750: 394A4A60  addi r10, r10, 0x4a60
	ctx.r[10].s64 = ctx.r[10].s64 + 19040;
	// 821A4754: 396B4B38  addi r11, r11, 0x4b38
	ctx.r[11].s64 = ctx.r[11].s64 + 19256;
	// 821A4758: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A475C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A4760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A4764 size=28
    let mut pc: u32 = 0x821A4764;
    'dispatch: loop {
        match pc {
            0x821A4764 => {
    //   block [0x821A4764..0x821A4780)
	// 821A4764: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A4768: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A476C: 394A4C88  addi r10, r10, 0x4c88
	ctx.r[10].s64 = ctx.r[10].s64 + 19592;
	// 821A4770: 396B4D80  addi r11, r11, 0x4d80
	ctx.r[11].s64 = ctx.r[11].s64 + 19840;
	// 821A4774: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821A4778: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821A477C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4780 size=176
    let mut pc: u32 = 0x821A4780;
    'dispatch: loop {
        match pc {
            0x821A4780 => {
    //   block [0x821A4780..0x821A47EC)
	// 821A4780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4784: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4788: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A478C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4790: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4794: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4798: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A479C: 419A0050  beq cr6, 0x821a47ec
	if ctx.cr[6].eq {
	pc = 0x821A47EC; continue 'dispatch;
	}
	// 821A47A0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A47A4: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A47A8: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A47AC: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A47B0: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A47B4: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A47B8: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A47BC: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A47C0: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A47C4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A47C8: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A47CC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A47D0: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A47D4: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A47D8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A47DC: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A47E0: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A47E4: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A47E8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A47EC; continue 'dispatch;
            }
            0x821A47EC => {
    //   block [0x821A47EC..0x821A480C)
	// 821A47EC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A47F0: 419A001C  beq cr6, 0x821a480c
	if ctx.cr[6].eq {
	pc = 0x821A480C; continue 'dispatch;
	}
	// 821A47F4: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A47F8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A47FC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4800: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4804: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4808: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A480C; continue 'dispatch;
            }
            0x821A480C => {
    //   block [0x821A480C..0x821A4830)
	// 821A480C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4810: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A4814: C00A0030  lfs f0, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4818: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A481C: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4820: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4824: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4828: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A482C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4830 size=216
    let mut pc: u32 = 0x821A4830;
    'dispatch: loop {
        match pc {
            0x821A4830 => {
    //   block [0x821A4830..0x821A489C)
	// 821A4830: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4834: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4838: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A483C: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4840: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4844: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4848: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A484C: 419A0050  beq cr6, 0x821a489c
	if ctx.cr[6].eq {
	pc = 0x821A489C; continue 'dispatch;
	}
	// 821A4850: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4854: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4858: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A485C: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4860: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4864: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4868: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A486C: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4870: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4874: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4878: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A487C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4880: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4884: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4888: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A488C: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4890: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4894: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4898: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A489C; continue 'dispatch;
            }
            0x821A489C => {
    //   block [0x821A489C..0x821A48E4)
	// 821A489C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A48A0: 419A0044  beq cr6, 0x821a48e4
	if ctx.cr[6].eq {
	pc = 0x821A48E4; continue 'dispatch;
	}
	// 821A48A4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A48A8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	pc = 0x821A48E4; continue 'dispatch;
            }
            0x821A48E4 => {
    //   block [0x821A48E4..0x821A4908)
	// 821A48E4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A48E8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A48EC: C00A0030  lfs f0, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A48F0: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A48F4: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A48F8: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A48FC: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4900: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A4904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4908 size=340
    let mut pc: u32 = 0x821A4908;
    'dispatch: loop {
        match pc {
            0x821A4908 => {
    //   block [0x821A4908..0x821A498C)
	// 821A4908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A490C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4914: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4918: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A491C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4920: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4924: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4928: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A492C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4930: 419A005C  beq cr6, 0x821a498c
	if ctx.cr[6].eq {
	pc = 0x821A498C; continue 'dispatch;
	}
	// 821A4934: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4938: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A493C: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4940: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4944: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821A4948: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A494C: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4950: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4954: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A4958: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A495C: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4960: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4964: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4968: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A496C: C0E1006C  lfs f7, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4970: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4974: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4978: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A497C: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4980: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4984: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4988: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A498C; continue 'dispatch;
            }
            0x821A498C => {
    //   block [0x821A498C..0x821A4A5C)
	// 821A498C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4990: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4A60 size=216
    let mut pc: u32 = 0x821A4A60;
    'dispatch: loop {
        match pc {
            0x821A4A60 => {
    //   block [0x821A4A60..0x821A4ACC)
	// 821A4A60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4A64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4A68: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4A6C: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4A70: 552B3032  slwi r11, r9, 6
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4A74: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4A78: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4A7C: 419A0050  beq cr6, 0x821a4acc
	if ctx.cr[6].eq {
	pc = 0x821A4ACC; continue 'dispatch;
	}
	// 821A4A80: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4A84: C1AA0010  lfs f13, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4A88: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4A8C: C16A0018  lfs f11, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4A90: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4A94: C12B0018  lfs f9, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4A98: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4A9C: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4AA0: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4AA4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4AA8: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4AAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4AB0: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4AB4: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4AB8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4ABC: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4AC0: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4AC4: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4AC8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A4ACC; continue 'dispatch;
            }
            0x821A4ACC => {
    //   block [0x821A4ACC..0x821A4AEC)
	// 821A4ACC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4AD0: 419A001C  beq cr6, 0x821a4aec
	if ctx.cr[6].eq {
	pc = 0x821A4AEC; continue 'dispatch;
	}
	// 821A4AD4: C00A0030  lfs f0, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4AD8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4ADC: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4AE0: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4AE4: C00A0038  lfs f0, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4AE8: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A4AEC; continue 'dispatch;
            }
            0x821A4AEC => {
    //   block [0x821A4AEC..0x821A4B38)
	// 821A4AEC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4AF0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A4AF4: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4AF8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4B38 size=336
    let mut pc: u32 = 0x821A4B38;
    'dispatch: loop {
        match pc {
            0x821A4B38 => {
    //   block [0x821A4B38..0x821A4BBC)
	// 821A4B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4B44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4B48: C101005C  lfs f8, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A4B4C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4B50: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4B54: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4B58: 552B3032  slwi r11, r9, 6
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4B5C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4B60: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4B64: 419A0058  beq cr6, 0x821a4bbc
	if ctx.cr[6].eq {
	pc = 0x821A4BBC; continue 'dispatch;
	}
	// 821A4B68: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4B6C: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4B70: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4B74: C16A0018  lfs f11, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4B78: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4B7C: C12B0018  lfs f9, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4B80: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4B84: ECED0032  fmuls f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4B88: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4B8C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4B90: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A4B94: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4B98: D1410054  stfs f10, 0x54(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A4B9C: D1210058  stfs f9, 0x58(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A4BA0: D106000C  stfs f8, 0xc(r6)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4BA4: EDAD383A  fmadds f13, f13, f0, f7
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 821A4BA8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4BAC: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4BB0: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4BB4: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4BB8: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A4BBC; continue 'dispatch;
            }
            0x821A4BBC => {
    //   block [0x821A4BBC..0x821A4C88)
	// 821A4BBC: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A4BC0: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A4C88 size=244
    let mut pc: u32 = 0x821A4C88;
    'dispatch: loop {
        match pc {
            0x821A4C88 => {
    //   block [0x821A4C88..0x821A4CF4)
	// 821A4C88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4C8C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4C90: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4C94: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4C98: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4C9C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4CA0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4CA4: 419A0050  beq cr6, 0x821a4cf4
	if ctx.cr[6].eq {
	pc = 0x821A4CF4; continue 'dispatch;
	}
	// 821A4CA8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4CAC: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4CB0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4CB4: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4CB8: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4CBC: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4CC0: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4CC4: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4CC8: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4CCC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4CD0: C0E1FFFC  lfs f7, -4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4CD4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4CD8: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4CDC: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4CE0: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4CE4: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4CE8: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4CEC: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4CF0: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A4CF4; continue 'dispatch;
            }
            0x821A4CF4 => {
    //   block [0x821A4CF4..0x821A4D3C)
	// 821A4CF4: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 821A4CF8: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 821A4CFC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821A4D00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A4D04: 419A0038  beq cr6, 0x821a4d3c
	if ctx.cr[6].eq {
	pc = 0x821A4D3C; continue 'dispatch;
	}
	// 821A4D08: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821A4D3C; continue 'dispatch;
            }
            0x821A4D3C => {
    //   block [0x821A4D3C..0x821A4D7C)
	// 821A4D3C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A4D40: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821A4D44: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A4D80 size=408
    let mut pc: u32 = 0x821A4D80;
    'dispatch: loop {
        match pc {
            0x821A4D80 => {
    //   block [0x821A4D80..0x821A4E10)
	// 821A4D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4D88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4D8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A4D90: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A4D94: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A4D98: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A4D9C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A4DA0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A4DA4: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A4DA8: 419A0068  beq cr6, 0x821a4e10
	if ctx.cr[6].eq {
	pc = 0x821A4E10; continue 'dispatch;
	}
	// 821A4DAC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A4DB0: C1AB0010  lfs f13, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4DB4: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A4DB8: C16B0018  lfs f11, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A4DBC: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821A4DC0: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A4DC4: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A4DC8: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4DCC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A4DD0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4DD4: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A4DD8: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A4DDC: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A4DE0: C14A0014  lfs f10, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A4DE4: C12A0018  lfs f9, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A4DE8: C0E1006C  lfs f7, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A4DEC: D1410054  stfs f10, 0x54(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A4DF0: D1210058  stfs f9, 0x58(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A4DF4: D0E6000C  stfs f7, 0xc(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A4DF8: EDAD403A  fmadds f13, f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A4DFC: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A4E00: EDAA603A  fmadds f13, f10, f0, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A4E04: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A4E08: EC09583A  fmadds f0, f9, f0, f11
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A4E0C: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821A4E10; continue 'dispatch;
            }
            0x821A4E10 => {
    //   block [0x821A4E10..0x821A4F18)
	// 821A4E10: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A4E14: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 821A4E18: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4F18 size=100
    let mut pc: u32 = 0x821A4F18;
    'dispatch: loop {
        match pc {
            0x821A4F18 => {
    //   block [0x821A4F18..0x821A4F68)
	// 821A4F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A4F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A4F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A4F2C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A4F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A4F34: 419A0034  beq cr6, 0x821a4f68
	if ctx.cr[6].eq {
	pc = 0x821A4F68; continue 'dispatch;
	}
	// 821A4F38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A4F3C: 4E800421  bctrl
	ctx.lr = 0x821A4F40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A4F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A4F44: 409A0024  bne cr6, 0x821a4f68
	if !ctx.cr[6].eq {
	pc = 0x821A4F68; continue 'dispatch;
	}
	// 821A4F48: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A4F4C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A4F50: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A4F54: 409A0014  bne cr6, 0x821a4f68
	if !ctx.cr[6].eq {
	pc = 0x821A4F68; continue 'dispatch;
	}
	// 821A4F58: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821A4F5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A4F60: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821A4F64: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
            }
            0x821A4F68 => {
    //   block [0x821A4F68..0x821A4F7C)
	// 821A4F68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A4F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A4F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A4F74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A4F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A4F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A4F80 size=340
    let mut pc: u32 = 0x821A4F80;
    'dispatch: loop {
        match pc {
            0x821A4F80 => {
    //   block [0x821A4F80..0x821A4FC8)
	// 821A4F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A4F84: 48390131  bl 0x825350b4
	ctx.lr = 0x821A4F88;
	sub_82535080(ctx, base);
	// 821A4F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A4F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A4F90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A4F94: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A4F98: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A4F9C: 38EB0E0C  addi r7, r11, 0xe0c
	ctx.r[7].s64 = ctx.r[11].s64 + 3596;
	// 821A4FA0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A4FA4: 38A00389  li r5, 0x389
	ctx.r[5].s64 = 905;
	// 821A4FA8: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A4FAC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 821A4FB0: 481C54E1  bl 0x8236a490
	ctx.lr = 0x821A4FB4;
	sub_8236A490(ctx, base);
	// 821A4FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A4FB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A4FBC: 419A000C  beq cr6, 0x821a4fc8
	if ctx.cr[6].eq {
	pc = 0x821A4FC8; continue 'dispatch;
	}
	// 821A4FC0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A4FC4: 48000008  b 0x821a4fcc
	pc = 0x821A4FCC; continue 'dispatch;
            }
            0x821A4FC8 => {
    //   block [0x821A4FC8..0x821A4FCC)
	// 821A4FC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A4FCC; continue 'dispatch;
            }
            0x821A4FCC => {
    //   block [0x821A4FCC..0x821A5088)
	// 821A4FCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A4FD0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A4FD4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A4FD8: 419A00B0  beq cr6, 0x821a5088
	if ctx.cr[6].eq {
	pc = 0x821A5088; continue 'dispatch;
	}
	// 821A4FDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A4FE0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A4FE4: 396B0E14  addi r11, r11, 0xe14
	ctx.r[11].s64 = ctx.r[11].s64 + 3604;
	// 821A4FE8: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A4FEC: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A4FF0: 390850D8  addi r8, r8, 0x50d8
	ctx.r[8].s64 = ctx.r[8].s64 + 20696;
	// 821A4FF4: 392951E8  addi r9, r9, 0x51e8
	ctx.r[9].s64 = ctx.r[9].s64 + 20968;
	// 821A4FF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A4FFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A5000: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 821A5004: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A5008: B3BF0084  sth r29, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u16 ) };
	// 821A500C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A5010: B3BF0086  sth r29, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[29].u16 ) };
	// 821A5014: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A5018: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A501C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A5020: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A5024: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A5028: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A502C: FBBF00E8  std r29, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u64 ) };
	// 821A5030: 1C9B0C60  mulli r4, r27, 0xc60
	ctx.r[4].s32 = ((ctx.r[27].s32 as i64 * 3168 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 821A5034: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A5038: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A503C: 9B9F001C  stb r28, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 821A5040: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A5044: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A5048: 4BFFCBE9  bl 0x821a1c30
	ctx.lr = 0x821A504C;
	sub_821A1C30(ctx, base);
	// 821A504C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5054: 409A0044  bne cr6, 0x821a5098
	if !ctx.cr[6].eq {
	pc = 0x821A5098; continue 'dispatch;
	}
	// 821A5058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A505C: 419A002C  beq cr6, 0x821a5088
	if ctx.cr[6].eq {
	pc = 0x821A5088; continue 'dispatch;
	}
	// 821A5060: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5064: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5068: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A506C: 409A001C  bne cr6, 0x821a5088
	if !ctx.cr[6].eq {
	pc = 0x821A5088; continue 'dispatch;
	}
	// 821A5070: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A5074: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A5078: 9B8B0025  stb r28, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 821A507C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A5080: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A5084: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A5088; continue 'dispatch;
            }
            0x821A5088 => {
    //   block [0x821A5088..0x821A5098)
	// 821A5088: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A508C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5090: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5094: 48390070  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821A5098 => {
    //   block [0x821A5098..0x821A50B0)
	// 821A5098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A509C: 419A0014  beq cr6, 0x821a50b0
	if ctx.cr[6].eq {
	pc = 0x821A50B0; continue 'dispatch;
	}
	// 821A50A0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A50A4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A50A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A50AC: 419A0008  beq cr6, 0x821a50b4
	if ctx.cr[6].eq {
	pc = 0x821A50B4; continue 'dispatch;
	}
	pc = 0x821A50B0; continue 'dispatch;
            }
            0x821A50B0 => {
    //   block [0x821A50B0..0x821A50B4)
	// 821A50B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A50B4; continue 'dispatch;
            }
            0x821A50B4 => {
    //   block [0x821A50B4..0x821A50D4)
	// 821A50B4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A50B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A50BC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 821A50C0: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 821A50C4: 937F00D0  stw r27, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 821A50C8: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A50CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A50D0: 48390034  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A50D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A50D8 size=272
    let mut pc: u32 = 0x821A50D8;
    'dispatch: loop {
        match pc {
            0x821A50D8 => {
    //   block [0x821A50D8..0x821A50F0)
	// 821A50D8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A50DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A50E0: 814BFAC0  lwz r10, -0x540(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A50E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A50E8: 419A0008  beq cr6, 0x821a50f0
	if ctx.cr[6].eq {
	pc = 0x821A50F0; continue 'dispatch;
	}
	// 821A50EC: 90EA0040  stw r7, 0x40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	pc = 0x821A50F0; continue 'dispatch;
            }
            0x821A50F0 => {
    //   block [0x821A50F0..0x821A5178)
	// 821A50F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A50F4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A50F8: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A50FC: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 821A5100: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A5104: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5108: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A510C: 992A001E  stb r9, 0x1e(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A5110: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A5114: 396B8E40  addi r11, r11, -0x71c0
	ctx.r[11].s64 = ctx.r[11].s64 + -29120;
	// 821A5118: B0EA0084  sth r7, 0x84(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(132 as u32), ctx.r[7].u16 ) };
	// 821A511C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821A5120: B0EA0086  sth r7, 0x86(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(134 as u32), ctx.r[7].u16 ) };
	// 821A5124: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 821A5128: 916A0080  stw r11, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A512C: D00A00B0  stfs f0, 0xb0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A5130: D00A00B4  stfs f0, 0xb4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A5134: 910A00A8  stw r8, 0xa8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A5138: 90AA00A4  stw r5, 0xa4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 821A513C: 912A0094  stw r9, 0x94(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A5140: 908A0098  stw r4, 0x98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 821A5144: 906A00A0  stw r3, 0xa0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821A5148: 816A00D4  lwz r11, 0xd4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A514C: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5150: D00A00B8  stfs f0, 0xb8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A5154: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A5158: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A515C: 916A0090  stw r11, 0x90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A5160: 812A00D0  lwz r9, 0xd0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A5164: 816A00CC  lwz r11, 0xcc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5168: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821A516C: 40990074  ble cr6, 0x821a51e0
	if !ctx.cr[6].gt {
	pc = 0x821A51E0; continue 'dispatch;
	}
	// 821A5170: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A5174: C169BA38  lfs f11, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x821A5178; continue 'dispatch;
            }
            0x821A5178 => {
    //   block [0x821A5178..0x821A518C)
	// 821A5178: 810A00D8  lwz r8, 0xd8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A517C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 821A5180: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5184: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A5188: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x821A518C; continue 'dispatch;
            }
            0x821A518C => {
    //   block [0x821A518C..0x821A51E0)
	// 821A518C: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821A5190: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A5194: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A5198: 5508DFFE  rlwinm r8, r8, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821A519C: 2F090020  cmpwi cr6, r9, 0x20
	ctx.cr[6].compare_i32(ctx.r[9].s32, 32, &mut ctx.xer);
	// 821A51A0: 910B002C  stw r8, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 821A51A4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A51A8: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A51AC: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A51B0: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A51B4: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A51B8: 90EB002C  stw r7, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[7].u32 ) };
	// 821A51BC: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A51C0: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A51C4: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A51C8: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A51CC: 4099FFC0  ble cr6, 0x821a518c
	if !ctx.cr[6].gt {
	pc = 0x821A518C; continue 'dispatch;
	}
	// 821A51D0: 812A00D0  lwz r9, 0xd0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A51D4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821A51D8: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A51DC: 4198FF9C  blt cr6, 0x821a5178
	if ctx.cr[6].lt {
	pc = 0x821A5178; continue 'dispatch;
	}
	pc = 0x821A51E0; continue 'dispatch;
            }
            0x821A51E0 => {
    //   block [0x821A51E0..0x821A51E8)
	// 821A51E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A51E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A51E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A51E8 size=68
    let mut pc: u32 = 0x821A51E8;
    'dispatch: loop {
        match pc {
            0x821A51E8 => {
    //   block [0x821A51E8..0x821A5218)
	// 821A51E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A51EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A51F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A51F4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A51F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A51FC: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A5200: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A5204: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A5208: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A520C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A5210: 419A0008  beq cr6, 0x821a5218
	if ctx.cr[6].eq {
	pc = 0x821A5218; continue 'dispatch;
	}
	// 821A5214: 4800001D  bl 0x821a5230
	ctx.lr = 0x821A5218;
	sub_821A5230(ctx, base);
	pc = 0x821A5218; continue 'dispatch;
            }
            0x821A5218 => {
    //   block [0x821A5218..0x821A522C)
	// 821A5218: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A521C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5230 size=648
    let mut pc: u32 = 0x821A5230;
    'dispatch: loop {
        match pc {
            0x821A5230 => {
    //   block [0x821A5230..0x821A5268)
	// 821A5230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5234: 4838FE65  bl 0x82535098
	ctx.lr = 0x821A5238;
	sub_82535080(ctx, base);
	// 821A5238: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A523C: 48390DA5  bl 0x82535fe0
	ctx.lr = 0x821A5240;
	sub_82535FB0(ctx, base);
	// 821A5240: 9421FA90  stwu r1, -0x570(r1)
	ea = ctx.r[1].u32.wrapping_add(-1392 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5244: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A5248: 817900E4  lwz r11, 0xe4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(228 as u32) ) } as u64;
	// 821A524C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5250: 419A0018  beq cr6, 0x821a5268
	if ctx.cr[6].eq {
	pc = 0x821A5268; continue 'dispatch;
	}
	// 821A5254: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5258: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A525C: 813900E0  lwz r9, 0xe0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A5260: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5264: 419A0008  beq cr6, 0x821a526c
	if ctx.cr[6].eq {
	pc = 0x821A526C; continue 'dispatch;
	}
	pc = 0x821A5268; continue 'dispatch;
            }
            0x821A5268 => {
    //   block [0x821A5268..0x821A526C)
	// 821A5268: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x821A526C; continue 'dispatch;
            }
            0x821A526C => {
    //   block [0x821A526C..0x821A5284)
	// 821A526C: 817B0084  lwz r11, 0x84(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A5270: 82B900CC  lwz r21, 0xcc(r25)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5274: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5278: 409A000C  bne cr6, 0x821a5284
	if !ctx.cr[6].eq {
	pc = 0x821A5284; continue 'dispatch;
	}
	// 821A527C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5280: 4800000C  b 0x821a528c
	pc = 0x821A528C; continue 'dispatch;
            }
            0x821A5284 => {
    //   block [0x821A5284..0x821A528C)
	// 821A5284: 815B008C  lwz r10, 0x8c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5288: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A528C; continue 'dispatch;
            }
            0x821A528C => {
    //   block [0x821A528C..0x821A52DC)
	// 821A528C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A5290: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A5294: 419A0208  beq cr6, 0x821a549c
	if ctx.cr[6].eq {
	pc = 0x821A549C; continue 'dispatch;
	}
	// 821A5298: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A529C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821A52A0: 3B0B33E0  addi r24, r11, 0x33e0
	ctx.r[24].s64 = ctx.r[11].s64 + 13280;
	// 821A52A4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A52A8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A52AC: 3AEBCFE0  addi r23, r11, -0x3020
	ctx.r[23].s64 = ctx.r[11].s64 + -12320;
	// 821A52B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A52B4: C347BA38  lfs f26, -0x45c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A52B8: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 821A52BC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A52C0: 3ACBD000  addi r22, r11, -0x3000
	ctx.r[22].s64 = ctx.r[11].s64 + -12288;
	// 821A52C4: C3682098  lfs f27, 0x2098(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8344 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A52C8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A52CC: 3A9900F0  addi r20, r25, 0xf0
	ctx.r[20].s64 = ctx.r[25].s64 + 240;
	// 821A52D0: C389D4DC  lfs f28, -0x2b24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A52D4: 3BABCFF0  addi r29, r11, -0x3010
	ctx.r[29].s64 = ctx.r[11].s64 + -12304;
	// 821A52D8: C3AA1FF8  lfs f29, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x821A52DC; continue 'dispatch;
            }
            0x821A52DC => {
    //   block [0x821A52DC..0x821A52FC)
	// 821A52DC: 817B0098  lwz r11, 0x98(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A52E0: 395C0024  addi r10, r28, 0x24
	ctx.r[10].s64 = ctx.r[28].s64 + 36;
	// 821A52E4: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 821A52E8: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A52EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A52F0: 409A000C  bne cr6, 0x821a52fc
	if !ctx.cr[6].eq {
	pc = 0x821A52FC; continue 'dispatch;
	}
	// 821A52F4: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A52F8: 48000020  b 0x821a5318
	pc = 0x821A5318; continue 'dispatch;
            }
            0x821A52FC => {
    //   block [0x821A52FC..0x821A5318)
	// 821A52FC: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821A5300: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5304: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A5308: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821A530C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A5310: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A5314: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x821A5318; continue 'dispatch;
            }
            0x821A5318 => {
    //   block [0x821A5318..0x821A535C)
	// 821A5318: 817900D4  lwz r11, 0xd4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A531C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A5320: 39090020  addi r8, r9, 0x20
	ctx.r[8].s64 = ctx.r[9].s64 + 32;
	// 821A5324: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 821A5328: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A532C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5330: 419A0070  beq cr6, 0x821a53a0
	if ctx.cr[6].eq {
	pc = 0x821A53A0; continue 'dispatch;
	}
	// 821A5334: 8148001C  lwz r10, 0x1c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A5338: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A533C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A5340: 419A001C  beq cr6, 0x821a535c
	if ctx.cr[6].eq {
	pc = 0x821A535C; continue 'dispatch;
	}
	// 821A5344: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A5348: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A534C: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 821A5350: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A5354: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A5358: 7C07542E  lfsx f0, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A535C; continue 'dispatch;
            }
            0x821A535C => {
    //   block [0x821A535C..0x821A5368)
	// 821A535C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821A5360: 40980008  bge cr6, 0x821a5368
	if !ctx.cr[6].lt {
	pc = 0x821A5368; continue 'dispatch;
	}
	// 821A5364: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x821A5368; continue 'dispatch;
            }
            0x821A5368 => {
    //   block [0x821A5368..0x821A53A0)
	// 821A5368: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A536C: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A5370: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821A5374: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A5378: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A537C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821A5380: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821A5384: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A5388: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A538C: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 821A5390: A161006E  lhz r11, 0x6e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 821A5394: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A5398: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A539C: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x821A53A0; continue 'dispatch;
            }
            0x821A53A0 => {
    //   block [0x821A53A0..0x821A53B4)
	// 821A53A0: 8168002C  lwz r11, 0x2c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A53A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A53A8: 409A000C  bne cr6, 0x821a53b4
	if !ctx.cr[6].eq {
	pc = 0x821A53B4; continue 'dispatch;
	}
	// 821A53AC: C3C90008  lfs f30, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A53B0: 48000020  b 0x821a53d0
	pc = 0x821A53D0; continue 'dispatch;
            }
            0x821A53B4 => {
    //   block [0x821A53B4..0x821A53D0)
	// 821A53B4: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 821A53B8: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A53BC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A53C0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A53C4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A53C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A53CC: 7FCA5C2E  lfsx f30, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821A53D0; continue 'dispatch;
            }
            0x821A53D0 => {
    //   block [0x821A53D0..0x821A548C)
	// 821A53D0: 817900D8  lwz r11, 0xd8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A53D4: C01C0184  lfs f0, 0x184(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A53D8: EC2D0732  fmuls f1, f13, f28
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 821A53DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A53E0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A53E4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821A53E8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A53EC: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A53F0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821A53F4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A53F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A53FC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A5400: 817B0094  lwz r11, 0x94(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A5404: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821A5408: EC41D82A  fadds f2, f1, f27
	ctx.f[2].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 821A540C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5410: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A5414: 4800ACFD  bl 0x821b0110
	ctx.lr = 0x821A5418;
	sub_821B0110(ctx, base);
	// 821A5418: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 821A541C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A5420: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821A5424: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821A5428: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821A542C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821A5430: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A5434: 4800AD65  bl 0x821b0198
	ctx.lr = 0x821A5438;
	sub_821B0198(ctx, base);
	// 821A5438: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821A543C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 821A5440: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 821A5444: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821A5448: 4800AFE1  bl 0x821b0428
	ctx.lr = 0x821A544C;
	sub_821B0428(ctx, base);
	// 821A544C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A5450: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821A5454: FC60D090  fmr f3, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[26].f64;
	// 821A5458: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821A545C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 821A5460: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 821A5464: EC3F07B2  fmuls f1, f31, f30
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A5468: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821A546C: 4800BA7D  bl 0x821b0ee8
	ctx.lr = 0x821A5470;
	sub_821B0EE8(ctx, base);
	// 821A5470: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5474: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 821A5478: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 821A547C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5480: 409A000C  bne cr6, 0x821a548c
	if !ctx.cr[6].eq {
	pc = 0x821A548C; continue 'dispatch;
	}
	// 821A5484: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5488: 4800000C  b 0x821a5494
	pc = 0x821A5494; continue 'dispatch;
            }
            0x821A548C => {
    //   block [0x821A548C..0x821A5494)
	// 821A548C: 815B008C  lwz r10, 0x8c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5490: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A5494; continue 'dispatch;
            }
            0x821A5494 => {
    //   block [0x821A5494..0x821A549C)
	// 821A5494: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A5498: 409AFE44  bne cr6, 0x821a52dc
	if !ctx.cr[6].eq {
	pc = 0x821A52DC; continue 'dispatch;
	}
	pc = 0x821A549C; continue 'dispatch;
            }
            0x821A549C => {
    //   block [0x821A549C..0x821A54B8)
	// 821A549C: 1D7A0042  mulli r11, r26, 0x42
	ctx.r[11].s32 = ((ctx.r[26].s32 as i64 * 66 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A54A0: 935900C8  stw r26, 0xc8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 821A54A4: 917900C4  stw r11, 0xc4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A54A8: 38210570  addi r1, r1, 0x570
	ctx.r[1].s64 = ctx.r[1].s64 + 1392;
	// 821A54AC: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A54B0: 48390B7D  bl 0x8253602c
	ctx.lr = 0x821A54B4;
	sub_82535FFC(ctx, base);
	// 821A54B4: 4838FC34  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A54E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A54E0 size=88
    let mut pc: u32 = 0x821A54E0;
    'dispatch: loop {
        match pc {
            0x821A54E0 => {
    //   block [0x821A54E0..0x821A5524)
	// 821A54E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A54E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A54E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A54EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A54F0: A164000C  lhz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A54F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A54F8: 4099002C  ble cr6, 0x821a5524
	if !ctx.cr[6].gt {
	pc = 0x821A5524; continue 'dispatch;
	}
	// 821A54FC: 481C1C3D  bl 0x82367138
	ctx.lr = 0x821A5500;
	sub_82367138(ctx, base);
	// 821A5500: A164000C  lhz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5504: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A5508: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A550C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A5510: 5563043E  clrlwi r3, r11, 0x10
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A5514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A551C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5520: 4E800020  blr
	return;
            }
            0x821A5524 => {
    //   block [0x821A5524..0x821A5538)
	// 821A5524: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A5528: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A552C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A5538 size=416
    let mut pc: u32 = 0x821A5538;
    'dispatch: loop {
        match pc {
            0x821A5538 => {
    //   block [0x821A5538..0x821A5584)
	// 821A5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A553C: 4838FB75  bl 0x825350b0
	ctx.lr = 0x821A5540;
	sub_82535080(ctx, base);
	// 821A5540: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A5548: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A554C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A5550: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A5554: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A5558: 38EB0E34  addi r7, r11, 0xe34
	ctx.r[7].s64 = ctx.r[11].s64 + 3636;
	// 821A555C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A5560: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A5564: 38A00289  li r5, 0x289
	ctx.r[5].s64 = 649;
	// 821A5568: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 821A556C: 481C4F25  bl 0x8236a490
	ctx.lr = 0x821A5570;
	sub_8236A490(ctx, base);
	// 821A5570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5574: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5578: 419A000C  beq cr6, 0x821a5584
	if ctx.cr[6].eq {
	pc = 0x821A5584; continue 'dispatch;
	}
	// 821A557C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5580: 48000008  b 0x821a5588
	pc = 0x821A5588; continue 'dispatch;
            }
            0x821A5584 => {
    //   block [0x821A5584..0x821A5588)
	// 821A5584: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A5588; continue 'dispatch;
            }
            0x821A5588 => {
    //   block [0x821A5588..0x821A564C)
	// 821A5588: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A558C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A5590: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A5594: 419A00B8  beq cr6, 0x821a564c
	if ctx.cr[6].eq {
	pc = 0x821A564C; continue 'dispatch;
	}
	// 821A5598: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A559C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A55A0: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A55A4: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A55A8: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A55AC: 390856D8  addi r8, r8, 0x56d8
	ctx.r[8].s64 = ctx.r[8].s64 + 22232;
	// 821A55B0: 39295780  addi r9, r9, 0x5780
	ctx.r[9].s64 = ctx.r[9].s64 + 22400;
	// 821A55B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A55B8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A55BC: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 821A55C0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A55C4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A55C8: B3BF0084  sth r29, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u16 ) };
	// 821A55CC: B3BF0086  sth r29, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[29].u16 ) };
	// 821A55D0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A55D4: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A55D8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A55DC: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A55E0: FBBF00F0  std r29, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[29].u64 ) };
	// 821A55E4: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A55E8: FBBF00F8  std r29, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[29].u64 ) };
	// 821A55EC: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A55F0: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A55F4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821A55F8: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A55FC: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A5600: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A5604: 55643032  slwi r4, r11, 6
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A5608: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A560C: 4BFFC625  bl 0x821a1c30
	ctx.lr = 0x821A5610;
	sub_821A1C30(ctx, base);
	// 821A5610: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5618: 409A0044  bne cr6, 0x821a565c
	if !ctx.cr[6].eq {
	pc = 0x821A565C; continue 'dispatch;
	}
	// 821A561C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5620: 419A002C  beq cr6, 0x821a564c
	if ctx.cr[6].eq {
	pc = 0x821A564C; continue 'dispatch;
	}
	// 821A5624: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5628: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A562C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5630: 409A001C  bne cr6, 0x821a564c
	if !ctx.cr[6].eq {
	pc = 0x821A564C; continue 'dispatch;
	}
	// 821A5634: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A5638: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A563C: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A5640: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A5644: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A5648: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A564C; continue 'dispatch;
            }
            0x821A564C => {
    //   block [0x821A564C..0x821A565C)
	// 821A564C: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A5650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5654: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A5658: 4838FAA8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A565C => {
    //   block [0x821A565C..0x821A5674)
	// 821A565C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5660: 419A0014  beq cr6, 0x821a5674
	if ctx.cr[6].eq {
	pc = 0x821A5674; continue 'dispatch;
	}
	// 821A5664: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5668: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A566C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5670: 419A0008  beq cr6, 0x821a5678
	if ctx.cr[6].eq {
	pc = 0x821A5678; continue 'dispatch;
	}
	pc = 0x821A5674; continue 'dispatch;
            }
            0x821A5674 => {
    //   block [0x821A5674..0x821A5678)
	// 821A5674: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A5678; continue 'dispatch;
            }
            0x821A5678 => {
    //   block [0x821A5678..0x821A56BC)
	// 821A5678: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A567C: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A5680: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A5684: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821A5688: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A568C: FBBF00F0  std r29, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[29].u64 ) };
	// 821A5690: 939F00D0  stw r28, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[28].u32 ) };
	// 821A5694: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A5698: 419A0024  beq cr6, 0x821a56bc
	if ctx.cr[6].eq {
	pc = 0x821A56BC; continue 'dispatch;
	}
	// 821A569C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A56A0: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 821A56A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A56A8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A56AC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A56B0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A56B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A56B8: 4838FA48  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A56BC => {
    //   block [0x821A56BC..0x821A56D8)
	// 821A56BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A56C0: 93BF0100  stw r29, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[29].u32 ) };
	// 821A56C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A56C8: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A56CC: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821A56D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A56D4: 4838FA2C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A56D8 size=164
    let mut pc: u32 = 0x821A56D8;
    'dispatch: loop {
        match pc {
            0x821A56D8 => {
    //   block [0x821A56D8..0x821A56FC)
	// 821A56D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A56DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A56E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A56E4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A56E8: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A56EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A56F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A56F4: 419A0008  beq cr6, 0x821a56fc
	if ctx.cr[6].eq {
	pc = 0x821A56FC; continue 'dispatch;
	}
	// 821A56F8: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x821A56FC; continue 'dispatch;
            }
            0x821A56FC => {
    //   block [0x821A56FC..0x821A577C)
	// 821A56FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A5700: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A5704: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A5708: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821A570C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A5710: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5714: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A5718: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A571C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821A5720: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A5724: B1630084  sth r11, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 821A5728: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A572C: B1630086  sth r11, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 821A5730: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A5734: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A5738: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A573C: 910300A8  stw r8, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A5740: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821A5744: 91230094  stw r9, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A5748: 90C30098  stw r6, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 821A574C: 90A300A0  stw r5, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821A5750: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A5754: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5758: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A575C: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A5760: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A5764: 480018AD  bl 0x821a7010
	ctx.lr = 0x821A5768;
	sub_821A7010(ctx, base);
	// 821A5768: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A576C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A5770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A5774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A5778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5780 size=68
    let mut pc: u32 = 0x821A5780;
    'dispatch: loop {
        match pc {
            0x821A5780 => {
    //   block [0x821A5780..0x821A57B0)
	// 821A5780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5788: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A578C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A5790: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A5794: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A5798: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A579C: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A57A0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A57A4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A57A8: 419A0008  beq cr6, 0x821a57b0
	if ctx.cr[6].eq {
	pc = 0x821A57B0; continue 'dispatch;
	}
	// 821A57AC: 4800001D  bl 0x821a57c8
	ctx.lr = 0x821A57B0;
	sub_821A57C8(ctx, base);
	pc = 0x821A57B0; continue 'dispatch;
            }
            0x821A57B0 => {
    //   block [0x821A57B0..0x821A57C4)
	// 821A57B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A57B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A57B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A57BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A57C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A57C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A57C8 size=892
    let mut pc: u32 = 0x821A57C8;
    'dispatch: loop {
        match pc {
            0x821A57C8 => {
    //   block [0x821A57C8..0x821A5804)
	// 821A57C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A57CC: 4838F8CD  bl 0x82535098
	ctx.lr = 0x821A57D0;
	sub_82535080(ctx, base);
	// 821A57D0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A57D4: 4839080D  bl 0x82535fe0
	ctx.lr = 0x821A57D8;
	sub_82535FB0(ctx, base);
	// 821A57D8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A57DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A57E0: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821A57E4: 817D00F4  lwz r11, 0xf4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A57E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A57EC: 419A0018  beq cr6, 0x821a5804
	if ctx.cr[6].eq {
	pc = 0x821A5804; continue 'dispatch;
	}
	// 821A57F0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A57F4: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 821A57F8: 813D00F0  lwz r9, 0xf0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A57FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5800: 419A0008  beq cr6, 0x821a5808
	if ctx.cr[6].eq {
	pc = 0x821A5808; continue 'dispatch;
	}
	pc = 0x821A5804; continue 'dispatch;
            }
            0x821A5804 => {
    //   block [0x821A5804..0x821A5808)
	// 821A5804: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	pc = 0x821A5808; continue 'dispatch;
            }
            0x821A5808 => {
    //   block [0x821A5808..0x821A5824)
	// 821A5808: 81790084  lwz r11, 0x84(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A580C: 83FD00CC  lwz r31, 0xcc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5810: 837900CC  lwz r27, 0xcc(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A5814: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5818: 409A000C  bne cr6, 0x821a5824
	if !ctx.cr[6].eq {
	pc = 0x821A5824; continue 'dispatch;
	}
	// 821A581C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821A5820: 4800000C  b 0x821a582c
	pc = 0x821A582C; continue 'dispatch;
            }
            0x821A5824 => {
    //   block [0x821A5824..0x821A582C)
	// 821A5824: 8159008C  lwz r10, 0x8c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5828: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A582C; continue 'dispatch;
            }
            0x821A582C => {
    //   block [0x821A582C..0x821A58B8)
	// 821A582C: 839D00D4  lwz r28, 0xd4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A5830: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A5834: 7E95A378  mr r21, r20
	ctx.r[21].u64 = ctx.r[20].u64;
	// 821A5838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A583C: 419A02EC  beq cr6, 0x821a5b28
	if ctx.cr[6].eq {
	pc = 0x821A5B28; continue 'dispatch;
	}
	// 821A5840: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821A5844: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 821A5848: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A584C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A5850: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A5854: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A5858: C3A6BA38  lfs f29, -0x45c8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A585C: C367CFEC  lfs f27, -0x3014(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A5860: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 821A5864: C388218C  lfs f28, 0x218c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8588 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A5868: 3ACB14A0  addi r22, r11, 0x14a0
	ctx.r[22].s64 = ctx.r[11].s64 + 5280;
	// 821A586C: C3492278  lfs f26, 0x2278(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8824 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A5870: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 821A5874: C3CA1FF8  lfs f30, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A5878: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 821A587C: A17E0010  lhz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A5880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5884: 419A0040  beq cr6, 0x821a58c4
	if ctx.cr[6].eq {
	pc = 0x821A58C4; continue 'dispatch;
	}
	// 821A5888: B29E0010  sth r20, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[20].u16 ) };
	// 821A588C: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A5890: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A5894: 40990024  ble cr6, 0x821a58b8
	if !ctx.cr[6].gt {
	pc = 0x821A58B8; continue 'dispatch;
	}
	// 821A5898: 481C18A1  bl 0x82367138
	ctx.lr = 0x821A589C;
	sub_82367138(ctx, base);
	// 821A589C: A17C000C  lhz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A58A0: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A58A4: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A58A8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A58AC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A58B0: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A58B4: 4800024C  b 0x821a5b00
	pc = 0x821A5B00; continue 'dispatch;
            }
            0x821A58B8 => {
    //   block [0x821A58B8..0x821A58C4)
	// 821A58B8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821A58BC: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A58C0: 48000240  b 0x821a5b00
	pc = 0x821A5B00; continue 'dispatch;
            }
            0x821A58C4 => {
    //   block [0x821A58C4..0x821A5904)
	// 821A58C4: 839D00D4  lwz r28, 0xd4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A58C8: 391E003C  addi r8, r30, 0x3c
	ctx.r[8].s64 = ctx.r[30].s64 + 60;
	// 821A58CC: 80F90098  lwz r7, 0x98(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A58D0: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A58D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A58D8: 419A00C4  beq cr6, 0x821a599c
	if ctx.cr[6].eq {
	pc = 0x821A599C; continue 'dispatch;
	}
	// 821A58DC: 8167005C  lwz r11, 0x5c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A58E0: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A58E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A58E8: 419A001C  beq cr6, 0x821a5904
	if ctx.cr[6].eq {
	pc = 0x821A5904; continue 'dispatch;
	}
	// 821A58EC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821A58F0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A58F4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A58F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A58FC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A5900: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A5904; continue 'dispatch;
            }
            0x821A5904 => {
    //   block [0x821A5904..0x821A5910)
	// 821A5904: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821A5908: 40980008  bge cr6, 0x821a5910
	if !ctx.cr[6].lt {
	pc = 0x821A5910; continue 'dispatch;
	}
	// 821A590C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x821A5910; continue 'dispatch;
            }
            0x821A5910 => {
    //   block [0x821A5910..0x821A599C)
	// 821A5910: A17E0198  lhz r11, 0x198(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 821A5914: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821A5918: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A591C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5920: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821A5924: A0CB0012  lhz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A5928: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A592C: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A5930: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A5934: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A5938: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A593C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A5940: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A5944: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A5948: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 821A594C: A161006E  lhz r11, 0x6e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 821A5950: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A5954: 556B2AF4  rlwinm r11, r11, 5, 0xb, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821A5958: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A595C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5960: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A5964: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5968: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A596C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5970: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A5974: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5978: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A597C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5980: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A5984: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5988: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A598C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5990: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A5994: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A5998: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	pc = 0x821A599C; continue 'dispatch;
            }
            0x821A599C => {
    //   block [0x821A599C..0x821A59C4)
	// 821A599C: 8167006C  lwz r11, 0x6c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A59A0: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A59A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A59A8: 419A001C  beq cr6, 0x821a59c4
	if ctx.cr[6].eq {
	pc = 0x821A59C4; continue 'dispatch;
	}
	// 821A59AC: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A59B0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A59B4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A59B8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A59BC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A59C0: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A59C4; continue 'dispatch;
            }
            0x821A59C4 => {
    //   block [0x821A59C4..0x821A59E0)
	// 821A59C4: 817900A0  lwz r11, 0xa0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A59C8: 556B018C  rlwinm r11, r11, 0, 6, 6
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A59CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A59D0: 419A0010  beq cr6, 0x821a59e0
	if ctx.cr[6].eq {
	pc = 0x821A59E0; continue 'dispatch;
	}
	// 821A59D4: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821A59D8: 40990008  ble cr6, 0x821a59e0
	if !ctx.cr[6].gt {
	pc = 0x821A59E0; continue 'dispatch;
	}
	// 821A59DC: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x821A59E0; continue 'dispatch;
            }
            0x821A59E0 => {
    //   block [0x821A59E0..0x821A5A30)
	// 821A59E0: 817D00D8  lwz r11, 0xd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A59E4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 821A59E8: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 821A59EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821A59F0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821A59F4: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A59F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A59FC: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A5A00: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821A5A04: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A5A08: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A5A0C: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A5A10: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 821A5A14: 4BFFE0F5  bl 0x821a3b08
	ctx.lr = 0x821A5A18;
	sub_821A3B08(ctx, base);
	// 821A5A18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A5A1C: 3964FFE9  addi r11, r4, -0x17
	ctx.r[11].s64 = ctx.r[4].s64 + -23;
	// 821A5A20: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 821A5A24: 4199000C  bgt cr6, 0x821a5a30
	if ctx.cr[6].gt {
	pc = 0x821A5A30; continue 'dispatch;
	}
	// 821A5A28: FFE0D890  fmr f31, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[27].f64;
	// 821A5A2C: 48000008  b 0x821a5a34
	pc = 0x821A5A34; continue 'dispatch;
            }
            0x821A5A30 => {
    //   block [0x821A5A30..0x821A5A34)
	// 821A5A30: FFE0D090  fmr f31, f26
	ctx.f[31].f64 = ctx.f[26].f64;
	pc = 0x821A5A34; continue 'dispatch;
            }
            0x821A5A34 => {
    //   block [0x821A5A34..0x821A5B00)
	// 821A5A34: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5A38: 387B0030  addi r3, r27, 0x30
	ctx.r[3].s64 = ctx.r[27].s64 + 48;
	// 821A5A3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A5A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A5A44: 4E800421  bctrl
	ctx.lr = 0x821A5A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A5A48: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
            }
            0x821A5B00 => {
    //   block [0x821A5B00..0x821A5B28)
	// 821A5B00: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5B04: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A5B08: 409A000C  bne cr6, 0x821a5b14
	if !ctx.cr[6].eq {
	pc = 0x821A5B14; continue 'dispatch;
	}
	// 821A5B0C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821A5B10: 4800000C  b 0x821a5b1c
	pc = 0x821A5B1C; continue 'dispatch;
	// 821A5B14: 8159008C  lwz r10, 0x8c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A5B18: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A5B1C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A5B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5B24: 409AFD58  bne cr6, 0x821a587c
	if !ctx.cr[6].eq {
	pc = 0x821A587C; continue 'dispatch;
	}
            }
            0x821A5B28 => {
    //   block [0x821A5B28..0x821A5B44)
	// 821A5B28: 56AB103A  slwi r11, r21, 2
	ctx.r[11].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5B2C: 92BD00C8  stw r21, 0xc8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(200 as u32), ctx.r[21].u32 ) };
	// 821A5B30: 917D00C4  stw r11, 0xc4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A5B34: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821A5B38: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A5B3C: 483904F1  bl 0x8253602c
	ctx.lr = 0x821A5B40;
	sub_82535FFC(ctx, base);
	// 821A5B40: 4838F5A8  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5B48 size=852
    let mut pc: u32 = 0x821A5B48;
    'dispatch: loop {
        match pc {
            0x821A5B48 => {
    //   block [0x821A5B48..0x821A5B7C)
	// 821A5B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A5B50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5B54: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821A5B58: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821A5B5C: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821A5B60: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5B68: 419A0014  beq cr6, 0x821a5b7c
	if ctx.cr[6].eq {
	pc = 0x821A5B7C; continue 'dispatch;
	}
	// 821A5B6C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5B70: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5B74: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A5B78: 419A0008  beq cr6, 0x821a5b80
	if ctx.cr[6].eq {
	pc = 0x821A5B80; continue 'dispatch;
	}
	pc = 0x821A5B7C; continue 'dispatch;
            }
            0x821A5B7C => {
    //   block [0x821A5B7C..0x821A5B80)
	// 821A5B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A5B80; continue 'dispatch;
            }
            0x821A5B80 => {
    //   block [0x821A5B80..0x821A5E9C)
	// 821A5B80: 396B0090  addi r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A5EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A5EA0 size=356
    let mut pc: u32 = 0x821A5EA0;
    'dispatch: loop {
        match pc {
            0x821A5EA0 => {
    //   block [0x821A5EA0..0x821A5EE8)
	// 821A5EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A5EA4: 4838F211  bl 0x825350b4
	ctx.lr = 0x821A5EA8;
	sub_82535080(ctx, base);
	// 821A5EA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A5EAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A5EB0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A5EB4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A5EB8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A5EBC: 38EB0E5C  addi r7, r11, 0xe5c
	ctx.r[7].s64 = ctx.r[11].s64 + 3676;
	// 821A5EC0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A5EC4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821A5EC8: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A5ECC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 821A5ED0: 481C45C1  bl 0x8236a490
	ctx.lr = 0x821A5ED4;
	sub_8236A490(ctx, base);
	// 821A5ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A5ED8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5EDC: 419A000C  beq cr6, 0x821a5ee8
	if ctx.cr[6].eq {
	pc = 0x821A5EE8; continue 'dispatch;
	}
	// 821A5EE0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5EE4: 48000008  b 0x821a5eec
	pc = 0x821A5EEC; continue 'dispatch;
            }
            0x821A5EE8 => {
    //   block [0x821A5EE8..0x821A5EEC)
	// 821A5EE8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A5EEC; continue 'dispatch;
            }
            0x821A5EEC => {
    //   block [0x821A5EEC..0x821A5FB0)
	// 821A5EEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A5EF0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A5EF4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A5EF8: 419A00B8  beq cr6, 0x821a5fb0
	if ctx.cr[6].eq {
	pc = 0x821A5FB0; continue 'dispatch;
	}
	// 821A5EFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A5F00: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A5F04: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A5F08: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A5F0C: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A5F10: 39086008  addi r8, r8, 0x6008
	ctx.r[8].s64 = ctx.r[8].s64 + 24584;
	// 821A5F14: 392960B0  addi r9, r9, 0x60b0
	ctx.r[9].s64 = ctx.r[9].s64 + 24752;
	// 821A5F18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A5F1C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A5F20: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A5F24: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A5F28: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A5F2C: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A5F30: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A5F34: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A5F38: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A5F3C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A5F40: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A5F44: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A5F48: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A5F4C: FB9F00F8  std r28, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821A5F50: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A5F54: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A5F58: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821A5F5C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A5F60: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A5F64: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A5F68: 5564482C  slwi r4, r11, 9
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(9);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A5F6C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A5F70: 4BFFBCC1  bl 0x821a1c30
	ctx.lr = 0x821A5F74;
	sub_821A1C30(ctx, base);
	// 821A5F74: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A5F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A5F7C: 409A0044  bne cr6, 0x821a5fc0
	if !ctx.cr[6].eq {
	pc = 0x821A5FC0; continue 'dispatch;
	}
	// 821A5F80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5F84: 419A002C  beq cr6, 0x821a5fb0
	if ctx.cr[6].eq {
	pc = 0x821A5FB0; continue 'dispatch;
	}
	// 821A5F88: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5F8C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5F90: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5F94: 409A001C  bne cr6, 0x821a5fb0
	if !ctx.cr[6].eq {
	pc = 0x821A5FB0; continue 'dispatch;
	}
	// 821A5F98: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A5F9C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A5FA0: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A5FA4: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A5FA8: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A5FAC: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A5FB0; continue 'dispatch;
            }
            0x821A5FB0 => {
    //   block [0x821A5FB0..0x821A5FC0)
	// 821A5FB0: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A5FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A5FBC: 4838F148  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821A5FC0 => {
    //   block [0x821A5FC0..0x821A5FD8)
	// 821A5FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A5FC4: 419A0014  beq cr6, 0x821a5fd8
	if ctx.cr[6].eq {
	pc = 0x821A5FD8; continue 'dispatch;
	}
	// 821A5FC8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A5FCC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5FD0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A5FD4: 419A0008  beq cr6, 0x821a5fdc
	if ctx.cr[6].eq {
	pc = 0x821A5FDC; continue 'dispatch;
	}
	pc = 0x821A5FD8; continue 'dispatch;
            }
            0x821A5FD8 => {
    //   block [0x821A5FD8..0x821A5FDC)
	// 821A5FD8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A5FDC; continue 'dispatch;
            }
            0x821A5FDC => {
    //   block [0x821A5FDC..0x821A6004)
	// 821A5FDC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A5FE0: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A5FE4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A5FE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A5FEC: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A5FF0: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A5FF4: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 821A5FF8: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A5FFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6000: 4838F104  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6008 size=168
    let mut pc: u32 = 0x821A6008;
    'dispatch: loop {
        match pc {
            0x821A6008 => {
    //   block [0x821A6008..0x821A602C)
	// 821A6008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A600C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6014: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6018: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A601C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A6020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6024: 419A0008  beq cr6, 0x821a602c
	if ctx.cr[6].eq {
	pc = 0x821A602C; continue 'dispatch;
	}
	// 821A6028: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x821A602C; continue 'dispatch;
            }
            0x821A602C => {
    //   block [0x821A602C..0x821A60B0)
	// 821A602C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A6030: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A6034: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A6038: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821A603C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A6040: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6044: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A6048: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A604C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821A6050: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A6054: B1630084  sth r11, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 821A6058: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A605C: B1630086  sth r11, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 821A6060: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A6064: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A6068: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A606C: 910300A8  stw r8, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A6070: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821A6074: 91230094  stw r9, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A6078: 90C30098  stw r6, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 821A607C: 90A300A0  stw r5, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821A6080: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6084: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6088: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A608C: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A6090: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A6094: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A6098: 48000061  bl 0x821a60f8
	ctx.lr = 0x821A609C;
	sub_821A60F8(ctx, base);
	// 821A609C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A60A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A60A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A60A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A60AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A60B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A60B0 size=68
    let mut pc: u32 = 0x821A60B0;
    'dispatch: loop {
        match pc {
            0x821A60B0 => {
    //   block [0x821A60B0..0x821A60E0)
	// 821A60B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A60B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A60B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A60BC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A60C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A60C4: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A60C8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A60CC: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A60D0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A60D4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A60D8: 419A0008  beq cr6, 0x821a60e0
	if ctx.cr[6].eq {
	pc = 0x821A60E0; continue 'dispatch;
	}
	// 821A60DC: 480000ED  bl 0x821a61c8
	ctx.lr = 0x821A60E0;
	sub_821A61C8(ctx, base);
	pc = 0x821A60E0; continue 'dispatch;
            }
            0x821A60E0 => {
    //   block [0x821A60E0..0x821A60F4)
	// 821A60E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A60E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A60E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A60EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A60F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A60F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A60F8 size=208
    let mut pc: u32 = 0x821A60F8;
    'dispatch: loop {
        match pc {
            0x821A60F8 => {
    //   block [0x821A60F8..0x821A6140)
	// 821A60F8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821A60FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A6100: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821A6104: 814600D0  lwz r10, 0xd0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A6108: 810600D8  lwz r8, 0xd8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A610C: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A6110: 816600CC  lwz r11, 0xcc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A6114: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A6118: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A611C: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A6120: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6124: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A6128: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A612C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A6130: 40990078  ble cr6, 0x821a61a8
	if !ctx.cr[6].gt {
	pc = 0x821A61A8; continue 'dispatch;
	}
	// 821A6134: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A6138: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A613C: C16ABA38  lfs f11, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x821A6140; continue 'dispatch;
            }
            0x821A6140 => {
    //   block [0x821A6140..0x821A6144)
	// 821A6140: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	pc = 0x821A6144; continue 'dispatch;
            }
            0x821A6144 => {
    //   block [0x821A6144..0x821A61A8)
	// 821A6144: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6148: 910B002C  stw r8, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 821A614C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6150: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A6154: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A6158: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A615C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A6160: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A6164: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6168: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821A616C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6170: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A6174: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6178: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A617C: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6180: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 821A6184: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6188: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A618C: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6190: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A6194: 409AFFB0  bne cr6, 0x821a6144
	if !ctx.cr[6].eq {
	pc = 0x821A6144; continue 'dispatch;
	}
	// 821A6198: 814600D0  lwz r10, 0xd0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A619C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821A61A0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A61A4: 4198FF9C  blt cr6, 0x821a6140
	if ctx.cr[6].lt {
	pc = 0x821A6140; continue 'dispatch;
	}
	pc = 0x821A61A8; continue 'dispatch;
            }
            0x821A61A8 => {
    //   block [0x821A61A8..0x821A61C8)
	// 821A61A8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A61AC: 814600D0  lwz r10, 0xd0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A61B0: 55442036  slwi r4, r10, 4
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A61B4: C04BD468  lfs f2, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A61B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A61BC: C02BD218  lfs f1, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A61C0: 48009CC0  b 0x821afe80
	sub_821AFE80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A61C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A61C8 size=636
    let mut pc: u32 = 0x821A61C8;
    'dispatch: loop {
        match pc {
            0x821A61C8 => {
    //   block [0x821A61C8..0x821A6200)
	// 821A61C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A61CC: 4838EECD  bl 0x82535098
	ctx.lr = 0x821A61D0;
	sub_82535080(ctx, base);
	// 821A61D0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A61D4: 4838FE11  bl 0x82535fe4
	ctx.lr = 0x821A61D8;
	sub_82535FB0(ctx, base);
	// 821A61D8: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A61DC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A61E0: 817A00F4  lwz r11, 0xf4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A61E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A61E8: 419A0018  beq cr6, 0x821a6200
	if ctx.cr[6].eq {
	pc = 0x821A6200; continue 'dispatch;
	}
	// 821A61EC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A61F0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A61F4: 813A00F0  lwz r9, 0xf0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A61F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A61FC: 419A0008  beq cr6, 0x821a6204
	if ctx.cr[6].eq {
	pc = 0x821A6204; continue 'dispatch;
	}
	pc = 0x821A6200; continue 'dispatch;
            }
            0x821A6200 => {
    //   block [0x821A6200..0x821A6204)
	// 821A6200: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x821A6204; continue 'dispatch;
            }
            0x821A6204 => {
    //   block [0x821A6204..0x821A6230)
	// 821A6204: 817A00D0  lwz r11, 0xd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A6208: 831A00CC  lwz r24, 0xcc(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A620C: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A6210: 815B0084  lwz r10, 0x84(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A6214: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A6218: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821A621C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6220: 7E8BC214  add r20, r11, r24
	ctx.r[20].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 821A6224: 409A000C  bne cr6, 0x821a6230
	if !ctx.cr[6].eq {
	pc = 0x821A6230; continue 'dispatch;
	}
	// 821A6228: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A622C: 4800000C  b 0x821a6238
	pc = 0x821A6238; continue 'dispatch;
            }
            0x821A6230 => {
    //   block [0x821A6230..0x821A6238)
	// 821A6230: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6234: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x821A6238; continue 'dispatch;
            }
            0x821A6238 => {
    //   block [0x821A6238..0x821A6274)
	// 821A6238: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A623C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6240: 419A01E0  beq cr6, 0x821a6420
	if ctx.cr[6].eq {
	pc = 0x821A6420; continue 'dispatch;
	}
	// 821A6244: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A6248: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A624C: 3AEB33F0  addi r23, r11, 0x33f0
	ctx.r[23].s64 = ctx.r[11].s64 + 13296;
	// 821A6250: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A6254: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A6258: 3ACB3400  addi r22, r11, 0x3400
	ctx.r[22].s64 = ctx.r[11].s64 + 13312;
	// 821A625C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A6260: C389D6C8  lfs f28, -0x2938(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A6264: 3AABD020  addi r21, r11, -0x2fe0
	ctx.r[21].s64 = ctx.r[11].s64 + -12256;
	// 821A6268: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A626C: C36A1FF8  lfs f27, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A6270: 3B8BD010  addi r28, r11, -0x2ff0
	ctx.r[28].s64 = ctx.r[11].s64 + -12272;
	pc = 0x821A6274; continue 'dispatch;
            }
            0x821A6274 => {
    //   block [0x821A6274..0x821A6294)
	// 821A6274: 817B0098  lwz r11, 0x98(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A6278: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	// 821A627C: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 821A6280: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6288: 409A000C  bne cr6, 0x821a6294
	if !ctx.cr[6].eq {
	pc = 0x821A6294; continue 'dispatch;
	}
	// 821A628C: C3AA0000  lfs f29, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A6290: 48000020  b 0x821a62b0
	pc = 0x821A62B0; continue 'dispatch;
            }
            0x821A6294 => {
    //   block [0x821A6294..0x821A62B0)
	// 821A6294: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821A6298: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A629C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A62A0: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821A62A4: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A62A8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A62AC: 7FA85C2E  lfsx f29, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x821A62B0; continue 'dispatch;
            }
            0x821A62B0 => {
    //   block [0x821A62B0..0x821A62F4)
	// 821A62B0: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A62B4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A62B8: 39090020  addi r8, r9, 0x20
	ctx.r[8].s64 = ctx.r[9].s64 + 32;
	// 821A62BC: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 821A62C0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A62C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A62C8: 419A0070  beq cr6, 0x821a6338
	if ctx.cr[6].eq {
	pc = 0x821A6338; continue 'dispatch;
	}
	// 821A62CC: 8148001C  lwz r10, 0x1c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A62D0: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A62D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A62D8: 419A001C  beq cr6, 0x821a62f4
	if ctx.cr[6].eq {
	pc = 0x821A62F4; continue 'dispatch;
	}
	// 821A62DC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821A62E0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A62E4: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 821A62E8: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A62EC: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A62F0: 7C07542E  lfsx f0, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A62F4; continue 'dispatch;
            }
            0x821A62F4 => {
    //   block [0x821A62F4..0x821A6300)
	// 821A62F4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821A62F8: 40980008  bge cr6, 0x821a6300
	if !ctx.cr[6].lt {
	pc = 0x821A6300; continue 'dispatch;
	}
	// 821A62FC: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	pc = 0x821A6300; continue 'dispatch;
            }
            0x821A6300 => {
    //   block [0x821A6300..0x821A6338)
	// 821A6300: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A6304: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A6308: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821A630C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A6310: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A6314: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A6318: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A631C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A6320: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A6324: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 821A6328: A161006E  lhz r11, 0x6e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 821A632C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6330: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6334: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x821A6338; continue 'dispatch;
            }
            0x821A6338 => {
    //   block [0x821A6338..0x821A634C)
	// 821A6338: 8168002C  lwz r11, 0x2c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A633C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6340: 409A000C  bne cr6, 0x821a634c
	if !ctx.cr[6].eq {
	pc = 0x821A634C; continue 'dispatch;
	}
	// 821A6344: C3C90008  lfs f30, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A6348: 48000020  b 0x821a6368
	pc = 0x821A6368; continue 'dispatch;
            }
            0x821A634C => {
    //   block [0x821A634C..0x821A6368)
	// 821A634C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 821A6350: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6354: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A6358: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A635C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A6360: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A6364: 7FCA5C2E  lfsx f30, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821A6368; continue 'dispatch;
            }
            0x821A6368 => {
    //   block [0x821A6368..0x821A6410)
	// 821A6368: 817A00D8  lwz r11, 0xd8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A636C: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6370: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821A6374: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 821A6378: 38FF0160  addi r7, r31, 0x160
	ctx.r[7].s64 = ctx.r[31].s64 + 352;
	// 821A637C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A6380: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821A6384: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A6388: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821A638C: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A6390: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A6394: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A6398: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A639C: 817B0094  lwz r11, 0x94(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A63A0: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821A63A4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A63A8: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A63AC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A63B0: 48009DE9  bl 0x821b0198
	ctx.lr = 0x821A63B4;
	sub_821B0198(ctx, base);
	// 821A63B4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A63B8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A63BC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A63C0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821A63C4: 7C8BA214  add r4, r11, r20
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 821A63C8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821A63CC: 4800A05D  bl 0x821b0428
	ctx.lr = 0x821A63D0;
	sub_821B0428(ctx, base);
	// 821A63D0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821A63D4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821A63D8: EC5D0732  fmuls f2, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 821A63DC: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 821A63E0: EC3F07B2  fmuls f1, f31, f30
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A63E4: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 821A63E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A63EC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821A63F0: 4800A5E1  bl 0x821b09d0
	ctx.lr = 0x821A63F4;
	sub_821B09D0(ctx, base);
	// 821A63F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A63F8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821A63FC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821A6400: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A6404: 409A000C  bne cr6, 0x821a6410
	if !ctx.cr[6].eq {
	pc = 0x821A6410; continue 'dispatch;
	}
	// 821A6408: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A640C: 4800000C  b 0x821a6418
	pc = 0x821A6418; continue 'dispatch;
            }
            0x821A6410 => {
    //   block [0x821A6410..0x821A6418)
	// 821A6410: 815B008C  lwz r10, 0x8c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6414: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A6418; continue 'dispatch;
            }
            0x821A6418 => {
    //   block [0x821A6418..0x821A6420)
	// 821A6418: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A641C: 409AFE58  bne cr6, 0x821a6274
	if !ctx.cr[6].eq {
	pc = 0x821A6274; continue 'dispatch;
	}
	pc = 0x821A6420; continue 'dispatch;
            }
            0x821A6420 => {
    //   block [0x821A6420..0x821A6444)
	// 821A6420: 572B083C  slwi r11, r25, 1
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6424: 933A00C8  stw r25, 0xc8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(200 as u32), ctx.r[25].u32 ) };
	// 821A6428: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 821A642C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6430: 917A00C4  stw r11, 0xc4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A6434: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 821A6438: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 821A643C: 4838FBF5  bl 0x82536030
	ctx.lr = 0x821A6440;
	sub_82535FFC(ctx, base);
	// 821A6440: 4838ECA8  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6448 size=356
    let mut pc: u32 = 0x821A6448;
    'dispatch: loop {
        match pc {
            0x821A6448 => {
    //   block [0x821A6448..0x821A6490)
	// 821A6448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A644C: 4838EC69  bl 0x825350b4
	ctx.lr = 0x821A6450;
	sub_82535080(ctx, base);
	// 821A6450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A6458: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A645C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A6460: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A6464: 38EB0E64  addi r7, r11, 0xe64
	ctx.r[7].s64 = ctx.r[11].s64 + 3684;
	// 821A6468: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A646C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821A6470: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A6474: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 821A6478: 481C4019  bl 0x8236a490
	ctx.lr = 0x821A647C;
	sub_8236A490(ctx, base);
	// 821A647C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6480: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6484: 419A000C  beq cr6, 0x821a6490
	if ctx.cr[6].eq {
	pc = 0x821A6490; continue 'dispatch;
	}
	// 821A6488: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A648C: 48000008  b 0x821a6494
	pc = 0x821A6494; continue 'dispatch;
            }
            0x821A6490 => {
    //   block [0x821A6490..0x821A6494)
	// 821A6490: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A6494; continue 'dispatch;
            }
            0x821A6494 => {
    //   block [0x821A6494..0x821A6558)
	// 821A6494: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6498: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A649C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A64A0: 419A00B8  beq cr6, 0x821a6558
	if ctx.cr[6].eq {
	pc = 0x821A6558; continue 'dispatch;
	}
	// 821A64A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A64A8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A64AC: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A64B0: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A64B4: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A64B8: 390865B0  addi r8, r8, 0x65b0
	ctx.r[8].s64 = ctx.r[8].s64 + 26032;
	// 821A64BC: 392966B8  addi r9, r9, 0x66b8
	ctx.r[9].s64 = ctx.r[9].s64 + 26296;
	// 821A64C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A64C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A64C8: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A64CC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A64D0: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A64D4: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A64D8: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A64DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A64E0: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A64E4: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A64E8: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A64EC: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A64F0: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A64F4: FB9F00F8  std r28, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821A64F8: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A64FC: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A6500: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821A6504: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A6508: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A650C: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A6510: 5564482C  slwi r4, r11, 9
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(9);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A6514: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A6518: 4BFFB719  bl 0x821a1c30
	ctx.lr = 0x821A651C;
	sub_821A1C30(ctx, base);
	// 821A651C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6524: 409A0044  bne cr6, 0x821a6568
	if !ctx.cr[6].eq {
	pc = 0x821A6568; continue 'dispatch;
	}
	// 821A6528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A652C: 419A002C  beq cr6, 0x821a6558
	if ctx.cr[6].eq {
	pc = 0x821A6558; continue 'dispatch;
	}
	// 821A6530: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6534: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6538: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A653C: 409A001C  bne cr6, 0x821a6558
	if !ctx.cr[6].eq {
	pc = 0x821A6558; continue 'dispatch;
	}
	// 821A6540: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A6544: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6548: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A654C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A6550: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A6554: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A6558; continue 'dispatch;
            }
            0x821A6558 => {
    //   block [0x821A6558..0x821A6568)
	// 821A6558: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A655C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6560: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6564: 4838EBA0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821A6568 => {
    //   block [0x821A6568..0x821A6580)
	// 821A6568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A656C: 419A0014  beq cr6, 0x821a6580
	if ctx.cr[6].eq {
	pc = 0x821A6580; continue 'dispatch;
	}
	// 821A6570: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6574: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6578: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A657C: 419A0008  beq cr6, 0x821a6584
	if ctx.cr[6].eq {
	pc = 0x821A6584; continue 'dispatch;
	}
	pc = 0x821A6580; continue 'dispatch;
            }
            0x821A6580 => {
    //   block [0x821A6580..0x821A6584)
	// 821A6580: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A6584; continue 'dispatch;
            }
            0x821A6584 => {
    //   block [0x821A6584..0x821A65AC)
	// 821A6584: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6588: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A658C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A6590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6594: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A6598: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A659C: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 821A65A0: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A65A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A65A8: 4838EB5C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A65B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A65B0 size=260
    let mut pc: u32 = 0x821A65B0;
    'dispatch: loop {
        match pc {
            0x821A65B0 => {
    //   block [0x821A65B0..0x821A65C8)
	// 821A65B0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A65B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A65B8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A65BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A65C0: 419A0008  beq cr6, 0x821a65c8
	if ctx.cr[6].eq {
	pc = 0x821A65C8; continue 'dispatch;
	}
	// 821A65C4: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	pc = 0x821A65C8; continue 'dispatch;
            }
            0x821A65C8 => {
    //   block [0x821A65C8..0x821A6660)
	// 821A65C8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A65CC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821A65D0: 3CE04020  lis r7, 0x4020
	ctx.r[7].s64 = 1075838976;
	// 821A65D4: 38C00120  li r6, 0x120
	ctx.r[6].s64 = 288;
	// 821A65D8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821A65DC: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A65E0: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 821A65E4: 990B001E  stb r8, 0x1e(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 821A65E8: 39000022  li r8, 0x22
	ctx.r[8].s64 = 34;
	// 821A65EC: B14B0084  sth r10, 0x84(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u16 ) };
	// 821A65F0: 39298E40  addi r9, r9, -0x71c0
	ctx.r[9].s64 = ctx.r[9].s64 + -29120;
	// 821A65F4: B14B0086  sth r10, 0x86(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(134 as u32), ctx.r[10].u16 ) };
	// 821A65F8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821A65FC: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821A6600: D00B00B0  stfs f0, 0xb0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A6604: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821A6608: D00B00B4  stfs f0, 0xb4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A660C: 90EB00A8  stw r7, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[7].u32 ) };
	// 821A6610: 90CB00A4  stw r6, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 821A6614: 910B0094  stw r8, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 821A6618: 90AB0098  stw r5, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 821A661C: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6620: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6624: D00B00B8  stfs f0, 0xb8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A6628: 3D4A0504  addis r10, r10, 0x504
	ctx.r[10].s64 = ctx.r[10].s64 + 84148224;
	// 821A662C: 394A4000  addi r10, r10, 0x4000
	ctx.r[10].s64 = ctx.r[10].s64 + 16384;
	// 821A6630: 914B0090  stw r10, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821A6634: 814B00D8  lwz r10, 0xd8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A6638: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A663C: 816B00CC  lwz r11, 0xcc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A6640: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A6644: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6648: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821A664C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A6650: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A6654: 40990058  ble cr6, 0x821a66ac
	if !ctx.cr[6].gt {
	pc = 0x821A66AC; continue 'dispatch;
	}
	// 821A6658: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A665C: C16ABA38  lfs f11, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x821A6660; continue 'dispatch;
            }
            0x821A6660 => {
    //   block [0x821A6660..0x821A6664)
	// 821A6660: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	pc = 0x821A6664; continue 'dispatch;
            }
            0x821A6664 => {
    //   block [0x821A6664..0x821A66AC)
	// 821A6664: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821A6668: 7C085A2C  dcbt r8, r11
	// 821A666C: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A6670: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A6674: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6678: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A667C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821A6680: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6684: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A6688: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A668C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A6690: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A6694: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A6698: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821A669C: 4199FFC8  bgt cr6, 0x821a6664
	if ctx.cr[6].gt {
	pc = 0x821A6664; continue 'dispatch;
	}
	// 821A66A0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821A66A4: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821A66A8: 4199FFB8  bgt cr6, 0x821a6660
	if ctx.cr[6].gt {
	pc = 0x821A6660; continue 'dispatch;
	}
	pc = 0x821A66AC; continue 'dispatch;
            }
            0x821A66AC => {
    //   block [0x821A66AC..0x821A66B4)
	// 821A66AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A66B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A66B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A66B8 size=68
    let mut pc: u32 = 0x821A66B8;
    'dispatch: loop {
        match pc {
            0x821A66B8 => {
    //   block [0x821A66B8..0x821A66E8)
	// 821A66B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A66BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A66C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A66C4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A66C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A66CC: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A66D0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A66D4: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A66D8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A66DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A66E0: 419A0008  beq cr6, 0x821a66e8
	if ctx.cr[6].eq {
	pc = 0x821A66E8; continue 'dispatch;
	}
	// 821A66E4: 4800001D  bl 0x821a6700
	ctx.lr = 0x821A66E8;
	sub_821A6700(ctx, base);
	pc = 0x821A66E8; continue 'dispatch;
            }
            0x821A66E8 => {
    //   block [0x821A66E8..0x821A66FC)
	// 821A66E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A66EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A66F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A66F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A66F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6700 size=692
    let mut pc: u32 = 0x821A6700;
    'dispatch: loop {
        match pc {
            0x821A6700 => {
    //   block [0x821A6700..0x821A6738)
	// 821A6700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6704: 4838E99D  bl 0x825350a0
	ctx.lr = 0x821A6708;
	sub_82535080(ctx, base);
	// 821A6708: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821A670C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821A6710: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6714: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821A6718: 817B00F4  lwz r11, 0xf4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A671C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6720: 419A0018  beq cr6, 0x821a6738
	if ctx.cr[6].eq {
	pc = 0x821A6738; continue 'dispatch;
	}
	// 821A6724: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6728: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 821A672C: 813B00F0  lwz r9, 0xf0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A6730: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A6734: 419A0008  beq cr6, 0x821a673c
	if ctx.cr[6].eq {
	pc = 0x821A673C; continue 'dispatch;
	}
	pc = 0x821A6738; continue 'dispatch;
            }
            0x821A6738 => {
    //   block [0x821A6738..0x821A673C)
	// 821A6738: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	pc = 0x821A673C; continue 'dispatch;
            }
            0x821A673C => {
    //   block [0x821A673C..0x821A6754)
	// 821A673C: 81770084  lwz r11, 0x84(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A6740: 82DB00CC  lwz r22, 0xcc(r27)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A6744: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A6748: 409A000C  bne cr6, 0x821a6754
	if !ctx.cr[6].eq {
	pc = 0x821A6754; continue 'dispatch;
	}
	// 821A674C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A6750: 4800000C  b 0x821a675c
	pc = 0x821A675C; continue 'dispatch;
            }
            0x821A6754 => {
    //   block [0x821A6754..0x821A675C)
	// 821A6754: 8157008C  lwz r10, 0x8c(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6758: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A675C; continue 'dispatch;
            }
            0x821A675C => {
    //   block [0x821A675C..0x821A6780)
	// 821A675C: 831B00D4  lwz r24, 0xd4(r27)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6760: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A6764: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A6768: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A676C: 419A0230  beq cr6, 0x821a699c
	if ctx.cr[6].eq {
	pc = 0x821A699C; continue 'dispatch;
	}
	// 821A6770: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A6774: 3BEB14B0  addi r31, r11, 0x14b0
	ctx.r[31].s64 = ctx.r[11].s64 + 5296;
	// 821A6778: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A677C: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821A6780; continue 'dispatch;
            }
            0x821A6780 => {
    //   block [0x821A6780..0x821A67B8)
	// 821A6780: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A6784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6788: 419A003C  beq cr6, 0x821a67c4
	if ctx.cr[6].eq {
	pc = 0x821A67C4; continue 'dispatch;
	}
	// 821A678C: A178000C  lhz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6790: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A6794: 40990024  ble cr6, 0x821a67b8
	if !ctx.cr[6].gt {
	pc = 0x821A67B8; continue 'dispatch;
	}
	// 821A6798: 481C09A1  bl 0x82367138
	ctx.lr = 0x821A679C;
	sub_82367138(ctx, base);
	// 821A679C: A178000C  lhz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A67A0: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A67A4: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A67A8: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A67AC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A67B0: B17D0198  sth r11, 0x198(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A67B4: 480001C4  b 0x821a6978
	pc = 0x821A6978; continue 'dispatch;
            }
            0x821A67B8 => {
    //   block [0x821A67B8..0x821A67C4)
	// 821A67B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A67BC: B17D0198  sth r11, 0x198(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A67C0: 480001B8  b 0x821a6978
	pc = 0x821A6978; continue 'dispatch;
            }
            0x821A67C4 => {
    //   block [0x821A67C4..0x821A6800)
	// 821A67C4: 83980000  lwz r28, 0(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A67C8: 393D003C  addi r9, r29, 0x3c
	ctx.r[9].s64 = ctx.r[29].s64 + 60;
	// 821A67CC: 81170098  lwz r8, 0x98(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A67D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821A67D4: 419A0084  beq cr6, 0x821a6858
	if ctx.cr[6].eq {
	pc = 0x821A6858; continue 'dispatch;
	}
	// 821A67D8: 8168005C  lwz r11, 0x5c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A67DC: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A67E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A67E4: 419A001C  beq cr6, 0x821a6800
	if ctx.cr[6].eq {
	pc = 0x821A6800; continue 'dispatch;
	}
	// 821A67E8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821A67EC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A67F0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A67F4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A67F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A67FC: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A6800; continue 'dispatch;
            }
            0x821A6800 => {
    //   block [0x821A6800..0x821A680C)
	// 821A6800: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821A6804: 40980008  bge cr6, 0x821a680c
	if !ctx.cr[6].lt {
	pc = 0x821A680C; continue 'dispatch;
	}
	// 821A6808: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x821A680C; continue 'dispatch;
            }
            0x821A680C => {
    //   block [0x821A680C..0x821A6858)
	// 821A680C: A17D0198  lhz r11, 0x198(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(408 as u32) ) } as u64;
	// 821A6810: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821A6814: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6818: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A681C: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 821A6820: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A6824: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A6828: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821A682C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821A6830: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A6834: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A6838: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A683C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A6840: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A6844: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 821A6848: A1610066  lhz r11, 0x66(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 821A684C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A6850: 556B2AF4  rlwinm r11, r11, 5, 0xb, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821A6854: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x821A6858; continue 'dispatch;
            }
            0x821A6858 => {
    //   block [0x821A6858..0x821A6880)
	// 821A6858: 8168006C  lwz r11, 0x6c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A685C: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6864: 419A001C  beq cr6, 0x821a6880
	if ctx.cr[6].eq {
	pc = 0x821A6880; continue 'dispatch;
	}
	// 821A6868: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A686C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A6870: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A6874: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A6878: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A687C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A6880; continue 'dispatch;
            }
            0x821A6880 => {
    //   block [0x821A6880..0x821A68B4)
	// 821A6880: 81770094  lwz r11, 0x94(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A6884: 393D0060  addi r9, r29, 0x60
	ctx.r[9].s64 = ctx.r[29].s64 + 96;
	// 821A6888: 815B00D8  lwz r10, 0xd8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A688C: 391F0900  addi r8, r31, 0x900
	ctx.r[8].s64 = ctx.r[31].s64 + 2304;
	// 821A6890: 55672036  slwi r7, r11, 4
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A6894: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A6898: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A689C: 395F0910  addi r10, r31, 0x910
	ctx.r[10].s64 = ctx.r[31].s64 + 2320;
	// 821A68A0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A68A4: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821A68A8: F8C80000  std r6, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821A68AC: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821A68B0: F8E80008  std r7, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	pc = 0x821A68B4; continue 'dispatch;
            }
            0x821A68B4 => {
    //   block [0x821A68B4..0x821A6978)
	// 821A68B4: 55672036  slwi r7, r11, 4
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821A68B8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821A68BC: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A68C0: 38DF0A10  addi r6, r31, 0xa10
	ctx.r[6].s64 = ctx.r[31].s64 + 2576;
	// 821A68C4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A68C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A68CC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821A68D0: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821A68D4: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821A68D8: F8C80000  std r6, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821A68DC: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821A68E0: F8E80008  std r7, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821A68E4: 4198FFD0  blt cr6, 0x821a68b4
	if ctx.cr[6].lt {
	pc = 0x821A68B4; continue 'dispatch;
	}
	// 821A68E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821A68EC: 395F0A10  addi r10, r31, 0xa10
	ctx.r[10].s64 = ctx.r[31].s64 + 2576;
	// 821A68F0: 556B2636  rlwinm r11, r11, 4, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821A68F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A68F8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A68FC: 38A0000F  li r5, 0xf
	ctx.r[5].s64 = 15;
	// 821A6900: 389F0900  addi r4, r31, 0x900
	ctx.r[4].s64 = ctx.r[31].s64 + 2304;
	// 821A6904: 387F0600  addi r3, r31, 0x600
	ctx.r[3].s64 = ctx.r[31].s64 + 1536;
	// 821A6908: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A690C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821A6910: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821A6914: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821A6918: 80DB0100  lwz r6, 0x100(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821A691C: 4BFF6015  bl 0x8219c930
	ctx.lr = 0x821A6920;
	sub_8219C930(ctx, base);
	// 821A6920: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A6924: C03D0180  lfs f1, 0x180(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(384 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A6928: 38DF0600  addi r6, r31, 0x600
	ctx.r[6].s64 = ctx.r[31].s64 + 1536;
	// 821A692C: 38BF0900  addi r5, r31, 0x900
	ctx.r[5].s64 = ctx.r[31].s64 + 2304;
	// 821A6930: 389F0300  addi r4, r31, 0x300
	ctx.r[4].s64 = ctx.r[31].s64 + 768;
	// 821A6934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6938: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A693C: 48009C8D  bl 0x821b05c8
	ctx.lr = 0x821A6940;
	sub_821B05C8(ctx, base);
	// 821A6940: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A6944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A6948: 48009F69  bl 0x821b08b0
	ctx.lr = 0x821A694C;
	sub_821B08B0(ctx, base);
	// 821A694C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6950: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821A6954: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6958: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821A695C: 389F0300  addi r4, r31, 0x300
	ctx.r[4].s64 = ctx.r[31].s64 + 768;
	// 821A6960: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821A6964: 4800A745  bl 0x821b10a8
	ctx.lr = 0x821A6968;
	sub_821B10A8(ctx, base);
	// 821A6968: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A696C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821A6970: 7F4BD214  add r26, r11, r26
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 821A6974: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	pc = 0x821A6978; continue 'dispatch;
            }
            0x821A6978 => {
    //   block [0x821A6978..0x821A698C)
	// 821A6978: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A697C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A6980: 409A000C  bne cr6, 0x821a698c
	if !ctx.cr[6].eq {
	pc = 0x821A698C; continue 'dispatch;
	}
	// 821A6984: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A6988: 4800000C  b 0x821a6994
	pc = 0x821A6994; continue 'dispatch;
            }
            0x821A698C => {
    //   block [0x821A698C..0x821A6994)
	// 821A698C: 8157008C  lwz r10, 0x8c(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A6990: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A6994; continue 'dispatch;
            }
            0x821A6994 => {
    //   block [0x821A6994..0x821A699C)
	// 821A6994: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821A6998: 409AFDE8  bne cr6, 0x821a6780
	if !ctx.cr[6].eq {
	pc = 0x821A6780; continue 'dispatch;
	}
	pc = 0x821A699C; continue 'dispatch;
            }
            0x821A699C => {
    //   block [0x821A699C..0x821A69B4)
	// 821A699C: 935B00C4  stw r26, 0xc4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 821A69A0: 933B00C8  stw r25, 0xc8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(200 as u32), ctx.r[25].u32 ) };
	// 821A69A4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821A69A8: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821A69AC: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821A69B0: 4838E740  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A69B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A69B8 size=556
    let mut pc: u32 = 0x821A69B8;
    'dispatch: loop {
        match pc {
            0x821A69B8 => {
    //   block [0x821A69B8..0x821A6BE4)
	// 821A69B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A69BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A69C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A69C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A69C8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821A69CC: 4838F60D  bl 0x82535fd8
	ctx.lr = 0x821A69D0;
	sub_82535FB0(ctx, base);
	// 821A69D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A69D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A69D8: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821A69DC: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 821A69E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A69E4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A69E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A69EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A69F0: 4E800421  bctrl
	ctx.lr = 0x821A69F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A69F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A69F8: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A69FC: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821A6A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6A04: C3CB0030  lfs f30, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A6A08: C3AB0034  lfs f29, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A6A0C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A6A10: C38B0038  lfs f28, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A6A14: D3C10080  stfs f30, 0x80(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A6A18: D3A10084  stfs f29, 0x84(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A6A1C: D3810088  stfs f28, 0x88(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A6A20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821A6A24: 4E800421  bctrl
	ctx.lr = 0x821A6A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A6A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A6A2C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821A6A30: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821A6A34: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 821A6A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6A3C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6A40: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A6A44: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6A48: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821A6A4C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6A50: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A6A54: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6BE8 size=392
    let mut pc: u32 = 0x821A6BE8;
    'dispatch: loop {
        match pc {
            0x821A6BE8 => {
    //   block [0x821A6BE8..0x821A6C40)
	// 821A6BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6BEC: 4838E4D1  bl 0x825350bc
	ctx.lr = 0x821A6BF0;
	sub_82535080(ctx, base);
	// 821A6BF0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821A6BF4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6BF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6BFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821A6C00: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 821A6C04: 398C6C18  addi r12, r12, 0x6c18
	ctx.r[12].s64 = ctx.r[12].s64 + 27672;
	// 821A6C08: 54A0103A  slwi r0, r5, 2
	ctx.r[0].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A6C0C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A6C10: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A6C14: 4E800420  bctr
	match ctx.r[31].u64 {
		0 => {
	pc = 0x821A6C40; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A6C18: 821A6C40  lwz r16, 0x6c40(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27712 as u32) ) } as u64;
	// 821A6C1C: 821A6C80  lwz r16, 0x6c80(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27776 as u32) ) } as u64;
	// 821A6C20: 821A6CC0  lwz r16, 0x6cc0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27840 as u32) ) } as u64;
	// 821A6C24: 821A6CC0  lwz r16, 0x6cc0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27840 as u32) ) } as u64;
	// 821A6C28: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C2C: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C30: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C34: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C38: 821A6D64  lwz r16, 0x6d64(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28004 as u32) ) } as u64;
	// 821A6C3C: 821A6D30  lwz r16, 0x6d30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27952 as u32) ) } as u64;
            }
            0x821A6C40 => {
    //   block [0x821A6C40..0x821A6D70)
	// 821A6C40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6C44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A6C48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6C4C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6C50: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6C54: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A6C58: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6C5C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6C60: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A6C64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A6C68: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821A6C6C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821A6C70: 48003D89  bl 0x821aa9f8
	ctx.lr = 0x821A6C74;
	sub_821AA9F8(ctx, base);
	// 821A6C74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6C78: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6C7C: 4838E490  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A6C80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6C84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A6C88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6C8C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6C90: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6C94: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A6C98: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6C9C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6CA0: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A6CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A6CA8: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821A6CAC: 38600016  li r3, 0x16
	ctx.r[3].s64 = 22;
	// 821A6CB0: 48003D49  bl 0x821aa9f8
	ctx.lr = 0x821A6CB4;
	sub_821AA9F8(ctx, base);
	// 821A6CB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6CB8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6CBC: 4838E450  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A6CC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6CC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A6CC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6CCC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6CD0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6CD4: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A6CD8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6CDC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6CE0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A6CE4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821A6CE8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6CEC: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 821A6CF0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821A6CF4: 48003D05  bl 0x821aa9f8
	ctx.lr = 0x821A6CF8;
	sub_821AA9F8(ctx, base);
	// 821A6CF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6CFC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6D00: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A6D04: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6D08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A6D0C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6D10: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821A6D14: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6D18: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 821A6D1C: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A6D20: 48003CD9  bl 0x821aa9f8
	ctx.lr = 0x821A6D24;
	sub_821AA9F8(ctx, base);
	// 821A6D24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6D28: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6D2C: 4838E3E0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 821A6D30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A6D34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A6D38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6D3C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 821A6D40: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 821A6D44: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A6D48: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A6D4C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A6D50: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A6D54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821A6D58: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821A6D5C: 38600017  li r3, 0x17
	ctx.r[3].s64 = 23;
	// 821A6D60: 48003C99  bl 0x821aa9f8
	ctx.lr = 0x821A6D64;
	sub_821AA9F8(ctx, base);
	// 821A6D64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A6D68: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821A6D6C: 4838E3A0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6D70 size=356
    let mut pc: u32 = 0x821A6D70;
    'dispatch: loop {
        match pc {
            0x821A6D70 => {
    //   block [0x821A6D70..0x821A6DB8)
	// 821A6D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6D74: 4838E341  bl 0x825350b4
	ctx.lr = 0x821A6D78;
	sub_82535080(ctx, base);
	// 821A6D78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6D7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A6D80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A6D84: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A6D88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821A6D8C: 38EB0E6C  addi r7, r11, 0xe6c
	ctx.r[7].s64 = ctx.r[11].s64 + 3692;
	// 821A6D90: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A6D94: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821A6D98: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A6D9C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 821A6DA0: 481C36F1  bl 0x8236a490
	ctx.lr = 0x821A6DA4;
	sub_8236A490(ctx, base);
	// 821A6DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A6DA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6DAC: 419A000C  beq cr6, 0x821a6db8
	if ctx.cr[6].eq {
	pc = 0x821A6DB8; continue 'dispatch;
	}
	// 821A6DB0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6DB4: 48000008  b 0x821a6dbc
	pc = 0x821A6DBC; continue 'dispatch;
            }
            0x821A6DB8 => {
    //   block [0x821A6DB8..0x821A6DBC)
	// 821A6DB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A6DBC; continue 'dispatch;
            }
            0x821A6DBC => {
    //   block [0x821A6DBC..0x821A6E80)
	// 821A6DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A6DC0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A6DC4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A6DC8: 419A00B8  beq cr6, 0x821a6e80
	if ctx.cr[6].eq {
	pc = 0x821A6E80; continue 'dispatch;
	}
	// 821A6DCC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A6DD0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A6DD4: 396B0E3C  addi r11, r11, 0xe3c
	ctx.r[11].s64 = ctx.r[11].s64 + 3644;
	// 821A6DD8: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A6DDC: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A6DE0: 39086ED8  addi r8, r8, 0x6ed8
	ctx.r[8].s64 = ctx.r[8].s64 + 28376;
	// 821A6DE4: 39296F80  addi r9, r9, 0x6f80
	ctx.r[9].s64 = ctx.r[9].s64 + 28544;
	// 821A6DE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A6DEC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A6DF0: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A6DF4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821A6DF8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A6DFC: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A6E00: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A6E04: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A6E08: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A6E0C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A6E10: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A6E14: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A6E18: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A6E1C: FB9F00F8  std r28, 0xf8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821A6E20: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A6E24: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A6E28: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821A6E2C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A6E30: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A6E34: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821A6E38: 55643032  slwi r4, r11, 6
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A6E3C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A6E40: 4BFFADF1  bl 0x821a1c30
	ctx.lr = 0x821A6E44;
	sub_821A1C30(ctx, base);
	// 821A6E44: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6E48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6E4C: 409A0044  bne cr6, 0x821a6e90
	if !ctx.cr[6].eq {
	pc = 0x821A6E90; continue 'dispatch;
	}
	// 821A6E50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6E54: 419A002C  beq cr6, 0x821a6e80
	if ctx.cr[6].eq {
	pc = 0x821A6E80; continue 'dispatch;
	}
	// 821A6E58: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6E5C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6E60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A6E64: 409A001C  bne cr6, 0x821a6e80
	if !ctx.cr[6].eq {
	pc = 0x821A6E80; continue 'dispatch;
	}
	// 821A6E68: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A6E6C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A6E70: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821A6E74: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A6E78: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A6E7C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A6E80; continue 'dispatch;
            }
            0x821A6E80 => {
    //   block [0x821A6E80..0x821A6E90)
	// 821A6E80: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A6E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6E88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6E8C: 4838E278  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821A6E90 => {
    //   block [0x821A6E90..0x821A6EA8)
	// 821A6E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6E94: 419A0014  beq cr6, 0x821a6ea8
	if ctx.cr[6].eq {
	pc = 0x821A6EA8; continue 'dispatch;
	}
	// 821A6E98: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A6E9C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6EA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A6EA4: 419A0008  beq cr6, 0x821a6eac
	if ctx.cr[6].eq {
	pc = 0x821A6EAC; continue 'dispatch;
	}
	pc = 0x821A6EA8; continue 'dispatch;
            }
            0x821A6EA8 => {
    //   block [0x821A6EA8..0x821A6EAC)
	// 821A6EA8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A6EAC; continue 'dispatch;
            }
            0x821A6EAC => {
    //   block [0x821A6EAC..0x821A6ED4)
	// 821A6EAC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6EB0: 393F00E0  addi r9, r31, 0xe0
	ctx.r[9].s64 = ctx.r[31].s64 + 224;
	// 821A6EB4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 821A6EB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A6EBC: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821A6EC0: FB9F00F0  std r28, 0xf0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u64 ) };
	// 821A6EC4: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 821A6EC8: 913F00D8  stw r9, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 821A6ECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A6ED0: 4838E234  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A6ED8 size=168
    let mut pc: u32 = 0x821A6ED8;
    'dispatch: loop {
        match pc {
            0x821A6ED8 => {
    //   block [0x821A6ED8..0x821A6EFC)
	// 821A6ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6EE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6EE4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6EE8: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A6EEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A6EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A6EF4: 419A0008  beq cr6, 0x821a6efc
	if ctx.cr[6].eq {
	pc = 0x821A6EFC; continue 'dispatch;
	}
	// 821A6EF8: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x821A6EFC; continue 'dispatch;
            }
            0x821A6EFC => {
    //   block [0x821A6EFC..0x821A6F80)
	// 821A6EFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A6F00: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A6F04: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821A6F08: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821A6F0C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A6F10: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A6F14: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A6F18: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A6F1C: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821A6F20: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A6F24: B1630084  sth r11, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 821A6F28: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A6F2C: B1630086  sth r11, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 821A6F30: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A6F34: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A6F38: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A6F3C: 910300A8  stw r8, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821A6F40: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821A6F44: 91230094  stw r9, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A6F48: 90C30098  stw r6, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[6].u32 ) };
	// 821A6F4C: 90A300A0  stw r5, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821A6F50: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A6F54: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A6F58: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A6F5C: 3D6B0504  addis r11, r11, 0x504
	ctx.r[11].s64 = ctx.r[11].s64 + 84148224;
	// 821A6F60: 396B4000  addi r11, r11, 0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + 16384;
	// 821A6F64: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821A6F68: 480000A9  bl 0x821a7010
	ctx.lr = 0x821A6F6C;
	sub_821A7010(ctx, base);
	// 821A6F6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A6F70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A6F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A6F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A6F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6F80 size=68
    let mut pc: u32 = 0x821A6F80;
    'dispatch: loop {
        match pc {
            0x821A6F80 => {
    //   block [0x821A6F80..0x821A6FB0)
	// 821A6F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6F88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6F8C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6F90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A6F94: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A6F98: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A6F9C: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A6FA0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A6FA4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A6FA8: 419A0008  beq cr6, 0x821a6fb0
	if ctx.cr[6].eq {
	pc = 0x821A6FB0; continue 'dispatch;
	}
	// 821A6FAC: 4800012D  bl 0x821a70d8
	ctx.lr = 0x821A6FB0;
	sub_821A70D8(ctx, base);
	pc = 0x821A6FB0; continue 'dispatch;
            }
            0x821A6FB0 => {
    //   block [0x821A6FB0..0x821A6FC4)
	// 821A6FB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A6FB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A6FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A6FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A6FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A6FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A6FC8 size=72
    let mut pc: u32 = 0x821A6FC8;
    'dispatch: loop {
        match pc {
            0x821A6FC8 => {
    //   block [0x821A6FC8..0x821A6FFC)
	// 821A6FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A6FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A6FD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A6FD4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A6FD8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A6FDC: 388B00CC  addi r4, r11, 0xcc
	ctx.r[4].s64 = ctx.r[11].s64 + 204;
	// 821A6FE0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A6FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A6FE8: 419A0014  beq cr6, 0x821a6ffc
	if ctx.cr[6].eq {
	pc = 0x821A6FFC; continue 'dispatch;
	}
	// 821A6FEC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A6FF0: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A6FF4: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A6FF8: 4BFFB089  bl 0x821a2080
	ctx.lr = 0x821A6FFC;
	sub_821A2080(ctx, base);
	pc = 0x821A6FFC; continue 'dispatch;
            }
            0x821A6FFC => {
    //   block [0x821A6FFC..0x821A7010)
	// 821A6FFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A7000: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A7004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A7008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A700C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A7010 size=200
    let mut pc: u32 = 0x821A7010;
    'dispatch: loop {
        match pc {
            0x821A7010 => {
    //   block [0x821A7010..0x821A7058)
	// 821A7010: 816300D8  lwz r11, 0xd8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A7014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A7018: 80E300D4  lwz r7, 0xd4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A701C: 80C300D0  lwz r6, 0xd0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A7020: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821A7024: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7028: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A702C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7030: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7034: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7038: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A703C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 821A7040: 39680018  addi r11, r8, 0x18
	ctx.r[11].s64 = ctx.r[8].s64 + 24;
	// 821A7044: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821A7048: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A704C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A7050: C147BA38  lfs f10, -0x45c8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A7054: C1681FF8  lfs f11, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x821A7058; continue 'dispatch;
            }
            0x821A7058 => {
    //   block [0x821A7058..0x821A7090)
	// 821A7058: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821A705C: 90AB0014  stw r5, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 821A7060: 914B00A4  stw r10, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821A7064: 914B0074  stw r10, 0x74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 821A7068: 914B0044  stw r10, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 821A706C: 409A0024  bne cr6, 0x821a7090
	if !ctx.cr[6].eq {
	pc = 0x821A7090; continue 'dispatch;
	}
	// 821A7070: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A7074: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A7078: D14B0038  stfs f10, 0x38(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821A707C: D16B003C  stfs f11, 0x3c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821A7080: D16B0068  stfs f11, 0x68(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821A7084: D14B006C  stfs f10, 0x6c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821A7088: D14B0098  stfs f10, 0x98(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A708C: D14B009C  stfs f10, 0x9c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x821A7090; continue 'dispatch;
            }
            0x821A7090 => {
    //   block [0x821A7090..0x821A70D8)
	// 821A7090: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821A7094: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A7098: D1ABFFFC  stfs f13, -4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821A709C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A70A0: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821A70A4: D1AB002C  stfs f13, 0x2c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821A70A8: D18B0030  stfs f12, 0x30(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821A70AC: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A70B0: D1AB005C  stfs f13, 0x5c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821A70B4: D18B0060  stfs f12, 0x60(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821A70B8: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A70BC: D1AB008C  stfs f13, 0x8c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A70C0: D18B0090  stfs f12, 0x90(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A70C4: 810300D0  lwz r8, 0xd0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A70C8: 396B00C0  addi r11, r11, 0xc0
	ctx.r[11].s64 = ctx.r[11].s64 + 192;
	// 821A70CC: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821A70D0: 4198FF88  blt cr6, 0x821a7058
	if ctx.cr[6].lt {
	pc = 0x821A7058; continue 'dispatch;
	}
	// 821A70D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A70D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A70D8 size=576
    let mut pc: u32 = 0x821A70D8;
    'dispatch: loop {
        match pc {
            0x821A70D8 => {
    //   block [0x821A70D8..0x821A7110)
	// 821A70D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A70DC: 4838DFD1  bl 0x825350ac
	ctx.lr = 0x821A70E0;
	sub_82535080(ctx, base);
	// 821A70E0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821A70E4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A70E8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821A70EC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A70F0: 817A00F4  lwz r11, 0xf4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(244 as u32) ) } as u64;
	// 821A70F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A70F8: 419A0018  beq cr6, 0x821a7110
	if ctx.cr[6].eq {
	pc = 0x821A7110; continue 'dispatch;
	}
	// 821A70FC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7100: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821A7104: 813A00F0  lwz r9, 0xf0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(240 as u32) ) } as u64;
	// 821A7108: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A710C: 419A0008  beq cr6, 0x821a7114
	if ctx.cr[6].eq {
	pc = 0x821A7114; continue 'dispatch;
	}
	pc = 0x821A7110; continue 'dispatch;
            }
            0x821A7110 => {
    //   block [0x821A7110..0x821A7114)
	// 821A7110: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	pc = 0x821A7114; continue 'dispatch;
            }
            0x821A7114 => {
    //   block [0x821A7114..0x821A712C)
	// 821A7114: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A7118: 83FA00CC  lwz r31, 0xcc(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A711C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7120: 409A000C  bne cr6, 0x821a712c
	if !ctx.cr[6].eq {
	pc = 0x821A712C; continue 'dispatch;
	}
	// 821A7124: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821A7128: 4800000C  b 0x821a7134
	pc = 0x821A7134; continue 'dispatch;
            }
            0x821A712C => {
    //   block [0x821A712C..0x821A7134)
	// 821A712C: 815C008C  lwz r10, 0x8c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7130: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A7134; continue 'dispatch;
            }
            0x821A7134 => {
    //   block [0x821A7134..0x821A714C)
	// 821A7134: 83BA00D4  lwz r29, 0xd4(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A7138: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 821A713C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A7140: 419A01C0  beq cr6, 0x821a7300
	if ctx.cr[6].eq {
	pc = 0x821A7300; continue 'dispatch;
	}
	// 821A7144: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A7148: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821A714C; continue 'dispatch;
            }
            0x821A714C => {
    //   block [0x821A714C..0x821A7188)
	// 821A714C: A17E0010  lhz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A7150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7154: 419A0040  beq cr6, 0x821a7194
	if ctx.cr[6].eq {
	pc = 0x821A7194; continue 'dispatch;
	}
	// 821A7158: B33E0010  sth r25, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[25].u16 ) };
	// 821A715C: A17D000C  lhz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A7160: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A7164: 40990024  ble cr6, 0x821a7188
	if !ctx.cr[6].gt {
	pc = 0x821A7188; continue 'dispatch;
	}
	// 821A7168: 481BFFD1  bl 0x82367138
	ctx.lr = 0x821A716C;
	sub_82367138(ctx, base);
	// 821A716C: A17D000C  lhz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A7170: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821A7174: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A7178: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821A717C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821A7180: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A7184: 48000158  b 0x821a72dc
	pc = 0x821A72DC; continue 'dispatch;
            }
            0x821A7188 => {
    //   block [0x821A7188..0x821A7194)
	// 821A7188: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821A718C: B17E0198  sth r11, 0x198(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821A7190: 4800014C  b 0x821a72dc
	pc = 0x821A72DC; continue 'dispatch;
            }
            0x821A7194 => {
    //   block [0x821A7194..0x821A71D0)
	// 821A7194: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7198: 391E003C  addi r8, r30, 0x3c
	ctx.r[8].s64 = ctx.r[30].s64 + 60;
	// 821A719C: 80FC0098  lwz r7, 0x98(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A71A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A71A4: 419A00C4  beq cr6, 0x821a7268
	if ctx.cr[6].eq {
	pc = 0x821A7268; continue 'dispatch;
	}
	// 821A71A8: 8167005C  lwz r11, 0x5c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A71AC: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A71B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A71B4: 419A001C  beq cr6, 0x821a71d0
	if ctx.cr[6].eq {
	pc = 0x821A71D0; continue 'dispatch;
	}
	// 821A71B8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821A71BC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A71C0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A71C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A71C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A71CC: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A71D0; continue 'dispatch;
            }
            0x821A71D0 => {
    //   block [0x821A71D0..0x821A71DC)
	// 821A71D0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A71D4: 40980008  bge cr6, 0x821a71dc
	if !ctx.cr[6].lt {
	pc = 0x821A71DC; continue 'dispatch;
	}
	// 821A71D8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x821A71DC; continue 'dispatch;
            }
            0x821A71DC => {
    //   block [0x821A71DC..0x821A7268)
	// 821A71DC: A17E0198  lhz r11, 0x198(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(408 as u32) ) } as u64;
	// 821A71E0: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821A71E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A71E8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A71EC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A71F0: A0CB0012  lhz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A71F4: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A71F8: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A71FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821A7200: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A7204: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A7208: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A720C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A7210: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7214: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 821A7218: A1610066  lhz r11, 0x66(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(102 as u32) ) } as u64;
	// 821A721C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A7220: 556B2AF4  rlwinm r11, r11, 5, 0xb, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821A7224: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A7228: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A722C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A7230: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7234: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A7238: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A723C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821A7240: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7244: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821A7248: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A724C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A7250: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7254: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A7258: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A725C: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A7260: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7264: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	pc = 0x821A7268; continue 'dispatch;
            }
            0x821A7268 => {
    //   block [0x821A7268..0x821A7290)
	// 821A7268: 8167006C  lwz r11, 0x6c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A726C: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7274: 419A001C  beq cr6, 0x821a7290
	if ctx.cr[6].eq {
	pc = 0x821A7290; continue 'dispatch;
	}
	// 821A7278: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821A727C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A7280: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A7284: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7288: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A728C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A7290; continue 'dispatch;
            }
            0x821A7290 => {
    //   block [0x821A7290..0x821A72DC)
	// 821A7290: 815A00D8  lwz r10, 0xd8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A7294: 397E0060  addi r11, r30, 0x60
	ctx.r[11].s64 = ctx.r[30].s64 + 96;
	// 821A7298: 38DE0180  addi r6, r30, 0x180
	ctx.r[6].s64 = ctx.r[30].s64 + 384;
	// 821A729C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A72A0: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A72A4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A72A8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A72AC: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821A72B0: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A72B4: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A72B8: 815C0094  lwz r10, 0x94(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A72BC: 390A0003  addi r8, r10, 3
	ctx.r[8].s64 = ctx.r[10].s64 + 3;
	// 821A72C0: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A72C4: 550A2636  rlwinm r10, r8, 4, 0x18, 0x1b
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x0FFFFFFFu64;
	// 821A72C8: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A72CC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A72D0: 48000049  bl 0x821a7318
	ctx.lr = 0x821A72D4;
	sub_821A7318(ctx, base);
	// 821A72D4: 3BFF00C0  addi r31, r31, 0xc0
	ctx.r[31].s64 = ctx.r[31].s64 + 192;
	// 821A72D8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x821A72DC; continue 'dispatch;
            }
            0x821A72DC => {
    //   block [0x821A72DC..0x821A72F0)
	// 821A72DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A72E0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A72E4: 409A000C  bne cr6, 0x821a72f0
	if !ctx.cr[6].eq {
	pc = 0x821A72F0; continue 'dispatch;
	}
	// 821A72E8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821A72EC: 4800000C  b 0x821a72f8
	pc = 0x821A72F8; continue 'dispatch;
            }
            0x821A72F0 => {
    //   block [0x821A72F0..0x821A72F8)
	// 821A72F0: 815C008C  lwz r10, 0x8c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A72F4: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A72F8; continue 'dispatch;
            }
            0x821A72F8 => {
    //   block [0x821A72F8..0x821A7300)
	// 821A72F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A72FC: 409AFE50  bne cr6, 0x821a714c
	if !ctx.cr[6].eq {
	pc = 0x821A714C; continue 'dispatch;
	}
	pc = 0x821A7300; continue 'dispatch;
            }
            0x821A7300 => {
    //   block [0x821A7300..0x821A7318)
	// 821A7300: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7304: 937A00C8  stw r27, 0xc8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 821A7308: 917A00C4  stw r11, 0xc4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A730C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A7310: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821A7314: 4838DDE8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A7318 size=516
    let mut pc: u32 = 0x821A7318;
    'dispatch: loop {
        match pc {
            0x821A7318 => {
    //   block [0x821A7318..0x821A751C)
	// 821A7318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A731C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A7320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A7324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A7328: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A7548 size=340
    let mut pc: u32 = 0x821A7548;
    'dispatch: loop {
        match pc {
            0x821A7548 => {
    //   block [0x821A7548..0x821A7590)
	// 821A7548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A754C: 4838DB69  bl 0x825350b4
	ctx.lr = 0x821A7550;
	sub_82535080(ctx, base);
	// 821A7550: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A7554: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A7558: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821A755C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A7560: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A7564: 38EB0E74  addi r7, r11, 0xe74
	ctx.r[7].s64 = ctx.r[11].s64 + 3700;
	// 821A7568: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A756C: 38A00389  li r5, 0x389
	ctx.r[5].s64 = 905;
	// 821A7570: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A7574: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 821A7578: 481C2F19  bl 0x8236a490
	ctx.lr = 0x821A757C;
	sub_8236A490(ctx, base);
	// 821A757C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A7580: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7584: 419A000C  beq cr6, 0x821a7590
	if ctx.cr[6].eq {
	pc = 0x821A7590; continue 'dispatch;
	}
	// 821A7588: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A758C: 48000008  b 0x821a7594
	pc = 0x821A7594; continue 'dispatch;
            }
            0x821A7590 => {
    //   block [0x821A7590..0x821A7594)
	// 821A7590: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A7594; continue 'dispatch;
            }
            0x821A7594 => {
    //   block [0x821A7594..0x821A7650)
	// 821A7594: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7598: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A759C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A75A0: 419A00B0  beq cr6, 0x821a7650
	if ctx.cr[6].eq {
	pc = 0x821A7650; continue 'dispatch;
	}
	// 821A75A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A75A8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821A75AC: 396B0E14  addi r11, r11, 0xe14
	ctx.r[11].s64 = ctx.r[11].s64 + 3604;
	// 821A75B0: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 821A75B4: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A75B8: 390876A0  addi r8, r8, 0x76a0
	ctx.r[8].s64 = ctx.r[8].s64 + 30368;
	// 821A75BC: 392977B0  addi r9, r9, 0x77b0
	ctx.r[9].s64 = ctx.r[9].s64 + 30640;
	// 821A75C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A75C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A75C8: 93BF0080  stw r29, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 821A75CC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821A75D0: B3BF0084  sth r29, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u16 ) };
	// 821A75D4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A75D8: B3BF0086  sth r29, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[29].u16 ) };
	// 821A75DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A75E0: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821A75E4: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821A75E8: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A75EC: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821A75F0: 394A6FC8  addi r10, r10, 0x6fc8
	ctx.r[10].s64 = ctx.r[10].s64 + 28616;
	// 821A75F4: FBBF00E8  std r29, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u64 ) };
	// 821A75F8: 1C9B0660  mulli r4, r27, 0x660
	ctx.r[4].s32 = ((ctx.r[27].s32 as i64 * 1632 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 821A75FC: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821A7600: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A7604: 9B9F001C  stb r28, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 821A7608: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A760C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A7610: 4BFFA621  bl 0x821a1c30
	ctx.lr = 0x821A7614;
	sub_821A1C30(ctx, base);
	// 821A7614: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A761C: 409A0044  bne cr6, 0x821a7660
	if !ctx.cr[6].eq {
	pc = 0x821A7660; continue 'dispatch;
	}
	// 821A7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7624: 419A002C  beq cr6, 0x821a7650
	if ctx.cr[6].eq {
	pc = 0x821A7650; continue 'dispatch;
	}
	// 821A7628: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A762C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7630: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7634: 409A001C  bne cr6, 0x821a7650
	if !ctx.cr[6].eq {
	pc = 0x821A7650; continue 'dispatch;
	}
	// 821A7638: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A763C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7640: 9B8B0025  stb r28, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[28].u8 ) };
	// 821A7644: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A7648: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A764C: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A7650; continue 'dispatch;
            }
            0x821A7650 => {
    //   block [0x821A7650..0x821A7660)
	// 821A7650: FBBE0000  std r29, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 821A7654: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A7658: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A765C: 4838DAA8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821A7660 => {
    //   block [0x821A7660..0x821A7678)
	// 821A7660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7664: 419A0014  beq cr6, 0x821a7678
	if ctx.cr[6].eq {
	pc = 0x821A7678; continue 'dispatch;
	}
	// 821A7668: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A766C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7670: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7674: 419A0008  beq cr6, 0x821a767c
	if ctx.cr[6].eq {
	pc = 0x821A767C; continue 'dispatch;
	}
	pc = 0x821A7678; continue 'dispatch;
            }
            0x821A7678 => {
    //   block [0x821A7678..0x821A767C)
	// 821A7678: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821A767C; continue 'dispatch;
            }
            0x821A767C => {
    //   block [0x821A767C..0x821A769C)
	// 821A767C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A7684: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 821A7688: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 821A768C: FBBF00E0  std r29, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 821A7690: 937F00D0  stw r27, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 821A7694: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A7698: 4838DA6C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A76A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A76A0 size=272
    let mut pc: u32 = 0x821A76A0;
    'dispatch: loop {
        match pc {
            0x821A76A0 => {
    //   block [0x821A76A0..0x821A76B8)
	// 821A76A0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A76A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A76A8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A76AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A76B0: 419A0008  beq cr6, 0x821a76b8
	if ctx.cr[6].eq {
	pc = 0x821A76B8; continue 'dispatch;
	}
	// 821A76B4: 910B0040  stw r8, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[8].u32 ) };
	pc = 0x821A76B8; continue 'dispatch;
            }
            0x821A76B8 => {
    //   block [0x821A76B8..0x821A7750)
	// 821A76B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A76BC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A76C0: 3CC04020  lis r6, 0x4020
	ctx.r[6].s64 = 1075838976;
	// 821A76C4: 38A00120  li r5, 0x120
	ctx.r[5].s64 = 288;
	// 821A76C8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A76CC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A76D0: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A76D4: 992B001E  stb r9, 0x1e(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A76D8: 39200022  li r9, 0x22
	ctx.r[9].s64 = 34;
	// 821A76DC: 394A8E40  addi r10, r10, -0x71c0
	ctx.r[10].s64 = ctx.r[10].s64 + -29120;
	// 821A76E0: B10B0084  sth r8, 0x84(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[8].u16 ) };
	// 821A76E4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821A76E8: B10B0086  sth r8, 0x86(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(134 as u32), ctx.r[8].u16 ) };
	// 821A76EC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821A76F0: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A76F4: D00B00B0  stfs f0, 0xb0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A76F8: D00B00B4  stfs f0, 0xb4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A76FC: 90CB00A8  stw r6, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[6].u32 ) };
	// 821A7700: 90AB00A4  stw r5, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 821A7704: 912B0094  stw r9, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821A7708: 908B0098  stw r4, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 821A770C: 906B00A0  stw r3, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821A7710: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A7714: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7718: D00B00B8  stfs f0, 0xb8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821A771C: 3D4A0504  addis r10, r10, 0x504
	ctx.r[10].s64 = ctx.r[10].s64 + 84148224;
	// 821A7720: 394A4000  addi r10, r10, 0x4000
	ctx.r[10].s64 = ctx.r[10].s64 + 16384;
	// 821A7724: 914B0090  stw r10, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821A7728: 812B00D8  lwz r9, 0xd8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A772C: 80CB00D0  lwz r6, 0xd0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A7730: 814B00CC  lwz r10, 0xcc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7734: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A7738: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A773C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7740: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A7744: 40990064  ble cr6, 0x821a77a8
	if !ctx.cr[6].gt {
	pc = 0x821A77A8; continue 'dispatch;
	}
	// 821A7748: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A774C: C169BA38  lfs f11, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x821A7750; continue 'dispatch;
            }
            0x821A7750 => {
    //   block [0x821A7750..0x821A7754)
	// 821A7750: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	pc = 0x821A7754; continue 'dispatch;
            }
            0x821A7754 => {
    //   block [0x821A7754..0x821A77A8)
	// 821A7754: 7D260034  cntlzw r6, r9
	ctx.r[6].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821A7758: D16A000C  stfs f11, 0xc(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A775C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A7760: 54C6DFFE  rlwinm r6, r6, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821A7764: 2F090011  cmpwi cr6, r9, 0x11
	ctx.cr[6].compare_i32(ctx.r[9].s32, 17, &mut ctx.xer);
	// 821A7768: 90CA002C  stw r6, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 821A776C: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A7770: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A7774: D18A0018  stfs f12, 0x18(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A7778: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 821A777C: D16A000C  stfs f11, 0xc(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A7780: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 821A7784: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A7788: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A778C: D18A0018  stfs f12, 0x18(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A7790: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 821A7794: 4198FFC0  blt cr6, 0x821a7754
	if ctx.cr[6].lt {
	pc = 0x821A7754; continue 'dispatch;
	}
	// 821A7798: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A779C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821A77A0: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821A77A4: 4198FFAC  blt cr6, 0x821a7750
	if ctx.cr[6].lt {
	pc = 0x821A7750; continue 'dispatch;
	}
	pc = 0x821A77A8; continue 'dispatch;
            }
            0x821A77A8 => {
    //   block [0x821A77A8..0x821A77B0)
	// 821A77A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A77AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A77B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A77B0 size=68
    let mut pc: u32 = 0x821A77B0;
    'dispatch: loop {
        match pc {
            0x821A77B0 => {
    //   block [0x821A77B0..0x821A77E0)
	// 821A77B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A77B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A77B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A77BC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A77C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A77C4: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A77C8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A77CC: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A77D0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A77D4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A77D8: 419A0008  beq cr6, 0x821a77e0
	if ctx.cr[6].eq {
	pc = 0x821A77E0; continue 'dispatch;
	}
	// 821A77DC: 4800001D  bl 0x821a77f8
	ctx.lr = 0x821A77E0;
	sub_821A77F8(ctx, base);
	pc = 0x821A77E0; continue 'dispatch;
            }
            0x821A77E0 => {
    //   block [0x821A77E0..0x821A77F4)
	// 821A77E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A77E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821A77E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A77EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A77F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A77F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A77F8 size=908
    let mut pc: u32 = 0x821A77F8;
    'dispatch: loop {
        match pc {
            0x821A77F8 => {
    //   block [0x821A77F8..0x821A7830)
	// 821A77F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A77FC: 4838D8A5  bl 0x825350a0
	ctx.lr = 0x821A7800;
	sub_82535080(ctx, base);
	// 821A7800: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821A7804: 4838E7C5  bl 0x82535fc8
	ctx.lr = 0x821A7808;
	sub_82535FB0(ctx, base);
	// 821A7808: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A780C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A7810: 817900E4  lwz r11, 0xe4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(228 as u32) ) } as u64;
	// 821A7814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7818: 419A0018  beq cr6, 0x821a7830
	if ctx.cr[6].eq {
	pc = 0x821A7830; continue 'dispatch;
	}
	// 821A781C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7820: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A7824: 813900E0  lwz r9, 0xe0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(224 as u32) ) } as u64;
	// 821A7828: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A782C: 419A0008  beq cr6, 0x821a7834
	if ctx.cr[6].eq {
	pc = 0x821A7834; continue 'dispatch;
	}
	pc = 0x821A7830; continue 'dispatch;
            }
            0x821A7830 => {
    //   block [0x821A7830..0x821A7834)
	// 821A7830: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x821A7834; continue 'dispatch;
            }
            0x821A7834 => {
    //   block [0x821A7834..0x821A784C)
	// 821A7834: 817A0084  lwz r11, 0x84(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A7838: 83F900CC  lwz r31, 0xcc(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A783C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7840: 409A000C  bne cr6, 0x821a784c
	if !ctx.cr[6].eq {
	pc = 0x821A784C; continue 'dispatch;
	}
	// 821A7844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A7848: 4800000C  b 0x821a7854
	pc = 0x821A7854; continue 'dispatch;
            }
            0x821A784C => {
    //   block [0x821A784C..0x821A7854)
	// 821A784C: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7850: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A7854; continue 'dispatch;
            }
            0x821A7854 => {
    //   block [0x821A7854..0x821A789C)
	// 821A7854: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A7858: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821A785C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7860: 419A0308  beq cr6, 0x821a7b68
	if ctx.cr[6].eq {
	pc = 0x821A7B68; continue 'dispatch;
	}
	// 821A7864: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A7868: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821A786C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A7870: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A7874: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A7878: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A787C: 3B0B20B0  addi r24, r11, 0x20b0
	ctx.r[24].s64 = ctx.r[11].s64 + 8368;
	// 821A7880: C3E6BA38  lfs f31, -0x45c8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A7884: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A7888: C2872490  lfs f20, 0x2490(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9360 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A788C: C2C82048  lfs f22, 0x2048(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8264 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A7890: C3C9BFFC  lfs f30, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A7894: 3AEBD030  addi r23, r11, -0x2fd0
	ctx.r[23].s64 = ctx.r[11].s64 + -12240;
	// 821A7898: C2AA1FF8  lfs f21, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	pc = 0x821A789C; continue 'dispatch;
            }
            0x821A789C => {
    //   block [0x821A789C..0x821A78C0)
	// 821A789C: 817A0098  lwz r11, 0x98(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A78A0: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 821A78A4: 393B0024  addi r9, r27, 0x24
	ctx.r[9].s64 = ctx.r[27].s64 + 36;
	// 821A78A8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 821A78AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A78B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A78B4: 409A000C  bne cr6, 0x821a78c0
	if !ctx.cr[6].eq {
	pc = 0x821A78C0; continue 'dispatch;
	}
	// 821A78B8: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A78BC: 48000020  b 0x821a78dc
	pc = 0x821A78DC; continue 'dispatch;
            }
            0x821A78C0 => {
    //   block [0x821A78C0..0x821A78DC)
	// 821A78C0: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 821A78C4: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A78C8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A78CC: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821A78D0: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A78D4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A78D8: 7DA8542E  lfsx f13, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x821A78DC; continue 'dispatch;
            }
            0x821A78DC => {
    //   block [0x821A78DC..0x821A78F8)
	// 821A78DC: 38EB0020  addi r7, r11, 0x20
	ctx.r[7].s64 = ctx.r[11].s64 + 32;
	// 821A78E0: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	// 821A78E4: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A78E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A78EC: 409A000C  bne cr6, 0x821a78f8
	if !ctx.cr[6].eq {
	pc = 0x821A78F8; continue 'dispatch;
	}
	// 821A78F0: C02A0000  lfs f1, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A78F4: 48000020  b 0x821a7914
	pc = 0x821A7914; continue 'dispatch;
            }
            0x821A78F8 => {
    //   block [0x821A78F8..0x821A7914)
	// 821A78F8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821A78FC: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7900: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A7904: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 821A7908: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A790C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A7910: 7C295C2E  lfsx f1, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x821A7914; continue 'dispatch;
            }
            0x821A7914 => {
    //   block [0x821A7914..0x821A7950)
	// 821A7914: 817900D4  lwz r11, 0xd4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A7918: 390A0008  addi r8, r10, 8
	ctx.r[8].s64 = ctx.r[10].s64 + 8;
	// 821A791C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A7924: 419A008C  beq cr6, 0x821a79b0
	if ctx.cr[6].eq {
	pc = 0x821A79B0; continue 'dispatch;
	}
	// 821A7928: 8147001C  lwz r10, 0x1c(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 821A792C: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A7934: 419A001C  beq cr6, 0x821a7950
	if ctx.cr[6].eq {
	pc = 0x821A7950; continue 'dispatch;
	}
	// 821A7938: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 821A793C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A7940: 7C0037AE  stfiwx f0, 0, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32, tmp.u32) };
	// 821A7944: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A7948: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821A794C: 7C06542E  lfsx f0, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A7950; continue 'dispatch;
            }
            0x821A7950 => {
    //   block [0x821A7950..0x821A795C)
	// 821A7950: FF00A800  fcmpu cr6, f0, f21
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[21].f64);
	// 821A7954: 40980008  bge cr6, 0x821a795c
	if !ctx.cr[6].lt {
	pc = 0x821A795C; continue 'dispatch;
	}
	// 821A7958: FC00A890  fmr f0, f21
	ctx.f[0].f64 = ctx.f[21].f64;
	pc = 0x821A795C; continue 'dispatch;
            }
            0x821A795C => {
    //   block [0x821A795C..0x821A79B0)
	// 821A795C: A0CB0012  lhz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A7960: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821A7964: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A7968: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821A796C: C9810068  lfd f12, 0x68(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A7970: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821A7974: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821A7978: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A797C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7980: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 821A7984: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 821A7988: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A798C: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7990: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A7994: C36B0000  lfs f27, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A7998: C38B0004  lfs f28, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A799C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A79A0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A79A4: EF20D828  fsubs f25, f0, f27
	ctx.f[25].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 821A79A8: EF4CE028  fsubs f26, f12, f28
	ctx.f[26].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 821A79AC: 48000014  b 0x821a79c0
	pc = 0x821A79C0; continue 'dispatch;
            }
            0x821A79B0 => {
    //   block [0x821A79B0..0x821A79C0)
	// 821A79B0: FF80A890  fmr f28, f21
	ctx.f[28].f64 = ctx.f[21].f64;
	// 821A79B4: FF60A890  fmr f27, f21
	ctx.f[27].f64 = ctx.f[21].f64;
	// 821A79B8: FF40F890  fmr f26, f31
	ctx.f[26].f64 = ctx.f[31].f64;
	// 821A79BC: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	pc = 0x821A79C0; continue 'dispatch;
            }
            0x821A79C0 => {
    //   block [0x821A79C0..0x821A79E8)
	// 821A79C0: 8167002C  lwz r11, 0x2c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) } as u64;
	// 821A79C4: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A79C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A79CC: 419A001C  beq cr6, 0x821a79e8
	if ctx.cr[6].eq {
	pc = 0x821A79E8; continue 'dispatch;
	}
	// 821A79D0: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 821A79D4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A79D8: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821A79DC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A79E0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A79E4: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A79E8; continue 'dispatch;
            }
            0x821A79E8 => {
    //   block [0x821A79E8..0x821A7A34)
	// 821A79E8: 817A0094  lwz r11, 0x94(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A79EC: C19B0184  lfs f12, 0x184(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A79F0: 815900D8  lwz r10, 0xd8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A79F4: EC4C0372  fmuls f2, f12, f13
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A79F8: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821A79FC: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821A7A00: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7A04: 38FB0160  addi r7, r27, 0x160
	ctx.r[7].s64 = ctx.r[27].s64 + 352;
	// 821A7A08: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821A7A0C: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A10: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821A7A14: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A7A18: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821A7A1C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821A7A20: 4BFF51A1  bl 0x8219cbc0
	ctx.lr = 0x821A7A24;
	sub_8219CBC0(ctx, base);
	// 821A7A24: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 821A7A28: EF19DFBA  fmadds f24, f25, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = (((ctx.f[25].f64 * ctx.f[30].f64 + ctx.f[27].f64) as f32) as f64);
	// 821A7A2C: EEFAE7BA  fmadds f23, f26, f30, f28
	ctx.f[23].f64 = (((ctx.f[26].f64 * ctx.f[30].f64 + ctx.f[28].f64) as f32) as f64);
	// 821A7A30: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	pc = 0x821A7A34; continue 'dispatch;
            }
            0x821A7A34 => {
    //   block [0x821A7A34..0x821A7A3C)
	// 821A7A34: 409A0008  bne cr6, 0x821a7a3c
	if !ctx.cr[6].eq {
	pc = 0x821A7A3C; continue 'dispatch;
	}
	// 821A7A38: 3B9CFF00  addi r28, r28, -0x100
	ctx.r[28].s64 = ctx.r[28].s64 + -256;
	pc = 0x821A7A3C; continue 'dispatch;
            }
            0x821A7A3C => {
    //   block [0x821A7A3C..0x821A7AAC)
	// 821A7A3C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A40: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A7A44: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A48: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A7A4C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A50: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A7A54: D31F0020  stfs f24, 0x20(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A7A58: D2FF0024  stfs f23, 0x24(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A7A5C: D3BF001C  stfs f29, 0x1c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A7A60: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821A7A64: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7A68: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7A6C: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A7A70: C17C0008  lfs f11, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A7A74: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A7A78: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821A7A7C: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A7A80: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A7A84: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 821A7A88: 41980064  blt cr6, 0x821a7aec
	if ctx.cr[6].lt {
	pc = 0x821A7AEC; continue 'dispatch;
	}
	// 821A7A8C: EC00B028  fsubs f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 821A7A90: FF00A800  fcmpu cr6, f0, f21
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[21].f64);
	// 821A7A94: 4098003C  bge cr6, 0x821a7ad0
	if !ctx.cr[6].lt {
	pc = 0x821A7AD0; continue 'dispatch;
	}
	// 821A7A98: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821A7A9C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A7AA0: 4098000C  bge cr6, 0x821a7aac
	if !ctx.cr[6].lt {
	pc = 0x821A7AAC; continue 'dispatch;
	}
	// 821A7AA4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A7AA8: 48000040  b 0x821a7ae8
	pc = 0x821A7AE8; continue 'dispatch;
            }
            0x821A7AAC => {
    //   block [0x821A7AAC..0x821A7AD0)
	// 821A7AAC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7AB0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A7AB4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A7AB8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A7ABC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A7AC0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A7AC4: 41980024  blt cr6, 0x821a7ae8
	if ctx.cr[6].lt {
	pc = 0x821A7AE8; continue 'dispatch;
	}
	// 821A7AC8: FC00A890  fmr f0, f21
	ctx.f[0].f64 = ctx.f[21].f64;
	// 821A7ACC: 4800001C  b 0x821a7ae8
	pc = 0x821A7AE8; continue 'dispatch;
            }
            0x821A7AD0 => {
    //   block [0x821A7AD0..0x821A7AE8)
	// 821A7AD0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A7AD4: 41980014  blt cr6, 0x821a7ae8
	if ctx.cr[6].lt {
	pc = 0x821A7AE8; continue 'dispatch;
	}
	// 821A7AD8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821A7ADC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A7AE0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A7AE4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821A7AE8; continue 'dispatch;
            }
            0x821A7AE8 => {
    //   block [0x821A7AE8..0x821A7AEC)
	// 821A7AE8: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	pc = 0x821A7AEC; continue 'dispatch;
            }
            0x821A7AEC => {
    //   block [0x821A7AEC..0x821A7B54)
	// 821A7AEC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 821A7AF0: EC200532  fmuls f1, f0, f20
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821A7AF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821A7AF8: 4BF6A2D9  bl 0x82111dd0
	ctx.lr = 0x821A7AFC;
	sub_82111DD0(ctx, base);
	// 821A7AFC: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A7B00: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A7B04: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821A7B08: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821A7B0C: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821A7B10: D3BF001C  stfs f29, 0x1c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821A7B14: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 821A7B18: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821A7B1C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821A7B20: EDAD05B2  fmuls f13, f13, f22
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[22].f64) as f32) as f64);
	// 821A7B24: EC00DE7A  fmadds f0, f0, f25, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64);
	// 821A7B28: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A7B2C: EC0DE6BA  fmadds f0, f13, f26, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[26].f64 + ctx.f[28].f64) as f32) as f64);
	// 821A7B30: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A7B34: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821A7B38: 4098FEFC  bge cr6, 0x821a7a34
	if !ctx.cr[6].lt {
	pc = 0x821A7A34; continue 'dispatch;
	}
	// 821A7B3C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7B40: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 821A7B44: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7B48: 409A000C  bne cr6, 0x821a7b54
	if !ctx.cr[6].eq {
	pc = 0x821A7B54; continue 'dispatch;
	}
	// 821A7B4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A7B50: 4800000C  b 0x821a7b5c
	pc = 0x821A7B5C; continue 'dispatch;
            }
            0x821A7B54 => {
    //   block [0x821A7B54..0x821A7B5C)
	// 821A7B54: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7B58: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A7B5C; continue 'dispatch;
            }
            0x821A7B5C => {
    //   block [0x821A7B5C..0x821A7B68)
	// 821A7B5C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821A7B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7B64: 409AFD38  bne cr6, 0x821a789c
	if !ctx.cr[6].eq {
	pc = 0x821A789C; continue 'dispatch;
	}
	pc = 0x821A7B68; continue 'dispatch;
            }
            0x821A7B68 => {
    //   block [0x821A7B68..0x821A7B84)
	// 821A7B68: 1D760022  mulli r11, r22, 0x22
	ctx.r[11].s32 = ((ctx.r[22].s32 as i64 * 34 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821A7B6C: 92D900C8  stw r22, 0xc8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(200 as u32), ctx.r[22].u32 ) };
	// 821A7B70: 917900C4  stw r11, 0xc4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821A7B74: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 821A7B78: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821A7B7C: 4838E499  bl 0x82536014
	ctx.lr = 0x821A7B80;
	sub_82535FFC(ctx, base);
	// 821A7B80: 4838D570  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A7B88 size=460
    let mut pc: u32 = 0x821A7B88;
    'dispatch: loop {
        match pc {
            0x821A7B88 => {
    //   block [0x821A7B88..0x821A7BC0)
	// 821A7B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A7B8C: 4838D51D  bl 0x825350a8
	ctx.lr = 0x821A7B90;
	sub_82535080(ctx, base);
	// 821A7B90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A7B94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821A7B98: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821A7B9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A7BA0: 570B0294  rlwinm r11, r24, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7BA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A7BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7BAC: FBDB0000  std r30, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A7BB0: 419A0010  beq cr6, 0x821a7bc0
	if ctx.cr[6].eq {
	pc = 0x821A7BC0; continue 'dispatch;
	}
	// 821A7BB4: 3D60821B  lis r11, -0x7de5
	ctx.r[11].s64 = -2112159744;
	// 821A7BB8: 3B2B83B0  addi r25, r11, -0x7c50
	ctx.r[25].s64 = ctx.r[11].s64 + -31824;
	// 821A7BBC: 4800000C  b 0x821a7bc8
	pc = 0x821A7BC8; continue 'dispatch;
            }
            0x821A7BC0 => {
    //   block [0x821A7BC0..0x821A7BC8)
	// 821A7BC0: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821A7BC4: 3B2B7D78  addi r25, r11, 0x7d78
	ctx.r[25].s64 = ctx.r[11].s64 + 32120;
	pc = 0x821A7BC8; continue 'dispatch;
            }
            0x821A7BC8 => {
    //   block [0x821A7BC8..0x821A7BF4)
	// 821A7BC8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A7BCC: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 821A7BD0: 38EB0E7C  addi r7, r11, 0xe7c
	ctx.r[7].s64 = ctx.r[11].s64 + 3708;
	// 821A7BD4: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821A7BD8: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821A7BDC: 481C28B5  bl 0x8236a490
	ctx.lr = 0x821A7BE0;
	sub_8236A490(ctx, base);
	// 821A7BE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A7BE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7BE8: 419A000C  beq cr6, 0x821a7bf4
	if ctx.cr[6].eq {
	pc = 0x821A7BF4; continue 'dispatch;
	}
	// 821A7BEC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7BF0: 48000008  b 0x821a7bf8
	pc = 0x821A7BF8; continue 'dispatch;
            }
            0x821A7BF4 => {
    //   block [0x821A7BF4..0x821A7BF8)
	// 821A7BF4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A7BF8; continue 'dispatch;
            }
            0x821A7BF8 => {
    //   block [0x821A7BF8..0x821A7CA4)
	// 821A7BF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7BFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A7C00: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A7C04: 419A00A0  beq cr6, 0x821a7ca4
	if ctx.cr[6].eq {
	pc = 0x821A7CA4; continue 'dispatch;
	}
	// 821A7C08: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A7C0C: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821A7C10: 396B0F7C  addi r11, r11, 0xf7c
	ctx.r[11].s64 = ctx.r[11].s64 + 3964;
	// 821A7C14: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821A7C18: 39297D58  addi r9, r9, 0x7d58
	ctx.r[9].s64 = ctx.r[9].s64 + 32088;
	// 821A7C1C: 394A8B68  addi r10, r10, -0x7498
	ctx.r[10].s64 = ctx.r[10].s64 + -29848;
	// 821A7C20: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821A7C24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A7C28: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A7C2C: 3BBF008C  addi r29, r31, 0x8c
	ctx.r[29].s64 = ctx.r[31].s64 + 140;
	// 821A7C30: FBDF00A8  std r30, 0xa8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u64 ) };
	// 821A7C34: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A7C38: FBDF00B0  std r30, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u64 ) };
	// 821A7C3C: FBDF00B8  std r30, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u64 ) };
	// 821A7C40: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A7C44: 1C9C01A0  mulli r4, r28, 0x1a0
	ctx.r[4].s32 = ((ctx.r[28].s32 as i64 * 416 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 821A7C48: FBDF00C0  std r30, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 821A7C4C: 913F0054  stw r9, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821A7C50: 933F0058  stw r25, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 821A7C54: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A7C58: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821A7C5C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A7C60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A7C64: 4BFF9FCD  bl 0x821a1c30
	ctx.lr = 0x821A7C68;
	sub_821A1C30(ctx, base);
	// 821A7C68: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A7C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A7C70: 409A0044  bne cr6, 0x821a7cb4
	if !ctx.cr[6].eq {
	pc = 0x821A7CB4; continue 'dispatch;
	}
	// 821A7C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7C78: 419A002C  beq cr6, 0x821a7ca4
	if ctx.cr[6].eq {
	pc = 0x821A7CA4; continue 'dispatch;
	}
	// 821A7C7C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7C80: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7C84: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7C88: 409A001C  bne cr6, 0x821a7ca4
	if !ctx.cr[6].eq {
	pc = 0x821A7CA4; continue 'dispatch;
	}
	// 821A7C8C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A7C90: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A7C94: 9B4B0025  stb r26, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821A7C98: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A7C9C: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A7CA0: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A7CA4; continue 'dispatch;
            }
            0x821A7CA4 => {
    //   block [0x821A7CA4..0x821A7CB4)
	// 821A7CA4: FBDB0000  std r30, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821A7CA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821A7CAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A7CB0: 4838D448  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821A7CB4 => {
    //   block [0x821A7CB4..0x821A7CCC)
	// 821A7CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7CB8: 419A0014  beq cr6, 0x821a7ccc
	if ctx.cr[6].eq {
	pc = 0x821A7CCC; continue 'dispatch;
	}
	// 821A7CBC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7CC0: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7CC8: 419A0008  beq cr6, 0x821a7cd0
	if ctx.cr[6].eq {
	pc = 0x821A7CD0; continue 'dispatch;
	}
	pc = 0x821A7CCC; continue 'dispatch;
            }
            0x821A7CCC => {
    //   block [0x821A7CCC..0x821A7CD0)
	// 821A7CCC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821A7CD0; continue 'dispatch;
            }
            0x821A7CD0 => {
    //   block [0x821A7CD0..0x821A7D0C)
	// 821A7CD0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CD4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A7CD8: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 821A7CDC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821A7CE0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821A7CE4: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821A7CE8: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821A7CEC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821A7CF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A7CF4: 939F0090  stw r28, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 821A7CF8: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 821A7CFC: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821A7D00: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 821A7D04: 90FF0084  stw r7, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A7D08: 40990028  ble cr6, 0x821a7d30
	if !ctx.cr[6].gt {
	pc = 0x821A7D30; continue 'dispatch;
	}
	pc = 0x821A7D0C; continue 'dispatch;
            }
            0x821A7D0C => {
    //   block [0x821A7D0C..0x821A7D30)
	// 821A7D0C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A7D10: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821A7D14: 394A01A0  addi r10, r10, 0x1a0
	ctx.r[10].s64 = ctx.r[10].s64 + 416;
	// 821A7D18: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A7D1C: 396B01A0  addi r11, r11, 0x1a0
	ctx.r[11].s64 = ctx.r[11].s64 + 416;
	// 821A7D20: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821A7D24: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A7D28: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821A7D2C: 4198FFE0  blt cr6, 0x821a7d0c
	if ctx.cr[6].lt {
	pc = 0x821A7D0C; continue 'dispatch;
	}
	pc = 0x821A7D30; continue 'dispatch;
            }
            0x821A7D30 => {
    //   block [0x821A7D30..0x821A7D54)
	// 821A7D30: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 821A7D34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821A7D38: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A7D3C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821A7D40: FBDF00B8  std r30, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u64 ) };
	// 821A7D44: FBDF00C0  std r30, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 821A7D48: 931F00A0  stw r24, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 821A7D4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821A7D50: 4838D3A8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A7D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A7D78 size=1592
    let mut pc: u32 = 0x821A7D78;
    'dispatch: loop {
        match pc {
            0x821A7D78 => {
    //   block [0x821A7D78..0x821A7DC0)
	// 821A7D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A7D7C: 4838D315  bl 0x82535090
	ctx.lr = 0x821A7D80;
	sub_82535080(ctx, base);
	// 821A7D80: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 821A7D84: 4838E241  bl 0x82535fc4
	ctx.lr = 0x821A7D88;
	sub_82535FB0(ctx, base);
	// 821A7D88: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A7D8C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A7D90: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821A7D94: 838BFAC0  lwz r28, -0x540(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A7D98: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A7D9C: 925C0040  stw r18, 0x40(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[18].u32 ) };
	// 821A7DA0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A7DA4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A7DA8: 419A05F4  beq cr6, 0x821a839c
	if ctx.cr[6].eq {
	pc = 0x821A839C; continue 'dispatch;
	}
	// 821A7DAC: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A7DB0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A7DB4: 409A000C  bne cr6, 0x821a7dc0
	if !ctx.cr[6].eq {
	pc = 0x821A7DC0; continue 'dispatch;
	}
	// 821A7DB8: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 821A7DBC: 4800000C  b 0x821a7dc8
	pc = 0x821A7DC8; continue 'dispatch;
            }
            0x821A7DC0 => {
    //   block [0x821A7DC0..0x821A7DC8)
	// 821A7DC0: 815C008C  lwz r10, 0x8c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A7DC4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A7DC8; continue 'dispatch;
            }
            0x821A7DC8 => {
    //   block [0x821A7DC8..0x821A7DF0)
	// 821A7DC8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A7DCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A7DD0: 409A0034  bne cr6, 0x821a7e04
	if !ctx.cr[6].eq {
	pc = 0x821A7E04; continue 'dispatch;
	}
	// 821A7DD4: 817C00BC  lwz r11, 0xbc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A7DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7DDC: 419A0014  beq cr6, 0x821a7df0
	if ctx.cr[6].eq {
	pc = 0x821A7DF0; continue 'dispatch;
	}
	// 821A7DE0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7DE4: 815C00B8  lwz r10, 0xb8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A7DE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7DEC: 419A05B0  beq cr6, 0x821a839c
	if ctx.cr[6].eq {
	pc = 0x821A839C; continue 'dispatch;
	}
	pc = 0x821A7DF0; continue 'dispatch;
            }
            0x821A7DF0 => {
    //   block [0x821A7DF0..0x821A7E04)
	// 821A7DF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A7DF4: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 821A7DF8: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 821A7DFC: 4838E215  bl 0x82536010
	ctx.lr = 0x821A7E00;
	sub_82535FFC(ctx, base);
	// 821A7E00: 4838D2E0  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            0x821A7E04 => {
    //   block [0x821A7E04..0x821A7E64)
	// 821A7E04: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A7E08: 829C009C  lwz r20, 0x9c(r28)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A7E0C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A7E10: 827C0098  lwz r19, 0x98(r28)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A7E14: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A7E18: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A7E1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A7E20: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821A7E24: 7F2B542E  lfsx f25, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821A7E28: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821A7E2C: 4BFFA845  bl 0x821a2670
	ctx.lr = 0x821A7E30;
	sub_821A2670(ctx, base);
	// 821A7E30: 82FC0094  lwz r23, 0x94(r28)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A7E34: FE600890  fmr f19, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[19].f64 = ctx.f[1].f64;
	// 821A7E38: 817C00A0  lwz r11, 0xa0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A7E3C: 3957FFFF  addi r10, r23, -1
	ctx.r[10].s64 = ctx.r[23].s64 + -1;
	// 821A7E40: 55690252  rlwinm r9, r11, 0, 9, 9
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7E44: 5559073E  clrlwi r25, r10, 0x1c
	ctx.r[25].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821A7E48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A7E4C: 419A0018  beq cr6, 0x821a7e64
	if ctx.cr[6].eq {
	pc = 0x821A7E64; continue 'dispatch;
	}
	// 821A7E50: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821A7E54: 409A0010  bne cr6, 0x821a7e64
	if !ctx.cr[6].eq {
	pc = 0x821A7E64; continue 'dispatch;
	}
	// 821A7E58: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	// 821A7E5C: 917C00A0  stw r11, 0xa0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821A7E60: 48000008  b 0x821a7e68
	pc = 0x821A7E68; continue 'dispatch;
            }
            0x821A7E64 => {
    //   block [0x821A7E64..0x821A7E68)
	// 821A7E64: 933C0094  stw r25, 0x94(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(148 as u32), ctx.r[25].u32 ) };
	pc = 0x821A7E68; continue 'dispatch;
            }
            0x821A7E68 => {
    //   block [0x821A7E68..0x821A7F08)
	// 821A7E68: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 821A7E6C: C301006C  lfs f24, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A7E70: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 821A7E74: C2E10068  lfs f23, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A7E78: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821A7E7C: C2C10064  lfs f22, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A7E80: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A7E84: C2A10060  lfs f21, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A7E88: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A7E8C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A7E90: C384BA38  lfs f28, -0x45c8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A7E94: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A7E98: C2851FF8  lfs f20, 0x1ff8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8184 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A7E9C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A7EA0: C34624D0  lfs f26, 0x24d0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(9424 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A7EA4: C36724CC  lfs f27, 0x24cc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9420 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A7EA8: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 821A7EAC: C3A82850  lfs f29, 0x2850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10320 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A7EB0: 3B0B14A0  addi r24, r11, 0x14a0
	ctx.r[24].s64 = ctx.r[11].s64 + 5280;
	// 821A7EB4: C3C925C0  lfs f30, 0x25c0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9664 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A7EB8: 3AA00030  li r21, 0x30
	ctx.r[21].s64 = 48;
	// 821A7EBC: C3EA2280  lfs f31, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A7EC0: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 821A7EC4: B25F0010  sth r18, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[18].u16 ) };
	// 821A7EC8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821A7ECC: 817C00A0  lwz r11, 0xa0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A7ED0: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 821A7ED4: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821A7ED8: 556B0318  rlwinm r11, r11, 0, 0xc, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7EDC: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A7EE0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A7EE4: 71660041  andi. r6, r11, 0x41
	ctx.r[6].u64 = ctx.r[11].u64 & 65;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A7EE8: 4BFF46D9  bl 0x8219c5c0
	ctx.lr = 0x821A7EEC;
	sub_8219C5C0(ctx, base);
	// 821A7EEC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A7EF0: 40980018  bge cr6, 0x821a7f08
	if !ctx.cr[6].lt {
	pc = 0x821A7F08; continue 'dispatch;
	}
	// 821A7EF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A7EF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A7EFC: 4BFF900D  bl 0x821a0f08
	ctx.lr = 0x821A7F00;
	sub_821A0F08(ctx, base);
	// 821A7F00: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A7F04: 48000490  b 0x821a8394
	pc = 0x821A8394; continue 'dispatch;
            }
            0x821A7F08 => {
    //   block [0x821A7F08..0x821A7F60)
	// 821A7F08: 811C00A0  lwz r8, 0xa0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A7F0C: 550B0420  rlwinm r11, r8, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821A7F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F14: 419A02C0  beq cr6, 0x821a81d4
	if ctx.cr[6].eq {
	pc = 0x821A81D4; continue 'dispatch;
	}
	// 821A7F18: 39770006  addi r11, r23, 6
	ctx.r[11].s64 = ctx.r[23].s64 + 6;
	// 821A7F1C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A7F20: 7F6BFA14  add r27, r11, r31
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A7F24: 817C00AC  lwz r11, 0xac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A7F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F2C: 419A0040  beq cr6, 0x821a7f6c
	if ctx.cr[6].eq {
	pc = 0x821A7F6C; continue 'dispatch;
	}
	// 821A7F30: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F34: 815C00A8  lwz r10, 0xa8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A7F38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A7F3C: 409A0030  bne cr6, 0x821a7f6c
	if !ctx.cr[6].eq {
	pc = 0x821A7F6C; continue 'dispatch;
	}
	// 821A7F40: 817C00AC  lwz r11, 0xac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A7F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A7F48: 419A0018  beq cr6, 0x821a7f60
	if ctx.cr[6].eq {
	pc = 0x821A7F60; continue 'dispatch;
	}
	// 821A7F4C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F50: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A7F54: 813C00A8  lwz r9, 0xa8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A7F58: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A7F5C: 419A0008  beq cr6, 0x821a7f64
	if ctx.cr[6].eq {
	pc = 0x821A7F64; continue 'dispatch;
	}
	pc = 0x821A7F60; continue 'dispatch;
            }
            0x821A7F60 => {
    //   block [0x821A7F60..0x821A7F64)
	// 821A7F60: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x821A7F64; continue 'dispatch;
            }
            0x821A7F64 => {
    //   block [0x821A7F64..0x821A7F6C)
	// 821A7F64: 3BAB0060  addi r29, r11, 0x60
	ctx.r[29].s64 = ctx.r[11].s64 + 96;
	// 821A7F68: 480000E8  b 0x821a8050
	pc = 0x821A8050; continue 'dispatch;
            }
            0x821A7F6C => {
    //   block [0x821A7F6C..0x821A8050)
	// 821A7F6C: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A7F70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A7F74: 83DC00CC  lwz r30, 0xcc(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A7F78: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 821A7F7C: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 821A7F80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821A7F84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A7F88: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 821A7F8C: 4BFFBB7D  bl 0x821a3b08
	ctx.lr = 0x821A7F90;
	sub_821A3B08(ctx, base);
	// 821A7F90: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A7F94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A7F98: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821A7F9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A7FA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A7FA4: 4E800421  bctrl
	ctx.lr = 0x821A7FA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A7FA8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
            }
            0x821A8050 => {
    //   block [0x821A8050..0x821A81D4)
	// 821A8050: 39790006  addi r11, r25, 6
	ctx.r[11].s64 = ctx.r[25].s64 + 6;
	// 821A8054: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8058: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A805C: EDBC0028  fsubs f13, f28, f0
	ctx.f[13].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A8060: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A8064: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8068: C15D0000  lfs f10, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A806C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8070: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A8074: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8078: C13B000C  lfs f9, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A807C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A8080: D12B000C  stfs f9, 0xc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821A8084: C15B0004  lfs f10, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A8088: C13B0008  lfs f9, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A808C: ED8A637A  fmadds f12, f10, f13, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821A8090: C11B0000  lfs f8, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821A8094: ED695B7A  fmadds f11, f9, f13, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A8098: EC08037A  fmadds f0, f8, f13, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821A809C: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A80A0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A80A4: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A80A8: 817C00A0  lwz r11, 0xa0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A80AC: 556A0462  rlwinm r10, r11, 0, 0x11, 0x11
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A80B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A80B4: 419A008C  beq cr6, 0x821a8140
	if ctx.cr[6].eq {
	pc = 0x821A8140; continue 'dispatch;
	}
	// 821A80B8: 481BF081  bl 0x82367138
	ctx.lr = 0x821A80BC;
	sub_82367138(ctx, base);
	// 821A80BC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A80C0: C1BB0000  lfs f13, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A80C4: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 821A80C8: C80100D8  lfd f0, 0xd8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 821A80CC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A80D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A80D4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A80D8: EC00EFB8  fmsubs f0, f0, f30, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 821A80DC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A80E0: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A80E4: 481BF055  bl 0x82367138
	ctx.lr = 0x821A80E8;
	sub_82367138(ctx, base);
	// 821A80E8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A80EC: C1BB0004  lfs f13, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A80F0: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821A80F4: C80100C0  lfd f0, 0xc0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821A80F8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A80FC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8100: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8104: EC00EFB8  fmsubs f0, f0, f30, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 821A8108: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A810C: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8110: 481BF029  bl 0x82367138
	ctx.lr = 0x821A8114;
	sub_82367138(ctx, base);
	// 821A8114: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8118: C1BB0008  lfs f13, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A811C: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 821A8120: C80100D0  lfd f0, 0xd0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 821A8124: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8128: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A812C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8130: EC00EFB8  fmsubs f0, f0, f30, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 821A8134: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A8138: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A813C: 48000238  b 0x821a8374
	pc = 0x821A8374; continue 'dispatch;
	// 821A8140: 556B03DE  rlwinm r11, r11, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8148: 419A022C  beq cr6, 0x821a8374
	if ctx.cr[6].eq {
	pc = 0x821A8374; continue 'dispatch;
	}
	// 821A814C: 481BEFED  bl 0x82367138
	ctx.lr = 0x821A8150;
	sub_82367138(ctx, base);
	// 821A8150: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8154: C1BB0000  lfs f13, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8158: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 821A815C: C80100E0  lfd f0, 0xe0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 821A8160: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8164: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8168: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A816C: EC00D6F8  fmsubs f0, f0, f27, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 - ctx.f[26].f64) as f32) as f64);
	// 821A8170: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A8174: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8178: 481BEFC1  bl 0x82367138
	ctx.lr = 0x821A817C;
	sub_82367138(ctx, base);
	// 821A817C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8180: C1BB0004  lfs f13, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8184: F96100F0  std r11, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u64 ) };
	// 821A8188: C80100F0  lfd f0, 0xf0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 821A818C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8190: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8194: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8198: EC00D6F8  fmsubs f0, f0, f27, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 - ctx.f[26].f64) as f32) as f64);
	// 821A819C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A81A0: D01B0004  stfs f0, 4(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A81A4: 481BEF95  bl 0x82367138
	ctx.lr = 0x821A81A8;
	sub_82367138(ctx, base);
	// 821A81A8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A81AC: C1BB0008  lfs f13, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A81B0: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 821A81B4: C80100B0  lfd f0, 0xb0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 821A81B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A81BC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A81C0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A81C4: EC00D6F8  fmsubs f0, f0, f27, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 - ctx.f[26].f64) as f32) as f64);
	// 821A81C8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A81CC: D01B0008  stfs f0, 8(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A81D0: 480001A4  b 0x821a8374
	pc = 0x821A8374; continue 'dispatch;
            }
            0x821A81D4 => {
    //   block [0x821A81D4..0x821A8394)
	// 821A81D4: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 821A81D8: 56E92036  slwi r9, r23, 4
	ctx.r[9].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A81DC: 572A2036  slwi r10, r25, 4
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A81E0: 550804A4  rlwinm r8, r8, 0, 0x12, 0x12
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821A81E4: 7FC95A14  add r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A81E8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A81EC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A81F0: 419A0040  beq cr6, 0x821a8230
	if ctx.cr[6].eq {
	pc = 0x821A8230; continue 'dispatch;
	}
	// 821A81F4: EC150672  fmuls f0, f21, f25
	ctx.f[0].f64 = (((ctx.f[21].f64 * ctx.f[25].f64) as f32) as f64);
	// 821A81F8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A81FC: EC160672  fmuls f0, f22, f25
	ctx.f[0].f64 = (((ctx.f[22].f64 * ctx.f[25].f64) as f32) as f64);
	// 821A8200: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A8204: EC170672  fmuls f0, f23, f25
	ctx.f[0].f64 = (((ctx.f[23].f64 * ctx.f[25].f64) as f32) as f64);
	// 821A8208: D301008C  stfs f24, 0x8c(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A820C: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A8210: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x821A8394; continue 'dispatch;
            }
            0x821A8394 => {
    //   block [0x821A8394..0x821A839C)
	// 821A8394: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8398: 409AFB2C  bne cr6, 0x821a7ec4
	if !ctx.cr[6].eq {
	pc = 0x821A7EC4; continue 'dispatch;
	}
	pc = 0x821A839C; continue 'dispatch;
            }
            0x821A839C => {
    //   block [0x821A839C..0x821A83B0)
	// 821A839C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A83A0: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 821A83A4: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 821A83A8: 4838DC69  bl 0x82536010
	ctx.lr = 0x821A83AC;
	sub_82535FFC(ctx, base);
	// 821A83AC: 4838CD34  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A83B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A83B0 size=1976
    let mut pc: u32 = 0x821A83B0;
    'dispatch: loop {
        match pc {
            0x821A83B0 => {
    //   block [0x821A83B0..0x821A83F8)
	// 821A83B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A83B4: 4838CCCD  bl 0x82535080
	ctx.lr = 0x821A83B8;
	sub_82535080(ctx, base);
	// 821A83B8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A83BC: 4838DBF5  bl 0x82535fb0
	ctx.lr = 0x821A83C0;
	sub_82535FB0(ctx, base);
	// 821A83C0: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A83C4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A83C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A83CC: 82ABFAC0  lwz r21, -0x540(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A83D0: 81750040  lwz r11, 0x40(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A83D4: 93F50040  stw r31, 0x40(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A83D8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A83DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A83E0: 419A03B4  beq cr6, 0x821a8794
	if ctx.cr[6].eq {
	pc = 0x821A8794; continue 'dispatch;
	}
	// 821A83E4: 81750084  lwz r11, 0x84(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A83E8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A83EC: 419A000C  beq cr6, 0x821a83f8
	if ctx.cr[6].eq {
	pc = 0x821A83F8; continue 'dispatch;
	}
	// 821A83F0: 8155008C  lwz r10, 0x8c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A83F4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A83F8; continue 'dispatch;
            }
            0x821A83F8 => {
    //   block [0x821A83F8..0x821A8430)
	// 821A83F8: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A83FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A8400: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 821A8404: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8408: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A840C: 916AB9EC  stw r11, -0x4614(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17940 as u32), ctx.r[11].u32 ) };
	// 821A8410: 409A0034  bne cr6, 0x821a8444
	if !ctx.cr[6].eq {
	pc = 0x821A8444; continue 'dispatch;
	}
	// 821A8414: 817500BC  lwz r11, 0xbc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A8418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A841C: 419A0014  beq cr6, 0x821a8430
	if ctx.cr[6].eq {
	pc = 0x821A8430; continue 'dispatch;
	}
	// 821A8420: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8424: 815500B8  lwz r10, 0xb8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A8428: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A842C: 419A0368  beq cr6, 0x821a8794
	if ctx.cr[6].eq {
	pc = 0x821A8794; continue 'dispatch;
	}
	pc = 0x821A8430; continue 'dispatch;
            }
            0x821A8430 => {
    //   block [0x821A8430..0x821A8444)
	// 821A8430: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A8434: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 821A8438: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A843C: 4838DBC1  bl 0x82535ffc
	ctx.lr = 0x821A8440;
	sub_82535FFC(ctx, base);
	// 821A8440: 4838CC90  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x821A8444 => {
    //   block [0x821A8444..0x821A85D4)
	// 821A8444: 817500CC  lwz r11, 0xcc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A8448: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821A844C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A8450: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8454: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A845C: 4E800421  bctrl
	ctx.lr = 0x821A8460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8460: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821A8464: 817500CC  lwz r11, 0xcc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A8468: C3E30030  lfs f31, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A846C: 614AA9C0  ori r10, r10, 0xa9c0
	ctx.r[10].u64 = ctx.r[10].u64 | 43456;
	// 821A8470: C3C30038  lfs f30, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A8474: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821A8478: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A847C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A8480: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8484: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A8488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A848C: 4E800421  bctrl
	ctx.lr = 0x821A8490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8490: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A8494: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821A8498: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 821A849C: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821A84A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A84A4: 8075009C  lwz r3, 0x9c(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A84A8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821A84AC: 7C2A4C2E  lfsx f1, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A84B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A84B4: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A84B8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821A84BC: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A84C0: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A84C4: D0210058  stfs f1, 0x58(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821A84C8: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A84CC: 81550098  lwz r10, 0x98(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A84D0: ED7F0032  fmuls f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A84D4: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A84D8: ED5E0032  fmuls f10, f30, f0
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A84DC: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A84E0: D1210084  stfs f9, 0x84(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A84E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821A84E8: EEAD583A  fmadds f21, f13, f0, f11
	ctx.f[21].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821A84EC: EE8C503A  fmadds f20, f12, f0, f10
	ctx.f[20].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821A84F0: 4BFFA181  bl 0x821a2670
	ctx.lr = 0x821A84F4;
	sub_821A2670(ctx, base);
	// 821A84F4: 82550094  lwz r18, 0x94(r21)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A84F8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A84FC: D0210070  stfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A8500: 3EC0820A  lis r22, -0x7df6
	ctx.r[22].s64 = -2113273856;
	// 821A8504: 3972FFFF  addi r11, r18, -1
	ctx.r[11].s64 = ctx.r[18].s64 + -1;
	// 821A8508: 3EE0820D  lis r23, -0x7df3
	ctx.r[23].s64 = -2113077248;
	// 821A850C: 5570073E  clrlwi r16, r11, 0x1c
	ctx.r[16].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821A8510: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A8514: C3EA2280  lfs f31, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A8518: 3F00820D  lis r24, -0x7df3
	ctx.r[24].s64 = -2113077248;
	// 821A851C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821A8520: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 821A8524: 92150094  stw r16, 0x94(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(148 as u32), ctx.r[16].u32 ) };
	// 821A8528: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 821A852C: 3F60820D  lis r27, -0x7df3
	ctx.r[27].s64 = -2113077248;
	// 821A8530: 3F80820D  lis r28, -0x7df3
	ctx.r[28].s64 = -2113077248;
	// 821A8534: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A8538: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A853C: 3FA0820D  lis r29, -0x7df3
	ctx.r[29].s64 = -2113077248;
	// 821A8540: 39EB14A0  addi r15, r11, 0x14a0
	ctx.r[15].s64 = ctx.r[11].s64 + 5280;
	// 821A8544: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A8548: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 821A854C: 396B4D30  addi r11, r11, 0x4d30
	ctx.r[11].s64 = ctx.r[11].s64 + 19760;
	// 821A8550: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 821A8554: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 821A8558: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 821A855C: 3CC08288  lis r6, -0x7d78
	ctx.r[6].s64 = -2105016320;
	// 821A8560: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A8564: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A8568: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A856C: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 821A8570: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A8574: 3E8082C0  lis r20, -0x7d40
	ctx.r[20].s64 = -2101346304;
	// 821A8578: 3E6082C0  lis r19, -0x7d40
	ctx.r[19].s64 = -2101346304;
	// 821A857C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821A8580: 3A200010  li r17, 0x10
	ctx.r[17].s64 = 16;
	// 821A8584: 39C00020  li r14, 0x20
	ctx.r[14].s64 = 32;
	// 821A8588: C31C209C  lfs f24, 0x209c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8348 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A858C: 8394B9E8  lwz r28, -0x4618(r20)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(-17944 as u32) ) } as u64;
	// 821A8590: C2FB207C  lfs f23, 0x207c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8316 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A8594: 8373B9E0  lwz r27, -0x4620(r19)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-17952 as u32) ) } as u64;
	// 821A8598: C01720CC  lfs f0, 0x20cc(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A859C: C26928F4  lfs f19, 0x28f4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10484 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821A85A0: C24844A8  lfs f18, 0x44a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(17576 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 821A85A4: C2C72068  lfs f22, 0x2068(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8296 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A85A8: C3D6BA38  lfs f30, -0x45c8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A85AC: C226D4DC  lfs f17, -0x2b24(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 821A85B0: C20524CC  lfs f16, 0x24cc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(9420 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 821A85B4: C34424EC  lfs f26, 0x24ec(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(9452 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A85B8: C32321DC  lfs f25, 0x21dc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8668 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821A85BC: C3BE2138  lfs f29, 0x2138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8504 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A85C0: C39D228C  lfs f28, 0x228c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8844 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A85C4: C37AD6C8  lfs f27, -0x2938(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821A85C8: C1D9223C  lfs f14, 0x223c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8764 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 821A85CC: C1F81FF8  lfs f15, 0x1ff8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8184 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 821A85D0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
            }
            0x821A85D4 => {
    //   block [0x821A85D4..0x821A8644)
	// 821A85D4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821A85D8: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 821A85DC: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A85E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A85E4: 41980060  blt cr6, 0x821a8644
	if ctx.cr[6].lt {
	pc = 0x821A8644; continue 'dispatch;
	}
	// 821A85E8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821A85EC: 4098012C  bge cr6, 0x821a8718
	if !ctx.cr[6].lt {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A85F0: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 821A85F4: 409A0124  bne cr6, 0x821a8718
	if !ctx.cr[6].eq {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A85F8: 481BEB41  bl 0x82367138
	ctx.lr = 0x821A85FC;
	sub_82367138(ctx, base);
	// 821A85FC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8600: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8608: 80D500A0  lwz r6, 0xa0(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A860C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8610: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 821A8614: C8010090  lfd f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A8618: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A861C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8620: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8624: EC2094FA  fmadds f1, f0, f19, f18
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[19].f64 + ctx.f[18].f64) as f32) as f64);
	// 821A8628: 480006C9  bl 0x821a8cf0
	ctx.lr = 0x821A862C;
	sub_821A8CF0(ctx, base);
	// 821A862C: 80750128  lwz r3, 0x128(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(296 as u32) ) } as u64;
	// 821A8630: 4BFFCEB1  bl 0x821a54e0
	ctx.lr = 0x821A8634;
	sub_821A54E0(ctx, base);
	// 821A8634: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821A8638: B07F0198  sth r3, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u16 ) };
	// 821A863C: B17F019A  sth r11, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[11].u16 ) };
	// 821A8640: 480000DC  b 0x821a871c
	pc = 0x821A871C; continue 'dispatch;
            }
            0x821A8644 => {
    //   block [0x821A8644..0x821A8664)
	// 821A8644: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821A8648: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A864C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A8650: 815EFBAC  lwz r10, -0x454(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1108 as u32) ) } as u64;
	// 821A8654: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8658: 419A000C  beq cr6, 0x821a8664
	if ctx.cr[6].eq {
	pc = 0x821A8664; continue 'dispatch;
	}
	// 821A865C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 821A8660: 409A00B8  bne cr6, 0x821a8718
	if !ctx.cr[6].eq {
	pc = 0x821A8718; continue 'dispatch;
	}
	pc = 0x821A8664; continue 'dispatch;
            }
            0x821A8664 => {
    //   block [0x821A8664..0x821A8718)
	// 821A8664: 481BEAD5  bl 0x82367138
	ctx.lr = 0x821A8668;
	sub_82367138(ctx, base);
	// 821A8668: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A866C: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 821A8670: C80100B8  lfd f0, 0xb8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 821A8674: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8678: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A867C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8680: EC00F5B8  fmsubs f0, f0, f22, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A8684: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821A8688: 481BEAB1  bl 0x82367138
	ctx.lr = 0x821A868C;
	sub_82367138(ctx, base);
	// 821A868C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8690: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 821A8694: C80100A0  lfd f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821A8698: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A869C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A86A0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A86A4: EC00F5B8  fmsubs f0, f0, f22, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A86A8: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 821A86AC: 481BEA8D  bl 0x82367138
	ctx.lr = 0x821A86B0;
	sub_82367138(ctx, base);
	// 821A86B0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A86B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A86B8: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 821A86BC: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 821A86C0: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 821A86C4: F9610110  std r11, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 821A86C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821A86CC: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 821A86D0: C8010110  lfd f0, 0x110(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 821A86D4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A86D8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A86DC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A86E0: EC00F5B8  fmsubs f0, f0, f22, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64 - ctx.f[30].f64) as f32) as f64);
	// 821A86E4: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821A86E8: 4BFF8551  bl 0x821a0c38
	ctx.lr = 0x821A86EC;
	sub_821A0C38(ctx, base);
	// 821A86EC: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A86F0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821A86F4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821A86F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A86FC: 814AB9EC  lwz r10, -0x4614(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17940 as u32) ) } as u64;
	// 821A8700: 9394B9E8  stw r28, -0x4618(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(-17944 as u32), ctx.r[28].u32 ) };
	// 821A8704: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8708: B17F019A  sth r11, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[11].u16 ) };
	// 821A870C: 4198000C  blt cr6, 0x821a8718
	if ctx.cr[6].lt {
	pc = 0x821A8718; continue 'dispatch;
	}
	// 821A8710: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A8714: 917EFBAC  stw r11, -0x454(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-1108 as u32), ctx.r[11].u32 ) };
	pc = 0x821A8718; continue 'dispatch;
            }
            0x821A8718 => {
    //   block [0x821A8718..0x821A871C)
	// 821A8718: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821A871C; continue 'dispatch;
            }
            0x821A871C => {
    //   block [0x821A871C..0x821A877C)
	// 821A871C: 817500A0  lwz r11, 0xa0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A8720: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8724: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 821A8728: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A872C: 556B0318  rlwinm r11, r11, 0, 0xc, 0xc
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8730: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A8734: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A8738: 71660041  andi. r6, r11, 0x41
	ctx.r[6].u64 = ctx.r[11].u64 & 65;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A873C: 4BFF3E85  bl 0x8219c5c0
	ctx.lr = 0x821A8740;
	sub_8219C5C0(ctx, base);
	// 821A8740: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821A8744: 409800A0  bge cr6, 0x821a87e4
	if !ctx.cr[6].lt {
	pc = 0x821A87E4; continue 'dispatch;
	}
	// 821A8748: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A874C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821A8750: 41990094  bgt cr6, 0x821a87e4
	if ctx.cr[6].gt {
	pc = 0x821A87E4; continue 'dispatch;
	}
	// 821A8754: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821A8758: 398C876C  addi r12, r12, -0x7894
	ctx.r[12].s64 = ctx.r[12].s64 + -30868;
	// 821A875C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821A8760: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821A8764: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821A8768: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821A877C; continue 'dispatch;
		},
		1 => {
	pc = 0x821A87A8; continue 'dispatch;
		},
		2 => {
	pc = 0x821A8920; continue 'dispatch;
		},
		3 => {
	pc = 0x821A89E4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821A876C: 821A877C  lwz r16, -0x7884(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30852 as u32) ) } as u64;
	// 821A8770: 821A87A8  lwz r16, -0x7858(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30808 as u32) ) } as u64;
	// 821A8774: 821A8920  lwz r16, -0x76e0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30432 as u32) ) } as u64;
	// 821A8778: 821A89E4  lwz r16, -0x761c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30236 as u32) ) } as u64;
            }
            0x821A877C => {
    //   block [0x821A877C..0x821A8794)
	// 821A877C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A8780: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821A8784: 4BFF8785  bl 0x821a0f08
	ctx.lr = 0x821A8788;
	sub_821A0F08(ctx, base);
	// 821A8788: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A878C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8790: 409AFE44  bne cr6, 0x821a85d4
	if !ctx.cr[6].eq {
	pc = 0x821A85D4; continue 'dispatch;
	}
	pc = 0x821A8794; continue 'dispatch;
            }
            0x821A8794 => {
    //   block [0x821A8794..0x821A87A8)
	// 821A8794: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A8798: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 821A879C: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A87A0: 4838D85D  bl 0x82535ffc
	ctx.lr = 0x821A87A4;
	sub_82535FFC(ctx, base);
	// 821A87A4: 4838C92C  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x821A87A8 => {
    //   block [0x821A87A8..0x821A87E4)
	// 821A87A8: 481BE991  bl 0x82367138
	ctx.lr = 0x821A87AC;
	sub_82367138(ctx, base);
	// 821A87AC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A87B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A87B4: 80D500A0  lwz r6, 0xa0(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A87B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A87BC: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 821A87C0: C80100B0  lfd f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 821A87C4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A87C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A87CC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A87D0: EC20847A  fmadds f1, f0, f17, f16
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[17].f64 + ctx.f[16].f64) as f32) as f64);
	// 821A87D4: 4800051D  bl 0x821a8cf0
	ctx.lr = 0x821A87D8;
	sub_821A8CF0(ctx, base);
	// 821A87D8: 80750128  lwz r3, 0x128(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(296 as u32) ) } as u64;
	// 821A87DC: 4BFFCD05  bl 0x821a54e0
	ctx.lr = 0x821A87E0;
	sub_821A54E0(ctx, base);
	// 821A87E0: B07F0198  sth r3, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u16 ) };
	pc = 0x821A87E4; continue 'dispatch;
            }
            0x821A87E4 => {
    //   block [0x821A87E4..0x821A8920)
	// 821A87E4: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A87E8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821A87EC: 409A0228  bne cr6, 0x821a8a14
	if !ctx.cr[6].eq {
	pc = 0x821A8A14; continue 'dispatch;
	}
	// 821A87F0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A87F4: 39520006  addi r10, r18, 6
	ctx.r[10].s64 = ctx.r[18].s64 + 6;
	// 821A87F8: 83B500CC  lwz r29, 0xcc(r21)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A87FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A8800: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	// 821A8804: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A8808: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 821A880C: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821A8810: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821A8814: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A8818: 4BFFB2F1  bl 0x821a3b08
	ctx.lr = 0x821A881C;
	sub_821A3B08(ctx, base);
	// 821A881C: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8820: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A8824: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821A8828: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A882C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A8830: 4E800421  bctrl
	ctx.lr = 0x821A8834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A8834: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
            }
            0x821A8920 => {
    //   block [0x821A8920..0x821A89E4)
	// 821A8920: 481BE819  bl 0x82367138
	ctx.lr = 0x821A8924;
	sub_82367138(ctx, base);
	// 821A8924: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8928: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A892C: 80D500A0  lwz r6, 0xa0(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A8930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8934: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 821A8938: C80100E0  lfd f0, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 821A893C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8940: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8944: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8948: EC20CEBA  fmadds f1, f0, f26, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[25].f64) as f32) as f64);
	// 821A894C: 480003A5  bl 0x821a8cf0
	ctx.lr = 0x821A8950;
	sub_821A8CF0(ctx, base);
	// 821A8950: 80750128  lwz r3, 0x128(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(296 as u32) ) } as u64;
	// 821A8954: 4BFFCB8D  bl 0x821a54e0
	ctx.lr = 0x821A8958;
	sub_821A54E0(ctx, base);
	// 821A8958: 39720006  addi r11, r18, 6
	ctx.r[11].s64 = ctx.r[18].s64 + 6;
	// 821A895C: B07F0198  sth r3, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u16 ) };
	// 821A8960: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A8964: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821A8968: 481BE7D1  bl 0x82367138
	ctx.lr = 0x821A896C;
	sub_82367138(ctx, base);
	// 821A896C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8970: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821A8974: C80100C0  lfd f0, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821A8978: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A897C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8980: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A8984: EC00AF7A  fmadds f0, f0, f29, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[21].f64) as f32) as f64);
	// 821A8988: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821A898C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8990: 481BE7A9  bl 0x82367138
	ctx.lr = 0x821A8994;
	sub_82367138(ctx, base);
	// 821A8994: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8998: D3040004  stfs f24, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A899C: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821A89A0: C8010098  lfd f0, 0x98(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821A89A4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A89A8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A89AC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A89B0: EC00A77A  fmadds f0, f0, f29, f20
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[20].f64) as f32) as f64);
	// 821A89B4: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821A89B8: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A89BC: 481BE77D  bl 0x82367138
	ctx.lr = 0x821A89C0;
	sub_82367138(ctx, base);
	// 821A89C0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A89C4: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821A89C8: C80100A8  lfd f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 821A89CC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A89D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A89D4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821A89D8: EC00DDF8  fmsubs f0, f0, f23, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64 - ctx.f[27].f64) as f32) as f64);
	// 821A89DC: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A89E0: 4BFFFE04  b 0x821a87e4
	pc = 0x821A87E4; continue 'dispatch;
            }
            0x821A89E4 => {
    //   block [0x821A89E4..0x821A8A14)
	// 821A89E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A89E8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821A89EC: 4BFF851D  bl 0x821a0f08
	ctx.lr = 0x821A89F0;
	sub_821A0F08(ctx, base);
	// 821A89F0: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 821A89F4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821A89F8: 9394B9E8  stw r28, -0x4618(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(-17944 as u32), ctx.r[28].u32 ) };
	// 821A89FC: 4199FD8C  bgt cr6, 0x821a8788
	if ctx.cr[6].gt {
	pc = 0x821A8788; continue 'dispatch;
	}
	// 821A8A00: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 821A8A04: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 821A8A08: 9394B9E8  stw r28, -0x4618(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(-17944 as u32), ctx.r[28].u32 ) };
	// 821A8A0C: 9373B9E0  stw r27, -0x4620(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(-17952 as u32), ctx.r[27].u32 ) };
	// 821A8A10: 4BFFFD78  b 0x821a8788
	pc = 0x821A8788; continue 'dispatch;
            }
            0x821A8A14 => {
    //   block [0x821A8A14..0x821A8B68)
	// 821A8A14: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 821A8A18: C0210058  lfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A8A1C: 560A2036  slwi r10, r16, 4
	ctx.r[10].u32 = ctx.r[16].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A8A20: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A8A24: 56492036  slwi r9, r18, 4
	ctx.r[9].u32 = ctx.r[18].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A8A28: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A8A2C: 3BBF0160  addi r29, r31, 0x160
	ctx.r[29].s64 = ctx.r[31].s64 + 352;
	// 821A8A30: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821A8A34: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821A8A38: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821A8A3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A8A40: 4BFF9D21  bl 0x821a2760
	ctx.lr = 0x821A8A44;
	sub_821A2760(ctx, base);
	// 821A8A44: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A8A48: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A8A4C: 409A00DC  bne cr6, 0x821a8b28
	if !ctx.cr[6].eq {
	pc = 0x821A8B28; continue 'dispatch;
	}
	// 821A8A50: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A8A54: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8A58: EC007028  fsubs f0, f0, f14
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[14].f64) as f32) as f64);
	// 821A8A5C: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8A60: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A8A64: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A8A68: 896A0001  lbz r11, 1(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A8A6C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A8A70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A8A74: 40990018  ble cr6, 0x821a8a8c
	if !ctx.cr[6].gt {
	pc = 0x821A8A8C; continue 'dispatch;
	}
	// 821A8A78: 896A0002  lbz r11, 2(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A8A7C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A8A80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A8A84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8A88: 41990008  bgt cr6, 0x821a8a90
	if ctx.cr[6].gt {
	pc = 0x821A8A90; continue 'dispatch;
	}
	// 821A8A8C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821A8A90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A8A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8A98: 409A0010  bne cr6, 0x821a8aa8
	if !ctx.cr[6].eq {
	pc = 0x821A8AA8; continue 'dispatch;
	}
	// 821A8A9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8AA0: 4800EA29  bl 0x821b74c8
	ctx.lr = 0x821A8AA4;
	sub_821B74C8(ctx, base);
	// 821A8AA4: 48000014  b 0x821a8ab8
	pc = 0x821A8AB8; continue 'dispatch;
	// 821A8AA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A8AAC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821A8AB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821A8AB4: 4800EA7D  bl 0x821b7530
	ctx.lr = 0x821A8AB8;
	sub_821B7530(ctx, base);
	// 821A8AB8: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8ABC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 821A8AC0: 41990080  bgt cr6, 0x821a8b40
	if ctx.cr[6].gt {
	pc = 0x821A8B40; continue 'dispatch;
	}
	// 821A8AC4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821A8AC8: 41990034  bgt cr6, 0x821a8afc
	if ctx.cr[6].gt {
	pc = 0x821A8AFC; continue 'dispatch;
	}
	// 821A8ACC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8AD0: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 821A8AD4: D37F0174  stfs f27, 0x174(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 821A8AD8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8ADC: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821A8AE0: D1FD0008  stfs f15, 8(r29)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A8AE4: D1FD0004  stfs f15, 4(r29)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8AE8: D1FD0000  stfs f15, 0(r29)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8AEC: A17F019A  lhz r11, 0x19a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(410 as u32) ) } as u64;
	// 821A8AF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A8AF4: B17F019A  sth r11, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[11].u16 ) };
	// 821A8AF8: 48000048  b 0x821a8b40
	pc = 0x821A8B40; continue 'dispatch;
	// 821A8AFC: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8B00: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8B04: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A8B08: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8B0C: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A8B10: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A8B14: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A8B18: D1BD0000  stfs f13, 0(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8B1C: D19D0004  stfs f12, 4(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8B20: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A8B24: 4800001C  b 0x821a8b40
	pc = 0x821A8B40; continue 'dispatch;
	// 821A8B28: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 821A8B2C: 409A0014  bne cr6, 0x821a8b40
	if !ctx.cr[6].eq {
	pc = 0x821A8B40; continue 'dispatch;
	}
	// 821A8B30: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8B34: C1A10078  lfs f13, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8B38: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821A8B3C: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8B40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A8B44: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A8B48: 409A0010  bne cr6, 0x821a8b58
	if !ctx.cr[6].eq {
	pc = 0x821A8B58; continue 'dispatch;
	}
	// 821A8B4C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821A8B50: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A8B54: 4BFFFC38  b 0x821a878c
	pc = 0x821A878C; continue 'dispatch;
	// 821A8B58: 8155008C  lwz r10, 0x8c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A8B5C: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821A8B60: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821A8B64: 4BFFFC28  b 0x821a878c
	pc = 0x821A878C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A8B68 size=264
    let mut pc: u32 = 0x821A8B68;
    'dispatch: loop {
        match pc {
            0x821A8B68 => {
    //   block [0x821A8B68..0x821A8BB0)
	// 821A8B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8B74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8B78: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A8B7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8B80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821A8B84: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A8B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8B8C: 481C176D  bl 0x8236a2f8
	ctx.lr = 0x821A8B90;
	sub_8236A2F8(ctx, base);
	// 821A8B90: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A8B94: 389F008C  addi r4, r31, 0x8c
	ctx.r[4].s64 = ctx.r[31].s64 + 140;
	// 821A8B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8B9C: 419A0014  beq cr6, 0x821a8bb0
	if ctx.cr[6].eq {
	pc = 0x821A8BB0; continue 'dispatch;
	}
	// 821A8BA0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A8BA4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A8BA8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A8BAC: 4BFF94D5  bl 0x821a2080
	ctx.lr = 0x821A8BB0;
	sub_821A2080(ctx, base);
	pc = 0x821A8BB0; continue 'dispatch;
            }
            0x821A8BB0 => {
    //   block [0x821A8BB0..0x821A8C00)
	// 821A8BB0: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A8BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8BB8: 419A0048  beq cr6, 0x821a8c00
	if ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BBC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8BC0: 813F00A8  lwz r9, 0xa8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A8BC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A8BC8: 409A0038  bne cr6, 0x821a8c00
	if !ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BCC: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A8BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8BD4: 419A002C  beq cr6, 0x821a8c00
	if ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BD8: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A8BDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A8BE0: 419A0020  beq cr6, 0x821a8c00
	if ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BE4: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8BE8: 812B0090  lwz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A8BEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A8BF0: 409A0010  bne cr6, 0x821a8c00
	if !ctx.cr[6].eq {
	pc = 0x821A8C00; continue 'dispatch;
	}
	// 821A8BF4: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A8BF8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A8BFC: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x821A8C00; continue 'dispatch;
            }
            0x821A8C00 => {
    //   block [0x821A8C00..0x821A8C58)
	// 821A8C00: 815F00C8  lwz r10, 0xc8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821A8C04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A8C08: 419A0050  beq cr6, 0x821a8c58
	if ctx.cr[6].eq {
	pc = 0x821A8C58; continue 'dispatch;
	}
	// 821A8C0C: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A8C10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A8C14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A8C18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8C1C: 419A003C  beq cr6, 0x821a8c58
	if ctx.cr[6].eq {
	pc = 0x821A8C58; continue 'dispatch;
	}
	// 821A8C20: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8C24: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A8C28: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A8C2C: 409A002C  bne cr6, 0x821a8c58
	if !ctx.cr[6].eq {
	pc = 0x821A8C58; continue 'dispatch;
	}
	// 821A8C30: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A8C34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A8C38: 409A0024  bne cr6, 0x821a8c5c
	if !ctx.cr[6].eq {
	pc = 0x821A8C5C; continue 'dispatch;
	}
	// 821A8C3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A8C40: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A8C44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8C48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8C4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8C50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8C54: 4E800020  blr
	return;
            }
            0x821A8C58 => {
    //   block [0x821A8C58..0x821A8C5C)
	// 821A8C58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x821A8C5C; continue 'dispatch;
            }
            0x821A8C5C => {
    //   block [0x821A8C5C..0x821A8C70)
	// 821A8C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8C60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8C64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8C68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8C6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8C70 size=128
    let mut pc: u32 = 0x821A8C70;
    'dispatch: loop {
        match pc {
            0x821A8C70 => {
    //   block [0x821A8C70..0x821A8CD8)
	// 821A8C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A8C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8C80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8C84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A8C88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A8C8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821A8C90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A8C94: 4BFF811D  bl 0x821a0db0
	ctx.lr = 0x821A8C98;
	sub_821A0DB0(ctx, base);
	// 821A8C98: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A8C9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A8CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8CA4: 419A0034  beq cr6, 0x821a8cd8
	if ctx.cr[6].eq {
	pc = 0x821A8CD8; continue 'dispatch;
	}
	// 821A8CA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A8CAC: B17F0010  sth r11, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 821A8CB0: 80DE00A0  lwz r6, 0xa0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A8CB4: 809E0098  lwz r4, 0x98(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A8CB8: 48000039  bl 0x821a8cf0
	ctx.lr = 0x821A8CBC;
	sub_821A8CF0(ctx, base);
	// 821A8CBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A8CC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8CC8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8CCC: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821A8CD0: D07F0194  stfs f3, 0x194(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 821A8CD4: B15F019A  sth r10, 0x19a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(410 as u32), ctx.r[10].u16 ) };
	pc = 0x821A8CD8; continue 'dispatch;
            }
            0x821A8CD8 => {
    //   block [0x821A8CD8..0x821A8CF0)
	// 821A8CD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8CDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8CE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8CE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A8CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8CF0 size=208
    let mut pc: u32 = 0x821A8CF0;
    'dispatch: loop {
        match pc {
            0x821A8CF0 => {
    //   block [0x821A8CF0..0x821A8D24)
	// 821A8CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8CF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8CFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8D00: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A8D04: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821A8D08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A8D0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A8D10: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8D14: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 821A8D18: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A8D1C: EDA00824  fdivs f13, f0, f1
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 821A8D20: 810A0084  lwz r8, 0x84(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	pc = 0x821A8D24; continue 'dispatch;
            }
            0x821A8D24 => {
    //   block [0x821A8D24..0x821A8D4C)
	// 821A8D24: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8D28: 2F070005  cmpwi cr6, r7, 5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 5, &mut ctx.xer);
	// 821A8D2C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A8D30: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8D34: 409A0018  bne cr6, 0x821a8d4c
	if !ctx.cr[6].eq {
	pc = 0x821A8D4C; continue 'dispatch;
	}
	// 821A8D38: 7D054B78  or r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821A8D3C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A8D40: 54A507FE  clrlwi r5, r5, 0x1f
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821A8D44: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821A8D48: 409A000C  bne cr6, 0x821a8d54
	if !ctx.cr[6].eq {
	pc = 0x821A8D54; continue 'dispatch;
	}
	pc = 0x821A8D4C; continue 'dispatch;
            }
            0x821A8D4C => {
    //   block [0x821A8D4C..0x821A8D54)
	// 821A8D4C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8D50: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x821A8D54; continue 'dispatch;
            }
            0x821A8D54 => {
    //   block [0x821A8D54..0x821A8DAC)
	// 821A8D54: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821A8D58: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A8D5C: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821A8D60: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821A8D64: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821A8D68: 2F070008  cmpwi cr6, r7, 8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 8, &mut ctx.xer);
	// 821A8D6C: 4198FFB8  blt cr6, 0x821a8d24
	if ctx.cr[6].lt {
	pc = 0x821A8D24; continue 'dispatch;
	}
	// 821A8D70: 54CB04E6  rlwinm r11, r6, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8D78: 419A0034  beq cr6, 0x821a8dac
	if ctx.cr[6].eq {
	pc = 0x821A8DAC; continue 'dispatch;
	}
	// 821A8D7C: 481BE3BD  bl 0x82367138
	ctx.lr = 0x821A8D80;
	sub_82367138(ctx, base);
	// 821A8D80: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A8D84: C1BF0034  lfs f13, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8D88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A8D8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A8D90: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A8D94: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A8D98: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A8D9C: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8DA0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A8DA4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821A8DA8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x821A8DAC; continue 'dispatch;
            }
            0x821A8DAC => {
    //   block [0x821A8DAC..0x821A8DC0)
	// 821A8DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8DBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8DC0 size=244
    let mut pc: u32 = 0x821A8DC0;
    'dispatch: loop {
        match pc {
            0x821A8DC0 => {
    //   block [0x821A8DC0..0x821A8E0C)
	// 821A8DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A8DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8DD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A8DD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A8DDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A8DE0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821A8DE4: 38EB0E84  addi r7, r11, 0xe84
	ctx.r[7].s64 = ctx.r[11].s64 + 3716;
	// 821A8DE8: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821A8DEC: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 821A8DF0: FBFE0000  std r31, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 821A8DF4: 481C169D  bl 0x8236a490
	ctx.lr = 0x821A8DF8;
	sub_8236A490(ctx, base);
	// 821A8DF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A8DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8E00: 419A000C  beq cr6, 0x821a8e0c
	if ctx.cr[6].eq {
	pc = 0x821A8E0C; continue 'dispatch;
	}
	// 821A8E04: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8E08: 48000008  b 0x821a8e10
	pc = 0x821A8E10; continue 'dispatch;
            }
            0x821A8E0C => {
    //   block [0x821A8E0C..0x821A8E10)
	// 821A8E0C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x821A8E10; continue 'dispatch;
            }
            0x821A8E10 => {
    //   block [0x821A8E10..0x821A8E74)
	// 821A8E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8E14: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A8E18: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821A8E1C: 419A0090  beq cr6, 0x821a8eac
	if ctx.cr[6].eq {
	pc = 0x821A8EAC; continue 'dispatch;
	}
	// 821A8E20: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A8E24: 3CE0821B  lis r7, -0x7de5
	ctx.r[7].s64 = -2112159744;
	// 821A8E28: 394A0F7C  addi r10, r10, 0xf7c
	ctx.r[10].s64 = ctx.r[10].s64 + 3964;
	// 821A8E2C: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821A8E30: 38E78EB8  addi r7, r7, -0x7148
	ctx.r[7].s64 = ctx.r[7].s64 + -29000;
	// 821A8E34: 39298EE8  addi r9, r9, -0x7118
	ctx.r[9].s64 = ctx.r[9].s64 + -28952;
	// 821A8E38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A8E3C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A8E40: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821A8E44: FBEB0188  std r31, 0x188(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), ctx.r[31].u64 ) };
	// 821A8E48: 394A90B0  addi r10, r10, -0x6f50
	ctx.r[10].s64 = ctx.r[10].s64 + -28496;
	// 821A8E4C: FBEB0190  std r31, 0x190(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[31].u64 ) };
	// 821A8E50: 912B0058  stw r9, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821A8E54: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821A8E58: 90EB0054  stw r7, 0x54(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821A8E5C: 98CB001C  stb r6, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[6].u8 ) };
	// 821A8E60: 914B005C  stw r10, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821A8E64: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A8E68: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821A8E6C: 419A0008  beq cr6, 0x821a8e74
	if ctx.cr[6].eq {
	pc = 0x821A8E74; continue 'dispatch;
	}
	// 821A8E70: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x821A8E74; continue 'dispatch;
            }
            0x821A8E74 => {
    //   block [0x821A8E74..0x821A8E90)
	// 821A8E74: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A8E78: 912B0194  stw r9, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[9].u32 ) };
	// 821A8E7C: 910B0190  stw r8, 0x190(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[8].u32 ) };
	// 821A8E80: FBEB0188  std r31, 0x188(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(392 as u32), ctx.r[31].u64 ) };
	// 821A8E84: 93EB017C  stw r31, 0x17c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(380 as u32), ctx.r[31].u32 ) };
	// 821A8E88: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8E8C: D00B0184  stfs f0, 0x184(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(388 as u32), tmp.u32 ) };
	pc = 0x821A8E90; continue 'dispatch;
            }
            0x821A8E90 => {
    //   block [0x821A8E90..0x821A8EAC)
	// 821A8E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A8E94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A8E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A8E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A8EA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A8EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A8EA8: 4E800020  blr
	return;
            }
            0x821A8EAC => {
    //   block [0x821A8EAC..0x821A8EB4)
	// 821A8EAC: FBFE0000  std r31, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 821A8EB0: 4BFFFFE0  b 0x821a8e90
	pc = 0x821A8E90; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A8EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A8EE8 size=456
    let mut pc: u32 = 0x821A8EE8;
    'dispatch: loop {
        match pc {
            0x821A8EE8 => {
    //   block [0x821A8EE8..0x821A8F48)
	// 821A8EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A8EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A8EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A8EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A8EF8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821A8EFC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A8F00: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A8F04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A8F08: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A8F0C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A8F10: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821A8F14: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A8F18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A8F1C: 419A0174  beq cr6, 0x821a9090
	if ctx.cr[6].eq {
	pc = 0x821A9090; continue 'dispatch;
	}
	// 821A8F20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A8F24: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8F28: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A8F2C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A8F30: 41990144  bgt cr6, 0x821a9074
	if ctx.cr[6].gt {
	pc = 0x821A9074; continue 'dispatch;
	}
	// 821A8F34: 83DF0118  lwz r30, 0x118(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 821A8F38: 57CB05EE  rlwinm r11, r30, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8F40: 419A0008  beq cr6, 0x821a8f48
	if ctx.cr[6].eq {
	pc = 0x821A8F48; continue 'dispatch;
	}
	// 821A8F44: 57DE07B6  rlwinm r30, r30, 0, 0x1e, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x821A8F48; continue 'dispatch;
            }
            0x821A8F48 => {
    //   block [0x821A8F48..0x821A8F80)
	// 821A8F48: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821A8F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8F50: 419A0054  beq cr6, 0x821a8fa4
	if ctx.cr[6].eq {
	pc = 0x821A8FA4; continue 'dispatch;
	}
	// 821A8F54: 57CB0294  rlwinm r11, r30, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A8F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A8F5C: 419A0024  beq cr6, 0x821a8f80
	if ctx.cr[6].eq {
	pc = 0x821A8F80; continue 'dispatch;
	}
	// 821A8F60: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A8F64: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A8F68: 816BB9E8  lwz r11, -0x4618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17944 as u32) ) } as u64;
	// 821A8F6C: 814AB9EC  lwz r10, -0x4614(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17940 as u32) ) } as u64;
	// 821A8F70: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A8F74: 4098000C  bge cr6, 0x821a8f80
	if !ctx.cr[6].lt {
	pc = 0x821A8F80; continue 'dispatch;
	}
	// 821A8F78: 7C8B5050  subf r4, r11, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821A8F7C: 48000020  b 0x821a8f9c
	pc = 0x821A8F9C; continue 'dispatch;
            }
            0x821A8F80 => {
    //   block [0x821A8F80..0x821A8F9C)
	// 821A8F80: C01F0170  lfs f0, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8F84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821A8F88: C1BF00D0  lfs f13, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8F8C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8F90: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821A8F94: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821A8F98: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821A8F9C; continue 'dispatch;
            }
            0x821A8F9C => {
    //   block [0x821A8F9C..0x821A8FA4)
	// 821A8F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A8FA0: 48000149  bl 0x821a90e8
	ctx.lr = 0x821A8FA4;
	sub_821A90E8(ctx, base);
	pc = 0x821A8FA4; continue 'dispatch;
            }
            0x821A8FA4 => {
    //   block [0x821A8FA4..0x821A8FFC)
	// 821A8FA4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A8FA8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821A8FAC: 397F0170  addi r11, r31, 0x170
	ctx.r[11].s64 = ctx.r[31].s64 + 368;
	// 821A8FB0: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821A8FB4: C14ABA38  lfs f10, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A8FB8: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821A8FBC: 394ABFF0  addi r10, r10, -0x4010
	ctx.r[10].s64 = ctx.r[10].s64 + -16400;
	// 821A8FC0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8FC4: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8FC8: EC0A0024  fdivs f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A8FCC: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821A8FD0: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821A8FD4: 419A0050  beq cr6, 0x821a9024
	if ctx.cr[6].eq {
	pc = 0x821A9024; continue 'dispatch;
	}
	// 821A8FD8: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A8FDC: C1BF00C8  lfs f13, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A8FE0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A8FE4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A8FE8: ED6B602A  fadds f11, f11, f12
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 821A8FEC: 40980010  bge cr6, 0x821a8ffc
	if !ctx.cr[6].lt {
	pc = 0x821A8FFC; continue 'dispatch;
	}
	// 821A8FF0: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 821A8FF4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821A8FF8: 48000008  b 0x821a9000
	pc = 0x821A9000; continue 'dispatch;
            }
            0x821A8FFC => {
    //   block [0x821A8FFC..0x821A9000)
	// 821A8FFC: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	pc = 0x821A9000; continue 'dispatch;
            }
            0x821A9000 => {
    //   block [0x821A9000..0x821A9010)
	// 821A9000: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821A9004: 4199000C  bgt cr6, 0x821a9010
	if ctx.cr[6].gt {
	pc = 0x821A9010; continue 'dispatch;
	}
	// 821A9008: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A900C: FD606090  fmr f11, f12
	ctx.f[11].f64 = ctx.f[12].f64;
	pc = 0x821A9010; continue 'dispatch;
            }
            0x821A9010 => {
    //   block [0x821A9010..0x821A9020)
	// 821A9010: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 821A9014: 4198000C  blt cr6, 0x821a9020
	if ctx.cr[6].lt {
	pc = 0x821A9020; continue 'dispatch;
	}
	// 821A9018: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A901C: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	pc = 0x821A9020; continue 'dispatch;
            }
            0x821A9020 => {
    //   block [0x821A9020..0x821A9024)
	// 821A9020: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821A9024; continue 'dispatch;
            }
            0x821A9024 => {
    //   block [0x821A9024..0x821A9048)
	// 821A9024: 57CB077A  rlwinm r11, r30, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A902C: 419A001C  beq cr6, 0x821a9048
	if ctx.cr[6].eq {
	pc = 0x821A9048; continue 'dispatch;
	}
	// 821A9030: 817F017C  lwz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 821A9034: 815F0180  lwz r10, 0x180(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 821A9038: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A903C: 41980024  blt cr6, 0x821a9060
	if ctx.cr[6].lt {
	pc = 0x821A9060; continue 'dispatch;
	}
	// 821A9040: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821A9044: 4800001C  b 0x821a9060
	pc = 0x821A9060; continue 'dispatch;
            }
            0x821A9048 => {
    //   block [0x821A9048..0x821A9060)
	// 821A9048: 57CB0738  rlwinm r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821A904C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9050: 419A0010  beq cr6, 0x821a9060
	if ctx.cr[6].eq {
	pc = 0x821A9060; continue 'dispatch;
	}
	// 821A9054: C01F0178  lfs f0, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9058: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 821A905C: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	pc = 0x821A9060; continue 'dispatch;
            }
            0x821A9060 => {
    //   block [0x821A9060..0x821A9074)
	// 821A9060: C01F0178  lfs f0, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9064: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821A9068: 41990028  bgt cr6, 0x821a9090
	if ctx.cr[6].gt {
	pc = 0x821A9090; continue 'dispatch;
	}
	// 821A906C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A9070: 48000024  b 0x821a9094
	pc = 0x821A9094; continue 'dispatch;
            }
            0x821A9074 => {
    //   block [0x821A9074..0x821A9090)
	// 821A9074: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A9078: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A907C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A9080: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A9084: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9088: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A908C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	pc = 0x821A9090; continue 'dispatch;
            }
            0x821A9090 => {
    //   block [0x821A9090..0x821A9094)
	// 821A9090: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x821A9094; continue 'dispatch;
            }
            0x821A9094 => {
    //   block [0x821A9094..0x821A90B0)
	// 821A9094: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A9098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A909C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A90A0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821A90A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A90A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A90AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A90E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A90E8 size=1740
    let mut pc: u32 = 0x821A90E8;
    'dispatch: loop {
        match pc {
            0x821A90E8 => {
    //   block [0x821A90E8..0x821A911C)
	// 821A90E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A90EC: 4838BF95  bl 0x82535080
	ctx.lr = 0x821A90F0;
	sub_82535080(ctx, base);
	// 821A90F0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A90F4: 4838CEC9  bl 0x82535fbc
	ctx.lr = 0x821A90F8;
	sub_82535FB0(ctx, base);
	// 821A90F8: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A90FC: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 821A9100: 9081020C  stw r4, 0x20c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), ctx.r[4].u32 ) };
	// 821A9104: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821A9108: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821A910C: 91C10054  stw r14, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[14].u32 ) };
	// 821A9110: 4199000C  bgt cr6, 0x821a911c
	if ctx.cr[6].gt {
	pc = 0x821A911C; continue 'dispatch;
	}
	// 821A9114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A9118: 9161020C  stw r11, 0x20c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	pc = 0x821A911C; continue 'dispatch;
            }
            0x821A911C => {
    //   block [0x821A911C..0x821A913C)
	// 821A911C: 8177018C  lwz r11, 0x18c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(396 as u32) ) } as u64;
	// 821A9120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9124: 419A0018  beq cr6, 0x821a913c
	if ctx.cr[6].eq {
	pc = 0x821A913C; continue 'dispatch;
	}
	// 821A9128: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A912C: 7D705B78  mr r16, r11
	ctx.r[16].u64 = ctx.r[11].u64;
	// 821A9130: 81370188  lwz r9, 0x188(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(392 as u32) ) } as u64;
	// 821A9134: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9138: 419A0008  beq cr6, 0x821a9140
	if ctx.cr[6].eq {
	pc = 0x821A9140; continue 'dispatch;
	}
	pc = 0x821A913C; continue 'dispatch;
            }
            0x821A913C => {
    //   block [0x821A913C..0x821A9140)
	// 821A913C: 7DD07378  mr r16, r14
	ctx.r[16].u64 = ctx.r[14].u64;
	pc = 0x821A9140; continue 'dispatch;
            }
            0x821A9140 => {
    //   block [0x821A9140..0x821A91E8)
	// 821A9140: 8161020C  lwz r11, 0x20c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 821A9144: 83170118  lwz r24, 0x118(r23)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(280 as u32) ) } as u64;
	// 821A9148: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821A914C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9150: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A9154: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821A9158: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821A915C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9160: C30BBA38  lfs f24, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A9164: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A9168: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A916C: EE380024  fdivs f17, f24, f0
	ctx.f[17].f64 = ((ctx.f[24].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A9170: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9174: EFF10032  fmuls f31, f17, f0
	ctx.f[31].f64 = (((ctx.f[17].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9178: 4099061C  ble cr6, 0x821a9794
	if !ctx.cr[6].gt {
	pc = 0x821A9794; continue 'dispatch;
	}
	// 821A917C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A9180: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A9184: 396BD6D0  addi r11, r11, -0x2930
	ctx.r[11].s64 = ctx.r[11].s64 + -10544;
	// 821A9188: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821A918C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821A9190: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A9194: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A9198: 3A4ADBD0  addi r18, r10, -0x2430
	ctx.r[18].s64 = ctx.r[10].s64 + -9264;
	// 821A919C: C2ABFB48  lfs f21, -0x4b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A91A0: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821A91A4: C28B0000  lfs f20, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A91A8: C2671FF8  lfs f19, 0x1ff8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821A91AC: 3DE08286  lis r15, -0x7d7a
	ctx.r[15].s64 = -2105147392;
	// 821A91B0: C2C82280  lfs f22, 0x2280(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8832 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A91B4: 3A6A14A0  addi r19, r10, 0x14a0
	ctx.r[19].s64 = ctx.r[10].s64 + 5280;
	// 821A91B8: C24920B0  lfs f18, 0x20b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8368 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 821A91BC: 3A800030  li r20, 0x30
	ctx.r[20].s64 = 48;
	// 821A91C0: C2E6D6C8  lfs f23, -0x2938(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A91C4: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 821A91C8: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 821A91CC: 3A20003F  li r17, 0x3f
	ctx.r[17].s64 = 63;
	// 821A91D0: 570B06B4  rlwinm r11, r24, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A91D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A91D8: 419A0010  beq cr6, 0x821a91e8
	if ctx.cr[6].eq {
	pc = 0x821A91E8; continue 'dispatch;
	}
	// 821A91DC: C0170178  lfs f0, 0x178(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A91E0: EC2004B2  fmuls f1, f0, f18
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[18].f64) as f32) as f64);
	// 821A91E4: 4800002C  b 0x821a9210
	pc = 0x821A9210; continue 'dispatch;
            }
            0x821A91E8 => {
    //   block [0x821A91E8..0x821A9210)
	// 821A91E8: 481BDF51  bl 0x82367138
	ctx.lr = 0x821A91EC;
	sub_82367138(ctx, base);
	// 821A91EC: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A91F0: C1B70114  lfs f13, 0x114(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A91F4: C1970110  lfs f12, 0x110(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A91F8: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 821A91FC: C80100D0  lfd f0, 0xd0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 821A9200: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9204: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A9208: EC0005B2  fmuls f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 821A920C: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	pc = 0x821A9210; continue 'dispatch;
            }
            0x821A9210 => {
    //   block [0x821A9210..0x821A922C)
	// 821A9210: 570B039C  rlwinm r11, r24, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9214: FC409890  fmr f2, f19
	ctx.f[2].f64 = ctx.f[19].f64;
	// 821A9218: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 821A921C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9220: 419A000C  beq cr6, 0x821a922c
	if ctx.cr[6].eq {
	pc = 0x821A922C; continue 'dispatch;
	}
	// 821A9224: FC60C090  fmr f3, f24
	ctx.f[3].f64 = ctx.f[24].f64;
	// 821A9228: 48000008  b 0x821a9230
	pc = 0x821A9230; continue 'dispatch;
            }
            0x821A922C => {
    //   block [0x821A922C..0x821A9230)
	// 821A922C: FC609890  fmr f3, f19
	ctx.f[3].f64 = ctx.f[19].f64;
	pc = 0x821A9230; continue 'dispatch;
            }
            0x821A9230 => {
    //   block [0x821A9230..0x821A9260)
	// 821A9230: 4BFFFA41  bl 0x821a8c70
	ctx.lr = 0x821A9234;
	sub_821A8C70(ctx, base);
	// 821A9234: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821A9238: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821A923C: 419A0558  beq cr6, 0x821a9794
	if ctx.cr[6].eq {
	pc = 0x821A9794; continue 'dispatch;
	}
	// 821A9240: 570B0294  rlwinm r11, r24, 0, 0xa, 0xa
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9248: 419A0018  beq cr6, 0x821a9260
	if ctx.cr[6].eq {
	pc = 0x821A9260; continue 'dispatch;
	}
	// 821A924C: 816FFBAC  lwz r11, -0x454(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-1108 as u32) ) } as u64;
	// 821A9250: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9254: 4198000C  blt cr6, 0x821a9260
	if ctx.cr[6].lt {
	pc = 0x821A9260; continue 'dispatch;
	}
	// 821A9258: B1790012  sth r11, 0x12(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 821A925C: 48000010  b 0x821a926c
	pc = 0x821A926C; continue 'dispatch;
            }
            0x821A9260 => {
    //   block [0x821A9260..0x821A926C)
	// 821A9260: 3877011C  addi r3, r23, 0x11c
	ctx.r[3].s64 = ctx.r[23].s64 + 284;
	// 821A9264: 4BFFA785  bl 0x821a39e8
	ctx.lr = 0x821A9268;
	sub_821A39E8(ctx, base);
	// 821A9268: B0790012  sth r3, 0x12(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(18 as u32), ctx.r[3].u16 ) };
	pc = 0x821A926C; continue 'dispatch;
            }
            0x821A926C => {
    //   block [0x821A926C..0x821A92C0)
	// 821A926C: 817000AC  lwz r11, 0xac(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A9270: 3BF90060  addi r31, r25, 0x60
	ctx.r[31].s64 = ctx.r[25].s64 + 96;
	// 821A9274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9278: 419A0064  beq cr6, 0x821a92dc
	if ctx.cr[6].eq {
	pc = 0x821A92DC; continue 'dispatch;
	}
	// 821A927C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9280: 813000A8  lwz r9, 0xa8(r16)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A9284: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9288: 409A0054  bne cr6, 0x821a92dc
	if !ctx.cr[6].eq {
	pc = 0x821A92DC; continue 'dispatch;
	}
	// 821A928C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A9290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9294: 419A0048  beq cr6, 0x821a92dc
	if ctx.cr[6].eq {
	pc = 0x821A92DC; continue 'dispatch;
	}
	// 821A9298: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A929C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A92A0: 419A0020  beq cr6, 0x821a92c0
	if ctx.cr[6].eq {
	pc = 0x821A92C0; continue 'dispatch;
	}
	// 821A92A4: 730A8040  andi. r10, r24, 0x8040
	ctx.r[10].u64 = ctx.r[24].u64 & 32832;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A92A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A92AC: 409A0014  bne cr6, 0x821a92c0
	if !ctx.cr[6].eq {
	pc = 0x821A92C0; continue 'dispatch;
	}
	// 821A92B0: D27F0008  stfs f19, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A92B4: D27F0004  stfs f19, 4(r31)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A92B8: D27F0000  stfs f19, 0(r31)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A92BC: 48000374  b 0x821a9630
	pc = 0x821A9630; continue 'dispatch;
            }
            0x821A92C0 => {
    //   block [0x821A92C0..0x821A92DC)
	// 821A92C0: C00B0060  lfs f0, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A92C4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A92C8: C00B0064  lfs f0, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A92CC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A92D0: C00B0068  lfs f0, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A92D4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A92D8: 48000358  b 0x821a9630
	pc = 0x821A9630; continue 'dispatch;
            }
            0x821A92DC => {
    //   block [0x821A92DC..0x821A9304)
	// 821A92DC: 730B8040  andi. r11, r24, 0x8040
	ctx.r[11].u64 = ctx.r[24].u64 & 32832;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A92E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A92E4: 419A0318  beq cr6, 0x821a95fc
	if ctx.cr[6].eq {
	pc = 0x821A95FC; continue 'dispatch;
	}
	// 821A92E8: 8177018C  lwz r11, 0x18c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(396 as u32) ) } as u64;
	// 821A92EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A92F0: 419A0014  beq cr6, 0x821a9304
	if ctx.cr[6].eq {
	pc = 0x821A9304; continue 'dispatch;
	}
	// 821A92F4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A92F8: 81370188  lwz r9, 0x188(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(392 as u32) ) } as u64;
	// 821A92FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9300: 419A0008  beq cr6, 0x821a9308
	if ctx.cr[6].eq {
	pc = 0x821A9308; continue 'dispatch;
	}
	pc = 0x821A9304; continue 'dispatch;
            }
            0x821A9304 => {
    //   block [0x821A9304..0x821A9308)
	// 821A9304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821A9308; continue 'dispatch;
            }
            0x821A9308 => {
    //   block [0x821A9308..0x821A95FC)
	// 821A9308: A1590012  lhz r10, 0x12(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[25].u32.wrapping_add(18 as u32) ) } as u64;
	// 821A930C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A9310: 83CB00CC  lwz r30, 0xcc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 821A9314: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821A9318: 7D440734  extsh r4, r10
	ctx.r[4].s64 = ctx.r[10].s16 as i64;
	// 821A931C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821A9320: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A9324: 4BFFA7E5  bl 0x821a3b08
	ctx.lr = 0x821A9328;
	sub_821A3B08(ctx, base);
	// 821A9328: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A932C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A9330: 3B9E0030  addi r28, r30, 0x30
	ctx.r[28].s64 = ctx.r[30].s64 + 48;
	// 821A9334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A9338: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821A933C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A9340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A9344: 4E800421  bctrl
	ctx.lr = 0x821A9348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A9348: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821A934C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A9350: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9354: 3B5B0010  addi r26, r27, 0x10
	ctx.r[26].s64 = ctx.r[27].s64 + 16;
	// 821A9358: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A935C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            0x821A95FC => {
    //   block [0x821A95FC..0x821A9630)
	// 821A95FC: 570B07BC  rlwinm r11, r24, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821A9600: 38770130  addi r3, r23, 0x130
	ctx.r[3].s64 = ctx.r[23].s64 + 304;
	// 821A9604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9608: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A960C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A9610: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A9614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A9618: 419A000C  beq cr6, 0x821a9624
	if ctx.cr[6].eq {
	pc = 0x821A9624; continue 'dispatch;
	}
	// 821A961C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821A9620: 48000008  b 0x821a9628
	pc = 0x821A9628; continue 'dispatch;
	// 821A9624: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A9628: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A962C: 4E800421  bctrl
	ctx.lr = 0x821A9630;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821A9630 => {
    //   block [0x821A9630..0x821A9794)
	// 821A9630: 3BD70080  addi r30, r23, 0x80
	ctx.r[30].s64 = ctx.r[23].s64 + 128;
	// 821A9634: 3BB70160  addi r29, r23, 0x160
	ctx.r[29].s64 = ctx.r[23].s64 + 352;
	// 821A9638: 38990160  addi r4, r25, 0x160
	ctx.r[4].s64 = ctx.r[25].s64 + 352;
	// 821A963C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821A9640: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821A9644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A9648: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821A964C: 4BFF75ED  bl 0x821a0c38
	ctx.lr = 0x821A9650;
	sub_821A0C38(ctx, base);
	// 821A9650: 481BDAE9  bl 0x82367138
	ctx.lr = 0x821A9654;
	sub_82367138(ctx, base);
	// 821A9654: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A9658: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A965C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A9660: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A9664: 57090630  rlwinm r9, r24, 0, 0x18, 0x18
	ctx.r[9].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x821A9794; continue 'dispatch;
            }
            0x821A9794 => {
    //   block [0x821A9794..0x821A97B4)
	// 821A9794: 8177017C  lwz r11, 0x17c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(380 as u32) ) } as u64;
	// 821A9798: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 821A979C: 7D6B7214  add r11, r11, r14
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 821A97A0: 9177017C  stw r11, 0x17c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 821A97A4: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821A97A8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821A97AC: 4838C85D  bl 0x82536008
	ctx.lr = 0x821A97B0;
	sub_82535FFC(ctx, base);
	// 821A97B0: 4838B920  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A97B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A97B8 size=332
    let mut pc: u32 = 0x821A97B8;
    'dispatch: loop {
        match pc {
            0x821A97B8 => {
    //   block [0x821A97B8..0x821A9800)
	// 821A97B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A97BC: 4838B8F5  bl 0x825350b0
	ctx.lr = 0x821A97C0;
	sub_82535080(ctx, base);
	// 821A97C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A97C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A97C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A97CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A97D0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821A97D4: 38EB0E8C  addi r7, r11, 0xe8c
	ctx.r[7].s64 = ctx.r[11].s64 + 3724;
	// 821A97D8: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821A97DC: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 821A97E0: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A97E4: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 821A97E8: 481C0CA9  bl 0x8236a490
	ctx.lr = 0x821A97EC;
	sub_8236A490(ctx, base);
	// 821A97EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A97F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A97F4: 419A000C  beq cr6, 0x821a9800
	if ctx.cr[6].eq {
	pc = 0x821A9800; continue 'dispatch;
	}
	// 821A97F8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A97FC: 48000008  b 0x821a9804
	pc = 0x821A9804; continue 'dispatch;
            }
            0x821A9800 => {
    //   block [0x821A9800..0x821A9804)
	// 821A9800: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A9804; continue 'dispatch;
            }
            0x821A9804 => {
    //   block [0x821A9804..0x821A9864)
	// 821A9804: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A9808: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A980C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A9810: 419A0084  beq cr6, 0x821a9894
	if ctx.cr[6].eq {
	pc = 0x821A9894; continue 'dispatch;
	}
	// 821A9814: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A9818: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821A981C: 396B0EA0  addi r11, r11, 0xea0
	ctx.r[11].s64 = ctx.r[11].s64 + 3744;
	// 821A9820: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A9824: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 821A9828: 57643032  slwi r4, r27, 6
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A982C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A9830: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A9834: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821A9838: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 821A983C: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821A9840: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821A9844: FB9F0098  std r28, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u64 ) };
	// 821A9848: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821A984C: FB9F00A0  std r28, 0xa0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[28].u64 ) };
	// 821A9850: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821A9854: 4BFF83DD  bl 0x821a1c30
	ctx.lr = 0x821A9858;
	sub_821A1C30(ctx, base);
	// 821A9858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A985C: 409A0048  bne cr6, 0x821a98a4
	if !ctx.cr[6].eq {
	pc = 0x821A98A4; continue 'dispatch;
	}
	// 821A9860: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821A9864; continue 'dispatch;
            }
            0x821A9864 => {
    //   block [0x821A9864..0x821A9894)
	// 821A9864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9868: 419A002C  beq cr6, 0x821a9894
	if ctx.cr[6].eq {
	pc = 0x821A9894; continue 'dispatch;
	}
	// 821A986C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9870: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A9874: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9878: 409A001C  bne cr6, 0x821a9894
	if !ctx.cr[6].eq {
	pc = 0x821A9894; continue 'dispatch;
	}
	// 821A987C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A9880: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A9884: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A9888: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821A988C: 9B4B0025  stb r26, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821A9890: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821A9894; continue 'dispatch;
            }
            0x821A9894 => {
    //   block [0x821A9894..0x821A98A4)
	// 821A9894: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821A9898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A989C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A98A0: 4838B860  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A98A4 => {
    //   block [0x821A98A4..0x821A98DC)
	// 821A98A4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A98A8: 38BF0094  addi r5, r31, 0x94
	ctx.r[5].s64 = ctx.r[31].s64 + 148;
	// 821A98AC: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821A98B0: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 821A98B4: 4BFF837D  bl 0x821a1c30
	ctx.lr = 0x821A98B8;
	sub_821A1C30(ctx, base);
	// 821A98B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A98BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A98C0: 419AFFA4  beq cr6, 0x821a9864
	if ctx.cr[6].eq {
	pc = 0x821A9864; continue 'dispatch;
	}
	// 821A98C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A98C8: 419A0014  beq cr6, 0x821a98dc
	if ctx.cr[6].eq {
	pc = 0x821A98DC; continue 'dispatch;
	}
	// 821A98CC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A98D0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A98D4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A98D8: 419A0008  beq cr6, 0x821a98e0
	if ctx.cr[6].eq {
	pc = 0x821A98E0; continue 'dispatch;
	}
	pc = 0x821A98DC; continue 'dispatch;
            }
            0x821A98DC => {
    //   block [0x821A98DC..0x821A98E0)
	// 821A98DC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A98E0; continue 'dispatch;
            }
            0x821A98E0 => {
    //   block [0x821A98E0..0x821A9904)
	// 821A98E0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A98E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A98E8: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821A98EC: 915F00A0  stw r10, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821A98F0: FB9F0098  std r28, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u64 ) };
	// 821A98F4: 937F0088  stw r27, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 821A98F8: 939F008C  stw r28, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 821A98FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A9900: 4838B800  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A9908 size=348
    let mut pc: u32 = 0x821A9908;
    'dispatch: loop {
        match pc {
            0x821A9908 => {
    //   block [0x821A9908..0x821A9928)
	// 821A9908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A990C: 4838B7A5  bl 0x825350b0
	ctx.lr = 0x821A9910;
	sub_82535080(ctx, base);
	// 821A9910: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A9914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A9918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A991C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A9920: 419A0008  beq cr6, 0x821a9928
	if ctx.cr[6].eq {
	pc = 0x821A9928; continue 'dispatch;
	}
	// 821A9924: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	pc = 0x821A9928; continue 'dispatch;
            }
            0x821A9928 => {
    //   block [0x821A9928..0x821A9A58)
	// 821A9928: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A992C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A9930: 38EB0E94  addi r7, r11, 0xe94
	ctx.r[7].s64 = ctx.r[11].s64 + 3732;
	// 821A9934: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A9938: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A993C: 38600108  li r3, 0x108
	ctx.r[3].s64 = 264;
	// 821A9940: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A9944: 481C0B4D  bl 0x8236a490
	ctx.lr = 0x821A9948;
	sub_8236A490(ctx, base);
	// 821A9948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A994C: 419A010C  beq cr6, 0x821a9a58
	if ctx.cr[6].eq {
	pc = 0x821A9A58; continue 'dispatch;
	}
	// 821A9950: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821A9954: 811E008C  lwz r8, 0x8c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9958: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 821A995C: 80FE0094  lwz r7, 0x94(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A9960: 80DE0090  lwz r6, 0x90(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A9964: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 821A9968: 3CA08288  lis r5, -0x7d78
	ctx.r[5].s64 = -2105016320;
	// 821A996C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 821A9970: C009BA38  lfs f0, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9974: 3D2082CF  lis r9, -0x7d31
	ctx.r[9].s64 = -2100363264;
	// 821A9978: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 821A997C: 38A58E40  addi r5, r5, -0x71c0
	ctx.r[5].s64 = ctx.r[5].s64 + -29120;
	// 821A9980: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 821A9984: 3929C470  addi r9, r9, -0x3b90
	ctx.r[9].s64 = ctx.r[9].s64 + -15248;
	// 821A9988: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 821A998C: 3FA0820C  lis r29, -0x7df4
	ctx.r[29].s64 = -2113142784;
	// 821A9990: FBEB0018  std r31, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 821A9994: 3B690228  addi r27, r9, 0x228
	ctx.r[27].s64 = ctx.r[9].s64 + 552;
	// 821A9998: FBEB0020  std r31, 0x20(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 821A999C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A99A0: FBEB0028  std r31, 0x28(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[31].u64 ) };
	// 821A99A4: 38843B44  addi r4, r4, 0x3b44
	ctx.r[4].s64 = ctx.r[4].s64 + 15172;
	// 821A99A8: FBEB0030  std r31, 0x30(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[31].u64 ) };
	// 821A99AC: 394300E0  addi r10, r3, 0xe0
	ctx.r[10].s64 = ctx.r[3].s64 + 224;
	// 821A99B0: FBEB0038  std r31, 0x38(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[31].u64 ) };
	// 821A99B4: 3BBD3B80  addi r29, r29, 0x3b80
	ctx.r[29].s64 = ctx.r[29].s64 + 15232;
	// 821A99B8: 93EB0040  stw r31, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A99BC: B3EB0044  sth r31, 0x44(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[31].u16 ) };
	// 821A99C0: B3EB0046  sth r31, 0x46(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(70 as u32), ctx.r[31].u16 ) };
	// 821A99C4: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A99C8: A3430014  lhz r26, 0x14(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A99CC: 93630080  stw r27, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 821A99D0: 539A1EDE  rlwimi r26, r28, 3, 0x1b, 0xf
	ctx.r[26].u64 = (((ctx.r[28].u32).rotate_left(3) as u64) & 0xFFFFFFFFFFFF001F) | (ctx.r[26].u64 & 0x000000000000FFE0);
	// 821A99D4: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 821A99D8: 9923001D  stb r9, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[9].u8 ) };
	// 821A99DC: 9923001E  stb r9, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 821A99E0: 90A300D0  stw r5, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[5].u32 ) };
	// 821A99E4: B3430014  sth r26, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[26].u16 ) };
	// 821A99E8: 93EB0048  stw r31, 0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 821A99EC: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 821A99F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821A99F4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821A99F8: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821A99FC: 396B8E38  addi r11, r11, -0x71c8
	ctx.r[11].s64 = ctx.r[11].s64 + -29128;
	// 821A9A00: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821A9A04: B3EA0008  sth r31, 8(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[31].u16 ) };
	// 821A9A08: B3EA000A  sth r31, 0xa(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[31].u16 ) };
	// 821A9A0C: 93EA000C  stw r31, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 821A9A10: B3EA0010  sth r31, 0x10(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[31].u16 ) };
	// 821A9A14: B3EA0012  sth r31, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[31].u16 ) };
	// 821A9A18: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 821A9A1C: 910300F8  stw r8, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[8].u32 ) };
	// 821A9A20: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 821A9A24: 394A7790  addi r10, r10, 0x7790
	ctx.r[10].s64 = ctx.r[10].s64 + 30608;
	// 821A9A28: 90C30100  stw r6, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[6].u32 ) };
	// 821A9A2C: 90E300FC  stw r7, 0xfc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 821A9A30: 91030088  stw r8, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 821A9A34: 916300E4  stw r11, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 821A9A38: B12300E8  sth r9, 0xe8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[9].u16 ) };
	// 821A9A3C: B3E300EA  sth r31, 0xea(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(234 as u32), ctx.r[31].u16 ) };
	// 821A9A40: 914300EC  stw r10, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 821A9A44: B12300F0  sth r9, 0xf0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[9].u16 ) };
	// 821A9A48: B3E300F2  sth r31, 0xf2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(242 as u32), ctx.r[31].u16 ) };
	// 821A9A4C: 907E00A8  stw r3, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 821A9A50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A9A54: 4838B6AC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A9A58 => {
    //   block [0x821A9A58..0x821A9A64)
	// 821A9A58: 93FE00A8  stw r31, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 821A9A5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A9A60: 4838B6A0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A9A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A9A68 size=1488
    let mut pc: u32 = 0x821A9A68;
    'dispatch: loop {
        match pc {
            0x821A9A68 => {
    //   block [0x821A9A68..0x821A9AB8)
	// 821A9A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A9A6C: 4838B641  bl 0x825350ac
	ctx.lr = 0x821A9A70;
	sub_82535080(ctx, base);
	// 821A9A70: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821A9A74: 4838C551  bl 0x82535fc4
	ctx.lr = 0x821A9A78;
	sub_82535FB0(ctx, base);
	// 821A9A78: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A9A7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A9A80: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821A9A84: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A9A88: 933E0040  stw r25, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[25].u32 ) };
	// 821A9A8C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A9A90: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A9A94: 419A0594  beq cr6, 0x821aa028
	if ctx.cr[6].eq {
	pc = 0x821AA028; continue 'dispatch;
	}
	// 821A9A98: 817E009C  lwz r11, 0x9c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A9A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9AA0: 419A0018  beq cr6, 0x821a9ab8
	if ctx.cr[6].eq {
	pc = 0x821A9AB8; continue 'dispatch;
	}
	// 821A9AA4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9AA8: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 821A9AAC: 813E0098  lwz r9, 0x98(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A9AB0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9AB4: 419A0008  beq cr6, 0x821a9abc
	if ctx.cr[6].eq {
	pc = 0x821A9ABC; continue 'dispatch;
	}
	pc = 0x821A9AB8; continue 'dispatch;
            }
            0x821A9AB8 => {
    //   block [0x821A9AB8..0x821A9ABC)
	// 821A9AB8: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	pc = 0x821A9ABC; continue 'dispatch;
            }
            0x821A9ABC => {
    //   block [0x821A9ABC..0x821A9B04)
	// 821A9ABC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A9AC0: 817A00AC  lwz r11, 0xac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(172 as u32) ) } as u64;
	// 821A9AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9AC8: C30A1FF8  lfs f24, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821A9ACC: 419A0038  beq cr6, 0x821a9b04
	if ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AD0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A9AD4: 813A00A8  lwz r9, 0xa8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(168 as u32) ) } as u64;
	// 821A9AD8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A9ADC: 409A0028  bne cr6, 0x821a9b04
	if !ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AE0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A9AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9AE8: 419A001C  beq cr6, 0x821a9b04
	if ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AEC: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A9AF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A9AF4: 419A0010  beq cr6, 0x821a9b04
	if ctx.cr[6].eq {
	pc = 0x821A9B04; continue 'dispatch;
	}
	// 821A9AF8: C26B0060  lfs f19, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821A9AFC: C28B0068  lfs f20, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821A9B00: 4800000C  b 0x821a9b0c
	pc = 0x821A9B0C; continue 'dispatch;
            }
            0x821A9B04 => {
    //   block [0x821A9B04..0x821A9B0C)
	// 821A9B04: FE80C090  fmr f20, f24
	ctx.f[20].f64 = ctx.f[24].f64;
	// 821A9B08: FE60C090  fmr f19, f24
	ctx.f[19].f64 = ctx.f[24].f64;
	pc = 0x821A9B0C; continue 'dispatch;
            }
            0x821A9B0C => {
    //   block [0x821A9B0C..0x821A9B40)
	// 821A9B0C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9B10: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821A9B14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9B18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A9B1C: C34B2280  lfs f26, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821A9B20: 4099011C  ble cr6, 0x821a9c3c
	if !ctx.cr[6].gt {
	pc = 0x821A9C3C; continue 'dispatch;
	}
	// 821A9B24: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A9B28: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821A9B2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A9B30: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 821A9B34: C0E9207C  lfs f7, 0x207c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8316 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821A9B38: C12AD478  lfs f9, -0x2b88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821A9B3C: C10BD6C8  lfs f8, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	pc = 0x821A9B40; continue 'dispatch;
            }
            0x821A9B40 => {
    //   block [0x821A9B40..0x821A9C28)
	// 821A9B40: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A9B44: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A9B48: 481BD5F1  bl 0x82367138
	ctx.lr = 0x821A9B4C;
	sub_82367138(ctx, base);
	// 821A9B4C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A9B50: 813E0088  lwz r9, 0x88(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A9B54: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 821A9B58: C1840008  lfs f12, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A9B5C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A9B60: ECCC0332  fmuls f6, f12, f12
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821A9B64: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9B68: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A9B6C: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 821A9B70: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821A9B74: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821A9B78: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 821A9B7C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9B80: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821A9B84: ECCD337A  fmadds f6, f13, f13, f6
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64);
	// 821A9B88: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A9B8C: ECCB32FA  fmadds f6, f11, f11, f6
	ctx.f[6].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64);
	// 821A9B90: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 821A9B94: EC004A3A  fmadds f0, f0, f8, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64);
	// 821A9B98: C9410068  lfd f10, 0x68(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821A9B9C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 821A9BA0: C8A10060  lfd f5, 0x60(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A9BA4: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 821A9BA8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821A9BAC: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821A9BB0: ECA55024  fdivs f5, f5, f10
	ctx.f[5].f64 = ((ctx.f[5].f64 / ctx.f[10].f64) as f32) as f64;
	// 821A9BB4: ED40302C  fsqrts f10, f6
	ctx.f[10].f64 = ((ctx.f[6].f64).sqrt() as f32) as f64;
	// 821A9BB8: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BBC: ECC549FA  fmadds f6, f5, f7, f9
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 821A9BC0: FF0A3000  fcmpu cr6, f10, f6
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[6].f64);
	// 821A9BC4: 40980064  bge cr6, 0x821a9c28
	if !ctx.cr[6].lt {
	pc = 0x821A9C28; continue 'dispatch;
	}
	// 821A9BC8: C1440010  lfs f10, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821A9BCC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BD0: C0C40014  lfs f6, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821A9BD4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BD8: C0A40018  lfs f5, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821A9BDC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BE0: C0840020  lfs f4, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821A9BE4: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BE8: C0640024  lfs f3, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821A9BEC: ECC60032  fmuls f6, f6, f0
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9BF0: C0440028  lfs f2, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A9BF4: ECA00172  fmuls f5, f0, f5
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 821A9BF8: D1640000  stfs f11, 0(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A9BFC: ED640032  fmuls f11, f4, f0
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9C00: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A9C04: EDA000F2  fmuls f13, f0, f3
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[3].f64) as f32) as f64);
	// 821A9C08: EC020032  fmuls f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A9C0C: D1840008  stfs f12, 8(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A9C10: D1440010  stfs f10, 0x10(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821A9C14: D0C40014  stfs f6, 0x14(r4)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821A9C18: D0A40018  stfs f5, 0x18(r4)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821A9C1C: D1640020  stfs f11, 0x20(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821A9C20: D1A40024  stfs f13, 0x24(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821A9C24: D0040028  stfs f0, 0x28(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x821A9C28; continue 'dispatch;
            }
            0x821A9C28 => {
    //   block [0x821A9C28..0x821A9C3C)
	// 821A9C28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821A9C2C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9C30: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 821A9C34: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A9C38: 4198FF08  blt cr6, 0x821a9b40
	if ctx.cr[6].lt {
	pc = 0x821A9B40; continue 'dispatch;
	}
	pc = 0x821A9C3C; continue 'dispatch;
            }
            0x821A9C3C => {
    //   block [0x821A9C3C..0x821A9C50)
	// 821A9C3C: 817A0084  lwz r11, 0x84(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A9C40: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A9C44: 409A000C  bne cr6, 0x821a9c50
	if !ctx.cr[6].eq {
	pc = 0x821A9C50; continue 'dispatch;
	}
	// 821A9C48: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821A9C4C: 4800000C  b 0x821a9c58
	pc = 0x821A9C58; continue 'dispatch;
            }
            0x821A9C50 => {
    //   block [0x821A9C50..0x821A9C58)
	// 821A9C50: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9C54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A9C58; continue 'dispatch;
            }
            0x821A9C58 => {
    //   block [0x821A9C58..0x821A9D04)
	// 821A9C58: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821A9C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9C60: 419A03BC  beq cr6, 0x821aa01c
	if ctx.cr[6].eq {
	pc = 0x821AA01C; continue 'dispatch;
	}
	// 821A9C64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A9C68: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821A9C6C: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 821A9C70: 3CE08288  lis r7, -0x7d78
	ctx.r[7].s64 = -2105016320;
	// 821A9C74: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821A9C78: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A9C7C: 3B8ADBD0  addi r28, r10, -0x2430
	ctx.r[28].s64 = ctx.r[10].s64 + -9264;
	// 821A9C80: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821A9C84: C2AB000C  lfs f21, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 821A9C88: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A9C8C: C2E82190  lfs f23, 0x2190(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8592 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821A9C90: 3B6AD040  addi r27, r10, -0x2fc0
	ctx.r[27].s64 = ctx.r[10].s64 + -12224;
	// 821A9C94: C2C92194  lfs f22, 0x2194(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8596 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821A9C98: C327D560  lfs f25, -0x2aa0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821A9C9C: 815E008C  lwz r10, 0x8c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A9CA0: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A9CA4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821A9CA8: 4098034C  bge cr6, 0x821a9ff4
	if !ctx.cr[6].lt {
	pc = 0x821A9FF4; continue 'dispatch;
	}
	// 821A9CAC: 817A0094  lwz r11, 0x94(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A9CB0: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A9CB4: 813E0090  lwz r9, 0x90(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A9CB8: 390B0006  addi r8, r11, 6
	ctx.r[8].s64 = ctx.r[11].s64 + 6;
	// 821A9CBC: 897C0001  lbz r11, 1(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A9CC0: 7FEA4A14  add r31, r10, r9
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A9CC4: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 821A9CC8: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A9CCC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821A9CD0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821A9CD4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A9CD8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A9CDC: EF80982A  fadds f28, f0, f19
	ctx.f[28].f64 = ((ctx.f[0].f64 + ctx.f[19].f64) as f32) as f64;
	// 821A9CE0: EF6DA02A  fadds f27, f13, f20
	ctx.f[27].f64 = ((ctx.f[13].f64 + ctx.f[20].f64) as f32) as f64;
	// 821A9CE4: D3810080  stfs f28, 0x80(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A9CE8: D3610088  stfs f27, 0x88(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821A9CEC: 40990018  ble cr6, 0x821a9d04
	if !ctx.cr[6].gt {
	pc = 0x821A9D04; continue 'dispatch;
	}
	// 821A9CF0: 897C0002  lbz r11, 2(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A9CF4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A9CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A9CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A9D00: 41990008  bgt cr6, 0x821a9d08
	if ctx.cr[6].gt {
	pc = 0x821A9D08; continue 'dispatch;
	}
	pc = 0x821A9D04; continue 'dispatch;
            }
            0x821A9D04 => {
    //   block [0x821A9D04..0x821A9D08)
	// 821A9D04: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821A9D08; continue 'dispatch;
            }
            0x821A9D08 => {
    //   block [0x821A9D08..0x821A9D24)
	// 821A9D08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A9D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A9D10: 409A004C  bne cr6, 0x821a9d5c
	if !ctx.cr[6].eq {
	pc = 0x821A9D5C; continue 'dispatch;
	}
	// 821A9D14: FF1CB000  fcmpu cr6, f28, f22
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[22].f64);
	// 821A9D18: 4098000C  bge cr6, 0x821a9d24
	if !ctx.cr[6].lt {
	pc = 0x821A9D24; continue 'dispatch;
	}
	// 821A9D1C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D20: 48000058  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
            }
            0x821A9D24 => {
    //   block [0x821A9D24..0x821A9D34)
	// 821A9D24: FF1CA800  fcmpu cr6, f28, f21
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[21].f64);
	// 821A9D28: 4099000C  ble cr6, 0x821a9d34
	if !ctx.cr[6].gt {
	pc = 0x821A9D34; continue 'dispatch;
	}
	// 821A9D2C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D30: 48000048  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
            }
            0x821A9D34 => {
    //   block [0x821A9D34..0x821A9D44)
	// 821A9D34: FF1BB000  fcmpu cr6, f27, f22
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[22].f64);
	// 821A9D38: 4098000C  bge cr6, 0x821a9d44
	if !ctx.cr[6].lt {
	pc = 0x821A9D44; continue 'dispatch;
	}
	// 821A9D3C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D40: 48000038  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
            }
            0x821A9D44 => {
    //   block [0x821A9D44..0x821A9D54)
	// 821A9D44: FF1BA800  fcmpu cr6, f27, f21
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[21].f64);
	// 821A9D48: 4099000C  ble cr6, 0x821a9d54
	if !ctx.cr[6].gt {
	pc = 0x821A9D54; continue 'dispatch;
	}
	// 821A9D4C: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 821A9D50: 48000028  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
            }
            0x821A9D54 => {
    //   block [0x821A9D54..0x821A9D5C)
	// 821A9D54: FFC0C090  fmr f30, f24
	ctx.f[30].f64 = ctx.f[24].f64;
	// 821A9D58: 48000020  b 0x821a9d78
	pc = 0x821A9D78; continue 'dispatch;
            }
            0x821A9D5C => {
    //   block [0x821A9D5C..0x821A9D78)
	// 821A9D5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A9D60: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 821A9D64: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A9D68: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A9D6C: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 821A9D70: 4800D7C1  bl 0x821b7530
	ctx.lr = 0x821A9D74;
	sub_821B7530(ctx, base);
	// 821A9D74: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x821A9D78; continue 'dispatch;
            }
            0x821A9D78 => {
    //   block [0x821A9D78..0x821A9FF4)
	// 821A9D78: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A9D7C: 481BD3BD  bl 0x82367138
	ctx.lr = 0x821A9D80;
	sub_82367138(ctx, base);
	// 821A9D80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A9D84: FC20C090  fmr f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[24].f64;
	// 821A9D88: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821A9D8C: 796B0260  clrldi r11, r11, 0x29
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000007FFFFFu64;
	// 821A9D90: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A9D94: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821A9D98: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A9D9C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A9DA0: EFA006B2  fmuls f29, f0, f26
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 821A9DA4: 481BE0ED  bl 0x82367e90
	ctx.lr = 0x821A9DA8;
	sub_82367E90(ctx, base);
	// 821A9DA8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A9DAC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821A9DB0: 481BE209  bl 0x82367fb8
	ctx.lr = 0x821A9DB4;
	sub_82367FB8(ctx, base);
	// 821A9DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A9DB8: FC20C090  fmr f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[24].f64;
	// 821A9DBC: 481BE32D  bl 0x823680e8
	ctx.lr = 0x821A9DC0;
	sub_823680E8(ctx, base);
	// 821A9DC0: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	pc = 0x821A9FF4; continue 'dispatch;
            }
            0x821A9FF4 => {
    //   block [0x821A9FF4..0x821AA01C)
	// 821A9FF4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A9FF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821A9FFC: 409A000C  bne cr6, 0x821aa008
	if !ctx.cr[6].eq {
	pc = 0x821AA008; continue 'dispatch;
	}
	// 821AA000: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821AA004: 4800000C  b 0x821aa010
	pc = 0x821AA010; continue 'dispatch;
	// 821AA008: 815A008C  lwz r10, 0x8c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA00C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AA010: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821AA014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA018: 409AFC84  bne cr6, 0x821a9c9c
	if !ctx.cr[6].eq {
	pc = 0x821A9C9C; continue 'dispatch;
	}
            }
            0x821AA01C => {
    //   block [0x821AA01C..0x821AA028)
	// 821AA01C: 817E00A8  lwz r11, 0xa8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 821AA020: 815E008C  lwz r10, 0x8c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA024: 914B00F8  stw r10, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	pc = 0x821AA028; continue 'dispatch;
            }
            0x821AA028 => {
    //   block [0x821AA028..0x821AA038)
	// 821AA028: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 821AA02C: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821AA030: 4838BFE1  bl 0x82536010
	ctx.lr = 0x821AA034;
	sub_82535FFC(ctx, base);
	// 821AA034: 4838B0C8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA038 size=104
    let mut pc: u32 = 0x821AA038;
    'dispatch: loop {
        match pc {
            0x821AA038 => {
    //   block [0x821AA038..0x821AA070)
	// 821AA038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA050: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 821AA054: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA05C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA060: 3BCBC470  addi r30, r11, -0x3b90
	ctx.r[30].s64 = ctx.r[11].s64 + -15248;
	// 821AA064: 419A000C  beq cr6, 0x821aa070
	if ctx.cr[6].eq {
	pc = 0x821AA070; continue 'dispatch;
	}
	// 821AA068: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821AA06C: 4BFF8015  bl 0x821a2080
	ctx.lr = 0x821AA070;
	sub_821A2080(ctx, base);
	pc = 0x821AA070; continue 'dispatch;
            }
            0x821AA070 => {
    //   block [0x821AA070..0x821AA088)
	// 821AA070: 389F0094  addi r4, r31, 0x94
	ctx.r[4].s64 = ctx.r[31].s64 + 148;
	// 821AA074: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA07C: 419A000C  beq cr6, 0x821aa088
	if ctx.cr[6].eq {
	pc = 0x821AA088; continue 'dispatch;
	}
	// 821AA080: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821AA084: 4BFF7FFD  bl 0x821a2080
	ctx.lr = 0x821AA088;
	sub_821A2080(ctx, base);
	pc = 0x821AA088; continue 'dispatch;
            }
            0x821AA088 => {
    //   block [0x821AA088..0x821AA0A0)
	// 821AA088: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA08C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA094: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AA098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA09C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA0A0 size=356
    let mut pc: u32 = 0x821AA0A0;
    'dispatch: loop {
        match pc {
            0x821AA0A0 => {
    //   block [0x821AA0A0..0x821AA0E8)
	// 821AA0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA0A4: 4838B011  bl 0x825350b4
	ctx.lr = 0x821AA0A8;
	sub_82535080(ctx, base);
	// 821AA0A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AA0B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821AA0B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AA0B8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821AA0BC: 38EB0EC0  addi r7, r11, 0xec0
	ctx.r[7].s64 = ctx.r[11].s64 + 3776;
	// 821AA0C0: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 821AA0C4: 38A00385  li r5, 0x385
	ctx.r[5].s64 = 901;
	// 821AA0C8: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821AA0CC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 821AA0D0: 481C03C1  bl 0x8236a490
	ctx.lr = 0x821AA0D4;
	sub_8236A490(ctx, base);
	// 821AA0D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AA0D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA0DC: 419A000C  beq cr6, 0x821aa0e8
	if ctx.cr[6].eq {
	pc = 0x821AA0E8; continue 'dispatch;
	}
	// 821AA0E0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA0E4: 48000008  b 0x821aa0ec
	pc = 0x821AA0EC; continue 'dispatch;
            }
            0x821AA0E8 => {
    //   block [0x821AA0E8..0x821AA0EC)
	// 821AA0E8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821AA0EC; continue 'dispatch;
            }
            0x821AA0EC => {
    //   block [0x821AA0EC..0x821AA1B0)
	// 821AA0EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA0F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AA0F4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821AA0F8: 419A00B8  beq cr6, 0x821aa1b0
	if ctx.cr[6].eq {
	pc = 0x821AA1B0; continue 'dispatch;
	}
	// 821AA0FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AA100: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AA104: 396B0EC8  addi r11, r11, 0xec8
	ctx.r[11].s64 = ctx.r[11].s64 + 3784;
	// 821AA108: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AA10C: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821AA110: 3908A208  addi r8, r8, -0x5df8
	ctx.r[8].s64 = ctx.r[8].s64 + -24056;
	// 821AA114: 3929A2F0  addi r9, r9, -0x5d10
	ctx.r[9].s64 = ctx.r[9].s64 + -23824;
	// 821AA118: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AA11C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA120: 939F0080  stw r28, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 821AA124: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821AA128: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AA12C: B39F0084  sth r28, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[28].u16 ) };
	// 821AA130: B39F0086  sth r28, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[28].u16 ) };
	// 821AA134: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AA138: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821AA13C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AA140: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AA144: FB9F00E0  std r28, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[28].u64 ) };
	// 821AA148: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA14C: FB9F00E8  std r28, 0xe8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[28].u64 ) };
	// 821AA150: 394AA338  addi r10, r10, -0x5cc8
	ctx.r[10].s64 = ctx.r[10].s64 + -23752;
	// 821AA154: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821AA158: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821AA15C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821AA160: 38BF00C0  addi r5, r31, 0xc0
	ctx.r[5].s64 = ctx.r[31].s64 + 192;
	// 821AA164: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821AA168: 55642834  slwi r4, r11, 5
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821AA16C: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AA170: 4BFF7AC1  bl 0x821a1c30
	ctx.lr = 0x821AA174;
	sub_821A1C30(ctx, base);
	// 821AA174: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA17C: 409A0044  bne cr6, 0x821aa1c0
	if !ctx.cr[6].eq {
	pc = 0x821AA1C0; continue 'dispatch;
	}
	// 821AA180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA184: 419A002C  beq cr6, 0x821aa1b0
	if ctx.cr[6].eq {
	pc = 0x821AA1B0; continue 'dispatch;
	}
	// 821AA188: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA18C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA190: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA194: 409A001C  bne cr6, 0x821aa1b0
	if !ctx.cr[6].eq {
	pc = 0x821AA1B0; continue 'dispatch;
	}
	// 821AA198: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AA19C: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA1A0: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821AA1A4: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AA1A8: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821AA1AC: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821AA1B0; continue 'dispatch;
            }
            0x821AA1B0 => {
    //   block [0x821AA1B0..0x821AA1C0)
	// 821AA1B0: FB9E0000  std r28, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821AA1B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AA1B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AA1BC: 4838AF48  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821AA1C0 => {
    //   block [0x821AA1C0..0x821AA1D8)
	// 821AA1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA1C4: 419A0014  beq cr6, 0x821aa1d8
	if ctx.cr[6].eq {
	pc = 0x821AA1D8; continue 'dispatch;
	}
	// 821AA1C8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA1CC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA1D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA1D4: 419A0008  beq cr6, 0x821aa1dc
	if ctx.cr[6].eq {
	pc = 0x821AA1DC; continue 'dispatch;
	}
	pc = 0x821AA1D8; continue 'dispatch;
            }
            0x821AA1D8 => {
    //   block [0x821AA1D8..0x821AA1DC)
	// 821AA1D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821AA1DC; continue 'dispatch;
            }
            0x821AA1DC => {
    //   block [0x821AA1DC..0x821AA204)
	// 821AA1DC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA1E0: 393F00D0  addi r9, r31, 0xd0
	ctx.r[9].s64 = ctx.r[31].s64 + 208;
	// 821AA1E4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 821AA1E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AA1EC: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 821AA1F0: FB9F00E0  std r28, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[28].u64 ) };
	// 821AA1F4: 93BF00C4  stw r29, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[29].u32 ) };
	// 821AA1F8: 913F00CC  stw r9, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[9].u32 ) };
	// 821AA1FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AA200: 4838AF04  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA208 size=232
    let mut pc: u32 = 0x821AA208;
    'dispatch: loop {
        match pc {
            0x821AA208 => {
    //   block [0x821AA208..0x821AA22C)
	// 821AA208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA210: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA214: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AA218: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AA21C: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AA220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AA224: 419A0008  beq cr6, 0x821aa22c
	if ctx.cr[6].eq {
	pc = 0x821AA22C; continue 'dispatch;
	}
	// 821AA228: 91230040  stw r9, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	pc = 0x821AA22C; continue 'dispatch;
            }
            0x821AA22C => {
    //   block [0x821AA22C..0x821AA27C)
	// 821AA22C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821AA230: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AA234: 396B8E40  addi r11, r11, -0x71c0
	ctx.r[11].s64 = ctx.r[11].s64 + -29120;
	// 821AA238: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821AA23C: 38E00160  li r7, 0x160
	ctx.r[7].s64 = 352;
	// 821AA240: 9943001E  stb r10, 0x1e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(30 as u32), ctx.r[10].u8 ) };
	// 821AA244: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821AA248: B1230084  sth r9, 0x84(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u16 ) };
	// 821AA24C: B1230086  sth r9, 0x86(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(134 as u32), ctx.r[9].u16 ) };
	// 821AA250: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AA254: 91030090  stw r8, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 821AA258: 90E300A4  stw r7, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821AA25C: 916300B8  stw r11, 0xb8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 821AA260: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA264: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821AA268: 556B0030  rlwinm r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA26C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA270: 419A000C  beq cr6, 0x821aa27c
	if ctx.cr[6].eq {
	pc = 0x821AA27C; continue 'dispatch;
	}
	// 821AA274: 9143008C  stw r10, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 821AA278: 4800000C  b 0x821aa284
	pc = 0x821AA284; continue 'dispatch;
            }
            0x821AA27C => {
    //   block [0x821AA27C..0x821AA284)
	// 821AA27C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821AA280: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	pc = 0x821AA284; continue 'dispatch;
            }
            0x821AA284 => {
    //   block [0x821AA284..0x821AA2A0)
	// 821AA284: 814300C8  lwz r10, 0xc8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA288: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821AA28C: 556B0672  rlwinm r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA294: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 821AA298: 409A0008  bne cr6, 0x821aa2a0
	if !ctx.cr[6].eq {
	pc = 0x821AA2A0; continue 'dispatch;
	}
	// 821AA29C: 39600022  li r11, 0x22
	ctx.r[11].s64 = 34;
	pc = 0x821AA2A0; continue 'dispatch;
            }
            0x821AA2A0 => {
    //   block [0x821AA2A0..0x821AA2D4)
	// 821AA2A0: 916300AC  stw r11, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 821AA2A4: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA2A8: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AA2AC: 3D080504  addis r8, r8, 0x504
	ctx.r[8].s64 = ctx.r[8].s64 + 84148224;
	// 821AA2B0: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA2B4: 39084000  addi r8, r8, 0x4000
	ctx.r[8].s64 = ctx.r[8].s64 + 16384;
	// 821AA2B8: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821AA2BC: 91030088  stw r8, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 821AA2C0: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AA2C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AA2C8: 409A000C  bne cr6, 0x821aa2d4
	if !ctx.cr[6].eq {
	pc = 0x821AA2D4; continue 'dispatch;
	}
	// 821AA2CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA2D0: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	pc = 0x821AA2D4; continue 'dispatch;
            }
            0x821AA2D4 => {
    //   block [0x821AA2D4..0x821AA2F0)
	// 821AA2D4: 912300A0  stw r9, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821AA2D8: 480000A9  bl 0x821aa380
	ctx.lr = 0x821AA2DC;
	sub_821AA380(ctx, base);
	// 821AA2DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA2E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AA2E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA2E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA2F0 size=68
    let mut pc: u32 = 0x821AA2F0;
    'dispatch: loop {
        match pc {
            0x821AA2F0 => {
    //   block [0x821AA2F0..0x821AA320)
	// 821AA2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA2F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA2FC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AA300: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AA304: 806BFAC0  lwz r3, -0x540(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AA308: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AA30C: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AA310: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AA314: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AA318: 419A0008  beq cr6, 0x821aa320
	if ctx.cr[6].eq {
	pc = 0x821AA320; continue 'dispatch;
	}
	// 821AA31C: 4800021D  bl 0x821aa538
	ctx.lr = 0x821AA320;
	sub_821AA538(ctx, base);
	pc = 0x821AA320; continue 'dispatch;
            }
            0x821AA320 => {
    //   block [0x821AA320..0x821AA334)
	// 821AA320: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AA328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AA338 size=72
    let mut pc: u32 = 0x821AA338;
    'dispatch: loop {
        match pc {
            0x821AA338 => {
    //   block [0x821AA338..0x821AA36C)
	// 821AA338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA340: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA344: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AA348: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AA34C: 388B00C0  addi r4, r11, 0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + 192;
	// 821AA350: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AA354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA358: 419A0014  beq cr6, 0x821aa36c
	if ctx.cr[6].eq {
	pc = 0x821AA36C; continue 'dispatch;
	}
	// 821AA35C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA360: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AA364: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AA368: 4BFF7D19  bl 0x821a2080
	ctx.lr = 0x821AA36C;
	sub_821A2080(ctx, base);
	pc = 0x821AA36C; continue 'dispatch;
            }
            0x821AA36C => {
    //   block [0x821AA36C..0x821AA380)
	// 821AA36C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA370: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AA374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AA380 size=436
    let mut pc: u32 = 0x821AA380;
    'dispatch: loop {
        match pc {
            0x821AA380 => {
    //   block [0x821AA380..0x821AA3BC)
	// 821AA380: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821AA384: 80C300C4  lwz r6, 0xc4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AA388: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AA38C: 814300C0  lwz r10, 0xc0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AA390: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AA394: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 821AA398: C1A8BA38  lfs f13, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA39C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA3A0: 41980130  blt cr6, 0x821aa4d0
	if ctx.cr[6].lt {
	pc = 0x821AA4D0; continue 'dispatch;
	}
	// 821AA3A4: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 821AA3A8: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA3AC: 396A0028  addi r11, r10, 0x28
	ctx.r[11].s64 = ctx.r[10].s64 + 40;
	// 821AA3B0: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 821AA3B4: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA3B8: 7CC83050  subf r6, r8, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	pc = 0x821AA3BC; continue 'dispatch;
            }
            0x821AA3BC => {
    //   block [0x821AA3BC..0x821AA4D0)
	// 821AA3BC: D1ABFFF4  stfs f13, -0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AA3C0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 821AA3C4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AA3C8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AA3CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AA3D0: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AA3D4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AA3D8: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA3DC: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA3E0: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AA3E4: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA3E8: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AA3EC: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA3F0: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AA3F4: 810BFFDC  lwz r8, -0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 821AA3F8: D1AB0054  stfs f13, 0x54(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821AA3FC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AA400: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA404: 394A0180  addi r10, r10, 0x180
	ctx.r[10].s64 = ctx.r[10].s64 + 384;
	// 821AA408: 910BFFDC  stw r8, -0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-36 as u32), ctx.r[8].u32 ) };
	// 821AA40C: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821AA410: D00B0060  stfs f0, 0x60(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821AA414: D00B005C  stfs f0, 0x5c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821AA418: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821AA41C: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA420: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA424: D18B0068  stfs f12, 0x68(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821AA428: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA42C: D18B006C  stfs f12, 0x6c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821AA430: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA434: D18B0070  stfs f12, 0x70(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821AA438: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821AA43C: D1AB00B4  stfs f13, 0xb4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AA440: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 821AA444: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA448: 910B003C  stw r8, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 821AA44C: D00B00C4  stfs f0, 0xc4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 821AA450: D00B00C0  stfs f0, 0xc0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 821AA454: D00B00BC  stfs f0, 0xbc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821AA458: D00B00B8  stfs f0, 0xb8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AA45C: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA460: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA464: D18B00C8  stfs f12, 0xc8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 821AA468: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA46C: D18B00CC  stfs f12, 0xcc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 821AA470: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA474: D18B00D0  stfs f12, 0xd0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821AA478: 810B009C  lwz r8, 0x9c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AA47C: D1AB0114  stfs f13, 0x114(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821AA480: 912B0098  stw r9, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 821AA484: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA488: 910B009C  stw r8, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[8].u32 ) };
	// 821AA48C: D00B0124  stfs f0, 0x124(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 821AA490: D00B0120  stfs f0, 0x120(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 821AA494: D00B011C  stfs f0, 0x11c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 821AA498: D00B0118  stfs f0, 0x118(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 821AA49C: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA4A0: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA4A4: D18B0128  stfs f12, 0x128(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 821AA4A8: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA4AC: D18B012C  stfs f12, 0x12c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 821AA4B0: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA4B4: D18B0130  stfs f12, 0x130(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 821AA4B8: 810B00FC  lwz r8, 0xfc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 821AA4BC: 912B00F8  stw r9, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[9].u32 ) };
	// 821AA4C0: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA4C4: 910B00FC  stw r8, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[8].u32 ) };
	// 821AA4C8: 396B0180  addi r11, r11, 0x180
	ctx.r[11].s64 = ctx.r[11].s64 + 384;
	// 821AA4CC: 409AFEF0  bne cr6, 0x821aa3bc
	if !ctx.cr[6].eq {
	pc = 0x821AA3BC; continue 'dispatch;
	}
	pc = 0x821AA4D0; continue 'dispatch;
            }
            0x821AA4D0 => {
    //   block [0x821AA4D0..0x821AA4DC)
	// 821AA4D0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821AA4D4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 821AA4D8: 396A0028  addi r11, r10, 0x28
	ctx.r[11].s64 = ctx.r[10].s64 + 40;
	pc = 0x821AA4DC; continue 'dispatch;
            }
            0x821AA4DC => {
    //   block [0x821AA4DC..0x821AA534)
	// 821AA4DC: D1ABFFF4  stfs f13, -0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AA4E0: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 821AA4E4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AA4E8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AA4EC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821AA4F0: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AA4F4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AA4F8: 810300CC  lwz r8, 0xcc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA4FC: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA500: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AA504: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA508: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AA50C: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA510: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AA514: 810BFFDC  lwz r8, -0x24(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 821AA518: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AA51C: 394A0060  addi r10, r10, 0x60
	ctx.r[10].s64 = ctx.r[10].s64 + 96;
	// 821AA520: 550800BE  clrlwi r8, r8, 2
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x3FFFFFFFu64;
	// 821AA524: 910BFFDC  stw r8, -0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-36 as u32), ctx.r[8].u32 ) };
	// 821AA528: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 821AA52C: 4199FFB0  bgt cr6, 0x821aa4dc
	if ctx.cr[6].gt {
	pc = 0x821AA4DC; continue 'dispatch;
	}
	// 821AA530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA538 size=868
    let mut pc: u32 = 0x821AA538;
    'dispatch: loop {
        match pc {
            0x821AA538 => {
    //   block [0x821AA538..0x821AA56C)
	// 821AA538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA53C: 4838AB75  bl 0x825350b0
	ctx.lr = 0x821AA540;
	sub_82535080(ctx, base);
	// 821AA540: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA544: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821AA548: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821AA54C: 817C00E4  lwz r11, 0xe4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 821AA550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA554: 419A0018  beq cr6, 0x821aa56c
	if ctx.cr[6].eq {
	pc = 0x821AA56C; continue 'dispatch;
	}
	// 821AA558: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA55C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821AA560: 813C00E0  lwz r9, 0xe0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) } as u64;
	// 821AA564: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA568: 419A0008  beq cr6, 0x821aa570
	if ctx.cr[6].eq {
	pc = 0x821AA570; continue 'dispatch;
	}
	pc = 0x821AA56C; continue 'dispatch;
            }
            0x821AA56C => {
    //   block [0x821AA56C..0x821AA570)
	// 821AA56C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x821AA570; continue 'dispatch;
            }
            0x821AA570 => {
    //   block [0x821AA570..0x821AA5BC)
	// 821AA570: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AA574: 817D00AC  lwz r11, 0xac(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(172 as u32) ) } as u64;
	// 821AA578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA57C: C14A1FF8  lfs f10, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AA580: 419A003C  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA584: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AA588: 813D00A8  lwz r9, 0xa8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) } as u64;
	// 821AA58C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AA590: 409A002C  bne cr6, 0x821aa5bc
	if !ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA594: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821AA598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA59C: 419A0020  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA5A0: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821AA5A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AA5A8: 419A0014  beq cr6, 0x821aa5bc
	if ctx.cr[6].eq {
	pc = 0x821AA5BC; continue 'dispatch;
	}
	// 821AA5AC: C0EB0060  lfs f7, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AA5B0: C10B0064  lfs f8, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AA5B4: C12B0068  lfs f9, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AA5B8: 48000010  b 0x821aa5c8
	pc = 0x821AA5C8; continue 'dispatch;
            }
            0x821AA5BC => {
    //   block [0x821AA5BC..0x821AA5C8)
	// 821AA5BC: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 821AA5C0: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 821AA5C4: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	pc = 0x821AA5C8; continue 'dispatch;
            }
            0x821AA5C8 => {
    //   block [0x821AA5C8..0x821AA5E0)
	// 821AA5C8: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AA5CC: 837C00C0  lwz r27, 0xc0(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AA5D0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA5D4: 409A000C  bne cr6, 0x821aa5e0
	if !ctx.cr[6].eq {
	pc = 0x821AA5E0; continue 'dispatch;
	}
	// 821AA5D8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821AA5DC: 4800000C  b 0x821aa5e8
	pc = 0x821AA5E8; continue 'dispatch;
            }
            0x821AA5E0 => {
    //   block [0x821AA5E0..0x821AA5E8)
	// 821AA5E0: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA5E4: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AA5E8; continue 'dispatch;
            }
            0x821AA5E8 => {
    //   block [0x821AA5E8..0x821AA5FC)
	// 821AA5E8: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 821AA5EC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA5F0: 409A000C  bne cr6, 0x821aa5fc
	if !ctx.cr[6].eq {
	pc = 0x821AA5FC; continue 'dispatch;
	}
	// 821AA5F4: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821AA5F8: 4800000C  b 0x821aa604
	pc = 0x821AA604; continue 'dispatch;
            }
            0x821AA5FC => {
    //   block [0x821AA5FC..0x821AA604)
	// 821AA5FC: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA600: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AA604; continue 'dispatch;
            }
            0x821AA604 => {
    //   block [0x821AA604..0x821AA610)
	// 821AA604: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821AA608: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AA60C: 419A0040  beq cr6, 0x821aa64c
	if ctx.cr[6].eq {
	pc = 0x821AA64C; continue 'dispatch;
	}
	pc = 0x821AA610; continue 'dispatch;
            }
            0x821AA610 => {
    //   block [0x821AA610..0x821AA63C)
	// 821AA610: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA614: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821AA618: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AA61C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AA620: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA624: 7F4BD92E  stwx r26, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[26].u32) };
	// 821AA628: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA62C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA630: 409A000C  bne cr6, 0x821aa63c
	if !ctx.cr[6].eq {
	pc = 0x821AA63C; continue 'dispatch;
	}
	// 821AA634: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821AA638: 4800000C  b 0x821aa644
	pc = 0x821AA644; continue 'dispatch;
            }
            0x821AA63C => {
    //   block [0x821AA63C..0x821AA644)
	// 821AA63C: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA640: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AA644; continue 'dispatch;
            }
            0x821AA644 => {
    //   block [0x821AA644..0x821AA64C)
	// 821AA644: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AA648: 409AFFC8  bne cr6, 0x821aa610
	if !ctx.cr[6].eq {
	pc = 0x821AA610; continue 'dispatch;
	}
	pc = 0x821AA64C; continue 'dispatch;
            }
            0x821AA64C => {
    //   block [0x821AA64C..0x821AA664)
	// 821AA64C: 83DC00C8  lwz r30, 0xc8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA650: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA654: 913C00BC  stw r9, 0xbc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(188 as u32), ctx.r[9].u32 ) };
	// 821AA658: 419A023C  beq cr6, 0x821aa894
	if ctx.cr[6].eq {
	pc = 0x821AA894; continue 'dispatch;
	}
	// 821AA65C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AA660: C0CBBA38  lfs f6, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	pc = 0x821AA664; continue 'dispatch;
            }
            0x821AA664 => {
    //   block [0x821AA664..0x821AA6B8)
	// 821AA664: A15F0010  lhz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AA668: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA66C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA670: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AA674: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AA678: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA67C: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821AA680: 419A0044  beq cr6, 0x821aa6c4
	if ctx.cr[6].eq {
	pc = 0x821AA6C4; continue 'dispatch;
	}
	// 821AA684: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821AA688: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AA68C: 48000215  bl 0x821aa8a0
	ctx.lr = 0x821AA690;
	sub_821AA8A0(ctx, base);
	// 821AA690: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA694: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821AA698: 40990020  ble cr6, 0x821aa6b8
	if !ctx.cr[6].gt {
	pc = 0x821AA6B8; continue 'dispatch;
	}
	// 821AA69C: 481BCA9D  bl 0x82367138
	ctx.lr = 0x821AA6A0;
	sub_82367138(ctx, base);
	// 821AA6A0: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA6A4: 7D435B96  divwu r10, r3, r11
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 821AA6A8: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AA6AC: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821AA6B0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821AA6B4: 48000008  b 0x821aa6bc
	pc = 0x821AA6BC; continue 'dispatch;
            }
            0x821AA6B8 => {
    //   block [0x821AA6B8..0x821AA6BC)
	// 821AA6B8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821AA6BC; continue 'dispatch;
            }
            0x821AA6BC => {
    //   block [0x821AA6BC..0x821AA6C4)
	// 821AA6BC: B17F0198  sth r11, 0x198(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u16 ) };
	// 821AA6C0: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	pc = 0x821AA6C4; continue 'dispatch;
            }
            0x821AA6C4 => {
    //   block [0x821AA6C4..0x821AA6F8)
	// 821AA6C4: 817D0098  lwz r11, 0x98(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AA6C8: 395F001C  addi r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 + 28;
	// 821AA6CC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AA6D0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA6D4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA6D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA6DC: 419A001C  beq cr6, 0x821aa6f8
	if ctx.cr[6].eq {
	pc = 0x821AA6F8; continue 'dispatch;
	}
	// 821AA6E0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821AA6E4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA6E8: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821AA6EC: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AA6F0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA6F4: 7C084C2E  lfsx f0, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AA6F8; continue 'dispatch;
            }
            0x821AA6F8 => {
    //   block [0x821AA6F8..0x821AA72C)
	// 821AA6F8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AA6FC: D0040048  stfs f0, 0x48(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821AA700: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 821AA704: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA708: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA70C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AA710: 419A001C  beq cr6, 0x821aa72c
	if ctx.cr[6].eq {
	pc = 0x821AA72C; continue 'dispatch;
	}
	// 821AA714: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821AA718: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA71C: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821AA720: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AA724: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA728: 7C08542E  lfsx f0, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AA72C; continue 'dispatch;
            }
            0x821AA72C => {
    //   block [0x821AA72C..0x821AA760)
	// 821AA72C: 394B0020  addi r10, r11, 0x20
	ctx.r[10].s64 = ctx.r[11].s64 + 32;
	// 821AA730: D004004C  stfs f0, 0x4c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821AA734: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 821AA738: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AA73C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA740: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AA744: 419A001C  beq cr6, 0x821aa760
	if ctx.cr[6].eq {
	pc = 0x821AA760; continue 'dispatch;
	}
	// 821AA748: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 821AA74C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA750: 7C0047AE  stfiwx f0, 0, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 821AA754: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AA758: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AA75C: 7C084C2E  lfsx f0, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AA760; continue 'dispatch;
            }
            0x821AA760 => {
    //   block [0x821AA760..0x821AA790)
	// 821AA760: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821AA764: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AA768: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821AA76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA770: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA774: 419A001C  beq cr6, 0x821aa790
	if ctx.cr[6].eq {
	pc = 0x821AA790; continue 'dispatch;
	}
	// 821AA778: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 821AA77C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA780: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 821AA784: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AA788: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AA78C: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AA790; continue 'dispatch;
            }
            0x821AA790 => {
    //   block [0x821AA790..0x821AA79C)
	// 821AA790: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821AA794: 40980008  bge cr6, 0x821aa79c
	if !ctx.cr[6].lt {
	pc = 0x821AA79C; continue 'dispatch;
	}
	// 821AA798: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x821AA79C; continue 'dispatch;
            }
            0x821AA79C => {
    //   block [0x821AA79C..0x821AA810)
	// 821AA79C: A17F0198  lhz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 821AA7A0: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821AA7A4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AA7A8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA7AC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AA7B0: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 821AA7B4: A12B0010  lhz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AA7B8: 7CEB07B4  extsw r11, r7
	ctx.r[11].s64 = ctx.r[7].s32 as i64;
	// 821AA7BC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821AA7C0: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821AA7C4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821AA7C8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821AA7CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA7D0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821AA7D4: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 821AA7D8: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 821AA7DC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AA7E0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821AA7E4: F9640050  std r11, 0x50(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA7E8: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA7EC: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AA7F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA7F4: 419A001C  beq cr6, 0x821aa810
	if ctx.cr[6].eq {
	pc = 0x821AA810; continue 'dispatch;
	}
	// 821AA7F8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821AA7FC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821AA800: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 821AA804: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821AA808: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AA80C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AA810; continue 'dispatch;
            }
            0x821AA810 => {
    //   block [0x821AA810..0x821AA82C)
	// 821AA810: 817D00A0  lwz r11, 0xa0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AA814: 556B018C  rlwinm r11, r11, 0, 6, 6
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA81C: 419A0010  beq cr6, 0x821aa82c
	if ctx.cr[6].eq {
	pc = 0x821AA82C; continue 'dispatch;
	}
	// 821AA820: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 821AA824: 40990008  ble cr6, 0x821aa82c
	if !ctx.cr[6].gt {
	pc = 0x821AA82C; continue 'dispatch;
	}
	// 821AA828: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	pc = 0x821AA82C; continue 'dispatch;
            }
            0x821AA82C => {
    //   block [0x821AA82C..0x821AA884)
	// 821AA82C: 817C00CC  lwz r11, 0xcc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AA830: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA834: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA838: D004003C  stfs f0, 0x3c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821AA83C: 817D0094  lwz r11, 0x94(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 821AA840: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 821AA844: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AA848: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821AA84C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA850: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AA854: D0040010  stfs f0, 0x10(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AA858: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA85C: EC00402A  fadds f0, f0, f8
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 821AA860: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821AA864: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA868: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 821AA86C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821AA870: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA874: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AA878: 409A000C  bne cr6, 0x821aa884
	if !ctx.cr[6].eq {
	pc = 0x821AA884; continue 'dispatch;
	}
	// 821AA87C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 821AA880: 4800000C  b 0x821aa88c
	pc = 0x821AA88C; continue 'dispatch;
            }
            0x821AA884 => {
    //   block [0x821AA884..0x821AA88C)
	// 821AA884: 815D008C  lwz r10, 0x8c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821AA888: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AA88C; continue 'dispatch;
            }
            0x821AA88C => {
    //   block [0x821AA88C..0x821AA894)
	// 821AA88C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AA890: 409AFDD4  bne cr6, 0x821aa664
	if !ctx.cr[6].eq {
	pc = 0x821AA664; continue 'dispatch;
	}
	pc = 0x821AA894; continue 'dispatch;
            }
            0x821AA894 => {
    //   block [0x821AA894..0x821AA89C)
	// 821AA894: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821AA898: 4838A868  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA8A0 size=268
    let mut pc: u32 = 0x821AA8A0;
    'dispatch: loop {
        match pc {
            0x821AA8A0 => {
    //   block [0x821AA8A0..0x821AA948)
	// 821AA8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AA8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821AA8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AA8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AA8B4: C0050180  lfs f0, 0x180(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AA8BC: D0040040  stfs f0, 0x40(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821AA8C0: C0050184  lfs f0, 0x184(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA8C4: D0040044  stfs f0, 0x44(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821AA8C8: C0050184  lfs f0, 0x184(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA8CC: C1A50180  lfs f13, 0x180(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA8D0: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AA8D4: C185018C  lfs f12, 0x18c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(396 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AA8D8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AA8DC: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821AA8E0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AA8E4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821AA8E8: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AA8EC: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA8F0: 8BEB0014  lbz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AA8F4: 57EB0030  rlwinm r11, r31, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA8FC: 419A008C  beq cr6, 0x821aa988
	if ctx.cr[6].eq {
	pc = 0x821AA988; continue 'dispatch;
	}
	// 821AA900: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 821AA904: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AA908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA90C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AA910: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AA914: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AA918: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AA91C: 419A002C  beq cr6, 0x821aa948
	if ctx.cr[6].eq {
	pc = 0x821AA948; continue 'dispatch;
	}
	// 821AA920: 481BC819  bl 0x82367138
	ctx.lr = 0x821AA924;
	sub_82367138(ctx, base);
	// 821AA924: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AA928: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA92C: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA930: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821AA934: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821AA938: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA93C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821AA940: 40990008  ble cr6, 0x821aa948
	if !ctx.cr[6].gt {
	pc = 0x821AA948; continue 'dispatch;
	}
	// 821AA944: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x821AA948; continue 'dispatch;
            }
            0x821AA948 => {
    //   block [0x821AA948..0x821AA97C)
	// 821AA948: 57EB07BC  rlwinm r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA94C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA950: 419A002C  beq cr6, 0x821aa97c
	if ctx.cr[6].eq {
	pc = 0x821AA97C; continue 'dispatch;
	}
	// 821AA954: 481BC7E5  bl 0x82367138
	ctx.lr = 0x821AA958;
	sub_82367138(ctx, base);
	// 821AA958: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AA95C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AA960: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AA964: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821AA968: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821AA96C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AA970: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821AA974: 40990008  ble cr6, 0x821aa97c
	if !ctx.cr[6].gt {
	pc = 0x821AA97C; continue 'dispatch;
	}
	// 821AA978: 63DE0002  ori r30, r30, 2
	ctx.r[30].u64 = ctx.r[30].u64 | 2;
	pc = 0x821AA97C; continue 'dispatch;
            }
            0x821AA97C => {
    //   block [0x821AA97C..0x821AA988)
	// 821AA97C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA980: 53CBE086  rlwimi r11, r30, 0x1c, 2, 3
	ctx.r[11].u64 = (((ctx.r[30].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[11].u64 & 0xFFFFFFFFCFFFFFFF);
	// 821AA984: 4800000C  b 0x821aa990
	pc = 0x821AA990; continue 'dispatch;
            }
            0x821AA988 => {
    //   block [0x821AA988..0x821AA990)
	// 821AA988: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AA98C: 53EBE086  rlwimi r11, r31, 0x1c, 2, 3
	ctx.r[11].u64 = (((ctx.r[31].u32).rotate_left(28) as u64) & 0x0000000030000000) | (ctx.r[11].u64 & 0xFFFFFFFFCFFFFFFF);
	pc = 0x821AA990; continue 'dispatch;
            }
            0x821AA990 => {
    //   block [0x821AA990..0x821AA9AC)
	// 821AA990: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821AA994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AA998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AA99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AA9A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821AA9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AA9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AA9B0 size=60
    let mut pc: u32 = 0x821AA9B0;
    'dispatch: loop {
        match pc {
            0x821AA9B0 => {
    //   block [0x821AA9B0..0x821AA9EC)
	// 821AA9B0: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AA9B4: 38E30088  addi r7, r3, 0x88
	ctx.r[7].s64 = ctx.r[3].s64 + 136;
	// 821AA9B8: 810300C0  lwz r8, 0xc0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AA9BC: 38C30080  addi r6, r3, 0x80
	ctx.r[6].s64 = ctx.r[3].s64 + 128;
	// 821AA9C0: 80A300BC  lwz r5, 0xbc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AA9C4: 808300B8  lwz r4, 0xb8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AA9C8: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821AA9CC: 556B0030  rlwinm r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AA9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AA9D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AA9D8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AA9DC: 392B0060  addi r9, r11, 0x60
	ctx.r[9].s64 = ctx.r[11].s64 + 96;
	// 821AA9E0: 419A000C  beq cr6, 0x821aa9ec
	if ctx.cr[6].eq {
		sub_821AA9EC(ctx, base);
		return;
	}
	// 821AA9E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AA9E8: 481C3658  b 0x8236e040
	sub_8236E040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA9EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AA9EC size=8
    let mut pc: u32 = 0x821AA9EC;
    'dispatch: loop {
        match pc {
            0x821AA9EC => {
    //   block [0x821AA9EC..0x821AA9F4)
	// 821AA9EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AA9F0: 481C3650  b 0x8236e040
	sub_8236E040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AA9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AA9F8 size=1888
    let mut pc: u32 = 0x821AA9F8;
    'dispatch: loop {
        match pc {
            0x821AA9F8 => {
    //   block [0x821AA9F8..0x821AAA60)
	// 821AA9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AA9FC: 4838A699  bl 0x82535094
	ctx.lr = 0x821AAA00;
	sub_82535080(ctx, base);
	// 821AAA00: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 821AAA04: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AAA08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AAA0C: 9141016C  stw r10, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[10].u32 ) };
	// 821AAA10: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AAA14: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 821AAA18: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA1C: 396B1E50  addi r11, r11, 0x1e50
	ctx.r[11].s64 = ctx.r[11].s64 + 7760;
	// 821AAA20: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 821AAA24: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 821AAA28: 81010174  lwz r8, 0x174(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 821AAA2C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA30: 7D354B78  mr r21, r9
	ctx.r[21].u64 = ctx.r[9].u64;
	// 821AAA34: 7F2A5A14  add r25, r10, r11
	ctx.r[25].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AAA38: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821AAA3C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 821AAA40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AAA44: 82990048  lwz r20, 0x48(r25)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AAA48: 568967FE  rlwinm r9, r20, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[20].u32 as u64 & 0x000FFFFFu64;
	// 821AAA4C: 419A0014  beq cr6, 0x821aaa60
	if ctx.cr[6].eq {
	pc = 0x821AAA60; continue 'dispatch;
	}
	// 821AAA50: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AAA54: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821AAA58: 7D6858AE  lbzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AAA5C: 48000008  b 0x821aaa64
	pc = 0x821AAA64; continue 'dispatch;
            }
            0x821AAA60 => {
    //   block [0x821AAA60..0x821AAA64)
	// 821AAA60: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x821AAA64; continue 'dispatch;
            }
            0x821AAA64 => {
    //   block [0x821AAA64..0x821AAAF8)
	// 821AAA64: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA68: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AAA6C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821AAA70: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AAA74: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAA78: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 821AAA7C: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 821AAA80: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAA84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AAA88: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AAA8C: 4BFFD0FD  bl 0x821a7b88
	ctx.lr = 0x821AAA90;
	sub_821A7B88(ctx, base);
	// 821AAA90: EB630000  ld r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AAA94: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 821AAA98: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAA9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AAAA0: 419A06AC  beq cr6, 0x821ab14c
	if ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AAAA4: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAAA8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAAAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAAB0: 409A069C  bne cr6, 0x821ab14c
	if !ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AAAB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAAB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AAABC: 4BFFE305  bl 0x821a8dc0
	ctx.lr = 0x821AAAC0;
	sub_821A8DC0(ctx, base);
	// 821AAAC0: EAE30000  ld r23, 0(r3)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AAAC4: FAE10050  std r23, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u64 ) };
	// 821AAAC8: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAACC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821AAAD0: 419A0644  beq cr6, 0x821ab114
	if ctx.cr[6].eq {
	pc = 0x821AB114; continue 'dispatch;
	}
	// 821AAAD4: 817A0030  lwz r11, 0x30(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAAD8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAADC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAAE0: 409A0634  bne cr6, 0x821ab114
	if !ctx.cr[6].eq {
	pc = 0x821AB114; continue 'dispatch;
	}
	// 821AAAE4: 83B90040  lwz r29, 0x40(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AAAE8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AAAEC: 4098000C  bge cr6, 0x821aaaf8
	if !ctx.cr[6].lt {
	pc = 0x821AAAF8; continue 'dispatch;
	}
	// 821AAAF0: 83D90044  lwz r30, 0x44(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(68 as u32) ) } as u64;
	// 821AAAF4: 48000014  b 0x821aab08
	pc = 0x821AAB08; continue 'dispatch;
            }
            0x821AAAF8 => {
    //   block [0x821AAAF8..0x821AAB08)
	// 821AAAF8: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821AAAFC: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AAB00: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 821AAB04: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AAB08; continue 'dispatch;
            }
            0x821AAB08 => {
    //   block [0x821AAB08..0x821AAC1C)
	// 821AAB08: 397FFFFB  addi r11, r31, -5
	ctx.r[11].s64 = ctx.r[31].s64 + -5;
	// 821AAB0C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821AAB10: 2B0B003A  cmplwi cr6, r11, 0x3a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 58 as u32, &mut ctx.xer);
	// 821AAB14: 41990394  bgt cr6, 0x821aaea8
	if ctx.cr[6].gt {
	pc = 0x821AAEA8; continue 'dispatch;
	}
	// 821AAB18: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821AAB1C: 398CAB30  addi r12, r12, -0x54d0
	ctx.r[12].s64 = ctx.r[12].s64 + -21712;
	// 821AAB20: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821AAB24: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821AAB28: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821AAB2C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821AAC1C; continue 'dispatch;
		},
		1 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		2 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		3 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		4 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		5 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		6 => {
	pc = 0x821AACC8; continue 'dispatch;
		},
		7 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		8 => {
	pc = 0x821AAC64; continue 'dispatch;
		},
		9 => {
	pc = 0x821AAC64; continue 'dispatch;
		},
		10 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		11 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		12 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		13 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		14 => {
	pc = 0x821AAD1C; continue 'dispatch;
		},
		15 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		16 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		17 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		18 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		19 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		20 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		21 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		22 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		23 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		24 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		25 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		26 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		27 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		28 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		29 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		30 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		31 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		32 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		33 => {
	pc = 0x821AAD7C; continue 'dispatch;
		},
		34 => {
	pc = 0x821AADF0; continue 'dispatch;
		},
		35 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		36 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		37 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		38 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		39 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		40 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		41 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		42 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		43 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		44 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		45 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		46 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		47 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		48 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		49 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		50 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		51 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		52 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		53 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		54 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		55 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		56 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		57 => {
	pc = 0x821AAEA8; continue 'dispatch;
		},
		58 => {
	pc = 0x821AAE4C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821AAB30: 821AAC1C  lwz r16, -0x53e4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21476 as u32) ) } as u64;
	// 821AAB34: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB38: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB3C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB40: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB44: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB48: 821AACC8  lwz r16, -0x5338(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21304 as u32) ) } as u64;
	// 821AAB4C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB50: 821AAC64  lwz r16, -0x539c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21404 as u32) ) } as u64;
	// 821AAB54: 821AAC64  lwz r16, -0x539c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21404 as u32) ) } as u64;
	// 821AAB58: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB5C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB60: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB64: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB68: 821AAD1C  lwz r16, -0x52e4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21220 as u32) ) } as u64;
	// 821AAB6C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB70: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB74: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB78: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB7C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB80: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB84: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB88: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB8C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB90: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB94: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB98: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAB9C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABA0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABA4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABA8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABAC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABB0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABB4: 821AAD7C  lwz r16, -0x5284(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21124 as u32) ) } as u64;
	// 821AABB8: 821AADF0  lwz r16, -0x5210(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-21008 as u32) ) } as u64;
	// 821AABBC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABC0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABC4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABC8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABCC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABD0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABD4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABD8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABDC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABE0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABE4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABE8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABEC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABF0: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABF4: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABF8: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AABFC: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC00: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC04: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC08: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC0C: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC10: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC14: 821AAEA8  lwz r16, -0x5158(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20824 as u32) ) } as u64;
	// 821AAC18: 821AAE4C  lwz r16, -0x51b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-20916 as u32) ) } as u64;
            }
            0x821AAC1C => {
    //   block [0x821AAC1C..0x821AAC64)
	// 821AAC1C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAC20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAC24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AAC28: 4BFFC149  bl 0x821a6d70
	ctx.lr = 0x821AAC2C;
	sub_821A6D70(ctx, base);
	// 821AAC2C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AAC30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AAC34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC3C: 419A0464  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAC40: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAC44: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAC48: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAC4C: 409A0454  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAC50: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AAC54: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AAC58: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAC5C: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAC60: 480002A0  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAC64 => {
    //   block [0x821AAC64..0x821AAC90)
	// 821AAC64: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAC68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAC6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AAC70: 4BFFB7D9  bl 0x821a6448
	ctx.lr = 0x821AAC74;
	sub_821A6448(ctx, base);
	// 821AAC74: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC7C: 419A0014  beq cr6, 0x821aac90
	if ctx.cr[6].eq {
	pc = 0x821AAC90; continue 'dispatch;
	}
	// 821AAC80: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAC84: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAC88: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAC8C: 419A0008  beq cr6, 0x821aac94
	if ctx.cr[6].eq {
	pc = 0x821AAC94; continue 'dispatch;
	}
	pc = 0x821AAC90; continue 'dispatch;
            }
            0x821AAC90 => {
    //   block [0x821AAC90..0x821AAC94)
	// 821AAC90: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AAC94; continue 'dispatch;
            }
            0x821AAC94 => {
    //   block [0x821AAC94..0x821AACC8)
	// 821AAC94: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAC9C: 419A0404  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AACA0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AACA4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AACA8: 409A03F8  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AACAC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821AACB0: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AACB4: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AACB8: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AACBC: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AACC0: 914B0100  stw r10, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 821AACC4: 4800023C  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AACC8 => {
    //   block [0x821AACC8..0x821AACF4)
	// 821AACC8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AACCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AACD0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821AACD4: 4BFFC875  bl 0x821a7548
	ctx.lr = 0x821AACD8;
	sub_821A7548(ctx, base);
	// 821AACD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AACDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AACE0: 419A0014  beq cr6, 0x821aacf4
	if ctx.cr[6].eq {
	pc = 0x821AACF4; continue 'dispatch;
	}
	// 821AACE4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AACE8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AACEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AACF0: 419A0008  beq cr6, 0x821aacf8
	if ctx.cr[6].eq {
	pc = 0x821AACF8; continue 'dispatch;
	}
	pc = 0x821AACF4; continue 'dispatch;
            }
            0x821AACF4 => {
    //   block [0x821AACF4..0x821AACF8)
	// 821AACF4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AACF8; continue 'dispatch;
            }
            0x821AACF8 => {
    //   block [0x821AACF8..0x821AAD1C)
	// 821AACF8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AACFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD00: 419A03A0  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD04: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD08: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAD0C: 409A0394  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD10: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAD14: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAD18: 480001E0  b 0x821aaef8
	pc = 0x821AAEF8; continue 'dispatch;
            }
            0x821AAD1C => {
    //   block [0x821AAD1C..0x821AAD4C)
	// 821AAD1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AAD20: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAD24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAD28: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AAD2C: 4BFFA80D  bl 0x821a5538
	ctx.lr = 0x821AAD30;
	sub_821A5538(ctx, base);
	// 821AAD30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAD34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD38: 419A0014  beq cr6, 0x821aad4c
	if ctx.cr[6].eq {
	pc = 0x821AAD4C; continue 'dispatch;
	}
	// 821AAD3C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD40: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAD44: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAD48: 419A0008  beq cr6, 0x821aad50
	if ctx.cr[6].eq {
	pc = 0x821AAD50; continue 'dispatch;
	}
	pc = 0x821AAD4C; continue 'dispatch;
            }
            0x821AAD4C => {
    //   block [0x821AAD4C..0x821AAD50)
	// 821AAD4C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AAD50; continue 'dispatch;
            }
            0x821AAD50 => {
    //   block [0x821AAD50..0x821AAD7C)
	// 821AAD50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD58: 419A0348  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD5C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD60: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAD64: 409A033C  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAD68: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AAD6C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AAD70: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAD74: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAD78: 48000188  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAD7C => {
    //   block [0x821AAD7C..0x821AADA8)
	// 821AAD7C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAD80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAD84: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821AAD88: 4BFFA1F9  bl 0x821a4f80
	ctx.lr = 0x821AAD8C;
	sub_821A4F80(ctx, base);
	// 821AAD8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAD94: 419A0014  beq cr6, 0x821aada8
	if ctx.cr[6].eq {
	pc = 0x821AADA8; continue 'dispatch;
	}
	// 821AAD98: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAD9C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AADA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AADA4: 419A0008  beq cr6, 0x821aadac
	if ctx.cr[6].eq {
	pc = 0x821AADAC; continue 'dispatch;
	}
	pc = 0x821AADA8; continue 'dispatch;
            }
            0x821AADA8 => {
    //   block [0x821AADA8..0x821AADAC)
	// 821AADA8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AADAC; continue 'dispatch;
            }
            0x821AADAC => {
    //   block [0x821AADAC..0x821AADF0)
	// 821AADAC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AADB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AADB4: 419A02EC  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AADB8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AADBC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AADC0: 409A02E0  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AADC4: EBEB00E8  ld r31, 0xe8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	// 821AADC8: 386B00F0  addi r3, r11, 0xf0
	ctx.r[3].s64 = ctx.r[11].s64 + 240;
	// 821AADCC: FB6B00E0  std r27, 0xe0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 821AADD0: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AADD4: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AADD8: C0730008  lfs f3, 8(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821AADDC: C0530004  lfs f2, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AADE0: C0330000  lfs f1, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AADE4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 821AADE8: 480055A1  bl 0x821b0388
	ctx.lr = 0x821AADEC;
	sub_821B0388(ctx, base);
	// 821AADEC: 48000118  b 0x821aaf04
	pc = 0x821AAF04; continue 'dispatch;
            }
            0x821AADF0 => {
    //   block [0x821AADF0..0x821AAE1C)
	// 821AADF0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AADF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AADF8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821AADFC: 4BFFB0A5  bl 0x821a5ea0
	ctx.lr = 0x821AAE00;
	sub_821A5EA0(ctx, base);
	// 821AAE00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE08: 419A0014  beq cr6, 0x821aae1c
	if ctx.cr[6].eq {
	pc = 0x821AAE1C; continue 'dispatch;
	}
	// 821AAE0C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE10: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE14: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAE18: 419A0008  beq cr6, 0x821aae20
	if ctx.cr[6].eq {
	pc = 0x821AAE20; continue 'dispatch;
	}
	pc = 0x821AAE1C; continue 'dispatch;
            }
            0x821AAE1C => {
    //   block [0x821AAE1C..0x821AAE20)
	// 821AAE1C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AAE20; continue 'dispatch;
            }
            0x821AAE20 => {
    //   block [0x821AAE20..0x821AAE4C)
	// 821AAE20: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE28: 419A0278  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE2C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE30: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAE34: 409A026C  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE38: EBEB00F8  ld r31, 0xf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AAE3C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AAE40: 93AB00D4  stw r29, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 821AAE44: 93CB00D8  stw r30, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 821AAE48: 480000B8  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAE4C => {
    //   block [0x821AAE4C..0x821AAE80)
	// 821AAE4C: 570B103A  slwi r11, r24, 2
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AAE50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAE54: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 821AAE58: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AAE5C: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AAE60: 4BFFE959  bl 0x821a97b8
	ctx.lr = 0x821AAE64;
	sub_821A97B8(ctx, base);
	// 821AAE64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE6C: 419A0014  beq cr6, 0x821aae80
	if ctx.cr[6].eq {
	pc = 0x821AAE80; continue 'dispatch;
	}
	// 821AAE70: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE74: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE78: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAE7C: 419A0008  beq cr6, 0x821aae84
	if ctx.cr[6].eq {
	pc = 0x821AAE84; continue 'dispatch;
	}
	pc = 0x821AAE80; continue 'dispatch;
            }
            0x821AAE80 => {
    //   block [0x821AAE80..0x821AAE84)
	// 821AAE80: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AAE84; continue 'dispatch;
            }
            0x821AAE84 => {
    //   block [0x821AAE84..0x821AAEA8)
	// 821AAE84: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAE88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAE8C: 419A0214  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE90: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAE94: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAE98: 409A0208  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAE9C: EBEB00A0  ld r31, 0xa0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	// 821AAEA0: FB6B0098  std r27, 0x98(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[27].u64 ) };
	// 821AAEA4: 4800005C  b 0x821aaf00
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAEA8 => {
    //   block [0x821AAEA8..0x821AAED4)
	// 821AAEA8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AAEAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AAEB0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821AAEB4: 4BFFF1ED  bl 0x821aa0a0
	ctx.lr = 0x821AAEB8;
	sub_821AA0A0(ctx, base);
	// 821AAEB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAEC0: 419A0014  beq cr6, 0x821aaed4
	if ctx.cr[6].eq {
	pc = 0x821AAED4; continue 'dispatch;
	}
	// 821AAEC4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAEC8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAECC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AAED0: 419A0008  beq cr6, 0x821aaed8
	if ctx.cr[6].eq {
	pc = 0x821AAED8; continue 'dispatch;
	}
	pc = 0x821AAED4; continue 'dispatch;
            }
            0x821AAED4 => {
    //   block [0x821AAED4..0x821AAED8)
	// 821AAED4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AAED8; continue 'dispatch;
            }
            0x821AAED8 => {
    //   block [0x821AAED8..0x821AAEF8)
	// 821AAED8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAEE0: 419A01C0  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAEE4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAEE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAEEC: 409A01B4  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAEF0: 93AB00C8  stw r29, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 821AAEF4: 93CB00CC  stw r30, 0xcc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	pc = 0x821AAEF8; continue 'dispatch;
            }
            0x821AAEF8 => {
    //   block [0x821AAEF8..0x821AAF00)
	// 821AAEF8: FB6B00E0  std r27, 0xe0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 821AAEFC: EBEB00E8  ld r31, 0xe8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	pc = 0x821AAF00; continue 'dispatch;
            }
            0x821AAF00 => {
    //   block [0x821AAF00..0x821AAF04)
	// 821AAF00: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	pc = 0x821AAF04; continue 'dispatch;
            }
            0x821AAF04 => {
    //   block [0x821AAF04..0x821AAF48)
	// 821AAF04: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AAF08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AAF0C: 419A0194  beq cr6, 0x821ab0a0
	if ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAF10: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AAF14: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AAF18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AAF1C: 409A0184  bne cr6, 0x821ab0a0
	if !ctx.cr[6].eq {
	pc = 0x821AB0A0; continue 'dispatch;
	}
	// 821AAF20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AAF24: FB7A0188  std r27, 0x188(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(392 as u32), ctx.r[27].u64 ) };
	// 821AAF28: FAFC00B8  std r23, 0xb8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(184 as u32), ctx.r[23].u64 ) };
	// 821AAF2C: 395A0080  addi r10, r26, 0x80
	ctx.r[10].s64 = ctx.r[26].s64 + 128;
	// 821AAF30: FBFC00C0  std r31, 0xc0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(192 as u32), ctx.r[31].u64 ) };
	// 821AAF34: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821AAF38: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAF3C: D01A0178  stfs f0, 0x178(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821AAF40: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAF44: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821AAF48; continue 'dispatch;
            }
            0x821AAF48 => {
    //   block [0x821AAF48..0x821AAFFC)
	// 821AAF48: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AAF4C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821AAF50: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821AAF54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821AAF58: 4200FFF0  bdnz 0x821aaf48
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AAF48; continue 'dispatch;
	}
	// 821AAF5C: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAF60: 393A00C0  addi r9, r26, 0xc0
	ctx.r[9].s64 = ctx.r[26].s64 + 192;
	// 821AAF64: 397A00E0  addi r11, r26, 0xe0
	ctx.r[11].s64 = ctx.r[26].s64 + 224;
	// 821AAF68: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AAF6C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 821AAF70: 3908B8B0  addi r8, r8, -0x4750
	ctx.r[8].s64 = ctx.r[8].s64 + -18256;
	// 821AAF74: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AAF78: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821AAF7C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AAF80: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821AAF84: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AAF88: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821AAF8C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AAF90: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821AAF94: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAF98: D01A00D0  stfs f0, 0xd0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821AAF9C: C019001C  lfs f0, 0x1c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAFA0: C1790010  lfs f11, 0x10(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AAFA4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFA8: C1B9002C  lfs f13, 0x2c(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AAFAC: ED6B07F2  fmuls f11, f11, f31
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFB0: C1990020  lfs f12, 0x20(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AAFB4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AAFB8: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFBC: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AAFC0: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AAFC4: EC0C07F2  fmuls f0, f12, f31
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AAFC8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AAFCC: 910B0020  stw r8, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 821AAFD0: C0190030  lfs f0, 0x30(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAFD4: D01A0110  stfs f0, 0x110(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821AAFD8: C0190034  lfs f0, 0x34(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AAFDC: D01A0114  stfs f0, 0x114(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821AAFE0: 419A001C  beq cr6, 0x821aaffc
	if ctx.cr[6].eq {
	pc = 0x821AAFFC; continue 'dispatch;
	}
	// 821AAFE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AAFE8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821AAFEC: 387A0130  addi r3, r26, 0x130
	ctx.r[3].s64 = ctx.r[26].s64 + 304;
	// 821AAFF0: 4BFF8C61  bl 0x821a3c50
	ctx.lr = 0x821AAFF4;
	sub_821A3C50(ctx, base);
	// 821AAFF4: FADC00A8  std r22, 0xa8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(168 as u32), ctx.r[22].u64 ) };
	// 821AAFF8: 4800004C  b 0x821ab044
	pc = 0x821AB044; continue 'dispatch;
            }
            0x821AAFFC => {
    //   block [0x821AAFFC..0x821AB030)
	// 821AAFFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AB000: 392BC448  addi r9, r11, -0x3bb8
	ctx.r[9].s64 = ctx.r[11].s64 + -15288;
	// 821AB004: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB00C: 419A0030  beq cr6, 0x821ab03c
	if ctx.cr[6].eq {
	pc = 0x821AB03C; continue 'dispatch;
	}
	// 821AB010: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB014: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB018: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB01C: 409A0020  bne cr6, 0x821ab03c
	if !ctx.cr[6].eq {
	pc = 0x821AB03C; continue 'dispatch;
	}
	// 821AB020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB024: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821AB028: 409A0008  bne cr6, 0x821ab030
	if !ctx.cr[6].eq {
	pc = 0x821AB030; continue 'dispatch;
	}
	// 821AB02C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821AB030; continue 'dispatch;
            }
            0x821AB030 => {
    //   block [0x821AB030..0x821AB03C)
	// 821AB030: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AB034: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AB038: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x821AB03C; continue 'dispatch;
            }
            0x821AB03C => {
    //   block [0x821AB03C..0x821AB044)
	// 821AB03C: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AB040: F97C00A8  std r11, 0xa8(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	pc = 0x821AB044; continue 'dispatch;
            }
            0x821AB044 => {
    //   block [0x821AB044..0x821AB064)
	// 821AB044: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821AB048: 419A001C  beq cr6, 0x821ab064
	if ctx.cr[6].eq {
	pc = 0x821AB064; continue 'dispatch;
	}
	// 821AB04C: C0130000  lfs f0, 0(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB050: D01A0160  stfs f0, 0x160(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 821AB054: C0130004  lfs f0, 4(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB058: D01A0164  stfs f0, 0x164(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821AB05C: C0130008  lfs f0, 8(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB060: 48000014  b 0x821ab074
	pc = 0x821AB074; continue 'dispatch;
            }
            0x821AB064 => {
    //   block [0x821AB064..0x821AB074)
	// 821AB064: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AB068: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB06C: D01A0164  stfs f0, 0x164(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821AB070: D01A0160  stfs f0, 0x160(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x821AB074; continue 'dispatch;
            }
            0x821AB074 => {
    //   block [0x821AB074..0x821AB0A0)
	// 821AB074: D01A0168  stfs f0, 0x168(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 821AB078: 929A0118  stw r20, 0x118(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(280 as u32), ctx.r[20].u32 ) };
	// 821AB07C: 931A0180  stw r24, 0x180(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(384 as u32), ctx.r[24].u32 ) };
	// 821AB080: 81790038  lwz r11, 0x38(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AB084: 917C0098  stw r11, 0x98(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AB088: 8179003C  lwz r11, 0x3c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(60 as u32) ) } as u64;
	// 821AB08C: 92DC00C8  stw r22, 0xc8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(200 as u32), ctx.r[22].u32 ) };
	// 821AB090: 917C009C  stw r11, 0x9c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821AB094: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AB098: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AB09C: 4838A048  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            0x821AB0A0 => {
    //   block [0x821AB0A0..0x821AB0D8)
	// 821AB0A0: 817A0194  lwz r11, 0x194(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(404 as u32) ) } as u64;
	// 821AB0A4: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 821AB0A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821AB0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB0B0: 419A0028  beq cr6, 0x821ab0d8
	if ctx.cr[6].eq {
	pc = 0x821AB0D8; continue 'dispatch;
	}
	// 821AB0B4: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB0B8: 80FA0190  lwz r7, 0x190(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(400 as u32) ) } as u64;
	// 821AB0BC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB0C0: 409A0018  bne cr6, 0x821ab0d8
	if !ctx.cr[6].eq {
	pc = 0x821AB0D8; continue 'dispatch;
	}
	// 821AB0C4: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB0C8: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 821AB0CC: 61088000  ori r8, r8, 0x8000
	ctx.r[8].u64 = ctx.r[8].u64 | 32768;
	// 821AB0D0: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821AB0D4: B10B0014  sth r8, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	pc = 0x821AB0D8; continue 'dispatch;
            }
            0x821AB0D8 => {
    //   block [0x821AB0D8..0x821AB114)
	// 821AB0D8: 817C00B4  lwz r11, 0xb4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB0E0: 419A006C  beq cr6, 0x821ab14c
	if ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB0E4: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB0E8: 80FC00B0  lwz r7, 0xb0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB0EC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB0F0: 409A005C  bne cr6, 0x821ab14c
	if !ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB0F4: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB0F8: 992B0019  stb r9, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[9].u8 ) };
	// 821AB0FC: 61098000  ori r9, r8, 0x8000
	ctx.r[9].u64 = ctx.r[8].u64 | 32768;
	// 821AB100: 994B0025  stb r10, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 821AB104: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821AB108: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AB10C: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AB110: 48389FD4  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            0x821AB114 => {
    //   block [0x821AB114..0x821AB14C)
	// 821AB114: 817C00B4  lwz r11, 0xb4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB11C: 419A0030  beq cr6, 0x821ab14c
	if ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB120: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB124: 813C00B0  lwz r9, 0xb0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB128: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB12C: 409A0020  bne cr6, 0x821ab14c
	if !ctx.cr[6].eq {
	pc = 0x821AB14C; continue 'dispatch;
	}
	// 821AB130: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AB134: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB138: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AB13C: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AB140: 610A8000  ori r10, r8, 0x8000
	ctx.r[10].u64 = ctx.r[8].u64 | 32768;
	// 821AB144: 992B0025  stb r9, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[9].u8 ) };
	// 821AB148: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	pc = 0x821AB14C; continue 'dispatch;
            }
            0x821AB14C => {
    //   block [0x821AB14C..0x821AB158)
	// 821AB14C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821AB150: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AB154: 48389F90  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AB158 size=1876
    let mut pc: u32 = 0x821AB158;
    'dispatch: loop {
        match pc {
            0x821AB158 => {
    //   block [0x821AB158..0x821AB1CC)
	// 821AB158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB15C: 48389F31  bl 0x8253508c
	ctx.lr = 0x821AB160;
	sub_82535080(ctx, base);
	// 821AB160: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 821AB164: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821AB168: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB16C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821AB170: 82610194  lwz r19, 0x194(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 821AB174: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AB178: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AB17C: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AB180: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821AB184: 396B1E50  addi r11, r11, 0x1e50
	ctx.r[11].s64 = ctx.r[11].s64 + 7760;
	// 821AB188: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 821AB18C: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 821AB190: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AB194: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821AB198: 7F4A5A14  add r26, r10, r11
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821AB19C: 814101A4  lwz r10, 0x1a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 821AB1A0: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 821AB1A4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821AB1A8: FAF10000  std r23, 0(r17)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[23].u64 ) };
	// 821AB1AC: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 821AB1B0: 7D745378  or r20, r11, r10
	ctx.r[20].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 821AB1B4: 568967FE  rlwinm r9, r20, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[20].u32 as u64 & 0x000FFFFFu64;
	// 821AB1B8: 419A0014  beq cr6, 0x821ab1cc
	if ctx.cr[6].eq {
	pc = 0x821AB1CC; continue 'dispatch;
	}
	// 821AB1BC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AB1C0: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821AB1C4: 7D5358AE  lbzx r10, r19, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AB1C8: 48000008  b 0x821ab1d0
	pc = 0x821AB1D0; continue 'dispatch;
            }
            0x821AB1CC => {
    //   block [0x821AB1CC..0x821AB1D0)
	// 821AB1CC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x821AB1D0; continue 'dispatch;
            }
            0x821AB1D0 => {
    //   block [0x821AB1D0..0x821AB218)
	// 821AB1D0: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AB1D4: 82C1019C  lwz r22, 0x19c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 821AB1D8: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821AB1DC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821AB1E0: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 821AB1E4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AB1E8: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 821AB1EC: 56CB057E  clrlwi r11, r22, 0x15
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000007FFu64;
	// 821AB1F0: 56C80428  rlwinm r8, r22, 0, 0x10, 0x14
	ctx.r[8].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	// 821AB1F4: 2F0B0058  cmpwi cr6, r11, 0x58
	ctx.cr[6].compare_i32(ctx.r[11].s32, 88, &mut ctx.xer);
	// 821AB1F8: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 821AB1FC: 7C89502E  lwzx r4, r9, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AB200: 7D6A0734  extsh r10, r11
	ctx.r[10].s64 = ctx.r[11].s16 as i64;
	// 821AB204: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821AB208: B101009C  sth r8, 0x9c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[8].u16 ) };
	// 821AB20C: B1410098  sth r10, 0x98(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u16 ) };
	// 821AB210: 40980008  bge cr6, 0x821ab218
	if !ctx.cr[6].lt {
	pc = 0x821AB218; continue 'dispatch;
	}
	// 821AB214: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x821AB218; continue 'dispatch;
            }
            0x821AB218 => {
    //   block [0x821AB218..0x821AB254)
	// 821AB218: B161009A  sth r11, 0x9a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(154 as u32), ctx.r[11].u16 ) };
	// 821AB21C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AB220: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 821AB224: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AB228: 4198002C  blt cr6, 0x821ab254
	if ctx.cr[6].lt {
	pc = 0x821AB254; continue 'dispatch;
	}
	// 821AB22C: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 821AB230: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AB234: 396BFFA8  addi r11, r11, -0x58
	ctx.r[11].s64 = ctx.r[11].s64 + -88;
	// 821AB238: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821AB23C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AB240: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AB244: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AB248: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AB24C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AB250: 48000008  b 0x821ab258
	pc = 0x821AB258; continue 'dispatch;
            }
            0x821AB254 => {
    //   block [0x821AB254..0x821AB258)
	// 821AB254: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x821AB258; continue 'dispatch;
            }
            0x821AB258 => {
    //   block [0x821AB258..0x821AB3D0)
	// 821AB258: 7F2B29D6  mullw r25, r11, r5
	ctx.r[25].s32 = ((ctx.r[11].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[25].s64 = ctx.r[25].s32 as i64;
	// 821AB25C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB260: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 821AB264: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821AB268: 4BFFC921  bl 0x821a7b88
	ctx.lr = 0x821AB26C;
	sub_821A7B88(ctx, base);
	// 821AB26C: EB630000  ld r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB270: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 821AB274: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB278: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821AB27C: 419A061C  beq cr6, 0x821ab898
	if ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB280: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB284: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB288: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB28C: 409A060C  bne cr6, 0x821ab898
	if !ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB290: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821AB298: 4BFFDB29  bl 0x821a8dc0
	ctx.lr = 0x821AB29C;
	sub_821A8DC0(ctx, base);
	// 821AB29C: EB030000  ld r24, 0(r3)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB2A0: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 821AB2A4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB2A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AB2AC: 419A05B8  beq cr6, 0x821ab864
	if ctx.cr[6].eq {
	pc = 0x821AB864; continue 'dispatch;
	}
	// 821AB2B0: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB2B4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB2B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB2BC: 409A05A8  bne cr6, 0x821ab864
	if !ctx.cr[6].eq {
	pc = 0x821AB864; continue 'dispatch;
	}
	// 821AB2C0: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AB2C4: 395D011C  addi r10, r29, 0x11c
	ctx.r[10].s64 = ctx.r[29].s64 + 284;
	// 821AB2C8: 8101009C  lwz r8, 0x9c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AB2CC: 397FFFF7  addi r11, r31, -9
	ctx.r[11].s64 = ctx.r[31].s64 + -9;
	// 821AB2D0: 2B0B0033  cmplwi cr6, r11, 0x33
	ctx.cr[6].compare_u32(ctx.r[11].u32, 51 as u32, &mut ctx.xer);
	// 821AB2D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821AB2D8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821AB2DC: 938A0008  stw r28, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821AB2E0: 839A0040  lwz r28, 0x40(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AB2E4: 419902CC  bgt cr6, 0x821ab5b0
	if ctx.cr[6].gt {
	pc = 0x821AB5B0; continue 'dispatch;
	}
	// 821AB2E8: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821AB2EC: 398CB300  addi r12, r12, -0x4d00
	ctx.r[12].s64 = ctx.r[12].s64 + -19712;
	// 821AB2F0: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821AB2F4: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821AB2F8: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821AB2FC: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		1 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		2 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		3 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		4 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		5 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		6 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		7 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		8 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		9 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		10 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		11 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		12 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		13 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		14 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		15 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		16 => {
	pc = 0x821AB420; continue 'dispatch;
		},
		17 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		18 => {
	pc = 0x821AB4BC; continue 'dispatch;
		},
		19 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		20 => {
	pc = 0x821AB4BC; continue 'dispatch;
		},
		21 => {
	pc = 0x821AB420; continue 'dispatch;
		},
		22 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		23 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		24 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		25 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		26 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		27 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		28 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		29 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		30 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		31 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		32 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		33 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		34 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		35 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		36 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		37 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		38 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		39 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		40 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		41 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		42 => {
	pc = 0x821AB3D0; continue 'dispatch;
		},
		43 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		44 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		45 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		46 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		47 => {
	pc = 0x821AB510; continue 'dispatch;
		},
		48 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		49 => {
	pc = 0x821AB5B0; continue 'dispatch;
		},
		50 => {
	pc = 0x821AB55C; continue 'dispatch;
		},
		51 => {
	pc = 0x821AB46C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821AB300: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
	// 821AB304: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB308: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB30C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB310: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB314: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB318: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB31C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB320: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB324: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB328: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB32C: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB330: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB334: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB338: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB33C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB340: 821AB420  lwz r16, -0x4be0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19424 as u32) ) } as u64;
	// 821AB344: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
	// 821AB348: 821AB4BC  lwz r16, -0x4b44(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19268 as u32) ) } as u64;
	// 821AB34C: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
	// 821AB350: 821AB4BC  lwz r16, -0x4b44(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19268 as u32) ) } as u64;
	// 821AB354: 821AB420  lwz r16, -0x4be0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19424 as u32) ) } as u64;
	// 821AB358: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB35C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB360: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB364: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB368: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB36C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB370: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB374: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB378: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB37C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB380: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB384: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB388: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB38C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB390: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB394: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB398: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB39C: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3A0: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB3A4: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB3A8: 821AB3D0  lwz r16, -0x4c30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 821AB3AC: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3B0: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3B4: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3B8: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3BC: 821AB510  lwz r16, -0x4af0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19184 as u32) ) } as u64;
	// 821AB3C0: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3C4: 821AB5B0  lwz r16, -0x4a50(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19024 as u32) ) } as u64;
	// 821AB3C8: 821AB55C  lwz r16, -0x4aa4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19108 as u32) ) } as u64;
	// 821AB3CC: 821AB46C  lwz r16, -0x4b94(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-19348 as u32) ) } as u64;
            }
            0x821AB3D0 => {
    //   block [0x821AB3D0..0x821AB420)
	// 821AB3D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB3D4: 80C101B4  lwz r6, 0x1b4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 821AB3D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB3DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AB3E0: 4BFFA159  bl 0x821a5538
	ctx.lr = 0x821AB3E4;
	sub_821A5538(ctx, base);
	// 821AB3E4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB3E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB3EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB3F4: 419A041C  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB3F8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB3FC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB400: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB404: 409A040C  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB408: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB40C: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB410: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB414: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB418: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB41C: 4800020C  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB420 => {
    //   block [0x821AB420..0x821AB46C)
	// 821AB420: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB428: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AB42C: 4BFFB945  bl 0x821a6d70
	ctx.lr = 0x821AB430;
	sub_821A6D70(ctx, base);
	// 821AB430: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB434: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB438: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB43C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB440: 419A03D0  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB444: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB448: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB44C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB450: 409A03C0  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB454: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB458: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB45C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB460: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB464: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB468: 480001C0  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB46C => {
    //   block [0x821AB46C..0x821AB4BC)
	// 821AB46C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB474: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821AB478: 4BFFAFD1  bl 0x821a6448
	ctx.lr = 0x821AB47C;
	sub_821A6448(ctx, base);
	// 821AB47C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB480: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB484: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB48C: 419A0384  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB490: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB494: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB498: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB49C: 409A0374  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB4A0: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB4A4: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB4A8: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB4AC: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB4B0: 92EB0100  stw r23, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[23].u32 ) };
	// 821AB4B4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB4B8: 48000170  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB4BC => {
    //   block [0x821AB4BC..0x821AB510)
	// 821AB4BC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB4C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB4C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821AB4C8: 4BFFAF81  bl 0x821a6448
	ctx.lr = 0x821AB4CC;
	sub_821A6448(ctx, base);
	// 821AB4CC: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB4D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB4D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB4DC: 419A0334  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB4E0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB4E4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB4E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB4EC: 409A0324  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB4F0: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB4F4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821AB4F8: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB4FC: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB500: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB504: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB508: 912B0100  stw r9, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[9].u32 ) };
	// 821AB50C: 4800011C  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB510 => {
    //   block [0x821AB510..0x821AB55C)
	// 821AB510: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB518: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821AB51C: 4BFFA985  bl 0x821a5ea0
	ctx.lr = 0x821AB520;
	sub_821A5EA0(ctx, base);
	// 821AB520: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB524: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB528: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB530: 419A02E0  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB534: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB538: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB53C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB540: 409A02D0  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB544: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB548: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB54C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB550: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB554: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB558: 480000D0  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB55C => {
    //   block [0x821AB55C..0x821AB5B0)
	// 821AB55C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB560: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB564: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821AB568: 4BFFAEE1  bl 0x821a6448
	ctx.lr = 0x821AB56C;
	sub_821A6448(ctx, base);
	// 821AB56C: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB570: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB574: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB57C: 419A0294  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB580: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB584: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB588: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB58C: 409A0284  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB590: E94B00F8  ld r10, 0xf8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	// 821AB594: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821AB598: 3BEB00E0  addi r31, r11, 0xe0
	ctx.r[31].s64 = ctx.r[11].s64 + 224;
	// 821AB59C: FB6B00F0  std r27, 0xf0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[27].u64 ) };
	// 821AB5A0: 938B00D4  stw r28, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821AB5A4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB5A8: 912B0100  stw r9, 0x100(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), ctx.r[9].u32 ) };
	// 821AB5AC: 4800007C  b 0x821ab628
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB5B0 => {
    //   block [0x821AB5B0..0x821AB614)
	// 821AB5B0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AB5B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AB5B8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AB5BC: 4BFFEAE5  bl 0x821aa0a0
	ctx.lr = 0x821AB5C0;
	sub_821AA0A0(ctx, base);
	// 821AB5C0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AB5C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB5C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB5CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB5D0: 419A0240  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB5D4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB5D8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB5DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB5E0: 409A0230  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB5E4: E94B00E8  ld r10, 0xe8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	// 821AB5E8: 2F1F0037  cmpwi cr6, r31, 0x37
	ctx.cr[6].compare_i32(ctx.r[31].s32, 55, &mut ctx.xer);
	// 821AB5EC: FB6B00E0  std r27, 0xe0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[27].u64 ) };
	// 821AB5F0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AB5F4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB5F8: 409A0028  bne cr6, 0x821ab620
	if !ctx.cr[6].eq {
	pc = 0x821AB620; continue 'dispatch;
	}
	// 821AB5FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AB600: 419A0014  beq cr6, 0x821ab614
	if ctx.cr[6].eq {
	pc = 0x821AB614; continue 'dispatch;
	}
	// 821AB604: 81090030  lwz r8, 0x30(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB608: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB60C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB610: 419A0008  beq cr6, 0x821ab618
	if ctx.cr[6].eq {
	pc = 0x821AB618; continue 'dispatch;
	}
	pc = 0x821AB614; continue 'dispatch;
            }
            0x821AB614 => {
    //   block [0x821AB614..0x821AB618)
	// 821AB614: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	pc = 0x821AB618; continue 'dispatch;
            }
            0x821AB618 => {
    //   block [0x821AB618..0x821AB620)
	// 821AB618: 39000388  li r8, 0x388
	ctx.r[8].s64 = 904;
	// 821AB61C: B1090014  sth r8, 0x14(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	pc = 0x821AB620; continue 'dispatch;
            }
            0x821AB620 => {
    //   block [0x821AB620..0x821AB628)
	// 821AB620: 3BEB00D0  addi r31, r11, 0xd0
	ctx.r[31].s64 = ctx.r[11].s64 + 208;
	// 821AB624: 938B00C8  stw r28, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[28].u32 ) };
	pc = 0x821AB628; continue 'dispatch;
            }
            0x821AB628 => {
    //   block [0x821AB628..0x821AB670)
	// 821AB628: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AB62C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AB630: 419A01E0  beq cr6, 0x821ab810
	if ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB634: 81690030  lwz r11, 0x30(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB638: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AB63C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AB640: 409A01D0  bne cr6, 0x821ab810
	if !ctx.cr[6].eq {
	pc = 0x821AB810; continue 'dispatch;
	}
	// 821AB644: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821AB648: 419A0030  beq cr6, 0x821ab678
	if ctx.cr[6].eq {
	pc = 0x821AB678; continue 'dispatch;
	}
	// 821AB64C: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB654: 419A001C  beq cr6, 0x821ab670
	if ctx.cr[6].eq {
	pc = 0x821AB670; continue 'dispatch;
	}
	// 821AB658: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB65C: 80F30000  lwz r7, 0(r19)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB660: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AB664: 409A000C  bne cr6, 0x821ab670
	if !ctx.cr[6].eq {
	pc = 0x821AB670; continue 'dispatch;
	}
	// 821AB668: A16B0016  lhz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 821AB66C: 48000008  b 0x821ab674
	pc = 0x821AB674; continue 'dispatch;
            }
            0x821AB670 => {
    //   block [0x821AB670..0x821AB674)
	// 821AB670: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821AB674; continue 'dispatch;
            }
            0x821AB674 => {
    //   block [0x821AB674..0x821AB678)
	// 821AB674: B1690016  sth r11, 0x16(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	pc = 0x821AB678; continue 'dispatch;
            }
            0x821AB678 => {
    //   block [0x821AB678..0x821AB698)
	// 821AB678: FB7D0188  std r27, 0x188(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(392 as u32), ctx.r[27].u64 ) };
	// 821AB67C: 393D0080  addi r9, r29, 0x80
	ctx.r[9].s64 = ctx.r[29].s64 + 128;
	// 821AB680: FB1E00B8  std r24, 0xb8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[24].u64 ) };
	// 821AB684: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 821AB688: F95E00C0  std r10, 0xc0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[10].u64 ) };
	// 821AB68C: D3FD0178  stfs f31, 0x178(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821AB690: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB694: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x821AB698; continue 'dispatch;
            }
            0x821AB698 => {
    //   block [0x821AB698..0x821AB758)
	// 821AB698: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AB69C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821AB6A0: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821AB6A4: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821AB6A8: 4200FFF0  bdnz 0x821ab698
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821AB698; continue 'dispatch;
	}
	// 821AB6AC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB6B0: 393D00C0  addi r9, r29, 0xc0
	ctx.r[9].s64 = ctx.r[29].s64 + 192;
	// 821AB6B4: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AB6B8: 397D00E0  addi r11, r29, 0xe0
	ctx.r[11].s64 = ctx.r[29].s64 + 224;
	// 821AB6BC: 3908B8B0  addi r8, r8, -0x4750
	ctx.r[8].s64 = ctx.r[8].s64 + -18256;
	// 821AB6C0: 2F16005A  cmpwi cr6, r22, 0x5a
	ctx.cr[6].compare_i32(ctx.r[22].s32, 90, &mut ctx.xer);
	// 821AB6C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB6C8: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821AB6CC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB6D0: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821AB6D4: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821AB6D8: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821AB6DC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AB6E0: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821AB6E4: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB6E8: D01D00D0  stfs f0, 0xd0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821AB6EC: C01A001C  lfs f0, 0x1c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB6F0: C1BA002C  lfs f13, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AB6F4: C19A0020  lfs f12, 0x20(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AB6F8: C17A0010  lfs f11, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AB6FC: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AB700: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AB704: D1AB001C  stfs f13, 0x1c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AB708: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AB70C: 910B0020  stw r8, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 821AB710: C01A0030  lfs f0, 0x30(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB714: D01D0110  stfs f0, 0x110(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821AB718: C01A0034  lfs f0, 0x34(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB71C: D01D0114  stfs f0, 0x114(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821AB720: 409A0050  bne cr6, 0x821ab770
	if !ctx.cr[6].eq {
	pc = 0x821AB770; continue 'dispatch;
	}
	// 821AB724: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AB728: 392BC448  addi r9, r11, -0x3bb8
	ctx.r[9].s64 = ctx.r[11].s64 + -15288;
	// 821AB72C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AB730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB734: 419A0030  beq cr6, 0x821ab764
	if ctx.cr[6].eq {
	pc = 0x821AB764; continue 'dispatch;
	}
	// 821AB738: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB73C: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AB740: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AB744: 409A0020  bne cr6, 0x821ab764
	if !ctx.cr[6].eq {
	pc = 0x821AB764; continue 'dispatch;
	}
	// 821AB748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB74C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821AB750: 409A0008  bne cr6, 0x821ab758
	if !ctx.cr[6].eq {
	pc = 0x821AB758; continue 'dispatch;
	}
	// 821AB754: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821AB758; continue 'dispatch;
            }
            0x821AB758 => {
    //   block [0x821AB758..0x821AB764)
	// 821AB758: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AB75C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AB760: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x821AB764; continue 'dispatch;
            }
            0x821AB764 => {
    //   block [0x821AB764..0x821AB770)
	// 821AB764: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AB768: F97E00A8  std r11, 0xa8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821AB76C: 4800001C  b 0x821ab788
	pc = 0x821AB788; continue 'dispatch;
            }
            0x821AB770 => {
    //   block [0x821AB770..0x821AB788)
	// 821AB770: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821AB774: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AB778: 388BD050  addi r4, r11, -0x2fb0
	ctx.r[4].s64 = ctx.r[11].s64 + -12208;
	// 821AB77C: 387D0130  addi r3, r29, 0x130
	ctx.r[3].s64 = ctx.r[29].s64 + 304;
	// 821AB780: 4BFF84D1  bl 0x821a3c50
	ctx.lr = 0x821AB784;
	sub_821A3C50(ctx, base);
	// 821AB784: FAFE00A8  std r23, 0xa8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[23].u64 ) };
	pc = 0x821AB788; continue 'dispatch;
            }
            0x821AB788 => {
    //   block [0x821AB788..0x821AB810)
	// 821AB788: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821AB78C: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 821AB790: 396B3410  addi r11, r11, 0x3410
	ctx.r[11].s64 = ctx.r[11].s64 + 13328;
	// 821AB794: 38CAB910  addi r6, r10, -0x46f0
	ctx.r[6].s64 = ctx.r[10].s64 + -18160;
	// 821AB798: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821AB79C: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 821AB7A0: 386A07E4  addi r3, r10, 0x7e4
	ctx.r[3].s64 = ctx.r[10].s64 + 2020;
	// 821AB7A4: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7A8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821AB7AC: D01D0160  stfs f0, 0x160(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 821AB7B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AB7B4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7B8: D01D0164  stfs f0, 0x164(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821AB7BC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7C0: D01D0168  stfs f0, 0x168(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 821AB7C4: 929D0118  stw r20, 0x118(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(280 as u32), ctx.r[20].u32 ) };
	// 821AB7C8: 933D0180  stw r25, 0x180(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(384 as u32), ctx.r[25].u32 ) };
	// 821AB7CC: 927E00CC  stw r19, 0xcc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(204 as u32), ctx.r[19].u32 ) };
	// 821AB7D0: 817A0038  lwz r11, 0x38(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AB7D4: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AB7D8: 817A003C  lwz r11, 0x3c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821AB7DC: 92FE00C8  stw r23, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[23].u32 ) };
	// 821AB7E0: 917E009C  stw r11, 0x9c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821AB7E4: 4BFF1905  bl 0x8219d0e8
	ctx.lr = 0x821AB7E8;
	sub_8219D0E8(ctx, base);
	// 821AB7E8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB7EC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821AB7F0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821AB7F4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AB7F8: E97E00B0  ld r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	// 821AB7FC: F9710000  std r11, 0(r17)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821AB800: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 821AB804: CBC1FF70  lfd f30, -0x90(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AB808: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AB80C: 483898D0  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            0x821AB810 => {
    //   block [0x821AB810..0x821AB844)
	// 821AB810: 817D0194  lwz r11, 0x194(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(404 as u32) ) } as u64;
	// 821AB814: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AB818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB81C: 419A0028  beq cr6, 0x821ab844
	if ctx.cr[6].eq {
	pc = 0x821AB844; continue 'dispatch;
	}
	// 821AB820: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB824: 811D0190  lwz r8, 0x190(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(400 as u32) ) } as u64;
	// 821AB828: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AB82C: 409A0018  bne cr6, 0x821ab844
	if !ctx.cr[6].eq {
	pc = 0x821AB844; continue 'dispatch;
	}
	// 821AB830: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB834: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AB838: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821AB83C: 9AAB0025  stb r21, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[21].u8 ) };
	// 821AB840: B12B0014  sth r9, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	pc = 0x821AB844; continue 'dispatch;
            }
            0x821AB844 => {
    //   block [0x821AB844..0x821AB864)
	// 821AB844: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB84C: 419A004C  beq cr6, 0x821ab898
	if ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB850: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB854: 811E00B0  lwz r8, 0xb0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB858: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AB85C: 409A003C  bne cr6, 0x821ab898
	if !ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB860: 48000024  b 0x821ab884
	pc = 0x821AB884; continue 'dispatch;
            }
            0x821AB864 => {
    //   block [0x821AB864..0x821AB884)
	// 821AB864: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 821AB868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AB86C: 419A002C  beq cr6, 0x821ab898
	if ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB870: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AB874: 813E00B0  lwz r9, 0xb0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AB878: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AB87C: 409A001C  bne cr6, 0x821ab898
	if !ctx.cr[6].eq {
	pc = 0x821AB898; continue 'dispatch;
	}
	// 821AB880: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	pc = 0x821AB884; continue 'dispatch;
            }
            0x821AB884 => {
    //   block [0x821AB884..0x821AB898)
	// 821AB884: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AB888: A12B0014  lhz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AB88C: 612A8000  ori r10, r9, 0x8000
	ctx.r[10].u64 = ctx.r[9].u64 | 32768;
	// 821AB890: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821AB894: 9AAB0025  stb r21, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[21].u8 ) };
	pc = 0x821AB898; continue 'dispatch;
            }
            0x821AB898 => {
    //   block [0x821AB898..0x821AB8AC)
	// 821AB898: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821AB89C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 821AB8A0: CBC1FF70  lfd f30, -0x90(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AB8A4: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AB8A8: 48389834  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AB8B0 size=140
    let mut pc: u32 = 0x821AB8B0;
    'dispatch: loop {
        match pc {
            0x821AB8B0 => {
    //   block [0x821AB8B0..0x821AB93C)
	// 821AB8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AB8B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AB8BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AB8C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AB8C4: 481BB875  bl 0x82367138
	ctx.lr = 0x821AB8C8;
	sub_82367138(ctx, base);
	// 821AB8C8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AB8CC: C1840010  lfs f12, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AB8D0: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AB8D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB8D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AB8DC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AB8E0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AB8E4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AB8E8: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB8EC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AB8F0: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 821AB8F4: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AB8F8: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AB8FC: 481BB83D  bl 0x82367138
	ctx.lr = 0x821AB900;
	sub_82367138(ctx, base);
	// 821AB900: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AB904: C1A4001C  lfs f13, 0x1c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AB908: C184000C  lfs f12, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AB90C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AB910: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AB914: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 821AB918: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821AB91C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AB920: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AB924: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AB928: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AB92C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AB930: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AB934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AB938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AB940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AB940 size=1812
    let mut pc: u32 = 0x821AB940;
    'dispatch: loop {
        match pc {
            0x821AB940 => {
    //   block [0x821AB940..0x821ABA00)
	// 821AB940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AB944: 48389759  bl 0x8253509c
	ctx.lr = 0x821AB948;
	sub_82535080(ctx, base);
	// 821AB948: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AB94C: 3AC5FFFF  addi r22, r5, -1
	ctx.r[22].s64 = ctx.r[5].s64 + -1;
	// 821AB950: 394B20C0  addi r10, r11, 0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + 8384;
	// 821AB954: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AB958: 392A0100  addi r9, r10, 0x100
	ctx.r[9].s64 = ctx.r[10].s64 + 256;
	// 821AB95C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821AB960: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 821AB964: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AB968: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AB96C: 7EAB4A14  add r21, r11, r9
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AB970: D015FFF8  stfs f0, -8(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AB974: D00A0108  stfs f0, 0x108(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 821AB978: D015FFF4  stfs f0, -0xc(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AB97C: D00A0104  stfs f0, 0x104(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821AB980: D015FFF0  stfs f0, -0x10(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821AB984: D00A0100  stfs f0, 0x100(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 821AB988: 41980148  blt cr6, 0x821abad0
	if ctx.cr[6].lt {
	pc = 0x821ABAD0; continue 'dispatch;
	}
	// 821AB98C: 3976FFFC  addi r11, r22, -4
	ctx.r[11].s64 = ctx.r[22].s64 + -4;
	// 821AB990: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 821AB994: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AB998: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 821AB99C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821AB9A0: 38CA0014  addi r6, r10, 0x14
	ctx.r[6].s64 = ctx.r[10].s64 + 20;
	// 821AB9A4: 386A001C  addi r3, r10, 0x1c
	ctx.r[3].s64 = ctx.r[10].s64 + 28;
	// 821AB9A8: 3BEA0020  addi r31, r10, 0x20
	ctx.r[31].s64 = ctx.r[10].s64 + 32;
	// 821AB9AC: 3BCA0024  addi r30, r10, 0x24
	ctx.r[30].s64 = ctx.r[10].s64 + 36;
	// 821AB9B0: 3BAA002C  addi r29, r10, 0x2c
	ctx.r[29].s64 = ctx.r[10].s64 + 44;
	// 821AB9B4: 3B8A0030  addi r28, r10, 0x30
	ctx.r[28].s64 = ctx.r[10].s64 + 48;
	// 821AB9B8: 3B6A0034  addi r27, r10, 0x34
	ctx.r[27].s64 = ctx.r[10].s64 + 52;
	// 821AB9BC: 3B4A003C  addi r26, r10, 0x3c
	ctx.r[26].s64 = ctx.r[10].s64 + 60;
	// 821AB9C0: 3B2A0040  addi r25, r10, 0x40
	ctx.r[25].s64 = ctx.r[10].s64 + 64;
	// 821AB9C4: 3B0A0044  addi r24, r10, 0x44
	ctx.r[24].s64 = ctx.r[10].s64 + 68;
	// 821AB9C8: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 821AB9CC: 7D044050  subf r8, r4, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[4].s64;
	// 821AB9D0: 7CE43850  subf r7, r4, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 821AB9D4: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 821AB9D8: 7C641850  subf r3, r4, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 821AB9DC: 7FE4F850  subf r31, r4, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[4].s64;
	// 821AB9E0: 7FC4F050  subf r30, r4, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[4].s64;
	// 821AB9E4: 7FA4E850  subf r29, r4, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[4].s64;
	// 821AB9E8: 7F84E050  subf r28, r4, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[4].s64;
	// 821AB9EC: 7F64D850  subf r27, r4, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[4].s64;
	// 821AB9F0: 7F44D050  subf r26, r4, r26
	ctx.r[26].s64 = ctx.r[26].s64 - ctx.r[4].s64;
	// 821AB9F4: 7F24C850  subf r25, r4, r25
	ctx.r[25].s64 = ctx.r[25].s64 - ctx.r[4].s64;
	// 821AB9F8: 7F04C050  subf r24, r4, r24
	ctx.r[24].s64 = ctx.r[24].s64 - ctx.r[4].s64;
	// 821AB9FC: 5537103A  slwi r23, r9, 2
	ctx.r[23].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	pc = 0x821ABA00; continue 'dispatch;
            }
            0x821ABA00 => {
    //   block [0x821ABA00..0x821ABAD0)
	// 821ABA00: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA04: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821ABA08: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA10: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA14: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ABA1C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA20: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA24: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA28: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA2C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA30: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA34: 7C065D2E  stfsx f0, r6, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA38: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA3C: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA40: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA44: 7C035D2E  stfsx f0, r3, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA48: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA4C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA50: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA54: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA58: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA5C: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA60: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA64: 7C1E5D2E  stfsx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA68: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA6C: C00B002C  lfs f0, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA70: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA74: 7C1D5D2E  stfsx f0, r29, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA78: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA7C: C00B0030  lfs f0, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA80: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA84: 7C1C5D2E  stfsx f0, r28, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA88: C1AB0024  lfs f13, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA8C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABA90: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABA94: 7C1B5D2E  stfsx f0, r27, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABA98: C1AB002C  lfs f13, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABA9C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABAA0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABAA4: 7C1A5D2E  stfsx f0, r26, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABAA8: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABAAC: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABAB0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABAB4: 7C195D2E  stfsx f0, r25, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABAB8: C00B0044  lfs f0, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABABC: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABAC0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABAC4: 7C185D2E  stfsx f0, r24, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821ABAC8: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821ABACC: 409AFF34  bne cr6, 0x821aba00
	if !ctx.cr[6].eq {
	pc = 0x821ABA00; continue 'dispatch;
	}
	pc = 0x821ABAD0; continue 'dispatch;
            }
            0x821ABAD0 => {
    //   block [0x821ABAD0..0x821ABB00)
	// 821ABAD0: 7F17B000  cmpw cr6, r23, r22
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821ABAD4: 4098006C  bge cr6, 0x821abb40
	if !ctx.cr[6].lt {
	pc = 0x821ABB40; continue 'dispatch;
	}
	// 821ABAD8: 56EB2036  slwi r11, r23, 4
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABADC: 392A000C  addi r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 + 12;
	// 821ABAE0: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821ABAE4: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 821ABAE8: 38CA0014  addi r6, r10, 0x14
	ctx.r[6].s64 = ctx.r[10].s64 + 20;
	// 821ABAEC: 7D044850  subf r8, r4, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 821ABAF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821ABAF4: 7CE43850  subf r7, r4, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 821ABAF8: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 821ABAFC: 7D37B050  subf r9, r23, r22
	ctx.r[9].s64 = ctx.r[22].s64 - ctx.r[23].s64;
	pc = 0x821ABB00; continue 'dispatch;
            }
            0x821ABB00 => {
    //   block [0x821ABB00..0x821ABB40)
	// 821ABB00: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB04: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821ABB08: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB10: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 821ABB14: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ABB1C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB20: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB24: 7C0B3D2E  stfsx f0, r11, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 821ABB28: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB2C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB30: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB34: 7C0B352E  stfsx f0, r11, r6
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 821ABB38: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821ABB3C: 409AFFC4  bne cr6, 0x821abb00
	if !ctx.cr[6].eq {
	pc = 0x821ABB00; continue 'dispatch;
	}
	pc = 0x821ABB40; continue 'dispatch;
            }
            0x821ABB40 => {
    //   block [0x821ABB40..0x821ABBD0)
	// 821ABB40: C00A0020  lfs f0, 0x20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821ABB48: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB4C: 3925FFFE  addi r9, r5, -2
	ctx.r[9].s64 = ctx.r[5].s64 + -2;
	// 821ABB50: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB54: C00A0024  lfs f0, 0x24(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB58: C1AA0014  lfs f13, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821ABB60: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB64: C00A0028  lfs f0, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB68: C1AA0018  lfs f13, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB6C: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB70: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABB74: D00A0018  stfs f0, 0x18(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821ABB78: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 821ABB7C: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ABB80: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ABB84: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821ABB88: C1AA0100  lfs f13, 0x100(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821ABB90: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABB94: D1AA0110  stfs f13, 0x110(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821ABB98: C1AA0104  lfs f13, 0x104(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABB9C: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABBA0: D1AA0114  stfs f13, 0x114(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821ABBA4: C1AA0108  lfs f13, 0x108(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABBA8: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABBAC: D1AA0118  stfs f13, 0x118(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 821ABBB0: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABBB4: 4198020C  blt cr6, 0x821abdc0
	if ctx.cr[6].lt {
	pc = 0x821ABDC0; continue 'dispatch;
	}
	// 821ABBB8: 3969FFFB  addi r11, r9, -5
	ctx.r[11].s64 = ctx.r[9].s64 + -5;
	// 821ABBBC: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABBC0: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821ABBC4: 396A0114  addi r11, r10, 0x114
	ctx.r[11].s64 = ctx.r[10].s64 + 276;
	// 821ABBC8: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821ABBCC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	pc = 0x821ABBD0; continue 'dispatch;
            }
            0x821ABBD0 => {
    //   block [0x821ABBD0..0x821ABDC0)
	// 821ABBD0: C18BFEFC  lfs f12, -0x104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABBD4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ABBD8: C14BFF0C  lfs f10, -0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABBDC: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABBE0: C16BFF1C  lfs f11, -0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABBE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ABBE8: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABBEC: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABBF0: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABBF4: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABBF8: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821ABBFC: C18BFF00  lfs f12, -0x100(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC00: C14BFF10  lfs f10, -0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-240 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC04: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC08: C16BFF20  lfs f11, -0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-224 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC0C: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABC10: D12BFF0C  stfs f9, -0xf4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-244 as u32), tmp.u32 ) };
	// 821ABC14: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC18: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC1C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC20: D18B0010  stfs f12, 0x10(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ABC24: C18BFF04  lfs f12, -0xfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC28: C14BFF14  lfs f10, -0xec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC2C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC30: C16BFF24  lfs f11, -0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-220 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC34: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABC38: D12BFF10  stfs f9, -0xf0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-240 as u32), tmp.u32 ) };
	// 821ABC3C: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC40: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC44: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC48: D18B0014  stfs f12, 0x14(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ABC4C: C18BFF0C  lfs f12, -0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC50: C14BFF2C  lfs f10, -0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC54: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC58: C16BFF1C  lfs f11, -0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC5C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC60: D12BFF14  stfs f9, -0xec(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-236 as u32), tmp.u32 ) };
	// 821ABC64: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC68: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC6C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC70: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821ABC74: C18BFF10  lfs f12, -0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABC78: C16BFF20  lfs f11, -0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-224 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABC7C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABC80: C14BFF30  lfs f10, -0xd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC84: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC88: D12BFF1C  stfs f9, -0xe4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-228 as u32), tmp.u32 ) };
	// 821ABC8C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABC90: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABC94: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABC98: D18B0020  stfs f12, 0x20(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821ABC9C: C18BFF14  lfs f12, -0xec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABCA0: C16BFF24  lfs f11, -0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-220 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABCA4: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABCA8: C14BFF34  lfs f10, -0xcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-204 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCAC: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABCB0: D12BFF20  stfs f9, -0xe0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-224 as u32), tmp.u32 ) };
	// 821ABCB4: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCB8: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABCBC: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABCC0: D18B0024  stfs f12, 0x24(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821ABCC4: C18BFF1C  lfs f12, -0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABCC8: C14BFF2C  lfs f10, -0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCCC: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABCD0: C16BFF3C  lfs f11, -0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABCD4: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABCD8: D12BFF24  stfs f9, -0xdc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-220 as u32), tmp.u32 ) };
	// 821ABCDC: C14B001C  lfs f10, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCE0: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABCE4: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABCE8: D18B002C  stfs f12, 0x2c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821ABCEC: C18BFF20  lfs f12, -0xe0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABCF0: C14BFF30  lfs f10, -0xd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABCF4: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABCF8: C16BFF40  lfs f11, -0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABCFC: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABD00: D12BFF2C  stfs f9, -0xd4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-212 as u32), tmp.u32 ) };
	// 821ABD04: C14B0020  lfs f10, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD08: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD0C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD10: D18B0030  stfs f12, 0x30(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821ABD14: C18BFF24  lfs f12, -0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-220 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD18: C14BFF34  lfs f10, -0xcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-204 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD1C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD20: C16BFF44  lfs f11, -0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD24: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABD28: D12BFF30  stfs f9, -0xd0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-208 as u32), tmp.u32 ) };
	// 821ABD2C: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD30: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD34: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD38: D18B0034  stfs f12, 0x34(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821ABD3C: C18BFF2C  lfs f12, -0xd4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD40: C16BFF3C  lfs f11, -0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD44: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD48: C14BFF4C  lfs f10, -0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-180 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD4C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD50: D12BFF34  stfs f9, -0xcc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-204 as u32), tmp.u32 ) };
	// 821ABD54: C14B002C  lfs f10, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD58: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD5C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD60: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821ABD64: C18BFF30  lfs f12, -0xd0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-208 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD68: C16BFF40  lfs f11, -0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD6C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD70: C14BFF50  lfs f10, -0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD74: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD78: D12BFF3C  stfs f9, -0xc4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-196 as u32), tmp.u32 ) };
	// 821ABD7C: C14B0030  lfs f10, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD80: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABD84: ED8C5ABC  fnmsubs f12, f12, f10, f11
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABD88: D18B0040  stfs f12, 0x40(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821ABD8C: C18BFF34  lfs f12, -0xcc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-204 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABD90: C16BFF44  lfs f11, -0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABD94: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABD98: C14BFF54  lfs f10, -0xac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-172 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABD9C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABDA0: D12BFF40  stfs f9, -0xc0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-192 as u32), tmp.u32 ) };
	// 821ABDA4: C14B0034  lfs f10, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABDA8: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABDAC: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABDB0: D18B0044  stfs f12, 0x44(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821ABDB4: D12BFF44  stfs f9, -0xbc(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-188 as u32), tmp.u32 ) };
	// 821ABDB8: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821ABDBC: 409AFE14  bne cr6, 0x821abbd0
	if !ctx.cr[6].eq {
	pc = 0x821ABBD0; continue 'dispatch;
	}
	pc = 0x821ABDC0; continue 'dispatch;
            }
            0x821ABDC0 => {
    //   block [0x821ABDC0..0x821ABDD8)
	// 821ABDC0: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821ABDC4: 4098009C  bge cr6, 0x821abe60
	if !ctx.cr[6].lt {
	pc = 0x821ABE60; continue 'dispatch;
	}
	// 821ABDC8: 54EB2036  slwi r11, r7, 4
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABDCC: 7D074850  subf r8, r7, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821ABDD0: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 821ABDD4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	pc = 0x821ABDD8; continue 'dispatch;
            }
            0x821ABDD8 => {
    //   block [0x821ABDD8..0x821ABE60)
	// 821ABDD8: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABDDC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ABDE0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABDE4: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABDE8: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABDEC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ABDF0: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABDF4: C14B00F0  lfs f10, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABDF8: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABDFC: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE00: D18B0100  stfs f12, 0x100(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 821ABE04: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABE08: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABE0C: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABE10: C14B0014  lfs f10, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE14: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE18: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ABE1C: C14B00F4  lfs f10, 0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE20: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABE24: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE28: D18B0104  stfs f12, 0x104(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821ABE2C: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABE30: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABE34: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABE38: C14B0018  lfs f10, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE3C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE40: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ABE44: C14B00F8  lfs f10, 0xf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE48: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABE4C: ED8A5B3C  fnmsubs f12, f10, f12, f11
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE50: D18B0108  stfs f12, 0x108(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 821ABE54: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ABE58: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821ABE5C: 409AFF7C  bne cr6, 0x821abdd8
	if !ctx.cr[6].eq {
	pc = 0x821ABDD8; continue 'dispatch;
	}
	pc = 0x821ABE60; continue 'dispatch;
            }
            0x821ABE60 => {
    //   block [0x821ABE60..0x821ABEC0)
	// 821ABE60: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABE64: C015FFE4  lfs f0, -0x1c(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABE68: 390A0100  addi r8, r10, 0x100
	ctx.r[8].s64 = ctx.r[10].s64 + 256;
	// 821ABE6C: C175FFF4  lfs f11, -0xc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABE70: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABE74: D015FFE4  stfs f0, -0x1c(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 821ABE78: C1B5FFE8  lfs f13, -0x18(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABE7C: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 821ABE80: C195FFF0  lfs f12, -0x10(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABE84: C155FFF8  lfs f10, -8(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABE88: 7C0B442E  lfsx f0, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABE8C: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABE90: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABE94: D1B5FFE8  stfs f13, -0x18(r21)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 821ABE98: 7C0B452E  stfsx f0, r11, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 821ABE9C: 41980148  blt cr6, 0x821abfe4
	if ctx.cr[6].lt {
	pc = 0x821ABFE4; continue 'dispatch;
	}
	// 821ABEA0: 3969FFFC  addi r11, r9, -4
	ctx.r[11].s64 = ctx.r[9].s64 + -4;
	// 821ABEA4: 38EA0114  addi r7, r10, 0x114
	ctx.r[7].s64 = ctx.r[10].s64 + 276;
	// 821ABEA8: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABEAC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821ABEB0: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABEB4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821ABEB8: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821ABEBC: 7D274850  subf r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	pc = 0x821ABEC0; continue 'dispatch;
            }
            0x821ABEC0 => {
    //   block [0x821ABEC0..0x821ABFE4)
	// 821ABEC0: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABEC4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 821ABEC8: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABECC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821ABED0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABED4: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABED8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821ABEDC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABEE0: C18BFEEC  lfs f12, -0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABEE4: C16BFFF4  lfs f11, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABEE8: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABEEC: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 821ABEF0: C14BFFDC  lfs f10, -0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABEF4: C12BFFE0  lfs f9, -0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821ABEF8: C10BFFE4  lfs f8, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821ABEFC: C0EBFFCC  lfs f7, -0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821ABF00: C0CBFFD0  lfs f6, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821ABF04: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF08: D00BFFEC  stfs f0, -0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 821ABF0C: C00BFEF0  lfs f0, -0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABF10: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821ABF14: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF18: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABF1C: D00BFFF0  stfs f0, -0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821ABF20: C18BFEF4  lfs f12, -0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-268 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF24: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF28: D18BFFF4  stfs f12, -0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821ABF2C: C18BFEDC  lfs f12, -0x124(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-292 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF30: C16BFFF4  lfs f11, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABF34: ED685828  fsubs f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABF38: C14BFFD4  lfs f10, -0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ABF3C: C10BFFC0  lfs f8, -0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-64 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821ABF40: C0ABFFC4  lfs f5, -0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821ABF44: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ABF48: C12BFFBC  lfs f9, -0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-68 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821ABF4C: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF50: D1ABFFDC  stfs f13, -0x24(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-36 as u32), tmp.u32 ) };
	// 821ABF54: C1ABFEE0  lfs f13, -0x120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-288 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABF58: C18BFFDC  lfs f12, -0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF5C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821ABF60: D00BFFE0  stfs f0, -0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 821ABF64: EDA76028  fsubs f13, f7, f12
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABF68: C18BFEE4  lfs f12, -0x11c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-284 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF6C: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF70: D18BFFE4  stfs f12, -0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 821ABF74: C18BFECC  lfs f12, -0x134(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF78: C16BFFE4  lfs f11, -0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABF7C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABF80: EC060028  fsubs f0, f6, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ABF84: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABF88: D1ABFFCC  stfs f13, -0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-52 as u32), tmp.u32 ) };
	// 821ABF8C: C1ABFED0  lfs f13, -0x130(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABF90: C18BFFCC  lfs f12, -0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABF94: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821ABF98: D00BFFD0  stfs f0, -0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 821ABF9C: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ABFA0: C18BFED4  lfs f12, -0x12c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABFA4: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABFA8: D18BFFD4  stfs f12, -0x2c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 821ABFAC: C16BFFD4  lfs f11, -0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ABFB0: ED655828  fsubs f11, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 821ABFB4: C18BFEBC  lfs f12, -0x144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-324 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ABFB8: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ABFBC: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ABFC0: D1ABFFBC  stfs f13, -0x44(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 821ABFC4: C1ABFEC0  lfs f13, -0x140(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ABFC8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821ABFCC: D00BFFC0  stfs f0, -0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 821ABFD0: C00BFEC4  lfs f0, -0x13c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABFD4: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 821ABFD8: D00BFFC4  stfs f0, -0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 821ABFDC: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 821ABFE0: 409AFEE0  bne cr6, 0x821abec0
	if !ctx.cr[6].eq {
	pc = 0x821ABEC0; continue 'dispatch;
	}
	pc = 0x821ABFE4; continue 'dispatch;
            }
            0x821ABFE4 => {
    //   block [0x821ABFE4..0x821ABFF8)
	// 821ABFE4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821ABFE8: 40990068  ble cr6, 0x821ac050
	if !ctx.cr[6].gt {
	pc = 0x821AC050; continue 'dispatch;
	}
	// 821ABFEC: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ABFF0: 394A0114  addi r10, r10, 0x114
	ctx.r[10].s64 = ctx.r[10].s64 + 276;
	// 821ABFF4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x821ABFF8; continue 'dispatch;
            }
            0x821ABFF8 => {
    //   block [0x821ABFF8..0x821AC050)
	// 821ABFF8: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ABFFC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821AC000: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC004: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AC008: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AC00C: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC010: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821AC014: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AC018: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC01C: C18BFFF4  lfs f12, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AC020: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821AC024: C16BFEEC  lfs f11, -0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-276 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC028: EC005824  fdivs f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 821AC02C: D00BFFEC  stfs f0, -0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 821AC030: C00BFEF0  lfs f0, -0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC034: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AC038: D00BFFF0  stfs f0, -0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821AC03C: C00BFEF4  lfs f0, -0x10c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC040: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AC044: D00BFFF4  stfs f0, -0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AC048: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821AC04C: 4199FFAC  bgt cr6, 0x821abff8
	if ctx.cr[6].gt {
	pc = 0x821ABFF8; continue 'dispatch;
	}
	pc = 0x821AC050; continue 'dispatch;
            }
            0x821AC050 => {
    //   block [0x821AC050..0x821AC054)
	// 821AC050: 4838909C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AC058 size=556
    let mut pc: u32 = 0x821AC058;
    'dispatch: loop {
        match pc {
            0x821AC058 => {
    //   block [0x821AC058..0x821AC254)
	// 821AC058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC05C: 4838905D  bl 0x825350b8
	ctx.lr = 0x821AC060;
	sub_82535080(ctx, base);
	// 821AC060: 3946FFFF  addi r10, r6, -1
	ctx.r[10].s64 = ctx.r[6].s64 + -1;
	// 821AC064: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AC068: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821AC06C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AC070: 409901E4  ble cr6, 0x821ac254
	if !ctx.cr[6].gt {
	pc = 0x821AC254; continue 'dispatch;
	}
	// 821AC074: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 821AC078: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821AC07C: 392920C0  addi r9, r9, 0x20c0
	ctx.r[9].s64 = ctx.r[9].s64 + 8384;
	// 821AC080: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 821AC084: 39290100  addi r9, r9, 0x100
	ctx.r[9].s64 = ctx.r[9].s64 + 256;
	// 821AC088: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 821AC08C: 7FE54850  subf r31, r5, r9
	ctx.r[31].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 821AC090: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AC094: C16425B8  lfs f11, 0x25b8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(9656 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AC098: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 821AC09C: 7FAA4850  subf r29, r10, r9
	ctx.r[29].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821AC0A0: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821AC0A4: C1872068  lfs f12, 0x2068(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8296 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AC0A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AC0AC: C1A9D5B0  lfs f13, -0x2a50(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC0B0: C14A1FF8  lfs f10, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AC0B4: 7D5F4214  add r10, r31, r8
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[8].u64;
	// 821AC0B8: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 821AC0BC: 38880010  addi r4, r8, 0x10
	ctx.r[4].s64 = ctx.r[8].s64 + 16;
	// 821AC0C0: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 821AC0C4: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	pc = 0x821AC254; continue 'dispatch;
            }
            0x821AC254 => {
    //   block [0x821AC254..0x821AC284)
	// 821AC254: 54CB2036  slwi r11, r6, 4
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC258: 57AA2036  slwi r10, r29, 4
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC25C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 821AC260: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 821AC264: 387D0001  addi r3, r29, 1
	ctx.r[3].s64 = ctx.r[29].s64 + 1;
	// 821AC268: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC26C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AC270: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC274: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AC278: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC27C: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AC280: 48388E88  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AC288 size=344
    let mut pc: u32 = 0x821AC288;
    'dispatch: loop {
        match pc {
            0x821AC288 => {
    //   block [0x821AC288..0x821AC3BC)
	// 821AC288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC28C: 48388E15  bl 0x825350a0
	ctx.lr = 0x821AC290;
	sub_82535080(ctx, base);
	// 821AC290: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC294: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821AC298: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821AC29C: 7F8B1E70  srawi r11, r28, 3
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 3) as i64;
	// 821AC2A0: 3AE0000F  li r23, 0xf
	ctx.r[23].s64 = 15;
	// 821AC2A4: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821AC2A8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AC2AC: 555B063E  clrlwi r27, r10, 0x18
	ctx.r[27].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821AC2B0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 821AC2B4: 3BEB63D0  addi r31, r11, 0x63d0
	ctx.r[31].s64 = ctx.r[11].s64 + 25552;
	// 821AC2B8: 7F8B1E70  srawi r11, r28, 3
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 3) as i64;
	// 821AC2BC: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 821AC2C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AC2C4: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821AC2C8: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 821AC2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC2D0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC2D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AC2D8: 7D6BE050  subf r11, r11, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 821AC2DC: 557A063E  clrlwi r26, r11, 0x18
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821AC2E0: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 821AC2E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC2E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AC2EC: 48560F71  bl 0x8270d25c
	ctx.lr = 0x821AC2F0;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821AC2F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AC2F4: 3F0082C0  lis r24, -0x7d40
	ctx.r[24].s64 = -2101346304;
	// 821AC2F8: 3B2B0EE8  addi r25, r11, 0xee8
	ctx.r[25].s64 = ctx.r[11].s64 + 3816;
	// 821AC2FC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821AC300: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 821AC304: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821AC308: 8098B9F8  lwz r4, -0x4608(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 821AC30C: 48049C55  bl 0x821f5f60
	ctx.lr = 0x821AC310;
	sub_821F5F60(ctx, base);
	// 821AC310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC314: 48560F59  bl 0x8270d26c
	ctx.lr = 0x821AC318;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821AC318: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821AC31C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC320: 419A00A8  beq cr6, 0x821ac3c8
	if ctx.cr[6].eq {
	pc = 0x821AC3C8; continue 'dispatch;
	}
	// 821AC324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC328: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AC32C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AC330: 4E800421  bctrl
	ctx.lr = 0x821AC334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC334: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821AC338: 41980090  blt cr6, 0x821ac3c8
	if ctx.cr[6].lt {
	pc = 0x821AC3C8; continue 'dispatch;
	}
	// 821AC33C: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 821AC340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC344: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 821AC348: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 821AC34C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC350: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 821AC354: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821AC358: 48560F05  bl 0x8270d25c
	ctx.lr = 0x821AC35C;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821AC35C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821AC360: 8098B9F8  lwz r4, -0x4608(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 821AC364: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 821AC368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AC36C: 48049BF5  bl 0x821f5f60
	ctx.lr = 0x821AC370;
	sub_821F5F60(ctx, base);
	// 821AC370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC374: 48560EF9  bl 0x8270d26c
	ctx.lr = 0x821AC378;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821AC378: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC37C: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 821AC380: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AC384: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC388: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC38C: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AC390: 814A0034  lwz r10, 0x34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821AC394: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821AC398: 4E800421  bctrl
	ctx.lr = 0x821AC39C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AC39C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AC3A0: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC3A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC3A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC3AC: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AC3B0: 7D6AF12A  stdx r11, r10, r30
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u64) };
	// 821AC3B4: 419A0008  beq cr6, 0x821ac3bc
	if ctx.cr[6].eq {
	pc = 0x821AC3BC; continue 'dispatch;
	}
	// 821AC3B8: 4BF70CA1  bl 0x8211d058
	ctx.lr = 0x821AC3BC;
	sub_8211D058(ctx, base);
            }
            0x821AC3BC => {
    //   block [0x821AC3BC..0x821AC3C8)
	// 821AC3BC: 397D0060  addi r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 + 96;
	// 821AC3C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC3C4: 7F8BF12E  stwx r28, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[28].u32) };
	pc = 0x821AC3C8; continue 'dispatch;
            }
            0x821AC3C8 => {
    //   block [0x821AC3C8..0x821AC3D8)
	// 821AC3C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821AC3CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC3D0: 419A0008  beq cr6, 0x821ac3d8
	if ctx.cr[6].eq {
	pc = 0x821AC3D8; continue 'dispatch;
	}
	// 821AC3D4: 4BF70C85  bl 0x8211d058
	ctx.lr = 0x821AC3D8;
	sub_8211D058(ctx, base);
	pc = 0x821AC3D8; continue 'dispatch;
            }
            0x821AC3D8 => {
    //   block [0x821AC3D8..0x821AC3E0)
	// 821AC3D8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821AC3DC: 48388D14  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC3E0 size=88
    let mut pc: u32 = 0x821AC3E0;
    'dispatch: loop {
        match pc {
            0x821AC3E0 => {
    //   block [0x821AC3E0..0x821AC424)
	// 821AC3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC3E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC3EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC3F0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AC3F4: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AC3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC3FC: 4800003D  bl 0x821ac438
	ctx.lr = 0x821AC400;
	sub_821AC438(ctx, base);
	// 821AC400: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 821AC404: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC40C: 419A0018  beq cr6, 0x821ac424
	if ctx.cr[6].eq {
	pc = 0x821AC424; continue 'dispatch;
	}
	// 821AC410: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC414: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821AC418: 409A000C  bne cr6, 0x821ac424
	if !ctx.cr[6].eq {
	pc = 0x821AC424; continue 'dispatch;
	}
	// 821AC41C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AC420: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x821AC424; continue 'dispatch;
            }
            0x821AC424 => {
    //   block [0x821AC424..0x821AC438)
	// 821AC424: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AC428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC42C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC438 size=96
    let mut pc: u32 = 0x821AC438;
    'dispatch: loop {
        match pc {
            0x821AC438 => {
    //   block [0x821AC438..0x821AC484)
	// 821AC438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC444: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AC44C: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AC450: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AC454: 409A0030  bne cr6, 0x821ac484
	if !ctx.cr[6].eq {
	pc = 0x821AC484; continue 'dispatch;
	}
	// 821AC458: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821AC45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC460: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AC464: 409A0020  bne cr6, 0x821ac484
	if !ctx.cr[6].eq {
	pc = 0x821AC484; continue 'dispatch;
	}
	// 821AC468: E97F00D0  ld r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	// 821AC46C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 821AC470: 419A0014  beq cr6, 0x821ac484
	if ctx.cr[6].eq {
	pc = 0x821AC484; continue 'dispatch;
	}
	// 821AC474: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821AC478: 481CC861  bl 0x82378cd8
	ctx.lr = 0x821AC47C;
	sub_82378CD8(ctx, base);
	// 821AC47C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AC480: F97F00D0  std r11, 0xd0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	pc = 0x821AC484; continue 'dispatch;
            }
            0x821AC484 => {
    //   block [0x821AC484..0x821AC498)
	// 821AC484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AC488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AC498 size=824
    let mut pc: u32 = 0x821AC498;
    'dispatch: loop {
        match pc {
            0x821AC498 => {
    //   block [0x821AC498..0x821AC560)
	// 821AC498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC49C: 48388BFD  bl 0x82535098
	ctx.lr = 0x821AC4A0;
	sub_82535080(ctx, base);
	// 821AC4A0: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 821AC4A4: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 821AC4A8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC4AC: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 821AC4B0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821AC4B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AC4B8: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 821AC4BC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AC4C0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821AC4C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AC4C8: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821AC4CC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC4D0: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 821AC4D4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AC4D8: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 821AC4DC: 3D4B0006  addis r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 393216;
	// 821AC4E0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 821AC4E4: 394AA580  addi r10, r10, -0x5a80
	ctx.r[10].s64 = ctx.r[10].s64 + -23168;
	// 821AC4E8: 3A800005  li r20, 5
	ctx.r[20].s64 = 5;
	// 821AC4EC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821AC4F0: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 821AC4F4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC4FC: 419A0088  beq cr6, 0x821ac584
	if ctx.cr[6].eq {
	pc = 0x821AC584; continue 'dispatch;
	}
	// 821AC500: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC504: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC508: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC50C: 409A0078  bne cr6, 0x821ac584
	if !ctx.cr[6].eq {
	pc = 0x821AC584; continue 'dispatch;
	}
	// 821AC510: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821AC514: E97D0110  ld r11, 0x110(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(272 as u32) ) };
	// 821AC518: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AC51C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC524: 419A003C  beq cr6, 0x821ac560
	if ctx.cr[6].eq {
	pc = 0x821AC560; continue 'dispatch;
	}
	// 821AC528: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC52C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC530: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AC534: 409A002C  bne cr6, 0x821ac560
	if !ctx.cr[6].eq {
	pc = 0x821AC560; continue 'dispatch;
	}
	// 821AC538: 574A06B4  rlwinm r10, r26, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 821AC53C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC540: 409A0070  bne cr6, 0x821ac5b0
	if !ctx.cr[6].eq {
	pc = 0x821AC5B0; continue 'dispatch;
	}
	// 821AC544: A14B0014  lhz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AC548: 9A8B0019  stb r20, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[20].u8 ) };
	// 821AC54C: 614A8000  ori r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 32768;
	// 821AC550: 9B6B0025  stb r27, 0x25(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821AC554: B14B0014  sth r10, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 821AC558: FABD0110  std r21, 0x110(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[21].u64 ) };
	// 821AC55C: 48000054  b 0x821ac5b0
	pc = 0x821AC5B0; continue 'dispatch;
            }
            0x821AC560 => {
    //   block [0x821AC560..0x821AC584)
	// 821AC560: E97D0118  ld r11, 0x118(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) };
	// 821AC564: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AC568: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AC56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC570: 419A0014  beq cr6, 0x821ac584
	if ctx.cr[6].eq {
	pc = 0x821AC584; continue 'dispatch;
	}
	// 821AC574: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC578: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AC57C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC580: 419A0030  beq cr6, 0x821ac5b0
	if ctx.cr[6].eq {
	pc = 0x821AC5B0; continue 'dispatch;
	}
	pc = 0x821AC584; continue 'dispatch;
            }
            0x821AC584 => {
    //   block [0x821AC584..0x821AC5B0)
	// 821AC584: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821AC588: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AC58C: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 821AC590: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821AC594: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821AC598: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AC59C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AC5A0: 48002401  bl 0x821ae9a0
	ctx.lr = 0x821AC5A4;
	sub_821AE9A0(ctx, base);
	// 821AC5A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC5A8: 419A0100  beq cr6, 0x821ac6a8
	if ctx.cr[6].eq {
	pc = 0x821AC6A8; continue 'dispatch;
	}
	// 821AC5AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x821AC5B0; continue 'dispatch;
            }
            0x821AC5B0 => {
    //   block [0x821AC5B0..0x821AC5D8)
	// 821AC5B0: E97D0118  ld r11, 0x118(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(280 as u32) ) };
	// 821AC5B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AC5B8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AC5BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AC5C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AC5C4: 419A0014  beq cr6, 0x821ac5d8
	if ctx.cr[6].eq {
	pc = 0x821AC5D8; continue 'dispatch;
	}
	// 821AC5C8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC5CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AC5D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC5D4: 419A01C4  beq cr6, 0x821ac798
	if ctx.cr[6].eq {
	pc = 0x821AC798; continue 'dispatch;
	}
	pc = 0x821AC5D8; continue 'dispatch;
            }
            0x821AC5D8 => {
    //   block [0x821AC5D8..0x821AC608)
	// 821AC5D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AC5DC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821AC5E0: 38EB0F18  addi r7, r11, 0xf18
	ctx.r[7].s64 = ctx.r[11].s64 + 3864;
	// 821AC5E4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 821AC5E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AC5EC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 821AC5F0: 481BDEA1  bl 0x8236a490
	ctx.lr = 0x821AC5F4;
	sub_8236A490(ctx, base);
	// 821AC5F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AC5F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AC5FC: 419A000C  beq cr6, 0x821ac608
	if ctx.cr[6].eq {
	pc = 0x821AC608; continue 'dispatch;
	}
	// 821AC600: 839F0030  lwz r28, 0x30(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC604: 48000008  b 0x821ac60c
	pc = 0x821AC60C; continue 'dispatch;
            }
            0x821AC608 => {
    //   block [0x821AC608..0x821AC60C)
	// 821AC608: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	pc = 0x821AC60C; continue 'dispatch;
            }
            0x821AC60C => {
    //   block [0x821AC60C..0x821AC6A8)
	// 821AC60C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821AC610: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AC614: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AC618: 419A0090  beq cr6, 0x821ac6a8
	if ctx.cr[6].eq {
	pc = 0x821AC6A8; continue 'dispatch;
	}
	// 821AC61C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AC620: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AC624: 396B0F20  addi r11, r11, 0xf20
	ctx.r[11].s64 = ctx.r[11].s64 + 3872;
	// 821AC628: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AC62C: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821AC630: 3908D9D8  addi r8, r8, -0x2628
	ctx.r[8].s64 = ctx.r[8].s64 + -9768;
	// 821AC634: 3929C7D0  addi r9, r9, -0x3830
	ctx.r[9].s64 = ctx.r[9].s64 + -14384;
	// 821AC638: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AC63C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AC640: 92BF0080  stw r21, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[21].u32 ) };
	// 821AC644: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AC648: B2BF0084  sth r21, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[21].u16 ) };
	// 821AC64C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AC650: B2BF0086  sth r21, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[21].u16 ) };
	// 821AC654: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821AC658: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821AC65C: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AC660: 388056A0  li r4, 0x56a0
	ctx.r[4].s64 = 22176;
	// 821AC664: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821AC668: 394AC878  addi r10, r10, -0x3788
	ctx.r[10].s64 = ctx.r[10].s64 + -14216;
	// 821AC66C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821AC670: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AC674: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 821AC678: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AC67C: 4BFF55B5  bl 0x821a1c30
	ctx.lr = 0x821AC680;
	sub_821A1C30(ctx, base);
	// 821AC680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AC684: 409A0038  bne cr6, 0x821ac6bc
	if !ctx.cr[6].eq {
	pc = 0x821AC6BC; continue 'dispatch;
	}
	// 821AC688: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC68C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821AC690: 409A0018  bne cr6, 0x821ac6a8
	if !ctx.cr[6].eq {
	pc = 0x821AC6A8; continue 'dispatch;
	}
	// 821AC694: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AC698: 9A9F0019  stb r20, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[20].u8 ) };
	// 821AC69C: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821AC6A0: 9B7F0025  stb r27, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[27].u8 ) };
	// 821AC6A4: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x821AC6A8; continue 'dispatch;
            }
            0x821AC6A8 => {
    //   block [0x821AC6A8..0x821AC6BC)
	// 821AC6A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AC6AC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AC6B0: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AC6B4: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821AC6B8: 48388A30  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AC6BC => {
    //   block [0x821AC6BC..0x821AC6D4)
	// 821AC6BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AC6C0: 574A06B4  rlwinm r10, r26, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 821AC6C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AC6C8: F97D0118  std r11, 0x118(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(280 as u32), ctx.r[11].u64 ) };
	// 821AC6CC: 409A0008  bne cr6, 0x821ac6d4
	if !ctx.cr[6].eq {
	pc = 0x821AC6D4; continue 'dispatch;
	}
	// 821AC6D0: FABD0110  std r21, 0x110(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[21].u64 ) };
	pc = 0x821AC6D4; continue 'dispatch;
            }
            0x821AC6D4 => {
    //   block [0x821AC6D4..0x821AC700)
	// 821AC6D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821AC6D8: 419A0030  beq cr6, 0x821ac708
	if ctx.cr[6].eq {
	pc = 0x821AC708; continue 'dispatch;
	}
	// 821AC6DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC6E4: 419A001C  beq cr6, 0x821ac700
	if ctx.cr[6].eq {
	pc = 0x821AC700; continue 'dispatch;
	}
	// 821AC6E8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC6EC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC6F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AC6F4: 409A000C  bne cr6, 0x821ac700
	if !ctx.cr[6].eq {
	pc = 0x821AC700; continue 'dispatch;
	}
	// 821AC6F8: A16B0016  lhz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 821AC6FC: 48000008  b 0x821ac704
	pc = 0x821AC704; continue 'dispatch;
            }
            0x821AC700 => {
    //   block [0x821AC700..0x821AC704)
	// 821AC700: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x821AC704; continue 'dispatch;
            }
            0x821AC704 => {
    //   block [0x821AC704..0x821AC708)
	// 821AC704: B17F0016  sth r11, 0x16(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	pc = 0x821AC708; continue 'dispatch;
            }
            0x821AC708 => {
    //   block [0x821AC708..0x821AC774)
	// 821AC708: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AC70C: D3FF00D8  stfs f31, 0xd8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 821AC710: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AC714: 813F00CC  lwz r9, 0xcc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AC718: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821AC71C: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821AC720: 38C00022  li r6, 0x22
	ctx.r[6].s64 = 34;
	// 821AC724: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AC728: 81410144  lwz r10, 0x144(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 821AC72C: 396B160C  addi r11, r11, 0x160c
	ctx.r[11].s64 = ctx.r[11].s64 + 5644;
	// 821AC730: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AC734: 911F00A8  stw r8, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821AC738: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821AC73C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821AC740: 90DF0094  stw r6, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[6].u32 ) };
	// 821AC744: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821AC748: 3940018C  li r10, 0x18c
	ctx.r[10].s64 = 396;
	// 821AC74C: 7D65582E  lwzx r11, r5, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AC750: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821AC754: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AC758: 909F00A0  stw r4, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 821AC75C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AC760: C1A8BA38  lfs f13, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AC764: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AC768: 39690024  addi r11, r9, 0x24
	ctx.r[11].s64 = ctx.r[9].s64 + 36;
	// 821AC76C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821AC770: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AC774; continue 'dispatch;
            }
            0x821AC774 => {
    //   block [0x821AC774..0x821AC798)
	// 821AC774: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AC778: D1ABFFE8  stfs f13, -0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 821AC77C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AC780: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AC784: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AC788: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821AC78C: 4199FFE8  bgt cr6, 0x821ac774
	if ctx.cr[6].gt {
	pc = 0x821AC774; continue 'dispatch;
	}
	// 821AC790: 92BF00D0  stw r21, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[21].u32 ) };
	// 821AC794: 48000008  b 0x821ac79c
	pc = 0x821AC79C; continue 'dispatch;
            }
            0x821AC798 => {
    //   block [0x821AC798..0x821AC79C)
	// 821AC798: D3FF00D8  stfs f31, 0xd8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	pc = 0x821AC79C; continue 'dispatch;
            }
            0x821AC79C => {
    //   block [0x821AC79C..0x821AC7D0)
	// 821AC79C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821AC7A0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AC7A4: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 821AC7A8: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 821AC7AC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821AC7B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821AC7B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AC7B8: 480028B1  bl 0x821af068
	ctx.lr = 0x821AC7BC;
	sub_821AF068(ctx, base);
	// 821AC7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AC7C0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AC7C4: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AC7C8: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 821AC7CC: 4838891C  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AC7D0 size=164
    let mut pc: u32 = 0x821AC7D0;
    'dispatch: loop {
        match pc {
            0x821AC7D0 => {
    //   block [0x821AC7D0..0x821AC864)
	// 821AC7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC7D4: 483888E5  bl 0x825350b8
	ctx.lr = 0x821AC7D8;
	sub_82535080(ctx, base);
	// 821AC7D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC7DC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AC7E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AC7E4: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AC7E8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AC7EC: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AC7F0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AC7F4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AC7F8: 419A0070  beq cr6, 0x821ac868
	if ctx.cr[6].eq {
	pc = 0x821AC868; continue 'dispatch;
	}
	// 821AC7FC: 83BF00D0  lwz r29, 0xd0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 821AC800: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821AC804: 40990060  ble cr6, 0x821ac864
	if !ctx.cr[6].gt {
	pc = 0x821AC864; continue 'dispatch;
	}
	// 821AC808: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AC80C: 839F00CC  lwz r28, 0xcc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AC810: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821AC814: C03F00D8  lfs f1, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AC818: 3BCB22C0  addi r30, r11, 0x22c0
	ctx.r[30].s64 = ctx.r[11].s64 + 8896;
	// 821AC81C: 38BC4A40  addi r5, r28, 0x4a40
	ctx.r[5].s64 = ctx.r[28].s64 + 19008;
	// 821AC820: 38DE18C0  addi r6, r30, 0x18c0
	ctx.r[6].s64 = ctx.r[30].s64 + 6336;
	// 821AC824: 389E0C60  addi r4, r30, 0xc60
	ctx.r[4].s64 = ctx.r[30].s64 + 3168;
	// 821AC828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AC82C: 480000AD  bl 0x821ac8d8
	ctx.lr = 0x821AC830;
	sub_821AC8D8(ctx, base);
	// 821AC830: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AC834: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AC838: C03F00DC  lfs f1, 0xdc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AC83C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821AC840: 80FF00D4  lwz r7, 0xd4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821AC844: 38BE0C60  addi r5, r30, 0xc60
	ctx.r[5].s64 = ctx.r[30].s64 + 3168;
	// 821AC848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821AC84C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AC850: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 821AC854: 48001245  bl 0x821ada98
	ctx.lr = 0x821AC858;
	sub_821ADA98(ctx, base);
	// 821AC858: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC85C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AC860: 483888A8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821AC864 => {
    //   block [0x821AC864..0x821AC868)
	// 821AC864: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	pc = 0x821AC868; continue 'dispatch;
            }
            0x821AC868 => {
    //   block [0x821AC868..0x821AC874)
	// 821AC868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC86C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AC870: 48388898  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC878 size=92
    let mut pc: u32 = 0x821AC878;
    'dispatch: loop {
        match pc {
            0x821AC878 => {
    //   block [0x821AC878..0x821AC8B0)
	// 821AC878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AC880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AC884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC888: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AC88C: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AC890: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 821AC894: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AC898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC89C: 419A0014  beq cr6, 0x821ac8b0
	if ctx.cr[6].eq {
	pc = 0x821AC8B0; continue 'dispatch;
	}
	// 821AC8A0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AC8A4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AC8A8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AC8AC: 4BFF57D5  bl 0x821a2080
	ctx.lr = 0x821AC8B0;
	sub_821A2080(ctx, base);
	pc = 0x821AC8B0; continue 'dispatch;
            }
            0x821AC8B0 => {
    //   block [0x821AC8B0..0x821AC8D4)
	// 821AC8B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AC8B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AC8B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AC8BC: F94B0118  std r10, 0x118(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), ctx.r[10].u64 ) };
	// 821AC8C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AC8C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AC8C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AC8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AC8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AC8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AC8D8 size=1092
    let mut pc: u32 = 0x821AC8D8;
    'dispatch: loop {
        match pc {
            0x821AC8D8 => {
    //   block [0x821AC8D8..0x821AC91C)
	// 821AC8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AC8DC: 483887D9  bl 0x825350b4
	ctx.lr = 0x821AC8E0;
	sub_82535080(ctx, base);
	// 821AC8E0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821AC8E4: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AC8E8: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821AC8EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AC8F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AC8F4: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821AC8F8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821AC8FC: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821AC900: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AC904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AC908: 419A0014  beq cr6, 0x821ac91c
	if ctx.cr[6].eq {
	pc = 0x821AC91C; continue 'dispatch;
	}
	// 821AC90C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AC910: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AC914: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AC918: 419A0008  beq cr6, 0x821ac920
	if ctx.cr[6].eq {
	pc = 0x821AC920; continue 'dispatch;
	}
	pc = 0x821AC91C; continue 'dispatch;
            }
            0x821AC91C => {
    //   block [0x821AC91C..0x821AC920)
	// 821AC91C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AC920; continue 'dispatch;
            }
            0x821AC920 => {
    //   block [0x821AC920..0x821AC984)
	// 821AC920: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
	// 821AC924: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821AC928: 4099005C  ble cr6, 0x821ac984
	if !ctx.cr[6].gt {
	pc = 0x821AC984; continue 'dispatch;
	}
	// 821AC92C: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 821AC930: 38E90010  addi r7, r9, 0x10
	ctx.r[7].s64 = ctx.r[9].s64 + 16;
	// 821AC934: 38C90020  addi r6, r9, 0x20
	ctx.r[6].s64 = ctx.r[9].s64 + 32;
	// 821AC938: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821AC93C: 7CBB2850  subf r5, r27, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[27].s64;
	// 821AC940: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x821AC984; continue 'dispatch;
            }
            0x821AC984 => {
    //   block [0x821AC984..0x821ACD1C)
	// 821AC984: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821AC988: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 821AC98C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ACD20 size=244
    let mut pc: u32 = 0x821ACD20;
    'dispatch: loop {
        match pc {
            0x821ACD20 => {
    //   block [0x821ACD20..0x821ACD94)
	// 821ACD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ACD28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821ACD2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ACD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ACD38: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821ACD3C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821ACD40: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821ACD44: 612993F0  ori r9, r9, 0x93f0
	ctx.r[9].u64 = ctx.r[9].u64 | 37872;
	// 821ACD48: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ACD4C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ACD50: 808A0080  lwz r4, 0x80(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ACD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACD58: 419A003C  beq cr6, 0x821acd94
	if ctx.cr[6].eq {
	pc = 0x821ACD94; continue 'dispatch;
	}
	// 821ACD5C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ACD60: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 821ACD64: 3BCBB460  addi r30, r11, -0x4ba0
	ctx.r[30].s64 = ctx.r[11].s64 + -19360;
	// 821ACD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ACD6C: 48193B1D  bl 0x82340888
	ctx.lr = 0x821ACD70;
	sub_82340888(ctx, base);
	// 821ACD70: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821ACD74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821ACD78: 419A0064  beq cr6, 0x821acddc
	if ctx.cr[6].eq {
	pc = 0x821ACDDC; continue 'dispatch;
	}
	// 821ACD7C: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 821ACD80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ACD84: 48193B05  bl 0x82340888
	ctx.lr = 0x821ACD88;
	sub_82340888(ctx, base);
	// 821ACD88: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821ACD8C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821ACD90: 419A004C  beq cr6, 0x821acddc
	if ctx.cr[6].eq {
	pc = 0x821ACDDC; continue 'dispatch;
	}
	pc = 0x821ACD94; continue 'dispatch;
            }
            0x821ACD94 => {
    //   block [0x821ACD94..0x821ACDDC)
	// 821ACD94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821ACD98: 419A0064  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACD9C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACDA0: 616B9C00  ori r11, r11, 0x9c00
	ctx.r[11].u64 = ctx.r[11].u64 | 39936;
	// 821ACDA4: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACDA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDAC: 419A0050  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDB0: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ACDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDB8: 419A0044  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDBC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACDC0: 616BEB2B  ori r11, r11, 0xeb2b
	ctx.r[11].u64 = ctx.r[11].u64 | 60203;
	// 821ACDC4: 7D6458AE  lbzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDCC: 409A0030  bne cr6, 0x821acdfc
	if !ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	// 821ACDD0: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ACDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACDD8: 419A0024  beq cr6, 0x821acdfc
	if ctx.cr[6].eq {
	pc = 0x821ACDFC; continue 'dispatch;
	}
	pc = 0x821ACDDC; continue 'dispatch;
            }
            0x821ACDDC => {
    //   block [0x821ACDDC..0x821ACDFC)
	// 821ACDDC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821ACDE0: 80DF00CC  lwz r6, 0xcc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821ACDE4: 38BF0090  addi r5, r31, 0x90
	ctx.r[5].s64 = ctx.r[31].s64 + 144;
	// 821ACDE8: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821ACDEC: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821ACDF0: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 821ACDF4: 38EB00E0  addi r7, r11, 0xe0
	ctx.r[7].s64 = ctx.r[11].s64 + 224;
	// 821ACDF8: 481C0B11  bl 0x8236d908
	ctx.lr = 0x821ACDFC;
	sub_8236D908(ctx, base);
	pc = 0x821ACDFC; continue 'dispatch;
            }
            0x821ACDFC => {
    //   block [0x821ACDFC..0x821ACE14)
	// 821ACDFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821ACE00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ACE04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ACE08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821ACE0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ACE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ACE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ACE18 size=2104
    let mut pc: u32 = 0x821ACE18;
    'dispatch: loop {
        match pc {
            0x821ACE18 => {
    //   block [0x821ACE18..0x821ACE6C)
	// 821ACE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ACE1C: 4838826D  bl 0x82535088
	ctx.lr = 0x821ACE20;
	sub_82535080(ctx, base);
	// 821ACE20: DBC1FF68  stfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 821ACE24: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 821ACE28: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ACE2C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACE30: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821ACE34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821ACE38: 616ABEB8  ori r10, r11, 0xbeb8
	ctx.r[10].u64 = ctx.r[11].u64 | 48824;
	// 821ACE3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821ACE40: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821ACE44: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821ACE48: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821ACE4C: 7E1C522E  lhzx r16, r28, r10
	ctx.r[16].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821ACE50: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 821ACE54: C3CB24D0  lfs f30, 0x24d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9424 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ACE58: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 821ACE5C: 2B100027  cmplwi cr6, r16, 0x27
	ctx.cr[6].compare_u32(ctx.r[16].u32, 39 as u32, &mut ctx.xer);
	// 821ACE60: 419A000C  beq cr6, 0x821ace6c
	if ctx.cr[6].eq {
	pc = 0x821ACE6C; continue 'dispatch;
	}
	// 821ACE64: 2B100026  cmplwi cr6, r16, 0x26
	ctx.cr[6].compare_u32(ctx.r[16].u32, 38 as u32, &mut ctx.xer);
	// 821ACE68: 409A0014  bne cr6, 0x821ace7c
	if !ctx.cr[6].eq {
	pc = 0x821ACE7C; continue 'dispatch;
	}
	pc = 0x821ACE6C; continue 'dispatch;
            }
            0x821ACE6C => {
    //   block [0x821ACE6C..0x821ACE7C)
	// 821ACE6C: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 821ACE70: 3AA00005  li r21, 5
	ctx.r[21].s64 = 5;
	// 821ACE74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ACE78: 419A0008  beq cr6, 0x821ace80
	if ctx.cr[6].eq {
	pc = 0x821ACE80; continue 'dispatch;
	}
	pc = 0x821ACE7C; continue 'dispatch;
            }
            0x821ACE7C => {
    //   block [0x821ACE7C..0x821ACE80)
	// 821ACE7C: 82A1016C  lwz r21, 0x16c(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	pc = 0x821ACE80; continue 'dispatch;
            }
            0x821ACE80 => {
    //   block [0x821ACE80..0x821ACEB0)
	// 821ACE80: 7F110734  extsh r17, r24
	ctx.r[17].s64 = ctx.r[24].s16 as i64;
	// 821ACE84: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACE88: 2F110001  cmpwi cr6, r17, 1
	ctx.cr[6].compare_i32(ctx.r[17].s32, 1, &mut ctx.xer);
	// 821ACE8C: 6172BEBC  ori r18, r11, 0xbebc
	ctx.r[18].u64 = ctx.r[11].u64 | 48828;
	// 821ACE90: 409A0020  bne cr6, 0x821aceb0
	if !ctx.cr[6].eq {
	pc = 0x821ACEB0; continue 'dispatch;
	}
	// 821ACE94: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821ACE98: 7D5C922E  lhzx r10, r28, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821ACE9C: 396B5720  addi r11, r11, 0x5720
	ctx.r[11].s64 = ctx.r[11].s64 + 22304;
	// 821ACEA0: 7D6A58AE  lbzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACEA4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821ACEA8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821ACEAC: 41980444  blt cr6, 0x821ad2f0
	if ctx.cr[6].lt {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	pc = 0x821ACEB0; continue 'dispatch;
            }
            0x821ACEB0 => {
    //   block [0x821ACEB0..0x821ACED8)
	// 821ACEB0: 7E6B0734  extsh r11, r19
	ctx.r[11].s64 = ctx.r[19].s16 as i64;
	// 821ACEB4: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 821ACEB8: 409A0078  bne cr6, 0x821acf30
	if !ctx.cr[6].eq {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACEBC: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821ACEC0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 821ACEC4: 409A0014  bne cr6, 0x821aced8
	if !ctx.cr[6].eq {
	pc = 0x821ACED8; continue 'dispatch;
	}
	// 821ACEC8: 2F110002  cmpwi cr6, r17, 2
	ctx.cr[6].compare_i32(ctx.r[17].s32, 2, &mut ctx.xer);
	// 821ACECC: 409A000C  bne cr6, 0x821aced8
	if !ctx.cr[6].eq {
	pc = 0x821ACED8; continue 'dispatch;
	}
	// 821ACED0: 3A600100  li r19, 0x100
	ctx.r[19].s64 = 256;
	// 821ACED4: 4800005C  b 0x821acf30
	pc = 0x821ACF30; continue 'dispatch;
            }
            0x821ACED8 => {
    //   block [0x821ACED8..0x821ACF04)
	// 821ACED8: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821ACEDC: 409A0030  bne cr6, 0x821acf0c
	if !ctx.cr[6].eq {
	pc = 0x821ACF0C; continue 'dispatch;
	}
	// 821ACEE0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACEE4: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821ACEE8: 7D7C5A2E  lhzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACEEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821ACEF0: 419A0014  beq cr6, 0x821acf04
	if ctx.cr[6].eq {
	pc = 0x821ACF04; continue 'dispatch;
	}
	// 821ACEF4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821ACEF8: 409A0038  bne cr6, 0x821acf30
	if !ctx.cr[6].eq {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACEFC: 3A600102  li r19, 0x102
	ctx.r[19].s64 = 258;
	// 821ACF00: 48000030  b 0x821acf30
	pc = 0x821ACF30; continue 'dispatch;
            }
            0x821ACF04 => {
    //   block [0x821ACF04..0x821ACF0C)
	// 821ACF04: 3A600101  li r19, 0x101
	ctx.r[19].s64 = 257;
	// 821ACF08: 48000028  b 0x821acf30
	pc = 0x821ACF30; continue 'dispatch;
            }
            0x821ACF0C => {
    //   block [0x821ACF0C..0x821ACF30)
	// 821ACF0C: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 821ACF10: 409A0020  bne cr6, 0x821acf30
	if !ctx.cr[6].eq {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACF14: 2F110001  cmpwi cr6, r17, 1
	ctx.cr[6].compare_i32(ctx.r[17].s32, 1, &mut ctx.xer);
	// 821ACF18: 41980018  blt cr6, 0x821acf30
	if ctx.cr[6].lt {
	pc = 0x821ACF30; continue 'dispatch;
	}
	// 821ACF1C: 3971FFFF  addi r11, r17, -1
	ctx.r[11].s64 = ctx.r[17].s64 + -1;
	// 821ACF20: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821ACF24: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821ACF28: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 821ACF2C: 3A6B0103  addi r19, r11, 0x103
	ctx.r[19].s64 = ctx.r[11].s64 + 259;
	pc = 0x821ACF30; continue 'dispatch;
            }
            0x821ACF30 => {
    //   block [0x821ACF30..0x821ACF50)
	// 821ACF30: 7CF40734  extsh r20, r7
	ctx.r[20].s64 = ctx.r[7].s16 as i64;
	// 821ACF34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821ACF38: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 821ACF3C: 419A0014  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF40: 2F14FFFF  cmpwi cr6, r20, -1
	ctx.cr[6].compare_i32(ctx.r[20].s32, -1, &mut ctx.xer);
	// 821ACF44: 419A000C  beq cr6, 0x821acf50
	if ctx.cr[6].eq {
	pc = 0x821ACF50; continue 'dispatch;
	}
	// 821ACF48: 2F140001  cmpwi cr6, r20, 1
	ctx.cr[6].compare_i32(ctx.r[20].s32, 1, &mut ctx.xer);
	// 821ACF4C: 409A01EC  bne cr6, 0x821ad138
	if !ctx.cr[6].eq {
	pc = 0x821AD138; continue 'dispatch;
	}
	pc = 0x821ACF50; continue 'dispatch;
            }
            0x821ACF50 => {
    //   block [0x821ACF50..0x821ACFD0)
	// 821ACF50: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ACF54: 616BE2D4  ori r11, r11, 0xe2d4
	ctx.r[11].u64 = ctx.r[11].u64 | 58068;
	// 821ACF58: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821ACF5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ACF60: 419A0080  beq cr6, 0x821acfe0
	if ctx.cr[6].eq {
	pc = 0x821ACFE0; continue 'dispatch;
	}
	// 821ACF64: A16B0034  lhz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821ACF68: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821ACF6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821ACF70: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 821ACF74: 4199006C  bgt cr6, 0x821acfe0
	if ctx.cr[6].gt {
	pc = 0x821ACFE0; continue 'dispatch;
	}
	// 821ACF78: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821ACF7C: 398CCF90  addi r12, r12, -0x3070
	ctx.r[12].s64 = ctx.r[12].s64 + -12400;
	// 821ACF80: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821ACF84: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821ACF88: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821ACF8C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821ACFD0; continue 'dispatch;
		},
		1 => {
	pc = 0x821ACFD0; continue 'dispatch;
		},
		2 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		3 => {
	pc = 0x821ACFD8; continue 'dispatch;
		},
		4 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		5 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		6 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		7 => {
	pc = 0x821ACFD8; continue 'dispatch;
		},
		8 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		9 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		10 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		11 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		12 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		13 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		14 => {
	pc = 0x821ACFE0; continue 'dispatch;
		},
		15 => {
	pc = 0x821ACFD8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821ACF90: 821ACFD0  lwz r16, -0x3030(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12336 as u32) ) } as u64;
	// 821ACF94: 821ACFD0  lwz r16, -0x3030(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12336 as u32) ) } as u64;
	// 821ACF98: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACF9C: 821ACFD8  lwz r16, -0x3028(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12328 as u32) ) } as u64;
	// 821ACFA0: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFA4: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFA8: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFAC: 821ACFD8  lwz r16, -0x3028(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12328 as u32) ) } as u64;
	// 821ACFB0: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFB4: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFB8: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFBC: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFC0: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFC4: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFC8: 821ACFE0  lwz r16, -0x3020(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12320 as u32) ) } as u64;
	// 821ACFCC: 821ACFD8  lwz r16, -0x3028(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12328 as u32) ) } as u64;
            }
            0x821ACFD0 => {
    //   block [0x821ACFD0..0x821ACFD8)
	// 821ACFD0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821ACFD4: 48000010  b 0x821acfe4
	pc = 0x821ACFE4; continue 'dispatch;
            }
            0x821ACFD8 => {
    //   block [0x821ACFD8..0x821ACFE0)
	// 821ACFD8: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 821ACFDC: 48000008  b 0x821acfe4
	pc = 0x821ACFE4; continue 'dispatch;
            }
            0x821ACFE0 => {
    //   block [0x821ACFE0..0x821ACFE4)
	// 821ACFE0: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	pc = 0x821ACFE4; continue 'dispatch;
            }
            0x821ACFE4 => {
    //   block [0x821ACFE4..0x821AD028)
	// 821ACFE4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821ACFE8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821ACFEC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821ACFF0: 614A93F0  ori r10, r10, 0x93f0
	ctx.r[10].u64 = ctx.r[10].u64 | 37872;
	// 821ACFF4: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821ACFF8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ACFFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD000: 3B6BB460  addi r27, r11, -0x4ba0
	ctx.r[27].s64 = ctx.r[11].s64 + -19360;
	// 821AD004: 419A0024  beq cr6, 0x821ad028
	if ctx.cr[6].eq {
	pc = 0x821AD028; continue 'dispatch;
	}
	// 821AD008: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 821AD00C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AD010: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AD014: 48193875  bl 0x82340888
	ctx.lr = 0x821AD018;
	sub_82340888(ctx, base);
	// 821AD018: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD01C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821AD020: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD024: 419A0008  beq cr6, 0x821ad02c
	if ctx.cr[6].eq {
	pc = 0x821AD02C; continue 'dispatch;
	}
	pc = 0x821AD028; continue 'dispatch;
            }
            0x821AD028 => {
    //   block [0x821AD028..0x821AD02C)
	// 821AD028: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	pc = 0x821AD02C; continue 'dispatch;
            }
            0x821AD02C => {
    //   block [0x821AD02C..0x821AD054)
	// 821AD02C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD030: 419A0024  beq cr6, 0x821ad054
	if ctx.cr[6].eq {
	pc = 0x821AD054; continue 'dispatch;
	}
	// 821AD034: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 821AD038: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AD03C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AD040: 48193849  bl 0x82340888
	ctx.lr = 0x821AD044;
	sub_82340888(ctx, base);
	// 821AD044: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD048: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD04C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AD050: 419A0008  beq cr6, 0x821ad058
	if ctx.cr[6].eq {
	pc = 0x821AD058; continue 'dispatch;
	}
	pc = 0x821AD054; continue 'dispatch;
            }
            0x821AD054 => {
    //   block [0x821AD054..0x821AD058)
	// 821AD054: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821AD058; continue 'dispatch;
            }
            0x821AD058 => {
    //   block [0x821AD058..0x821AD070)
	// 821AD058: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821AD05C: 409A0014  bne cr6, 0x821ad070
	if !ctx.cr[6].eq {
	pc = 0x821AD070; continue 'dispatch;
	}
	// 821AD060: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD064: 409A001C  bne cr6, 0x821ad080
	if !ctx.cr[6].eq {
	pc = 0x821AD080; continue 'dispatch;
	}
	// 821AD068: 63DE0020  ori r30, r30, 0x20
	ctx.r[30].u64 = ctx.r[30].u64 | 32;
	// 821AD06C: 4800003C  b 0x821ad0a8
	pc = 0x821AD0A8; continue 'dispatch;
            }
            0x821AD070 => {
    //   block [0x821AD070..0x821AD080)
	// 821AD070: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 821AD074: 419A0014  beq cr6, 0x821ad088
	if ctx.cr[6].eq {
	pc = 0x821AD088; continue 'dispatch;
	}
	// 821AD078: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD07C: 419A0020  beq cr6, 0x821ad09c
	if ctx.cr[6].eq {
	pc = 0x821AD09C; continue 'dispatch;
	}
	pc = 0x821AD080; continue 'dispatch;
            }
            0x821AD080 => {
    //   block [0x821AD080..0x821AD088)
	// 821AD080: 2F190002  cmpwi cr6, r25, 2
	ctx.cr[6].compare_i32(ctx.r[25].s32, 2, &mut ctx.xer);
	// 821AD084: 409A0018  bne cr6, 0x821ad09c
	if !ctx.cr[6].eq {
	pc = 0x821AD09C; continue 'dispatch;
	}
	pc = 0x821AD088; continue 'dispatch;
            }
            0x821AD088 => {
    //   block [0x821AD088..0x821AD09C)
	// 821AD088: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD08C: 63DE0060  ori r30, r30, 0x60
	ctx.r[30].u64 = ctx.r[30].u64 | 96;
	// 821AD090: 3A6000C2  li r19, 0xc2
	ctx.r[19].s64 = 194;
	// 821AD094: C3CB240C  lfs f30, 0x240c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9228 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821AD098: 48000010  b 0x821ad0a8
	pc = 0x821AD0A8; continue 'dispatch;
            }
            0x821AD09C => {
    //   block [0x821AD09C..0x821AD0A8)
	// 821AD09C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD0A0: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD0A4: EFFF0032  fmuls f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x821AD0A8; continue 'dispatch;
            }
            0x821AD0A8 => {
    //   block [0x821AD0A8..0x821AD0C4)
	// 821AD0A8: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821AD0AC: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 821AD0B0: 419A0014  beq cr6, 0x821ad0c4
	if ctx.cr[6].eq {
	pc = 0x821AD0C4; continue 'dispatch;
	}
	// 821AD0B4: 2B0B002A  cmplwi cr6, r11, 0x2a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 42 as u32, &mut ctx.xer);
	// 821AD0B8: 419A000C  beq cr6, 0x821ad0c4
	if ctx.cr[6].eq {
	pc = 0x821AD0C4; continue 'dispatch;
	}
	// 821AD0BC: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 821AD0C0: 409A0014  bne cr6, 0x821ad0d4
	if !ctx.cr[6].eq {
	pc = 0x821AD0D4; continue 'dispatch;
	}
	pc = 0x821AD0C4; continue 'dispatch;
            }
            0x821AD0C4 => {
    //   block [0x821AD0C4..0x821AD0D4)
	// 821AD0C4: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 821AD0C8: 409A000C  bne cr6, 0x821ad0d4
	if !ctx.cr[6].eq {
	pc = 0x821AD0D4; continue 'dispatch;
	}
	// 821AD0CC: 38E00018  li r7, 0x18
	ctx.r[7].s64 = 24;
	// 821AD0D0: 48000068  b 0x821ad138
	pc = 0x821AD138; continue 'dispatch;
            }
            0x821AD0D4 => {
    //   block [0x821AD0D4..0x821AD10C)
	// 821AD0D4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821AD0D8: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 821AD0DC: 614ABECC  ori r10, r10, 0xbecc
	ctx.r[10].u64 = ctx.r[10].u64 | 48844;
	// 821AD0E0: 409A002C  bne cr6, 0x821ad10c
	if !ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD0E4: 7D3C502E  lwzx r9, r28, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AD0E8: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 821AD0EC: 409A0020  bne cr6, 0x821ad10c
	if !ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD0F0: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 821AD0F4: 409A0018  bne cr6, 0x821ad10c
	if !ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD0F8: 2F140001  cmpwi cr6, r20, 1
	ctx.cr[6].compare_i32(ctx.r[20].s32, 1, &mut ctx.xer);
	// 821AD0FC: 419A0010  beq cr6, 0x821ad10c
	if ctx.cr[6].eq {
	pc = 0x821AD10C; continue 'dispatch;
	}
	// 821AD100: 38E0001A  li r7, 0x1a
	ctx.r[7].s64 = 26;
	// 821AD104: 3AA00005  li r21, 5
	ctx.r[21].s64 = 5;
	// 821AD108: 48000030  b 0x821ad138
	pc = 0x821AD138; continue 'dispatch;
            }
            0x821AD10C => {
    //   block [0x821AD10C..0x821AD134)
	// 821AD10C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821AD110: 409A0024  bne cr6, 0x821ad134
	if !ctx.cr[6].eq {
	pc = 0x821AD134; continue 'dispatch;
	}
	// 821AD114: 7D7C502E  lwzx r11, r28, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AD118: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 821AD11C: 409A0018  bne cr6, 0x821ad134
	if !ctx.cr[6].eq {
	pc = 0x821AD134; continue 'dispatch;
	}
	// 821AD120: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 821AD124: 409A0010  bne cr6, 0x821ad134
	if !ctx.cr[6].eq {
	pc = 0x821AD134; continue 'dispatch;
	}
	// 821AD128: 2F140001  cmpwi cr6, r20, 1
	ctx.cr[6].compare_i32(ctx.r[20].s32, 1, &mut ctx.xer);
	// 821AD12C: 38E0001B  li r7, 0x1b
	ctx.r[7].s64 = 27;
	// 821AD130: 409A0008  bne cr6, 0x821ad138
	if !ctx.cr[6].eq {
	pc = 0x821AD138; continue 'dispatch;
	}
	pc = 0x821AD134; continue 'dispatch;
            }
            0x821AD134 => {
    //   block [0x821AD134..0x821AD138)
	// 821AD134: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x821AD138; continue 'dispatch;
            }
            0x821AD138 => {
    //   block [0x821AD138..0x821AD148)
	// 821AD138: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 821AD13C: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 821AD140: 409A0008  bne cr6, 0x821ad148
	if !ctx.cr[6].eq {
	pc = 0x821AD148; continue 'dispatch;
	}
	// 821AD144: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x821AD148; continue 'dispatch;
            }
            0x821AD148 => {
    //   block [0x821AD148..0x821AD178)
	// 821AD148: 7CEB0734  extsh r11, r7
	ctx.r[11].s64 = ctx.r[7].s16 as i64;
	// 821AD14C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821AD150: 419800D4  blt cr6, 0x821ad224
	if ctx.cr[6].lt {
	pc = 0x821AD224; continue 'dispatch;
	}
	// 821AD154: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 821AD158: 409800CC  bge cr6, 0x821ad224
	if !ctx.cr[6].lt {
	pc = 0x821AD224; continue 'dispatch;
	}
	// 821AD15C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821AD160: 56E6047E  clrlwi r6, r23, 0x11
	ctx.r[6].u64 = ctx.r[23].u32 as u64 & 0x00007FFFu64;
	// 821AD164: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 821AD168: 7CCB0734  extsh r11, r6
	ctx.r[11].s64 = ctx.r[6].s16 as i64;
	// 821AD16C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 821AD170: 409A0008  bne cr6, 0x821ad178
	if !ctx.cr[6].eq {
	pc = 0x821AD178; continue 'dispatch;
	}
	// 821AD174: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	pc = 0x821AD178; continue 'dispatch;
            }
            0x821AD178 => {
    //   block [0x821AD178..0x821AD190)
	// 821AD178: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821AD17C: 2B0B001B  cmplwi cr6, r11, 0x1b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 27 as u32, &mut ctx.xer);
	// 821AD180: 409A0010  bne cr6, 0x821ad190
	if !ctx.cr[6].eq {
	pc = 0x821AD190; continue 'dispatch;
	}
	// 821AD184: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD188: 396B15A0  addi r11, r11, 0x15a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5536;
	// 821AD18C: 48000020  b 0x821ad1ac
	pc = 0x821AD1AC; continue 'dispatch;
            }
            0x821AD190 => {
    //   block [0x821AD190..0x821AD1A4)
	// 821AD190: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821AD194: 409A0010  bne cr6, 0x821ad1a4
	if !ctx.cr[6].eq {
	pc = 0x821AD1A4; continue 'dispatch;
	}
	// 821AD198: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD19C: 396B1630  addi r11, r11, 0x1630
	ctx.r[11].s64 = ctx.r[11].s64 + 5680;
	// 821AD1A0: 4800000C  b 0x821ad1ac
	pc = 0x821AD1AC; continue 'dispatch;
            }
            0x821AD1A4 => {
    //   block [0x821AD1A4..0x821AD1AC)
	// 821AD1A4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD1A8: 396B1528  addi r11, r11, 0x1528
	ctx.r[11].s64 = ctx.r[11].s64 + 5416;
	pc = 0x821AD1AC; continue 'dispatch;
            }
            0x821AD1AC => {
    //   block [0x821AD1AC..0x821AD1C8)
	// 821AD1AC: 562A103A  slwi r10, r17, 2
	ctx.r[10].u32 = ctx.r[17].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AD1B0: 2B10000B  cmplwi cr6, r16, 0xb
	ctx.cr[6].compare_u32(ctx.r[16].u32, 11 as u32, &mut ctx.xer);
	// 821AD1B4: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AD1B8: 409A0010  bne cr6, 0x821ad1c8
	if !ctx.cr[6].eq {
	pc = 0x821AD1C8; continue 'dispatch;
	}
	// 821AD1BC: 2F050017  cmpwi cr6, r5, 0x17
	ctx.cr[6].compare_i32(ctx.r[5].s32, 23, &mut ctx.xer);
	// 821AD1C0: 409A0008  bne cr6, 0x821ad1c8
	if !ctx.cr[6].eq {
	pc = 0x821AD1C8; continue 'dispatch;
	}
	// 821AD1C4: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	pc = 0x821AD1C8; continue 'dispatch;
            }
            0x821AD1C8 => {
    //   block [0x821AD1C8..0x821AD1EC)
	// 821AD1C8: 7E6B0734  extsh r11, r19
	ctx.r[11].s64 = ctx.r[19].s16 as i64;
	// 821AD1CC: 2F0B00C1  cmpwi cr6, r11, 0xc1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 193, &mut ctx.xer);
	// 821AD1D0: 409A001C  bne cr6, 0x821ad1ec
	if !ctx.cr[6].eq {
	pc = 0x821AD1EC; continue 'dispatch;
	}
	// 821AD1D4: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 821AD1D8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD1DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AD1E0: 396B53C8  addi r11, r11, 0x53c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21448;
	// 821AD1E4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AD1E8: 7D730734  extsh r19, r11
	ctx.r[19].s64 = ctx.r[11].s16 as i64;
	pc = 0x821AD1EC; continue 'dispatch;
            }
            0x821AD1EC => {
    //   block [0x821AD1EC..0x821AD224)
	// 821AD1EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AD1F0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821AD1F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AD1F8: 7E680734  extsh r8, r19
	ctx.r[8].s64 = ctx.r[19].s16 as i64;
	// 821AD1FC: 7D270734  extsh r7, r9
	ctx.r[7].s64 = ctx.r[9].s16 as i64;
	// 821AD200: 7CC60734  extsh r6, r6
	ctx.r[6].s64 = ctx.r[6].s16 as i64;
	// 821AD204: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AD208: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AD20C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821AD210: 4BFF38B9  bl 0x821a0ac8
	ctx.lr = 0x821AD214;
	sub_821A0AC8(ctx, base);
	// 821AD214: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD218: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD21C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD220: 48387EB8  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD224 => {
    //   block [0x821AD224..0x821AD2B8)
	// 821AD224: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AD228: 2B0B001A  cmplwi cr6, r11, 0x1a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 26 as u32, &mut ctx.xer);
	// 821AD22C: 41990420  bgt cr6, 0x821ad64c
	if ctx.cr[6].gt {
	pc = 0x821AD64C; continue 'dispatch;
	}
	// 821AD230: 83E10164  lwz r31, 0x164(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD234: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821AD238: 398CD24C  addi r12, r12, -0x2db4
	ctx.r[12].s64 = ctx.r[12].s64 + -11700;
	// 821AD23C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821AD240: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821AD244: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821AD248: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821AD2B8; continue 'dispatch;
		},
		1 => {
	pc = 0x821AD3D8; continue 'dispatch;
		},
		2 => {
	pc = 0x821AD300; continue 'dispatch;
		},
		3 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		4 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		5 => {
	pc = 0x821AD394; continue 'dispatch;
		},
		6 => {
	pc = 0x821AD364; continue 'dispatch;
		},
		7 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		8 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		9 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		10 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		11 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		12 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		13 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		14 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		15 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		16 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		17 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		18 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		19 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		20 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		21 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		22 => {
	pc = 0x821AD64C; continue 'dispatch;
		},
		23 => {
	pc = 0x821AD470; continue 'dispatch;
		},
		24 => {
	pc = 0x821AD430; continue 'dispatch;
		},
		25 => {
	pc = 0x821AD554; continue 'dispatch;
		},
		26 => {
	pc = 0x821AD5D0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821AD24C: 821AD2B8  lwz r16, -0x2d48(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11592 as u32) ) } as u64;
	// 821AD250: 821AD3D8  lwz r16, -0x2c28(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11304 as u32) ) } as u64;
	// 821AD254: 821AD300  lwz r16, -0x2d00(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11520 as u32) ) } as u64;
	// 821AD258: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD25C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD260: 821AD394  lwz r16, -0x2c6c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11372 as u32) ) } as u64;
	// 821AD264: 821AD364  lwz r16, -0x2c9c(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11420 as u32) ) } as u64;
	// 821AD268: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD26C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD270: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD274: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD278: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD27C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD280: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD284: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD288: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD28C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD290: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD294: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD298: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD29C: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD2A0: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD2A4: 821AD64C  lwz r16, -0x29b4(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10676 as u32) ) } as u64;
	// 821AD2A8: 821AD470  lwz r16, -0x2b90(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11152 as u32) ) } as u64;
	// 821AD2AC: 821AD430  lwz r16, -0x2bd0(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-11216 as u32) ) } as u64;
	// 821AD2B0: 821AD554  lwz r16, -0x2aac(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10924 as u32) ) } as u64;
	// 821AD2B4: 821AD5D0  lwz r16, -0x2a30(r26)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-10800 as u32) ) } as u64;
            }
            0x821AD2B8 => {
    //   block [0x821AD2B8..0x821AD2E4)
	// 821AD2B8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD2BC: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD2C0: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD2C4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD2C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AD2CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD2D0: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD2D4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD2D8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD2DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD2E0: 48000371  bl 0x821ad650
	ctx.lr = 0x821AD2E4;
	sub_821AD650(ctx, base);
	pc = 0x821AD2E4; continue 'dispatch;
            }
            0x821AD2E4 => {
    //   block [0x821AD2E4..0x821AD2F0)
	// 821AD2E4: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD2EC: 409A00EC  bne cr6, 0x821ad3d8
	if !ctx.cr[6].eq {
	pc = 0x821AD3D8; continue 'dispatch;
	}
	pc = 0x821AD2F0; continue 'dispatch;
            }
            0x821AD2F0 => {
    //   block [0x821AD2F0..0x821AD300)
	// 821AD2F0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD2F4: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD2F8: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD2FC: 48387DDC  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD300 => {
    //   block [0x821AD300..0x821AD31C)
	// 821AD300: 2F110019  cmpwi cr6, r17, 0x19
	ctx.cr[6].compare_i32(ctx.r[17].s32, 25, &mut ctx.xer);
	// 821AD304: 419A0018  beq cr6, 0x821ad31c
	if ctx.cr[6].eq {
	pc = 0x821AD31C; continue 'dispatch;
	}
	// 821AD308: 2F11001A  cmpwi cr6, r17, 0x1a
	ctx.cr[6].compare_i32(ctx.r[17].s32, 26, &mut ctx.xer);
	// 821AD30C: 419A0010  beq cr6, 0x821ad31c
	if ctx.cr[6].eq {
	pc = 0x821AD31C; continue 'dispatch;
	}
	// 821AD310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD314: C04B2098  lfs f2, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AD318: 4800000C  b 0x821ad324
	pc = 0x821AD324; continue 'dispatch;
            }
            0x821AD31C => {
    //   block [0x821AD31C..0x821AD324)
	// 821AD31C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD320: C04B2090  lfs f2, 0x2090(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8336 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	pc = 0x821AD324; continue 'dispatch;
            }
            0x821AD324 => {
    //   block [0x821AD324..0x821AD364)
	// 821AD324: 81610164  lwz r11, 0x164(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD328: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD32C: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD330: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821AD334: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AD338: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD33C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD340: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD344: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD348: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821AD34C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD350: 4BFFF149  bl 0x821ac498
	ctx.lr = 0x821AD354;
	sub_821AC498(ctx, base);
	// 821AD354: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD358: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD35C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD360: 48387D78  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD364 => {
    //   block [0x821AD364..0x821AD394)
	// 821AD364: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD368: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD36C: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD370: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD374: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821AD378: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD37C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD380: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD384: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD38C: 480002C5  bl 0x821ad650
	ctx.lr = 0x821AD390;
	sub_821AD650(ctx, base);
	// 821AD390: 4BFFFF54  b 0x821ad2e4
	pc = 0x821AD2E4; continue 'dispatch;
            }
            0x821AD394 => {
    //   block [0x821AD394..0x821AD3D8)
	// 821AD394: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD398: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD39C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD3A0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD3A4: 390000C1  li r8, 0xc1
	ctx.r[8].s64 = 193;
	// 821AD3A8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821AD3AC: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD3B0: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD3B4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD3B8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD3BC: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AD3C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD3C4: 3A6000C1  li r19, 0xc1
	ctx.r[19].s64 = 193;
	// 821AD3C8: 48000289  bl 0x821ad650
	ctx.lr = 0x821AD3CC;
	sub_821AD650(ctx, base);
	// 821AD3CC: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD3D4: 419AFF1C  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	pc = 0x821AD3D8; continue 'dispatch;
            }
            0x821AD3D8 => {
    //   block [0x821AD3D8..0x821AD3E8)
	// 821AD3D8: 2F110019  cmpwi cr6, r17, 0x19
	ctx.cr[6].compare_i32(ctx.r[17].s32, 25, &mut ctx.xer);
	// 821AD3DC: 419A000C  beq cr6, 0x821ad3e8
	if ctx.cr[6].eq {
	pc = 0x821AD3E8; continue 'dispatch;
	}
	// 821AD3E0: 2F11001A  cmpwi cr6, r17, 0x1a
	ctx.cr[6].compare_i32(ctx.r[17].s32, 26, &mut ctx.xer);
	// 821AD3E4: 409A000C  bne cr6, 0x821ad3f0
	if !ctx.cr[6].eq {
	pc = 0x821AD3F0; continue 'dispatch;
	}
	pc = 0x821AD3E8; continue 'dispatch;
            }
            0x821AD3E8 => {
    //   block [0x821AD3E8..0x821AD3F0)
	// 821AD3E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD3EC: C3CB209C  lfs f30, 0x209c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821AD3F0; continue 'dispatch;
            }
            0x821AD3F0 => {
    //   block [0x821AD3F0..0x821AD430)
	// 821AD3F0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD3F4: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821AD3F8: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD3FC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821AD400: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AD404: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD408: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD40C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD410: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD414: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD418: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD41C: 4BFFF07D  bl 0x821ac498
	ctx.lr = 0x821AD420;
	sub_821AC498(ctx, base);
	// 821AD420: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD424: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD428: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD42C: 48387CAC  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD430 => {
    //   block [0x821AD430..0x821AD470)
	// 821AD430: 81610164  lwz r11, 0x164(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD434: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD438: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD43C: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD440: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 821AD444: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD448: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD44C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD450: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD454: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821AD458: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD45C: 480001F5  bl 0x821ad650
	ctx.lr = 0x821AD460;
	sub_821AD650(ctx, base);
	// 821AD460: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD464: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD468: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD46C: 48387C6C  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD470 => {
    //   block [0x821AD470..0x821AD488)
	// 821AD470: 7D7C922E  lhzx r11, r28, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821AD474: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 821AD478: 409A0010  bne cr6, 0x821ad488
	if !ctx.cr[6].eq {
	pc = 0x821AD488; continue 'dispatch;
	}
	// 821AD47C: 3BA00040  li r29, 0x40
	ctx.r[29].s64 = 64;
	// 821AD480: 3B400156  li r26, 0x156
	ctx.r[26].s64 = 342;
	// 821AD484: 48000008  b 0x821ad48c
	pc = 0x821AD48C; continue 'dispatch;
            }
            0x821AD488 => {
    //   block [0x821AD488..0x821AD48C)
	// 821AD488: 3B400128  li r26, 0x128
	ctx.r[26].s64 = 296;
	pc = 0x821AD48C; continue 'dispatch;
            }
            0x821AD48C => {
    //   block [0x821AD48C..0x821AD508)
	// 821AD48C: 83610164  lwz r27, 0x164(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD490: 63DE0001  ori r30, r30, 1
	ctx.r[30].u64 = ctx.r[30].u64 | 1;
	// 821AD494: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 821AD498: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD49C: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AD4A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD4A4: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD4A8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD4AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD4B0: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821AD4B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD4B8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD4BC: 48000195  bl 0x821ad650
	ctx.lr = 0x821AD4C0;
	sub_821AD650(ctx, base);
	// 821AD4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AD4C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD4C8: 419A0040  beq cr6, 0x821ad508
	if ctx.cr[6].eq {
	pc = 0x821AD508; continue 'dispatch;
	}
	// 821AD4CC: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821AD4D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD4D4: 409A0034  bne cr6, 0x821ad508
	if !ctx.cr[6].eq {
	pc = 0x821AD508; continue 'dispatch;
	}
	// 821AD4D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AD4DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AD4E0: 38EB0F40  addi r7, r11, 0xf40
	ctx.r[7].s64 = ctx.r[11].s64 + 3904;
	// 821AD4E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AD4E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AD4EC: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 821AD4F0: 481BCFA1  bl 0x8236a490
	ctx.lr = 0x821AD4F4;
	sub_8236A490(ctx, base);
	// 821AD4F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AD4F8: 419A0010  beq cr6, 0x821ad508
	if ctx.cr[6].eq {
	pc = 0x821AD508; continue 'dispatch;
	}
	// 821AD4FC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AD500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AD504: 4BFEEA7D  bl 0x8219bf80
	ctx.lr = 0x821AD508;
	sub_8219BF80(ctx, base);
	pc = 0x821AD508; continue 'dispatch;
            }
            0x821AD508 => {
    //   block [0x821AD508..0x821AD554)
	// 821AD508: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD510: 419AFDE0  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821AD514: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD518: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 821AD51C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 821AD520: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 821AD524: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AD528: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD52C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD530: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD534: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD538: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD53C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD540: 4BFFEF59  bl 0x821ac498
	ctx.lr = 0x821AD544;
	sub_821AC498(ctx, base);
	// 821AD544: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD548: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD54C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD550: 48387B88  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD554 => {
    //   block [0x821AD554..0x821AD5D0)
	// 821AD554: 83E10164  lwz r31, 0x164(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD558: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD55C: 390000C0  li r8, 0xc0
	ctx.r[8].s64 = 192;
	// 821AD560: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD564: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 821AD568: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD56C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD570: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD574: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD578: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD57C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD580: 480000D1  bl 0x821ad650
	ctx.lr = 0x821AD584;
	sub_821AD650(ctx, base);
	// 821AD584: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD58C: 419AFD64  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821AD590: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD594: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821AD598: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD59C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD5A0: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 821AD5A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD5A8: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD5AC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821AD5B0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD5B4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD5B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD5BC: 4BFFEEDD  bl 0x821ac498
	ctx.lr = 0x821AD5C0;
	sub_821AC498(ctx, base);
	// 821AD5C0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD5C4: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD5C8: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD5CC: 48387B0C  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD5D0 => {
    //   block [0x821AD5D0..0x821AD64C)
	// 821AD5D0: 83E10164  lwz r31, 0x164(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 821AD5D4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD5D8: 390000C0  li r8, 0xc0
	ctx.r[8].s64 = 192;
	// 821AD5DC: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 821AD5E0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 821AD5E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD5E8: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD5EC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD5F0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD5F4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD5F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD5FC: 48000055  bl 0x821ad650
	ctx.lr = 0x821AD600;
	sub_821AD650(ctx, base);
	// 821AD600: 57CB06B4  rlwinm r11, r30, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD608: 419AFCE8  beq cr6, 0x821ad2f0
	if ctx.cr[6].eq {
	pc = 0x821AD2F0; continue 'dispatch;
	}
	// 821AD60C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821AD610: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821AD614: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 821AD618: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821AD61C: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 821AD620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD624: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD628: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821AD62C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD630: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AD634: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821AD638: 4BFFEE61  bl 0x821ac498
	ctx.lr = 0x821AD63C;
	sub_821AC498(ctx, base);
	// 821AD63C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821AD640: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 821AD644: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821AD648: 48387A90  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD64C => {
    //   block [0x821AD64C..0x821AD650)
	// 821AD64C: 48000000  b 0x821ad64c
	pc = 0x821AD64C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AD650 size=900
    let mut pc: u32 = 0x821AD650;
    'dispatch: loop {
        match pc {
            0x821AD650 => {
    //   block [0x821AD650..0x821AD718)
	// 821AD650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AD654: 48387A41  bl 0x82535094
	ctx.lr = 0x821AD658;
	sub_82535080(ctx, base);
	// 821AD658: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 821AD65C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AD660: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821AD664: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821AD668: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 821AD66C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 821AD670: 6149A580  ori r9, r10, 0xa580
	ctx.r[9].u64 = ctx.r[10].u64 | 42368;
	// 821AD674: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AD678: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821AD67C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AD680: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821AD684: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AD688: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821AD68C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821AD690: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 821AD694: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 821AD698: 3A600005  li r19, 5
	ctx.r[19].s64 = 5;
	// 821AD69C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821AD6A0: 7D6B482A  ldx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	// 821AD6A4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821AD6A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD6AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD6B4: 419A0088  beq cr6, 0x821ad73c
	if ctx.cr[6].eq {
	pc = 0x821AD73C; continue 'dispatch;
	}
	// 821AD6B8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD6BC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AD6C0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AD6C4: 409A0078  bne cr6, 0x821ad73c
	if !ctx.cr[6].eq {
	pc = 0x821AD73C; continue 'dispatch;
	}
	// 821AD6C8: E94B0118  ld r10, 0x118(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	// 821AD6CC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821AD6D0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AD6D4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD6DC: 419A003C  beq cr6, 0x821ad718
	if ctx.cr[6].eq {
	pc = 0x821AD718; continue 'dispatch;
	}
	// 821AD6E0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD6E4: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AD6E8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AD6EC: 409A002C  bne cr6, 0x821ad718
	if !ctx.cr[6].eq {
	pc = 0x821AD718; continue 'dispatch;
	}
	// 821AD6F0: 570906B4  rlwinm r9, r24, 0, 0x1a, 0x1a
	ctx.r[9].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD6F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AD6F8: 409A0070  bne cr6, 0x821ad768
	if !ctx.cr[6].eq {
	pc = 0x821AD768; continue 'dispatch;
	}
	// 821AD6FC: A12A0014  lhz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD700: 9A6A0019  stb r19, 0x19(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25 as u32), ctx.r[19].u8 ) };
	// 821AD704: 61298000  ori r9, r9, 0x8000
	ctx.r[9].u64 = ctx.r[9].u64 | 32768;
	// 821AD708: 9B4A0025  stb r26, 0x25(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821AD70C: B12A0014  sth r9, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u16 ) };
	// 821AD710: FB2B0118  std r25, 0x118(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), ctx.r[25].u64 ) };
	// 821AD714: 48000054  b 0x821ad768
	pc = 0x821AD768; continue 'dispatch;
            }
            0x821AD718 => {
    //   block [0x821AD718..0x821AD73C)
	// 821AD718: E96B0110  ld r11, 0x110(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 821AD71C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD720: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821AD724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD728: 419A0014  beq cr6, 0x821ad73c
	if ctx.cr[6].eq {
	pc = 0x821AD73C; continue 'dispatch;
	}
	// 821AD72C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD730: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821AD734: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AD738: 419A0030  beq cr6, 0x821ad768
	if ctx.cr[6].eq {
	pc = 0x821AD768; continue 'dispatch;
	}
	pc = 0x821AD73C; continue 'dispatch;
            }
            0x821AD73C => {
    //   block [0x821AD73C..0x821AD768)
	// 821AD73C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821AD740: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD744: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 821AD748: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 821AD74C: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821AD750: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821AD754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821AD758: 48001249  bl 0x821ae9a0
	ctx.lr = 0x821AD75C;
	sub_821AE9A0(ctx, base);
	// 821AD75C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AD760: 419A0164  beq cr6, 0x821ad8c4
	if ctx.cr[6].eq {
	pc = 0x821AD8C4; continue 'dispatch;
	}
	// 821AD764: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x821AD768; continue 'dispatch;
            }
            0x821AD768 => {
    //   block [0x821AD768..0x821AD790)
	// 821AD768: E97B0110  ld r11, 0x110(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(272 as u32) ) };
	// 821AD76C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AD770: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AD774: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AD778: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD77C: 419A0014  beq cr6, 0x821ad790
	if ctx.cr[6].eq {
	pc = 0x821AD790; continue 'dispatch;
	}
	// 821AD780: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD784: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AD788: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AD78C: 419A0218  beq cr6, 0x821ad9a4
	if ctx.cr[6].eq {
	pc = 0x821AD9A4; continue 'dispatch;
	}
	pc = 0x821AD790; continue 'dispatch;
            }
            0x821AD790 => {
    //   block [0x821AD790..0x821AD7C0)
	// 821AD790: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AD794: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821AD798: 38EB0F4C  addi r7, r11, 0xf4c
	ctx.r[7].s64 = ctx.r[11].s64 + 3916;
	// 821AD79C: 38A00389  li r5, 0x389
	ctx.r[5].s64 = 905;
	// 821AD7A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821AD7A4: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821AD7A8: 481BCCE9  bl 0x8236a490
	ctx.lr = 0x821AD7AC;
	sub_8236A490(ctx, base);
	// 821AD7AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AD7B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD7B4: 419A000C  beq cr6, 0x821ad7c0
	if ctx.cr[6].eq {
	pc = 0x821AD7C0; continue 'dispatch;
	}
	// 821AD7B8: 839F0030  lwz r28, 0x30(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD7BC: 48000008  b 0x821ad7c4
	pc = 0x821AD7C4; continue 'dispatch;
            }
            0x821AD7C0 => {
    //   block [0x821AD7C0..0x821AD7C4)
	// 821AD7C0: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	pc = 0x821AD7C4; continue 'dispatch;
            }
            0x821AD7C4 => {
    //   block [0x821AD7C4..0x821AD84C)
	// 821AD7C4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821AD7C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AD7CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821AD7D0: 419A00F4  beq cr6, 0x821ad8c4
	if ctx.cr[6].eq {
	pc = 0x821AD8C4; continue 'dispatch;
	}
	// 821AD7D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AD7D8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AD7DC: 396B0F54  addi r11, r11, 0xf54
	ctx.r[11].s64 = ctx.r[11].s64 + 3924;
	// 821AD7E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AD7E4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821AD7E8: 933F0080  stw r25, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 821AD7EC: B33F0084  sth r25, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[25].u16 ) };
	// 821AD7F0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821AD7F4: B33F0086  sth r25, 0x86(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(134 as u32), ctx.r[25].u16 ) };
	// 821AD7F8: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821AD7FC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821AD800: 614A93F0  ori r10, r10, 0x93f0
	ctx.r[10].u64 = ctx.r[10].u64 | 37872;
	// 821AD804: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AD808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD80C: 419A004C  beq cr6, 0x821ad858
	if ctx.cr[6].eq {
	pc = 0x821AD858; continue 'dispatch;
	}
	// 821AD810: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AD814: 38A0005F  li r5, 0x5f
	ctx.r[5].s64 = 95;
	// 821AD818: 3BCBB460  addi r30, r11, -0x4ba0
	ctx.r[30].s64 = ctx.r[11].s64 + -19360;
	// 821AD81C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AD820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AD824: 48193065  bl 0x82340888
	ctx.lr = 0x821AD828;
	sub_82340888(ctx, base);
	// 821AD828: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD82C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD830: 419A001C  beq cr6, 0x821ad84c
	if ctx.cr[6].eq {
	pc = 0x821AD84C; continue 'dispatch;
	}
	// 821AD834: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 821AD838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AD83C: 4819304D  bl 0x82340888
	ctx.lr = 0x821AD840;
	sub_82340888(ctx, base);
	// 821AD840: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 821AD844: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821AD848: 409A0010  bne cr6, 0x821ad858
	if !ctx.cr[6].eq {
	pc = 0x821AD858; continue 'dispatch;
	}
	pc = 0x821AD84C; continue 'dispatch;
            }
            0x821AD84C => {
    //   block [0x821AD84C..0x821AD858)
	// 821AD84C: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD850: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AD854: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x821AD858; continue 'dispatch;
            }
            0x821AD858 => {
    //   block [0x821AD858..0x821AD8C4)
	// 821AD858: 3D00821B  lis r8, -0x7de5
	ctx.r[8].s64 = -2112159744;
	// 821AD85C: 9B5F001C  stb r26, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821AD860: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821AD864: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AD868: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AD86C: 3908D9D8  addi r8, r8, -0x2628
	ctx.r[8].s64 = ctx.r[8].s64 + -9768;
	// 821AD870: 3929DA18  addi r9, r9, -0x25e8
	ctx.r[9].s64 = ctx.r[9].s64 + -9704;
	// 821AD874: 394ADA38  addi r10, r10, -0x25c8
	ctx.r[10].s64 = ctx.r[10].s64 + -9672;
	// 821AD878: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AD87C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AD880: 38BF00CC  addi r5, r31, 0xcc
	ctx.r[5].s64 = ctx.r[31].s64 + 204;
	// 821AD884: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821AD888: 38804A40  li r4, 0x4a40
	ctx.r[4].s64 = 19008;
	// 821AD88C: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821AD890: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AD894: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821AD898: 4BFF4399  bl 0x821a1c30
	ctx.lr = 0x821AD89C;
	sub_821A1C30(ctx, base);
	// 821AD89C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AD8A0: 409A0034  bne cr6, 0x821ad8d4
	if !ctx.cr[6].eq {
	pc = 0x821AD8D4; continue 'dispatch;
	}
	// 821AD8A4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD8A8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821AD8AC: 409A0018  bne cr6, 0x821ad8c4
	if !ctx.cr[6].eq {
	pc = 0x821AD8C4; continue 'dispatch;
	}
	// 821AD8B0: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AD8B4: 9A7F0019  stb r19, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[19].u8 ) };
	// 821AD8B8: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821AD8BC: 9B5F0025  stb r26, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 821AD8C0: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x821AD8C4; continue 'dispatch;
            }
            0x821AD8C4 => {
    //   block [0x821AD8C4..0x821AD8D4)
	// 821AD8C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AD8C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AD8CC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AD8D0: 48387814  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            0x821AD8D4 => {
    //   block [0x821AD8D4..0x821AD8EC)
	// 821AD8D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AD8D8: 570A06B4  rlwinm r10, r24, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821AD8DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AD8E0: F97B0110  std r11, 0x110(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 821AD8E4: 409A0008  bne cr6, 0x821ad8ec
	if !ctx.cr[6].eq {
	pc = 0x821AD8EC; continue 'dispatch;
	}
	// 821AD8E8: FB3B0118  std r25, 0x118(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(280 as u32), ctx.r[25].u64 ) };
	pc = 0x821AD8EC; continue 'dispatch;
            }
            0x821AD8EC => {
    //   block [0x821AD8EC..0x821AD918)
	// 821AD8EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AD8F0: 419A0030  beq cr6, 0x821ad920
	if ctx.cr[6].eq {
	pc = 0x821AD920; continue 'dispatch;
	}
	// 821AD8F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AD8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD8FC: 419A001C  beq cr6, 0x821ad918
	if ctx.cr[6].eq {
	pc = 0x821AD918; continue 'dispatch;
	}
	// 821AD900: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AD904: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AD908: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AD90C: 409A000C  bne cr6, 0x821ad918
	if !ctx.cr[6].eq {
	pc = 0x821AD918; continue 'dispatch;
	}
	// 821AD910: A16B0016  lhz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 821AD914: 48000008  b 0x821ad91c
	pc = 0x821AD91C; continue 'dispatch;
            }
            0x821AD918 => {
    //   block [0x821AD918..0x821AD91C)
	// 821AD918: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821AD91C; continue 'dispatch;
            }
            0x821AD91C => {
    //   block [0x821AD91C..0x821AD920)
	// 821AD91C: B17F0016  sth r11, 0x16(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[11].u16 ) };
	pc = 0x821AD920; continue 'dispatch;
            }
            0x821AD920 => {
    //   block [0x821AD920..0x821AD988)
	// 821AD920: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AD924: 8141013C  lwz r10, 0x13c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 821AD928: 3D004020  lis r8, 0x4020
	ctx.r[8].s64 = 1075838976;
	// 821AD92C: 813F00CC  lwz r9, 0xcc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AD930: 38E00120  li r7, 0x120
	ctx.r[7].s64 = 288;
	// 821AD934: 38C00022  li r6, 0x22
	ctx.r[6].s64 = 34;
	// 821AD938: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821AD93C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AD940: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AD944: 911F00A8  stw r8, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 821AD948: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821AD94C: 396B160C  addi r11, r11, 0x160c
	ctx.r[11].s64 = ctx.r[11].s64 + 5644;
	// 821AD950: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 821AD954: 90DF0094  stw r6, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[6].u32 ) };
	// 821AD958: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821AD95C: 3940018C  li r10, 0x18c
	ctx.r[10].s64 = 396;
	// 821AD960: 7D65582E  lwzx r11, r5, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AD964: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821AD968: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821AD96C: 909F00A0  stw r4, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 821AD970: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821AD974: C1A8BA38  lfs f13, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AD978: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821AD97C: 39690024  addi r11, r9, 0x24
	ctx.r[11].s64 = ctx.r[9].s64 + 36;
	// 821AD980: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821AD984: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821AD988; continue 'dispatch;
            }
            0x821AD988 => {
    //   block [0x821AD988..0x821AD9A4)
	// 821AD988: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AD98C: D1ABFFE8  stfs f13, -0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 821AD990: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AD994: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AD998: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AD99C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 821AD9A0: 4199FFE8  bgt cr6, 0x821ad988
	if ctx.cr[6].gt {
	pc = 0x821AD988; continue 'dispatch;
	}
	pc = 0x821AD9A4; continue 'dispatch;
            }
            0x821AD9A4 => {
    //   block [0x821AD9A4..0x821AD9D4)
	// 821AD9A4: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 821AD9A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AD9AC: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821AD9B0: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 821AD9B4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821AD9B8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AD9BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AD9C0: 480016A9  bl 0x821af068
	ctx.lr = 0x821AD9C4;
	sub_821AF068(ctx, base);
	// 821AD9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AD9C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AD9CC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821AD9D0: 48387714  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AD9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AD9D8 size=60
    let mut pc: u32 = 0x821AD9D8;
    'dispatch: loop {
        match pc {
            0x821AD9D8 => {
    //   block [0x821AD9D8..0x821AD9F0)
	// 821AD9D8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AD9DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AD9E0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AD9E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AD9E8: 419A0008  beq cr6, 0x821ad9f0
	if ctx.cr[6].eq {
	pc = 0x821AD9F0; continue 'dispatch;
	}
	// 821AD9EC: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	pc = 0x821AD9F0; continue 'dispatch;
            }
            0x821AD9F0 => {
    //   block [0x821AD9F0..0x821ADA14)
	// 821AD9F0: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 821AD9F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AD9F8: 39298E40  addi r9, r9, -0x71c0
	ctx.r[9].s64 = ctx.r[9].s64 + -29120;
	// 821AD9FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821ADA00: 990B001E  stb r8, 0x1e(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 821ADA04: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821ADA08: B14B0084  sth r10, 0x84(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u16 ) };
	// 821ADA0C: B14B0086  sth r10, 0x86(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(134 as u32), ctx.r[10].u16 ) };
	// 821ADA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ADA18 size=32
    let mut pc: u32 = 0x821ADA18;
    'dispatch: loop {
        match pc {
            0x821ADA18 => {
    //   block [0x821ADA18..0x821ADA38)
	// 821ADA18: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADA1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821ADA20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821ADA24: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADA28: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821ADA2C: 912B0040  stw r9, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 821ADA30: B141FFF0  sth r10, -0x10(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u16 ) };
	// 821ADA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADA38 size=92
    let mut pc: u32 = 0x821ADA38;
    'dispatch: loop {
        match pc {
            0x821ADA38 => {
    //   block [0x821ADA38..0x821ADA70)
	// 821ADA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADA40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ADA44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADA48: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADA4C: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADA50: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 821ADA54: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821ADA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADA5C: 419A0014  beq cr6, 0x821ada70
	if ctx.cr[6].eq {
	pc = 0x821ADA70; continue 'dispatch;
	}
	// 821ADA60: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821ADA64: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821ADA68: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821ADA6C: 4BFF4615  bl 0x821a2080
	ctx.lr = 0x821ADA70;
	sub_821A2080(ctx, base);
	pc = 0x821ADA70; continue 'dispatch;
            }
            0x821ADA70 => {
    //   block [0x821ADA70..0x821ADA94)
	// 821ADA70: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821ADA74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821ADA78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821ADA7C: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 821ADA80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ADA84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ADA88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ADA8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ADA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ADA98 size=772
    let mut pc: u32 = 0x821ADA98;
    'dispatch: loop {
        match pc {
            0x821ADA98 => {
    //   block [0x821ADA98..0x821ADBAC)
	// 821ADA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADA9C: 4838761D  bl 0x825350b8
	ctx.lr = 0x821ADAA0;
	sub_82535080(ctx, base);
	// 821ADAA0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821ADAA4: 4838850D  bl 0x82535fb0
	ctx.lr = 0x821ADAA8;
	sub_82535FB0(ctx, base);
	// 821ADAA8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADAAC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821ADAB0: C007000C  lfs f0, 0xc(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADAB4: EEA00072  fmuls f21, f0, f1
	ctx.f[21].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821ADAB8: C007001C  lfs f0, 0x1c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADABC: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 821ADAC0: EF400072  fmuls f26, f0, f1
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821ADAC4: C3070000  lfs f24, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 821ADAC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADACC: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821ADAD0: C1A70020  lfs f13, 0x20(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADAD4: C2E70004  lfs f23, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 821ADAD8: EDADC028  fsubs f13, f13, f24
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[24].f64) as f32) as f64);
	// 821ADADC: C1870024  lfs f12, 0x24(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ADAE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821ADAE4: C2C70008  lfs f22, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821ADAE8: ED8CB828  fsubs f12, f12, f23
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[23].f64) as f32) as f64);
	// 821ADAEC: C1670028  lfs f11, 0x28(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ADAF0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821ADAF4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821ADAF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821ADAFC: C147002C  lfs f10, 0x2c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ADB00: ED6BB028  fsubs f11, f11, f22
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[22].f64) as f32) as f64);
	// 821ADB04: ED4AA878  fmsubs f10, f10, f1, f21
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 - ctx.f[21].f64) as f32) as f64);
	// 821ADB08: C3A70010  lfs f29, 0x10(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821ADB0C: C3870014  lfs f28, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821ADB10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821ADB14: C3670018  lfs f27, 0x18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821ADB18: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ADB1C: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821ADB20: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821ADB24: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821ADB28: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 821ADB2C: EDCD0032  fmuls f14, f13, f0
	ctx.f[14].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB30: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB34: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821ADB38: EDAB0032  fmuls f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB3C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821ADB40: EDAA0032  fmuls f13, f10, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB44: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821ADB48: C1A70030  lfs f13, 0x30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADB4C: C1870034  lfs f12, 0x34(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821ADB50: EDADE828  fsubs f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[29].f64) as f32) as f64);
	// 821ADB54: C1670038  lfs f11, 0x38(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821ADB58: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 821ADB5C: C147003C  lfs f10, 0x3c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821ADB60: ED6BD828  fsubs f11, f11, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[27].f64) as f32) as f64);
	// 821ADB64: ED4AD078  fmsubs f10, f10, f1, f26
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 - ctx.f[26].f64) as f32) as f64);
	// 821ADB68: EE4D0032  fmuls f18, f13, f0
	ctx.f[18].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB6C: EE2C0032  fmuls f17, f12, f0
	ctx.f[17].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB70: EE0B0032  fmuls f16, f11, f0
	ctx.f[16].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB74: EDEA0032  fmuls f15, f10, f0
	ctx.f[15].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ADB78: 419A0214  beq cr6, 0x821add8c
	if ctx.cr[6].eq {
	pc = 0x821ADD8C; continue 'dispatch;
	}
	// 821ADB7C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821ADB80: 3CE08288  lis r7, -0x7d78
	ctx.r[7].s64 = -2105016320;
	// 821ADB84: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821ADB88: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821ADB8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821ADB90: C1A91FF8  lfs f13, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADB94: C267D4DC  lfs f19, -0x2b24(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821ADB98: C2882490  lfs f20, 0x2490(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9360 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821ADB9C: C32A2048  lfs f25, 0x2048(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8264 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821ADBA0: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ADBA4: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821ADBA8: 48000008  b 0x821adbb0
	pc = 0x821ADBB0; continue 'dispatch;
            }
            0x821ADBAC => {
    //   block [0x821ADBAC..0x821ADBB0)
	// 821ADBAC: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x821ADBB0; continue 'dispatch;
            }
            0x821ADBB0 => {
    //   block [0x821ADBB0..0x821ADBF8)
	// 821ADBB0: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBB4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ADBB8: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBBC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ADBC0: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBC4: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ADBC8: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADBCC: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821ADBD0: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 821ADBD4: 41980064  blt cr6, 0x821adc38
	if ctx.cr[6].lt {
	pc = 0x821ADC38; continue 'dispatch;
	}
	// 821ADBD8: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	// 821ADBDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821ADBE0: 4098003C  bge cr6, 0x821adc1c
	if !ctx.cr[6].lt {
	pc = 0x821ADC1C; continue 'dispatch;
	}
	// 821ADBE4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821ADBE8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADBEC: 4098000C  bge cr6, 0x821adbf8
	if !ctx.cr[6].lt {
	pc = 0x821ADBF8; continue 'dispatch;
	}
	// 821ADBF0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADBF4: 48000040  b 0x821adc34
	pc = 0x821ADC34; continue 'dispatch;
            }
            0x821ADBF8 => {
    //   block [0x821ADBF8..0x821ADC1C)
	// 821ADBF8: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADBFC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821ADC00: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821ADC04: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ADC08: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADC0C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADC10: 41980024  blt cr6, 0x821adc34
	if ctx.cr[6].lt {
	pc = 0x821ADC34; continue 'dispatch;
	}
	// 821ADC14: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821ADC18: 4800001C  b 0x821adc34
	pc = 0x821ADC34; continue 'dispatch;
            }
            0x821ADC1C => {
    //   block [0x821ADC1C..0x821ADC34)
	// 821ADC1C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADC20: 41980014  blt cr6, 0x821adc34
	if ctx.cr[6].lt {
	pc = 0x821ADC34; continue 'dispatch;
	}
	// 821ADC24: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADC28: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821ADC2C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821ADC30: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821ADC34; continue 'dispatch;
            }
            0x821ADC34 => {
    //   block [0x821ADC34..0x821ADC38)
	// 821ADC34: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	pc = 0x821ADC38; continue 'dispatch;
            }
            0x821ADC38 => {
    //   block [0x821ADC38..0x821ADCD8)
	// 821ADC38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821ADC3C: EC200532  fmuls f1, f0, f20
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821ADC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ADC44: 4BF6418D  bl 0x82111dd0
	ctx.lr = 0x821ADC48;
	sub_82111DD0(ctx, base);
	// 821ADC48: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADC4C: EC00FCFA  fmadds f0, f0, f19, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[19].f64 + ctx.f[31].f64) as f32) as f64);
	// 821ADC50: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADC54: EDADFCF8  fmsubs f13, f13, f19, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[19].f64 - ctx.f[31].f64) as f32) as f64);
	// 821ADC58: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821ADC5C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821ADC60: EC0D0672  fmuls f0, f13, f25
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 821ADC64: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821ADC68: D3BF0010  stfs f29, 0x10(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ADC6C: EFB2E82A  fadds f29, f18, f29
	ctx.f[29].f64 = ((ctx.f[18].f64 + ctx.f[29].f64) as f32) as f64;
	// 821ADC70: D39F0014  stfs f28, 0x14(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ADC74: EF91E02A  fadds f28, f17, f28
	ctx.f[28].f64 = ((ctx.f[17].f64 + ctx.f[28].f64) as f32) as f64;
	// 821ADC78: D37F0018  stfs f27, 0x18(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821ADC7C: EF70D82A  fadds f27, f16, f27
	ctx.f[27].f64 = ((ctx.f[16].f64 + ctx.f[27].f64) as f32) as f64;
	// 821ADC80: D35F001C  stfs f26, 0x1c(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821ADC84: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821ADC88: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADC8C: EF4FD02A  fadds f26, f15, f26
	ctx.f[26].f64 = ((ctx.f[15].f64 + ctx.f[26].f64) as f32) as f64;
	// 821ADC90: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821ADC94: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADC98: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821ADC9C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADCA0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821ADCA4: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADCA8: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821ADCAC: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 821ADCB0: 41980068  blt cr6, 0x821add18
	if ctx.cr[6].lt {
	pc = 0x821ADD18; continue 'dispatch;
	}
	// 821ADCB4: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	// 821ADCB8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADCBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821ADCC0: 4098003C  bge cr6, 0x821adcfc
	if !ctx.cr[6].lt {
	pc = 0x821ADCFC; continue 'dispatch;
	}
	// 821ADCC4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821ADCC8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADCCC: 4098000C  bge cr6, 0x821adcd8
	if !ctx.cr[6].lt {
	pc = 0x821ADCD8; continue 'dispatch;
	}
	// 821ADCD0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADCD4: 48000040  b 0x821add14
	pc = 0x821ADD14; continue 'dispatch;
            }
            0x821ADCD8 => {
    //   block [0x821ADCD8..0x821ADCFC)
	// 821ADCD8: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADCDC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821ADCE0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821ADCE4: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821ADCE8: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821ADCEC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADCF0: 41980024  blt cr6, 0x821add14
	if ctx.cr[6].lt {
	pc = 0x821ADD14; continue 'dispatch;
	}
	// 821ADCF4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821ADCF8: 4800001C  b 0x821add14
	pc = 0x821ADD14; continue 'dispatch;
            }
            0x821ADCFC => {
    //   block [0x821ADCFC..0x821ADD14)
	// 821ADCFC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821ADD00: 41980014  blt cr6, 0x821add14
	if ctx.cr[6].lt {
	pc = 0x821ADD14; continue 'dispatch;
	}
	// 821ADD04: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821ADD08: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821ADD0C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821ADD10: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821ADD14; continue 'dispatch;
            }
            0x821ADD14 => {
    //   block [0x821ADD14..0x821ADD18)
	// 821ADD14: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	pc = 0x821ADD18; continue 'dispatch;
            }
            0x821ADD18 => {
    //   block [0x821ADD18..0x821ADD8C)
	// 821ADD18: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821ADD1C: EC200532  fmuls f1, f0, f20
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821ADD20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821ADD24: 4BF640AD  bl 0x82111dd0
	ctx.lr = 0x821ADD28;
	sub_82111DD0(ctx, base);
	// 821ADD28: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD2C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821ADD30: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821ADD34: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821ADD38: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821ADD3C: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 821ADD40: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821ADD44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821ADD48: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821ADD4C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821ADD50: EC0D0672  fmuls f0, f13, f25
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 821ADD54: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821ADD58: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD5C: D2FF0014  stfs f23, 0x14(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821ADD60: EEE0B82A  fadds f23, f0, f23
	ctx.f[23].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 821ADD64: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD68: D2DF0018  stfs f22, 0x18(r31)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821ADD6C: EEC0B02A  fadds f22, f0, f22
	ctx.f[22].f64 = ((ctx.f[0].f64 + ctx.f[22].f64) as f32) as f64;
	// 821ADD70: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ADD74: D31F0010  stfs f24, 0x10(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821ADD78: EF0EC02A  fadds f24, f14, f24
	ctx.f[24].f64 = ((ctx.f[14].f64 + ctx.f[24].f64) as f32) as f64;
	// 821ADD7C: D2BF001C  stfs f21, 0x1c(r31)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821ADD80: EEA0A82A  fadds f21, f0, f21
	ctx.f[21].f64 = ((ctx.f[0].f64 + ctx.f[21].f64) as f32) as f64;
	// 821ADD84: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821ADD88: 409AFE24  bne cr6, 0x821adbac
	if !ctx.cr[6].eq {
	pc = 0x821ADBAC; continue 'dispatch;
	}
	pc = 0x821ADD8C; continue 'dispatch;
            }
            0x821ADD8C => {
    //   block [0x821ADD8C..0x821ADD9C)
	// 821ADD8C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821ADD90: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821ADD94: 48388269  bl 0x82535ffc
	ctx.lr = 0x821ADD98;
	sub_82535FFC(ctx, base);
	// 821ADD98: 48387370  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADDC8 size=100
    let mut pc: u32 = 0x821ADDC8;
    'dispatch: loop {
        match pc {
            0x821ADDC8 => {
    //   block [0x821ADDC8..0x821ADE18)
	// 821ADDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADDCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADDD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ADDD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADDD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADDDC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821ADDE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADDE4: 419A0034  beq cr6, 0x821ade18
	if ctx.cr[6].eq {
	pc = 0x821ADE18; continue 'dispatch;
	}
	// 821ADDE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821ADDEC: 4E800421  bctrl
	ctx.lr = 0x821ADDF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ADDF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADDF4: 409A0024  bne cr6, 0x821ade18
	if !ctx.cr[6].eq {
	pc = 0x821ADE18; continue 'dispatch;
	}
	// 821ADDF8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADDFC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADE00: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821ADE04: 409A0014  bne cr6, 0x821ade18
	if !ctx.cr[6].eq {
	pc = 0x821ADE18; continue 'dispatch;
	}
	// 821ADE08: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821ADE0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821ADE10: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821ADE14: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
            }
            0x821ADE18 => {
    //   block [0x821ADE18..0x821ADE2C)
	// 821ADE18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ADE1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ADE20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ADE24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ADE28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ADE30 size=100
    let mut pc: u32 = 0x821ADE30;
    'dispatch: loop {
        match pc {
            0x821ADE30 => {
    //   block [0x821ADE30..0x821ADE80)
	// 821ADE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ADE38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ADE3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADE40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADE44: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821ADE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ADE4C: 419A0034  beq cr6, 0x821ade80
	if ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821ADE54: 4E800421  bctrl
	ctx.lr = 0x821ADE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ADE58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADE5C: 409A0024  bne cr6, 0x821ade80
	if !ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE60: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821ADE64: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821ADE68: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821ADE6C: 409A0014  bne cr6, 0x821ade80
	if !ctx.cr[6].eq {
	pc = 0x821ADE80; continue 'dispatch;
	}
	// 821ADE70: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821ADE74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821ADE78: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821ADE7C: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
            }
            0x821ADE80 => {
    //   block [0x821ADE80..0x821ADE94)
	// 821ADE80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ADE84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ADE88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ADE8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ADE90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ADE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ADE98 size=1292
    let mut pc: u32 = 0x821ADE98;
    'dispatch: loop {
        match pc {
            0x821ADE98 => {
    //   block [0x821ADE98..0x821ADF14)
	// 821ADE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ADE9C: 4838720D  bl 0x825350a8
	ctx.lr = 0x821ADEA0;
	sub_82535080(ctx, base);
	// 821ADEA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ADEA4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821ADEA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ADEAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821ADEB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821ADEB4: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 821ADEB8: 419A04E0  beq cr6, 0x821ae398
	if ctx.cr[6].eq {
	pc = 0x821AE398; continue 'dispatch;
	}
	// 821ADEBC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821ADEC0: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821ADEC4: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821ADEC8: 3BCAC470  addi r30, r10, -0x3b90
	ctx.r[30].s64 = ctx.r[10].s64 + -15248;
	// 821ADECC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821ADED0: 54ABE7FE  rlwinm r11, r5, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 821ADED4: 38EA0F74  addi r7, r10, 0xf74
	ctx.r[7].s64 = ctx.r[10].s64 + 3956;
	// 821ADED8: 7D5F48AE  lbzx r10, r31, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ADEDC: 393E0014  addi r9, r30, 0x14
	ctx.r[9].s64 = ctx.r[30].s64 + 20;
	// 821ADEE0: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 821ADEE4: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 821ADEE8: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821ADEEC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821ADEF0: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 821ADEF4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821ADEF8: 7C8B482E  lwzx r4, r11, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ADEFC: 481BC595  bl 0x8236a490
	ctx.lr = 0x821ADF00;
	sub_8236A490(ctx, base);
	// 821ADF00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821ADF04: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821ADF08: 419A000C  beq cr6, 0x821adf14
	if ctx.cr[6].eq {
	pc = 0x821ADF14; continue 'dispatch;
	}
	// 821ADF0C: 833C0030  lwz r25, 0x30(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821ADF10: 48000008  b 0x821adf18
	pc = 0x821ADF18; continue 'dispatch;
            }
            0x821ADF14 => {
    //   block [0x821ADF14..0x821ADF18)
	// 821ADF14: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	pc = 0x821ADF18; continue 'dispatch;
            }
            0x821ADF18 => {
    //   block [0x821ADF18..0x821ADF3C)
	// 821ADF18: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821ADF1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821ADF20: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821ADF24: 419A0018  beq cr6, 0x821adf3c
	if ctx.cr[6].eq {
	pc = 0x821ADF3C; continue 'dispatch;
	}
	// 821ADF28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821ADF2C: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821ADF30: 396B0F7C  addi r11, r11, 0xf7c
	ctx.r[11].s64 = ctx.r[11].s64 + 3964;
	// 821ADF34: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821ADF38: 48000008  b 0x821adf40
	pc = 0x821ADF40; continue 'dispatch;
            }
            0x821ADF3C => {
    //   block [0x821ADF3C..0x821ADF40)
	// 821ADF3C: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	pc = 0x821ADF40; continue 'dispatch;
            }
            0x821ADF40 => {
    //   block [0x821ADF40..0x821AE010)
	// 821ADF40: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 821ADF44: 93FB0080  stw r31, 0x80(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 821ADF48: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821ADF4C: B3BB00C0  sth r29, 0xc0(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(192 as u32), ctx.r[29].u16 ) };
	// 821ADF50: 3D60821B  lis r11, -0x7de5
	ctx.r[11].s64 = -2112159744;
	// 821ADF54: 3929E3A8  addi r9, r9, -0x1c58
	ctx.r[9].s64 = ctx.r[9].s64 + -7256;
	// 821ADF58: 394AE458  addi r10, r10, -0x1ba8
	ctx.r[10].s64 = ctx.r[10].s64 + -7080;
	// 821ADF5C: 396BE510  addi r11, r11, -0x1af0
	ctx.r[11].s64 = ctx.r[11].s64 + -6896;
	// 821ADF60: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821ADF64: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821ADF68: 38BB00C4  addi r5, r27, 0xc4
	ctx.r[5].s64 = ctx.r[27].s64 + 196;
	// 821ADF6C: 913B0054  stw r9, 0x54(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821ADF70: 38800300  li r4, 0x300
	ctx.r[4].s64 = 768;
	// 821ADF74: 915B0058  stw r10, 0x58(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821ADF78: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821ADF7C: 917B005C  stw r11, 0x5c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821ADF80: 9B5B001C  stb r26, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 821ADF84: 4BFF3CAD  bl 0x821a1c30
	ctx.lr = 0x821ADF88;
	sub_821A1C30(ctx, base);
	// 821ADF88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ADF8C: 419A03E0  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821ADF90: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821ADF94: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821ADF98: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 821ADF9C: 6149A578  ori r9, r10, 0xa578
	ctx.r[9].u64 = ctx.r[10].u64 | 42360;
	// 821ADFA0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821ADFA4: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821ADFA8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821ADFAC: 387B0090  addi r3, r27, 0x90
	ctx.r[3].s64 = ctx.r[27].s64 + 144;
	// 821ADFB0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821ADFB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821ADFB8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821ADFBC: 7D0A492A  stdx r8, r10, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u64) };
	// 821ADFC0: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821ADFC4: 98FB0025  stb r7, 0x25(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821ADFC8: 38EAFC94  addi r7, r10, -0x36c
	ctx.r[7].s64 = ctx.r[10].s64 + -876;
	// 821ADFCC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821ADFD0: 614ABEBC  ori r10, r10, 0xbebc
	ctx.r[10].u64 = ctx.r[10].u64 | 48828;
	// 821ADFD4: 4198003C  blt cr6, 0x821ae010
	if ctx.cr[6].lt {
	pc = 0x821AE010; continue 'dispatch;
	}
	// 821ADFD8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821ADFDC: 41990034  bgt cr6, 0x821ae010
	if ctx.cr[6].gt {
	pc = 0x821AE010; continue 'dispatch;
	}
	// 821ADFE0: 7CDF522E  lhzx r6, r31, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821ADFE4: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821ADFE8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821ADFEC: 39290198  addi r9, r9, 0x198
	ctx.r[9].s64 = ctx.r[9].s64 + 408;
	// 821ADFF0: 54C6103E  rotlwi r6, r6, 2
	ctx.r[6].u64 = ((ctx.r[6].u32).rotate_left(2)) as u64;
	// 821ADFF4: 7D26482E  lwzx r9, r6, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821ADFF8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821ADFFC: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 821AE000: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE004: 7D040734  extsh r4, r8
	ctx.r[4].s64 = ctx.r[8].s16 as i64;
	// 821AE008: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821AE00C: 48000018  b 0x821ae024
	pc = 0x821AE024; continue 'dispatch;
            }
            0x821AE010 => {
    //   block [0x821AE010..0x821AE024)
	// 821AE010: 392BFFF7  addi r9, r11, -9
	ctx.r[9].s64 = ctx.r[11].s64 + -9;
	// 821AE014: 390704BC  addi r8, r7, 0x4bc
	ctx.r[8].s64 = ctx.r[7].s64 + 1212;
	// 821AE018: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE01C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821AE020: 7C86402E  lwzx r4, r6, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	pc = 0x821AE024; continue 'dispatch;
            }
            0x821AE024 => {
    //   block [0x821AE024..0x821AE0A8)
	// 821AE024: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE028: 4198019C  blt cr6, 0x821ae1c4
	if ctx.cr[6].lt {
	pc = 0x821AE1C4; continue 'dispatch;
	}
	// 821AE02C: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 821AE030: 41990194  bgt cr6, 0x821ae1c4
	if ctx.cr[6].gt {
	pc = 0x821AE1C4; continue 'dispatch;
	}
	// 821AE034: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821AE038: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE03C: 5526083C  slwi r6, r9, 1
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE040: 390A1308  addi r8, r10, 0x1308
	ctx.r[8].s64 = ctx.r[10].s64 + 4872;
	// 821AE044: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE048: 392A1040  addi r9, r10, 0x1040
	ctx.r[9].s64 = ctx.r[10].s64 + 4160;
	// 821AE04C: 7D5F3A2E  lhzx r10, r31, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AE050: 3CE08286  lis r7, -0x7d7a
	ctx.r[7].s64 = -2105147392;
	// 821AE054: 5545103E  rotlwi r5, r10, 2
	ctx.r[5].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821AE058: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 821AE05C: 38E70540  addi r7, r7, 0x540
	ctx.r[7].s64 = ctx.r[7].s64 + 1344;
	// 821AE060: 7D45402E  lwzx r10, r5, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE064: 7D4A322E  lhzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821AE068: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821AE06C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE070: 7D4A4A2E  lhzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821AE074: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821AE078: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE07C: 7CAA3A14  add r5, r10, r7
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821AE080: 409A0028  bne cr6, 0x821ae0a8
	if !ctx.cr[6].eq {
	pc = 0x821AE0A8; continue 'dispatch;
	}
	// 821AE084: 38E50010  addi r7, r5, 0x10
	ctx.r[7].s64 = ctx.r[5].s64 + 16;
	// 821AE088: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821AE08C: 38A0001D  li r5, 0x1d
	ctx.r[5].s64 = 29;
	// 821AE090: 3880001F  li r4, 0x1f
	ctx.r[4].s64 = 31;
	// 821AE094: 4BFF6655  bl 0x821a46e8
	ctx.lr = 0x821AE098;
	sub_821A46E8(ctx, base);
	// 821AE098: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE09C: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE0A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE0A4: 48387054  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AE0A8 => {
    //   block [0x821AE0A8..0x821AE0C8)
	// 821AE0A8: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 821AE0AC: 409A020C  bne cr6, 0x821ae2b8
	if !ctx.cr[6].eq {
	pc = 0x821AE2B8; continue 'dispatch;
	}
	// 821AE0B0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AE0B4: 616B9CFC  ori r11, r11, 0x9cfc
	ctx.r[11].u64 = ctx.r[11].u64 | 40188;
	// 821AE0B8: 7D3F582E  lwzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AE0BC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821AE0C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE0C4: 419A0048  beq cr6, 0x821ae10c
	if ctx.cr[6].eq {
	pc = 0x821AE10C; continue 'dispatch;
	}
	pc = 0x821AE0C8; continue 'dispatch;
            }
            0x821AE0C8 => {
    //   block [0x821AE0C8..0x821AE0E4)
	// 821AE0C8: 896A004A  lbz r11, 0x4a(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(74 as u32) ) } as u64;
	// 821AE0CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821AE0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE0D4: 4099002C  ble cr6, 0x821ae100
	if !ctx.cr[6].gt {
	pc = 0x821AE100; continue 'dispatch;
	}
	// 821AE0D8: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821AE0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE0E0: 419A0020  beq cr6, 0x821ae100
	if ctx.cr[6].eq {
	pc = 0x821AE100; continue 'dispatch;
	}
	pc = 0x821AE0E4; continue 'dispatch;
            }
            0x821AE0E4 => {
    //   block [0x821AE0E4..0x821AE100)
	// 821AE0E4: 890B004E  lbz r8, 0x4e(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(78 as u32) ) } as u64;
	// 821AE0E8: 550807BC  rlwinm r8, r8, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821AE0EC: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 821AE0F0: 419A00BC  beq cr6, 0x821ae1ac
	if ctx.cr[6].eq {
	pc = 0x821AE1AC; continue 'dispatch;
	}
	// 821AE0F4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AE0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE0FC: 409AFFE8  bne cr6, 0x821ae0e4
	if !ctx.cr[6].eq {
	pc = 0x821AE0E4; continue 'dispatch;
	}
	pc = 0x821AE100; continue 'dispatch;
            }
            0x821AE100 => {
    //   block [0x821AE100..0x821AE10C)
	// 821AE100: 814A0040  lwz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE108: 409AFFC0  bne cr6, 0x821ae0c8
	if !ctx.cr[6].eq {
	pc = 0x821AE0C8; continue 'dispatch;
	}
	pc = 0x821AE10C; continue 'dispatch;
            }
            0x821AE10C => {
    //   block [0x821AE10C..0x821AE110)
	// 821AE10C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	pc = 0x821AE110; continue 'dispatch;
            }
            0x821AE110 => {
    //   block [0x821AE110..0x821AE11C)
	// 821AE110: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821AE114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE118: 419A0048  beq cr6, 0x821ae160
	if ctx.cr[6].eq {
	pc = 0x821AE160; continue 'dispatch;
	}
	pc = 0x821AE11C; continue 'dispatch;
            }
            0x821AE11C => {
    //   block [0x821AE11C..0x821AE138)
	// 821AE11C: 896A004A  lbz r11, 0x4a(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(74 as u32) ) } as u64;
	// 821AE120: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821AE124: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE128: 4099002C  ble cr6, 0x821ae154
	if !ctx.cr[6].gt {
	pc = 0x821AE154; continue 'dispatch;
	}
	// 821AE12C: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821AE130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE134: 419A0020  beq cr6, 0x821ae154
	if ctx.cr[6].eq {
	pc = 0x821AE154; continue 'dispatch;
	}
	pc = 0x821AE138; continue 'dispatch;
            }
            0x821AE138 => {
    //   block [0x821AE138..0x821AE154)
	// 821AE138: 892B004E  lbz r9, 0x4e(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(78 as u32) ) } as u64;
	// 821AE13C: 552907FE  clrlwi r9, r9, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821AE140: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 821AE144: 419A0074  beq cr6, 0x821ae1b8
	if ctx.cr[6].eq {
	pc = 0x821AE1B8; continue 'dispatch;
	}
	// 821AE148: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AE14C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE150: 409AFFE8  bne cr6, 0x821ae138
	if !ctx.cr[6].eq {
	pc = 0x821AE138; continue 'dispatch;
	}
	pc = 0x821AE154; continue 'dispatch;
            }
            0x821AE154 => {
    //   block [0x821AE154..0x821AE160)
	// 821AE154: 814A0040  lwz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AE15C: 409AFFC0  bne cr6, 0x821ae11c
	if !ctx.cr[6].eq {
	pc = 0x821AE11C; continue 'dispatch;
	}
	pc = 0x821AE160; continue 'dispatch;
            }
            0x821AE160 => {
    //   block [0x821AE160..0x821AE164)
	// 821AE160: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	pc = 0x821AE164; continue 'dispatch;
            }
            0x821AE164 => {
    //   block [0x821AE164..0x821AE1AC)
	// 821AE164: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 821AE168: 419A0204  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE16C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821AE170: 419A01FC  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE174: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE178: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821AE17C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE180: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AE184: 394A4780  addi r10, r10, 0x4780
	ctx.r[10].s64 = ctx.r[10].s64 + 18304;
	// 821AE188: 93030008  stw r24, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821AE18C: 396B4780  addi r11, r11, 0x4780
	ctx.r[11].s64 = ctx.r[11].s64 + 18304;
	// 821AE190: 9303000C  stw r24, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821AE194: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE198: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE19C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE1A0: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE1A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE1A8: 48386F50  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AE1AC => {
    //   block [0x821AE1AC..0x821AE1B8)
	// 821AE1AC: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE1B0: 7D680734  extsh r8, r11
	ctx.r[8].s64 = ctx.r[11].s16 as i64;
	// 821AE1B4: 4BFFFF5C  b 0x821ae110
	pc = 0x821AE110; continue 'dispatch;
            }
            0x821AE1B8 => {
    //   block [0x821AE1B8..0x821AE1C4)
	// 821AE1B8: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE1BC: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 821AE1C0: 4BFFFFA4  b 0x821ae164
	pc = 0x821AE164; continue 'dispatch;
            }
            0x821AE1C4 => {
    //   block [0x821AE1C4..0x821AE20C)
	// 821AE1C4: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821AE1C8: 41980090  blt cr6, 0x821ae258
	if ctx.cr[6].lt {
	pc = 0x821AE258; continue 'dispatch;
	}
	// 821AE1CC: 2F0B001A  cmpwi cr6, r11, 0x1a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 26, &mut ctx.xer);
	// 821AE1D0: 41990088  bgt cr6, 0x821ae258
	if ctx.cr[6].gt {
	pc = 0x821AE258; continue 'dispatch;
	}
	// 821AE1D4: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 821AE1D8: 392BFFF6  addi r9, r11, -0xa
	ctx.r[9].s64 = ctx.r[11].s64 + -10;
	// 821AE1DC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE1E0: 6108BEB8  ori r8, r8, 0xbeb8
	ctx.r[8].u64 = ctx.r[8].u64 | 48824;
	// 821AE1E4: 394AFB68  addi r10, r10, -0x498
	ctx.r[10].s64 = ctx.r[10].s64 + -1176;
	// 821AE1E8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE1EC: 7D1F422E  lhzx r8, r31, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE1F0: 7CA9502E  lwzx r5, r9, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AE1F4: 2B08002B  cmplwi cr6, r8, 0x2b
	ctx.cr[6].compare_u32(ctx.r[8].u32, 43 as u32, &mut ctx.xer);
	// 821AE1F8: 409A00C0  bne cr6, 0x821ae2b8
	if !ctx.cr[6].eq {
	pc = 0x821AE2B8; continue 'dispatch;
	}
	// 821AE1FC: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 821AE200: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821AE204: 40980008  bge cr6, 0x821ae20c
	if !ctx.cr[6].lt {
	pc = 0x821AE20C; continue 'dispatch;
	}
	// 821AE208: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x821AE20C; continue 'dispatch;
            }
            0x821AE20C => {
    //   block [0x821AE20C..0x821AE258)
	// 821AE20C: 3D2B0001  addis r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 65536;
	// 821AE210: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE214: 39296104  addi r9, r9, 0x6104
	ctx.r[9].s64 = ctx.r[9].s64 + 24836;
	// 821AE218: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE21C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE220: 39050010  addi r8, r5, 0x10
	ctx.r[8].s64 = ctx.r[5].s64 + 16;
	// 821AE224: 394A42C0  addi r10, r10, 0x42c0
	ctx.r[10].s64 = ctx.r[10].s64 + 17088;
	// 821AE228: 396B4520  addi r11, r11, 0x4520
	ctx.r[11].s64 = ctx.r[11].s64 + 17696;
	// 821AE22C: 7C09FC2E  lfsx f0, r9, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE230: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821AE234: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AE238: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821AE23C: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821AE240: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE244: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE248: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE24C: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE250: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE254: 48386EA4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AE258 => {
    //   block [0x821AE258..0x821AE2B8)
	// 821AE258: 2F0B001B  cmpwi cr6, r11, 0x1b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 27, &mut ctx.xer);
	// 821AE25C: 41980074  blt cr6, 0x821ae2d0
	if ctx.cr[6].lt {
	pc = 0x821AE2D0; continue 'dispatch;
	}
	// 821AE260: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821AE264: 4199006C  bgt cr6, 0x821ae2d0
	if ctx.cr[6].gt {
	pc = 0x821AE2D0; continue 'dispatch;
	}
	// 821AE268: 394BFFE5  addi r10, r11, -0x1b
	ctx.r[10].s64 = ctx.r[11].s64 + -27;
	// 821AE26C: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 821AE270: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 821AE274: 396B9CF0  addi r11, r11, -0x6310
	ctx.r[11].s64 = ctx.r[11].s64 + -25360;
	// 821AE278: 409800F4  bge cr6, 0x821ae36c
	if !ctx.cr[6].lt {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE27C: 392A001D  addi r9, r10, 0x1d
	ctx.r[9].s64 = ctx.r[10].s64 + 29;
	// 821AE280: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE284: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AE288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE28C: 419A00E0  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE290: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE294: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE298: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 821AE29C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821AE2A0: 419A00CC  beq cr6, 0x821ae36c
	if ctx.cr[6].eq {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE2A4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AE2A8: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE2AC: 396B0540  addi r11, r11, 0x540
	ctx.r[11].s64 = ctx.r[11].s64 + 1344;
	// 821AE2B0: 396B0800  addi r11, r11, 0x800
	ctx.r[11].s64 = ctx.r[11].s64 + 2048;
	// 821AE2B4: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AE2B8; continue 'dispatch;
            }
            0x821AE2B8 => {
    //   block [0x821AE2B8..0x821AE2D0)
	// 821AE2B8: 38C50010  addi r6, r5, 0x10
	ctx.r[6].s64 = ctx.r[5].s64 + 16;
	// 821AE2BC: 4BFF5B25  bl 0x821a3de0
	ctx.lr = 0x821AE2C0;
	sub_821A3DE0(ctx, base);
	// 821AE2C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE2C4: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE2C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE2CC: 48386E2C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AE2D0 => {
    //   block [0x821AE2D0..0x821AE344)
	// 821AE2D0: 2F0B0023  cmpwi cr6, r11, 0x23
	ctx.cr[6].compare_i32(ctx.r[11].s32, 35, &mut ctx.xer);
	// 821AE2D4: 41980098  blt cr6, 0x821ae36c
	if ctx.cr[6].lt {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE2D8: 2F0B0025  cmpwi cr6, r11, 0x25
	ctx.cr[6].compare_i32(ctx.r[11].s32, 37, &mut ctx.xer);
	// 821AE2DC: 41990090  bgt cr6, 0x821ae36c
	if ctx.cr[6].gt {
	pc = 0x821AE36C; continue 'dispatch;
	}
	// 821AE2E0: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AE2E4: 396BFFDD  addi r11, r11, -0x23
	ctx.r[11].s64 = ctx.r[11].s64 + -35;
	// 821AE2E8: 392A02B0  addi r9, r10, 0x2b0
	ctx.r[9].s64 = ctx.r[10].s64 + 688;
	// 821AE2EC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE2F0: 39070004  addi r8, r7, 4
	ctx.r[8].s64 = ctx.r[7].s64 + 4;
	// 821AE2F4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE2F8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AE2FC: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821AE300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE304: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AE308: 9303000C  stw r24, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821AE30C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821AE310: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821AE314: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821AE318: 409A002C  bne cr6, 0x821ae344
	if !ctx.cr[6].eq {
	pc = 0x821AE344; continue 'dispatch;
	}
	// 821AE31C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE320: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE324: 394A4780  addi r10, r10, 0x4780
	ctx.r[10].s64 = ctx.r[10].s64 + 18304;
	// 821AE328: 396B4780  addi r11, r11, 0x4780
	ctx.r[11].s64 = ctx.r[11].s64 + 18304;
	// 821AE32C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE330: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE334: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE338: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE33C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE340: 48386DB8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AE344 => {
    //   block [0x821AE344..0x821AE36C)
	// 821AE344: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 821AE348: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 821AE34C: 394A4830  addi r10, r10, 0x4830
	ctx.r[10].s64 = ctx.r[10].s64 + 18480;
	// 821AE350: 396B4908  addi r11, r11, 0x4908
	ctx.r[11].s64 = ctx.r[11].s64 + 18696;
	// 821AE354: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821AE358: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821AE35C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821AE360: B31B00C2  sth r24, 0xc2(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(194 as u32), ctx.r[24].u16 ) };
	// 821AE364: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE368: 48386D90  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x821AE36C => {
    //   block [0x821AE36C..0x821AE398)
	// 821AE36C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AE370: 419A0028  beq cr6, 0x821ae398
	if ctx.cr[6].eq {
	pc = 0x821AE398; continue 'dispatch;
	}
	// 821AE374: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE378: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 821AE37C: 409A001C  bne cr6, 0x821ae398
	if !ctx.cr[6].eq {
	pc = 0x821AE398; continue 'dispatch;
	}
	// 821AE380: A17C0014  lhz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 821AE384: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821AE388: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821AE38C: 995C0019  stb r10, 0x19(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821AE390: B17C0014  sth r11, 0x14(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 821AE394: 9B5C0025  stb r26, 0x25(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	pc = 0x821AE398; continue 'dispatch;
            }
            0x821AE398 => {
    //   block [0x821AE398..0x821AE3A4)
	// 821AE398: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AE39C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821AE3A0: 48386D58  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE3A8 size=176
    let mut pc: u32 = 0x821AE3A8;
    'dispatch: loop {
        match pc {
            0x821AE3A8 => {
    //   block [0x821AE3A8..0x821AE3D0)
	// 821AE3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE3B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE3B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE3B8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AE3BC: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AE3C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AE3C4: 419A000C  beq cr6, 0x821ae3d0
	if ctx.cr[6].eq {
	pc = 0x821AE3D0; continue 'dispatch;
	}
	// 821AE3C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE3CC: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x821AE3D0; continue 'dispatch;
            }
            0x821AE3D0 => {
    //   block [0x821AE3D0..0x821AE458)
	// 821AE3D0: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AE3D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AE3D8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AE3DC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE3E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821AE3E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE3E8: 4E800421  bctrl
	ctx.lr = 0x821AE3EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE3EC: A17F00C2  lhz r11, 0xc2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AE3F0: 393F0090  addi r9, r31, 0x90
	ctx.r[9].s64 = ctx.r[31].s64 + 144;
	// 821AE3F4: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE3F8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE3FC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821AE400: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AE404: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821AE408: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821AE40C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821AE410: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 821AE414: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 821AE418: 55062036  slwi r6, r8, 4
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE41C: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE420: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE424: B0BF00C2  sth r5, 0xc2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(194 as u32), ctx.r[5].u16 ) };
	// 821AE428: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE42C: 7CC65214  add r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 821AE430: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AE434: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE438: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821AE43C: 4E800421  bctrl
	ctx.lr = 0x821AE440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE440: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AE448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE450: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE454: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE458 size=180
    let mut pc: u32 = 0x821AE458;
    'dispatch: loop {
        match pc {
            0x821AE458 => {
    //   block [0x821AE458..0x821AE4F4)
	// 821AE458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE468: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AE46C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AE470: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AE474: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AE478: 915F0040  stw r10, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 821AE47C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE480: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AE484: 419A0070  beq cr6, 0x821ae4f4
	if ctx.cr[6].eq {
	pc = 0x821AE4F4; continue 'dispatch;
	}
	// 821AE488: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AE48C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AE490: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE494: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821AE49C: 4E800421  bctrl
	ctx.lr = 0x821AE4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821AE4A0: A17F00C2  lhz r11, 0xc2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AE4A4: 393F0090  addi r9, r31, 0x90
	ctx.r[9].s64 = ctx.r[31].s64 + 144;
	// 821AE4A8: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE4AC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE4B0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821AE4B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AE4B8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821AE4BC: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821AE4C0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821AE4C4: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 821AE4C8: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 821AE4CC: 55062036  slwi r6, r8, 4
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821AE4D0: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE4D4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE4D8: B0BF00C2  sth r5, 0xc2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(194 as u32), ctx.r[5].u16 ) };
	// 821AE4DC: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 821AE4E0: 7CC65214  add r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 821AE4E4: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821AE4E8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE4EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821AE4F0: 4E800421  bctrl
	ctx.lr = 0x821AE4F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821AE4F4 => {
    //   block [0x821AE4F4..0x821AE50C)
	// 821AE4F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE4F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AE4FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE510 size=164
    let mut pc: u32 = 0x821AE510;
    'dispatch: loop {
        match pc {
            0x821AE510 => {
    //   block [0x821AE510..0x821AE548)
	// 821AE510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AE518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AE51C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE520: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AE524: 83EBFAC0  lwz r31, -0x540(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AE528: 389F00C4  addi r4, r31, 0xc4
	ctx.r[4].s64 = ctx.r[31].s64 + 196;
	// 821AE52C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE534: 419A0014  beq cr6, 0x821ae548
	if ctx.cr[6].eq {
	pc = 0x821AE548; continue 'dispatch;
	}
	// 821AE538: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AE53C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821AE540: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821AE544: 4BFF3B3D  bl 0x821a2080
	ctx.lr = 0x821AE548;
	sub_821A2080(ctx, base);
	pc = 0x821AE548; continue 'dispatch;
            }
            0x821AE548 => {
    //   block [0x821AE548..0x821AE588)
	// 821AE548: A17F00C0  lhz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 821AE54C: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AE550: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AE554: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE558: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AE55C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE560: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE564: 3D4B0006  addis r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 393216;
	// 821AE568: 394AA578  addi r10, r10, -0x5a88
	ctx.r[10].s64 = ctx.r[10].s64 + -23176;
	// 821AE56C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AE570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE574: 419A0014  beq cr6, 0x821ae588
	if ctx.cr[6].eq {
	pc = 0x821AE588; continue 'dispatch;
	}
	// 821AE578: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE57C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AE580: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AE584: 419A0008  beq cr6, 0x821ae58c
	if ctx.cr[6].eq {
	pc = 0x821AE58C; continue 'dispatch;
	}
	pc = 0x821AE588; continue 'dispatch;
            }
            0x821AE588 => {
    //   block [0x821AE588..0x821AE58C)
	// 821AE588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821AE58C; continue 'dispatch;
            }
            0x821AE58C => {
    //   block [0x821AE58C..0x821AE5A0)
	// 821AE58C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821AE590: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AE594: 409A000C  bne cr6, 0x821ae5a0
	if !ctx.cr[6].eq {
	pc = 0x821AE5A0; continue 'dispatch;
	}
	// 821AE598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821AE59C: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	pc = 0x821AE5A0; continue 'dispatch;
            }
            0x821AE5A0 => {
    //   block [0x821AE5A0..0x821AE5B4)
	// 821AE5A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821AE5A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AE5A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AE5AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AE5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AE5B8 size=188
    let mut pc: u32 = 0x821AE5B8;
    'dispatch: loop {
        match pc {
            0x821AE5B8 => {
    //   block [0x821AE5B8..0x821AE5F0)
	// 821AE5B8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821AE5BC: 551F07FE  clrlwi r31, r8, 0x1f
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 821AE5C0: 80E400C4  lwz r7, 0xc4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE5C4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821AE5C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AE5CC: 409A0024  bne cr6, 0x821ae5f0
	if !ctx.cr[6].eq {
	pc = 0x821AE5F0; continue 'dispatch;
	}
	// 821AE5D0: 54A92036  slwi r9, r5, 4
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AE5D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821AE5D8: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821AE5DC: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 821AE5E0: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821AE5E4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821AE5E8: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821AE5EC: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	pc = 0x821AE5F0; continue 'dispatch;
            }
            0x821AE5F0 => {
    //   block [0x821AE5F0..0x821AE604)
	// 821AE5F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AE5F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AE5F8: 40990040  ble cr6, 0x821ae638
	if !ctx.cr[6].gt {
	pc = 0x821AE638; continue 'dispatch;
	}
	// 821AE5FC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821AE600: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x821AE604; continue 'dispatch;
            }
            0x821AE604 => {
    //   block [0x821AE604..0x821AE638)
	// 821AE604: 54A82036  slwi r8, r5, 4
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AE608: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821AE60C: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 821AE610: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821AE614: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821AE618: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821AE61C: 54A5073E  clrlwi r5, r5, 0x1c
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 821AE620: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821AE624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AE628: F8890000  std r4, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 821AE62C: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821AE630: F9090008  std r8, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821AE634: 409AFFD0  bne cr6, 0x821ae604
	if !ctx.cr[6].eq {
	pc = 0x821AE604; continue 'dispatch;
	}
	pc = 0x821AE638; continue 'dispatch;
            }
            0x821AE638 => {
    //   block [0x821AE638..0x821AE66C)
	// 821AE638: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821AE63C: 409A0030  bne cr6, 0x821ae66c
	if !ctx.cr[6].eq {
	pc = 0x821AE66C; continue 'dispatch;
	}
	// 821AE640: 3965FFFF  addi r11, r5, -1
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	// 821AE644: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE648: 556B2636  rlwinm r11, r11, 4, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821AE64C: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 821AE650: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821AE654: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821AE658: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821AE65C: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821AE660: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821AE664: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821AE668: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	pc = 0x821AE66C; continue 'dispatch;
            }
            0x821AE66C => {
    //   block [0x821AE66C..0x821AE674)
	// 821AE66C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821AE670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AE678 size=804
    let mut pc: u32 = 0x821AE678;
    'dispatch: loop {
        match pc {
            0x821AE678 => {
    //   block [0x821AE678..0x821AE6A4)
	// 821AE678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE67C: 48386A3D  bl 0x825350b8
	ctx.lr = 0x821AE680;
	sub_82535080(ctx, base);
	// 821AE680: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AE684: 810400C4  lwz r8, 0xc4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) } as u64;
	// 821AE688: 54E707FE  clrlwi r7, r7, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821AE68C: 38880100  addi r4, r8, 0x100
	ctx.r[4].s64 = ctx.r[8].s64 + 256;
	// 821AE690: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE694: 3B86FFFF  addi r28, r6, -1
	ctx.r[28].s64 = ctx.r[6].s64 + -1;
	// 821AE698: C1AB1FF8  lfs f13, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AE69C: 409A0008  bne cr6, 0x821ae6a4
	if !ctx.cr[6].eq {
	pc = 0x821AE6A4; continue 'dispatch;
	}
	// 821AE6A0: 3B860001  addi r28, r6, 1
	ctx.r[28].s64 = ctx.r[6].s64 + 1;
	pc = 0x821AE6A4; continue 'dispatch;
            }
            0x821AE6A4 => {
    //   block [0x821AE6A4..0x821AE6E0)
	// 821AE6A4: 7F8B07B4  extsw r11, r28
	ctx.r[11].s64 = ctx.r[28].s32 as i64;
	// 821AE6A8: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 821AE6AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821AE6B0: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821AE6B4: F961FFD0  std r11, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u64 ) };
	// 821AE6B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AE6BC: C801FFD0  lfd f0, -0x30(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821AE6C0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AE6C4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AE6C8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AE6CC: ED406024  fdivs f10, f0, f12
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 821AE6D0: 41980224  blt cr6, 0x821ae8f4
	if ctx.cr[6].lt {
	pc = 0x821AE8F4; continue 'dispatch;
	}
	// 821AE6D4: 3BBCFFFD  addi r29, r28, -3
	ctx.r[29].s64 = ctx.r[28].s64 + -3;
	// 821AE6D8: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 821AE6DC: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	pc = 0x821AE6E0; continue 'dispatch;
            }
            0x821AE6E0 => {
    //   block [0x821AE6E0..0x821AE758)
	// 821AE6E0: ED8D0372  fmuls f12, f13, f13
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE6E4: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE6E8: ED6A682A  fadds f11, f10, f13
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AE6EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE6F0: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE6F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE6F8: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE6FC: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE700: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE704: ED8C037C  fnmsubs f12, f12, f13, f0
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE708: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE70C: D0CBFFF8  stfs f6, -8(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821AE710: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE714: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE718: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AE71C: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE720: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE724: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE728: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE72C: ED274B7A  fmadds f9, f7, f13, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE730: ED06437A  fmadds f8, f6, f13, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE734: EDA5637A  fmadds f13, f5, f13, f12
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AE738: D1ABFFEC  stfs f13, -0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 821AE73C: D12BFFF0  stfs f9, -0x10(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821AE740: D10BFFF4  stfs f8, -0xc(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 821AE744: 409A0014  bne cr6, 0x821ae758
	if !ctx.cr[6].eq {
	pc = 0x821AE758; continue 'dispatch;
	}
	// 821AE748: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AE74C: 419A0014  beq cr6, 0x821ae760
	if ctx.cr[6].eq {
	pc = 0x821AE760; continue 'dispatch;
	}
	// 821AE750: 7F1E3000  cmpw cr6, r30, r6
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE754: 4098000C  bge cr6, 0x821ae760
	if !ctx.cr[6].lt {
	pc = 0x821AE760; continue 'dispatch;
	}
	pc = 0x821AE758; continue 'dispatch;
            }
            0x821AE758 => {
    //   block [0x821AE758..0x821AE760)
	// 821AE758: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE75C: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	pc = 0x821AE760; continue 'dispatch;
            }
            0x821AE760 => {
    //   block [0x821AE760..0x821AE7D8)
	// 821AE760: EDAB02F2  fmuls f13, f11, f11
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 821AE764: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE768: ED8A582A  fadds f12, f10, f11
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 821AE76C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE770: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE774: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE778: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE77C: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE780: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE784: EDAD02FC  fnmsubs f13, f13, f11, f0
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE788: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE78C: D0CB0008  stfs f6, 8(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AE790: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE794: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE798: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AE79C: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE7A0: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE7A4: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE7A8: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE7AC: ED274AFA  fmadds f9, f7, f11, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE7B0: ED0642FA  fmadds f8, f6, f11, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE7B4: EDA56AFA  fmadds f13, f5, f11, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AE7B8: D1ABFFFC  stfs f13, -4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AE7BC: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AE7C0: D10B0004  stfs f8, 4(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AE7C4: 409A0014  bne cr6, 0x821ae7d8
	if !ctx.cr[6].eq {
	pc = 0x821AE7D8; continue 'dispatch;
	}
	// 821AE7C8: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AE7CC: 41820014  beq 0x821ae7e0
	if ctx.cr[0].eq {
	pc = 0x821AE7E0; continue 'dispatch;
	}
	// 821AE7D0: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE7D4: 4098000C  bge cr6, 0x821ae7e0
	if !ctx.cr[6].lt {
	pc = 0x821AE7E0; continue 'dispatch;
	}
	pc = 0x821AE7D8; continue 'dispatch;
            }
            0x821AE7D8 => {
    //   block [0x821AE7D8..0x821AE7E0)
	// 821AE7D8: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE7DC: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	pc = 0x821AE7E0; continue 'dispatch;
            }
            0x821AE7E0 => {
    //   block [0x821AE7E0..0x821AE858)
	// 821AE7E0: EDAC0332  fmuls f13, f12, f12
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE7E4: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE7E8: ED6A602A  fadds f11, f10, f12
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 821AE7EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE7F0: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE7F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE7F8: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE7FC: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE800: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE804: EDAD033C  fnmsubs f13, f13, f12, f0
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE808: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE80C: D0CB0018  stfs f6, 0x18(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821AE810: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE814: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE818: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AE81C: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE820: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE824: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE828: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE82C: ED274B3A  fmadds f9, f7, f12, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE830: ED06433A  fmadds f8, f6, f12, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE834: EDA56B3A  fmadds f13, f5, f12, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AE838: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AE83C: D12B0010  stfs f9, 0x10(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821AE840: D10B0014  stfs f8, 0x14(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821AE844: 409A0014  bne cr6, 0x821ae858
	if !ctx.cr[6].eq {
	pc = 0x821AE858; continue 'dispatch;
	}
	// 821AE848: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821AE84C: 419A0014  beq cr6, 0x821ae860
	if ctx.cr[6].eq {
	pc = 0x821AE860; continue 'dispatch;
	}
	// 821AE850: 7F1F3000  cmpw cr6, r31, r6
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE854: 4098000C  bge cr6, 0x821ae860
	if !ctx.cr[6].lt {
	pc = 0x821AE860; continue 'dispatch;
	}
	pc = 0x821AE858; continue 'dispatch;
            }
            0x821AE858 => {
    //   block [0x821AE858..0x821AE860)
	// 821AE858: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE85C: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	pc = 0x821AE860; continue 'dispatch;
            }
            0x821AE860 => {
    //   block [0x821AE860..0x821AE8D8)
	// 821AE860: EDAB02F2  fmuls f13, f11, f11
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 821AE864: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE868: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE86C: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821AE870: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821AE874: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE878: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE87C: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE880: ED8D02FC  fnmsubs f12, f13, f11, f0
	ctx.f[12].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE884: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE888: EDAA582A  fadds f13, f10, f11
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 821AE88C: D0CB0028  stfs f6, 0x28(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821AE890: C0AA0000  lfs f5, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE894: C0CA0008  lfs f6, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE898: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AE89C: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE8A0: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE8A4: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE8A8: C0EA0004  lfs f7, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE8AC: ED274AFA  fmadds f9, f7, f11, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE8B0: ED0642FA  fmadds f8, f6, f11, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE8B4: ED8562FA  fmadds f12, f5, f11, f12
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AE8B8: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AE8BC: D12B0020  stfs f9, 0x20(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821AE8C0: D10B0024  stfs f8, 0x24(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821AE8C4: 409A0014  bne cr6, 0x821ae8d8
	if !ctx.cr[6].eq {
	pc = 0x821AE8D8; continue 'dispatch;
	}
	// 821AE8C8: 355F0001  addic. r10, r31, 1
	ctx.xer.ca = (ctx.r[31].u32 > (!(1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AE8CC: 41820014  beq 0x821ae8e0
	if ctx.cr[0].eq {
	pc = 0x821AE8E0; continue 'dispatch;
	}
	// 821AE8D0: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE8D4: 4098000C  bge cr6, 0x821ae8e0
	if !ctx.cr[6].lt {
	pc = 0x821AE8E0; continue 'dispatch;
	}
	pc = 0x821AE8D8; continue 'dispatch;
            }
            0x821AE8D8 => {
    //   block [0x821AE8D8..0x821AE8E0)
	// 821AE8D8: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821AE8DC: 5545073E  clrlwi r5, r10, 0x1c
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	pc = 0x821AE8E0; continue 'dispatch;
            }
            0x821AE8E0 => {
    //   block [0x821AE8E0..0x821AE8F4)
	// 821AE8E0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821AE8E4: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821AE8E8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821AE8EC: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821AE8F0: 4099FDF0  ble cr6, 0x821ae6e0
	if !ctx.cr[6].gt {
	pc = 0x821AE6E0; continue 'dispatch;
	}
	pc = 0x821AE8F4; continue 'dispatch;
            }
            0x821AE8F4 => {
    //   block [0x821AE8F4..0x821AE908)
	// 821AE8F4: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821AE8F8: 419900A0  bgt cr6, 0x821ae998
	if ctx.cr[6].gt {
	pc = 0x821AE998; continue 'dispatch;
	}
	// 821AE8FC: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE900: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821AE904: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	pc = 0x821AE908; continue 'dispatch;
            }
            0x821AE908 => {
    //   block [0x821AE908..0x821AE980)
	// 821AE908: ED8D0372  fmuls f12, f13, f13
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AE90C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE910: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821AE914: 7D2B2214  add r9, r11, r4
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821AE918: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821AE91C: C1290004  lfs f9, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AE920: C1090008  lfs f8, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821AE924: C0E90000  lfs f7, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE928: ED8C037C  fnmsubs f12, f12, f13, f0
	ctx.f[12].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AE92C: C0CB000C  lfs f6, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE930: D0CA0008  stfs f6, 8(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821AE934: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AE938: C0CB0008  lfs f6, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821AE93C: C0AB0000  lfs f5, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821AE940: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AE944: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE948: ED080332  fmuls f8, f8, f12
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE94C: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AE950: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821AE954: ED274AFA  fmadds f9, f7, f11, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821AE958: D12A0000  stfs f9, 0(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AE95C: ED0642FA  fmadds f8, f6, f11, f8
	ctx.f[8].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821AE960: D10A0004  stfs f8, 4(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AE964: ED8562FA  fmadds f12, f5, f11, f12
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 821AE968: D18AFFFC  stfs f12, -4(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821AE96C: 409A0014  bne cr6, 0x821ae980
	if !ctx.cr[6].eq {
	pc = 0x821AE980; continue 'dispatch;
	}
	// 821AE970: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AE974: 419A0014  beq cr6, 0x821ae988
	if ctx.cr[6].eq {
	pc = 0x821AE988; continue 'dispatch;
	}
	// 821AE978: 7F1E3000  cmpw cr6, r30, r6
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821AE97C: 4098000C  bge cr6, 0x821ae988
	if !ctx.cr[6].lt {
	pc = 0x821AE988; continue 'dispatch;
	}
	pc = 0x821AE980; continue 'dispatch;
            }
            0x821AE980 => {
    //   block [0x821AE980..0x821AE988)
	// 821AE980: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 821AE984: 5565073E  clrlwi r5, r11, 0x1c
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	pc = 0x821AE988; continue 'dispatch;
            }
            0x821AE988 => {
    //   block [0x821AE988..0x821AE998)
	// 821AE988: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821AE98C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821AE990: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821AE994: 4099FF74  ble cr6, 0x821ae908
	if !ctx.cr[6].gt {
	pc = 0x821AE908; continue 'dispatch;
	}
	pc = 0x821AE998; continue 'dispatch;
            }
            0x821AE998 => {
    //   block [0x821AE998..0x821AE99C)
	// 821AE998: 48386770  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AE9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821AE9A0 size=344
    let mut pc: u32 = 0x821AE9A0;
    'dispatch: loop {
        match pc {
            0x821AE9A0 => {
    //   block [0x821AE9A0..0x821AE9FC)
	// 821AE9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AE9A4: 48386711  bl 0x825350b4
	ctx.lr = 0x821AE9A8;
	sub_82535080(ctx, base);
	// 821AE9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AE9AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821AE9B0: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821AE9B4: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 821AE9B8: 6148A578  ori r8, r10, 0xa578
	ctx.r[8].u64 = ctx.r[10].u64 | 42360;
	// 821AE9BC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AE9C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821AE9C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AE9C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821AE9CC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AE9D0: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821AE9D4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 821AE9D8: 7D7B402A  ldx r11, r27, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32)) };
	// 821AE9DC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821AE9E0: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821AE9E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AE9E8: 419A0014  beq cr6, 0x821ae9fc
	if ctx.cr[6].eq {
	pc = 0x821AE9FC; continue 'dispatch;
	}
	// 821AE9EC: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AE9F0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821AE9F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AE9F8: 419A002C  beq cr6, 0x821aea24
	if ctx.cr[6].eq {
	pc = 0x821AEA24; continue 'dispatch;
	}
	pc = 0x821AE9FC; continue 'dispatch;
            }
            0x821AE9FC => {
    //   block [0x821AE9FC..0x821AEA18)
	// 821AE9FC: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821AEA00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821AEA04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AEA08: 4BFFF491  bl 0x821ade98
	ctx.lr = 0x821AEA0C;
	sub_821ADE98(ctx, base);
	// 821AEA0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821AEA10: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AEA14: 409A0010  bne cr6, 0x821aea24
	if !ctx.cr[6].eq {
	pc = 0x821AEA24; continue 'dispatch;
	}
	pc = 0x821AEA18; continue 'dispatch;
            }
            0x821AEA18 => {
    //   block [0x821AEA18..0x821AEA24)
	// 821AEA18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AEA1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AEA20: 483866E4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821AEA24 => {
    //   block [0x821AEA24..0x821AEA54)
	// 821AEA24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AEA28: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821AEA2C: 38EB0F9C  addi r7, r11, 0xf9c
	ctx.r[7].s64 = ctx.r[11].s64 + 3996;
	// 821AEA30: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821AEA34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AEA38: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 821AEA3C: 481BBA55  bl 0x8236a490
	ctx.lr = 0x821AEA40;
	sub_8236A490(ctx, base);
	// 821AEA40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AEA44: 419A0010  beq cr6, 0x821aea54
	if ctx.cr[6].eq {
	pc = 0x821AEA54; continue 'dispatch;
	}
	// 821AEA48: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AEA4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821AEA50: 48000008  b 0x821aea58
	pc = 0x821AEA58; continue 'dispatch;
            }
            0x821AEA54 => {
    //   block [0x821AEA54..0x821AEA58)
	// 821AEA54: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	pc = 0x821AEA58; continue 'dispatch;
            }
            0x821AEA58 => {
    //   block [0x821AEA58..0x821AEAF8)
	// 821AEA58: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821AEA5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821AEA60: 419AFFB8  beq cr6, 0x821aea18
	if ctx.cr[6].eq {
	pc = 0x821AEA18; continue 'dispatch;
	}
	// 821AEA64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AEA68: 3D40821B  lis r10, -0x7de5
	ctx.r[10].s64 = -2112159744;
	// 821AEA6C: 396B0F7C  addi r11, r11, 0xf7c
	ctx.r[11].s64 = ctx.r[11].s64 + 3964;
	// 821AEA70: 394AF3A0  addi r10, r10, -0xc60
	ctx.r[10].s64 = ctx.r[10].s64 + -3168;
	// 821AEA74: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 821AEA78: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 821AEA7C: 39297D58  addi r9, r9, 0x7d58
	ctx.r[9].s64 = ctx.r[9].s64 + 32088;
	// 821AEA80: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821AEA84: 3D60821B  lis r11, -0x7de5
	ctx.r[11].s64 = -2112159744;
	// 821AEA88: FBE30110  std r31, 0x110(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[31].u64 ) };
	// 821AEA8C: FBE30118  std r31, 0x118(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[31].u64 ) };
	// 821AEA90: 390BF948  addi r8, r11, -0x6b8
	ctx.r[8].s64 = ctx.r[11].s64 + -1720;
	// 821AEA94: FBE30120  std r31, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[31].u64 ) };
	// 821AEA98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821AEA9C: FBE30128  std r31, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[31].u64 ) };
	// 821AEAA0: 91430058  stw r10, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821AEAA4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821AEAA8: 91230054  stw r9, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821AEAAC: 9103005C  stw r8, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821AEAB0: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 821AEAB4: 98E30025  stb r7, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[7].u8 ) };
	// 821AEAB8: B14300AE  sth r10, 0xae(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(174 as u32), ctx.r[10].u16 ) };
	// 821AEABC: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821AEAC0: 93C30080  stw r30, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 821AEAC4: B3A300AA  sth r29, 0xaa(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(170 as u32), ctx.r[29].u16 ) };
	// 821AEAC8: 614AA580  ori r10, r10, 0xa580
	ctx.r[10].u64 = ctx.r[10].u64 | 42368;
	// 821AEACC: FBE30120  std r31, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[31].u64 ) };
	// 821AEAD0: FBE30128  std r31, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[31].u64 ) };
	// 821AEAD4: B3E300AC  sth r31, 0xac(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[31].u16 ) };
	// 821AEAD8: 811C0010  lwz r8, 0x10(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AEADC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AEAE0: A10800C2  lhz r8, 0xc2(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AEAE4: B16300A8  sth r11, 0xa8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[11].u16 ) };
	// 821AEAE8: B10300A4  sth r8, 0xa4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[8].u16 ) };
	// 821AEAEC: 7D3B512A  stdx r9, r27, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u64) };
	// 821AEAF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821AEAF4: 48386610  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AEAF8 size=356
    let mut pc: u32 = 0x821AEAF8;
    'dispatch: loop {
        match pc {
            0x821AEAF8 => {
    //   block [0x821AEAF8..0x821AEB64)
	// 821AEAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AEB00: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 821AEB04: 483874E5  bl 0x82535fe8
	ctx.lr = 0x821AEB08;
	sub_82535FB0(ctx, base);
	// 821AEB08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEB0C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEB10: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 821AEB14: 7CC60734  extsh r6, r6
	ctx.r[6].s64 = ctx.r[6].s16 as i64;
	// 821AEB18: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 821AEB1C: 6167BEBC  ori r7, r11, 0xbebc
	ctx.r[7].u64 = ctx.r[11].u64 | 48828;
	// 821AEB20: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821AEB24: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AEB28: 2F060100  cmpwi cr6, r6, 0x100
	ctx.cr[6].compare_i32(ctx.r[6].s32, 256, &mut ctx.xer);
	// 821AEB2C: 392BA510  addi r9, r11, -0x5af0
	ctx.r[9].s64 = ctx.r[11].s64 + -23280;
	// 821AEB30: 40980034  bge cr6, 0x821aeb64
	if !ctx.cr[6].lt {
	pc = 0x821AEB64; continue 'dispatch;
	}
	// 821AEB34: 7CAA0734  extsh r10, r5
	ctx.r[10].s64 = ctx.r[5].s16 as i64;
	// 821AEB38: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEB3C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AEB40: 396BFADC  addi r11, r11, -0x524
	ctx.r[11].s64 = ctx.r[11].s64 + -1316;
	// 821AEB44: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEB4C: 409A002C  bne cr6, 0x821aeb78
	if !ctx.cr[6].eq {
	pc = 0x821AEB78; continue 'dispatch;
	}
	// 821AEB50: 7D643A2E  lhzx r11, r4, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AEB54: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821AEB58: 556B303E  rotlwi r11, r11, 6
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 821AEB5C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AEB60: 48000018  b 0x821aeb78
	pc = 0x821AEB78; continue 'dispatch;
            }
            0x821AEB64 => {
    //   block [0x821AEB64..0x821AEB78)
	// 821AEB64: 3946FF00  addi r10, r6, -0x100
	ctx.r[10].s64 = ctx.r[6].s64 + -256;
	// 821AEB68: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821AEB6C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AEB70: 396BB650  addi r11, r11, -0x49b0
	ctx.r[11].s64 = ctx.r[11].s64 + -18864;
	// 821AEB74: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821AEB78; continue 'dispatch;
            }
            0x821AEB78 => {
    //   block [0x821AEB78..0x821AEB98)
	// 821AEB78: 2F0600FF  cmpwi cr6, r6, 0xff
	ctx.cr[6].compare_i32(ctx.r[6].s32, 255, &mut ctx.xer);
	// 821AEB7C: 409A001C  bne cr6, 0x821aeb98
	if !ctx.cr[6].eq {
	pc = 0x821AEB98; continue 'dispatch;
	}
	// 821AEB80: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AEB84: 409A0014  bne cr6, 0x821aeb98
	if !ctx.cr[6].eq {
	pc = 0x821AEB98; continue 'dispatch;
	}
	// 821AEB88: 7D443A2E  lhzx r10, r4, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821AEB8C: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 821AEB90: 7FCA4C2E  lfsx f30, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821AEB94: 48000038  b 0x821aebcc
	pc = 0x821AEBCC; continue 'dispatch;
            }
            0x821AEB98 => {
    //   block [0x821AEB98..0x821AEBC4)
	// 821AEB98: 2F0600C0  cmpwi cr6, r6, 0xc0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 192, &mut ctx.xer);
	// 821AEB9C: 40980028  bge cr6, 0x821aebc4
	if !ctx.cr[6].lt {
	pc = 0x821AEBC4; continue 'dispatch;
	}
	// 821AEBA0: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 821AEBA4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821AEBA8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AEBAC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AEBB0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AEBB4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AEBB8: C00A2050  lfs f0, 0x2050(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEBBC: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AEBC0: 4800000C  b 0x821aebcc
	pc = 0x821AEBCC; continue 'dispatch;
            }
            0x821AEBC4 => {
    //   block [0x821AEBC4..0x821AEBCC)
	// 821AEBC4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AEBC8: C3CA2074  lfs f30, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821AEBCC; continue 'dispatch;
            }
            0x821AEBCC => {
    //   block [0x821AEBCC..0x821AEBDC)
	// 821AEBCC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821AEBD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AEBD4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AEBD8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821AEBDC; continue 'dispatch;
            }
            0x821AEBDC => {
    //   block [0x821AEBDC..0x821AEC04)
	// 821AEBDC: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEBE0: 2F0600C0  cmpwi cr6, r6, 0xc0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 192, &mut ctx.xer);
	// 821AEBE4: EC800732  fmuls f4, f0, f28
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 821AEBE8: 419A0028  beq cr6, 0x821aec10
	if ctx.cr[6].eq {
	pc = 0x821AEC10; continue 'dispatch;
	}
	// 821AEBEC: 2F0600C1  cmpwi cr6, r6, 0xc1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 193, &mut ctx.xer);
	// 821AEBF0: 419A0020  beq cr6, 0x821aec10
	if ctx.cr[6].eq {
	pc = 0x821AEC10; continue 'dispatch;
	}
	// 821AEBF4: 2F0600C2  cmpwi cr6, r6, 0xc2
	ctx.cr[6].compare_i32(ctx.r[6].s32, 194, &mut ctx.xer);
	// 821AEBF8: 409A000C  bne cr6, 0x821aec04
	if !ctx.cr[6].eq {
	pc = 0x821AEC04; continue 'dispatch;
	}
	// 821AEBFC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821AEC00: 41980010  blt cr6, 0x821aec10
	if ctx.cr[6].lt {
	pc = 0x821AEC10; continue 'dispatch;
	}
	pc = 0x821AEC04; continue 'dispatch;
            }
            0x821AEC04 => {
    //   block [0x821AEC04..0x821AEC10)
	// 821AEC04: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEC08: EC5D0032  fmuls f2, f29, f0
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AEC0C: 48000008  b 0x821aec14
	pc = 0x821AEC14; continue 'dispatch;
            }
            0x821AEC10 => {
    //   block [0x821AEC10..0x821AEC14)
	// 821AEC10: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	pc = 0x821AEC14; continue 'dispatch;
            }
            0x821AEC14 => {
    //   block [0x821AEC14..0x821AEC24)
	// 821AEC14: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821AEC18: 4198000C  blt cr6, 0x821aec24
	if ctx.cr[6].lt {
	pc = 0x821AEC24; continue 'dispatch;
	}
	// 821AEC1C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AEC20: 48000008  b 0x821aec28
	pc = 0x821AEC28; continue 'dispatch;
            }
            0x821AEC24 => {
    //   block [0x821AEC24..0x821AEC28)
	// 821AEC24: C028FFFC  lfs f1, -4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x821AEC28; continue 'dispatch;
            }
            0x821AEC28 => {
    //   block [0x821AEC28..0x821AEC5C)
	// 821AEC28: C0680004  lfs f3, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821AEC2C: 481C218D  bl 0x82370db8
	ctx.lr = 0x821AEC30;
	sub_82370DB8(ctx, base);
	// 821AEC30: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821AEC34: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 821AEC38: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 821AEC3C: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 821AEC40: 4198FF9C  blt cr6, 0x821aebdc
	if ctx.cr[6].lt {
	pc = 0x821AEBDC; continue 'dispatch;
	}
	// 821AEC44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821AEC48: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 821AEC4C: 483873E9  bl 0x82536034
	ctx.lr = 0x821AEC50;
	sub_82535FFC(ctx, base);
	// 821AEC50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AEC54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AEC58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AEC60 size=1028
    let mut pc: u32 = 0x821AEC60;
    'dispatch: loop {
        match pc {
            0x821AEC60 => {
    //   block [0x821AEC60..0x821AECCC)
	// 821AEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AEC64: 48386441  bl 0x825350a4
	ctx.lr = 0x821AEC68;
	sub_82535080(ctx, base);
	// 821AEC68: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821AEC6C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AEC70: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821AEC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AEC78: 56EB07BC  rlwinm r11, r23, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821AEC7C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821AEC80: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821AEC84: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821AEC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AEC8C: 419A0370  beq cr6, 0x821aeffc
	if ctx.cr[6].eq {
	pc = 0x821AEFFC; continue 'dispatch;
	}
	// 821AEC90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AEC94: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AEC98: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEC9C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AECA0: 4099035C  ble cr6, 0x821aeffc
	if !ctx.cr[6].gt {
	pc = 0x821AEFFC; continue 'dispatch;
	}
	// 821AECA4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821AECA8: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821AECAC: 616B91F4  ori r11, r11, 0x91f4
	ctx.r[11].u64 = ctx.r[11].u64 | 37364;
	// 821AECB0: 7D385A2E  lhzx r9, r24, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AECB4: 419A0018  beq cr6, 0x821aeccc
	if ctx.cr[6].eq {
	pc = 0x821AECCC; continue 'dispatch;
	}
	// 821AECB8: A17F00AE  lhz r11, 0xae(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(174 as u32) ) } as u64;
	// 821AECBC: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 821AECC0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AECC4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821AECC8: 419A0334  beq cr6, 0x821aeffc
	if ctx.cr[6].eq {
	pc = 0x821AEFFC; continue 'dispatch;
	}
	pc = 0x821AECCC; continue 'dispatch;
            }
            0x821AECCC => {
    //   block [0x821AECCC..0x821AED20)
	// 821AECCC: 817F0124  lwz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AECD0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821AECD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AECD8: 419A004C  beq cr6, 0x821aed24
	if ctx.cr[6].eq {
	pc = 0x821AED24; continue 'dispatch;
	}
	// 821AECDC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AECE0: 811F0120  lwz r8, 0x120(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AECE4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AECE8: 409A003C  bne cr6, 0x821aed24
	if !ctx.cr[6].eq {
	pc = 0x821AED24; continue 'dispatch;
	}
	// 821AECEC: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AECF0: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AECF4: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AECF8: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AECFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AED00: 419A0020  beq cr6, 0x821aed20
	if ctx.cr[6].eq {
	pc = 0x821AED20; continue 'dispatch;
	}
	// 821AED04: 810A0030  lwz r8, 0x30(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AED08: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AED0C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AED10: 409A0010  bne cr6, 0x821aed20
	if !ctx.cr[6].eq {
	pc = 0x821AED20; continue 'dispatch;
	}
	// 821AED14: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AED18: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED1C: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AED20; continue 'dispatch;
            }
            0x821AED20 => {
    //   block [0x821AED20..0x821AED24)
	// 821AED20: FB9F0120  std r28, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[28].u64 ) };
	pc = 0x821AED24; continue 'dispatch;
            }
            0x821AED24 => {
    //   block [0x821AED24..0x821AED74)
	// 821AED24: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AED28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AED2C: 419A004C  beq cr6, 0x821aed78
	if ctx.cr[6].eq {
	pc = 0x821AED78; continue 'dispatch;
	}
	// 821AED30: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AED34: 811F0128  lwz r8, 0x128(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AED38: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AED3C: 409A003C  bne cr6, 0x821aed78
	if !ctx.cr[6].eq {
	pc = 0x821AED78; continue 'dispatch;
	}
	// 821AED40: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AED44: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED48: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AED4C: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AED50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AED54: 419A0020  beq cr6, 0x821aed74
	if ctx.cr[6].eq {
	pc = 0x821AED74; continue 'dispatch;
	}
	// 821AED58: 810A0030  lwz r8, 0x30(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AED5C: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AED60: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AED64: 409A0010  bne cr6, 0x821aed74
	if !ctx.cr[6].eq {
	pc = 0x821AED74; continue 'dispatch;
	}
	// 821AED68: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AED6C: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED70: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AED74; continue 'dispatch;
            }
            0x821AED74 => {
    //   block [0x821AED74..0x821AED78)
	// 821AED74: FB9F0128  std r28, 0x128(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[28].u64 ) };
	pc = 0x821AED78; continue 'dispatch;
            }
            0x821AED78 => {
    //   block [0x821AED78..0x821AEDE8)
	// 821AED78: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 821AED7C: B13F00AE  sth r9, 0xae(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(174 as u32), ctx.r[9].u16 ) };
	// 821AED80: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AED84: 419A0064  beq cr6, 0x821aede8
	if ctx.cr[6].eq {
	pc = 0x821AEDE8; continue 'dispatch;
	}
	// 821AED88: 556A04A0  rlwinm r10, r11, 0, 0x12, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AED8C: 556B97FE  rlwinm r11, r11, 0x12, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 821AED90: 7D5A0734  extsh r26, r10
	ctx.r[26].s64 = ctx.r[10].s16 as i64;
	// 821AED94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AED98: 419A0054  beq cr6, 0x821aedec
	if ctx.cr[6].eq {
	pc = 0x821AEDEC; continue 'dispatch;
	}
	// 821AED9C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEDA0: 616BED4E  ori r11, r11, 0xed4e
	ctx.r[11].u64 = ctx.r[11].u64 | 60750;
	// 821AEDA4: 7D785A2E  lhzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEDA8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 821AEDAC: 409A0040  bne cr6, 0x821aedec
	if !ctx.cr[6].eq {
	pc = 0x821AEDEC; continue 'dispatch;
	}
	// 821AEDB0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEDB4: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 821AEDB8: 616ABEBC  ori r10, r11, 0xbebc
	ctx.r[10].u64 = ctx.r[11].u64 | 48828;
	// 821AEDBC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AEDC0: 3B6000C1  li r27, 0xc1
	ctx.r[27].s64 = 193;
	// 821AEDC4: 3B400009  li r26, 9
	ctx.r[26].s64 = 9;
	// 821AEDC8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AEDCC: D3FF008C  stfs f31, 0x8c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AEDD0: 7D58522E  lhzx r10, r24, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AEDD4: 2B0A001B  cmplwi cr6, r10, 0x1b
	ctx.cr[6].compare_u32(ctx.r[10].u32, 27 as u32, &mut ctx.xer);
	// 821AEDD8: 409A0044  bne cr6, 0x821aee1c
	if !ctx.cr[6].eq {
	pc = 0x821AEE1C; continue 'dispatch;
	}
	// 821AEDDC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEDE0: 396B15A0  addi r11, r11, 0x15a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5536;
	// 821AEDE4: 48000054  b 0x821aee38
	pc = 0x821AEE38; continue 'dispatch;
            }
            0x821AEDE8 => {
    //   block [0x821AEDE8..0x821AEDEC)
	// 821AEDE8: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	pc = 0x821AEDEC; continue 'dispatch;
            }
            0x821AEDEC => {
    //   block [0x821AEDEC..0x821AEE08)
	// 821AEDEC: 7F4B0734  extsh r11, r26
	ctx.r[11].s64 = ctx.r[26].s16 as i64;
	// 821AEDF0: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AEDF4: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AEDF8: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 821AEDFC: 4198000C  blt cr6, 0x821aee08
	if ctx.cr[6].lt {
	pc = 0x821AEE08; continue 'dispatch;
	}
	// 821AEE00: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821AEE04: 7D7A0734  extsh r26, r11
	ctx.r[26].s64 = ctx.r[11].s16 as i64;
	pc = 0x821AEE08; continue 'dispatch;
            }
            0x821AEE08 => {
    //   block [0x821AEE08..0x821AEE1C)
	// 821AEE08: 7F4B0734  extsh r11, r26
	ctx.r[11].s64 = ctx.r[26].s16 as i64;
	// 821AEE0C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821AEE10: 41990100  bgt cr6, 0x821aef10
	if ctx.cr[6].gt {
	pc = 0x821AEF10; continue 'dispatch;
	}
	// 821AEE14: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 821AEE18: 48000108  b 0x821aef20
	pc = 0x821AEF20; continue 'dispatch;
            }
            0x821AEE1C => {
    //   block [0x821AEE1C..0x821AEE30)
	// 821AEE1C: 2B0A0023  cmplwi cr6, r10, 0x23
	ctx.cr[6].compare_u32(ctx.r[10].u32, 35 as u32, &mut ctx.xer);
	// 821AEE20: 409A0010  bne cr6, 0x821aee30
	if !ctx.cr[6].eq {
	pc = 0x821AEE30; continue 'dispatch;
	}
	// 821AEE24: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEE28: 396B1630  addi r11, r11, 0x1630
	ctx.r[11].s64 = ctx.r[11].s64 + 5680;
	// 821AEE2C: 4800000C  b 0x821aee38
	pc = 0x821AEE38; continue 'dispatch;
            }
            0x821AEE30 => {
    //   block [0x821AEE30..0x821AEE38)
	// 821AEE30: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEE34: 396B1528  addi r11, r11, 0x1528
	ctx.r[11].s64 = ctx.r[11].s64 + 5416;
	pc = 0x821AEE38; continue 'dispatch;
            }
            0x821AEE38 => {
    //   block [0x821AEE38..0x821AEE5C)
	// 821AEE38: A13F00AA  lhz r9, 0xaa(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AEE3C: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 821AEE40: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821AEE44: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AEE48: 7FC9582E  lwzx r30, r9, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEE4C: 409A0010  bne cr6, 0x821aee5c
	if !ctx.cr[6].eq {
	pc = 0x821AEE5C; continue 'dispatch;
	}
	// 821AEE50: 2F1E0017  cmpwi cr6, r30, 0x17
	ctx.cr[6].compare_i32(ctx.r[30].s32, 23, &mut ctx.xer);
	// 821AEE54: 409A0008  bne cr6, 0x821aee5c
	if !ctx.cr[6].eq {
	pc = 0x821AEE5C; continue 'dispatch;
	}
	// 821AEE58: 3BC0001F  li r30, 0x1f
	ctx.r[30].s64 = 31;
	pc = 0x821AEE5C; continue 'dispatch;
            }
            0x821AEE5C => {
    //   block [0x821AEE5C..0x821AEF10)
	// 821AEE5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821AEE60: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821AEE64: 390000C1  li r8, 0xc1
	ctx.r[8].s64 = 193;
	// 821AEE68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AEE6C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821AEE70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821AEE74: C02BD218  lfs f1, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEE78: 3D600010  lis r11, 0x10
	ctx.r[11].s64 = 1048576;
	// 821AEE7C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AEE80: 617D0100  ori r29, r11, 0x100
	ctx.r[29].u64 = ctx.r[11].u64 | 256;
	// 821AEE84: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821AEE88: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821AEE8C: 4BFF1C3D  bl 0x821a0ac8
	ctx.lr = 0x821AEE90;
	sub_821A0AC8(ctx, base);
	// 821AEE90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AEE94: 39000400  li r8, 0x400
	ctx.r[8].s64 = 1024;
	// 821AEE98: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821AEE9C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AEEA0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821AEEA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821AEEA8: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 821AEEAC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821AEEB0: 9381008C  stw r28, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u32 ) };
	// 821AEEB4: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AEEB8: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 821AEEBC: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 821AEEC0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 821AEEC4: C02A2068  lfs f1, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEEC8: 3900007C  li r8, 0x7c
	ctx.r[8].s64 = 124;
	// 821AEECC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821AEED0: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 821AEED4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AEED8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 821AEEDC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821AEEE0: F97F0120  std r11, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u64 ) };
	// 821AEEE4: 4BFFC275  bl 0x821ab158
	ctx.lr = 0x821AEEE8;
	sub_821AB158(ctx, base);
	// 821AEEE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AEEEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821AEEF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AEEF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AEEF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821AEEFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821AEF00: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821AEF04: F97F0128  std r11, 0x128(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u64 ) };
	// 821AEF08: 481B2201  bl 0x82361108
	ctx.lr = 0x821AEF0C;
	sub_82361108(ctx, base);
	// 821AEF0C: 480000BC  b 0x821aefc8
	pc = 0x821AEFC8; continue 'dispatch;
            }
            0x821AEF10 => {
    //   block [0x821AEF10..0x821AEF20)
	// 821AEF10: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821AEF14: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 821AEF18: 40990008  ble cr6, 0x821aef20
	if !ctx.cr[6].gt {
	pc = 0x821AEF20; continue 'dispatch;
	}
	// 821AEF1C: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	pc = 0x821AEF20; continue 'dispatch;
            }
            0x821AEF20 => {
    //   block [0x821AEF20..0x821AEF48)
	// 821AEF20: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821AEF24: 419800A0  blt cr6, 0x821aefc4
	if ctx.cr[6].lt {
	pc = 0x821AEFC4; continue 'dispatch;
	}
	// 821AEF28: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AEF2C: 616BBEBC  ori r11, r11, 0xbebc
	ctx.r[11].u64 = ctx.r[11].u64 | 48828;
	// 821AEF30: 7D585A2E  lhzx r10, r24, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEF34: 2B0A001B  cmplwi cr6, r10, 0x1b
	ctx.cr[6].compare_u32(ctx.r[10].u32, 27 as u32, &mut ctx.xer);
	// 821AEF38: 409A0010  bne cr6, 0x821aef48
	if !ctx.cr[6].eq {
	pc = 0x821AEF48; continue 'dispatch;
	}
	// 821AEF3C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEF40: 396B15A0  addi r11, r11, 0x15a0
	ctx.r[11].s64 = ctx.r[11].s64 + 5536;
	// 821AEF44: 48000020  b 0x821aef64
	pc = 0x821AEF64; continue 'dispatch;
            }
            0x821AEF48 => {
    //   block [0x821AEF48..0x821AEF5C)
	// 821AEF48: 2B0A0023  cmplwi cr6, r10, 0x23
	ctx.cr[6].compare_u32(ctx.r[10].u32, 35 as u32, &mut ctx.xer);
	// 821AEF4C: 409A0010  bne cr6, 0x821aef5c
	if !ctx.cr[6].eq {
	pc = 0x821AEF5C; continue 'dispatch;
	}
	// 821AEF50: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEF54: 396B1630  addi r11, r11, 0x1630
	ctx.r[11].s64 = ctx.r[11].s64 + 5680;
	// 821AEF58: 4800000C  b 0x821aef64
	pc = 0x821AEF64; continue 'dispatch;
            }
            0x821AEF5C => {
    //   block [0x821AEF5C..0x821AEF64)
	// 821AEF5C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEF60: 396B1528  addi r11, r11, 0x1528
	ctx.r[11].s64 = ctx.r[11].s64 + 5416;
	pc = 0x821AEF64; continue 'dispatch;
            }
            0x821AEF64 => {
    //   block [0x821AEF64..0x821AEF88)
	// 821AEF64: A13F00AA  lhz r9, 0xaa(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AEF68: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 821AEF6C: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821AEF70: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AEF74: 7CA9582E  lwzx r5, r9, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AEF78: 409A0010  bne cr6, 0x821aef88
	if !ctx.cr[6].eq {
	pc = 0x821AEF88; continue 'dispatch;
	}
	// 821AEF7C: 2F050017  cmpwi cr6, r5, 0x17
	ctx.cr[6].compare_i32(ctx.r[5].s32, 23, &mut ctx.xer);
	// 821AEF80: 409A0008  bne cr6, 0x821aef88
	if !ctx.cr[6].eq {
	pc = 0x821AEF88; continue 'dispatch;
	}
	// 821AEF84: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	pc = 0x821AEF88; continue 'dispatch;
            }
            0x821AEF88 => {
    //   block [0x821AEF88..0x821AEFC4)
	// 821AEF88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AEF8C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821AEF90: 3D400010  lis r10, 0x10
	ctx.r[10].s64 = 1048576;
	// 821AEF94: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 821AEF98: 614A0100  ori r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 256;
	// 821AEF9C: 38E0000E  li r7, 0xe
	ctx.r[7].s64 = 14;
	// 821AEFA0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821AEFA4: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEFA8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AEFAC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821AEFB0: 4BFF1B19  bl 0x821a0ac8
	ctx.lr = 0x821AEFB4;
	sub_821A0AC8(ctx, base);
	// 821AEFB4: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821AEFB8: 3B600080  li r27, 0x80
	ctx.r[27].s64 = 128;
	// 821AEFBC: F97F0120  std r11, 0x120(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u64 ) };
	// 821AEFC0: 48000008  b 0x821aefc8
	pc = 0x821AEFC8; continue 'dispatch;
            }
            0x821AEFC4 => {
    //   block [0x821AEFC4..0x821AEFC8)
	// 821AEFC4: 3B6000FF  li r27, 0xff
	ctx.r[27].s64 = 255;
	pc = 0x821AEFC8; continue 'dispatch;
            }
            0x821AEFC8 => {
    //   block [0x821AEFC8..0x821AEFF4)
	// 821AEFC8: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AEFCC: 395A0001  addi r10, r26, 1
	ctx.r[10].s64 = ctx.r[26].s64 + 1;
	// 821AEFD0: 396BFC10  addi r11, r11, -0x3f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1008;
	// 821AEFD4: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821AEFD8: 392B0058  addi r9, r11, 0x58
	ctx.r[9].s64 = ctx.r[11].s64 + 88;
	// 821AEFDC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AEFE0: 56E8077A  rlwinm r8, r23, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821AEFE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821AEFE8: 7C2A4C2E  lfsx f1, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AEFEC: 419A0008  beq cr6, 0x821aeff4
	if ctx.cr[6].eq {
	pc = 0x821AEFF4; continue 'dispatch;
	}
	// 821AEFF0: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	pc = 0x821AEFF4; continue 'dispatch;
            }
            0x821AEFF4 => {
    //   block [0x821AEFF4..0x821AEFFC)
	// 821AEFF4: 7C4A5C2E  lfsx f2, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AEFF8: 48000018  b 0x821af010
	pc = 0x821AF010; continue 'dispatch;
            }
            0x821AEFFC => {
    //   block [0x821AEFFC..0x821AF010)
	// 821AEFFC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF000: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821AF004: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AF008: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821AF00C: 419A004C  beq cr6, 0x821af058
	if ctx.cr[6].eq {
	pc = 0x821AF058; continue 'dispatch;
	}
	pc = 0x821AF010; continue 'dispatch;
            }
            0x821AF010 => {
    //   block [0x821AF010..0x821AF040)
	// 821AF010: 7F2B0734  extsh r11, r25
	ctx.r[11].s64 = ctx.r[25].s16 as i64;
	// 821AF014: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821AF018: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF01C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821AF020: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AF024: 394A1420  addi r10, r10, 0x1420
	ctx.r[10].s64 = ctx.r[10].s64 + 5152;
	// 821AF028: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF02C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF030: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821AF034: 396A00C0  addi r11, r10, 0xc0
	ctx.r[11].s64 = ctx.r[10].s64 + 192;
	// 821AF038: 419A0008  beq cr6, 0x821af040
	if ctx.cr[6].eq {
	pc = 0x821AF040; continue 'dispatch;
	}
	// 821AF03C: 396A0018  addi r11, r10, 0x18
	ctx.r[11].s64 = ctx.r[10].s64 + 24;
	pc = 0x821AF040; continue 'dispatch;
            }
            0x821AF040 => {
    //   block [0x821AF040..0x821AF058)
	// 821AF040: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821AF044: 917F00A0  stw r11, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821AF048: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF04C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821AF050: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 821AF054: 4BFFFAA5  bl 0x821aeaf8
	ctx.lr = 0x821AF058;
	sub_821AEAF8(ctx, base);
	pc = 0x821AF058; continue 'dispatch;
            }
            0x821AF058 => {
    //   block [0x821AF058..0x821AF064)
	// 821AF058: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821AF05C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821AF060: 48386094  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AF068 size=544
    let mut pc: u32 = 0x821AF068;
    'dispatch: loop {
        match pc {
            0x821AF068 => {
    //   block [0x821AF068..0x821AF0D8)
	// 821AF068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821AF070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821AF074: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF078: 81630124  lwz r11, 0x124(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AF07C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821AF080: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821AF084: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 821AF088: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AF08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF090: 419A004C  beq cr6, 0x821af0dc
	if ctx.cr[6].eq {
	pc = 0x821AF0DC; continue 'dispatch;
	}
	// 821AF094: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF098: 80830120  lwz r4, 0x120(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AF09C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821AF0A0: 409A003C  bne cr6, 0x821af0dc
	if !ctx.cr[6].eq {
	pc = 0x821AF0DC; continue 'dispatch;
	}
	// 821AF0A4: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF0A8: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF0AC: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF0B0: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF0B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF0B8: 419A0020  beq cr6, 0x821af0d8
	if ctx.cr[6].eq {
	pc = 0x821AF0D8; continue 'dispatch;
	}
	// 821AF0BC: 808A0030  lwz r4, 0x30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF0C0: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF0C4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF0C8: 409A0010  bne cr6, 0x821af0d8
	if !ctx.cr[6].eq {
	pc = 0x821AF0D8; continue 'dispatch;
	}
	// 821AF0CC: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF0D0: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF0D4: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF0D8; continue 'dispatch;
            }
            0x821AF0D8 => {
    //   block [0x821AF0D8..0x821AF0DC)
	// 821AF0D8: F9030120  std r8, 0x120(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[8].u64 ) };
	pc = 0x821AF0DC; continue 'dispatch;
            }
            0x821AF0DC => {
    //   block [0x821AF0DC..0x821AF12C)
	// 821AF0DC: 8163012C  lwz r11, 0x12c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AF0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF0E4: 419A004C  beq cr6, 0x821af130
	if ctx.cr[6].eq {
	pc = 0x821AF130; continue 'dispatch;
	}
	// 821AF0E8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF0EC: 80830128  lwz r4, 0x128(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AF0F0: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821AF0F4: 409A003C  bne cr6, 0x821af130
	if !ctx.cr[6].eq {
	pc = 0x821AF130; continue 'dispatch;
	}
	// 821AF0F8: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF0FC: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF100: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF104: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF10C: 419A0020  beq cr6, 0x821af12c
	if ctx.cr[6].eq {
	pc = 0x821AF12C; continue 'dispatch;
	}
	// 821AF110: 808A0030  lwz r4, 0x30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF114: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF118: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF11C: 409A0010  bne cr6, 0x821af12c
	if !ctx.cr[6].eq {
	pc = 0x821AF12C; continue 'dispatch;
	}
	// 821AF120: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF124: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF128: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF12C; continue 'dispatch;
            }
            0x821AF12C => {
    //   block [0x821AF12C..0x821AF130)
	// 821AF12C: F9030128  std r8, 0x128(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[8].u64 ) };
	pc = 0x821AF130; continue 'dispatch;
            }
            0x821AF130 => {
    //   block [0x821AF130..0x821AF160)
	// 821AF130: 552B0420  rlwinm r11, r9, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF134: 80830080  lwz r4, 0x80(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AF138: D023008C  stfs f1, 0x8c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AF13C: 91030098  stw r8, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[8].u32 ) };
	// 821AF140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF144: D0230088  stfs f1, 0x88(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821AF148: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF14C: C00B294C  lfs f0, 0x294c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF150: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821AF154: 419A000C  beq cr6, 0x821af160
	if ctx.cr[6].eq {
	pc = 0x821AF160; continue 'dispatch;
	}
	// 821AF158: 60A50008  ori r5, r5, 8
	ctx.r[5].u64 = ctx.r[5].u64 | 8;
	// 821AF15C: 5529047E  clrlwi r9, r9, 0x11
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	pc = 0x821AF160; continue 'dispatch;
            }
            0x821AF160 => {
    //   block [0x821AF160..0x821AF1B8)
	// 821AF160: 7D2B0734  extsh r11, r9
	ctx.r[11].s64 = ctx.r[9].s16 as i64;
	// 821AF164: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821AF168: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AF16C: 2F0B7FFF  cmpwi cr6, r11, 0x7fff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32767, &mut ctx.xer);
	// 821AF170: C189BA38  lfs f12, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AF174: C16A1FF8  lfs f11, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF178: 409A009C  bne cr6, 0x821af214
	if !ctx.cr[6].eq {
	pc = 0x821AF214; continue 'dispatch;
	}
	// 821AF17C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821AF180: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821AF184: 616BE2D4  ori r11, r11, 0xe2d4
	ctx.r[11].u64 = ctx.r[11].u64 | 58068;
	// 821AF188: 614AFAF0  ori r10, r10, 0xfaf0
	ctx.r[10].u64 = ctx.r[10].u64 | 64240;
	// 821AF18C: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821AF190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF194: 419A0024  beq cr6, 0x821af1b8
	if ctx.cr[6].eq {
	pc = 0x821AF1B8; continue 'dispatch;
	}
	// 821AF198: A16B0038  lhz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821AF19C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF1A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AF1A4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AF1A8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AF1AC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AF1B0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821AF1B4: 40980018  bge cr6, 0x821af1cc
	if !ctx.cr[6].lt {
	pc = 0x821AF1CC; continue 'dispatch;
	}
	pc = 0x821AF1B8; continue 'dispatch;
            }
            0x821AF1B8 => {
    //   block [0x821AF1B8..0x821AF1CC)
	// 821AF1B8: 7D64502E  lwzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AF1BC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF1C0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF1C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF1C8: 48000060  b 0x821af228
	pc = 0x821AF228; continue 'dispatch;
            }
            0x821AF1CC => {
    //   block [0x821AF1CC..0x821AF1F8)
	// 821AF1CC: A16300AA  lhz r11, 0xaa(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AF1D0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF1D4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821AF1D8: 419A0020  beq cr6, 0x821af1f8
	if ctx.cr[6].eq {
	pc = 0x821AF1F8; continue 'dispatch;
	}
	// 821AF1DC: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 821AF1E0: 419A0018  beq cr6, 0x821af1f8
	if ctx.cr[6].eq {
	pc = 0x821AF1F8; continue 'dispatch;
	}
	// 821AF1E4: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 821AF1E8: 7D64502E  lwzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AF1EC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF1F0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF1F4: 48000034  b 0x821af228
	pc = 0x821AF228; continue 'dispatch;
            }
            0x821AF1F8 => {
    //   block [0x821AF1F8..0x821AF214)
	// 821AF1F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF1FC: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF200: 7D64502E  lwzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821AF204: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AF208: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF20C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF210: 48000018  b 0x821af228
	pc = 0x821AF228; continue 'dispatch;
            }
            0x821AF214 => {
    //   block [0x821AF214..0x821AF228)
	// 821AF214: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821AF218: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821AF21C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821AF220: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AF224: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x821AF228; continue 'dispatch;
            }
            0x821AF228 => {
    //   block [0x821AF228..0x821AF238)
	// 821AF228: D1830090  stfs f12, 0x90(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821AF22C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821AF230: 41990008  bgt cr6, 0x821af238
	if ctx.cr[6].gt {
	pc = 0x821AF238; continue 'dispatch;
	}
	// 821AF234: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x821AF238; continue 'dispatch;
            }
            0x821AF238 => {
    //   block [0x821AF238..0x821AF250)
	// 821AF238: 7FEB0734  extsh r11, r31
	ctx.r[11].s64 = ctx.r[31].s16 as i64;
	// 821AF23C: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821AF240: 90A300B0  stw r5, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[5].u32 ) };
	// 821AF244: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821AF248: 41990008  bgt cr6, 0x821af250
	if ctx.cr[6].gt {
	pc = 0x821AF250; continue 'dispatch;
	}
	// 821AF24C: 3BE0000A  li r31, 0xa
	ctx.r[31].s64 = 10;
	pc = 0x821AF250; continue 'dispatch;
            }
            0x821AF250 => {
    //   block [0x821AF250..0x821AF260)
	// 821AF250: 7FEB0734  extsh r11, r31
	ctx.r[11].s64 = ctx.r[31].s16 as i64;
	// 821AF254: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 821AF258: 40990008  ble cr6, 0x821af260
	if !ctx.cr[6].gt {
	pc = 0x821AF260; continue 'dispatch;
	}
	// 821AF25C: 3BE0000E  li r31, 0xe
	ctx.r[31].s64 = 14;
	pc = 0x821AF260; continue 'dispatch;
            }
            0x821AF260 => {
    //   block [0x821AF260..0x821AF288)
	// 821AF260: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821AF264: B3E300A6  sth r31, 0xa6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(166 as u32), ctx.r[31].u16 ) };
	// 821AF268: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 821AF26C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821AF270: 4BFFF9F1  bl 0x821aec60
	ctx.lr = 0x821AF274;
	sub_821AEC60(ctx, base);
	// 821AF274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821AF278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821AF27C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821AF280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821AF284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AF288 size=280
    let mut pc: u32 = 0x821AF288;
    'dispatch: loop {
        match pc {
            0x821AF288 => {
    //   block [0x821AF288..0x821AF2AC)
	// 821AF288: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF28C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821AF290: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 821AF294: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 821AF298: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF29C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821AF2A0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AF2A4: 40990058  ble cr6, 0x821af2fc
	if !ctx.cr[6].gt {
	pc = 0x821AF2FC; continue 'dispatch;
	}
	// 821AF2A8: 3924FFFF  addi r9, r4, -1
	ctx.r[9].s64 = ctx.r[4].s64 + -1;
	pc = 0x821AF2AC; continue 'dispatch;
            }
            0x821AF2AC => {
    //   block [0x821AF2AC..0x821AF2FC)
	// 821AF2AC: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF2B0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821AF2B4: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF2B8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF2BC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AF2C0: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AF2C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF2C8: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821AF2CC: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF2D0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AF2D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF2D8: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821AF2DC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF2E0: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AF2E4: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AF2E8: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 821AF2EC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AF2F0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AF2F4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF2F8: 409AFFB4  bne cr6, 0x821af2ac
	if !ctx.cr[6].eq {
	pc = 0x821AF2AC; continue 'dispatch;
	}
	pc = 0x821AF2FC; continue 'dispatch;
            }
            0x821AF2FC => {
    //   block [0x821AF2FC..0x821AF330)
	// 821AF2FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF300: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 821AF304: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF308: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821AF30C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF310: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821AF314: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AF318: 41980058  blt cr6, 0x821af370
	if ctx.cr[6].lt {
	pc = 0x821AF370; continue 'dispatch;
	}
	// 821AF31C: 3944FFFB  addi r10, r4, -5
	ctx.r[10].s64 = ctx.r[4].s64 + -5;
	// 821AF320: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF324: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821AF328: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821AF32C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	pc = 0x821AF330; continue 'dispatch;
            }
            0x821AF330 => {
    //   block [0x821AF330..0x821AF370)
	// 821AF330: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF334: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AF338: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AF33C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF340: C16B002C  lfs f11, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AF344: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF348: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AF34C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF350: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF354: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821AF358: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821AF35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF360: D16B002C  stfs f11, 0x2c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821AF364: D14B003C  stfs f10, 0x3c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821AF368: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821AF36C: 409AFFC4  bne cr6, 0x821af330
	if !ctx.cr[6].eq {
	pc = 0x821AF330; continue 'dispatch;
	}
	pc = 0x821AF370; continue 'dispatch;
            }
            0x821AF370 => {
    //   block [0x821AF370..0x821AF380)
	// 821AF370: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821AF374: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 821AF378: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821AF37C: 7D492050  subf r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	pc = 0x821AF380; continue 'dispatch;
            }
            0x821AF380 => {
    //   block [0x821AF380..0x821AF3A0)
	// 821AF380: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF384: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821AF388: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821AF38C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AF390: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF398: 409AFFE8  bne cr6, 0x821af380
	if !ctx.cr[6].eq {
	pc = 0x821AF380; continue 'dispatch;
	}
	// 821AF39C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AF3A0 size=1444
    let mut pc: u32 = 0x821AF3A0;
    'dispatch: loop {
        match pc {
            0x821AF3A0 => {
    //   block [0x821AF3A0..0x821AF438)
	// 821AF3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AF3A4: 48385CE9  bl 0x8253508c
	ctx.lr = 0x821AF3A8;
	sub_82535080(ctx, base);
	// 821AF3A8: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821AF3AC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AF3B0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AF3B4: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 821AF3B8: 83CBFAC0  lwz r30, -0x540(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AF3BC: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821AF3C0: 923E0040  stw r17, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[17].u32 ) };
	// 821AF3C4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF3C8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821AF3CC: 419A0558  beq cr6, 0x821af924
	if ctx.cr[6].eq {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF3D0: 825E0080  lwz r18, 0x80(r30)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AF3D4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AF3D8: 82BE00B0  lwz r21, 0xb0(r30)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821AF3DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF3E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821AF3E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821AF3E8: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821AF3EC: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 821AF3F0: 4BFFF871  bl 0x821aec60
	ctx.lr = 0x821AF3F4;
	sub_821AEC60(ctx, base);
	// 821AF3F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AF3F8: 82FE0010  lwz r23, 0x10(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821AF3FC: C01E0084  lfs f0, 0x84(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF400: A15E00A8  lhz r10, 0xa8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 821AF404: 7D5A0734  extsh r26, r10
	ctx.r[26].s64 = ctx.r[10].s16 as i64;
	// 821AF408: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AF40C: A17700C2  lhz r11, 0xc2(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(194 as u32) ) } as u64;
	// 821AF410: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AF414: B17E00A4  sth r11, 0xa4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[11].u16 ) };
	// 821AF418: 4099002C  ble cr6, 0x821af444
	if !ctx.cr[6].gt {
	pc = 0x821AF444; continue 'dispatch;
	}
	// 821AF41C: A17E00A6  lhz r11, 0xa6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(166 as u32) ) } as u64;
	// 821AF420: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF424: 7D7A5850  subf r11, r26, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 821AF428: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821AF42C: 4099000C  ble cr6, 0x821af438
	if !ctx.cr[6].gt {
	pc = 0x821AF438; continue 'dispatch;
	}
	// 821AF430: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 821AF434: 4800000C  b 0x821af440
	pc = 0x821AF440; continue 'dispatch;
            }
            0x821AF438 => {
    //   block [0x821AF438..0x821AF440)
	// 821AF438: 4098000C  bge cr6, 0x821af444
	if !ctx.cr[6].lt {
	pc = 0x821AF444; continue 'dispatch;
	}
	// 821AF43C: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	pc = 0x821AF440; continue 'dispatch;
            }
            0x821AF440 => {
    //   block [0x821AF440..0x821AF444)
	// 821AF440: B35E00A8  sth r26, 0xa8(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[26].u16 ) };
	pc = 0x821AF444; continue 'dispatch;
            }
            0x821AF444 => {
    //   block [0x821AF444..0x821AF4F0)
	// 821AF444: A17E00A4  lhz r11, 0xa4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821AF448: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 821AF44C: 837E0114  lwz r27, 0x114(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 821AF450: 7D790734  extsh r25, r11
	ctx.r[25].s64 = ctx.r[11].s16 as i64;
	// 821AF454: 829E009C  lwz r20, 0x9c(r30)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821AF458: 3D600504  lis r11, 0x504
	ctx.r[11].s64 = 84148224;
	// 821AF45C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821AF460: 61784000  ori r24, r11, 0x4000
	ctx.r[24].u64 = ctx.r[11].u64 | 16384;
	// 821AF464: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821AF468: 3BEB20C0  addi r31, r11, 0x20c0
	ctx.r[31].s64 = ctx.r[11].s64 + 8384;
	// 821AF46C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821AF470: 3ACBC470  addi r22, r11, -0x3b90
	ctx.r[22].s64 = ctx.r[11].s64 + -15248;
	// 821AF474: 419A01C0  beq cr6, 0x821af634
	if ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF478: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF47C: 815E0110  lwz r10, 0x110(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 821AF480: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF484: 409A01B0  bne cr6, 0x821af634
	if !ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF488: 2F1A0003  cmpwi cr6, r26, 3
	ctx.cr[6].compare_i32(ctx.r[26].s32, 3, &mut ctx.xer);
	// 821AF48C: 41980110  blt cr6, 0x821af59c
	if ctx.cr[6].lt {
	pc = 0x821AF59C; continue 'dispatch;
	}
	// 821AF490: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF494: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 821AF498: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF49C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF4A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF4A4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AF4A8: 386B18C0  addi r3, r11, 0x18c0
	ctx.r[3].s64 = ctx.r[11].s64 + 6336;
	// 821AF4AC: 4BFFF10D  bl 0x821ae5b8
	ctx.lr = 0x821AF4B0;
	sub_821AE5B8(ctx, base);
	// 821AF4B0: 56BD07FE  clrlwi r29, r21, 0x1f
	ctx.r[29].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	// 821AF4B4: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF4B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AF4BC: 388B18C0  addi r4, r11, 0x18c0
	ctx.r[4].s64 = ctx.r[11].s64 + 6336;
	// 821AF4C0: 419A0030  beq cr6, 0x821af4f0
	if ctx.cr[6].eq {
	pc = 0x821AF4F0; continue 'dispatch;
	}
	// 821AF4C4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AF4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AF4CC: 4BFFC475  bl 0x821ab940
	ctx.lr = 0x821AF4D0;
	sub_821AB940(ctx, base);
	// 821AF4D0: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF4D4: 387F2720  addi r3, r31, 0x2720
	ctx.r[3].s64 = ctx.r[31].s64 + 10016;
	// 821AF4D8: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AF4DC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF4E0: 38AB18C0  addi r5, r11, 0x18c0
	ctx.r[5].s64 = ctx.r[11].s64 + 6336;
	// 821AF4E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AF4E8: 4BFFCB71  bl 0x821ac058
	ctx.lr = 0x821AF4EC;
	sub_821AC058(ctx, base);
	// 821AF4EC: 48000018  b 0x821af504
	pc = 0x821AF504; continue 'dispatch;
            }
            0x821AF4F0 => {
    //   block [0x821AF4F0..0x821AF504)
	// 821AF4F0: 387F2720  addi r3, r31, 0x2720
	ctx.r[3].s64 = ctx.r[31].s64 + 10016;
	// 821AF4F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF4F8: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821AF4FC: 38BAFFFF  addi r5, r26, -1
	ctx.r[5].s64 = ctx.r[26].s64 + -1;
	// 821AF500: 4BFED431  bl 0x8219c930
	ctx.lr = 0x821AF504;
	sub_8219C930(ctx, base);
	pc = 0x821AF504; continue 'dispatch;
            }
            0x821AF504 => {
    //   block [0x821AF504..0x821AF564)
	// 821AF504: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF508: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821AF50C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 821AF510: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF514: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF518: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AF51C: 386B18C0  addi r3, r11, 0x18c0
	ctx.r[3].s64 = ctx.r[11].s64 + 6336;
	// 821AF520: 4BFFF159  bl 0x821ae678
	ctx.lr = 0x821AF524;
	sub_821AE678(ctx, base);
	// 821AF524: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AF528: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF52C: 419A0038  beq cr6, 0x821af564
	if ctx.cr[6].eq {
	pc = 0x821AF564; continue 'dispatch;
	}
	// 821AF530: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AF534: 388B18C0  addi r4, r11, 0x18c0
	ctx.r[4].s64 = ctx.r[11].s64 + 6336;
	// 821AF538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AF53C: 4BFFC405  bl 0x821ab940
	ctx.lr = 0x821AF540;
	sub_821AB940(ctx, base);
	// 821AF540: 395F2720  addi r10, r31, 0x2720
	ctx.r[10].s64 = ctx.r[31].s64 + 10016;
	// 821AF544: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF548: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AF54C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF550: 38AA18C0  addi r5, r10, 0x18c0
	ctx.r[5].s64 = ctx.r[10].s64 + 6336;
	// 821AF554: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AF558: 386B0C60  addi r3, r11, 0xc60
	ctx.r[3].s64 = ctx.r[11].s64 + 3168;
	// 821AF55C: 4BFFCAFD  bl 0x821ac058
	ctx.lr = 0x821AF560;
	sub_821AC058(ctx, base);
	// 821AF560: 48000020  b 0x821af580
	pc = 0x821AF580; continue 'dispatch;
            }
            0x821AF564 => {
    //   block [0x821AF564..0x821AF580)
	// 821AF564: 395F2720  addi r10, r31, 0x2720
	ctx.r[10].s64 = ctx.r[31].s64 + 10016;
	// 821AF568: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF56C: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821AF570: 38BAFFFF  addi r5, r26, -1
	ctx.r[5].s64 = ctx.r[26].s64 + -1;
	// 821AF574: 388A18C0  addi r4, r10, 0x18c0
	ctx.r[4].s64 = ctx.r[10].s64 + 6336;
	// 821AF578: 386B0C60  addi r3, r11, 0xc60
	ctx.r[3].s64 = ctx.r[11].s64 + 3168;
	// 821AF57C: 4BFED3B5  bl 0x8219c930
	ctx.lr = 0x821AF580;
	sub_8219C930(ctx, base);
	pc = 0x821AF580; continue 'dispatch;
            }
            0x821AF580 => {
    //   block [0x821AF580..0x821AF59C)
	// 821AF580: 387F2720  addi r3, r31, 0x2720
	ctx.r[3].s64 = ctx.r[31].s64 + 10016;
	// 821AF584: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821AF588: 4BFFFD01  bl 0x821af288
	ctx.lr = 0x821AF58C;
	sub_821AF288(ctx, base);
	// 821AF58C: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF590: 386B0C60  addi r3, r11, 0xc60
	ctx.r[3].s64 = ctx.r[11].s64 + 3168;
	// 821AF594: 4BFFFCF5  bl 0x821af288
	ctx.lr = 0x821AF598;
	sub_821AF288(ctx, base);
	// 821AF598: 48000008  b 0x821af5a0
	pc = 0x821AF5A0; continue 'dispatch;
            }
            0x821AF59C => {
    //   block [0x821AF59C..0x821AF5A0)
	// 821AF59C: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	pc = 0x821AF5A0; continue 'dispatch;
            }
            0x821AF5A0 => {
    //   block [0x821AF5A0..0x821AF5E8)
	// 821AF5A0: C01E0090  lfs f0, 0x90(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF5A4: 83BE0098  lwz r29, 0x98(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AF5A8: C1BE008C  lfs f13, 0x8c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF5AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821AF5B0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF5B4: B39E00AC  sth r28, 0xac(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[28].u16 ) };
	// 821AF5B8: 419A0030  beq cr6, 0x821af5e8
	if ctx.cr[6].eq {
	pc = 0x821AF5E8; continue 'dispatch;
	}
	// 821AF5BC: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF5C0: 807B00CC  lwz r3, 0xcc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AF5C4: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF5C8: 389F2720  addi r4, r31, 0x2720
	ctx.r[4].s64 = ctx.r[31].s64 + 10016;
	// 821AF5CC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821AF5D0: 38FE00C0  addi r7, r30, 0xc0
	ctx.r[7].s64 = ctx.r[30].s64 + 192;
	// 821AF5D4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821AF5D8: 915B00C4  stw r10, 0xc4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 821AF5DC: 38AB0C60  addi r5, r11, 0xc60
	ctx.r[5].s64 = ctx.r[11].s64 + 3168;
	// 821AF5E0: 4BFFE4B9  bl 0x821ada98
	ctx.lr = 0x821AF5E4;
	sub_821ADA98(ctx, base);
	// 821AF5E4: 48000008  b 0x821af5ec
	pc = 0x821AF5EC; continue 'dispatch;
            }
            0x821AF5E8 => {
    //   block [0x821AF5E8..0x821AF5EC)
	// 821AF5E8: 923B00C4  stw r17, 0xc4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(196 as u32), ctx.r[17].u32 ) };
	pc = 0x821AF5EC; continue 'dispatch;
            }
            0x821AF5EC => {
    //   block [0x821AF5EC..0x821AF634)
	// 821AF5EC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 821AF5F0: 419A0044  beq cr6, 0x821af634
	if ctx.cr[6].eq {
	pc = 0x821AF634; continue 'dispatch;
	}
	// 821AF5F4: A1740004  lhz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF5F8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821AF5FC: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 821AF600: 917B0090  stw r11, 0x90(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821AF604: A1740004  lhz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF608: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821AF60C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF610: 7D6B3670  srawi r11, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 821AF614: 794906A0  clrldi r9, r10, 0x3a
	ctx.r[9].u64 = ctx.r[10].u64 & 0x000000000000003Fu64;
	// 821AF618: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF61C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF620: 81760024  lwz r11, 0x24(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF624: 7D0A582A  ldx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821AF628: 7E694836  sld r9, r19, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[19].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821AF62C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AF630: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	pc = 0x821AF634; continue 'dispatch;
            }
            0x821AF634 => {
    //   block [0x821AF634..0x821AF66C)
	// 821AF634: 83BE011C  lwz r29, 0x11c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) } as u64;
	// 821AF638: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821AF63C: 419A017C  beq cr6, 0x821af7b8
	if ctx.cr[6].eq {
	pc = 0x821AF7B8; continue 'dispatch;
	}
	// 821AF640: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF644: 815E0118  lwz r10, 0x118(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF648: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF64C: 409A016C  bne cr6, 0x821af7b8
	if !ctx.cr[6].eq {
	pc = 0x821AF7B8; continue 'dispatch;
	}
	// 821AF650: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821AF654: 816A44F0  lwz r11, 0x44f0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17648 as u32) ) } as u64;
	// 821AF658: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821AF65C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF660: 409A000C  bne cr6, 0x821af66c
	if !ctx.cr[6].eq {
	pc = 0x821AF66C; continue 'dispatch;
	}
	// 821AF664: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821AF668: 916A44F0  stw r11, 0x44f0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17648 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF66C; continue 'dispatch;
            }
            0x821AF66C => {
    //   block [0x821AF66C..0x821AF6B4)
	// 821AF66C: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 821AF670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF674: 419A0040  beq cr6, 0x821af6b4
	if ctx.cr[6].eq {
	pc = 0x821AF6B4; continue 'dispatch;
	}
	// 821AF678: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF67C: 815E0110  lwz r10, 0x110(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) } as u64;
	// 821AF680: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF684: 409A0030  bne cr6, 0x821af6b4
	if !ctx.cr[6].eq {
	pc = 0x821AF6B4; continue 'dispatch;
	}
	// 821AF688: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821AF68C: 38C000C0  li r6, 0xc0
	ctx.r[6].s64 = 192;
	// 821AF690: 386B44B0  addi r3, r11, 0x44b0
	ctx.r[3].s64 = ctx.r[11].s64 + 17584;
	// 821AF694: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AF698: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821AF69C: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821AF6A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821AF6A4: C04BBA38  lfs f2, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821AF6A8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821AF6AC: 4BFFF44D  bl 0x821aeaf8
	ctx.lr = 0x821AF6B0;
	sub_821AEAF8(ctx, base);
	// 821AF6B0: 48000008  b 0x821af6b8
	pc = 0x821AF6B8; continue 'dispatch;
            }
            0x821AF6B4 => {
    //   block [0x821AF6B4..0x821AF6B8)
	// 821AF6B4: 3B7E00C0  addi r27, r30, 0xc0
	ctx.r[27].s64 = ctx.r[30].s64 + 192;
	pc = 0x821AF6B8; continue 'dispatch;
            }
            0x821AF6B8 => {
    //   block [0x821AF6B8..0x821AF724)
	// 821AF6B8: 2F1A0003  cmpwi cr6, r26, 3
	ctx.cr[6].compare_i32(ctx.r[26].s32, 3, &mut ctx.xer);
	// 821AF6BC: 4198008C  blt cr6, 0x821af748
	if ctx.cr[6].lt {
	pc = 0x821AF748; continue 'dispatch;
	}
	// 821AF6C0: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF6C4: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 821AF6C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF6CC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF6D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821AF6D4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821AF6D8: 386B18C0  addi r3, r11, 0x18c0
	ctx.r[3].s64 = ctx.r[11].s64 + 6336;
	// 821AF6DC: 4BFFEEDD  bl 0x821ae5b8
	ctx.lr = 0x821AF6E0;
	sub_821AE5B8(ctx, base);
	// 821AF6E0: 56AB07FE  clrlwi r11, r21, 0x1f
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	// 821AF6E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF6E8: 419A003C  beq cr6, 0x821af724
	if ctx.cr[6].eq {
	pc = 0x821AF724; continue 'dispatch;
	}
	// 821AF6EC: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF6F0: 839D00CC  lwz r28, 0xcc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AF6F4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821AF6F8: 388B18C0  addi r4, r11, 0x18c0
	ctx.r[4].s64 = ctx.r[11].s64 + 6336;
	// 821AF6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AF700: 4BFFC241  bl 0x821ab940
	ctx.lr = 0x821AF704;
	sub_821AB940(ctx, base);
	// 821AF704: 397F2720  addi r11, r31, 0x2720
	ctx.r[11].s64 = ctx.r[31].s64 + 10016;
	// 821AF708: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821AF70C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821AF710: 38AB18C0  addi r5, r11, 0x18c0
	ctx.r[5].s64 = ctx.r[11].s64 + 6336;
	// 821AF714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821AF718: 387C4A40  addi r3, r28, 0x4a40
	ctx.r[3].s64 = ctx.r[28].s64 + 19008;
	// 821AF71C: 4BFFC93D  bl 0x821ac058
	ctx.lr = 0x821AF720;
	sub_821AC058(ctx, base);
	// 821AF720: 4800002C  b 0x821af74c
	pc = 0x821AF74C; continue 'dispatch;
            }
            0x821AF724 => {
    //   block [0x821AF724..0x821AF748)
	// 821AF724: 817D00CC  lwz r11, 0xcc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 821AF728: 395F2720  addi r10, r31, 0x2720
	ctx.r[10].s64 = ctx.r[31].s64 + 10016;
	// 821AF72C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821AF730: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821AF734: 38BAFFFF  addi r5, r26, -1
	ctx.r[5].s64 = ctx.r[26].s64 + -1;
	// 821AF738: 388A18C0  addi r4, r10, 0x18c0
	ctx.r[4].s64 = ctx.r[10].s64 + 6336;
	// 821AF73C: 386B4A40  addi r3, r11, 0x4a40
	ctx.r[3].s64 = ctx.r[11].s64 + 19008;
	// 821AF740: 4BFED1F1  bl 0x8219c930
	ctx.lr = 0x821AF744;
	sub_8219C930(ctx, base);
	// 821AF744: 48000008  b 0x821af74c
	pc = 0x821AF74C; continue 'dispatch;
            }
            0x821AF748 => {
    //   block [0x821AF748..0x821AF74C)
	// 821AF748: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	pc = 0x821AF74C; continue 'dispatch;
            }
            0x821AF74C => {
    //   block [0x821AF74C..0x821AF7B8)
	// 821AF74C: C01E0090  lfs f0, 0x90(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF750: 817E00A0  lwz r11, 0xa0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF754: C1BE008C  lfs f13, 0x8c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF758: 815E0098  lwz r10, 0x98(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AF75C: B07E00AC  sth r3, 0xac(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[3].u16 ) };
	// 821AF760: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AF764: D01D00DC  stfs f0, 0xdc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 821AF768: 907D00D0  stw r3, 0xd0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(208 as u32), ctx.r[3].u32 ) };
	// 821AF76C: 937D00D4  stw r27, 0xd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(212 as u32), ctx.r[27].u32 ) };
	// 821AF770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF774: 419A0044  beq cr6, 0x821af7b8
	if ctx.cr[6].eq {
	pc = 0x821AF7B8; continue 'dispatch;
	}
	// 821AF778: A12B0004  lhz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF77C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821AF780: 7D29C214  add r9, r9, r24
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[24].u64;
	// 821AF784: 913D0090  stw r9, 0x90(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 821AF788: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF78C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF790: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821AF794: 7D6B3670  srawi r11, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 821AF798: 794906A0  clrldi r9, r10, 0x3a
	ctx.r[9].u64 = ctx.r[10].u64 & 0x000000000000003Fu64;
	// 821AF79C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821AF7A0: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF7A4: 81760024  lwz r11, 0x24(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 821AF7A8: 7D0A582A  ldx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821AF7AC: 7E694836  sld r9, r19, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[19].u64) << ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821AF7B0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821AF7B4: 7D2A592A  stdx r9, r10, r11
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u64) };
	pc = 0x821AF7B8; continue 'dispatch;
            }
            0x821AF7B8 => {
    //   block [0x821AF7B8..0x821AF7E4)
	// 821AF7B8: 56AB06F6  rlwinm r11, r21, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF7BC: C01E0084  lfs f0, 0x84(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF7C4: 409A0020  bne cr6, 0x821af7e4
	if !ctx.cr[6].eq {
	pc = 0x821AF7E4; continue 'dispatch;
	}
	// 821AF7C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821AF7CC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821AF7D0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821AF7D4: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821AF7D8: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF7DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AF7E0: D01E0084  stfs f0, 0x84(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x821AF7E4; continue 'dispatch;
            }
            0x821AF7E4 => {
    //   block [0x821AF7E4..0x821AF804)
	// 821AF7E4: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 821AF7E8: 419A0020  beq cr6, 0x821af808
	if ctx.cr[6].eq {
	pc = 0x821AF808; continue 'dispatch;
	}
	// 821AF7EC: 817E0098  lwz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821AF7F0: A1540012  lhz r10, 0x12(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[20].u32.wrapping_add(18 as u32) ) } as u64;
	// 821AF7F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821AF7F8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821AF7FC: 41980008  blt cr6, 0x821af804
	if ctx.cr[6].lt {
	pc = 0x821AF804; continue 'dispatch;
	}
	// 821AF800: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821AF804; continue 'dispatch;
            }
            0x821AF804 => {
    //   block [0x821AF804..0x821AF808)
	// 821AF804: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF808; continue 'dispatch;
            }
            0x821AF808 => {
    //   block [0x821AF808..0x821AF84C)
	// 821AF808: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AF80C: 41990118  bgt cr6, 0x821af924
	if ctx.cr[6].gt {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF810: A17E00AA  lhz r11, 0xaa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AF814: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF818: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821AF81C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821AF820: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF824: 7D6B9214  add r11, r11, r18
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 821AF828: 3D4B0006  addis r10, r11, 6
	ctx.r[10].s64 = ctx.r[11].s64 + 393216;
	// 821AF82C: 394AA580  addi r10, r10, -0x5a80
	ctx.r[10].s64 = ctx.r[10].s64 + -23168;
	// 821AF830: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF838: 419A0014  beq cr6, 0x821af84c
	if ctx.cr[6].eq {
	pc = 0x821AF84C; continue 'dispatch;
	}
	// 821AF83C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF840: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF844: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821AF848: 419A0008  beq cr6, 0x821af850
	if ctx.cr[6].eq {
	pc = 0x821AF850; continue 'dispatch;
	}
	pc = 0x821AF84C; continue 'dispatch;
            }
            0x821AF84C => {
    //   block [0x821AF84C..0x821AF850)
	// 821AF84C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x821AF850; continue 'dispatch;
            }
            0x821AF850 => {
    //   block [0x821AF850..0x821AF85C)
	// 821AF850: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821AF854: 409A0008  bne cr6, 0x821af85c
	if !ctx.cr[6].eq {
	pc = 0x821AF85C; continue 'dispatch;
	}
	// 821AF858: FA2A0000  std r17, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[17].u64 ) };
	pc = 0x821AF85C; continue 'dispatch;
            }
            0x821AF85C => {
    //   block [0x821AF85C..0x821AF8CC)
	// 821AF85C: C01E0094  lfs f0, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AF860: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821AF864: C1BE0090  lfs f13, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AF868: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821AF86C: 409900C8  ble cr6, 0x821af934
	if !ctx.cr[6].gt {
	pc = 0x821AF934; continue 'dispatch;
	}
	// 821AF870: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821AF874: 409900C0  ble cr6, 0x821af934
	if !ctx.cr[6].gt {
	pc = 0x821AF934; continue 'dispatch;
	}
	// 821AF878: D01E0090  stfs f0, 0x90(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821AF87C: 817E0124  lwz r11, 0x124(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AF880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF884: 419A004C  beq cr6, 0x821af8d0
	if ctx.cr[6].eq {
	pc = 0x821AF8D0; continue 'dispatch;
	}
	// 821AF888: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF88C: 813E0120  lwz r9, 0x120(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AF890: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AF894: 409A003C  bne cr6, 0x821af8d0
	if !ctx.cr[6].eq {
	pc = 0x821AF8D0; continue 'dispatch;
	}
	// 821AF898: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF89C: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF8A0: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF8A4: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF8A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF8AC: 419A0020  beq cr6, 0x821af8cc
	if ctx.cr[6].eq {
	pc = 0x821AF8CC; continue 'dispatch;
	}
	// 821AF8B0: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF8B4: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF8B8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF8BC: 409A0010  bne cr6, 0x821af8cc
	if !ctx.cr[6].eq {
	pc = 0x821AF8CC; continue 'dispatch;
	}
	// 821AF8C0: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF8C4: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF8C8: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF8CC; continue 'dispatch;
            }
            0x821AF8CC => {
    //   block [0x821AF8CC..0x821AF8D0)
	// 821AF8CC: FA3E0120  std r17, 0x120(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), ctx.r[17].u64 ) };
	pc = 0x821AF8D0; continue 'dispatch;
            }
            0x821AF8D0 => {
    //   block [0x821AF8D0..0x821AF920)
	// 821AF8D0: 817E012C  lwz r11, 0x12c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AF8D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF8D8: 419A004C  beq cr6, 0x821af924
	if ctx.cr[6].eq {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF8DC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF8E0: 813E0128  lwz r9, 0x128(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AF8E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821AF8E8: 409A003C  bne cr6, 0x821af924
	if !ctx.cr[6].eq {
	pc = 0x821AF924; continue 'dispatch;
	}
	// 821AF8EC: 814B00A0  lwz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF8F0: 554A0356  rlwinm r10, r10, 0, 0xd, 0xb
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF8F4: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821AF8F8: 814B00BC  lwz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF8FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821AF900: 419A0020  beq cr6, 0x821af920
	if ctx.cr[6].eq {
	pc = 0x821AF920; continue 'dispatch;
	}
	// 821AF904: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF908: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF90C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF910: 409A0010  bne cr6, 0x821af920
	if !ctx.cr[6].eq {
	pc = 0x821AF920; continue 'dispatch;
	}
	// 821AF914: 816A0118  lwz r11, 0x118(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF918: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF91C: 916A0118  stw r11, 0x118(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF920; continue 'dispatch;
            }
            0x821AF920 => {
    //   block [0x821AF920..0x821AF924)
	// 821AF920: FA3E0128  std r17, 0x128(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(296 as u32), ctx.r[17].u64 ) };
	pc = 0x821AF924; continue 'dispatch;
            }
            0x821AF924 => {
    //   block [0x821AF924..0x821AF934)
	// 821AF924: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AF928: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AF92C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AF930: 483857AC  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            0x821AF934 => {
    //   block [0x821AF934..0x821AF944)
	// 821AF934: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821AF938: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821AF93C: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821AF940: 4838579C  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AF948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AF948 size=268
    let mut pc: u32 = 0x821AF948;
    'dispatch: loop {
        match pc {
            0x821AF948 => {
    //   block [0x821AF948..0x821AF994)
	// 821AF948: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821AF94C: 814BFAC0  lwz r10, -0x540(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821AF950: A16A00AA  lhz r11, 0xaa(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(170 as u32) ) } as u64;
	// 821AF954: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821AF958: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821AF95C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821AF960: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821AF964: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821AF968: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821AF96C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821AF970: 3D2B0006  addis r9, r11, 6
	ctx.r[9].s64 = ctx.r[11].s64 + 393216;
	// 821AF974: 3929A580  addi r9, r9, -0x5a80
	ctx.r[9].s64 = ctx.r[9].s64 + -23168;
	// 821AF978: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821AF97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF980: 419A0014  beq cr6, 0x821af994
	if ctx.cr[6].eq {
	pc = 0x821AF994; continue 'dispatch;
	}
	// 821AF984: 80EB0030  lwz r7, 0x30(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF988: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821AF98C: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821AF990: 419A0008  beq cr6, 0x821af998
	if ctx.cr[6].eq {
	pc = 0x821AF998; continue 'dispatch;
	}
	pc = 0x821AF994; continue 'dispatch;
            }
            0x821AF994 => {
    //   block [0x821AF994..0x821AF998)
	// 821AF994: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x821AF998; continue 'dispatch;
            }
            0x821AF998 => {
    //   block [0x821AF998..0x821AF9A4)
	// 821AF998: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821AF99C: 409A0008  bne cr6, 0x821af9a4
	if !ctx.cr[6].eq {
	pc = 0x821AF9A4; continue 'dispatch;
	}
	// 821AF9A0: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	pc = 0x821AF9A4; continue 'dispatch;
            }
            0x821AF9A4 => {
    //   block [0x821AF9A4..0x821AF9F4)
	// 821AF9A4: 816A0124  lwz r11, 0x124(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(292 as u32) ) } as u64;
	// 821AF9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AF9AC: 419A004C  beq cr6, 0x821af9f8
	if ctx.cr[6].eq {
	pc = 0x821AF9F8; continue 'dispatch;
	}
	// 821AF9B0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF9B4: 80EA0120  lwz r7, 0x120(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(288 as u32) ) } as u64;
	// 821AF9B8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AF9BC: 409A003C  bne cr6, 0x821af9f8
	if !ctx.cr[6].eq {
	pc = 0x821AF9F8; continue 'dispatch;
	}
	// 821AF9C0: 812B00A0  lwz r9, 0xa0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AF9C4: 55290356  rlwinm r9, r9, 0, 0xd, 0xb
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF9C8: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821AF9CC: 812B00BC  lwz r9, 0xbc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AF9D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AF9D4: 419A0020  beq cr6, 0x821af9f4
	if ctx.cr[6].eq {
	pc = 0x821AF9F4; continue 'dispatch;
	}
	// 821AF9D8: 80E90030  lwz r7, 0x30(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AF9DC: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AF9E0: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AF9E4: 409A0010  bne cr6, 0x821af9f4
	if !ctx.cr[6].eq {
	pc = 0x821AF9F4; continue 'dispatch;
	}
	// 821AF9E8: 81690118  lwz r11, 0x118(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AF9EC: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AF9F0: 91690118  stw r11, 0x118(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AF9F4; continue 'dispatch;
            }
            0x821AF9F4 => {
    //   block [0x821AF9F4..0x821AF9F8)
	// 821AF9F4: F90A0120  std r8, 0x120(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(288 as u32), ctx.r[8].u64 ) };
	pc = 0x821AF9F8; continue 'dispatch;
            }
            0x821AF9F8 => {
    //   block [0x821AF9F8..0x821AFA48)
	// 821AF9F8: 816A012C  lwz r11, 0x12c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(300 as u32) ) } as u64;
	// 821AF9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFA00: 419A004C  beq cr6, 0x821afa4c
	if ctx.cr[6].eq {
	pc = 0x821AFA4C; continue 'dispatch;
	}
	// 821AFA04: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AFA08: 80EA0128  lwz r7, 0x128(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(296 as u32) ) } as u64;
	// 821AFA0C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821AFA10: 409A003C  bne cr6, 0x821afa4c
	if !ctx.cr[6].eq {
	pc = 0x821AFA4C; continue 'dispatch;
	}
	// 821AFA14: 812B00A0  lwz r9, 0xa0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821AFA18: 55290356  rlwinm r9, r9, 0, 0xd, 0xb
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821AFA1C: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821AFA20: 812B00BC  lwz r9, 0xbc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821AFA24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821AFA28: 419A0020  beq cr6, 0x821afa48
	if ctx.cr[6].eq {
	pc = 0x821AFA48; continue 'dispatch;
	}
	// 821AFA2C: 80E90030  lwz r7, 0x30(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 821AFA30: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 821AFA34: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821AFA38: 409A0010  bne cr6, 0x821afa48
	if !ctx.cr[6].eq {
	pc = 0x821AFA48; continue 'dispatch;
	}
	// 821AFA3C: 81690118  lwz r11, 0x118(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(280 as u32) ) } as u64;
	// 821AFA40: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821AFA44: 91690118  stw r11, 0x118(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x821AFA48; continue 'dispatch;
            }
            0x821AFA48 => {
    //   block [0x821AFA48..0x821AFA4C)
	// 821AFA48: F90A0128  std r8, 0x128(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(296 as u32), ctx.r[8].u64 ) };
	pc = 0x821AFA4C; continue 'dispatch;
            }
            0x821AFA4C => {
    //   block [0x821AFA4C..0x821AFA54)
	// 821AFA4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821AFA50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFA58 size=144
    let mut pc: u32 = 0x821AFA58;
    'dispatch: loop {
        match pc {
            0x821AFA58 => {
    //   block [0x821AFA58..0x821AFA94)
	// 821AFA58: C1430004  lfs f10, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821AFA5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AFA60: EC0A0072  fmuls f0, f10, f1
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 821AFA64: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AFA68: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821AFA6C: 419A00D8  beq cr6, 0x821afb44
	if ctx.cr[6].eq {
		sub_821AFB44(ctx, base);
		return;
	}
	// 821AFA70: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFA74: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFA78: C1230000  lfs f9, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821AFA7C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 821AFA80: EC29002A  fadds f1, f9, f0
	ctx.f[1].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AFA84: 40980010  bge cr6, 0x821afa94
	if !ctx.cr[6].lt {
	pc = 0x821AFA94; continue 'dispatch;
	}
	// 821AFA88: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 821AFA8C: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 821AFA90: 48000008  b 0x821afa98
	pc = 0x821AFA98; continue 'dispatch;
            }
            0x821AFA94 => {
    //   block [0x821AFA94..0x821AFA98)
	// 821AFA94: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x821AFA98; continue 'dispatch;
            }
            0x821AFA98 => {
    //   block [0x821AFA98..0x821AFAC4)
	// 821AFA98: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821AFA9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFAA0: 419A0048  beq cr6, 0x821afae8
	if ctx.cr[6].eq {
		sub_821AFAE8(ctx, base);
		return;
	}
	// 821AFAA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AFAA8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AFAAC: C18B2074  lfs f12, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFAB0: 41990014  bgt cr6, 0x821afac4
	if ctx.cr[6].gt {
	pc = 0x821AFAC4; continue 'dispatch;
	}
	// 821AFAB4: ED600828  fsubs f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 821AFAB8: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AFABC: D1430004  stfs f10, 4(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFAC0: EC2B002A  fadds f1, f11, f0
	ctx.f[1].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x821AFAC4; continue 'dispatch;
            }
            0x821AFAC4 => {
    //   block [0x821AFAC4..0x821AFAE8)
	// 821AFAC4: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821AFAC8: 41980074  blt cr6, 0x821afb3c
	if ctx.cr[6].lt {
		sub_821AFB1C(ctx, base);
		return;
	}
	// 821AFACC: EC016828  fsubs f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AFAD0: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821AFAD4: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821AFAD8: D1830004  stfs f12, 4(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFADC: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821AFAE0: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AFAE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFAE8 size=52
    let mut pc: u32 = 0x821AFAE8;
    'dispatch: loop {
        match pc {
            0x821AFAE8 => {
    //   block [0x821AFAE8..0x821AFB04)
	// 821AFAE8: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 821AFAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821AFAF0: 419A002C  beq cr6, 0x821afb1c
	if ctx.cr[6].eq {
		sub_821AFB1C(ctx, base);
		return;
	}
	// 821AFAF4: FF010000  fcmpu cr6, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AFAF8: 4199000C  bgt cr6, 0x821afb04
	if ctx.cr[6].gt {
	pc = 0x821AFB04; continue 'dispatch;
	}
	// 821AFAFC: ED800828  fsubs f12, f0, f1
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 821AFB00: EC2D6028  fsubs f1, f13, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x821AFB04; continue 'dispatch;
            }
            0x821AFB04 => {
    //   block [0x821AFB04..0x821AFB1C)
	// 821AFB04: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821AFB08: 41980034  blt cr6, 0x821afb3c
	if ctx.cr[6].lt {
		sub_821AFB1C(ctx, base);
		return;
	}
	// 821AFB0C: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 821AFB10: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821AFB14: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AFB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFB1C size=40
    let mut pc: u32 = 0x821AFB1C;
    'dispatch: loop {
        match pc {
            0x821AFB1C => {
    //   block [0x821AFB1C..0x821AFB2C)
	// 821AFB1C: FF010000  fcmpu cr6, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821AFB20: 4199000C  bgt cr6, 0x821afb2c
	if ctx.cr[6].gt {
	pc = 0x821AFB2C; continue 'dispatch;
	}
	// 821AFB24: D1630004  stfs f11, 4(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFB28: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x821AFB2C; continue 'dispatch;
            }
            0x821AFB2C => {
    //   block [0x821AFB2C..0x821AFB3C)
	// 821AFB2C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821AFB30: 4198000C  blt cr6, 0x821afb3c
	if ctx.cr[6].lt {
	pc = 0x821AFB3C; continue 'dispatch;
	}
	// 821AFB34: D1630004  stfs f11, 4(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821AFB38: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	pc = 0x821AFB3C; continue 'dispatch;
            }
            0x821AFB3C => {
    //   block [0x821AFB3C..0x821AFB44)
	// 821AFB3C: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821AFB40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFB44 size=8
    let mut pc: u32 = 0x821AFB44;
    'dispatch: loop {
        match pc {
            0x821AFB44 => {
    //   block [0x821AFB44..0x821AFB4C)
	// 821AFB44: C0230000  lfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFB48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821AFB50 size=56
    let mut pc: u32 = 0x821AFB50;
    'dispatch: loop {
        match pc {
            0x821AFB50 => {
    //   block [0x821AFB50..0x821AFB88)
	// 821AFB50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AFB54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AFB58: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFB5C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821AFB60: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFB64: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFB68: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821AFB6C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821AFB70: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821AFB74: C00A277C  lfs f0, 0x277c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFB78: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821AFB7C: 4098000C  bge cr6, 0x821afb88
	if !ctx.cr[6].lt {
		sub_821AFB88(ctx, base);
		return;
	}
	// 821AFB80: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821AFB84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821AFB88 size=88
    let mut pc: u32 = 0x821AFB88;
    'dispatch: loop {
        match pc {
            0x821AFB88 => {
    //   block [0x821AFB88..0x821AFBE0)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AFBE0 size=668
    let mut pc: u32 = 0x821AFBE0;
    'dispatch: loop {
        match pc {
            0x821AFBE0 => {
    //   block [0x821AFBE0..0x821AFC5C)
	// 821AFBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFBE4: 483854C9  bl 0x825350ac
	ctx.lr = 0x821AFBE8;
	sub_82535080(ctx, base);
	// 821AFBE8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821AFBEC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821AFBF0: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFBF4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821AFBF8: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821AFBFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821AFC00: 7F4907B4  extsw r9, r26
	ctx.r[9].s64 = ctx.r[26].s32 as i64;
	// 821AFC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFC08: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821AFC0C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821AFC10: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFC14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821AFC18: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 821AFC1C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821AFC20: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821AFC24: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821AFC28: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821AFC2C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821AFC30: EDA2F028  fsubs f13, f2, f30
	ctx.f[13].f64 = (((ctx.f[2].f64 - ctx.f[30].f64) as f32) as f64);
	// 821AFC34: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821AFC38: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821AFC3C: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFC40: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821AFC44: C80100A0  lfd f0, 0xa0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821AFC48: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFC4C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFC50: EFED0024  fdivs f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821AFC54: 419A0008  beq cr6, 0x821afc5c
	if ctx.cr[6].eq {
	pc = 0x821AFC5C; continue 'dispatch;
	}
	// 821AFC58: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	pc = 0x821AFC5C; continue 'dispatch;
            }
            0x821AFC5C => {
    //   block [0x821AFC5C..0x821AFE58)
	// 821AFC5C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821AFC60: 40990208  ble cr6, 0x821afe68
	if !ctx.cr[6].gt {
	pc = 0x821AFE68; continue 'dispatch;
	}
	// 821AFC64: 54DD103A  slwi r29, r6, 2
	ctx.r[29].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821AFC68: 3B810090  addi r28, r1, 0x90
	ctx.r[28].s64 = ctx.r[1].s64 + 144;
	// 821AFC6C: 7FDDE52E  stfsx f30, r29, r28
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32), tmp.u32) };
	// 821AFC70: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821AFC74: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821AFC78: 409901E0  ble cr6, 0x821afe58
	if !ctx.cr[6].gt {
	pc = 0x821AFE58; continue 'dispatch;
	}
	// 821AFC7C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 821AFC80: C0210090  lfs f1, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFC84: 481B820D  bl 0x82367e90
	ctx.lr = 0x821AFC88;
	sub_82367E90(ctx, base);
	// 821AFC88: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821AFC8C: C0210094  lfs f1, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFC90: 481B8329  bl 0x82367fb8
	ctx.lr = 0x821AFC94;
	sub_82367FB8(ctx, base);
	// 821AFC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AFC98: C0210098  lfs f1, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821AFC9C: 481B844D  bl 0x823680e8
	ctx.lr = 0x821AFCA0;
	sub_823680E8(ctx, base);
	// 821AFCA0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821AFCA4: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFCA8: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFCAC: C181007C  lfs f12, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821AFCB0: 7D7DE42E  lfsx f11, r29, r28
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x821AFE58; continue 'dispatch;
            }
            0x821AFE58 => {
    //   block [0x821AFE58..0x821AFE68)
	// 821AFE58: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 821AFE5C: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 821AFE60: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821AFE64: 4199FE08  bgt cr6, 0x821afc6c
	if ctx.cr[6].gt {
	pc = 0x821AFC6C; continue 'dispatch;
	}
	pc = 0x821AFE68; continue 'dispatch;
            }
            0x821AFE68 => {
    //   block [0x821AFE68..0x821AFE7C)
	// 821AFE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821AFE6C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 821AFE70: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821AFE74: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821AFE78: 48385284  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821AFE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821AFE80 size=656
    let mut pc: u32 = 0x821AFE80;
    'dispatch: loop {
        match pc {
            0x821AFE80 => {
    //   block [0x821AFE80..0x821B00FC)
	// 821AFE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821AFE84: 48385239  bl 0x825350bc
	ctx.lr = 0x821AFE88;
	sub_82535080(ctx, base);
	// 821AFE88: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821AFE8C: 48386159  bl 0x82535fe4
	ctx.lr = 0x821AFE90;
	sub_82535FB0(ctx, base);
	// 821AFE90: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821AFE94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821AFE98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821AFE9C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821AFEA0: 4099025C  ble cr6, 0x821b00fc
	if !ctx.cr[6].gt {
	pc = 0x821B00FC; continue 'dispatch;
	}
	// 821AFEA4: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 821AFEA8: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821AFEAC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821AFEB0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821AFEB4: C368D218  lfs f27, -0x2de8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821AFEB8: 3BABFBB0  addi r29, r11, -0x450
	ctx.r[29].s64 = ctx.r[11].s64 + -1104;
	// 821AFEBC: C389D468  lfs f28, -0x2b98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821AFEC0: C3EA2280  lfs f31, 0x2280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821AFEC4: 481B7275  bl 0x82367138
	ctx.lr = 0x821AFEC8;
	sub_82367138(ctx, base);
	// 821AFEC8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AFECC: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 821AFED0: C80100A8  lfd f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 821AFED4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFED8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFEDC: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AFEE0: 481B7259  bl 0x82367138
	ctx.lr = 0x821AFEE4;
	sub_82367138(ctx, base);
	// 821AFEE4: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821AFEE8: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 821AFEEC: C8010098  lfd f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821AFEF0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFEF4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFEF8: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AFEFC: 481B723D  bl 0x82367138
	ctx.lr = 0x821AFF00;
	sub_82367138(ctx, base);
	// 821AFF00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821AFF04: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 821AFF08: 796B0260  clrldi r11, r11, 0x29
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000007FFFFFu64;
	// 821AFF0C: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 821AFF10: C80100A0  lfd f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821AFF14: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821AFF18: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821AFF1C: EFA007F2  fmuls f29, f0, f31
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821AFF20: 481B7F71  bl 0x82367e90
	ctx.lr = 0x821AFF24;
	sub_82367E90(ctx, base);
	// 821AFF24: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821AFF28: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821AFF2C: 481B808D  bl 0x82367fb8
	ctx.lr = 0x821AFF30;
	sub_82367FB8(ctx, base);
	// 821AFF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821AFF34: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821AFF38: 481B81B1  bl 0x823680e8
	ctx.lr = 0x821AFF3C;
	sub_823680E8(ctx, base);
	// 821AFF3C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821AFF40: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821AFF44: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 821AFF48: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821AFF4C: C181007C  lfs f12, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x821B00FC; continue 'dispatch;
            }
            0x821B00FC => {
    //   block [0x821B00FC..0x821B0110)
	// 821B00FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0100: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 821B0104: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821B0108: 48385F29  bl 0x82536030
	ctx.lr = 0x821B010C;
	sub_82535FFC(ctx, base);
	// 821B010C: 48385000  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0110 size=132
    let mut pc: u32 = 0x821B0110;
    'dispatch: loop {
        match pc {
            0x821B0110 => {
    //   block [0x821B0110..0x821B0194)
	// 821B0110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B0114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B0118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B011C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B0120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0124: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B0128: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B012C: 396BFBB0  addi r11, r11, -0x450
	ctx.r[11].s64 = ctx.r[11].s64 + -1104;
	// 821B0130: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B0134: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B0138: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B013C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B0140: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B0144: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 821B0148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B014C: 4BFFFA95  bl 0x821afbe0
	ctx.lr = 0x821B0150;
	sub_821AFBE0(ctx, base);
	// 821B0150: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B0154: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B0158: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821B015C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821B0160: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821B0164: C04BBA38  lfs f2, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B0168: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B016C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B0170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B0174: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B0178: 4BFFFA69  bl 0x821afbe0
	ctx.lr = 0x821B017C;
	sub_821AFBE0(ctx, base);
	// 821B017C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B0180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B0184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B0188: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B018C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B0190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0198 size=496
    let mut pc: u32 = 0x821B0198;
    'dispatch: loop {
        match pc {
            0x821B0198 => {
    //   block [0x821B0198..0x821B02BC)
	// 821B0198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B019C: 48384F15  bl 0x825350b0
	ctx.lr = 0x821B01A0;
	sub_82535080(ctx, base);
	// 821B01A0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B01A4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B01A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B01AC: C0640008  lfs f3, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B01B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B01B4: C0440004  lfs f2, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B01B8: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B01BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B01C0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821B01C4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821B01C8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821B01CC: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 821B01D0: 481B8049  bl 0x82368218
	ctx.lr = 0x821B01D4;
	sub_82368218(ctx, base);
	// 821B01D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B01D8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B01DC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B01E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B01E4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B01E8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821B01EC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B01F0: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B01F4: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821B01F8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821B01FC: 419A00C0  beq cr6, 0x821b02bc
	if ctx.cr[6].eq {
	pc = 0x821B02BC; continue 'dispatch;
	}
	// 821B0200: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821B0204: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 821B0208: 393F0010  addi r9, r31, 0x10
	ctx.r[9].s64 = ctx.r[31].s64 + 16;
	// 821B020C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 821B0210: 3D603F80  lis r11, 0x3f80
	ctx.r[11].s64 = 1065353216;
	// 821B0214: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B0218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B021C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	pc = 0x821B02BC; continue 'dispatch;
            }
            0x821B02BC => {
    //   block [0x821B02BC..0x821B0388)
	// 821B02BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B02C0: C07C0008  lfs f3, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B02C4: C05C0004  lfs f2, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B02C8: C03C0000  lfs f1, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B02CC: 481B7F4D  bl 0x82368218
	ctx.lr = 0x821B02D0;
	sub_82368218(ctx, base);
	// 821B02D0: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B02D4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821B02D8: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821B02DC: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B02E0: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B02E4: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B02E8: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B02EC: D3FF003C  stfs f31, 0x3c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B02F0: 419A007C  beq cr6, 0x821b036c
	if ctx.cr[6].eq {
	pc = 0x821B036C; continue 'dispatch;
	}
	// 821B02F4: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B02F8: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B02FC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0300: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B0304: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B0308: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B030C: C17F0020  lfs f11, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B0310: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B0314: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821B0318: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B031C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0320: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B0324: C13F0014  lfs f9, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B0328: EDAA0032  fmuls f13, f10, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B032C: C11F0024  lfs f8, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B0330: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B0334: EDA00272  fmuls f13, f0, f9
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 821B0338: EC000232  fmuls f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 821B033C: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B0340: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B0344: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0348: C0FF0008  lfs f7, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B034C: C0DF0018  lfs f6, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B0350: EDA70032  fmuls f13, f7, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0354: C0BF0028  lfs f5, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B0358: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B035C: EDA60032  fmuls f13, f6, f0
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0360: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0364: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B0368: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821B036C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B0370: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B0374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B0378: 481B79B9  bl 0x82367d30
	ctx.lr = 0x821B037C;
	sub_82367D30(ctx, base);
	// 821B037C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B0380: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B0384: 48384D7C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0388 size=156
    let mut pc: u32 = 0x821B0388;
    'dispatch: loop {
        match pc {
            0x821B0388 => {
    //   block [0x821B0388..0x821B0424)
	// 821B0388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B038C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B0390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B0394: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 821B0398: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821B039C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821B03A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B03A4: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 821B03A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B03AC: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 821B03B0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B03B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821B03B8: 48382AF1  bl 0x82532ea8
	ctx.lr = 0x821B03BC;
	sub_82532EA8(ctx, base);
	// 821B03BC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821B03C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B03C4: EDBE07B2  fmuls f13, f30, f30
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B03C8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B03CC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B03D0: EDBF6FFA  fmadds f13, f31, f31, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B03D4: C3EB2254  lfs f31, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B03D8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B03DC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B03E0: EC40682C  fsqrts f2, f13
	ctx.f[2].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 821B03E4: 48382AC5  bl 0x82532ea8
	ctx.lr = 0x821B03E8;
	sub_82532EA8(ctx, base);
	// 821B03E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B03EC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B03F0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B03F4: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B03F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B03FC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B0400: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B0404: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B0408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B040C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B0410: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B0414: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821B0418: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B041C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B0420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B0428 size=412
    let mut pc: u32 = 0x821B0428;
    'dispatch: loop {
        match pc {
            0x821B0428 => {
    //   block [0x821B0428..0x821B0558)
	// 821B0428: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B042C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B0430: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 821B0434: 41980124  blt cr6, 0x821b0558
	if ctx.cr[6].lt {
	pc = 0x821B0558; continue 'dispatch;
	}
	// 821B0438: 3945FFFC  addi r10, r5, -4
	ctx.r[10].s64 = ctx.r[5].s64 + -4;
	// 821B043C: 39660030  addi r11, r6, 0x30
	ctx.r[11].s64 = ctx.r[6].s64 + 48;
	// 821B0440: 5549F0BE  srwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B0444: 39460010  addi r10, r6, 0x10
	ctx.r[10].s64 = ctx.r[6].s64 + 16;
	// 821B0448: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 821B044C: 39260020  addi r9, r6, 0x20
	ctx.r[9].s64 = ctx.r[6].s64 + 32;
	// 821B0450: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B0454: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 821B0458: 7CA72850  subf r5, r7, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 821B045C: 3BE00020  li r31, 0x20
	ctx.r[31].s64 = 32;
	// 821B0460: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	pc = 0x821B0558; continue 'dispatch;
            }
            0x821B0558 => {
    //   block [0x821B0558..0x821B05C4)
	// 821B0558: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B055C: 4099005C  ble cr6, 0x821b05b8
	if !ctx.cr[6].gt {
	pc = 0x821B05B8; continue 'dispatch;
	}
	// 821B0560: 39660030  addi r11, r6, 0x30
	ctx.r[11].s64 = ctx.r[6].s64 + 48;
	// 821B0564: 39460010  addi r10, r6, 0x10
	ctx.r[10].s64 = ctx.r[6].s64 + 16;
	// 821B0568: 39260020  addi r9, r6, 0x20
	ctx.r[9].s64 = ctx.r[6].s64 + 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B05C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B05C8 size=744
    let mut pc: u32 = 0x821B05C8;
    'dispatch: loop {
        match pc {
            0x821B05C8 => {
    //   block [0x821B05C8..0x821B060C)
	// 821B05C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B05CC: 48384AF1  bl 0x825350bc
	ctx.lr = 0x821B05D0;
	sub_82535080(ctx, base);
	// 821B05D0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B05D4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B05D8: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821B05DC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821B05E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B05E4: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821B05E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B05EC: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821B05F0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B05F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B05F8: 419A0014  beq cr6, 0x821b060c
	if ctx.cr[6].eq {
	pc = 0x821B060C; continue 'dispatch;
	}
	// 821B05FC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0600: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0604: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B0608: 419A0008  beq cr6, 0x821b0610
	if ctx.cr[6].eq {
	pc = 0x821B0610; continue 'dispatch;
	}
	pc = 0x821B060C; continue 'dispatch;
            }
            0x821B060C => {
    //   block [0x821B060C..0x821B0610)
	// 821B060C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B0610; continue 'dispatch;
            }
            0x821B0610 => {
    //   block [0x821B0610..0x821B0674)
	// 821B0610: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
	// 821B0614: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B0618: 4099005C  ble cr6, 0x821b0674
	if !ctx.cr[6].gt {
	pc = 0x821B0674; continue 'dispatch;
	}
	// 821B061C: 39090030  addi r8, r9, 0x30
	ctx.r[8].s64 = ctx.r[9].s64 + 48;
	// 821B0620: 38E90010  addi r7, r9, 0x10
	ctx.r[7].s64 = ctx.r[9].s64 + 16;
	// 821B0624: 38A90020  addi r5, r9, 0x20
	ctx.r[5].s64 = ctx.r[9].s64 + 32;
	// 821B0628: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B062C: 7CDD3050  subf r6, r29, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[29].s64;
	// 821B0630: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x821B0674; continue 'dispatch;
            }
            0x821B0674 => {
    //   block [0x821B0674..0x821B08B0)
	// 821B0674: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821B0678: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 821B067C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B08B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B08B0 size=288
    let mut pc: u32 = 0x821B08B0;
    'dispatch: loop {
        match pc {
            0x821B08B0 => {
    //   block [0x821B08B0..0x821B08D8)
	// 821B08B0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B08B4: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 821B08B8: 38EB14B0  addi r7, r11, 0x14b0
	ctx.r[7].s64 = ctx.r[11].s64 + 5296;
	// 821B08BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B08C0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 821B08C4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B08C8: D007000C  stfs f0, 0xc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B08CC: 40990060  ble cr6, 0x821b092c
	if !ctx.cr[6].gt {
	pc = 0x821B092C; continue 'dispatch;
	}
	// 821B08D0: 3924FFFF  addi r9, r4, -1
	ctx.r[9].s64 = ctx.r[4].s64 + -1;
	// 821B08D4: 39670018  addi r11, r7, 0x18
	ctx.r[11].s64 = ctx.r[7].s64 + 24;
	pc = 0x821B08D8; continue 'dispatch;
            }
            0x821B08D8 => {
    //   block [0x821B08D8..0x821B092C)
	// 821B08D8: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B08DC: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 821B08E0: C16BFFFC  lfs f11, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B08E4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821B08E8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B08EC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B08F0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B08F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B08F8: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B08FC: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B0900: C14BFFF8  lfs f10, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B0904: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821B0908: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 821B090C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B0910: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B0914: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B0918: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 821B091C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B0920: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B0924: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B0928: 409AFFB0  bne cr6, 0x821b08d8
	if !ctx.cr[6].eq {
	pc = 0x821B08D8; continue 'dispatch;
	}
	pc = 0x821B092C; continue 'dispatch;
            }
            0x821B092C => {
    //   block [0x821B092C..0x821B0960)
	// 821B092C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B0930: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 821B0934: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B0938: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821B093C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0940: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 821B0944: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B0948: 41980058  blt cr6, 0x821b09a0
	if ctx.cr[6].lt {
	pc = 0x821B09A0; continue 'dispatch;
	}
	// 821B094C: 3944FFFB  addi r10, r4, -5
	ctx.r[10].s64 = ctx.r[4].s64 + -5;
	// 821B0950: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B0954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B0958: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B095C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	pc = 0x821B0960; continue 'dispatch;
            }
            0x821B0960 => {
    //   block [0x821B0960..0x821B09A0)
	// 821B0960: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0964: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B0968: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B096C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B0970: C16B002C  lfs f11, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B0974: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0978: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B097C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0980: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B0984: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B0988: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B098C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B0990: D16B002C  stfs f11, 0x2c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821B0994: D14B003C  stfs f10, 0x3c(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B0998: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821B099C: 409AFFC4  bne cr6, 0x821b0960
	if !ctx.cr[6].eq {
	pc = 0x821B0960; continue 'dispatch;
	}
	pc = 0x821B09A0; continue 'dispatch;
            }
            0x821B09A0 => {
    //   block [0x821B09A0..0x821B09B0)
	// 821B09A0: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821B09A4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 821B09A8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821B09AC: 7D492050  subf r10, r9, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	pc = 0x821B09B0; continue 'dispatch;
            }
            0x821B09B0 => {
    //   block [0x821B09B0..0x821B09D0)
	// 821B09B0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B09B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B09B8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B09BC: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B09C0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B09C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B09C8: 409AFFE8  bne cr6, 0x821b09b0
	if !ctx.cr[6].eq {
	pc = 0x821B09B0; continue 'dispatch;
	}
	// 821B09CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B09D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B09D0 size=1300
    let mut pc: u32 = 0x821B09D0;
    'dispatch: loop {
        match pc {
            0x821B09D0 => {
    //   block [0x821B09D0..0x821B0A34)
	// 821B09D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B09D4: 483846B1  bl 0x82535084
	ctx.lr = 0x821B09D8;
	sub_82535080(ctx, base);
	// 821B09D8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 821B09DC: 483855E9  bl 0x82535fc4
	ctx.lr = 0x821B09E0;
	sub_82535FB0(ctx, base);
	// 821B09E0: 3981FF00  addi r12, r1, -0x100
	ctx.r[12].s64 = ctx.r[1].s64 + -256;
	// 821B09E4: 483889B9  bl 0x8253939c
	ctx.lr = 0x821B09E8;
	sub_82539130(ctx, base);
	// 821B09E8: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B09EC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B09F0: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 821B09F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B09F8: FE601090  fmr f19, f2
	ctx.f[19].f64 = ctx.f[2].f64;
	// 821B09FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B0A00: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 821B0A04: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B0A08: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B0A0C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B0A10: C28B1FF8  lfs f20, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 821B0A14: 419A0020  beq cr6, 0x821b0a34
	if ctx.cr[6].eq {
	pc = 0x821B0A34; continue 'dispatch;
	}
	// 821B0A18: C3670000  lfs f27, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821B0A1C: C3870004  lfs f28, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B0A20: C0070008  lfs f0, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0A24: C1A70014  lfs f13, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0A28: EF00D828  fsubs f24, f0, f27
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 821B0A2C: EF2DE028  fsubs f25, f13, f28
	ctx.f[25].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 821B0A30: 48000014  b 0x821b0a44
	pc = 0x821B0A44; continue 'dispatch;
            }
            0x821B0A34 => {
    //   block [0x821B0A34..0x821B0A44)
	// 821B0A34: FF80A090  fmr f28, f20
	ctx.f[28].f64 = ctx.f[20].f64;
	// 821B0A38: FF60A090  fmr f27, f20
	ctx.f[27].f64 = ctx.f[20].f64;
	// 821B0A3C: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821B0A40: FF00F890  fmr f24, f31
	ctx.f[24].f64 = ctx.f[31].f64;
	pc = 0x821B0A44; continue 'dispatch;
            }
            0x821B0A44 => {
    //   block [0x821B0A44..0x821B0A78)
	// 821B0A44: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 821B0A48: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0A4C: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 821B0A50: C3A9BFFC  lfs f29, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B0A54: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B0A58: EED8DF7A  fmadds f22, f24, f29, f27
	ctx.f[22].f64 = (((ctx.f[24].f64 * ctx.f[29].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B0A5C: EEB9E77A  fmadds f21, f25, f29, f28
	ctx.f[21].f64 = (((ctx.f[25].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 821B0A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B0A64: 419A0014  beq cr6, 0x821b0a78
	if ctx.cr[6].eq {
	pc = 0x821B0A78; continue 'dispatch;
	}
	// 821B0A68: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B0A6C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B0A70: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B0A74: 419A0008  beq cr6, 0x821b0a7c
	if ctx.cr[6].eq {
	pc = 0x821B0A7C; continue 'dispatch;
	}
	pc = 0x821B0A78; continue 'dispatch;
            }
            0x821B0A78 => {
    //   block [0x821B0A78..0x821B0A7C)
	// 821B0A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B0A7C; continue 'dispatch;
            }
            0x821B0A7C => {
    //   block [0x821B0A7C..0x821B0EE4)
	// 821B0A7C: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B0EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B0EE8 size=448
    let mut pc: u32 = 0x821B0EE8;
    'dispatch: loop {
        match pc {
            0x821B0EE8 => {
    //   block [0x821B0EE8..0x821B0F3C)
	// 821B0EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B0EEC: 483841CD  bl 0x825350b8
	ctx.lr = 0x821B0EF0;
	sub_82535080(ctx, base);
	// 821B0EF0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821B0EF4: 483850DD  bl 0x82535fd0
	ctx.lr = 0x821B0EF8;
	sub_82535FB0(ctx, base);
	// 821B0EF8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B0EFC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B0F00: FEE00890  fmr f23, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[23].f64 = ctx.f[1].f64;
	// 821B0F04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0F08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B0F0C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821B0F10: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B0F14: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B0F18: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B0F1C: 419A0020  beq cr6, 0x821b0f3c
	if ctx.cr[6].eq {
	pc = 0x821B0F3C; continue 'dispatch;
	}
	// 821B0F20: C3450000  lfs f26, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821B0F24: C3650004  lfs f27, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821B0F28: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0F2C: C1A50014  lfs f13, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B0F30: EF00D028  fsubs f24, f0, f26
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 821B0F34: EF2DD828  fsubs f25, f13, f27
	ctx.f[25].f64 = (((ctx.f[13].f64 - ctx.f[27].f64) as f32) as f64);
	// 821B0F38: 48000014  b 0x821b0f4c
	pc = 0x821B0F4C; continue 'dispatch;
            }
            0x821B0F3C => {
    //   block [0x821B0F3C..0x821B0F4C)
	// 821B0F3C: FF60F090  fmr f27, f30
	ctx.f[27].f64 = ctx.f[30].f64;
	// 821B0F40: FF40F090  fmr f26, f30
	ctx.f[26].f64 = ctx.f[30].f64;
	// 821B0F44: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821B0F48: FF00F890  fmr f24, f31
	ctx.f[24].f64 = ctx.f[31].f64;
	pc = 0x821B0F4C; continue 'dispatch;
            }
            0x821B0F4C => {
    //   block [0x821B0F4C..0x821B0F6C)
	// 821B0F4C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B0F50: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B0F54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B0F58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B0F5C: C2C92490  lfs f22, 0x2490(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9360 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821B0F60: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 821B0F64: C38A2048  lfs f28, 0x2048(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B0F68: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x821B0F6C; continue 'dispatch;
            }
            0x821B0F6C => {
    //   block [0x821B0F6C..0x821B0F78)
	// 821B0F6C: 409A000C  bne cr6, 0x821b0f78
	if !ctx.cr[6].eq {
	pc = 0x821B0F78; continue 'dispatch;
	}
	// 821B0F70: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821B0F74: 4800000C  b 0x821b0f80
	pc = 0x821B0F80; continue 'dispatch;
            }
            0x821B0F78 => {
    //   block [0x821B0F78..0x821B0F80)
	// 821B0F78: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B0F7C: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x821B0F80; continue 'dispatch;
            }
            0x821B0F80 => {
    //   block [0x821B0F80..0x821B0FB0)
	// 821B0F80: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B0F84: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B0F88: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 821B0F8C: 41980064  blt cr6, 0x821b0ff0
	if ctx.cr[6].lt {
	pc = 0x821B0FF0; continue 'dispatch;
	}
	// 821B0F90: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821B0F94: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821B0F98: 4098003C  bge cr6, 0x821b0fd4
	if !ctx.cr[6].lt {
	pc = 0x821B0FD4; continue 'dispatch;
	}
	// 821B0F9C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B0FA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B0FA4: 4098000C  bge cr6, 0x821b0fb0
	if !ctx.cr[6].lt {
	pc = 0x821B0FB0; continue 'dispatch;
	}
	// 821B0FA8: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B0FAC: 48000040  b 0x821b0fec
	pc = 0x821B0FEC; continue 'dispatch;
            }
            0x821B0FB0 => {
    //   block [0x821B0FB0..0x821B0FD4)
	// 821B0FB0: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B0FB4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B0FB8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B0FBC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B0FC0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B0FC4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B0FC8: 41980024  blt cr6, 0x821b0fec
	if ctx.cr[6].lt {
	pc = 0x821B0FEC; continue 'dispatch;
	}
	// 821B0FCC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821B0FD0: 4800001C  b 0x821b0fec
	pc = 0x821B0FEC; continue 'dispatch;
            }
            0x821B0FD4 => {
    //   block [0x821B0FD4..0x821B0FEC)
	// 821B0FD4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B0FD8: 41980014  blt cr6, 0x821b0fec
	if ctx.cr[6].lt {
	pc = 0x821B0FEC; continue 'dispatch;
	}
	// 821B0FDC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B0FE0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B0FE4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B0FE8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821B0FEC; continue 'dispatch;
            }
            0x821B0FEC => {
    //   block [0x821B0FEC..0x821B0FF0)
	// 821B0FEC: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	pc = 0x821B0FF0; continue 'dispatch;
            }
            0x821B0FF0 => {
    //   block [0x821B0FF0..0x821B10A8)
	// 821B0FF0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B0FF4: EC2005B2  fmuls f1, f0, f22
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 821B0FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B0FFC: 4BF60DD5  bl 0x82111dd0
	ctx.lr = 0x821B1000;
	sub_82111DD0(ctx, base);
	// 821B1000: C19F0000  lfs f12, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1004: D19E0000  stfs f12, 0(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1008: 397E0030  addi r11, r30, 0x30
	ctx.r[11].s64 = ctx.r[30].s64 + 48;
	// 821B100C: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1010: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B1014: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B1018: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B101C: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 821B1020: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1024: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1028: ED80F82A  fadds f12, f0, f31
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B102C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B1030: EC00FFBA  fmadds f0, f0, f30, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64);
	// 821B1034: ED6DF828  fsubs f11, f13, f31
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B1038: D2FE001C  stfs f23, 0x1c(r30)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B103C: EDADFFB8  fmsubs f13, f13, f30, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B1040: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 821B1044: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821B1048: ED6B0732  fmuls f11, f11, f28
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[28].f64) as f32) as f64);
	// 821B104C: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 821B1050: ED8CD63A  fmadds f12, f12, f24, f26
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[24].f64 + ctx.f[26].f64) as f32) as f64);
	// 821B1054: EC00D63A  fmadds f0, f0, f24, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[26].f64) as f32) as f64);
	// 821B1058: D01E0020  stfs f0, 0x20(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B105C: ED6BDE7A  fmadds f11, f11, f25, f27
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1060: EC0DDE7A  fmadds f0, f13, f25, f27
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1064: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B1068: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B106C: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	// 821B1070: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1074: C01F0204  lfs f0, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1078: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B107C: C01F0208  lfs f0, 0x208(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1080: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1084: D18B0020  stfs f12, 0x20(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B1088: D16B0024  stfs f11, 0x24(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B108C: D2EB001C  stfs f23, 0x1c(r11)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B1090: 4099FEDC  ble cr6, 0x821b0f6c
	if !ctx.cr[6].gt {
	pc = 0x821B0F6C; continue 'dispatch;
	}
	// 821B1094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B1098: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821B109C: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821B10A0: 48384F7D  bl 0x8253601c
	ctx.lr = 0x821B10A4;
	sub_82535FFC(ctx, base);
	// 821B10A4: 48384064  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B10A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B10A8 size=480
    let mut pc: u32 = 0x821B10A8;
    'dispatch: loop {
        match pc {
            0x821B10A8 => {
    //   block [0x821B10A8..0x821B10FC)
	// 821B10A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B10AC: 48384005  bl 0x825350b0
	ctx.lr = 0x821B10B0;
	sub_82535080(ctx, base);
	// 821B10B0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821B10B4: 48384F11  bl 0x82535fc4
	ctx.lr = 0x821B10B8;
	sub_82535FB0(ctx, base);
	// 821B10B8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B10BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B10C0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821B10C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B10C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B10CC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821B10D0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821B10D4: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B10D8: C26B1FF8  lfs f19, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 821B10DC: 419A0020  beq cr6, 0x821b10fc
	if ctx.cr[6].eq {
	pc = 0x821B10FC; continue 'dispatch;
	}
	// 821B10E0: C3660000  lfs f27, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821B10E4: C3860004  lfs f28, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B10E8: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B10EC: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B10F0: EF00D828  fsubs f24, f0, f27
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 821B10F4: EF2DE028  fsubs f25, f13, f28
	ctx.f[25].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 821B10F8: 48000014  b 0x821b110c
	pc = 0x821B110C; continue 'dispatch;
            }
            0x821B10FC => {
    //   block [0x821B10FC..0x821B110C)
	// 821B10FC: FF809890  fmr f28, f19
	ctx.f[28].f64 = ctx.f[19].f64;
	// 821B1100: FF609890  fmr f27, f19
	ctx.f[27].f64 = ctx.f[19].f64;
	// 821B1104: FF20F890  fmr f25, f31
	ctx.f[25].f64 = ctx.f[31].f64;
	// 821B1108: FF00F890  fmr f24, f31
	ctx.f[24].f64 = ctx.f[31].f64;
	pc = 0x821B110C; continue 'dispatch;
            }
            0x821B110C => {
    //   block [0x821B110C..0x821B1160)
	// 821B110C: 7F6A07B4  extsw r10, r27
	ctx.r[10].s64 = ctx.r[27].s32 as i64;
	// 821B1110: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1114: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821B1118: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821B111C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 821B1120: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821B1124: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B1128: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B112C: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B1130: EEB8DF7A  fmadds f21, f24, f29, f27
	ctx.f[21].f64 = (((ctx.f[24].f64 * ctx.f[29].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1134: EE99E77A  fmadds f20, f25, f29, f28
	ctx.f[20].f64 = (((ctx.f[25].f64 * ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64);
	// 821B1138: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B113C: EEFE0024  fdivs f23, f30, f0
	ctx.f[23].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 821B1140: 40990138  ble cr6, 0x821b1278
	if !ctx.cr[6].gt {
	pc = 0x821B1278; continue 'dispatch;
	}
	// 821B1144: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B1148: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B114C: 396B14B0  addi r11, r11, 0x14b0
	ctx.r[11].s64 = ctx.r[11].s64 + 5296;
	// 821B1150: 3BCB0008  addi r30, r11, 8
	ctx.r[30].s64 = ctx.r[11].s64 + 8;
	// 821B1154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1158: C2CA2490  lfs f22, 0x2490(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9360 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 821B115C: C34B2048  lfs f26, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	pc = 0x821B1160; continue 'dispatch;
            }
            0x821B1160 => {
    //   block [0x821B1160..0x821B11E4)
	// 821B1160: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 821B1164: 9343005C  stw r26, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 821B1168: 3BE30030  addi r31, r3, 0x30
	ctx.r[31].s64 = ctx.r[3].s64 + 48;
	// 821B116C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B1170: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821B1174: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1178: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B117C: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1180: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B1184: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1188: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 821B118C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1190: D2A30020  stfs f21, 0x20(r3)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B1194: D2830024  stfs f20, 0x24(r3)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B1198: D3C3001C  stfs f30, 0x1c(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B119C: C01EFFF8  lfs f0, -8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11A0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B11A4: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11A8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B11AC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11B0: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B11B4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B11B8: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B11BC: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 821B11C0: 41980064  blt cr6, 0x821b1224
	if ctx.cr[6].lt {
	pc = 0x821B1224; continue 'dispatch;
	}
	// 821B11C4: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 821B11C8: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 821B11CC: 4098003C  bge cr6, 0x821b1208
	if !ctx.cr[6].lt {
	pc = 0x821B1208; continue 'dispatch;
	}
	// 821B11D0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821B11D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B11D8: 4098000C  bge cr6, 0x821b11e4
	if !ctx.cr[6].lt {
	pc = 0x821B11E4; continue 'dispatch;
	}
	// 821B11DC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B11E0: 48000040  b 0x821b1220
	pc = 0x821B1220; continue 'dispatch;
            }
            0x821B11E4 => {
    //   block [0x821B11E4..0x821B1208)
	// 821B11E4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B11E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B11EC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B11F0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B11F4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B11F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B11FC: 41980024  blt cr6, 0x821b1220
	if ctx.cr[6].lt {
	pc = 0x821B1220; continue 'dispatch;
	}
	// 821B1200: FC009890  fmr f0, f19
	ctx.f[0].f64 = ctx.f[19].f64;
	// 821B1204: 4800001C  b 0x821b1220
	pc = 0x821B1220; continue 'dispatch;
            }
            0x821B1208 => {
    //   block [0x821B1208..0x821B1220)
	// 821B1208: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B120C: 41980014  blt cr6, 0x821b1220
	if ctx.cr[6].lt {
	pc = 0x821B1220; continue 'dispatch;
	}
	// 821B1210: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821B1214: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B1218: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B121C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821B1220; continue 'dispatch;
            }
            0x821B1220 => {
    //   block [0x821B1220..0x821B1224)
	// 821B1220: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	pc = 0x821B1224; continue 'dispatch;
            }
            0x821B1224 => {
    //   block [0x821B1224..0x821B1278)
	// 821B1224: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821B1228: EC2005B2  fmuls f1, f0, f22
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 821B122C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B1230: 4BF60BA1  bl 0x82111dd0
	ctx.lr = 0x821B1234;
	sub_82111DD0(ctx, base);
	// 821B1234: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1238: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B123C: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B1240: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B1244: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821B1248: D3DF001C  stfs f30, 0x1c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B124C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821B1250: EFDEB828  fsubs f30, f30, f23
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[23].f64) as f32) as f64);
	// 821B1254: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821B1258: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 821B125C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821B1260: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 821B1264: EC00DE3A  fmadds f0, f0, f24, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[27].f64) as f32) as f64);
	// 821B1268: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B126C: EC0DE67A  fmadds f0, f13, f25, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64 + ctx.f[28].f64) as f32) as f64);
	// 821B1270: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B1274: 4198FEEC  blt cr6, 0x821b1160
	if ctx.cr[6].lt {
	pc = 0x821B1160; continue 'dispatch;
	}
	pc = 0x821B1278; continue 'dispatch;
            }
            0x821B1278 => {
    //   block [0x821B1278..0x821B1288)
	// 821B1278: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B127C: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821B1280: 48384D91  bl 0x82536010
	ctx.lr = 0x821B1284;
	sub_82535FFC(ctx, base);
	// 821B1284: 48383E7C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1288 size=656
    let mut pc: u32 = 0x821B1288;
    'dispatch: loop {
        match pc {
            0x821B1288 => {
    //   block [0x821B1288..0x821B1300)
	// 821B1288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B128C: 48383E29  bl 0x825350b4
	ctx.lr = 0x821B1290;
	sub_82535080(ctx, base);
	// 821B1290: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 821B1294: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821B1298: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821B129C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B12A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B12A4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B12A8: 54BD057E  clrlwi r29, r5, 0x15
	ctx.r[29].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 821B12AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B12B0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821B12B4: 54A90428  rlwinm r9, r5, 0, 0x10, 0x14
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821B12B8: FB7C0000  std r27, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821B12BC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821B12C0: 419A01A8  beq cr6, 0x821b1468
	if ctx.cr[6].eq {
	pc = 0x821B1468; continue 'dispatch;
	}
	// 821B12C4: 2F1D0059  cmpwi cr6, r29, 0x59
	ctx.cr[6].compare_i32(ctx.r[29].s32, 89, &mut ctx.xer);
	// 821B12C8: 419A0108  beq cr6, 0x821b13d0
	if ctx.cr[6].eq {
	pc = 0x821B13D0; continue 'dispatch;
	}
	// 821B12CC: 2F1D005A  cmpwi cr6, r29, 0x5a
	ctx.cr[6].compare_i32(ctx.r[29].s32, 90, &mut ctx.xer);
	// 821B12D0: 419A00F0  beq cr6, 0x821b13c0
	if ctx.cr[6].eq {
	pc = 0x821B13C0; continue 'dispatch;
	}
	// 821B12D4: 2F1D0058  cmpwi cr6, r29, 0x58
	ctx.cr[6].compare_i32(ctx.r[29].s32, 88, &mut ctx.xer);
	// 821B12D8: 41980028  blt cr6, 0x821b1300
	if ctx.cr[6].lt {
	pc = 0x821B1300; continue 'dispatch;
	}
	// 821B12DC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821B12E0: 397DFFA8  addi r11, r29, -0x58
	ctx.r[11].s64 = ctx.r[29].s64 + -88;
	// 821B12E4: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 821B12E8: 390A0002  addi r8, r10, 2
	ctx.r[8].s64 = ctx.r[10].s64 + 2;
	// 821B12EC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B12F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B12F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B12F8: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B12FC: 7D7D0734  extsh r29, r11
	ctx.r[29].s64 = ctx.r[11].s16 as i64;
	pc = 0x821B1300; continue 'dispatch;
            }
            0x821B1300 => {
    //   block [0x821B1300..0x821B138C)
	// 821B1300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B1304: 419A01FC  beq cr6, 0x821b1500
	if ctx.cr[6].eq {
	pc = 0x821B1500; continue 'dispatch;
	}
	// 821B1308: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B130C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1310: 419A007C  beq cr6, 0x821b138c
	if ctx.cr[6].eq {
	pc = 0x821B138C; continue 'dispatch;
	}
	// 821B1314: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B1318: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B131C: 386B14A0  addi r3, r11, 0x14a0
	ctx.r[3].s64 = ctx.r[11].s64 + 5280;
	// 821B1320: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B1324: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B1328: 4BFF27E1  bl 0x821a3b08
	ctx.lr = 0x821B132C;
	sub_821A3B08(ctx, base);
	// 821B132C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1330: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B1334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1338: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B133C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B1340: 4E800421  bctrl
	ctx.lr = 0x821B1344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B1344: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1348: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821B134C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821B1350: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
            }
            0x821B138C => {
    //   block [0x821B138C..0x821B13C0)
	// 821B138C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1390: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B1394: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B139C: 4E800421  bctrl
	ctx.lr = 0x821B13A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B13A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B13A4: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B13A8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B13AC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B13B0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B13B4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B13B8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B13BC: 48000144  b 0x821b1500
	pc = 0x821B1500; continue 'dispatch;
            }
            0x821B13C0 => {
    //   block [0x821B13C0..0x821B13D0)
	// 821B13C0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B13C4: E96BC448  ld r11, -0x3bb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-15288 as u32) ) };
	// 821B13C8: F97C0000  std r11, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B13CC: 48000134  b 0x821b1500
	pc = 0x821B1500; continue 'dispatch;
            }
            0x821B13D0 => {
    //   block [0x821B13D0..0x821B1468)
	// 821B13D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B13D4: 419A012C  beq cr6, 0x821b1500
	if ctx.cr[6].eq {
	pc = 0x821B1500; continue 'dispatch;
	}
	// 821B13D8: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B13DC: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B13E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B13E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B13E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B13EC: 4E800421  bctrl
	ctx.lr = 0x821B13F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B13F0: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B13F4: C3E30030  lfs f31, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B13F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B13FC: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 821B1400: C3C30034  lfs f30, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B1404: C3A30038  lfs f29, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B1408: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B140C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821B1410: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1414: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B141C: 4E800421  bctrl
	ctx.lr = 0x821B1420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B1420: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B1424: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B1428: C0E1006C  lfs f7, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B142C: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1430: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B1434: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B1438: ED3E0032  fmuls f9, f30, f0
	ctx.f[9].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B143C: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B1440: ED1D0032  fmuls f8, f29, f0
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B1444: C16B0038  lfs f11, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B1448: D0FF000C  stfs f7, 0xc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B144C: EDAD503A  fmadds f13, f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821B1450: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1454: EDAC483A  fmadds f13, f12, f0, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B1458: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B145C: EC0B403A  fmadds f0, f11, f0, f8
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821B1460: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B1464: 4800009C  b 0x821b1500
	pc = 0x821B1500; continue 'dispatch;
            }
            0x821B1468 => {
    //   block [0x821B1468..0x821B1500)
	// 821B1468: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B146C: 419A0094  beq cr6, 0x821b1500
	if ctx.cr[6].eq {
	pc = 0x821B1500; continue 'dispatch;
	}
	// 821B1470: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B1474: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B1478: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821B147C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B1484: 4E800421  bctrl
	ctx.lr = 0x821B1488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B1488: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B148C: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1490: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B1494: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1498: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B149C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B14A0: C0430038  lfs f2, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B14A4: D05F0008  stfs f2, 8(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B14A8: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B14AC: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B14B0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B14B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B14B8: 40990018  ble cr6, 0x821b14d0
	if !ctx.cr[6].gt {
	pc = 0x821B14D0; continue 'dispatch;
	}
	// 821B14BC: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B14C0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B14C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B14C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B14CC: 41990008  bgt cr6, 0x821b14d4
	if ctx.cr[6].gt {
	pc = 0x821B14D4; continue 'dispatch;
	}
	// 821B14D0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B14D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B14D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B14DC: 409A0010  bne cr6, 0x821b14ec
	if !ctx.cr[6].eq {
	pc = 0x821B14EC; continue 'dispatch;
	}
	// 821B14E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B14E4: 48005FE5  bl 0x821b74c8
	ctx.lr = 0x821B14E8;
	sub_821B74C8(ctx, base);
	// 821B14E8: 48000014  b 0x821b14fc
	pc = 0x821B14FC; continue 'dispatch;
	// 821B14EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B14F0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821B14F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B14F8: 48006039  bl 0x821b7530
	ctx.lr = 0x821B14FC;
	sub_821B7530(ctx, base);
	// 821B14FC: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
            }
            0x821B1500 => {
    //   block [0x821B1500..0x821B1518)
	// 821B1500: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B1504: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B1508: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B150C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B1510: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B1514: 48383BF0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1518 size=540
    let mut pc: u32 = 0x821B1518;
    'dispatch: loop {
        match pc {
            0x821B1518 => {
    //   block [0x821B1518..0x821B156C)
	// 821B1518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B151C: 48383B91  bl 0x825350ac
	ctx.lr = 0x821B1520;
	sub_82535080(ctx, base);
	// 821B1520: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B1528: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B152C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821B1530: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B1534: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821B1538: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821B153C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 821B1540: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B1544: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821B1548: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B154C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 821B1550: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 821B1554: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821B1558: 93BF0044  stw r29, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[29].u32 ) };
	// 821B155C: 409A0010  bne cr6, 0x821b156c
	if !ctx.cr[6].eq {
	pc = 0x821B156C; continue 'dispatch;
	}
	// 821B1560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B1564: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B1568: 48383B94  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B156C => {
    //   block [0x821B156C..0x821B158C)
	// 821B156C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B1570: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1574: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821B1578: 388B0FA4  addi r4, r11, 0xfa4
	ctx.r[4].s64 = ctx.r[11].s64 + 4004;
	// 821B157C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B1580: 48381C11  bl 0x82533190
	ctx.lr = 0x821B1584;
	sub_82533190(ctx, base);
	// 821B1584: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821B1588: 419A0010  beq cr6, 0x821b1598
	if ctx.cr[6].eq {
	pc = 0x821B1598; continue 'dispatch;
	}
	pc = 0x821B158C; continue 'dispatch;
            }
            0x821B158C => {
    //   block [0x821B158C..0x821B1598)
	// 821B158C: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1590: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B1594: 48383B68  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B1598 => {
    //   block [0x821B1598..0x821B15C8)
	// 821B1598: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B159C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B15A0: 2F0B0102  cmpwi cr6, r11, 0x102
	ctx.cr[6].compare_i32(ctx.r[11].s32, 258, &mut ctx.xer);
	// 821B15A4: 409AFFE8  bne cr6, 0x821b158c
	if !ctx.cr[6].eq {
	pc = 0x821B158C; continue 'dispatch;
	}
	// 821B15A8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821B15AC: 419A00AC  beq cr6, 0x821b1658
	if ctx.cr[6].eq {
	pc = 0x821B1658; continue 'dispatch;
	}
	// 821B15B0: 3B9F004C  addi r28, r31, 0x4c
	ctx.r[28].s64 = ctx.r[31].s64 + 76;
	// 821B15B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B15B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B15BC: 409A000C  bne cr6, 0x821b15c8
	if !ctx.cr[6].eq {
	pc = 0x821B15C8; continue 'dispatch;
	}
	// 821B15C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B15C4: 4800002C  b 0x821b15f0
	pc = 0x821B15F0; continue 'dispatch;
            }
            0x821B15C8 => {
    //   block [0x821B15C8..0x821B15E0)
	// 821B15C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B15CC: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B15D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B15D4: 419A000C  beq cr6, 0x821b15e0
	if ctx.cr[6].eq {
	pc = 0x821B15E0; continue 'dispatch;
	}
	// 821B15D8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821B15DC: 48000014  b 0x821b15f0
	pc = 0x821B15F0; continue 'dispatch;
            }
            0x821B15E0 => {
    //   block [0x821B15E0..0x821B15F0)
	// 821B15E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B15E4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B15E8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B15EC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x821B15F0; continue 'dispatch;
            }
            0x821B15F0 => {
    //   block [0x821B15F0..0x821B1614)
	// 821B15F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B15F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B15F8: 419A001C  beq cr6, 0x821b1614
	if ctx.cr[6].eq {
	pc = 0x821B1614; continue 'dispatch;
	}
	// 821B15FC: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821B1600: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1604: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821B1608: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B160C: 419A0008  beq cr6, 0x821b1614
	if ctx.cr[6].eq {
	pc = 0x821B1614; continue 'dispatch;
	}
	// 821B1610: 4BF6BA49  bl 0x8211d058
	ctx.lr = 0x821B1614;
	sub_8211D058(ctx, base);
	pc = 0x821B1614; continue 'dispatch;
            }
            0x821B1614 => {
    //   block [0x821B1614..0x821B1658)
	// 821B1614: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B1618: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B161C: 38CB0FA8  addi r6, r11, 0xfa8
	ctx.r[6].s64 = ctx.r[11].s64 + 4008;
	// 821B1620: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1624: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B1628: 386BDBE0  addi r3, r11, -0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + -9248;
	// 821B162C: 48043CBD  bl 0x821f52e8
	ctx.lr = 0x821B1630;
	sub_821F52E8(ctx, base);
	// 821B1630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B1634: 419AFF58  beq cr6, 0x821b158c
	if ctx.cr[6].eq {
	pc = 0x821B158C; continue 'dispatch;
	}
	// 821B1638: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B163C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B1640: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B1644: 4807BDA5  bl 0x8222d3e8
	ctx.lr = 0x821B1648;
	sub_8222D3E8(ctx, base);
	// 821B1648: 48383509  bl 0x82534b50
	ctx.lr = 0x821B164C;
	sub_82534B50(ctx, base);
	// 821B164C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B1650: 4807BD99  bl 0x8222d3e8
	ctx.lr = 0x821B1654;
	sub_8222D3E8(ctx, base);
	// 821B1654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x821B1658; continue 'dispatch;
            }
            0x821B1658 => {
    //   block [0x821B1658..0x821B170C)
	// 821B1658: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821B165C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1660: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821B1664: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821B1668: E96AFB60  ld r11, -0x4a0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-1184 as u32) ) };
	// 821B166C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821B1670: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B1674: F96AFB60  std r11, -0x4a0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-1184 as u32), ctx.r[11].u64 ) };
	// 821B1678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B167C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B1680: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821B1684: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1688: 814A0024  lwz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B168C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1690: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821B1694: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1698: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B169C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16A0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821B16A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16A8: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B16AC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16B0: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B16B4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16B8: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B16BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16C0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821B16C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16C8: 814A0034  lwz r10, 0x34(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B16CC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16D0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B16D4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16D8: 814A0038  lwz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B16DC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B16E0: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821B16E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B16E8: 394B0040  addi r10, r11, 0x40
	ctx.r[10].s64 = ctx.r[11].s64 + 64;
	// 821B16EC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821B16F0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B16F4: F93F0058  std r9, 0x58(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821B16F8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821B16FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B1700: 419A000C  beq cr6, 0x821b170c
	if ctx.cr[6].eq {
	pc = 0x821B170C; continue 'dispatch;
	}
	// 821B1704: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B1708: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	pc = 0x821B170C; continue 'dispatch;
            }
            0x821B170C => {
    //   block [0x821B170C..0x821B1734)
	// 821B170C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B1710: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B1714: 614ABEC8  ori r10, r10, 0xbec8
	ctx.r[10].u64 = ctx.r[10].u64 | 48840;
	// 821B1718: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B171C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821B1720: 7D79522E  lhzx r11, r25, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1724: 93BF0048  stw r29, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 821B1728: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 821B172C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B1730: 483839CC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1738 size=156
    let mut pc: u32 = 0x821B1738;
    'dispatch: loop {
        match pc {
            0x821B1738 => {
    //   block [0x821B1738..0x821B176C)
	// 821B1738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B173C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B1744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B174C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B1750: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B1754: 397E004C  addi r11, r30, 0x4c
	ctx.r[11].s64 = ctx.r[30].s64 + 76;
	// 821B1758: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B175C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1760: 409A000C  bne cr6, 0x821b176c
	if !ctx.cr[6].eq {
	pc = 0x821B176C; continue 'dispatch;
	}
	// 821B1764: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821B1768: 4800002C  b 0x821b1794
	pc = 0x821B1794; continue 'dispatch;
            }
            0x821B176C => {
    //   block [0x821B176C..0x821B1784)
	// 821B176C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1770: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1774: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B1778: 419A000C  beq cr6, 0x821b1784
	if ctx.cr[6].eq {
	pc = 0x821B1784; continue 'dispatch;
	}
	// 821B177C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821B1780: 48000014  b 0x821b1794
	pc = 0x821B1794; continue 'dispatch;
            }
            0x821B1784 => {
    //   block [0x821B1784..0x821B1794)
	// 821B1784: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1788: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821B178C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821B1790: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x821B1794; continue 'dispatch;
            }
            0x821B1794 => {
    //   block [0x821B1794..0x821B17B8)
	// 821B1794: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B1798: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B179C: 419A001C  beq cr6, 0x821b17b8
	if ctx.cr[6].eq {
	pc = 0x821B17B8; continue 'dispatch;
	}
	// 821B17A0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821B17A4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B17A8: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821B17AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B17B0: 419A0008  beq cr6, 0x821b17b8
	if ctx.cr[6].eq {
	pc = 0x821B17B8; continue 'dispatch;
	}
	// 821B17B4: 4BF6B8A5  bl 0x8211d058
	ctx.lr = 0x821B17B8;
	sub_8211D058(ctx, base);
	pc = 0x821B17B8; continue 'dispatch;
            }
            0x821B17B8 => {
    //   block [0x821B17B8..0x821B17D4)
	// 821B17B8: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 821B17BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B17C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B17C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B17C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B17CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B17D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B17D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B17D8 size=156
    let mut pc: u32 = 0x821B17D8;
    'dispatch: loop {
        match pc {
            0x821B17D8 => {
    //   block [0x821B17D8..0x821B17F0)
	// 821B17D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B17DC: 419A0014  beq cr6, 0x821b17f0
	if ctx.cr[6].eq {
	pc = 0x821B17F0; continue 'dispatch;
	}
	// 821B17E0: E9680000  ld r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821B17E4: E9430058  ld r10, 0x58(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	// 821B17E8: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 821B17EC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x821B17F0; continue 'dispatch;
            }
            0x821B17F0 => {
    //   block [0x821B17F0..0x821B1874)
	// 821B17F0: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B17F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B17F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B17FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1800: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B1804: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B1808: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 821B180C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821B1810: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 821B1814: 39450008  addi r10, r5, 8
	ctx.r[10].s64 = ctx.r[5].s64 + 8;
	// 821B1818: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B181C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1820: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B1824: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 821B1828: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B182C: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B1830: 616BBEC8  ori r11, r11, 0xbec8
	ctx.r[11].u64 = ctx.r[11].u64 | 48840;
	// 821B1834: 7D645A2E  lhzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1838: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B183C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821B1840: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B1844: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821B1848: C00BCFEC  lfs f0, -0x3014(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B184C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B1850: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1854: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B1858: C00B06A4  lfs f0, 0x6a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B185C: 90A3002C  stw r5, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 821B1860: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821B1864: 90C30030  stw r6, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[6].u32 ) };
	// 821B1868: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B186C: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 821B1870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1878 size=428
    let mut pc: u32 = 0x821B1878;
    'dispatch: loop {
        match pc {
            0x821B1878 => {
    //   block [0x821B1878..0x821B19B8)
	// 821B1878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B187C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1880: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1884: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B1888: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B188C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B1890: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1894: C14A1FF8  lfs f10, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B1898: D1460000  stfs f10, 0(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B189C: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 821B18A0: 91250000  stw r9, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B18A4: 409A0170  bne cr6, 0x821b1a14
	if !ctx.cr[6].eq {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B18A8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B18AC: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B18B0: 614ABEC8  ori r10, r10, 0xbec8
	ctx.r[10].u64 = ctx.r[10].u64 | 48840;
	// 821B18B4: 7D44522E  lhzx r10, r4, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B18B8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B18BC: 409A0158  bne cr6, 0x821b1a14
	if !ctx.cr[6].eq {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B18C0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821B18C4: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B18C8: FC00581E  fctiwz f0, f11
	ctx.f[0].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821B18CC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B18D0: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B18D4: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 821B18D8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B18DC: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 821B18E0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B18E4: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B18E8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B18EC: 1D4A0054  mulli r10, r10, 0x54
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 84 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821B18F0: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B18F4: A1070000  lhz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B18F8: A0670002  lhz r3, 2(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B18FC: 7D0A0734  extsh r10, r8
	ctx.r[10].s64 = ctx.r[8].s16 as i64;
	// 821B1900: 7C680734  extsh r8, r3
	ctx.r[8].s64 = ctx.r[3].s16 as i64;
	// 821B1904: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B1908: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821B190C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B1910: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1914: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B1918: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B191C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 821B1920: 40980098  bge cr6, 0x821b19b8
	if !ctx.cr[6].lt {
	pc = 0x821B19B8; continue 'dispatch;
	}
	// 821B1924: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1928: 1D4A000E  mulli r10, r10, 0xe
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 14 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821B192C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B1930: 3D206666  lis r9, 0x6666
	ctx.r[9].s64 = 1717960704;
	// 821B1934: 61286667  ori r8, r9, 0x6667
	ctx.r[8].u64 = ctx.r[9].u64 | 26215;
	// 821B1938: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B193C: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1940: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821B1944: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B1948: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821B194C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B1950: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B1954: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B1958: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B195C: C00923BC  lfs f0, 0x23bc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1960: 7D2A4096  mulhw r9, r10, r8
	ctx.r[9].s64 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) >> 32);
	// 821B1964: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B1968: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821B196C: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B1970: C9A82008  lfd f13, 0x2008(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8200 as u32) ) };
	// 821B1974: 55280FFE  srwi r8, r9, 0x1f
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B1978: FD80682E  fsel f12, f0, f0, f13
	ctx.f[12].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B197C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B1980: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821B1984: C8082000  lfd f0, 0x2000(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 821B1988: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B198C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B1990: FD2C0028  fsub f9, f12, f0
	ctx.f[9].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 821B1994: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821B1998: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B199C: FD89602E  fsel f12, f9, f0, f12
	ctx.f[12].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 821B19A0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821B19A4: FDAC6B2E  fsel f13, f12, f12, f13
	ctx.f[13].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 821B19A8: FD8D0028  fsub f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 821B19AC: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B19B0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B19B4: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821B19B8; continue 'dispatch;
            }
            0x821B19B8 => {
    //   block [0x821B19B8..0x821B1A14)
	// 821B19B8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B19BC: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 821B19C0: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B19C4: A1470002  lhz r10, 2(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B19C8: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 821B19CC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821B19D0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821B19D4: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B19D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B19DC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B19E0: C1AACFEC  lfs f13, -0x3014(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B19E4: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B19E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B19EC: 41980028  blt cr6, 0x821b1a14
	if ctx.cr[6].lt {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B19F0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B19F4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B19F8: D14B0034  stfs f10, 0x34(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B19FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1A00: 912B003C  stw r9, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 821B1A04: 419A0010  beq cr6, 0x821b1a14
	if ctx.cr[6].eq {
	pc = 0x821B1A14; continue 'dispatch;
	}
	// 821B1A08: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821B1A0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B1A10: 4E800421  bctrl
	ctx.lr = 0x821B1A14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B1A14 => {
    //   block [0x821B1A14..0x821B1A24)
	// 821B1A14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1A28 size=140
    let mut pc: u32 = 0x821B1A28;
    'dispatch: loop {
        match pc {
            0x821B1A28 => {
    //   block [0x821B1A28..0x821B1A60)
	// 821B1A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1A30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1A34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1A38: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B1A3C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B1A40: 614ABEC8  ori r10, r10, 0xbec8
	ctx.r[10].u64 = ctx.r[10].u64 | 48840;
	// 821B1A44: 6129BE64  ori r9, r9, 0xbe64
	ctx.r[9].u64 = ctx.r[9].u64 | 48740;
	// 821B1A48: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B1A4C: 7D43522E  lhzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1A50: 7FE348AE  lbzx r31, r3, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B1A54: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 821B1A58: 409A0008  bne cr6, 0x821b1a60
	if !ctx.cr[6].eq {
	pc = 0x821B1A60; continue 'dispatch;
	}
	// 821B1A5C: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	pc = 0x821B1A60; continue 'dispatch;
            }
            0x821B1A60 => {
    //   block [0x821B1A60..0x821B1AB4)
	// 821B1A60: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B1A64: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B1A68: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B1A6C: 394ACB28  addi r10, r10, -0x34d8
	ctx.r[10].s64 = ctx.r[10].s64 + -13528;
	// 821B1A70: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821B1A74: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B1A78: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821B1A7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1A84: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B1A88: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B1A8C: 4BFFFA8D  bl 0x821b1518
	ctx.lr = 0x821B1A90;
	sub_821B1518(ctx, base);
	// 821B1A90: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 821B1A94: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B1A98: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B1A9C: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 821B1AA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1AA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1AA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1AAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1AB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1AB8 size=416
    let mut pc: u32 = 0x821B1AB8;
    'dispatch: loop {
        match pc {
            0x821B1AB8 => {
    //   block [0x821B1AB8..0x821B1B1C)
	// 821B1AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1ABC: 483835FD  bl 0x825350b8
	ctx.lr = 0x821B1AC0;
	sub_82535080(ctx, base);
	// 821B1AC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1AC4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1AC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B1ACC: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821B1AD0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821B1AD4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B1AD8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B1ADC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B1AE0: 7D5D58AE  lbzx r10, r29, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1AE4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1AE8: 6167BEC8  ori r7, r11, 0xbec8
	ctx.r[7].u64 = ctx.r[11].u64 | 48840;
	// 821B1AEC: 409A0054  bne cr6, 0x821b1b40
	if !ctx.cr[6].eq {
	pc = 0x821B1B40; continue 'dispatch;
	}
	// 821B1AF0: 7D3D3A14  add r9, r29, r7
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[7].u64;
	// 821B1AF4: A1690000  lhz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1AF8: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 821B1AFC: 419A0028  beq cr6, 0x821b1b24
	if ctx.cr[6].eq {
	pc = 0x821B1B24; continue 'dispatch;
	}
	// 821B1B00: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821B1B04: 409A0018  bne cr6, 0x821b1b1c
	if !ctx.cr[6].eq {
	pc = 0x821B1B1C; continue 'dispatch;
	}
	// 821B1B08: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1B0C: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821B1B10: 7D7D5A2E  lhzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1B18: 409A000C  bne cr6, 0x821b1b24
	if !ctx.cr[6].eq {
	pc = 0x821B1B24; continue 'dispatch;
	}
	pc = 0x821B1B1C; continue 'dispatch;
            }
            0x821B1B1C => {
    //   block [0x821B1B1C..0x821B1B24)
	// 821B1B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1B20: 48000008  b 0x821b1b28
	pc = 0x821B1B28; continue 'dispatch;
            }
            0x821B1B24 => {
    //   block [0x821B1B24..0x821B1B28)
	// 821B1B24: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B1B28; continue 'dispatch;
            }
            0x821B1B28 => {
    //   block [0x821B1B28..0x821B1B40)
	// 821B1B28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1B30: 419A0010  beq cr6, 0x821b1b40
	if ctx.cr[6].eq {
	pc = 0x821B1B40; continue 'dispatch;
	}
	// 821B1B34: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 821B1B38: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821B1B3C: B1690000  sth r11, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x821B1B40; continue 'dispatch;
            }
            0x821B1B40 => {
    //   block [0x821B1B40..0x821B1B6C)
	// 821B1B40: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1B44: 3BEBCB28  addi r31, r11, -0x34d8
	ctx.r[31].s64 = ctx.r[11].s64 + -13528;
	// 821B1B48: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B1B4C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1B50: 557E2834  slwi r30, r11, 5
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B1B54: 7D3EFA14  add r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 821B1B58: 8169003C  lwz r11, 0x3c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1B5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1B60: 409A000C  bne cr6, 0x821b1b6c
	if !ctx.cr[6].eq {
	pc = 0x821B1B6C; continue 'dispatch;
	}
	// 821B1B64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B1B68: 4800000C  b 0x821b1b74
	pc = 0x821B1B74; continue 'dispatch;
            }
            0x821B1B6C => {
    //   block [0x821B1B6C..0x821B1B74)
	// 821B1B6C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1B70: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x821B1B74; continue 'dispatch;
            }
            0x821B1B74 => {
    //   block [0x821B1B74..0x821B1B90)
	// 821B1B74: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B1B78: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B1B7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1B80: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 821B1B84: 409A000C  bne cr6, 0x821b1b90
	if !ctx.cr[6].eq {
	pc = 0x821B1B90; continue 'dispatch;
	}
	// 821B1B88: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821B1B8C: 4800000C  b 0x821b1b98
	pc = 0x821B1B98; continue 'dispatch;
            }
            0x821B1B90 => {
    //   block [0x821B1B90..0x821B1B98)
	// 821B1B90: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1B94: 409900B8  ble cr6, 0x821b1c4c
	if !ctx.cr[6].gt {
	pc = 0x821B1C4C; continue 'dispatch;
	}
	pc = 0x821B1B98; continue 'dispatch;
            }
            0x821B1B98 => {
    //   block [0x821B1B98..0x821B1BE8)
	// 821B1B98: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B1B9C: 4098004C  bge cr6, 0x821b1be8
	if !ctx.cr[6].lt {
	pc = 0x821B1BE8; continue 'dispatch;
	}
	// 821B1BA0: 397F003C  addi r11, r31, 0x3c
	ctx.r[11].s64 = ctx.r[31].s64 + 60;
	// 821B1BA4: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1BA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1BAC: 419A007C  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1BB0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1BB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1BB8: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821B1BBC: 4BFFFC1D  bl 0x821b17d8
	ctx.lr = 0x821B1BC0;
	sub_821B17D8(ctx, base);
	// 821B1BC0: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 821B1BC4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B1BC8: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1BCC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1BD0: 419A0058  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1BD4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B1BD8: 938B003C  stw r28, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 821B1BDC: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1BE0: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1BE4: 48000044  b 0x821b1c28
	pc = 0x821B1C28; continue 'dispatch;
            }
            0x821B1BE8 => {
    //   block [0x821B1BE8..0x821B1C28)
	// 821B1BE8: 397F015C  addi r11, r31, 0x15c
	ctx.r[11].s64 = ctx.r[31].s64 + 348;
	// 821B1BEC: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1BF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1BF4: 419A0034  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1BF8: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 821B1BFC: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 821B1C00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B1C04: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B1C08: 4BFFFBD1  bl 0x821b17d8
	ctx.lr = 0x821B1C0C;
	sub_821B17D8(ctx, base);
	// 821B1C0C: 8169003C  lwz r11, 0x3c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1C10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B1C14: 419A0014  beq cr6, 0x821b1c28
	if ctx.cr[6].eq {
	pc = 0x821B1C28; continue 'dispatch;
	}
	// 821B1C18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1C1C: 9389003C  stw r28, 0x3c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 821B1C20: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1C24: D0090034  stfs f0, 0x34(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x821B1C28; continue 'dispatch;
            }
            0x821B1C28 => {
    //   block [0x821B1C28..0x821B1C40)
	// 821B1C28: 7D7D3A14  add r11, r29, r7
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[7].u64;
	// 821B1C2C: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1C30: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 821B1C34: 409A000C  bne cr6, 0x821b1c40
	if !ctx.cr[6].eq {
	pc = 0x821B1C40; continue 'dispatch;
	}
	// 821B1C38: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B1C3C: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	pc = 0x821B1C40; continue 'dispatch;
            }
            0x821B1C40 => {
    //   block [0x821B1C40..0x821B1C4C)
	// 821B1C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B1C44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B1C48: 483834C0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821B1C4C => {
    //   block [0x821B1C4C..0x821B1C58)
	// 821B1C4C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821B1C50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B1C54: 483834B4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B1C58 size=236
    let mut pc: u32 = 0x821B1C58;
    'dispatch: loop {
        match pc {
            0x821B1C58 => {
    //   block [0x821B1C58..0x821B1CA8)
	// 821B1C58: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B1C5C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1C60: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 821B1C64: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B1C68: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 821B1C6C: 6129BEC8  ori r9, r9, 0xbec8
	ctx.r[9].u64 = ctx.r[9].u64 | 48840;
	// 821B1C70: 6108BE64  ori r8, r8, 0xbe64
	ctx.r[8].u64 = ctx.r[8].u64 | 48740;
	// 821B1C74: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1C78: 7D4B4A2E  lhzx r10, r11, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B1C7C: 7D2B40AE  lbzx r9, r11, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B1C80: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B1C84: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 821B1C88: 419A0028  beq cr6, 0x821b1cb0
	if ctx.cr[6].eq {
	pc = 0x821B1CB0; continue 'dispatch;
	}
	// 821B1C8C: 2B0A0023  cmplwi cr6, r10, 0x23
	ctx.cr[6].compare_u32(ctx.r[10].u32, 35 as u32, &mut ctx.xer);
	// 821B1C90: 409A0018  bne cr6, 0x821b1ca8
	if !ctx.cr[6].eq {
	pc = 0x821B1CA8; continue 'dispatch;
	}
	// 821B1C94: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B1C98: 614AED6A  ori r10, r10, 0xed6a
	ctx.r[10].u64 = ctx.r[10].u64 | 60778;
	// 821B1C9C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1CA4: 409A000C  bne cr6, 0x821b1cb0
	if !ctx.cr[6].eq {
	pc = 0x821B1CB0; continue 'dispatch;
	}
	pc = 0x821B1CA8; continue 'dispatch;
            }
            0x821B1CA8 => {
    //   block [0x821B1CA8..0x821B1CB0)
	// 821B1CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1CAC: 48000008  b 0x821b1cb4
	pc = 0x821B1CB4; continue 'dispatch;
            }
            0x821B1CB0 => {
    //   block [0x821B1CB0..0x821B1CB4)
	// 821B1CB0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x821B1CB4; continue 'dispatch;
            }
            0x821B1CB4 => {
    //   block [0x821B1CB4..0x821B1CE8)
	// 821B1CB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1CB8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B1CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1CC0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1CC4: 396BCB28  addi r11, r11, -0x34d8
	ctx.r[11].s64 = ctx.r[11].s64 + -13528;
	// 821B1CC8: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1CCC: 419A0034  beq cr6, 0x821b1d00
	if ctx.cr[6].eq {
	pc = 0x821B1D00; continue 'dispatch;
	}
	// 821B1CD0: 814B00FC  lwz r10, 0xfc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 821B1CD4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1CD8: 419A0010  beq cr6, 0x821b1ce8
	if ctx.cr[6].eq {
	pc = 0x821B1CE8; continue 'dispatch;
	}
	// 821B1CDC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821B1CE0: D00B00F4  stfs f0, 0xf4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 821B1CE4: 914B00FC  stw r10, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	pc = 0x821B1CE8; continue 'dispatch;
            }
            0x821B1CE8 => {
    //   block [0x821B1CE8..0x821B1D00)
	// 821B1CE8: 814B021C  lwz r10, 0x21c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(540 as u32) ) } as u64;
	// 821B1CEC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1CF0: 419A0010  beq cr6, 0x821b1d00
	if ctx.cr[6].eq {
	pc = 0x821B1D00; continue 'dispatch;
	}
	// 821B1CF4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821B1CF8: D00B0214  stfs f0, 0x214(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(532 as u32), tmp.u32 ) };
	// 821B1CFC: 914B021C  stw r10, 0x21c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(540 as u32), ctx.r[10].u32 ) };
	pc = 0x821B1D00; continue 'dispatch;
            }
            0x821B1D00 => {
    //   block [0x821B1D00..0x821B1D24)
	// 821B1D00: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1D04: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821B1D08: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B1D0C: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B1D10: 80EA003C  lwz r7, 0x3c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1D14: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B1D18: 419A000C  beq cr6, 0x821b1d24
	if ctx.cr[6].eq {
	pc = 0x821B1D24; continue 'dispatch;
	}
	// 821B1D1C: D00A0034  stfs f0, 0x34(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1D20: 910A003C  stw r8, 0x3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	pc = 0x821B1D24; continue 'dispatch;
            }
            0x821B1D24 => {
    //   block [0x821B1D24..0x821B1D44)
	// 821B1D24: 396B0120  addi r11, r11, 0x120
	ctx.r[11].s64 = ctx.r[11].s64 + 288;
	// 821B1D28: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B1D2C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B1D30: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1D34: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B1D38: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B1D3C: 910B003C  stw r8, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 821B1D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1D48 size=344
    let mut pc: u32 = 0x821B1D48;
    'dispatch: loop {
        match pc {
            0x821B1D48 => {
    //   block [0x821B1D48..0x821B1DAC)
	// 821B1D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1D50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1D54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1D58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1D5C: 3FE30002  addis r31, r3, 2
	ctx.r[31].s64 = ctx.r[3].s64 + 131072;
	// 821B1D60: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821B1D64: 3BFFBEC8  addi r31, r31, -0x4138
	ctx.r[31].s64 = ctx.r[31].s64 + -16696;
	// 821B1D68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B1D6C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B1D70: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1D74: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821B1D78: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1D7C: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B1D80: 7D2358AE  lbzx r9, r3, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1D84: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1D88: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 821B1D8C: 419A0028  beq cr6, 0x821b1db4
	if ctx.cr[6].eq {
	pc = 0x821B1DB4; continue 'dispatch;
	}
	// 821B1D90: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 821B1D94: 409A0018  bne cr6, 0x821b1dac
	if !ctx.cr[6].eq {
	pc = 0x821B1DAC; continue 'dispatch;
	}
	// 821B1D98: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1D9C: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821B1DA0: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B1DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1DA8: 409A000C  bne cr6, 0x821b1db4
	if !ctx.cr[6].eq {
	pc = 0x821B1DB4; continue 'dispatch;
	}
	pc = 0x821B1DAC; continue 'dispatch;
            }
            0x821B1DAC => {
    //   block [0x821B1DAC..0x821B1DB4)
	// 821B1DAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B1DB0: 48000008  b 0x821b1db8
	pc = 0x821B1DB8; continue 'dispatch;
            }
            0x821B1DB4 => {
    //   block [0x821B1DB4..0x821B1DB8)
	// 821B1DB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821B1DB8; continue 'dispatch;
            }
            0x821B1DB8 => {
    //   block [0x821B1DB8..0x821B1E0C)
	// 821B1DB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B1DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1DC0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1DC4: 396BCB28  addi r11, r11, -0x34d8
	ctx.r[11].s64 = ctx.r[11].s64 + -13528;
	// 821B1DC8: 419A0084  beq cr6, 0x821b1e4c
	if ctx.cr[6].eq {
	pc = 0x821B1E4C; continue 'dispatch;
	}
	// 821B1DCC: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 821B1DD0: B15F0000  sth r10, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 821B1DD4: 814B00FC  lwz r10, 0xfc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 821B1DD8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821B1DDC: 409A0030  bne cr6, 0x821b1e0c
	if !ctx.cr[6].eq {
	pc = 0x821B1E0C; continue 'dispatch;
	}
	// 821B1DE0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1DE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1DE8: 386B00C0  addi r3, r11, 0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + 192;
	// 821B1DEC: 4BFFFA8D  bl 0x821b1878
	ctx.lr = 0x821B1DF0;
	sub_821B1878(ctx, base);
	// 821B1DF0: 39600023  li r11, 0x23
	ctx.r[11].s64 = 35;
	// 821B1DF4: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 821B1DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1E08: 4E800020  blr
	return;
            }
            0x821B1E0C => {
    //   block [0x821B1E0C..0x821B1E44)
	// 821B1E0C: 814B021C  lwz r10, 0x21c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(540 as u32) ) } as u64;
	// 821B1E10: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821B1E14: 409A0030  bne cr6, 0x821b1e44
	if !ctx.cr[6].eq {
	pc = 0x821B1E44; continue 'dispatch;
	}
	// 821B1E18: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1E1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1E20: 386B01E0  addi r3, r11, 0x1e0
	ctx.r[3].s64 = ctx.r[11].s64 + 480;
	// 821B1E24: 4BFFFA55  bl 0x821b1878
	ctx.lr = 0x821B1E28;
	sub_821B1878(ctx, base);
	// 821B1E28: 39600023  li r11, 0x23
	ctx.r[11].s64 = 35;
	// 821B1E2C: B17F0000  sth r11, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 821B1E30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1E3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1E40: 4E800020  blr
	return;
            }
            0x821B1E44 => {
    //   block [0x821B1E44..0x821B1E4C)
	// 821B1E44: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B1E48: B15F0000  sth r10, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	pc = 0x821B1E4C; continue 'dispatch;
            }
            0x821B1E4C => {
    //   block [0x821B1E4C..0x821B1E7C)
	// 821B1E4C: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1E50: 390B003C  addi r8, r11, 0x3c
	ctx.r[8].s64 = ctx.r[11].s64 + 60;
	// 821B1E54: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821B1E58: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B1E5C: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B1E60: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 821B1E64: 419A0018  beq cr6, 0x821b1e7c
	if ctx.cr[6].eq {
	pc = 0x821B1E7C; continue 'dispatch;
	}
	// 821B1E68: 392B015C  addi r9, r11, 0x15c
	ctx.r[9].s64 = ctx.r[11].s64 + 348;
	// 821B1E6C: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B1E70: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 821B1E74: 409A0018  bne cr6, 0x821b1e8c
	if !ctx.cr[6].eq {
	pc = 0x821B1E8C; continue 'dispatch;
	}
	// 821B1E78: 396B0120  addi r11, r11, 0x120
	ctx.r[11].s64 = ctx.r[11].s64 + 288;
	pc = 0x821B1E7C; continue 'dispatch;
            }
            0x821B1E7C => {
    //   block [0x821B1E7C..0x821B1E8C)
	// 821B1E7C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821B1E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B1E84: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B1E88: 4BFFF9F1  bl 0x821b1878
	ctx.lr = 0x821B1E8C;
	sub_821B1878(ctx, base);
	pc = 0x821B1E8C; continue 'dispatch;
            }
            0x821B1E8C => {
    //   block [0x821B1E8C..0x821B1EA0)
	// 821B1E8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B1E90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1E94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1E98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1E9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B1EA0 size=96
    let mut pc: u32 = 0x821B1EA0;
    'dispatch: loop {
        match pc {
            0x821B1EA0 => {
    //   block [0x821B1EA0..0x821B1F00)
	// 821B1EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B1EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B1EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B1EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1EB4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B1EB8: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B1EBC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B1EC0: 3BEBCB28  addi r31, r11, -0x34d8
	ctx.r[31].s64 = ctx.r[11].s64 + -13528;
	// 821B1EC4: 7D6350AE  lbzx r11, r3, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B1EC8: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821B1ECC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B1ED0: 557E2834  slwi r30, r11, 5
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B1ED4: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 821B1ED8: 4BFFF861  bl 0x821b1738
	ctx.lr = 0x821B1EDC;
	sub_821B1738(ctx, base);
	// 821B1EDC: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 821B1EE0: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821B1EE4: 4BFFF855  bl 0x821b1738
	ctx.lr = 0x821B1EE8;
	sub_821B1738(ctx, base);
	// 821B1EE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B1EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B1EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B1EF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B1EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B1EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B1F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B1F00 size=312
    let mut pc: u32 = 0x821B1F00;
    'dispatch: loop {
        match pc {
            0x821B1F00 => {
    //   block [0x821B1F00..0x821B1F34)
	// 821B1F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B1F04: 483831AD  bl 0x825350b0
	ctx.lr = 0x821B1F08;
	sub_82535080(ctx, base);
	// 821B1F08: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B1F0C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B1F10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B1F14: 3B800007  li r28, 7
	ctx.r[28].s64 = 7;
	// 821B1F18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B1F1C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B1F20: 3B6B0100  addi r27, r11, 0x100
	ctx.r[27].s64 = ctx.r[11].s64 + 256;
	// 821B1F24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B1F28: 3B5B1BC8  addi r26, r27, 0x1bc8
	ctx.r[26].s64 = ctx.r[27].s64 + 7112;
	// 821B1F2C: 3BFA000C  addi r31, r26, 0xc
	ctx.r[31].s64 = ctx.r[26].s64 + 12;
	// 821B1F30: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821B1F34; continue 'dispatch;
            }
            0x821B1F34 => {
    //   block [0x821B1F34..0x821B1F5C)
	// 821B1F34: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1F38: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 821B1F3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1F40: 915FFFF8  stw r10, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 821B1F44: 419A0018  beq cr6, 0x821b1f5c
	if ctx.cr[6].eq {
	pc = 0x821B1F5C; continue 'dispatch;
	}
	// 821B1F48: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1F4C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1F50: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1F54: 41990010  bgt cr6, 0x821b1f64
	if ctx.cr[6].gt {
	pc = 0x821B1F64; continue 'dispatch;
	}
	// 821B1F58: 48000008  b 0x821b1f60
	pc = 0x821B1F60; continue 'dispatch;
            }
            0x821B1F5C => {
    //   block [0x821B1F5C..0x821B1F60)
	// 821B1F5C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821B1F60; continue 'dispatch;
            }
            0x821B1F60 => {
    //   block [0x821B1F60..0x821B1F64)
	// 821B1F60: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821B1F64; continue 'dispatch;
            }
            0x821B1F64 => {
    //   block [0x821B1F64..0x821B1F84)
	// 821B1F64: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821B1F68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B1F6C: 419A0018  beq cr6, 0x821b1f84
	if ctx.cr[6].eq {
	pc = 0x821B1F84; continue 'dispatch;
	}
	// 821B1F70: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1F74: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821B1F78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B1F7C: 41990010  bgt cr6, 0x821b1f8c
	if ctx.cr[6].gt {
	pc = 0x821B1F8C; continue 'dispatch;
	}
	// 821B1F80: 48000008  b 0x821b1f88
	pc = 0x821B1F88; continue 'dispatch;
            }
            0x821B1F84 => {
    //   block [0x821B1F84..0x821B1F88)
	// 821B1F84: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821B1F88; continue 'dispatch;
            }
            0x821B1F88 => {
    //   block [0x821B1F88..0x821B1F8C)
	// 821B1F88: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821B1F8C; continue 'dispatch;
            }
            0x821B1F8C => {
    //   block [0x821B1F8C..0x821B1FC8)
	// 821B1F8C: 387FFFF4  addi r3, r31, -0xc
	ctx.r[3].s64 = ctx.r[31].s64 + -12;
	// 821B1F90: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B1F94: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B1F98: 4BF72381  bl 0x82124318
	ctx.lr = 0x821B1F9C;
	sub_82124318(ctx, base);
	// 821B1F9C: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 821B1FA0: 3BFF00A8  addi r31, r31, 0xa8
	ctx.r[31].s64 = ctx.r[31].s64 + 168;
	// 821B1FA4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B1FA8: 409AFF8C  bne cr6, 0x821b1f34
	if !ctx.cr[6].eq {
	pc = 0x821B1F34; continue 'dispatch;
	}
	// 821B1FAC: 387A0348  addi r3, r26, 0x348
	ctx.r[3].s64 = ctx.r[26].s64 + 840;
	// 821B1FB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B1FB4: 4BF72365  bl 0x82124318
	ctx.lr = 0x821B1FB8;
	sub_82124318(ctx, base);
	// 821B1FB8: 397B02BC  addi r11, r27, 0x2bc
	ctx.r[11].s64 = ctx.r[27].s64 + 700;
	// 821B1FBC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 821B1FC0: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B1FC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821B1FC8; continue 'dispatch;
            }
            0x821B1FC8 => {
    //   block [0x821B1FC8..0x821B2014)
	// 821B1FC8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B1FCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B1FD0: 4200FFF8  bdnz 0x821b1fc8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B1FC8; continue 'dispatch;
	}
	// 821B1FD4: D3FB1BC4  stfs f31, 0x1bc4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(7108 as u32), tmp.u32 ) };
	// 821B1FD8: 93DB1BC0  stw r30, 0x1bc0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(7104 as u32), ctx.r[30].u32 ) };
	// 821B1FDC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B1FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1FE4: 419A0030  beq cr6, 0x821b2014
	if ctx.cr[6].eq {
	pc = 0x821B2014; continue 'dispatch;
	}
	// 821B1FE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B1FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B1FF0: 419A0024  beq cr6, 0x821b2014
	if ctx.cr[6].eq {
	pc = 0x821B2014; continue 'dispatch;
	}
	// 821B1FF4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B1FF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B1FFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B2000: 816BFB08  lwz r11, -0x4f8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1272 as u32) ) } as u64;
	// 821B2004: D3FD003C  stfs f31, 0x3c(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B2008: 93DD0030  stw r30, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 821B200C: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 821B2010: 480010A9  bl 0x821b30b8
	ctx.lr = 0x821B2014;
	sub_821B30B8(ctx, base);
	pc = 0x821B2014; continue 'dispatch;
            }
            0x821B2014 => {
    //   block [0x821B2014..0x821B2038)
	// 821B2014: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B2018: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821B201C: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2020: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B2024: 915D0024  stw r10, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 821B2028: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821B202C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B2030: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B2034: 483830CC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B2038 size=3844
    let mut pc: u32 = 0x821B2038;
    'dispatch: loop {
        match pc {
            0x821B2038 => {
    //   block [0x821B2038..0x821B2098)
	// 821B2038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B203C: 4838306D  bl 0x825350a8
	ctx.lr = 0x821B2040;
	sub_82535080(ctx, base);
	// 821B2040: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 821B2044: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821B2048: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821B204C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2050: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B2054: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821B2058: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821B205C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821B2060: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821B2064: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2068: 3B8B0100  addi r28, r11, 0x100
	ctx.r[28].s64 = ctx.r[11].s64 + 256;
	// 821B206C: 3BFC1BC8  addi r31, r28, 0x1bc8
	ctx.r[31].s64 = ctx.r[28].s64 + 7112;
	// 821B2070: 419A0030  beq cr6, 0x821b20a0
	if ctx.cr[6].eq {
	pc = 0x821B20A0; continue 'dispatch;
	}
	// 821B2074: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B2078: 616B9CC0  ori r11, r11, 0x9cc0
	ctx.r[11].u64 = ctx.r[11].u64 | 40128;
	// 821B207C: 7D78582E  lwzx r11, r24, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B2080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B2084: 419A0014  beq cr6, 0x821b2098
	if ctx.cr[6].eq {
	pc = 0x821B2098; continue 'dispatch;
	}
	// 821B2088: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B208C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B2090: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821B2094: 4199001C  bgt cr6, 0x821b20b0
	if ctx.cr[6].gt {
	pc = 0x821B20B0; continue 'dispatch;
	}
	pc = 0x821B2098; continue 'dispatch;
            }
            0x821B2098 => {
    //   block [0x821B2098..0x821B20A0)
	// 821B2098: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B209C: 48000014  b 0x821b20b0
	pc = 0x821B20B0; continue 'dispatch;
            }
            0x821B20A0 => {
    //   block [0x821B20A0..0x821B20B0)
	// 821B20A0: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B20A4: 216B0001  subfic r11, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[11].s64;
	// 821B20A8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B20AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x821B20B0; continue 'dispatch;
            }
            0x821B20B0 => {
    //   block [0x821B20B0..0x821B20E4)
	// 821B20B0: 917B0028  stw r11, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821B20B4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B20B8: 815B0024  lwz r10, 0x24(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B20BC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B20C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B20C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B20C8: C3A91FF8  lfs f29, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B20CC: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B20D0: 419A00DC  beq cr6, 0x821b21ac
	if ctx.cr[6].eq {
	pc = 0x821B21AC; continue 'dispatch;
	}
	// 821B20D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B20D8: 419A0048  beq cr6, 0x821b2120
	if ctx.cr[6].eq {
	pc = 0x821B2120; continue 'dispatch;
	}
	// 821B20DC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821B20E0: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	pc = 0x821B20E4; continue 'dispatch;
            }
            0x821B20E4 => {
    //   block [0x821B20E4..0x821B2110)
	// 821B20E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B20E8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B20EC: 4BF7222D  bl 0x82124318
	ctx.lr = 0x821B20F0;
	sub_82124318(ctx, base);
	// 821B20F0: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 821B20F4: 3BBD00A8  addi r29, r29, 0xa8
	ctx.r[29].s64 = ctx.r[29].s64 + 168;
	// 821B20F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B20FC: 409AFFE8  bne cr6, 0x821b20e4
	if !ctx.cr[6].eq {
	pc = 0x821B20E4; continue 'dispatch;
	}
	// 821B2100: 397C02BC  addi r11, r28, 0x2bc
	ctx.r[11].s64 = ctx.r[28].s64 + 700;
	// 821B2104: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821B2108: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B210C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821B2110; continue 'dispatch;
            }
            0x821B2110 => {
    //   block [0x821B2110..0x821B2120)
	// 821B2110: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B2114: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B2118: 4200FFF8  bdnz 0x821b2110
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B2110; continue 'dispatch;
	}
	// 821B211C: 48000090  b 0x821b21ac
	pc = 0x821B21AC; continue 'dispatch;
            }
            0x821B2120 => {
    //   block [0x821B2120..0x821B2160)
	// 821B2120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B2124: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B2128: 4BF721F1  bl 0x82124318
	ctx.lr = 0x821B212C;
	sub_82124318(ctx, base);
	// 821B212C: 3880004F  li r4, 0x4f
	ctx.r[4].s64 = 79;
	// 821B2130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B2134: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B2138: 4BF72189  bl 0x821242c0
	ctx.lr = 0x821B213C;
	sub_821242C0(ctx, base);
	// 821B213C: 38800043  li r4, 0x43
	ctx.r[4].s64 = 67;
	// 821B2140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B2144: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821B2148: 4BF72179  bl 0x821242c0
	ctx.lr = 0x821B214C;
	sub_821242C0(ctx, base);
	// 821B214C: 3D203F59  lis r9, 0x3f59
	ctx.r[9].s64 = 1062797312;
	// 821B2150: 397C02BC  addi r11, r28, 0x2bc
	ctx.r[11].s64 = ctx.r[28].s64 + 700;
	// 821B2154: 6129999A  ori r9, r9, 0x999a
	ctx.r[9].u64 = ctx.r[9].u64 | 39322;
	// 821B2158: 39400023  li r10, 0x23
	ctx.r[10].s64 = 35;
	// 821B215C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821B2160; continue 'dispatch;
            }
            0x821B2160 => {
    //   block [0x821B2160..0x821B2190)
	// 821B2160: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B2164: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B2168: 4200FFF8  bdnz 0x821b2160
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B2160; continue 'dispatch;
	}
	// 821B216C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B2170: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B2174: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B2178: 614A8654  ori r10, r10, 0x8654
	ctx.r[10].u64 = ctx.r[10].u64 | 34388;
	// 821B217C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B2180: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 821B2184: 419A000C  beq cr6, 0x821b2190
	if ctx.cr[6].eq {
	pc = 0x821B2190; continue 'dispatch;
	}
	// 821B2188: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821B218C: 409A0020  bne cr6, 0x821b21ac
	if !ctx.cr[6].eq {
	pc = 0x821B21AC; continue 'dispatch;
	}
	pc = 0x821B2190; continue 'dispatch;
            }
            0x821B2190 => {
    //   block [0x821B2190..0x821B21A0)
	// 821B2190: 397C031C  addi r11, r28, 0x31c
	ctx.r[11].s64 = ctx.r[28].s64 + 796;
	// 821B2194: 3D203F40  lis r9, 0x3f40
	ctx.r[9].s64 = 1061158912;
	// 821B2198: 3940000B  li r10, 0xb
	ctx.r[10].s64 = 11;
	// 821B219C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821B21A0; continue 'dispatch;
            }
            0x821B21A0 => {
    //   block [0x821B21A0..0x821B21AC)
	// 821B21A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B21A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821B21A8: 4200FFF8  bdnz 0x821b21a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B21A0; continue 'dispatch;
	}
	pc = 0x821B21AC; continue 'dispatch;
            }
            0x821B21AC => {
    //   block [0x821B21AC..0x821B21D4)
	// 821B21AC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821B21B0: 419A0024  beq cr6, 0x821b21d4
	if ctx.cr[6].eq {
	pc = 0x821B21D4; continue 'dispatch;
	}
	// 821B21B4: 81780030  lwz r11, 0x30(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B21B8: 38780030  addi r3, r24, 0x30
	ctx.r[3].s64 = ctx.r[24].s64 + 48;
	// 821B21BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B21C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B21C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B21C8: 4E800421  bctrl
	ctx.lr = 0x821B21CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B21CC: 907C2060  stw r3, 0x2060(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8288 as u32), ctx.r[3].u32 ) };
	// 821B21D0: 48000008  b 0x821b21d8
	pc = 0x821B21D8; continue 'dispatch;
            }
            0x821B21D4 => {
    //   block [0x821B21D4..0x821B21D8)
	// 821B21D4: 933C2060  stw r25, 0x2060(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8288 as u32), ctx.r[25].u32 ) };
	pc = 0x821B21D8; continue 'dispatch;
            }
            0x821B21D8 => {
    //   block [0x821B21D8..0x821B21F0)
	// 821B21D8: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B21DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B21E0: 419A0010  beq cr6, 0x821b21f0
	if ctx.cr[6].eq {
	pc = 0x821B21F0; continue 'dispatch;
	}
	// 821B21E4: D3BB0014  stfs f29, 0x14(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B21E8: D3BB003C  stfs f29, 0x3c(r27)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B21EC: D3DB0040  stfs f30, 0x40(r27)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x821B21F0; continue 'dispatch;
            }
            0x821B21F0 => {
    //   block [0x821B21F0..0x821B2208)
	// 821B21F0: C01B0014  lfs f0, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B21F4: 397F0150  addi r11, r31, 0x150
	ctx.r[11].s64 = ctx.r[31].s64 + 336;
	// 821B21F8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821B21FC: 4098000C  bge cr6, 0x821b2208
	if !ctx.cr[6].lt {
	pc = 0x821B2208; continue 'dispatch;
	}
	// 821B2200: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821B2204: 48000010  b 0x821b2214
	pc = 0x821B2214; continue 'dispatch;
            }
            0x821B2208 => {
    //   block [0x821B2208..0x821B2214)
	// 821B2208: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821B220C: 40990008  ble cr6, 0x821b2214
	if !ctx.cr[6].gt {
	pc = 0x821B2214; continue 'dispatch;
	}
	// 821B2210: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x821B2214; continue 'dispatch;
            }
            0x821B2214 => {
    //   block [0x821B2214..0x821B2250)
	// 821B2214: C1BB0044  lfs f13, 0x44(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2218: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B221C: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B2220: C3EA2150  lfs f31, 0x2150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8528 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B2224: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2228: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B222C: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821B2230: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B2234: EDBE0028  fsubs f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B2238: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B223C: 40980014  bge cr6, 0x821b2250
	if !ctx.cr[6].lt {
	pc = 0x821B2250; continue 'dispatch;
	}
	// 821B2240: 3980FF7F  li r12, -0x81
	ctx.r[12].s64 = -129;
	// 821B2244: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2248: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B224C: 48000010  b 0x821b225c
	pc = 0x821B225C; continue 'dispatch;
            }
            0x821B2250 => {
    //   block [0x821B2250..0x821B225C)
	// 821B2250: 614A0080  ori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 128;
	// 821B2254: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2258: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x821B225C; continue 'dispatch;
            }
            0x821B225C => {
    //   block [0x821B225C..0x821B2278)
	// 821B225C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2260: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2264: 40980014  bge cr6, 0x821b2278
	if !ctx.cr[6].lt {
	pc = 0x821B2278; continue 'dispatch;
	}
	// 821B2268: 3980FF7F  li r12, -0x81
	ctx.r[12].s64 = -129;
	// 821B226C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2270: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2274: 48000010  b 0x821b2284
	pc = 0x821B2284; continue 'dispatch;
            }
            0x821B2278 => {
    //   block [0x821B2278..0x821B2284)
	// 821B2278: 614A0080  ori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 128;
	// 821B227C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2280: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x821B2284; continue 'dispatch;
            }
            0x821B2284 => {
    //   block [0x821B2284..0x821B22A0)
	// 821B2284: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2288: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B228C: 40980014  bge cr6, 0x821b22a0
	if !ctx.cr[6].lt {
	pc = 0x821B22A0; continue 'dispatch;
	}
	// 821B2290: 3980FEFF  li r12, -0x101
	ctx.r[12].s64 = -257;
	// 821B2294: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2298: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B229C: 48000010  b 0x821b22ac
	pc = 0x821B22AC; continue 'dispatch;
            }
            0x821B22A0 => {
    //   block [0x821B22A0..0x821B22AC)
	// 821B22A0: 614A0100  ori r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 256;
	// 821B22A4: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22A8: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x821B22AC; continue 'dispatch;
            }
            0x821B22AC => {
    //   block [0x821B22AC..0x821B22C8)
	// 821B22AC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B22B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B22B4: 40980014  bge cr6, 0x821b22c8
	if !ctx.cr[6].lt {
	pc = 0x821B22C8; continue 'dispatch;
	}
	// 821B22B8: 3980FEFF  li r12, -0x101
	ctx.r[12].s64 = -257;
	// 821B22BC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B22C0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22C4: 48000010  b 0x821b22d4
	pc = 0x821B22D4; continue 'dispatch;
            }
            0x821B22C8 => {
    //   block [0x821B22C8..0x821B22D4)
	// 821B22C8: 614A0100  ori r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 256;
	// 821B22CC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22D0: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x821B22D4; continue 'dispatch;
            }
            0x821B22D4 => {
    //   block [0x821B22D4..0x821B22F4)
	// 821B22D4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B22D8: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B22DC: 40980018  bge cr6, 0x821b22f4
	if !ctx.cr[6].lt {
	pc = 0x821B22F4; continue 'dispatch;
	}
	// 821B22E0: 3D80FFF7  lis r12, -9
	ctx.r[12].s64 = -589824;
	// 821B22E4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B22E8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B22EC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22F0: 48000010  b 0x821b2300
	pc = 0x821B2300; continue 'dispatch;
            }
            0x821B22F4 => {
    //   block [0x821B22F4..0x821B2300)
	// 821B22F4: 654A0008  oris r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 524288;
	// 821B22F8: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B22FC: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x821B2300; continue 'dispatch;
            }
            0x821B2300 => {
    //   block [0x821B2300..0x821B2320)
	// 821B2300: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2304: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2308: 40980018  bge cr6, 0x821b2320
	if !ctx.cr[6].lt {
	pc = 0x821B2320; continue 'dispatch;
	}
	// 821B230C: 3D80FFF7  lis r12, -9
	ctx.r[12].s64 = -589824;
	// 821B2310: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2314: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2318: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B231C: 48000010  b 0x821b232c
	pc = 0x821B232C; continue 'dispatch;
            }
            0x821B2320 => {
    //   block [0x821B2320..0x821B232C)
	// 821B2320: 654A0008  oris r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 524288;
	// 821B2324: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2328: D00B0064  stfs f0, 0x64(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x821B232C; continue 'dispatch;
            }
            0x821B232C => {
    //   block [0x821B232C..0x821B234C)
	// 821B232C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2330: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B2334: 40980018  bge cr6, 0x821b234c
	if !ctx.cr[6].lt {
	pc = 0x821B234C; continue 'dispatch;
	}
	// 821B2338: 3D80FFEF  lis r12, -0x11
	ctx.r[12].s64 = -1114112;
	// 821B233C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2340: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2344: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2348: 48000010  b 0x821b2358
	pc = 0x821B2358; continue 'dispatch;
            }
            0x821B234C => {
    //   block [0x821B234C..0x821B2358)
	// 821B234C: 654A0010  oris r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 1048576;
	// 821B2350: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2354: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x821B2358; continue 'dispatch;
            }
            0x821B2358 => {
    //   block [0x821B2358..0x821B2378)
	// 821B2358: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B235C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2360: 40980018  bge cr6, 0x821b2378
	if !ctx.cr[6].lt {
	pc = 0x821B2378; continue 'dispatch;
	}
	// 821B2364: 3D80FFEF  lis r12, -0x11
	ctx.r[12].s64 = -1114112;
	// 821B2368: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B236C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2370: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2374: 48000010  b 0x821b2384
	pc = 0x821B2384; continue 'dispatch;
            }
            0x821B2378 => {
    //   block [0x821B2378..0x821B2384)
	// 821B2378: 654A0010  oris r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 1048576;
	// 821B237C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2380: D00B0068  stfs f0, 0x68(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x821B2384; continue 'dispatch;
            }
            0x821B2384 => {
    //   block [0x821B2384..0x821B23CC)
	// 821B2384: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821B2388: 419A0738  beq cr6, 0x821b2ac0
	if ctx.cr[6].eq {
	pc = 0x821B2AC0; continue 'dispatch;
	}
	// 821B238C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B2390: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 821B2394: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821B2398: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B239C: 4BFFF9AD  bl 0x821b1d48
	ctx.lr = 0x821B23A0;
	sub_821B1D48(ctx, base);
	// 821B23A0: C01B0034  lfs f0, 0x34(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B23A4: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B23A8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B23AC: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B23B0: 397F00A8  addi r11, r31, 0xa8
	ctx.r[11].s64 = ctx.r[31].s64 + 168;
	// 821B23B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B23B8: EDBE0028  fsubs f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B23BC: 419A0010  beq cr6, 0x821b23cc
	if ctx.cr[6].eq {
	pc = 0x821B23CC; continue 'dispatch;
	}
	// 821B23C0: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B23C4: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B23C8: 48000008  b 0x821b23d0
	pc = 0x821B23D0; continue 'dispatch;
            }
            0x821B23CC => {
    //   block [0x821B23CC..0x821B23D0)
	// 821B23CC: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x821B23D0; continue 'dispatch;
            }
            0x821B23D0 => {
    //   block [0x821B23D0..0x821B23F0)
	// 821B23D0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B23D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B23D8: 419A0024  beq cr6, 0x821b23fc
	if ctx.cr[6].eq {
	pc = 0x821B23FC; continue 'dispatch;
	}
	// 821B23DC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B23E0: 41980010  blt cr6, 0x821b23f0
	if ctx.cr[6].lt {
	pc = 0x821B23F0; continue 'dispatch;
	}
	// 821B23E4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B23E8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B23EC: 41980014  blt cr6, 0x821b2400
	if ctx.cr[6].lt {
	pc = 0x821B2400; continue 'dispatch;
	}
	pc = 0x821B23F0; continue 'dispatch;
            }
            0x821B23F0 => {
    //   block [0x821B23F0..0x821B23FC)
	// 821B23F0: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B23F4: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B23F8: 4800000C  b 0x821b2404
	pc = 0x821B2404; continue 'dispatch;
            }
            0x821B23FC => {
    //   block [0x821B23FC..0x821B2400)
	// 821B23FC: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B2400; continue 'dispatch;
            }
            0x821B2400 => {
    //   block [0x821B2400..0x821B2404)
	// 821B2400: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x821B2404; continue 'dispatch;
            }
            0x821B2404 => {
    //   block [0x821B2404..0x821B241C)
	// 821B2404: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2408: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B240C: 40980010  bge cr6, 0x821b241c
	if !ctx.cr[6].lt {
	pc = 0x821B241C; continue 'dispatch;
	}
	// 821B2410: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 821B2414: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2418: 48000010  b 0x821b2428
	pc = 0x821B2428; continue 'dispatch;
            }
            0x821B241C => {
    //   block [0x821B241C..0x821B2428)
	// 821B241C: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821B2420: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2424: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x821B2428; continue 'dispatch;
            }
            0x821B2428 => {
    //   block [0x821B2428..0x821B2440)
	// 821B2428: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B242C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2430: 40980010  bge cr6, 0x821b2440
	if !ctx.cr[6].lt {
	pc = 0x821B2440; continue 'dispatch;
	}
	// 821B2434: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 821B2438: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B243C: 48000010  b 0x821b244c
	pc = 0x821B244C; continue 'dispatch;
            }
            0x821B2440 => {
    //   block [0x821B2440..0x821B244C)
	// 821B2440: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821B2444: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2448: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x821B244C; continue 'dispatch;
            }
            0x821B244C => {
    //   block [0x821B244C..0x821B2468)
	// 821B244C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2450: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B2454: 40980014  bge cr6, 0x821b2468
	if !ctx.cr[6].lt {
	pc = 0x821B2468; continue 'dispatch;
	}
	// 821B2458: 3980FFFD  li r12, -3
	ctx.r[12].s64 = -3;
	// 821B245C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2460: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2464: 48000010  b 0x821b2474
	pc = 0x821B2474; continue 'dispatch;
            }
            0x821B2468 => {
    //   block [0x821B2468..0x821B2474)
	// 821B2468: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821B246C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2470: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x821B2474; continue 'dispatch;
            }
            0x821B2474 => {
    //   block [0x821B2474..0x821B2490)
	// 821B2474: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2478: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B247C: 40980014  bge cr6, 0x821b2490
	if !ctx.cr[6].lt {
	pc = 0x821B2490; continue 'dispatch;
	}
	// 821B2480: 3980FFFD  li r12, -3
	ctx.r[12].s64 = -3;
	// 821B2484: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2488: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B248C: 48000010  b 0x821b249c
	pc = 0x821B249C; continue 'dispatch;
            }
            0x821B2490 => {
    //   block [0x821B2490..0x821B249C)
	// 821B2490: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821B2494: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2498: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x821B249C; continue 'dispatch;
            }
            0x821B249C => {
    //   block [0x821B249C..0x821B24B8)
	// 821B249C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B24A0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B24A4: 40980014  bge cr6, 0x821b24b8
	if !ctx.cr[6].lt {
	pc = 0x821B24B8; continue 'dispatch;
	}
	// 821B24A8: 3980EFFF  li r12, -0x1001
	ctx.r[12].s64 = -4097;
	// 821B24AC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B24B0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24B4: 48000010  b 0x821b24c4
	pc = 0x821B24C4; continue 'dispatch;
            }
            0x821B24B8 => {
    //   block [0x821B24B8..0x821B24C4)
	// 821B24B8: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	// 821B24BC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24C0: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x821B24C4; continue 'dispatch;
            }
            0x821B24C4 => {
    //   block [0x821B24C4..0x821B24E0)
	// 821B24C4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B24C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B24CC: 40980014  bge cr6, 0x821b24e0
	if !ctx.cr[6].lt {
	pc = 0x821B24E0; continue 'dispatch;
	}
	// 821B24D0: 3980EFFF  li r12, -0x1001
	ctx.r[12].s64 = -4097;
	// 821B24D4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B24D8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24DC: 48000010  b 0x821b24ec
	pc = 0x821B24EC; continue 'dispatch;
            }
            0x821B24E0 => {
    //   block [0x821B24E0..0x821B24EC)
	// 821B24E0: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	// 821B24E4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B24E8: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x821B24EC; continue 'dispatch;
            }
            0x821B24EC => {
    //   block [0x821B24EC..0x821B2508)
	// 821B24EC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B24F0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 821B24F4: 40980014  bge cr6, 0x821b2508
	if !ctx.cr[6].lt {
	pc = 0x821B2508; continue 'dispatch;
	}
	// 821B24F8: 3980DFFF  li r12, -0x2001
	ctx.r[12].s64 = -8193;
	// 821B24FC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2500: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2504: 48000010  b 0x821b2514
	pc = 0x821B2514; continue 'dispatch;
            }
            0x821B2508 => {
    //   block [0x821B2508..0x821B2514)
	// 821B2508: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 821B250C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2510: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x821B2514; continue 'dispatch;
            }
            0x821B2514 => {
    //   block [0x821B2514..0x821B2530)
	// 821B2514: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2518: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B251C: 40980014  bge cr6, 0x821b2530
	if !ctx.cr[6].lt {
	pc = 0x821B2530; continue 'dispatch;
	}
	// 821B2520: 3980DFFF  li r12, -0x2001
	ctx.r[12].s64 = -8193;
	// 821B2524: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2528: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B252C: 48000010  b 0x821b253c
	pc = 0x821B253C; continue 'dispatch;
            }
            0x821B2530 => {
    //   block [0x821B2530..0x821B253C)
	// 821B2530: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 821B2534: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2538: D00B004C  stfs f0, 0x4c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x821B253C; continue 'dispatch;
            }
            0x821B253C => {
    //   block [0x821B253C..0x821B2564)
	// 821B253C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2540: EC1E6028  fsubs f0, f30, f12
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B2544: 397F01F8  addi r11, r31, 0x1f8
	ctx.r[11].s64 = ctx.r[31].s64 + 504;
	// 821B2548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B254C: 419A0018  beq cr6, 0x821b2564
	if ctx.cr[6].eq {
	pc = 0x821B2564; continue 'dispatch;
	}
	// 821B2550: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B2554: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B2558: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 821B255C: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B2560: 48000008  b 0x821b2568
	pc = 0x821B2568; continue 'dispatch;
            }
            0x821B2564 => {
    //   block [0x821B2564..0x821B2568)
	// 821B2564: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x821B2568; continue 'dispatch;
            }
            0x821B2568 => {
    //   block [0x821B2568..0x821B2588)
	// 821B2568: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B256C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B2570: 419A0024  beq cr6, 0x821b2594
	if ctx.cr[6].eq {
	pc = 0x821B2594; continue 'dispatch;
	}
	// 821B2574: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B2578: 41980010  blt cr6, 0x821b2588
	if ctx.cr[6].lt {
	pc = 0x821B2588; continue 'dispatch;
	}
	// 821B257C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2580: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B2584: 41980014  blt cr6, 0x821b2598
	if ctx.cr[6].lt {
	pc = 0x821B2598; continue 'dispatch;
	}
	pc = 0x821B2588; continue 'dispatch;
            }
            0x821B2588 => {
    //   block [0x821B2588..0x821B2594)
	// 821B2588: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B258C: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B2590: 4800000C  b 0x821b259c
	pc = 0x821B259C; continue 'dispatch;
            }
            0x821B2594 => {
    //   block [0x821B2594..0x821B2598)
	// 821B2594: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B2598; continue 'dispatch;
            }
            0x821B2598 => {
    //   block [0x821B2598..0x821B259C)
	// 821B2598: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x821B259C; continue 'dispatch;
            }
            0x821B259C => {
    //   block [0x821B259C..0x821B25B8)
	// 821B259C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B25A0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B25A4: 40980014  bge cr6, 0x821b25b8
	if !ctx.cr[6].lt {
	pc = 0x821B25B8; continue 'dispatch;
	}
	// 821B25A8: 3980FDFF  li r12, -0x201
	ctx.r[12].s64 = -513;
	// 821B25AC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B25B0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25B4: 48000010  b 0x821b25c4
	pc = 0x821B25C4; continue 'dispatch;
            }
            0x821B25B8 => {
    //   block [0x821B25B8..0x821B25C4)
	// 821B25B8: 614A0200  ori r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 512;
	// 821B25BC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25C0: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x821B25C4; continue 'dispatch;
            }
            0x821B25C4 => {
    //   block [0x821B25C4..0x821B25E0)
	// 821B25C4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B25C8: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B25CC: 40980014  bge cr6, 0x821b25e0
	if !ctx.cr[6].lt {
	pc = 0x821B25E0; continue 'dispatch;
	}
	// 821B25D0: 3980FDFF  li r12, -0x201
	ctx.r[12].s64 = -513;
	// 821B25D4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B25D8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25DC: 48000010  b 0x821b25ec
	pc = 0x821B25EC; continue 'dispatch;
            }
            0x821B25E0 => {
    //   block [0x821B25E0..0x821B25EC)
	// 821B25E0: 614A0200  ori r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 512;
	// 821B25E4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B25E8: D18B003C  stfs f12, 0x3c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x821B25EC; continue 'dispatch;
            }
            0x821B25EC => {
    //   block [0x821B25EC..0x821B2608)
	// 821B25EC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B25F0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B25F4: 40980014  bge cr6, 0x821b2608
	if !ctx.cr[6].lt {
	pc = 0x821B2608; continue 'dispatch;
	}
	// 821B25F8: 3980FBFF  li r12, -0x401
	ctx.r[12].s64 = -1025;
	// 821B25FC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2600: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2604: 48000010  b 0x821b2614
	pc = 0x821B2614; continue 'dispatch;
            }
            0x821B2608 => {
    //   block [0x821B2608..0x821B2614)
	// 821B2608: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 821B260C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2610: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x821B2614; continue 'dispatch;
            }
            0x821B2614 => {
    //   block [0x821B2614..0x821B2630)
	// 821B2614: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2618: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B261C: 40980014  bge cr6, 0x821b2630
	if !ctx.cr[6].lt {
	pc = 0x821B2630; continue 'dispatch;
	}
	// 821B2620: 3980FBFF  li r12, -0x401
	ctx.r[12].s64 = -1025;
	// 821B2624: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2628: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B262C: 48000010  b 0x821b263c
	pc = 0x821B263C; continue 'dispatch;
            }
            0x821B2630 => {
    //   block [0x821B2630..0x821B263C)
	// 821B2630: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 821B2634: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2638: D18B0040  stfs f12, 0x40(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x821B263C; continue 'dispatch;
            }
            0x821B263C => {
    //   block [0x821B263C..0x821B2658)
	// 821B263C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2640: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2644: 40980014  bge cr6, 0x821b2658
	if !ctx.cr[6].lt {
	pc = 0x821B2658; continue 'dispatch;
	}
	// 821B2648: 3980F7FF  li r12, -0x801
	ctx.r[12].s64 = -2049;
	// 821B264C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2650: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2654: 48000010  b 0x821b2664
	pc = 0x821B2664; continue 'dispatch;
            }
            0x821B2658 => {
    //   block [0x821B2658..0x821B2664)
	// 821B2658: 614A0800  ori r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 2048;
	// 821B265C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2660: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x821B2664; continue 'dispatch;
            }
            0x821B2664 => {
    //   block [0x821B2664..0x821B2680)
	// 821B2664: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2668: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B266C: 40980014  bge cr6, 0x821b2680
	if !ctx.cr[6].lt {
	pc = 0x821B2680; continue 'dispatch;
	}
	// 821B2670: 3980F7FF  li r12, -0x801
	ctx.r[12].s64 = -2049;
	// 821B2674: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2678: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B267C: 48000010  b 0x821b268c
	pc = 0x821B268C; continue 'dispatch;
            }
            0x821B2680 => {
    //   block [0x821B2680..0x821B268C)
	// 821B2680: 614A0800  ori r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 2048;
	// 821B2684: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2688: D18B0044  stfs f12, 0x44(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x821B268C; continue 'dispatch;
            }
            0x821B268C => {
    //   block [0x821B268C..0x821B26AC)
	// 821B268C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2690: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2694: 40980018  bge cr6, 0x821b26ac
	if !ctx.cr[6].lt {
	pc = 0x821B26AC; continue 'dispatch;
	}
	// 821B2698: 3D80FFDF  lis r12, -0x21
	ctx.r[12].s64 = -2162688;
	// 821B269C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B26A0: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B26A4: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26A8: 48000010  b 0x821b26b8
	pc = 0x821B26B8; continue 'dispatch;
            }
            0x821B26AC => {
    //   block [0x821B26AC..0x821B26B8)
	// 821B26AC: 654A0020  oris r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 2097152;
	// 821B26B0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26B4: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	pc = 0x821B26B8; continue 'dispatch;
            }
            0x821B26B8 => {
    //   block [0x821B26B8..0x821B26D8)
	// 821B26B8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B26BC: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B26C0: 40980018  bge cr6, 0x821b26d8
	if !ctx.cr[6].lt {
	pc = 0x821B26D8; continue 'dispatch;
	}
	// 821B26C4: 3D80FFDF  lis r12, -0x21
	ctx.r[12].s64 = -2162688;
	// 821B26C8: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B26CC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B26D0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26D4: 48000010  b 0x821b26e4
	pc = 0x821B26E4; continue 'dispatch;
            }
            0x821B26D8 => {
    //   block [0x821B26D8..0x821B26E4)
	// 821B26D8: 654A0020  oris r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 2097152;
	// 821B26DC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B26E0: D18B006C  stfs f12, 0x6c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	pc = 0x821B26E4; continue 'dispatch;
            }
            0x821B26E4 => {
    //   block [0x821B26E4..0x821B2704)
	// 821B26E4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B26E8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B26EC: 40980018  bge cr6, 0x821b2704
	if !ctx.cr[6].lt {
	pc = 0x821B2704; continue 'dispatch;
	}
	// 821B26F0: 3D80FFBF  lis r12, -0x41
	ctx.r[12].s64 = -4259840;
	// 821B26F4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B26F8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B26FC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2700: 48000010  b 0x821b2710
	pc = 0x821B2710; continue 'dispatch;
            }
            0x821B2704 => {
    //   block [0x821B2704..0x821B2710)
	// 821B2704: 654A0040  oris r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 4194304;
	// 821B2708: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B270C: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x821B2710; continue 'dispatch;
            }
            0x821B2710 => {
    //   block [0x821B2710..0x821B2730)
	// 821B2710: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2714: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2718: 40980018  bge cr6, 0x821b2730
	if !ctx.cr[6].lt {
	pc = 0x821B2730; continue 'dispatch;
	}
	// 821B271C: 3D80FFBF  lis r12, -0x41
	ctx.r[12].s64 = -4259840;
	// 821B2720: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2724: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2728: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B272C: 48000010  b 0x821b273c
	pc = 0x821B273C; continue 'dispatch;
            }
            0x821B2730 => {
    //   block [0x821B2730..0x821B273C)
	// 821B2730: 654A0040  oris r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 4194304;
	// 821B2734: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2738: D18B0070  stfs f12, 0x70(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x821B273C; continue 'dispatch;
            }
            0x821B273C => {
    //   block [0x821B273C..0x821B275C)
	// 821B273C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2740: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2744: 40980018  bge cr6, 0x821b275c
	if !ctx.cr[6].lt {
	pc = 0x821B275C; continue 'dispatch;
	}
	// 821B2748: 3D80FF7F  lis r12, -0x81
	ctx.r[12].s64 = -8454144;
	// 821B274C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2750: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2754: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2758: 48000010  b 0x821b2768
	pc = 0x821B2768; continue 'dispatch;
            }
            0x821B275C => {
    //   block [0x821B275C..0x821B2768)
	// 821B275C: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 821B2760: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2764: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x821B2768; continue 'dispatch;
            }
            0x821B2768 => {
    //   block [0x821B2768..0x821B2788)
	// 821B2768: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B276C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2770: 40980018  bge cr6, 0x821b2788
	if !ctx.cr[6].lt {
	pc = 0x821B2788; continue 'dispatch;
	}
	// 821B2774: 3D80FF7F  lis r12, -0x81
	ctx.r[12].s64 = -8454144;
	// 821B2778: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B277C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2780: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2784: 48000010  b 0x821b2794
	pc = 0x821B2794; continue 'dispatch;
            }
            0x821B2788 => {
    //   block [0x821B2788..0x821B2794)
	// 821B2788: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 821B278C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2790: D18B0074  stfs f12, 0x74(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x821B2794; continue 'dispatch;
            }
            0x821B2794 => {
    //   block [0x821B2794..0x821B27B4)
	// 821B2794: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2798: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B279C: 40980018  bge cr6, 0x821b27b4
	if !ctx.cr[6].lt {
	pc = 0x821B27B4; continue 'dispatch;
	}
	// 821B27A0: 3D80FEFF  lis r12, -0x101
	ctx.r[12].s64 = -16842752;
	// 821B27A4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B27A8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B27AC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27B0: 48000010  b 0x821b27c0
	pc = 0x821B27C0; continue 'dispatch;
            }
            0x821B27B4 => {
    //   block [0x821B27B4..0x821B27C0)
	// 821B27B4: 654A0100  oris r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 16777216;
	// 821B27B8: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27BC: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x821B27C0; continue 'dispatch;
            }
            0x821B27C0 => {
    //   block [0x821B27C0..0x821B27E0)
	// 821B27C0: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B27C4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B27C8: 40980018  bge cr6, 0x821b27e0
	if !ctx.cr[6].lt {
	pc = 0x821B27E0; continue 'dispatch;
	}
	// 821B27CC: 3D80FEFF  lis r12, -0x101
	ctx.r[12].s64 = -16842752;
	// 821B27D0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B27D4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B27D8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27DC: 48000010  b 0x821b27ec
	pc = 0x821B27EC; continue 'dispatch;
            }
            0x821B27E0 => {
    //   block [0x821B27E0..0x821B27EC)
	// 821B27E0: 654A0100  oris r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 16777216;
	// 821B27E4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B27E8: D18B0078  stfs f12, 0x78(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x821B27EC; continue 'dispatch;
            }
            0x821B27EC => {
    //   block [0x821B27EC..0x821B280C)
	// 821B27EC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B27F0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B27F4: 40980018  bge cr6, 0x821b280c
	if !ctx.cr[6].lt {
	pc = 0x821B280C; continue 'dispatch;
	}
	// 821B27F8: 3D80FDFF  lis r12, -0x201
	ctx.r[12].s64 = -33619968;
	// 821B27FC: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2800: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2804: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2808: 48000010  b 0x821b2818
	pc = 0x821B2818; continue 'dispatch;
            }
            0x821B280C => {
    //   block [0x821B280C..0x821B2818)
	// 821B280C: 654A0200  oris r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 33554432;
	// 821B2810: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2814: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x821B2818; continue 'dispatch;
            }
            0x821B2818 => {
    //   block [0x821B2818..0x821B2838)
	// 821B2818: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B281C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2820: 40980018  bge cr6, 0x821b2838
	if !ctx.cr[6].lt {
	pc = 0x821B2838; continue 'dispatch;
	}
	// 821B2824: 3D80FDFF  lis r12, -0x201
	ctx.r[12].s64 = -33619968;
	// 821B2828: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B282C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2830: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2834: 48000010  b 0x821b2844
	pc = 0x821B2844; continue 'dispatch;
            }
            0x821B2838 => {
    //   block [0x821B2838..0x821B2844)
	// 821B2838: 654A0200  oris r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 33554432;
	// 821B283C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2840: D18B007C  stfs f12, 0x7c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x821B2844; continue 'dispatch;
            }
            0x821B2844 => {
    //   block [0x821B2844..0x821B2864)
	// 821B2844: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2848: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B284C: 40980018  bge cr6, 0x821b2864
	if !ctx.cr[6].lt {
	pc = 0x821B2864; continue 'dispatch;
	}
	// 821B2850: 3D80FBFF  lis r12, -0x401
	ctx.r[12].s64 = -67174400;
	// 821B2854: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2858: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B285C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2860: 48000010  b 0x821b2870
	pc = 0x821B2870; continue 'dispatch;
            }
            0x821B2864 => {
    //   block [0x821B2864..0x821B2870)
	// 821B2864: 654A0400  oris r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 67108864;
	// 821B2868: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B286C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	pc = 0x821B2870; continue 'dispatch;
            }
            0x821B2870 => {
    //   block [0x821B2870..0x821B2890)
	// 821B2870: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2874: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2878: 40980018  bge cr6, 0x821b2890
	if !ctx.cr[6].lt {
	pc = 0x821B2890; continue 'dispatch;
	}
	// 821B287C: 3D80FBFF  lis r12, -0x401
	ctx.r[12].s64 = -67174400;
	// 821B2880: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2884: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2888: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B288C: 48000010  b 0x821b289c
	pc = 0x821B289C; continue 'dispatch;
            }
            0x821B2890 => {
    //   block [0x821B2890..0x821B289C)
	// 821B2890: 654A0400  oris r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 67108864;
	// 821B2894: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2898: D18B0080  stfs f12, 0x80(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	pc = 0x821B289C; continue 'dispatch;
            }
            0x821B289C => {
    //   block [0x821B289C..0x821B28BC)
	// 821B289C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B28A0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B28A4: 40980018  bge cr6, 0x821b28bc
	if !ctx.cr[6].lt {
	pc = 0x821B28BC; continue 'dispatch;
	}
	// 821B28A8: 3D80F7FF  lis r12, -0x801
	ctx.r[12].s64 = -134283264;
	// 821B28AC: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B28B0: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B28B4: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28B8: 48000010  b 0x821b28c8
	pc = 0x821B28C8; continue 'dispatch;
            }
            0x821B28BC => {
    //   block [0x821B28BC..0x821B28C8)
	// 821B28BC: 654A0800  oris r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 134217728;
	// 821B28C0: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28C4: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x821B28C8; continue 'dispatch;
            }
            0x821B28C8 => {
    //   block [0x821B28C8..0x821B28E8)
	// 821B28C8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B28CC: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B28D0: 40980018  bge cr6, 0x821b28e8
	if !ctx.cr[6].lt {
	pc = 0x821B28E8; continue 'dispatch;
	}
	// 821B28D4: 3D80F7FF  lis r12, -0x801
	ctx.r[12].s64 = -134283264;
	// 821B28D8: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B28DC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B28E0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28E4: 48000010  b 0x821b28f4
	pc = 0x821B28F4; continue 'dispatch;
            }
            0x821B28E8 => {
    //   block [0x821B28E8..0x821B28F4)
	// 821B28E8: 654A0800  oris r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 134217728;
	// 821B28EC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B28F0: D18B0084  stfs f12, 0x84(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x821B28F4; continue 'dispatch;
            }
            0x821B28F4 => {
    //   block [0x821B28F4..0x821B2914)
	// 821B28F4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B28F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B28FC: 40980018  bge cr6, 0x821b2914
	if !ctx.cr[6].lt {
	pc = 0x821B2914; continue 'dispatch;
	}
	// 821B2900: 3D80EFFF  lis r12, -0x1001
	ctx.r[12].s64 = -268500992;
	// 821B2904: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2908: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B290C: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2910: 48000010  b 0x821b2920
	pc = 0x821B2920; continue 'dispatch;
            }
            0x821B2914 => {
    //   block [0x821B2914..0x821B2920)
	// 821B2914: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 821B2918: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B291C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x821B2920; continue 'dispatch;
            }
            0x821B2920 => {
    //   block [0x821B2920..0x821B2940)
	// 821B2920: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2924: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2928: 40980018  bge cr6, 0x821b2940
	if !ctx.cr[6].lt {
	pc = 0x821B2940; continue 'dispatch;
	}
	// 821B292C: 3D80EFFF  lis r12, -0x1001
	ctx.r[12].s64 = -268500992;
	// 821B2930: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2934: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2938: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B293C: 48000010  b 0x821b294c
	pc = 0x821B294C; continue 'dispatch;
            }
            0x821B2940 => {
    //   block [0x821B2940..0x821B294C)
	// 821B2940: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 821B2944: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2948: D18B0088  stfs f12, 0x88(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x821B294C; continue 'dispatch;
            }
            0x821B294C => {
    //   block [0x821B294C..0x821B296C)
	// 821B294C: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2950: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2954: 40980018  bge cr6, 0x821b296c
	if !ctx.cr[6].lt {
	pc = 0x821B296C; continue 'dispatch;
	}
	// 821B2958: 3D80DFFF  lis r12, -0x2001
	ctx.r[12].s64 = -536936448;
	// 821B295C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2960: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2964: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2968: 48000010  b 0x821b2978
	pc = 0x821B2978; continue 'dispatch;
            }
            0x821B296C => {
    //   block [0x821B296C..0x821B2978)
	// 821B296C: 654A2000  oris r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 536870912;
	// 821B2970: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2974: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x821B2978; continue 'dispatch;
            }
            0x821B2978 => {
    //   block [0x821B2978..0x821B2998)
	// 821B2978: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B297C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2980: 40980018  bge cr6, 0x821b2998
	if !ctx.cr[6].lt {
	pc = 0x821B2998; continue 'dispatch;
	}
	// 821B2984: 3D80DFFF  lis r12, -0x2001
	ctx.r[12].s64 = -536936448;
	// 821B2988: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B298C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2990: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2994: 48000010  b 0x821b29a4
	pc = 0x821B29A4; continue 'dispatch;
            }
            0x821B2998 => {
    //   block [0x821B2998..0x821B29A4)
	// 821B2998: 654A2000  oris r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 536870912;
	// 821B299C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29A0: D18B008C  stfs f12, 0x8c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x821B29A4; continue 'dispatch;
            }
            0x821B29A4 => {
    //   block [0x821B29A4..0x821B29C4)
	// 821B29A4: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B29A8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B29AC: 40980018  bge cr6, 0x821b29c4
	if !ctx.cr[6].lt {
	pc = 0x821B29C4; continue 'dispatch;
	}
	// 821B29B0: 3D80BFFF  lis r12, -0x4001
	ctx.r[12].s64 = -1073807360;
	// 821B29B4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B29B8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B29BC: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29C0: 48000010  b 0x821b29d0
	pc = 0x821B29D0; continue 'dispatch;
            }
            0x821B29C4 => {
    //   block [0x821B29C4..0x821B29D0)
	// 821B29C4: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821B29C8: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29CC: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x821B29D0; continue 'dispatch;
            }
            0x821B29D0 => {
    //   block [0x821B29D0..0x821B29F0)
	// 821B29D0: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B29D4: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B29D8: 40980018  bge cr6, 0x821b29f0
	if !ctx.cr[6].lt {
	pc = 0x821B29F0; continue 'dispatch;
	}
	// 821B29DC: 3D80BFFF  lis r12, -0x4001
	ctx.r[12].s64 = -1073807360;
	// 821B29E0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B29E4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B29E8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29EC: 48000010  b 0x821b29fc
	pc = 0x821B29FC; continue 'dispatch;
            }
            0x821B29F0 => {
    //   block [0x821B29F0..0x821B29FC)
	// 821B29F0: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821B29F4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B29F8: D18B0090  stfs f12, 0x90(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x821B29FC; continue 'dispatch;
            }
            0x821B29FC => {
    //   block [0x821B29FC..0x821B2A1C)
	// 821B29FC: E95F0010  ld r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2A00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2A04: 40980018  bge cr6, 0x821b2a1c
	if !ctx.cr[6].lt {
	pc = 0x821B2A1C; continue 'dispatch;
	}
	// 821B2A08: 3980FFFE  li r12, -2
	ctx.r[12].s64 = -2;
	// 821B2A0C: 798CFFE4  rldicr r12, r12, 0x1f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(31) & 0xFFFFFFFFFFFFFFFF;
	// 821B2A10: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2A14: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A18: 48000010  b 0x821b2a28
	pc = 0x821B2A28; continue 'dispatch;
            }
            0x821B2A1C => {
    //   block [0x821B2A1C..0x821B2A28)
	// 821B2A1C: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821B2A20: F95F0010  std r10, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A24: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	pc = 0x821B2A28; continue 'dispatch;
            }
            0x821B2A28 => {
    //   block [0x821B2A28..0x821B2A48)
	// 821B2A28: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2A2C: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2A30: 40980018  bge cr6, 0x821b2a48
	if !ctx.cr[6].lt {
	pc = 0x821B2A48; continue 'dispatch;
	}
	// 821B2A34: 3980FFFE  li r12, -2
	ctx.r[12].s64 = -2;
	// 821B2A38: 798CFFE4  rldicr r12, r12, 0x1f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(31) & 0xFFFFFFFFFFFFFFFF;
	// 821B2A3C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2A40: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A44: 48000010  b 0x821b2a54
	pc = 0x821B2A54; continue 'dispatch;
            }
            0x821B2A48 => {
    //   block [0x821B2A48..0x821B2A54)
	// 821B2A48: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821B2A4C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2A50: D18B0094  stfs f12, 0x94(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	pc = 0x821B2A54; continue 'dispatch;
            }
            0x821B2A54 => {
    //   block [0x821B2A54..0x821B2A60)
	// 821B2A54: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821B2A58: 390B0098  addi r8, r11, 0x98
	ctx.r[8].s64 = ctx.r[11].s64 + 152;
	// 821B2A5C: 7CEBF850  subf r7, r11, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	pc = 0x821B2A60; continue 'dispatch;
            }
            0x821B2A60 => {
    //   block [0x821B2A60..0x821B2A80)
	// 821B2A60: 7D2A07B4  extsw r10, r9
	ctx.r[10].s64 = ctx.r[9].s32 as i64;
	// 821B2A64: E8DF0010  ld r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B2A68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2A6C: 7F4A5036  sld r10, r26, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[26].u64) << ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821B2A70: 40980010  bge cr6, 0x821b2a80
	if !ctx.cr[6].lt {
	pc = 0x821B2A80; continue 'dispatch;
	}
	// 821B2A74: 7CC65078  andc r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 821B2A78: F8DF0010  std r6, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821B2A7C: 48000010  b 0x821b2a8c
	pc = 0x821B2A8C; continue 'dispatch;
            }
            0x821B2A80 => {
    //   block [0x821B2A80..0x821B2A8C)
	// 821B2A80: 7D463378  or r6, r10, r6
	ctx.r[6].u64 = ctx.r[10].u64 | ctx.r[6].u64;
	// 821B2A84: F8DF0010  std r6, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821B2A88: 7C07452E  stfsx f0, r7, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	pc = 0x821B2A8C; continue 'dispatch;
            }
            0x821B2A8C => {
    //   block [0x821B2A8C..0x821B2AA4)
	// 821B2A8C: E8CB0010  ld r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2A90: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821B2A94: 40980010  bge cr6, 0x821b2aa4
	if !ctx.cr[6].lt {
	pc = 0x821B2AA4; continue 'dispatch;
	}
	// 821B2A98: 7CCA5078  andc r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 & !ctx.r[10].u64;
	// 821B2A9C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2AA0: 48000010  b 0x821b2ab0
	pc = 0x821B2AB0; continue 'dispatch;
            }
            0x821B2AA4 => {
    //   block [0x821B2AA4..0x821B2AB0)
	// 821B2AA4: 7CCA5378  or r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 | ctx.r[10].u64;
	// 821B2AA8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2AAC: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821B2AB0; continue 'dispatch;
            }
            0x821B2AB0 => {
    //   block [0x821B2AB0..0x821B2AC0)
	// 821B2AB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821B2AB4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821B2AB8: 2F090022  cmpwi cr6, r9, 0x22
	ctx.cr[6].compare_i32(ctx.r[9].s32, 34, &mut ctx.xer);
	// 821B2ABC: 4099FFA4  ble cr6, 0x821b2a60
	if !ctx.cr[6].gt {
	pc = 0x821B2A60; continue 'dispatch;
	}
	pc = 0x821B2AC0; continue 'dispatch;
            }
            0x821B2AC0 => {
    //   block [0x821B2AC0..0x821B2AF4)
	// 821B2AC0: C01B003C  lfs f0, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2AC4: C1BB0040  lfs f13, 0x40(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2AC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B2ACC: 419A03A4  beq cr6, 0x821b2e70
	if ctx.cr[6].eq {
	pc = 0x821B2E70; continue 'dispatch;
	}
	// 821B2AD0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2AD4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2AD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B2ADC: 396B1F68  addi r11, r11, 0x1f68
	ctx.r[11].s64 = ctx.r[11].s64 + 8040;
	// 821B2AE0: 419A0014  beq cr6, 0x821b2af4
	if ctx.cr[6].eq {
	pc = 0x821B2AF4; continue 'dispatch;
	}
	// 821B2AE4: 813B0038  lwz r9, 0x38(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B2AE8: 7D4950AE  lbzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B2AEC: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B2AF0: 48000008  b 0x821b2af8
	pc = 0x821B2AF8; continue 'dispatch;
            }
            0x821B2AF4 => {
    //   block [0x821B2AF4..0x821B2AF8)
	// 821B2AF4: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x821B2AF8; continue 'dispatch;
            }
            0x821B2AF8 => {
    //   block [0x821B2AF8..0x821B2B18)
	// 821B2AF8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2AFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B2B00: 419A0024  beq cr6, 0x821b2b24
	if ctx.cr[6].eq {
	pc = 0x821B2B24; continue 'dispatch;
	}
	// 821B2B04: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B2B08: 41980010  blt cr6, 0x821b2b18
	if ctx.cr[6].lt {
	pc = 0x821B2B18; continue 'dispatch;
	}
	// 821B2B0C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2B10: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B2B14: 41980014  blt cr6, 0x821b2b28
	if ctx.cr[6].lt {
	pc = 0x821B2B28; continue 'dispatch;
	}
	pc = 0x821B2B18; continue 'dispatch;
            }
            0x821B2B18 => {
    //   block [0x821B2B18..0x821B2B24)
	// 821B2B18: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2B1C: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B2B20: 4800000C  b 0x821b2b2c
	pc = 0x821B2B2C; continue 'dispatch;
            }
            0x821B2B24 => {
    //   block [0x821B2B24..0x821B2B28)
	// 821B2B24: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B2B28; continue 'dispatch;
            }
            0x821B2B28 => {
    //   block [0x821B2B28..0x821B2B2C)
	// 821B2B28: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x821B2B2C; continue 'dispatch;
            }
            0x821B2B2C => {
    //   block [0x821B2B2C..0x821B2B48)
	// 821B2B2C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2B30: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2B34: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2B38: 40980010  bge cr6, 0x821b2b48
	if !ctx.cr[6].lt {
	pc = 0x821B2B48; continue 'dispatch;
	}
	// 821B2B3C: 794A07A4  rldicr r10, r10, 0, 0x3e
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(0) & 0xFFFFFFFFFFFFFFFE;
	// 821B2B40: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B44: 48000010  b 0x821b2b54
	pc = 0x821B2B54; continue 'dispatch;
            }
            0x821B2B48 => {
    //   block [0x821B2B48..0x821B2B54)
	// 821B2B48: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821B2B4C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B50: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x821B2B54; continue 'dispatch;
            }
            0x821B2B54 => {
    //   block [0x821B2B54..0x821B2B70)
	// 821B2B54: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2B58: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2B5C: 40980014  bge cr6, 0x821b2b70
	if !ctx.cr[6].lt {
	pc = 0x821B2B70; continue 'dispatch;
	}
	// 821B2B60: 3980FFFD  li r12, -3
	ctx.r[12].s64 = -3;
	// 821B2B64: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2B68: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B6C: 48000010  b 0x821b2b7c
	pc = 0x821B2B7C; continue 'dispatch;
            }
            0x821B2B70 => {
    //   block [0x821B2B70..0x821B2B7C)
	// 821B2B70: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821B2B74: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B78: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x821B2B7C; continue 'dispatch;
            }
            0x821B2B7C => {
    //   block [0x821B2B7C..0x821B2B98)
	// 821B2B7C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2B80: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2B84: 40980014  bge cr6, 0x821b2b98
	if !ctx.cr[6].lt {
	pc = 0x821B2B98; continue 'dispatch;
	}
	// 821B2B88: 3980EFFF  li r12, -0x1001
	ctx.r[12].s64 = -4097;
	// 821B2B8C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2B90: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2B94: 48000010  b 0x821b2ba4
	pc = 0x821B2BA4; continue 'dispatch;
            }
            0x821B2B98 => {
    //   block [0x821B2B98..0x821B2BA4)
	// 821B2B98: 614A1000  ori r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 4096;
	// 821B2B9C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BA0: D00B0048  stfs f0, 0x48(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x821B2BA4; continue 'dispatch;
            }
            0x821B2BA4 => {
    //   block [0x821B2BA4..0x821B2BC0)
	// 821B2BA4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2BA8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2BAC: 40980014  bge cr6, 0x821b2bc0
	if !ctx.cr[6].lt {
	pc = 0x821B2BC0; continue 'dispatch;
	}
	// 821B2BB0: 3980DFFF  li r12, -0x2001
	ctx.r[12].s64 = -8193;
	// 821B2BB4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2BB8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BBC: 48000010  b 0x821b2bcc
	pc = 0x821B2BCC; continue 'dispatch;
            }
            0x821B2BC0 => {
    //   block [0x821B2BC0..0x821B2BCC)
	// 821B2BC0: 614A2000  ori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 8192;
	// 821B2BC4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BC8: D00B004C  stfs f0, 0x4c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x821B2BCC; continue 'dispatch;
            }
            0x821B2BCC => {
    //   block [0x821B2BCC..0x821B2BE8)
	// 821B2BCC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2BD0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2BD4: 40980014  bge cr6, 0x821b2be8
	if !ctx.cr[6].lt {
	pc = 0x821B2BE8; continue 'dispatch;
	}
	// 821B2BD8: 3980FDFF  li r12, -0x201
	ctx.r[12].s64 = -513;
	// 821B2BDC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2BE0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BE4: 48000010  b 0x821b2bf4
	pc = 0x821B2BF4; continue 'dispatch;
            }
            0x821B2BE8 => {
    //   block [0x821B2BE8..0x821B2BF4)
	// 821B2BE8: 614A0200  ori r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 512;
	// 821B2BEC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2BF0: D00B003C  stfs f0, 0x3c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x821B2BF4; continue 'dispatch;
            }
            0x821B2BF4 => {
    //   block [0x821B2BF4..0x821B2C10)
	// 821B2BF4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2BF8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2BFC: 40980014  bge cr6, 0x821b2c10
	if !ctx.cr[6].lt {
	pc = 0x821B2C10; continue 'dispatch;
	}
	// 821B2C00: 3980FBFF  li r12, -0x401
	ctx.r[12].s64 = -1025;
	// 821B2C04: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C08: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C0C: 48000010  b 0x821b2c1c
	pc = 0x821B2C1C; continue 'dispatch;
            }
            0x821B2C10 => {
    //   block [0x821B2C10..0x821B2C1C)
	// 821B2C10: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 821B2C14: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C18: D00B0040  stfs f0, 0x40(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x821B2C1C; continue 'dispatch;
            }
            0x821B2C1C => {
    //   block [0x821B2C1C..0x821B2C38)
	// 821B2C1C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2C20: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2C24: 40980014  bge cr6, 0x821b2c38
	if !ctx.cr[6].lt {
	pc = 0x821B2C38; continue 'dispatch;
	}
	// 821B2C28: 3980F7FF  li r12, -0x801
	ctx.r[12].s64 = -2049;
	// 821B2C2C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C30: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C34: 48000010  b 0x821b2c44
	pc = 0x821B2C44; continue 'dispatch;
            }
            0x821B2C38 => {
    //   block [0x821B2C38..0x821B2C44)
	// 821B2C38: 614A0800  ori r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 2048;
	// 821B2C3C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C40: D00B0044  stfs f0, 0x44(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x821B2C44; continue 'dispatch;
            }
            0x821B2C44 => {
    //   block [0x821B2C44..0x821B2C64)
	// 821B2C44: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2C48: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2C4C: 40980018  bge cr6, 0x821b2c64
	if !ctx.cr[6].lt {
	pc = 0x821B2C64; continue 'dispatch;
	}
	// 821B2C50: 3D80FFDF  lis r12, -0x21
	ctx.r[12].s64 = -2162688;
	// 821B2C54: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2C58: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C5C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C60: 48000010  b 0x821b2c70
	pc = 0x821B2C70; continue 'dispatch;
            }
            0x821B2C64 => {
    //   block [0x821B2C64..0x821B2C70)
	// 821B2C64: 654A0020  oris r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 2097152;
	// 821B2C68: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C6C: D00B006C  stfs f0, 0x6c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	pc = 0x821B2C70; continue 'dispatch;
            }
            0x821B2C70 => {
    //   block [0x821B2C70..0x821B2C90)
	// 821B2C70: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2C74: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2C78: 40980018  bge cr6, 0x821b2c90
	if !ctx.cr[6].lt {
	pc = 0x821B2C90; continue 'dispatch;
	}
	// 821B2C7C: 3D80FFBF  lis r12, -0x41
	ctx.r[12].s64 = -4259840;
	// 821B2C80: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2C84: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2C88: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C8C: 48000010  b 0x821b2c9c
	pc = 0x821B2C9C; continue 'dispatch;
            }
            0x821B2C90 => {
    //   block [0x821B2C90..0x821B2C9C)
	// 821B2C90: 654A0040  oris r10, r10, 0x40
	ctx.r[10].u64 = ctx.r[10].u64 | 4194304;
	// 821B2C94: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2C98: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x821B2C9C; continue 'dispatch;
            }
            0x821B2C9C => {
    //   block [0x821B2C9C..0x821B2CBC)
	// 821B2C9C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2CA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2CA4: 40980018  bge cr6, 0x821b2cbc
	if !ctx.cr[6].lt {
	pc = 0x821B2CBC; continue 'dispatch;
	}
	// 821B2CA8: 3D80FF7F  lis r12, -0x81
	ctx.r[12].s64 = -8454144;
	// 821B2CAC: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2CB0: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2CB4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CB8: 48000010  b 0x821b2cc8
	pc = 0x821B2CC8; continue 'dispatch;
            }
            0x821B2CBC => {
    //   block [0x821B2CBC..0x821B2CC8)
	// 821B2CBC: 654A0080  oris r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 8388608;
	// 821B2CC0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CC4: D00B0074  stfs f0, 0x74(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x821B2CC8; continue 'dispatch;
            }
            0x821B2CC8 => {
    //   block [0x821B2CC8..0x821B2CE8)
	// 821B2CC8: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2CCC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2CD0: 40980018  bge cr6, 0x821b2ce8
	if !ctx.cr[6].lt {
	pc = 0x821B2CE8; continue 'dispatch;
	}
	// 821B2CD4: 3D80FEFF  lis r12, -0x101
	ctx.r[12].s64 = -16842752;
	// 821B2CD8: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2CDC: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2CE0: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CE4: 48000010  b 0x821b2cf4
	pc = 0x821B2CF4; continue 'dispatch;
            }
            0x821B2CE8 => {
    //   block [0x821B2CE8..0x821B2CF4)
	// 821B2CE8: 654A0100  oris r10, r10, 0x100
	ctx.r[10].u64 = ctx.r[10].u64 | 16777216;
	// 821B2CEC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2CF0: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x821B2CF4; continue 'dispatch;
            }
            0x821B2CF4 => {
    //   block [0x821B2CF4..0x821B2D14)
	// 821B2CF4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2CF8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2CFC: 40980018  bge cr6, 0x821b2d14
	if !ctx.cr[6].lt {
	pc = 0x821B2D14; continue 'dispatch;
	}
	// 821B2D00: 3D80FDFF  lis r12, -0x201
	ctx.r[12].s64 = -33619968;
	// 821B2D04: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D08: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D0C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D10: 48000010  b 0x821b2d20
	pc = 0x821B2D20; continue 'dispatch;
            }
            0x821B2D14 => {
    //   block [0x821B2D14..0x821B2D20)
	// 821B2D14: 654A0200  oris r10, r10, 0x200
	ctx.r[10].u64 = ctx.r[10].u64 | 33554432;
	// 821B2D18: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D1C: D00B007C  stfs f0, 0x7c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x821B2D20; continue 'dispatch;
            }
            0x821B2D20 => {
    //   block [0x821B2D20..0x821B2D40)
	// 821B2D20: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2D24: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2D28: 40980018  bge cr6, 0x821b2d40
	if !ctx.cr[6].lt {
	pc = 0x821B2D40; continue 'dispatch;
	}
	// 821B2D2C: 3D80FBFF  lis r12, -0x401
	ctx.r[12].s64 = -67174400;
	// 821B2D30: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D34: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D38: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D3C: 48000010  b 0x821b2d4c
	pc = 0x821B2D4C; continue 'dispatch;
            }
            0x821B2D40 => {
    //   block [0x821B2D40..0x821B2D4C)
	// 821B2D40: 654A0400  oris r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 67108864;
	// 821B2D44: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D48: D00B0080  stfs f0, 0x80(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	pc = 0x821B2D4C; continue 'dispatch;
            }
            0x821B2D4C => {
    //   block [0x821B2D4C..0x821B2D6C)
	// 821B2D4C: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2D50: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2D54: 40980018  bge cr6, 0x821b2d6c
	if !ctx.cr[6].lt {
	pc = 0x821B2D6C; continue 'dispatch;
	}
	// 821B2D58: 3D80F7FF  lis r12, -0x801
	ctx.r[12].s64 = -134283264;
	// 821B2D5C: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D60: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D64: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D68: 48000010  b 0x821b2d78
	pc = 0x821B2D78; continue 'dispatch;
            }
            0x821B2D6C => {
    //   block [0x821B2D6C..0x821B2D78)
	// 821B2D6C: 654A0800  oris r10, r10, 0x800
	ctx.r[10].u64 = ctx.r[10].u64 | 134217728;
	// 821B2D70: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D74: D00B0084  stfs f0, 0x84(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x821B2D78; continue 'dispatch;
            }
            0x821B2D78 => {
    //   block [0x821B2D78..0x821B2D98)
	// 821B2D78: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2D7C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2D80: 40980018  bge cr6, 0x821b2d98
	if !ctx.cr[6].lt {
	pc = 0x821B2D98; continue 'dispatch;
	}
	// 821B2D84: 3D80EFFF  lis r12, -0x1001
	ctx.r[12].s64 = -268500992;
	// 821B2D88: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2D8C: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2D90: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2D94: 48000010  b 0x821b2da4
	pc = 0x821B2DA4; continue 'dispatch;
            }
            0x821B2D98 => {
    //   block [0x821B2D98..0x821B2DA4)
	// 821B2D98: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 821B2D9C: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DA0: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x821B2DA4; continue 'dispatch;
            }
            0x821B2DA4 => {
    //   block [0x821B2DA4..0x821B2DC4)
	// 821B2DA4: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2DA8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2DAC: 40980018  bge cr6, 0x821b2dc4
	if !ctx.cr[6].lt {
	pc = 0x821B2DC4; continue 'dispatch;
	}
	// 821B2DB0: 3D80DFFF  lis r12, -0x2001
	ctx.r[12].s64 = -536936448;
	// 821B2DB4: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2DB8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2DBC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DC0: 48000010  b 0x821b2dd0
	pc = 0x821B2DD0; continue 'dispatch;
            }
            0x821B2DC4 => {
    //   block [0x821B2DC4..0x821B2DD0)
	// 821B2DC4: 654A2000  oris r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 | 536870912;
	// 821B2DC8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DCC: D00B008C  stfs f0, 0x8c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x821B2DD0; continue 'dispatch;
            }
            0x821B2DD0 => {
    //   block [0x821B2DD0..0x821B2DF0)
	// 821B2DD0: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2DD4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2DD8: 40980018  bge cr6, 0x821b2df0
	if !ctx.cr[6].lt {
	pc = 0x821B2DF0; continue 'dispatch;
	}
	// 821B2DDC: 3D80BFFF  lis r12, -0x4001
	ctx.r[12].s64 = -1073807360;
	// 821B2DE0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2DE4: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2DE8: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DEC: 48000010  b 0x821b2dfc
	pc = 0x821B2DFC; continue 'dispatch;
            }
            0x821B2DF0 => {
    //   block [0x821B2DF0..0x821B2DFC)
	// 821B2DF0: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821B2DF4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2DF8: D00B0090  stfs f0, 0x90(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x821B2DFC; continue 'dispatch;
            }
            0x821B2DFC => {
    //   block [0x821B2DFC..0x821B2E1C)
	// 821B2DFC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2E00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2E04: 40980018  bge cr6, 0x821b2e1c
	if !ctx.cr[6].lt {
	pc = 0x821B2E1C; continue 'dispatch;
	}
	// 821B2E08: 3980FFFE  li r12, -2
	ctx.r[12].s64 = -2;
	// 821B2E0C: 798CFFE4  rldicr r12, r12, 0x1f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(31) & 0xFFFFFFFFFFFFFFFF;
	// 821B2E10: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2E14: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2E18: 48000010  b 0x821b2e28
	pc = 0x821B2E28; continue 'dispatch;
            }
            0x821B2E1C => {
    //   block [0x821B2E1C..0x821B2E28)
	// 821B2E1C: 654A8000  oris r10, r10, 0x8000
	ctx.r[10].u64 = ctx.r[10].u64 | 2147483648;
	// 821B2E20: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2E24: D00B0094  stfs f0, 0x94(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), tmp.u32 ) };
	pc = 0x821B2E28; continue 'dispatch;
            }
            0x821B2E28 => {
    //   block [0x821B2E28..0x821B2E30)
	// 821B2E28: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821B2E2C: 392B0098  addi r9, r11, 0x98
	ctx.r[9].s64 = ctx.r[11].s64 + 152;
	pc = 0x821B2E30; continue 'dispatch;
            }
            0x821B2E30 => {
    //   block [0x821B2E30..0x821B2E50)
	// 821B2E30: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 821B2E34: E8EB0010  ld r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2E38: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B2E3C: 7F484036  sld r8, r26, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[26].u64) << ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 821B2E40: 40980010  bge cr6, 0x821b2e50
	if !ctx.cr[6].lt {
	pc = 0x821B2E50; continue 'dispatch;
	}
	// 821B2E44: 7CE84078  andc r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 & !ctx.r[8].u64;
	// 821B2E48: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 821B2E4C: 48000010  b 0x821b2e5c
	pc = 0x821B2E5C; continue 'dispatch;
            }
            0x821B2E50 => {
    //   block [0x821B2E50..0x821B2E5C)
	// 821B2E50: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821B2E54: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 821B2E58: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x821B2E5C; continue 'dispatch;
            }
            0x821B2E5C => {
    //   block [0x821B2E5C..0x821B2E70)
	// 821B2E5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B2E60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821B2E64: 2F0A0022  cmpwi cr6, r10, 0x22
	ctx.cr[6].compare_i32(ctx.r[10].s32, 34, &mut ctx.xer);
	// 821B2E68: 4099FFC8  ble cr6, 0x821b2e30
	if !ctx.cr[6].gt {
	pc = 0x821B2E30; continue 'dispatch;
	}
	// 821B2E6C: D01B0040  stfs f0, 0x40(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x821B2E70; continue 'dispatch;
            }
            0x821B2E70 => {
    //   block [0x821B2E70..0x821B2E90)
	// 821B2E70: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2E74: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2E78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B2E7C: 396B20B8  addi r11, r11, 0x20b8
	ctx.r[11].s64 = ctx.r[11].s64 + 8376;
	// 821B2E80: 419A0010  beq cr6, 0x821b2e90
	if ctx.cr[6].eq {
	pc = 0x821B2E90; continue 'dispatch;
	}
	// 821B2E84: 894A002B  lbz r10, 0x2b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(43 as u32) ) } as u64;
	// 821B2E88: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821B2E8C: 48000008  b 0x821b2e94
	pc = 0x821B2E94; continue 'dispatch;
            }
            0x821B2E90 => {
    //   block [0x821B2E90..0x821B2E94)
	// 821B2E90: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x821B2E94; continue 'dispatch;
            }
            0x821B2E94 => {
    //   block [0x821B2E94..0x821B2EB4)
	// 821B2E94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B2E98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B2E9C: 419A0024  beq cr6, 0x821b2ec0
	if ctx.cr[6].eq {
	pc = 0x821B2EC0; continue 'dispatch;
	}
	// 821B2EA0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B2EA4: 41980010  blt cr6, 0x821b2eb4
	if ctx.cr[6].lt {
	pc = 0x821B2EB4; continue 'dispatch;
	}
	// 821B2EA8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B2EAC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B2EB0: 41980014  blt cr6, 0x821b2ec4
	if ctx.cr[6].lt {
	pc = 0x821B2EC4; continue 'dispatch;
	}
	pc = 0x821B2EB4; continue 'dispatch;
            }
            0x821B2EB4 => {
    //   block [0x821B2EB4..0x821B2EC0)
	// 821B2EB4: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2EB8: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 821B2EBC: 4800000C  b 0x821b2ec8
	pc = 0x821B2EC8; continue 'dispatch;
            }
            0x821B2EC0 => {
    //   block [0x821B2EC0..0x821B2EC4)
	// 821B2EC0: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B2EC4; continue 'dispatch;
            }
            0x821B2EC4 => {
    //   block [0x821B2EC4..0x821B2EC8)
	// 821B2EC4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x821B2EC8; continue 'dispatch;
            }
            0x821B2EC8 => {
    //   block [0x821B2EC8..0x821B2F04)
	// 821B2EC8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B2ECC: D3AB000C  stfs f29, 0xc(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B2ED0: 614AED6A  ori r10, r10, 0xed6a
	ctx.r[10].u64 = ctx.r[10].u64 | 60778;
	// 821B2ED4: 7D58522E  lhzx r10, r24, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B2ED8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 821B2EDC: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2EE0: 419A0024  beq cr6, 0x821b2f04
	if ctx.cr[6].eq {
	pc = 0x821B2F04; continue 'dispatch;
	}
	// 821B2EE4: 3980FFEF  li r12, -0x11
	ctx.r[12].s64 = -17;
	// 821B2EE8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2EEC: 3D80FFFE  lis r12, -2
	ctx.r[12].s64 = -131072;
	// 821B2EF0: 618CFFFF  ori r12, r12, 0xffff
	ctx.r[12].u64 = ctx.r[12].u64 | 65535;
	// 821B2EF4: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2EF8: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 821B2EFC: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2F00: 48000020  b 0x821b2f20
	pc = 0x821B2F20; continue 'dispatch;
            }
            0x821B2F04 => {
    //   block [0x821B2F04..0x821B2F20)
	// 821B2F04: 614A0010  ori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 | 16;
	// 821B2F08: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2F0C: D3CB0028  stfs f30, 0x28(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821B2F10: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 821B2F14: 654A0001  oris r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 65536;
	// 821B2F18: F94B0010  std r10, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u64 ) };
	// 821B2F1C: D3CB0058  stfs f30, 0x58(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x821B2F20; continue 'dispatch;
            }
            0x821B2F20 => {
    //   block [0x821B2F20..0x821B2F3C)
	// 821B2F20: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B2F24: 917B0024  stw r11, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B2F28: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B2F2C: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821B2F30: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821B2F34: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821B2F38: 483821C0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B2F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B2F40 size=372
    let mut pc: u32 = 0x821B2F40;
    'dispatch: loop {
        match pc {
            0x821B2F40 => {
    //   block [0x821B2F40..0x821B3000)
	// 821B2F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B2F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B2F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B2F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B2F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B2F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B2F58: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B2F5C: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B2F60: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B2F64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B2F68: C00B06A4  lfs f0, 0x6a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B2F6C: 409A0120  bne cr6, 0x821b308c
	if !ctx.cr[6].eq {
	pc = 0x821B308C; continue 'dispatch;
	}
	// 821B2F70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B2F74: 356B1CC8  addic. r11, r11, 0x1cc8
	ctx.xer.ca = (ctx.r[11].u32 > (!(7368 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + 7368;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B2F78: 41820114  beq 0x821b308c
	if ctx.cr[0].eq {
	pc = 0x821B308C; continue 'dispatch;
	}
	// 821B2F7C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B2F80: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B2F84: 419A0108  beq cr6, 0x821b308c
	if ctx.cr[6].eq {
	pc = 0x821B308C; continue 'dispatch;
	}
	// 821B2F88: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B2F8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B2F90: ED4C0032  fmuls f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B2F94: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2F98: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B2F9C: EC0D502A  fadds f0, f13, f10
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 821B2FA0: C1AB9F78  lfs f13, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2FA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B2FA8: C16B2074  lfs f11, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B2FAC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B2FB0: 40990050  ble cr6, 0x821b3000
	if !ctx.cr[6].gt {
	pc = 0x821B3000; continue 'dispatch;
	}
	// 821B2FB4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B2FB8: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B2FBC: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B2FC0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B2FC4: 481B4175  bl 0x82367138
	ctx.lr = 0x821B2FC8;
	sub_82367138(ctx, base);
	// 821B2FC8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B2FCC: C1ABD2B0  lfs f13, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B2FD0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821B2FD4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B2FD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B2FDC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B2FE0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821B2FE4: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821B2FE8: C18B2280  lfs f12, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B2FEC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B2FF0: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B2FF4: C18BD760  lfs f12, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B2FF8: EDA9637E  fnmadds f13, f9, f13, f12
	ctx.f[13].f64 = -(ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64);
	// 821B2FFC: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x821B3000; continue 'dispatch;
            }
            0x821B3000 => {
    //   block [0x821B3000..0x821B3050)
	// 821B3000: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 821B3004: 409A004C  bne cr6, 0x821b3050
	if !ctx.cr[6].eq {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3008: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B300C: 40990044  ble cr6, 0x821b3050
	if !ctx.cr[6].gt {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3010: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3014: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3018: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 821B301C: 40980034  bge cr6, 0x821b3050
	if !ctx.cr[6].lt {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3020: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3024: C1ABD6C8  lfs f13, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3028: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B302C: 40980024  bge cr6, 0x821b3050
	if !ctx.cr[6].lt {
	pc = 0x821B3050; continue 'dispatch;
	}
	// 821B3030: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B3034: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B3038: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B303C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B3040: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B3044: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B3048: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B304C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	pc = 0x821B3050; continue 'dispatch;
            }
            0x821B3050 => {
    //   block [0x821B3050..0x821B3088)
	// 821B3050: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3054: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B3058: 40980030  bge cr6, 0x821b3088
	if !ctx.cr[6].lt {
	pc = 0x821B3088; continue 'dispatch;
	}
	// 821B305C: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B3060: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 821B3064: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 821B3068: D19F0018  stfs f12, 0x18(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B306C: 419A0038  beq cr6, 0x821b30a4
	if ctx.cr[6].eq {
	pc = 0x821B30A4; continue 'dispatch;
	}
	// 821B3070: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 821B3074: 419A0030  beq cr6, 0x821b30a4
	if ctx.cr[6].eq {
	pc = 0x821B30A4; continue 'dispatch;
	}
	// 821B3078: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B307C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B3080: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B3084: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x821B3088; continue 'dispatch;
            }
            0x821B3088 => {
    //   block [0x821B3088..0x821B308C)
	// 821B3088: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x821B308C; continue 'dispatch;
            }
            0x821B308C => {
    //   block [0x821B308C..0x821B30A4)
	// 821B308C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B3090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B3094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B3098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B309C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B30A0: 4E800020  blr
	return;
            }
            0x821B30A4 => {
    //   block [0x821B30A4..0x821B30B4)
	// 821B30A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B30A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B30AC: 4800000D  bl 0x821b30b8
	ctx.lr = 0x821B30B0;
	sub_821B30B8(ctx, base);
	// 821B30B0: 4BFFFFDC  b 0x821b308c
	pc = 0x821B308C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B30B8 size=332
    let mut pc: u32 = 0x821B30B8;
    'dispatch: loop {
        match pc {
            0x821B30B8 => {
    //   block [0x821B30B8..0x821B3110)
	// 821B30B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B30BC: 48381FFD  bl 0x825350b8
	ctx.lr = 0x821B30C0;
	sub_82535080(ctx, base);
	// 821B30C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B30C4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B30C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B30CC: 3BABF9E4  addi r29, r11, -0x61c
	ctx.r[29].s64 = ctx.r[11].s64 + -1564;
	// 821B30D0: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B30D4: 397D00DC  addi r11, r29, 0xdc
	ctx.r[11].s64 = ctx.r[29].s64 + 220;
	// 821B30D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B30DC: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 821B30E0: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 821B30E4: 7C1E5C2E  lfsx f0, r30, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B30E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B30EC: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B30F0: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 821B30F4: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B30F8: 41980018  blt cr6, 0x821b3110
	if ctx.cr[6].lt {
	pc = 0x821B3110; continue 'dispatch;
	}
	// 821B30FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3100: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B3104: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3108: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B310C: 48000094  b 0x821b31a0
	pc = 0x821B31A0; continue 'dispatch;
            }
            0x821B3110 => {
    //   block [0x821B3110..0x821B3160)
	// 821B3110: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 821B3114: 419A004C  beq cr6, 0x821b3160
	if ctx.cr[6].eq {
	pc = 0x821B3160; continue 'dispatch;
	}
	// 821B3118: 2F040003  cmpwi cr6, r4, 3
	ctx.cr[6].compare_i32(ctx.r[4].s32, 3, &mut ctx.xer);
	// 821B311C: 419A0044  beq cr6, 0x821b3160
	if ctx.cr[6].eq {
	pc = 0x821B3160; continue 'dispatch;
	}
	// 821B3120: 481B4019  bl 0x82367138
	ctx.lr = 0x821B3124;
	sub_82367138(ctx, base);
	// 821B3124: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B3128: C00BD2B0  lfs f0, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B312C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821B3130: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B3134: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3138: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B313C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B3140: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B3144: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3148: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B314C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3150: C1ABD760  lfs f13, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3154: EC0B683E  fnmadds f0, f11, f0, f13
	ctx.f[0].f64 = -(ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64);
	// 821B3158: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B315C: 48000040  b 0x821b319c
	pc = 0x821B319C; continue 'dispatch;
            }
            0x821B3160 => {
    //   block [0x821B3160..0x821B319C)
	// 821B3160: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B3164: 481B3FD5  bl 0x82367138
	ctx.lr = 0x821B3168;
	sub_82367138(ctx, base);
	// 821B3168: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B316C: C00BD2B0  lfs f0, -0x2d50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3170: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821B3174: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B3178: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B317C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B3180: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B3184: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B3188: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B318C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B3190: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3194: C1ABD760  lfs f13, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3198: EC0B683E  fnmadds f0, f11, f0, f13
	ctx.f[0].f64 = -(ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64);
	pc = 0x821B319C; continue 'dispatch;
            }
            0x821B319C => {
    //   block [0x821B319C..0x821B31A0)
	// 821B319C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x821B31A0; continue 'dispatch;
            }
            0x821B31A0 => {
    //   block [0x821B31A0..0x821B31C0)
	// 821B31A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B31A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B31A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B31AC: 419A0014  beq cr6, 0x821b31c0
	if ctx.cr[6].eq {
	pc = 0x821B31C0; continue 'dispatch;
	}
	// 821B31B0: 7D3EE82E  lwzx r9, r30, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821B31B4: 7D6958AE  lbzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B31B8: 556B067E  clrlwi r11, r11, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 821B31BC: 48000008  b 0x821b31c4
	pc = 0x821B31C4; continue 'dispatch;
            }
            0x821B31C0 => {
    //   block [0x821B31C0..0x821B31C4)
	// 821B31C0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B31C4; continue 'dispatch;
            }
            0x821B31C4 => {
    //   block [0x821B31C4..0x821B31E4)
	// 821B31C4: 812A1E1C  lwz r9, 0x1e1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7708 as u32) ) } as u64;
	// 821B31C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B31CC: 419A0028  beq cr6, 0x821b31f4
	if ctx.cr[6].eq {
	pc = 0x821B31F4; continue 'dispatch;
	}
	// 821B31D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B31D4: 41980010  blt cr6, 0x821b31e4
	if ctx.cr[6].lt {
	pc = 0x821B31E4; continue 'dispatch;
	}
	// 821B31D8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B31DC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B31E0: 41980018  blt cr6, 0x821b31f8
	if ctx.cr[6].lt {
	pc = 0x821B31F8; continue 'dispatch;
	}
	pc = 0x821B31E4; continue 'dispatch;
            }
            0x821B31E4 => {
    //   block [0x821B31E4..0x821B31F4)
	// 821B31E4: D18A1E24  stfs f12, 0x1e24(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7716 as u32), tmp.u32 ) };
	// 821B31E8: 938A1E20  stw r28, 0x1e20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7712 as u32), ctx.r[28].u32 ) };
	// 821B31EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B31F0: 48381F18  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821B31F4 => {
    //   block [0x821B31F4..0x821B31F8)
	// 821B31F4: D18A1E24  stfs f12, 0x1e24(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7716 as u32), tmp.u32 ) };
	pc = 0x821B31F8; continue 'dispatch;
            }
            0x821B31F8 => {
    //   block [0x821B31F8..0x821B3204)
	// 821B31F8: 916A1E20  stw r11, 0x1e20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(7712 as u32), ctx.r[11].u32 ) };
	// 821B31FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B3200: 48381F08  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3208 size=312
    let mut pc: u32 = 0x821B3208;
    'dispatch: loop {
        match pc {
            0x821B3208 => {
    //   block [0x821B3208..0x821B3244)
	// 821B3208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B320C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B3210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B3214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3218: 3FE30006  addis r31, r3, 6
	ctx.r[31].s64 = ctx.r[3].s64 + 393216;
	// 821B321C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821B3220: 3BFFA910  addi r31, r31, -0x56f0
	ctx.r[31].s64 = ctx.r[31].s64 + -22256;
	// 821B3224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3228: 419A0030  beq cr6, 0x821b3258
	if ctx.cr[6].eq {
	pc = 0x821B3258; continue 'dispatch;
	}
	// 821B322C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B3230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B3234: 419A0010  beq cr6, 0x821b3244
	if ctx.cr[6].eq {
	pc = 0x821B3244; continue 'dispatch;
	}
	// 821B3238: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B323C: 409A0008  bne cr6, 0x821b3244
	if !ctx.cr[6].eq {
	pc = 0x821B3244; continue 'dispatch;
	}
	// 821B3240: 909F0030  stw r4, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	pc = 0x821B3244; continue 'dispatch;
            }
            0x821B3244 => {
    //   block [0x821B3244..0x821B3258)
	// 821B3244: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B3248: 90BF002C  stw r5, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 821B324C: 409A0010  bne cr6, 0x821b325c
	if !ctx.cr[6].eq {
	pc = 0x821B325C; continue 'dispatch;
	}
	// 821B3250: 480000F1  bl 0x821b3340
	ctx.lr = 0x821B3254;
	sub_821B3340(ctx, base);
	// 821B3254: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	pc = 0x821B3258; continue 'dispatch;
            }
            0x821B3258 => {
    //   block [0x821B3258..0x821B325C)
	// 821B3258: 90BF0030  stw r5, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[5].u32 ) };
	pc = 0x821B325C; continue 'dispatch;
            }
            0x821B325C => {
    //   block [0x821B325C..0x821B326C)
	// 821B325C: 2F050016  cmpwi cr6, r5, 0x16
	ctx.cr[6].compare_i32(ctx.r[5].s32, 22, &mut ctx.xer);
	// 821B3260: 4198000C  blt cr6, 0x821b326c
	if ctx.cr[6].lt {
	pc = 0x821B326C; continue 'dispatch;
	}
	// 821B3264: 3885FFEC  addi r4, r5, -0x14
	ctx.r[4].s64 = ctx.r[5].s64 + -20;
	// 821B3268: 480000BC  b 0x821b3324
	pc = 0x821B3324; continue 'dispatch;
            }
            0x821B326C => {
    //   block [0x821B326C..0x821B32C0)
	// 821B326C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B3270: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3274: 3D008288  lis r8, -0x7d78
	ctx.r[8].s64 = -2105016320;
	// 821B3278: 394BFB08  addi r10, r11, -0x4f8
	ctx.r[10].s64 = ctx.r[11].s64 + -1272;
	// 821B327C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B3280: 54A7103A  slwi r7, r5, 2
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B3284: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 821B3288: 39291CC8  addi r9, r9, 0x1cc8
	ctx.r[9].s64 = ctx.r[9].s64 + 7368;
	// 821B328C: C1A8D4DC  lfs f13, -0x2b24(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3290: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821B3294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3298: 7D47502E  lwzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B329C: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B32A0: 90DF0038  stw r6, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[6].u32 ) };
	// 821B32A4: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B32A8: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B32AC: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821B32B0: 419A0010  beq cr6, 0x821b32c0
	if ctx.cr[6].eq {
	pc = 0x821B32C0; continue 'dispatch;
	}
	// 821B32B4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B32B8: 556B067E  clrlwi r11, r11, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 821B32BC: 48000008  b 0x821b32c4
	pc = 0x821B32C4; continue 'dispatch;
            }
            0x821B32C0 => {
    //   block [0x821B32C0..0x821B32C4)
	// 821B32C0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821B32C4; continue 'dispatch;
            }
            0x821B32C4 => {
    //   block [0x821B32C4..0x821B32E4)
	// 821B32C4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B32C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B32CC: 419A0024  beq cr6, 0x821b32f0
	if ctx.cr[6].eq {
	pc = 0x821B32F0; continue 'dispatch;
	}
	// 821B32D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B32D4: 41980010  blt cr6, 0x821b32e4
	if ctx.cr[6].lt {
	pc = 0x821B32E4; continue 'dispatch;
	}
	// 821B32D8: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B32DC: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B32E0: 41980014  blt cr6, 0x821b32f4
	if ctx.cr[6].lt {
	pc = 0x821B32F4; continue 'dispatch;
	}
	pc = 0x821B32E4; continue 'dispatch;
            }
            0x821B32E4 => {
    //   block [0x821B32E4..0x821B32F0)
	// 821B32E4: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B32E8: 90890008  stw r4, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821B32EC: 4800000C  b 0x821b32f8
	pc = 0x821B32F8; continue 'dispatch;
            }
            0x821B32F0 => {
    //   block [0x821B32F0..0x821B32F4)
	// 821B32F0: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B32F4; continue 'dispatch;
            }
            0x821B32F4 => {
    //   block [0x821B32F4..0x821B32F8)
	// 821B32F4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821B32F8; continue 'dispatch;
            }
            0x821B32F8 => {
    //   block [0x821B32F8..0x821B3318)
	// 821B32F8: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B32FC: 2F0A001A  cmpwi cr6, r10, 0x1a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 26, &mut ctx.xer);
	// 821B3300: 419A0020  beq cr6, 0x821b3320
	if ctx.cr[6].eq {
	pc = 0x821B3320; continue 'dispatch;
	}
	// 821B3304: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3308: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B330C: 419A000C  beq cr6, 0x821b3318
	if ctx.cr[6].eq {
	pc = 0x821B3318; continue 'dispatch;
	}
	// 821B3310: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B3314: 41980018  blt cr6, 0x821b332c
	if ctx.cr[6].lt {
	pc = 0x821B332C; continue 'dispatch;
	}
	pc = 0x821B3318; continue 'dispatch;
            }
            0x821B3318 => {
    //   block [0x821B3318..0x821B3320)
	// 821B3318: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B331C: 48000008  b 0x821b3324
	pc = 0x821B3324; continue 'dispatch;
            }
            0x821B3320 => {
    //   block [0x821B3320..0x821B3324)
	// 821B3320: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821B3324; continue 'dispatch;
            }
            0x821B3324 => {
    //   block [0x821B3324..0x821B332C)
	// 821B3324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B3328: 4BFFFD91  bl 0x821b30b8
	ctx.lr = 0x821B332C;
	sub_821B30B8(ctx, base);
	pc = 0x821B332C; continue 'dispatch;
            }
            0x821B332C => {
    //   block [0x821B332C..0x821B3340)
	// 821B332C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B3330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B3334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B3338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B333C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3340 size=144
    let mut pc: u32 = 0x821B3340;
    'dispatch: loop {
        match pc {
            0x821B3340 => {
    //   block [0x821B3340..0x821B3374)
	// 821B3340: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B3348: 616BBEB8  ori r11, r11, 0xbeb8
	ctx.r[11].u64 = ctx.r[11].u64 | 48824;
	// 821B334C: 7CE35A2E  lhzx r7, r3, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3350: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 821B3354: 409A0024  bne cr6, 0x821b3378
	if !ctx.cr[6].eq {
	pc = 0x821B3378; continue 'dispatch;
	}
	// 821B3358: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B335C: 616BED6A  ori r11, r11, 0xed6a
	ctx.r[11].u64 = ctx.r[11].u64 | 60778;
	// 821B3360: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3364: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B3368: 419A000C  beq cr6, 0x821b3374
	if ctx.cr[6].eq {
	pc = 0x821B3374; continue 'dispatch;
	}
	// 821B336C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B3370: 409A0008  bne cr6, 0x821b3378
	if !ctx.cr[6].eq {
	pc = 0x821B3378; continue 'dispatch;
	}
	pc = 0x821B3374; continue 'dispatch;
            }
            0x821B3374 => {
    //   block [0x821B3374..0x821B3378)
	// 821B3374: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x821B3378; continue 'dispatch;
            }
            0x821B3378 => {
    //   block [0x821B3378..0x821B33C8)
	// 821B3378: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B337C: 6168D380  ori r8, r11, 0xd380
	ctx.r[8].u64 = ctx.r[11].u64 | 54144;
	// 821B3380: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B3384: 392BBFF0  addi r9, r11, -0x4010
	ctx.r[9].s64 = ctx.r[11].s64 + -16400;
	// 821B3388: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B338C: 616B85E4  ori r11, r11, 0x85e4
	ctx.r[11].u64 = ctx.r[11].u64 | 34276;
	// 821B3390: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3394: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B3398: 419A01DC  beq cr6, 0x821b3574
	if ctx.cr[6].eq {
		sub_821B3560(ctx, base);
		return;
	}
	// 821B339C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B33A0: 616BA95C  ori r11, r11, 0xa95c
	ctx.r[11].u64 = ctx.r[11].u64 | 43356;
	// 821B33A4: 7D43582E  lwzx r10, r3, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B33A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B33AC: 409A0024  bne cr6, 0x821b33d0
	if !ctx.cr[6].eq {
		sub_821B33D0(ctx, base);
		return;
	}
	// 821B33B0: 7D63422E  lhzx r11, r3, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B33B4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B33B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B33BC: 419A000C  beq cr6, 0x821b33c8
	if ctx.cr[6].eq {
	pc = 0x821B33C8; continue 'dispatch;
	}
	// 821B33C0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B33C4: 409A000C  bne cr6, 0x821b33d0
	if !ctx.cr[6].eq {
		sub_821B33D0(ctx, base);
		return;
	}
	pc = 0x821B33C8; continue 'dispatch;
            }
            0x821B33C8 => {
    //   block [0x821B33C8..0x821B33D0)
	// 821B33C8: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821B33CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B33D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B33D0 size=28
    let mut pc: u32 = 0x821B33D0;
    'dispatch: loop {
        match pc {
            0x821B33D0 => {
    //   block [0x821B33D0..0x821B33EC)
	// 821B33D0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B33D4: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B33D8: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B33DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B33E0: 419A000C  beq cr6, 0x821b33ec
	if ctx.cr[6].eq {
		sub_821B33EC(ctx, base);
		return;
	}
	// 821B33E4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B33E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B33EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B33EC size=48
    let mut pc: u32 = 0x821B33EC;
    'dispatch: loop {
        match pc {
            0x821B33EC => {
    //   block [0x821B33EC..0x821B341C)
	// 821B33EC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B33F0: 616BEB03  ori r11, r11, 0xeb03
	ctx.r[11].u64 = ctx.r[11].u64 | 60163;
	// 821B33F4: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B33F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B33FC: 419A0044  beq cr6, 0x821b3440
	if ctx.cr[6].eq {
		sub_821B3440(ctx, base);
		return;
	}
	// 821B3400: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B3404: 409A0018  bne cr6, 0x821b341c
	if !ctx.cr[6].eq {
		sub_821B341C(ctx, base);
		return;
	}
	// 821B3408: 7D63422E  lhzx r11, r3, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B340C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3410: 409A000C  bne cr6, 0x821b341c
	if !ctx.cr[6].eq {
		sub_821B341C(ctx, base);
		return;
	}
	// 821B3414: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 821B3418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B341C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B341C size=36
    let mut pc: u32 = 0x821B341C;
    'dispatch: loop {
        match pc {
            0x821B341C => {
    //   block [0x821B341C..0x821B3440)
	// 821B341C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3420: 616BBED4  ori r11, r11, 0xbed4
	ctx.r[11].u64 = ctx.r[11].u64 | 48852;
	// 821B3424: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3428: 896B0006  lbz r11, 6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 821B342C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B3430: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B3434: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B3438: 386B0003  addi r3, r11, 3
	ctx.r[3].s64 = ctx.r[11].s64 + 3;
	// 821B343C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3440 size=120
    let mut pc: u32 = 0x821B3440;
    'dispatch: loop {
        match pc {
            0x821B3440 => {
    //   block [0x821B3440..0x821B3460)
	// 821B3440: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B3444: 616B8654  ori r11, r11, 0x8654
	ctx.r[11].u64 = ctx.r[11].u64 | 34388;
	// 821B3448: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B344C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 821B3450: 409A0010  bne cr6, 0x821b3460
	if !ctx.cr[6].eq {
	pc = 0x821B3460; continue 'dispatch;
	}
	// 821B3454: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B3458: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B345C: 419AFF6C  beq cr6, 0x821b33c8
	if ctx.cr[6].eq {
		sub_821B3340(ctx, base);
		return;
	}
	pc = 0x821B3460; continue 'dispatch;
            }
            0x821B3460 => {
    //   block [0x821B3460..0x821B34B8)
	// 821B3460: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3464: 616BEB59  ori r11, r11, 0xeb59
	ctx.r[11].u64 = ctx.r[11].u64 | 60249;
	// 821B3468: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B346C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3470: 409AFF58  bne cr6, 0x821b33c8
	if !ctx.cr[6].eq {
		sub_821B3340(ctx, base);
		return;
	}
	// 821B3474: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3478: 616BED3A  ori r11, r11, 0xed3a
	ctx.r[11].u64 = ctx.r[11].u64 | 60730;
	// 821B347C: 7D435A2E  lhzx r10, r3, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3480: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3484: 616BED48  ori r11, r11, 0xed48
	ctx.r[11].u64 = ctx.r[11].u64 | 60744;
	// 821B3488: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 821B348C: 409A0040  bne cr6, 0x821b34cc
	if !ctx.cr[6].eq {
		sub_821B34B8(ctx, base);
		return;
	}
	// 821B3490: 7CA35A2E  lhzx r5, r3, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3494: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B3498: 409A0020  bne cr6, 0x821b34b8
	if !ctx.cr[6].eq {
		sub_821B34B8(ctx, base);
		return;
	}
	// 821B349C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B34A0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B34A4: 616B8658  ori r11, r11, 0x8658
	ctx.r[11].u64 = ctx.r[11].u64 | 34392;
	// 821B34A8: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34AC: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 821B34B0: 51630FBC  rlwimi r3, r11, 1, 0x1e, 0x1e
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x0000000000000002) | (ctx.r[3].u64 & 0xFFFFFFFFFFFFFFFD);
	// 821B34B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B34B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B34B8 size=48
    let mut pc: u32 = 0x821B34B8;
    'dispatch: loop {
        match pc {
            0x821B34B8 => {
    //   block [0x821B34B8..0x821B34CC)
	// 821B34B8: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 821B34BC: 409A0010  bne cr6, 0x821b34cc
	if !ctx.cr[6].eq {
	pc = 0x821B34CC; continue 'dispatch;
	}
	// 821B34C0: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B34C8: 409A02C8  bne cr6, 0x821b3790
	if !ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	pc = 0x821B34CC; continue 'dispatch;
            }
            0x821B34CC => {
    //   block [0x821B34CC..0x821B34E8)
	// 821B34CC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B34D0: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 821B34D4: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B34DC: 419A000C  beq cr6, 0x821b34e8
	if ctx.cr[6].eq {
		sub_821B34E8(ctx, base);
		return;
	}
	// 821B34E0: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821B34E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B34E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B34E8 size=96
    let mut pc: u32 = 0x821B34E8;
    'dispatch: loop {
        match pc {
            0x821B34E8 => {
    //   block [0x821B34E8..0x821B3548)
	// 821B34E8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B34EC: 616BEB0F  ori r11, r11, 0xeb0f
	ctx.r[11].u64 = ctx.r[11].u64 | 60175;
	// 821B34F0: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B34F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B34F8: 419A0068  beq cr6, 0x821b3560
	if ctx.cr[6].eq {
		sub_821B3560(ctx, base);
		return;
	}
	// 821B34FC: 3D630002  addis r11, r3, 2
	ctx.r[11].s64 = ctx.r[3].s64 + 131072;
	// 821B3500: 396BD340  addi r11, r11, -0x2cc0
	ctx.r[11].s64 = ctx.r[11].s64 + -11456;
	// 821B3504: C00B002C  lfs f0, 0x2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3508: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B350C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 821B3510: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3514: C00BE360  lfs f0, -0x1ca0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3518: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B351C: 4198002C  blt cr6, 0x821b3548
	if ctx.cr[6].lt {
		sub_821B3548(ctx, base);
		return;
	}
	// 821B3520: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3524: 616BEDC4  ori r11, r11, 0xedc4
	ctx.r[11].u64 = ctx.r[11].u64 | 60868;
	// 821B3528: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B352C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B3530: 2F0B00C8  cmpwi cr6, r11, 0xc8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 200, &mut ctx.xer);
	// 821B3534: 41980014  blt cr6, 0x821b3548
	if ctx.cr[6].lt {
		sub_821B3548(ctx, base);
		return;
	}
	// 821B3538: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 821B353C: 409AFFA4  bne cr6, 0x821b34e0
	if !ctx.cr[6].eq {
		sub_821B34B8(ctx, base);
		return;
	}
	// 821B3540: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 821B3544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3548 size=24
    let mut pc: u32 = 0x821B3548;
    'dispatch: loop {
        match pc {
            0x821B3548 => {
    //   block [0x821B3548..0x821B3560)
	// 821B3548: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 821B354C: 409AFFF4  bne cr6, 0x821b3540
	if !ctx.cr[6].eq {
		sub_821B34E8(ctx, base);
		return;
	}
	// 821B3550: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821B3554: 409AFFEC  bne cr6, 0x821b3540
	if !ctx.cr[6].eq {
		sub_821B34E8(ctx, base);
		return;
	}
	// 821B3558: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 821B355C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3560 size=84
    let mut pc: u32 = 0x821B3560;
    'dispatch: loop {
        match pc {
            0x821B3560 => {
    //   block [0x821B3560..0x821B35B4)
	// 821B3560: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3564: 616BEB0E  ori r11, r11, 0xeb0e
	ctx.r[11].u64 = ctx.r[11].u64 | 60174;
	// 821B3568: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B356C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3570: 409AFE58  bne cr6, 0x821b33c8
	if !ctx.cr[6].eq {
		sub_821B3340(ctx, base);
		return;
	}
	// 821B3574: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B3578: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 821B357C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3580: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B3584: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B3588: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B358C: 419A0114  beq cr6, 0x821b36a0
	if ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B3590: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B3594: 419A0020  beq cr6, 0x821b35b4
	if ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B3598: 2F070023  cmpwi cr6, r7, 0x23
	ctx.cr[6].compare_i32(ctx.r[7].s32, 35, &mut ctx.xer);
	// 821B359C: 409A01EC  bne cr6, 0x821b3788
	if !ctx.cr[6].eq {
		sub_821B35B4(ctx, base);
		return;
	}
	// 821B35A0: 7CCB0034  cntlzw r11, r6
	ctx.r[11].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 821B35A4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B35A8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 821B35AC: 386B0012  addi r3, r11, 0x12
	ctx.r[3].s64 = ctx.r[11].s64 + 18;
	// 821B35B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B35B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B35B4 size=484
    let mut pc: u32 = 0x821B35B4;
    'dispatch: loop {
        match pc {
            0x821B35B4 => {
    //   block [0x821B35B4..0x821B3698)
	// 821B35B4: 3967FFFF  addi r11, r7, -1
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	// 821B35B8: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 821B35BC: 419901C4  bgt cr6, 0x821b3780
	if ctx.cr[6].gt {
	pc = 0x821B3780; continue 'dispatch;
	}
	// 821B35C0: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B35C4: 398C35D8  addi r12, r12, 0x35d8
	ctx.r[12].s64 = ctx.r[12].s64 + 13784;
	// 821B35C8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B35CC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B35D0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B35D4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		1 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		2 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		3 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		4 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		5 => {
	pc = 0x821B3698; continue 'dispatch;
		},
		6 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		7 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		8 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		9 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		10 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		11 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		12 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		13 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		14 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		15 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		16 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		17 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		18 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		19 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		20 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		21 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		22 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		23 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		24 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		25 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		26 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		27 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		28 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		29 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		30 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		31 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		32 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		33 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		34 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		35 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		36 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		37 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		38 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		39 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		40 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		41 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		42 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		43 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		44 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		45 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		46 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		47 => {
	pc = 0x821B3788; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B35D8: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35DC: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35E0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35E4: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35E8: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35EC: 821B3698  lwz r16, 0x3698(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13976 as u32) ) } as u64;
	// 821B35F0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B35F4: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35F8: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B35FC: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3600: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3604: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3608: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B360C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3610: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3614: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3618: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B361C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3620: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3624: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3628: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B362C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3630: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3634: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3638: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B363C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3640: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3644: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3648: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B364C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3650: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3654: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3658: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B365C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3660: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3664: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3668: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B366C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3670: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3674: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3678: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B367C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3680: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3684: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3688: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B368C: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3690: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3694: 821B3788  lwz r16, 0x3788(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14216 as u32) ) } as u64;
            }
            0x821B3698 => {
    //   block [0x821B3698..0x821B3780)
	// 821B3698: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821B369C: 4E800020  blr
	return;
	// 821B36A0: 3967FFFE  addi r11, r7, -2
	ctx.r[11].s64 = ctx.r[7].s64 + -2;
	// 821B36A4: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 821B36A8: 419900E8  bgt cr6, 0x821b3790
	if ctx.cr[6].gt {
	pc = 0x821B3790; continue 'dispatch;
	}
	// 821B36AC: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B36B0: 398C36C4  addi r12, r12, 0x36c4
	ctx.r[12].s64 = ctx.r[12].s64 + 14020;
	// 821B36B4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B36B8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B36BC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B36C0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		1 => {
	pc = 0x821B3788; continue 'dispatch;
		},
		2 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		3 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		4 => {
	pc = 0x821B3698; continue 'dispatch;
		},
		5 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		6 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		7 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		8 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		9 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		10 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		11 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		12 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		13 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		14 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		15 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		16 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		17 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		18 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		19 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		20 => {
	pc = 0x821B3698; continue 'dispatch;
		},
		21 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		22 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		23 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		24 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		25 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		26 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		27 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		28 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		29 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		30 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		31 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		32 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		33 => {
	pc = 0x821B3780; continue 'dispatch;
		},
		34 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		35 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		36 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		37 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		38 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		39 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		40 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		41 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		42 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		43 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		44 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		45 => {
	pc = 0x821B3790; continue 'dispatch;
		},
		46 => {
	pc = 0x821B3788; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B36C4: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B36C8: 821B3788  lwz r16, 0x3788(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14216 as u32) ) } as u64;
	// 821B36CC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36D0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36D4: 821B3698  lwz r16, 0x3698(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13976 as u32) ) } as u64;
	// 821B36D8: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36DC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36E0: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36E4: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36E8: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B36EC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36F0: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B36F4: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36F8: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B36FC: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3700: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3704: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3708: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B370C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3710: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B3714: 821B3698  lwz r16, 0x3698(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13976 as u32) ) } as u64;
	// 821B3718: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B371C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3720: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3724: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3728: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B372C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3730: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3734: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3738: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B373C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3740: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3744: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3748: 821B3780  lwz r16, 0x3780(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14208 as u32) ) } as u64;
	// 821B374C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3750: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3754: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3758: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B375C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3760: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3764: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3768: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B376C: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3770: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3774: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B3778: 821B3790  lwz r16, 0x3790(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14224 as u32) ) } as u64;
	// 821B377C: 821B3788  lwz r16, 0x3788(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(14216 as u32) ) } as u64;
            }
            0x821B3780 => {
    //   block [0x821B3780..0x821B3788)
	// 821B3780: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821B3784: 4E800020  blr
	return;
            }
            0x821B3788 => {
    //   block [0x821B3788..0x821B3790)
	// 821B3788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B378C: 4E800020  blr
	return;
            }
            0x821B3790 => {
    //   block [0x821B3790..0x821B3798)
	// 821B3790: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 821B3794: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3798 size=220
    let mut pc: u32 = 0x821B3798;
    'dispatch: loop {
        match pc {
            0x821B3798 => {
    //   block [0x821B3798..0x821B37DC)
	// 821B3798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B379C: 48381909  bl 0x825350a4
	ctx.lr = 0x821B37A0;
	sub_82535080(ctx, base);
	// 821B37A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B37A4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B37A8: 38A00C40  li r5, 0xc40
	ctx.r[5].s64 = 3136;
	// 821B37AC: 3BCBCF90  addi r30, r11, -0x3070
	ctx.r[30].s64 = ctx.r[11].s64 + -12400;
	// 821B37B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B37B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B37B8: 48381A19  bl 0x825351d0
	ctx.lr = 0x821B37BC;
	sub_825351D0(ctx, base);
	// 821B37BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821B37C0: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 821B37C4: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 821B37C8: 3B0000A6  li r24, 0xa6
	ctx.r[24].s64 = 166;
	// 821B37CC: 3B200015  li r25, 0x15
	ctx.r[25].s64 = 21;
	// 821B37D0: 3B400011  li r26, 0x11
	ctx.r[26].s64 = 17;
	// 821B37D4: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 821B37D8: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	pc = 0x821B37DC; continue 'dispatch;
            }
            0x821B37DC => {
    //   block [0x821B37DC..0x821B3874)
	// 821B37DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B37E0: B2FFFFFC  sth r23, -4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[23].u16 ) };
	// 821B37E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B37E8: B31FFFFE  sth r24, -2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(-2 as u32), ctx.r[24].u16 ) };
	// 821B37EC: B33F0000  sth r25, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 821B37F0: B35F0002  sth r26, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[26].u16 ) };
	// 821B37F4: B37F0004  sth r27, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 821B37F8: B39F0006  sth r28, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[28].u16 ) };
	// 821B37FC: 4800007D  bl 0x821b3878
	ctx.lr = 0x821B3800;
	sub_821B3878(ctx, base);
	// 821B3800: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821B3804: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 821B3808: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821B380C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B3810: 4198FFCC  blt cr6, 0x821b37dc
	if ctx.cr[6].lt {
	pc = 0x821B37DC; continue 'dispatch;
	}
	// 821B3814: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B3818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B381C: C00BD4DC  lfs f0, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3820: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3824: D01E07F0  stfs f0, 0x7f0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2032 as u32), tmp.u32 ) };
	// 821B3828: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B382C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B3830: D01E0800  stfs f0, 0x800(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2048 as u32), tmp.u32 ) };
	// 821B3834: D01E0804  stfs f0, 0x804(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2052 as u32), tmp.u32 ) };
	// 821B3838: D01E0808  stfs f0, 0x808(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2056 as u32), tmp.u32 ) };
	// 821B383C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3840: D1BE080C  stfs f13, 0x80c(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2060 as u32), tmp.u32 ) };
	// 821B3844: D01E0810  stfs f0, 0x810(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2064 as u32), tmp.u32 ) };
	// 821B3848: D01E0814  stfs f0, 0x814(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2068 as u32), tmp.u32 ) };
	// 821B384C: D01E0818  stfs f0, 0x818(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2072 as u32), tmp.u32 ) };
	// 821B3850: D1BE081C  stfs f13, 0x81c(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2076 as u32), tmp.u32 ) };
	// 821B3854: D01E0820  stfs f0, 0x820(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(2080 as u32), tmp.u32 ) };
	// 821B3858: 480007B9  bl 0x821b4010
	ctx.lr = 0x821B385C;
	sub_821B4010(ctx, base);
	// 821B385C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3860: C00B2190  lfs f0, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3864: D01E0C34  stfs f0, 0xc34(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3124 as u32), tmp.u32 ) };
	// 821B3868: 48000121  bl 0x821b3988
	ctx.lr = 0x821B386C;
	sub_821B3988(ctx, base);
	// 821B386C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B3870: 48381884  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B3878 size=268
    let mut pc: u32 = 0x821B3878;
    'dispatch: loop {
        match pc {
            0x821B3878 => {
    //   block [0x821B3878..0x821B38B0)
	// 821B3878: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B387C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B3880: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B3884: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821B3888: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B388C: 1D440310  mulli r10, r4, 0x310
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * 784 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821B3890: C0061FF8  lfs f0, 0x1ff8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3894: 38EB06A2  addi r7, r11, 0x6a2
	ctx.r[7].s64 = ctx.r[11].s64 + 1698;
	// 821B3898: 1D040031  mulli r8, r4, 0x31
	ctx.r[8].s32 = ((ctx.r[4].s32 as i64 * 49 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821B389C: 392B0028  addi r9, r11, 0x28
	ctx.r[9].s64 = ctx.r[11].s64 + 40;
	// 821B38A0: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 821B38A4: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B38A8: 38E00031  li r7, 0x31
	ctx.r[7].s64 = 49;
	// 821B38AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B38B0; continue 'dispatch;
            }
            0x821B38B0 => {
    //   block [0x821B38B0..0x821B3984)
	// 821B38B0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 821B38B4: D009FFF8  stfs f0, -8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B38B8: D009FFFC  stfs f0, -4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821B38BC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B38C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B38C4: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B38C8: 9948FF9E  stb r10, -0x62(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(-98 as u32), ctx.r[10].u8 ) };
	// 821B38CC: 99480000  stb r10, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821B38D0: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 821B38D4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821B38D8: 409AFFD8  bne cr6, 0x821b38b0
	if !ctx.cr[6].eq {
	pc = 0x821B38B0; continue 'dispatch;
	}
	// 821B38DC: 390B07D0  addi r8, r11, 0x7d0
	ctx.r[8].s64 = ctx.r[11].s64 + 2000;
	// 821B38E0: 54892036  slwi r9, r4, 4
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B38E4: 38EB0798  addi r7, r11, 0x798
	ctx.r[7].s64 = ctx.r[11].s64 + 1944;
	// 821B38E8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B38EC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821B38F0: 5486103A  slwi r6, r4, 2
	ctx.r[6].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B38F4: 38AB0778  addi r5, r11, 0x778
	ctx.r[5].s64 = ctx.r[11].s64 + 1912;
	// 821B38F8: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B38FC: 3BEB0780  addi r31, r11, 0x780
	ctx.r[31].s64 = ctx.r[11].s64 + 1920;
	// 821B3900: C1A8BA38  lfs f13, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3904: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B3908: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B390C: 7C062D2E  stfsx f0, r6, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 821B3910: 38CB0790  addi r6, r11, 0x790
	ctx.r[6].s64 = ctx.r[11].s64 + 1936;
	// 821B3914: 5485103A  slwi r5, r4, 2
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B3918: 7C03FD2E  stfsx f0, r3, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821B391C: 386B07B0  addi r3, r11, 0x7b0
	ctx.r[3].s64 = ctx.r[11].s64 + 1968;
	// 821B3920: 7D48392E  stwx r10, r8, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32), ctx.r[10].u32) };
	// 821B3924: 390B0788  addi r8, r11, 0x788
	ctx.r[8].s64 = ctx.r[11].s64 + 1928;
	// 821B3928: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B392C: 3BEB07B8  addi r31, r11, 0x7b8
	ctx.r[31].s64 = ctx.r[11].s64 + 1976;
	// 821B3930: 7D45192E  stwx r10, r5, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 821B3934: 5485103A  slwi r5, r4, 2
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821B3938: 7D5E412E  stwx r10, r30, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 821B393C: 386B07C8  addi r3, r11, 0x7c8
	ctx.r[3].s64 = ctx.r[11].s64 + 1992;
	// 821B3940: 7D47312E  stwx r10, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[10].u32) };
	// 821B3944: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B3948: 5487103A  slwi r7, r4, 2
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B394C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B3950: 38CB07A8  addi r6, r11, 0x7a8
	ctx.r[6].s64 = ctx.r[11].s64 + 1960;
	// 821B3954: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B3958: 5484103A  slwi r4, r4, 2
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821B395C: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B3960: 396B0824  addi r11, r11, 0x824
	ctx.r[11].s64 = ctx.r[11].s64 + 2084;
	// 821B3964: D1A9000C  stfs f13, 0xc(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B3968: 7D48F92E  stwx r10, r8, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 821B396C: 7D45192E  stwx r10, r5, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 821B3970: 7D47312E  stwx r10, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[10].u32) };
	// 821B3974: 7D44592E  stwx r10, r4, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 821B3978: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B397C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821B3980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B3988 size=104
    let mut pc: u32 = 0x821B3988;
    'dispatch: loop {
        match pc {
            0x821B3988 => {
    //   block [0x821B3988..0x821B39A8)
	// 821B3988: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B398C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B3990: 38CBCF90  addi r6, r11, -0x3070
	ctx.r[6].s64 = ctx.r[11].s64 + -12400;
	// 821B3994: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B3998: 39660028  addi r11, r6, 0x28
	ctx.r[11].s64 = ctx.r[6].s64 + 40;
	// 821B399C: 394606A2  addi r10, r6, 0x6a2
	ctx.r[10].s64 = ctx.r[6].s64 + 1698;
	// 821B39A0: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B39A4: 39060770  addi r8, r6, 0x770
	ctx.r[8].s64 = ctx.r[6].s64 + 1904;
	pc = 0x821B39A8; continue 'dispatch;
            }
            0x821B39A8 => {
    //   block [0x821B39A8..0x821B39B0)
	// 821B39A8: 39200031  li r9, 0x31
	ctx.r[9].s64 = 49;
	// 821B39AC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x821B39B0; continue 'dispatch;
            }
            0x821B39B0 => {
    //   block [0x821B39B0..0x821B39F0)
	// 821B39B0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821B39B4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B39B8: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821B39BC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B39C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B39C4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B39C8: 98EAFF9E  stb r7, -0x62(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-98 as u32), ctx.r[7].u8 ) };
	// 821B39CC: 98EA0000  stb r7, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 821B39D0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821B39D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B39D8: 409AFFD8  bne cr6, 0x821b39b0
	if !ctx.cr[6].eq {
	pc = 0x821B39B0; continue 'dispatch;
	}
	// 821B39DC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821B39E0: 39260778  addi r9, r6, 0x778
	ctx.r[9].s64 = ctx.r[6].s64 + 1912;
	// 821B39E4: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B39E8: 4198FFC0  blt cr6, 0x821b39a8
	if ctx.cr[6].lt {
	pc = 0x821B39A8; continue 'dispatch;
	}
	// 821B39EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B39F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B39F0 size=780
    let mut pc: u32 = 0x821B39F0;
    'dispatch: loop {
        match pc {
            0x821B39F0 => {
    //   block [0x821B39F0..0x821B3A70)
	// 821B39F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B39F4: 483816B9  bl 0x825350ac
	ctx.lr = 0x821B39F8;
	sub_82535080(ctx, base);
	// 821B39F8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821B39FC: 483825ED  bl 0x82535fe8
	ctx.lr = 0x821B3A00;
	sub_82535FB0(ctx, base);
	// 821B3A00: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821B3A04: 483859A1  bl 0x825393a4
	ctx.lr = 0x821B3A08;
	sub_82539130(ctx, base);
	// 821B3A08: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3A0C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3A10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B3A14: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B3A18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3A1C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B3A20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821B3A24: 61299B74  ori r9, r9, 0x9b74
	ctx.r[9].u64 = ctx.r[9].u64 | 39796;
	// 821B3A28: 7F7E50AE  lbzx r27, r30, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B3A2C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B3A30: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B3A34: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821B3A38: 577F103E  rotlwi r31, r27, 2
	ctx.r[31].u64 = ((ctx.r[27].u32).rotate_left(2)) as u64;
	// 821B3A3C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 821B3A40: 396B3420  addi r11, r11, 0x3420
	ctx.r[11].s64 = ctx.r[11].s64 + 13344;
	// 821B3A44: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 821B3A48: 7C1E4C2E  lfsx f0, r30, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3A4C: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 821B3A50: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 821B3A54: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3A58: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B3A5C: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B3A60: C1AA2570  lfs f13, 0x2570(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3A64: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821B3A68: 40990008  ble cr6, 0x821b3a70
	if !ctx.cr[6].gt {
	pc = 0x821B3A70; continue 'dispatch;
	}
	// 821B3A6C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x821B3A70; continue 'dispatch;
            }
            0x821B3A70 => {
    //   block [0x821B3A70..0x821B3A9C)
	// 821B3A70: 7C1F5D2E  stfsx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821B3A74: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B3A78: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B3A7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B3A80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3A84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B3A88: 4E800421  bctrl
	ctx.lr = 0x821B3A8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B3A8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B3A90: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B3A94: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821B3A98: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
            }
            0x821B3A9C => {
    //   block [0x821B3A9C..0x821B3CFC)
	// 821B3A9C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B3AA0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B3AA4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B3AA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B3AAC: 4200FFF0  bdnz 0x821b3a9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B3A9C; continue 'dispatch;
	}
	// 821B3AB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B3AB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B3AB8: 481B41D1  bl 0x82367c88
	ctx.lr = 0x821B3ABC;
	sub_82367C88(ctx, base);
	// 821B3ABC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B3AC0: 3B8B0FBC  addi r28, r11, 0xfbc
	ctx.r[28].s64 = ctx.r[11].s64 + 4028;
	// 821B3AC4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 821B3AC8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3D00 size=316
    let mut pc: u32 = 0x821B3D00;
    'dispatch: loop {
        match pc {
            0x821B3D00 => {
    //   block [0x821B3D00..0x821B3D40)
	// 821B3D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B3D04: 483813B9  bl 0x825350bc
	ctx.lr = 0x821B3D08;
	sub_82535080(ctx, base);
	// 821B3D08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3D0C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B3D10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B3D14: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B3D18: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B3D1C: 395D07A0  addi r10, r29, 0x7a0
	ctx.r[10].s64 = ctx.r[29].s64 + 1952;
	// 821B3D20: 57C7103A  slwi r7, r30, 2
	ctx.r[7].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B3D24: 38DD0798  addi r6, r29, 0x798
	ctx.r[6].s64 = ctx.r[29].s64 + 1944;
	// 821B3D28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B3D2C: 7C8B512E  stwx r4, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[4].u32) };
	// 821B3D30: 7D67302E  lwzx r11, r7, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B3D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B3D38: 419A0008  beq cr6, 0x821b3d40
	if ctx.cr[6].eq {
	pc = 0x821B3D40; continue 'dispatch;
	}
	// 821B3D3C: 392B0030  addi r9, r11, 0x30
	ctx.r[9].s64 = ctx.r[11].s64 + 48;
	pc = 0x821B3D40; continue 'dispatch;
            }
            0x821B3D40 => {
    //   block [0x821B3D40..0x821B3E3C)
	// 821B3D40: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B3D44: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B3D48: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 821B3D4C: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B3D50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B3D54: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B3D58: 391D0710  addi r8, r29, 0x710
	ctx.r[8].s64 = ctx.r[29].s64 + 1808;
	// 821B3D5C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B3D60: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821B3D64: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821B3D68: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B3D6C: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821B3D70: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B3D74: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B3D78: 7FE7302E  lwzx r31, r7, r6
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B3D7C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B3D84: 4E800421  bctrl
	ctx.lr = 0x821B3D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B3D88: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3D8C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B3D90: 393D07D0  addi r9, r29, 0x7d0
	ctx.r[9].s64 = ctx.r[29].s64 + 2000;
	// 821B3D94: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3D98: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B3D9C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B3DA0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B3DA4: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3DA8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B3DAC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B3DB0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B3E40 size=336
    let mut pc: u32 = 0x821B3E40;
    'dispatch: loop {
        match pc {
            0x821B3E40 => {
    //   block [0x821B3E40..0x821B3F90)
	// 821B3E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B3E44: 48381279  bl 0x825350bc
	ctx.lr = 0x821B3E48;
	sub_82535080(ctx, base);
	// 821B3E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B3E4C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B3E50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B3E54: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B3E58: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B3E5C: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 821B3E60: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B3E64: 61288410  ori r8, r9, 0x8410
	ctx.r[8].u64 = ctx.r[9].u64 | 33808;
	// 821B3E68: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B3E6C: 392B0750  addi r9, r11, 0x750
	ctx.r[9].s64 = ctx.r[11].s64 + 1872;
	// 821B3E70: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 821B3E74: 554B203E  rotlwi r11, r10, 4
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 821B3E78: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B3E7C: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B3E80: 7C1E442E  lfsx f0, r30, r8
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B3E84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B3E88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B3E8C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B3E90: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B3E94: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B3E98: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B3E9C: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B3EA0: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B3EA4: C18BD4DC  lfs f12, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B3EA8: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B3EAC: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B3EB0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B3EB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B3EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B3EBC: 4E800421  bctrl
	ctx.lr = 0x821B3EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B3EC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B3EC4: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B3F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B3F90 size=128
    let mut pc: u32 = 0x821B3F90;
    'dispatch: loop {
        match pc {
            0x821B3F90 => {
    //   block [0x821B3F90..0x821B3FBC)
	// 821B3F90: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B3F94: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821B3F98: 38EACF90  addi r7, r10, -0x3070
	ctx.r[7].s64 = ctx.r[10].s64 + -12400;
	// 821B3F9C: 89270C30  lbz r9, 0xc30(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B3FA0: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 821B3FA4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 821B3FA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B3FAC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B3FB0: 40990028  ble cr6, 0x821b3fd8
	if !ctx.cr[6].gt {
	pc = 0x821B3FD8; continue 'dispatch;
	}
	// 821B3FB4: A0CB0002  lhz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B3FB8: 39470832  addi r10, r7, 0x832
	ctx.r[10].s64 = ctx.r[7].s64 + 2098;
	pc = 0x821B3FBC; continue 'dispatch;
            }
            0x821B3FBC => {
    //   block [0x821B3FBC..0x821B3FD8)
	// 821B3FBC: A0AA0000  lhz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B3FC0: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B3FC4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B3FC8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821B3FCC: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B3FD0: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B3FD4: 4198FFE8  blt cr6, 0x821b3fbc
	if ctx.cr[6].lt {
	pc = 0x821B3FBC; continue 'dispatch;
	}
	pc = 0x821B3FD8; continue 'dispatch;
            }
            0x821B3FD8 => {
    //   block [0x821B3FD8..0x821B3FEC)
	// 821B3FD8: 552A3032  slwi r10, r9, 6
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B3FDC: 39070830  addi r8, r7, 0x830
	ctx.r[8].s64 = ctx.r[7].s64 + 2096;
	// 821B3FE0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821B3FE4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B3FE8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821B3FEC; continue 'dispatch;
            }
            0x821B3FEC => {
    //   block [0x821B3FEC..0x821B4010)
	// 821B3FEC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B3FF0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B3FF4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B3FF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B3FFC: 4200FFF0  bdnz 0x821b3fec
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B3FEC; continue 'dispatch;
	}
	// 821B4000: 89670C30  lbz r11, 0xc30(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4004: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B4008: 99670C30  stb r11, 0xc30(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(3120 as u32), ctx.r[11].u8 ) };
	// 821B400C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B4010 size=128
    let mut pc: u32 = 0x821B4010;
    'dispatch: loop {
        match pc {
            0x821B4010 => {
    //   block [0x821B4010..0x821B4034)
	// 821B4010: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4014: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 821B4018: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 821B401C: 390BCF90  addi r8, r11, -0x3070
	ctx.r[8].s64 = ctx.r[11].s64 + -12400;
	// 821B4020: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 821B4024: 39680848  addi r11, r8, 0x848
	ctx.r[11].s64 = ctx.r[8].s64 + 2120;
	// 821B4028: C0061FF8  lfs f0, 0x1ff8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B402C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B4030: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x821B4034; continue 'dispatch;
            }
            0x821B4034 => {
    //   block [0x821B4034..0x821B4090)
	// 821B4034: B12BFFEA  sth r9, -0x16(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-22 as u32), ctx.r[9].u16 ) };
	// 821B4038: 38C80C48  addi r6, r8, 0xc48
	ctx.r[6].s64 = ctx.r[8].s64 + 3144;
	// 821B403C: 994BFFE8  stb r10, -0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), ctx.r[10].u8 ) };
	// 821B4040: 994BFFE9  stb r10, -0x17(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-23 as u32), ctx.r[10].u8 ) };
	// 821B4044: 914BFFEC  stw r10, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[10].u32 ) };
	// 821B4048: 90EBFFF0  stw r7, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[7].u32 ) };
	// 821B404C: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B4050: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821B4054: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B4058: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B405C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B4060: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B4064: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821B4068: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B406C: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B4070: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821B4074: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821B4078: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B407C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821B4080: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B4084: 4198FFB0  blt cr6, 0x821b4034
	if ctx.cr[6].lt {
	pc = 0x821B4034; continue 'dispatch;
	}
	// 821B4088: 99480C30  stb r10, 0xc30(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3120 as u32), ctx.r[10].u8 ) };
	// 821B408C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4090 size=564
    let mut pc: u32 = 0x821B4090;
    'dispatch: loop {
        match pc {
            0x821B4090 => {
    //   block [0x821B4090..0x821B413C)
	// 821B4090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4094: 48381025  bl 0x825350b8
	ctx.lr = 0x821B4098;
	sub_82535080(ctx, base);
	// 821B4098: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B409C: E9440000  ld r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 821B40A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B40A4: E9240008  ld r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 821B40A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B40AC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B40B0: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B40B4: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B40B8: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B40BC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B40C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B40C4: C06B1FF8  lfs f3, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B40C8: D0610054  stfs f3, 0x54(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B40CC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B40D0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821B40D4: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 821B40D8: 40990064  ble cr6, 0x821b413c
	if !ctx.cr[6].gt {
	pc = 0x821B413C; continue 'dispatch;
	}
	// 821B40DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B40E0: 1181038C  vspltisw v12, 1
	for i in 0..4 {
		ctx.v[12].u32[i] = 1;
	}
	// 821B40E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B40E8: 1161634A  vcfsx v11, v12, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[11].f32[i] = (ctx.v[12].s32[i] as f32) * scale;
	}
	pc = 0x821B413C; continue 'dispatch;
            }
            0x821B413C => {
    //   block [0x821B413C..0x821B42C4)
	// 821B413C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B4140: FC201890  fmr f1, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[3].f64;
	// 821B4144: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B4148: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B414C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4150: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4154: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B4158: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B415C: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4160: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821B4164: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4168: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B416C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4170: C04B2AF0  lfs f2, 0x2af0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10992 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B4174: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821B4178: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821B417C: 481B409D  bl 0x82368218
	ctx.lr = 0x821B4180;
	sub_82368218(ctx, base);
	// 821B4180: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821B4184: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B4188: 481C0219  bl 0x823743a0
	ctx.lr = 0x821B418C;
	sub_823743A0(ctx, base);
	// 821B418C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B4190: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B4194: 481B43A5  bl 0x82368538
	ctx.lr = 0x821B4198;
	sub_82368538(ctx, base);
	// 821B4198: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821B419C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B42C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B42C8 size=352
    let mut pc: u32 = 0x821B42C8;
    'dispatch: loop {
        match pc {
            0x821B42C8 => {
    //   block [0x821B42C8..0x821B4310)
	// 821B42C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B42CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B42D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B42D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B42D8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821B42DC: 48381D0D  bl 0x82535fe8
	ctx.lr = 0x821B42E0;
	sub_82535FB0(ctx, base);
	// 821B42E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B42E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B42E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B42EC: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B42F0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B42F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B42F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B42FC: 4E800421  bctrl
	ctx.lr = 0x821B4300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4300: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4304: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4308: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821B430C: 39630038  addi r11, r3, 0x38
	ctx.r[11].s64 = ctx.r[3].s64 + 56;
            }
            0x821B4310 => {
    //   block [0x821B4310..0x821B4428)
	// 821B4310: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4314: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B4318: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B431C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4320: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B4324: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4328: C12B0040  lfs f9, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B432C: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4330: C10B0078  lfs f8, 0x78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B4334: ED29682A  fadds f9, f9, f13
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4338: C0EB0080  lfs f7, 0x80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B433C: ED00402A  fadds f8, f0, f8
	ctx.f[8].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 821B4340: C0CB00B8  lfs f6, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B4344: ECE7682A  fadds f7, f7, f13
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4348: C0AB00C0  lfs f5, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B434C: ECC6002A  fadds f6, f6, f0
	ctx.f[6].f64 = ((ctx.f[6].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4350: C08B00F8  lfs f4, 0xf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821B4354: ECA5682A  fadds f5, f5, f13
	ctx.f[5].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4358: C06B0100  lfs f3, 0x100(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B435C: EC80202A  fadds f4, f0, f4
	ctx.f[4].f64 = ((ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64;
	// 821B4360: C04B0138  lfs f2, 0x138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B4364: EC63682A  fadds f3, f3, f13
	ctx.f[3].f64 = ((ctx.f[3].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4368: C02B0140  lfs f1, 0x140(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B436C: EC42002A  fadds f2, f2, f0
	ctx.f[2].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4370: C3EB0178  lfs f31, 0x178(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(376 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B4374: EC21682A  fadds f1, f1, f13
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4378: C3CB0180  lfs f30, 0x180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(384 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B437C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 821B4380: C3AB01B8  lfs f29, 0x1b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B4384: EFDE682A  fadds f30, f30, f13
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4388: C38B01C0  lfs f28, 0x1c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(448 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B438C: EFBD002A  fadds f29, f29, f0
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4390: EF9C682A  fadds f28, f28, f13
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4394: D18BFFF8  stfs f12, -8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821B4398: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B439C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B43A0: D14B0038  stfs f10, 0x38(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B43A4: D12B0040  stfs f9, 0x40(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821B43A8: D10B0078  stfs f8, 0x78(r11)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B43AC: D0EB0080  stfs f7, 0x80(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821B43B0: D0CB00B8  stfs f6, 0xb8(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821B43B4: D0AB00C0  stfs f5, 0xc0(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 821B43B8: D08B00F8  stfs f4, 0xf8(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 821B43BC: D06B0100  stfs f3, 0x100(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 821B43C0: D04B0138  stfs f2, 0x138(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 821B43C4: D02B0140  stfs f1, 0x140(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 821B43C8: D3EB0178  stfs f31, 0x178(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 821B43CC: D3CB0180  stfs f30, 0x180(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 821B43D0: D3AB01B8  stfs f29, 0x1b8(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 821B43D4: D38B01C0  stfs f28, 0x1c0(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 821B43D8: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821B43DC: 409AFF34  bne cr6, 0x821b4310
	if !ctx.cr[6].eq {
	pc = 0x821B4310; continue 'dispatch;
	}
	// 821B43E0: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B43E4: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 821B43E8: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 821B43EC: 616B9248  ori r11, r11, 0x9248
	ctx.r[11].u64 = ctx.r[11].u64 | 37448;
	// 821B43F0: 614A924C  ori r10, r10, 0x924c
	ctx.r[10].u64 = ctx.r[10].u64 | 37452;
	// 821B43F4: 61299244  ori r9, r9, 0x9244
	ctx.r[9].u64 = ctx.r[9].u64 | 37444;
	// 821B43F8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B43FC: 7C1E5D2E  stfsx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821B4400: 7DBE552E  stfsx f13, r30, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 821B4404: 7D1E492E  stwx r8, r30, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 821B4408: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B440C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821B4410: 48381C25  bl 0x82536034
	ctx.lr = 0x821B4414;
	sub_82535FFC(ctx, base);
	// 821B4414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B4418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B441C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B4420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B4424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B4428 size=92
    let mut pc: u32 = 0x821B4428;
    'dispatch: loop {
        match pc {
            0x821B4428 => {
    //   block [0x821B4428..0x821B4484)
	// 821B4428: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821B442C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4430: C00B25B0  lfs f0, 0x25b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4434: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4438: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B443C: C94B2008  lfd f10, 0x2008(r11)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 821B4440: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4444: C96B2000  lfd f11, 0x2000(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 821B4448: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B444C: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B4450: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4454: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B4458: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B445C: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 821B4460: 40980024  bge cr6, 0x821b4484
	if !ctx.cr[6].lt {
		sub_821B4484(ctx, base);
		return;
	}
	// 821B4464: C1ABD4DC  lfs f13, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4468: EDAD1024  fdivs f13, f13, f2
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[2].f64) as f32) as f64;
	// 821B446C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B4470: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B4474: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4478: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B447C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B4480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4484(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B4484 size=44
    let mut pc: u32 = 0x821B4484;
    'dispatch: loop {
        match pc {
            0x821B4484 => {
    //   block [0x821B4484..0x821B44B0)
	// 821B4484: C18BD4DC  lfs f12, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4488: EDA2602A  fadds f13, f2, f12
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[12].f64) as f32) as f64;
	// 821B448C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B4490: 40980020  bge cr6, 0x821b44b0
	if !ctx.cr[6].lt {
		sub_821B44B0(ctx, base);
		return;
	}
	// 821B4494: EDAC1028  fsubs f13, f12, f2
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B4498: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B449C: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B44A0: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B44A4: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B44A8: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B44AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B44B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B44B0 size=68
    let mut pc: u32 = 0x821B44B0;
    'dispatch: loop {
        match pc {
            0x821B44B0 => {
    //   block [0x821B44B0..0x821B44F4)
	// 821B44B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B44B4: C1ABD6C8  lfs f13, -0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B44B8: EDA2682A  fadds f13, f2, f13
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B44BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B44C0: 40980034  bge cr6, 0x821b44f4
	if !ctx.cr[6].lt {
		sub_821B44F4(ctx, base);
		return;
	}
	// 821B44C4: EDA01028  fsubs f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B44C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B44CC: C00B2164  lfs f0, 0x2164(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B44D4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B44D8: C00B20D8  lfs f0, 0x20d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8408 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B44DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B44E0: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B44E4: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B44E8: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B44EC: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B44F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B44F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B44F4 size=56
    let mut pc: u32 = 0x821B44F4;
    'dispatch: loop {
        match pc {
            0x821B44F4 => {
    //   block [0x821B44F4..0x821B452C)
	// 821B44F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B44F8: C1ABD6D0  lfs f13, -0x2930(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B44FC: EDA2682A  fadds f13, f2, f13
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B4500: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B4504: 40980028  bge cr6, 0x821b452c
	if !ctx.cr[6].lt {
		sub_821B452C(ctx, base);
		return;
	}
	// 821B4508: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B450C: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4510: EDAD1028  fsubs f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B4514: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B4518: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B451C: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4520: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B4524: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B4528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B452C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B452C size=64
    let mut pc: u32 = 0x821B452C;
    'dispatch: loop {
        match pc {
            0x821B452C => {
    //   block [0x821B452C..0x821B456C)
	// 821B452C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4530: C1AB20C8  lfs f13, 0x20c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4534: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B4538: ED2D1028  fsubs f9, f13, f2
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B453C: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4540: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4544: EDA06B3A  fmadds f13, f0, f12, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B4548: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B454C: EC004824  fdivs f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 821B4550: EDAD1028  fsubs f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 821B4554: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B4558: FC00502E  fsel f0, f0, f0, f10
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 821B455C: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 821B4560: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 821B4564: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B4568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B4570 size=172
    let mut pc: u32 = 0x821B4570;
    'dispatch: loop {
        match pc {
            0x821B4570 => {
    //   block [0x821B4570..0x821B45C4)
	// 821B4570: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821B4574: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 821B4578: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 821B457C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4580: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821B4584: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B4588: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821B458C: 419A0038  beq cr6, 0x821b45c4
	if ctx.cr[6].eq {
	pc = 0x821B45C4; continue 'dispatch;
	}
	// 821B4590: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4594: 556BA73E  rlwinm r11, r11, 0x14, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821B4598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B459C: 419A0028  beq cr6, 0x821b45c4
	if ctx.cr[6].eq {
	pc = 0x821B45C4; continue 'dispatch;
	}
	// 821B45A0: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B45A4: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 821B45A8: 394ACF90  addi r10, r10, -0x3070
	ctx.r[10].s64 = ctx.r[10].s64 + -12400;
	// 821B45AC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B45B0: 394A07F0  addi r10, r10, 0x7f0
	ctx.r[10].s64 = ctx.r[10].s64 + 2032;
	pc = 0x821B45C4; continue 'dispatch;
            }
            0x821B45C4 => {
    //   block [0x821B45C4..0x821B461C)
	// 821B45C4: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4620 size=360
    let mut pc: u32 = 0x821B4620;
    'dispatch: loop {
        match pc {
            0x821B4620 => {
    //   block [0x821B4620..0x821B4710)
	// 821B4620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4624: 48380A91  bl 0x825350b4
	ctx.lr = 0x821B4628;
	sub_82535080(ctx, base);
	// 821B4628: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821B462C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821B4630: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4638: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B463C: 3F7F0002  addis r27, r31, 2
	ctx.r[27].s64 = ctx.r[31].s64 + 131072;
	// 821B4640: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B4644: 3B7BBE64  addi r27, r27, -0x419c
	ctx.r[27].s64 = ctx.r[27].s64 + -16796;
	// 821B4648: 391D0750  addi r8, r29, 0x750
	ctx.r[8].s64 = ctx.r[29].s64 + 1872;
	// 821B464C: 393D0798  addi r9, r29, 0x798
	ctx.r[9].s64 = ctx.r[29].s64 + 1944;
	// 821B4650: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B4654: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B4658: 895B0000  lbz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B465C: 5547103E  rotlwi r7, r10, 2
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B4660: 554A203E  rotlwi r10, r10, 4
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 821B4664: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B4668: 7D27482E  lwzx r9, r7, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B466C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4670: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B4674: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B4678: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B467C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B4680: 419A00E4  beq cr6, 0x821b4764
	if ctx.cr[6].eq {
	pc = 0x821B4764; continue 'dispatch;
	}
	// 821B4684: 3BC90030  addi r30, r9, 0x30
	ctx.r[30].s64 = ctx.r[9].s64 + 48;
	// 821B4688: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B468C: 419A00D8  beq cr6, 0x821b4764
	if ctx.cr[6].eq {
	pc = 0x821B4764; continue 'dispatch;
	}
	// 821B4690: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B4694: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4698: 4837E811  bl 0x82532ea8
	ctx.lr = 0x821B469C;
	sub_82532EA8(ctx, base);
	// 821B469C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B46A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B46A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B46A8: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 821B46AC: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B46B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B46B4: C3EB2254  lfs f31, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B46B8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B46BC: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B46C0: 4BF88C19  bl 0x8213d2d8
	ctx.lr = 0x821B46C4;
	sub_8213D2D8(ctx, base);
	// 821B46C4: C1810058  lfs f12, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B46C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B46CC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B46D0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B46D4: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B46D8: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B46DC: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B46E0: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B46E4: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B46E8: EDAA02FA  fmadds f13, f10, f11, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B46EC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B46F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B46F4: C18BBA38  lfs f12, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B46F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B46FC: 41980014  blt cr6, 0x821b4710
	if ctx.cr[6].lt {
	pc = 0x821B4710; continue 'dispatch;
	}
	// 821B4700: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4704: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821B4708: C3CB2074  lfs f30, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B470C: 4800001C  b 0x821b4728
	pc = 0x821B4728; continue 'dispatch;
            }
            0x821B4710 => {
    //   block [0x821B4710..0x821B4728)
	// 821B4710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4718: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 821B471C: C02BBFFC  lfs f1, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4720: 4BF88BB9  bl 0x8213d2d8
	ctx.lr = 0x821B4724;
	sub_8213D2D8(ctx, base);
	// 821B4724: FFC06090  fmr f30, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[12].f64;
	pc = 0x821B4728; continue 'dispatch;
            }
            0x821B4728 => {
    //   block [0x821B4728..0x821B4764)
	// 821B4728: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B472C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821B4730: EC00603C  fnmsubs f0, f0, f0, f12
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B4734: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821B4738: 4837E771  bl 0x82532ea8
	ctx.lr = 0x821B473C;
	sub_82532EA8(ctx, base);
	// 821B473C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4740: 3C7F0006  addis r3, r31, 6
	ctx.r[3].s64 = ctx.r[31].s64 + 393216;
	// 821B4744: 3863A510  addi r3, r3, -0x5af0
	ctx.r[3].s64 = ctx.r[3].s64 + -23280;
	// 821B4748: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B474C: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B4750: 481B3741  bl 0x82367e90
	ctx.lr = 0x821B4754;
	sub_82367E90(ctx, base);
	// 821B4754: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B4758: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B475C: 616BA550  ori r11, r11, 0xa550
	ctx.r[11].u64 = ctx.r[11].u64 | 42320;
	// 821B4760: 7D5F592E  stwx r10, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	pc = 0x821B4764; continue 'dispatch;
            }
            0x821B4764 => {
    //   block [0x821B4764..0x821B4788)
	// 821B4764: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4768: 395D0788  addi r10, r29, 0x788
	ctx.r[10].s64 = ctx.r[29].s64 + 1928;
	// 821B476C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B4770: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B4774: 7F8B512E  stwx r28, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u32) };
	// 821B4778: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B477C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B4780: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B4784: 48380980  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4788 size=240
    let mut pc: u32 = 0x821B4788;
    'dispatch: loop {
        match pc {
            0x821B4788 => {
    //   block [0x821B4788..0x821B4828)
	// 821B4788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B478C: 4838092D  bl 0x825350b8
	ctx.lr = 0x821B4790;
	sub_82535080(ctx, base);
	// 821B4790: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821B4794: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821B4798: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B479C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B47A0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B47A4: 3F9F0002  addis r28, r31, 2
	ctx.r[28].s64 = ctx.r[31].s64 + 131072;
	// 821B47A8: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B47AC: 3B9CBE64  addi r28, r28, -0x419c
	ctx.r[28].s64 = ctx.r[28].s64 + -16796;
	// 821B47B0: 395D0710  addi r10, r29, 0x710
	ctx.r[10].s64 = ctx.r[29].s64 + 1808;
	// 821B47B4: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B47B8: 556B203E  rotlwi r11, r11, 4
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 821B47BC: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B47C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B47C4: 419A0090  beq cr6, 0x821b4854
	if ctx.cr[6].eq {
	pc = 0x821B4854; continue 'dispatch;
	}
	// 821B47C8: C05E0008  lfs f2, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B47CC: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B47D0: 4837E6D9  bl 0x82532ea8
	ctx.lr = 0x821B47D4;
	sub_82532EA8(ctx, base);
	// 821B47D4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B47D8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B47DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B47E0: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 821B47E4: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B47E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B47EC: C3EB2254  lfs f31, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B47F0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B47F4: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B47F8: 4BF88AE1  bl 0x8213d2d8
	ctx.lr = 0x821B47FC;
	sub_8213D2D8(ctx, base);
	// 821B47FC: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4800: 395D0788  addi r10, r29, 0x788
	ctx.r[10].s64 = ctx.r[29].s64 + 1928;
	// 821B4804: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B4808: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B480C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B4810: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B4814: C18ABA38  lfs f12, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B4818: 409A004C  bne cr6, 0x821b4864
	if !ctx.cr[6].eq {
	pc = 0x821B4864; continue 'dispatch;
	}
	// 821B481C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4820: C02BBFFC  lfs f1, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4824: 4BF88AB5  bl 0x8213d2d8
	ctx.lr = 0x821B4828;
	sub_8213D2D8(ctx, base);
	pc = 0x821B4828; continue 'dispatch;
            }
            0x821B4828 => {
    //   block [0x821B4828..0x821B482C)
	// 821B4828: FFC06090  fmr f30, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[12].f64;
	pc = 0x821B482C; continue 'dispatch;
            }
            0x821B482C => {
    //   block [0x821B482C..0x821B4854)
	// 821B482C: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4830: EC01607C  fnmsubs f0, f1, f1, f12
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B4834: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821B4838: 4837E671  bl 0x82532ea8
	ctx.lr = 0x821B483C;
	sub_82532EA8(ctx, base);
	// 821B483C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B4840: 3C7F0006  addis r3, r31, 6
	ctx.r[3].s64 = ctx.r[31].s64 + 393216;
	// 821B4844: 3863A510  addi r3, r3, -0x5af0
	ctx.r[3].s64 = ctx.r[3].s64 + -23280;
	// 821B4848: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B484C: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B4850: 481B3641  bl 0x82367e90
	ctx.lr = 0x821B4854;
	sub_82367E90(ctx, base);
	pc = 0x821B4854; continue 'dispatch;
            }
            0x821B4854 => {
    //   block [0x821B4854..0x821B4864)
	// 821B4854: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B4858: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B485C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B4860: 483808A8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821B4864 => {
    //   block [0x821B4864..0x821B4878)
	// 821B4864: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B4868: 409AFFC0  bne cr6, 0x821b4828
	if !ctx.cr[6].eq {
	pc = 0x821B4828; continue 'dispatch;
	}
	// 821B486C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4870: C3CB2074  lfs f30, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B4874: 4BFFFFB8  b 0x821b482c
	pc = 0x821B482C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4878 size=644
    let mut pc: u32 = 0x821B4878;
    'dispatch: loop {
        match pc {
            0x821B4878 => {
    //   block [0x821B4878..0x821B48C4)
	// 821B4878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B487C: 4838083D  bl 0x825350b8
	ctx.lr = 0x821B4880;
	sub_82535080(ctx, base);
	// 821B4880: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821B4884: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821B4888: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821B488C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4890: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4898: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B489C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B48A0: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B48A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B48A8: 409A001C  bne cr6, 0x821b48c4
	if !ctx.cr[6].eq {
	pc = 0x821B48C4; continue 'dispatch;
	}
	// 821B48AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B48B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B48B4: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B48B8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B48BC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B48C0: 48380848  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821B48C4 => {
    //   block [0x821B48C4..0x821B494C)
	// 821B48C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B48C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B48CC: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B48D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B48D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B48D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B48DC: 48003895  bl 0x821b8170
	ctx.lr = 0x821B48E0;
	sub_821B8170(ctx, base);
	// 821B48E0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B48E4: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 821B48E8: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 821B48EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B48F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B48F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B48F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B48FC: 4E800421  bctrl
	ctx.lr = 0x821B4900;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B4900: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4904: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B4908: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B490C: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B4910: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B4914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4918: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B491C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B4920: 419A0060  beq cr6, 0x821b4980
	if ctx.cr[6].eq {
	pc = 0x821B4980; continue 'dispatch;
	}
	// 821B4924: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B4928: 554AC73E  rlwinm r10, r10, 0x18, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B492C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B4930: 419A0050  beq cr6, 0x821b4980
	if ctx.cr[6].eq {
	pc = 0x821B4980; continue 'dispatch;
	}
	// 821B4934: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B4938: 419A0014  beq cr6, 0x821b494c
	if ctx.cr[6].eq {
	pc = 0x821B494C; continue 'dispatch;
	}
	// 821B493C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B4940: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B4944: 2F0B003A  cmpwi cr6, r11, 0x3a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 58, &mut ctx.xer);
	// 821B4948: 419A0038  beq cr6, 0x821b4980
	if ctx.cr[6].eq {
	pc = 0x821B4980; continue 'dispatch;
	}
            }
            0x821B494C => {
    //   block [0x821B494C..0x821B4980)
	// 821B494C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B4950: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 821B4954: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4958: 394BCF90  addi r10, r11, -0x3070
	ctx.r[10].s64 = ctx.r[11].s64 + -12400;
	// 821B495C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821B4960: 7D1F48AE  lbzx r8, r31, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B4964: 392A0730  addi r9, r10, 0x730
	ctx.r[9].s64 = ctx.r[10].s64 + 1840;
	// 821B4968: 550A203E  rotlwi r10, r8, 4
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(4)) as u64;
	// 821B496C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B4970: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B4974: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B4978: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B497C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821B4980; continue 'dispatch;
            }
            0x821B4980 => {
    //   block [0x821B4980..0x821B4A70)
	// 821B4980: 3FBF0002  addis r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 131072;
	// 821B4984: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4988: 3BBDEB32  addi r29, r29, -0x14ce
	ctx.r[29].s64 = ctx.r[29].s64 + -5326;
	// 821B498C: C3CB2190  lfs f30, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B4990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B4994: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4998: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B499C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B49A0: 419A00D0  beq cr6, 0x821b4a70
	if ctx.cr[6].eq {
	pc = 0x821B4A70; continue 'dispatch;
	}
	// 821B49A4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B49A8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B49AC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B49B0: 616B8410  ori r11, r11, 0x8410
	ctx.r[11].u64 = ctx.r[11].u64 | 33808;
	// 821B49B4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B49B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B49BC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B49C0: 7C1F5C2E  lfsx f0, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B49C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B49C8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B49CC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B49D0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B49D4: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B49D8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B49DC: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B49E0: C3EBD4DC  lfs f31, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B49E4: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B49E8: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B49EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B49F0: 4E800421  bctrl
	ctx.lr = 0x821B49F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B49F4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B49F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B49FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B4A00: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821B4A04: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 821B4A08: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
            }
            0x821B4A70 => {
    //   block [0x821B4A70..0x821B4AFC)
	// 821B4A70: EC1D0828  fsubs f0, f29, f1
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[1].f64) as f32) as f64);
	// 821B4A74: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B4A78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4A7C: 614AD338  ori r10, r10, 0xd338
	ctx.r[10].u64 = ctx.r[10].u64 | 54072;
	// 821B4A80: FC000F6E  fsel f0, f0, f29, f1
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[29].f64 } else { ctx.f[1].f64 };
	// 821B4A84: 7C1F552E  stfsx f0, r31, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 821B4A88: 409A0024  bne cr6, 0x821b4aac
	if !ctx.cr[6].eq {
	pc = 0x821B4AAC; continue 'dispatch;
	}
	// 821B4A8C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B4A90: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 821B4A94: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B4A98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B4A9C: 409A0010  bne cr6, 0x821b4aac
	if !ctx.cr[6].eq {
	pc = 0x821B4AAC; continue 'dispatch;
	}
	// 821B4AA0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B4AA4: 614AD33C  ori r10, r10, 0xd33c
	ctx.r[10].u64 = ctx.r[10].u64 | 54076;
	// 821B4AA8: 7C1F552E  stfsx f0, r31, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 821B4AAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B4AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4AB4: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821B4AB8: 409A002C  bne cr6, 0x821b4ae4
	if !ctx.cr[6].eq {
	pc = 0x821B4AE4; continue 'dispatch;
	}
	// 821B4ABC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B4AC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4AC4: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 821B4AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4ACC: 4BF71B4D  bl 0x82126618
	ctx.lr = 0x821B4AD0;
	sub_82126618(ctx, base);
	// 821B4AD0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B4AD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4AD8: 3880003B  li r4, 0x3b
	ctx.r[4].s64 = 59;
	// 821B4ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4AE0: 4BF71B39  bl 0x82126618
	ctx.lr = 0x821B4AE4;
	sub_82126618(ctx, base);
	// 821B4AE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B4AE8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B4AEC: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821B4AF0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B4AF4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B4AF8: 48380610  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4B00 size=204
    let mut pc: u32 = 0x821B4B00;
    'dispatch: loop {
        match pc {
            0x821B4B00 => {
    //   block [0x821B4B00..0x821B4B58)
	// 821B4B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4B04: 483805B9  bl 0x825350bc
	ctx.lr = 0x821B4B08;
	sub_82535080(ctx, base);
	// 821B4B08: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B4B0C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4B10: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4B14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B4B18: 3BEBCF90  addi r31, r11, -0x3070
	ctx.r[31].s64 = ctx.r[11].s64 + -12400;
	// 821B4B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4B20: 4BFFEC79  bl 0x821b3798
	ctx.lr = 0x821B4B24;
	sub_821B3798(ctx, base);
	// 821B4B24: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4B28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B4B2C: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B4B30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4B34: 48004165  bl 0x821b8c98
	ctx.lr = 0x821B4B38;
	sub_821B8C98(ctx, base);
	// 821B4B38: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B4B3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4B40: 409A0018  bne cr6, 0x821b4b58
	if !ctx.cr[6].eq {
	pc = 0x821B4B58; continue 'dispatch;
	}
	// 821B4B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4B48: 48004631  bl 0x821b9178
	ctx.lr = 0x821B4B4C;
	sub_821B9178(ctx, base);
	// 821B4B4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B4B50: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B4B54: 483805B8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821B4B58 => {
    //   block [0x821B4B58..0x821B4BCC)
	// 821B4B58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B4B5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B4B60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B4B64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B4B68: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B4B6C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4B70: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821B4B74: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B4B78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B4B7C: 994B0001  stb r10, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 821B4B80: 994B0002  stb r10, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 821B4B84: 994B0003  stb r10, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 821B4B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B4B8C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B4B90: 480029A1  bl 0x821b7530
	ctx.lr = 0x821B4B94;
	sub_821B7530(ctx, base);
	// 821B4B94: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821B4B98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B4B9C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821B4BA0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821B4BA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B4BA8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B4BAC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B4BB0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B4BB4: D01F0820  stfs f0, 0x820(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2080 as u32), tmp.u32 ) };
	// 821B4BB8: 48002979  bl 0x821b7530
	ctx.lr = 0x821B4BBC;
	sub_821B7530(ctx, base);
	// 821B4BBC: D03F0C34  stfs f1, 0xc34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3124 as u32), tmp.u32 ) };
	// 821B4BC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B4BC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B4BC8: 48380544  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4BD0 size=196
    let mut pc: u32 = 0x821B4BD0;
    'dispatch: loop {
        match pc {
            0x821B4BD0 => {
    //   block [0x821B4BD0..0x821B4C7C)
	// 821B4BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B4BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B4BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B4BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4BE8: 3FDF0002  addis r30, r31, 2
	ctx.r[30].s64 = ctx.r[31].s64 + 131072;
	// 821B4BEC: 3BDEBE64  addi r30, r30, -0x419c
	ctx.r[30].s64 = ctx.r[30].s64 + -16796;
	// 821B4BF0: 889E0000  lbz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4BF4: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 821B4BF8: 40980084  bge cr6, 0x821b4c7c
	if !ctx.cr[6].lt {
	pc = 0x821B4C7C; continue 'dispatch;
	}
	// 821B4BFC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4C00: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B4C04: 4BFFEC75  bl 0x821b3878
	ctx.lr = 0x821B4C08;
	sub_821B3878(ctx, base);
	// 821B4C08: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4C0C: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B4C10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B4C14: 396BCD68  addi r11, r11, -0x3298
	ctx.r[11].s64 = ctx.r[11].s64 + -12952;
	// 821B4C18: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821B4C1C: 396B020C  addi r11, r11, 0x20c
	ctx.r[11].s64 = ctx.r[11].s64 + 524;
	// 821B4C20: 386A1090  addi r3, r10, 0x1090
	ctx.r[3].s64 = ctx.r[10].s64 + 4240;
	// 821B4C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B4C28: 7FC959AE  stbx r30, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 821B4C2C: 4BFE5EAD  bl 0x8219aad8
	ctx.lr = 0x821B4C30;
	sub_8219AAD8(ctx, base);
	// 821B4C30: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B4C34: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B4C38: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B4C3C: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 821B4C40: 614AEB34  ori r10, r10, 0xeb34
	ctx.r[10].u64 = ctx.r[10].u64 | 60212;
	// 821B4C44: 6129EB32  ori r9, r9, 0xeb32
	ctx.r[9].u64 = ctx.r[9].u64 | 60210;
	// 821B4C48: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B4C4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4C50: 38800029  li r4, 0x29
	ctx.r[4].s64 = 41;
	// 821B4C54: 7FDF59AE  stbx r30, r31, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 821B4C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4C5C: 7FDF51AE  stbx r30, r31, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u8) };
	// 821B4C60: 7FDF49AE  stbx r30, r31, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u8) };
	// 821B4C64: 4BF719B5  bl 0x82126618
	ctx.lr = 0x821B4C68;
	sub_82126618(ctx, base);
	// 821B4C68: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821B4C6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B4C70: 3880003B  li r4, 0x3b
	ctx.r[4].s64 = 59;
	// 821B4C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4C78: 4BF719A1  bl 0x82126618
	ctx.lr = 0x821B4C7C;
	sub_82126618(ctx, base);
	pc = 0x821B4C7C; continue 'dispatch;
            }
            0x821B4C7C => {
    //   block [0x821B4C7C..0x821B4C94)
	// 821B4C7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B4C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B4C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B4C88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B4C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B4C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4C98 size=224
    let mut pc: u32 = 0x821B4C98;
    'dispatch: loop {
        match pc {
            0x821B4C98 => {
    //   block [0x821B4C98..0x821B4CE4)
	// 821B4C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4C9C: 48380421  bl 0x825350bc
	ctx.lr = 0x821B4CA0;
	sub_82535080(ctx, base);
	// 821B4CA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4CA4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4CA8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B4CAC: 3BEBCF90  addi r31, r11, -0x3070
	ctx.r[31].s64 = ctx.r[11].s64 + -12400;
	// 821B4CB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B4CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B4CB8: 4BFFECD1  bl 0x821b3988
	ctx.lr = 0x821B4CBC;
	sub_821B3988(ctx, base);
	// 821B4CBC: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821B4CC0: 4BFFFF11  bl 0x821b4bd0
	ctx.lr = 0x821B4CC4;
	sub_821B4BD0(ctx, base);
	// 821B4CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4CC8: 4BFFFF09  bl 0x821b4bd0
	ctx.lr = 0x821B4CCC;
	sub_821B4BD0(ctx, base);
	// 821B4CCC: 895F0C30  lbz r10, 0xc30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4CD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B4CD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B4CD8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821B4CDC: 419A0020  beq cr6, 0x821b4cfc
	if ctx.cr[6].eq {
	pc = 0x821B4CFC; continue 'dispatch;
	}
	// 821B4CE0: 395F0831  addi r10, r31, 0x831
	ctx.r[10].s64 = ctx.r[31].s64 + 2097;
	pc = 0x821B4CE4; continue 'dispatch;
            }
            0x821B4CE4 => {
    //   block [0x821B4CE4..0x821B4CFC)
	// 821B4CE4: 9BCA0000  stb r30, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 821B4CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B4CEC: 893F0C30  lbz r9, 0xc30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4CF0: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B4CF4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B4CF8: 4198FFEC  blt cr6, 0x821b4ce4
	if ctx.cr[6].lt {
	pc = 0x821B4CE4; continue 'dispatch;
	}
	pc = 0x821B4CFC; continue 'dispatch;
            }
            0x821B4CFC => {
    //   block [0x821B4CFC..0x821B4D14)
	// 821B4CFC: 48137865  bl 0x822ec560
	ctx.lr = 0x821B4D00;
	sub_822EC560(ctx, base);
	// 821B4D00: 48138431  bl 0x822ed130
	ctx.lr = 0x821B4D04;
	sub_822ED130(ctx, base);
	// 821B4D04: 481396DD  bl 0x822ee3e0
	ctx.lr = 0x821B4D08;
	sub_822EE3E0(ctx, base);
	// 821B4D08: 48138429  bl 0x822ed130
	ctx.lr = 0x821B4D0C;
	sub_822ED130(ctx, base);
	// 821B4D0C: 4813976D  bl 0x822ee478
	ctx.lr = 0x821B4D10;
	sub_822EE478(ctx, base);
	// 821B4D10: 3BBF0830  addi r29, r31, 0x830
	ctx.r[29].s64 = ctx.r[31].s64 + 2096;
	pc = 0x821B4D14; continue 'dispatch;
            }
            0x821B4D14 => {
    //   block [0x821B4D14..0x821B4D24)
	// 821B4D14: 897F0C30  lbz r11, 0xc30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B4D18: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 821B4D1C: 40990008  ble cr6, 0x821b4d24
	if !ctx.cr[6].gt {
	pc = 0x821B4D24; continue 'dispatch;
	}
	// 821B4D20: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x821B4D24; continue 'dispatch;
            }
            0x821B4D24 => {
    //   block [0x821B4D24..0x821B4D3C)
	// 821B4D24: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B4D28: 4098003C  bge cr6, 0x821b4d64
	if !ctx.cr[6].lt {
	pc = 0x821B4D64; continue 'dispatch;
	}
	// 821B4D2C: 2F1E0010  cmpwi cr6, r30, 0x10
	ctx.cr[6].compare_i32(ctx.r[30].s32, 16, &mut ctx.xer);
	// 821B4D30: 397F0830  addi r11, r31, 0x830
	ctx.r[11].s64 = ctx.r[31].s64 + 2096;
	// 821B4D34: 40980008  bge cr6, 0x821b4d3c
	if !ctx.cr[6].lt {
	pc = 0x821B4D3C; continue 'dispatch;
	}
	// 821B4D38: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821B4D3C; continue 'dispatch;
            }
            0x821B4D3C => {
    //   block [0x821B4D3C..0x821B4D64)
	// 821B4D3C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B4D40: A06B0002  lhz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B4D44: 38EB0030  addi r7, r11, 0x30
	ctx.r[7].s64 = ctx.r[11].s64 + 48;
	// 821B4D48: 38CB0020  addi r6, r11, 0x20
	ctx.r[6].s64 = ctx.r[11].s64 + 32;
	// 821B4D4C: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 821B4D50: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B4D54: 481376D5  bl 0x822ec428
	ctx.lr = 0x821B4D58;
	sub_822EC428(ctx, base);
	// 821B4D58: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821B4D5C: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 821B4D60: 4BFFFFB4  b 0x821b4d14
	pc = 0x821B4D14; continue 'dispatch;
            }
            0x821B4D64 => {
    //   block [0x821B4D64..0x821B4D78)
	// 821B4D64: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B4D68: C02BD5B0  lfs f1, -0x2a50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4D6C: 48137A2D  bl 0x822ec798
	ctx.lr = 0x821B4D70;
	sub_822EC798(ctx, base);
	// 821B4D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B4D74: 48380398  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4D78 size=252
    let mut pc: u32 = 0x821B4D78;
    'dispatch: loop {
        match pc {
            0x821B4D78 => {
    //   block [0x821B4D78..0x821B4DD8)
	// 821B4D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4D7C: 48380321  bl 0x8253509c
	ctx.lr = 0x821B4D80;
	sub_82535080(ctx, base);
	// 821B4D80: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4D84: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4D88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B4D8C: 3BCBCD68  addi r30, r11, -0x3298
	ctx.r[30].s64 = ctx.r[11].s64 + -12952;
	// 821B4D90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B4D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4D98: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821B4D9C: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4DA0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821B4DA4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B4DA8: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821B4DAC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 821B4DB0: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 821B4DB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B4DB8: 48003361  bl 0x821b8118
	ctx.lr = 0x821B4DBC;
	sub_821B8118(ctx, base);
	// 821B4DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B4DC0: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B4DC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4DC8: 48003351  bl 0x821b8118
	ctx.lr = 0x821B4DCC;
	sub_821B8118(ctx, base);
	// 821B4DCC: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 821B4DD0: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 821B4DD4: 41990058  bgt cr6, 0x821b4e2c
	if ctx.cr[6].gt {
	pc = 0x821B4E2C; continue 'dispatch;
	}
	pc = 0x821B4DD8; continue 'dispatch;
            }
            0x821B4DD8 => {
    //   block [0x821B4DD8..0x821B4E24)
	// 821B4DD8: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 821B4DDC: 4199008C  bgt cr6, 0x821b4e68
	if ctx.cr[6].gt {
	pc = 0x821B4E68; continue 'dispatch;
	}
	// 821B4DE0: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821B4DE4: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 821B4DE8: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821B4DEC: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 821B4DF0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821B4DF4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B4DF8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B4DFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B4E00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B4E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4E08: 48003B31  bl 0x821b8938
	ctx.lr = 0x821B4E0C;
	sub_821B8938(ctx, base);
	// 821B4E0C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821B4E10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B4E14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4E18: 419AFFC0  beq cr6, 0x821b4dd8
	if ctx.cr[6].eq {
	pc = 0x821B4DD8; continue 'dispatch;
	}
	// 821B4E1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B4E20: 483802CC  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            0x821B4E24 => {
    //   block [0x821B4E24..0x821B4E2C)
	// 821B4E24: 7F1FA800  cmpw cr6, r31, r21
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[21].s32, &mut ctx.xer);
	// 821B4E28: 41980040  blt cr6, 0x821b4e68
	if ctx.cr[6].lt {
	pc = 0x821B4E68; continue 'dispatch;
	}
	pc = 0x821B4E2C; continue 'dispatch;
            }
            0x821B4E2C => {
    //   block [0x821B4E2C..0x821B4E68)
	// 821B4E2C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821B4E30: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 821B4E34: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821B4E38: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 821B4E3C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821B4E40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B4E44: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B4E48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B4E4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B4E50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B4E54: 48003AE5  bl 0x821b8938
	ctx.lr = 0x821B4E58;
	sub_821B8938(ctx, base);
	// 821B4E58: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821B4E5C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 821B4E60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B4E64: 419AFFC0  beq cr6, 0x821b4e24
	if ctx.cr[6].eq {
	pc = 0x821B4E24; continue 'dispatch;
	}
	pc = 0x821B4E68; continue 'dispatch;
            }
            0x821B4E68 => {
    //   block [0x821B4E68..0x821B4E74)
	// 821B4E68: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821B4E6C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B4E70: 4838027C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B4E78 size=332
    let mut pc: u32 = 0x821B4E78;
    'dispatch: loop {
        match pc {
            0x821B4E78 => {
    //   block [0x821B4E78..0x821B4F54)
	// 821B4E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4E7C: 4838020D  bl 0x82535088
	ctx.lr = 0x821B4E80;
	sub_82535080(ctx, base);
	// 821B4E80: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4E84: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4E88: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B4E8C: 3ACBCF90  addi r22, r11, -0x3070
	ctx.r[22].s64 = ctx.r[11].s64 + -12400;
	// 821B4E90: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B4E94: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821B4E98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B4E9C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821B4EA0: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 821B4EA4: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 821B4EA8: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821B4EAC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821B4EB0: 3B760800  addi r27, r22, 0x800
	ctx.r[27].s64 = ctx.r[22].s64 + 2048;
	// 821B4EB4: 3A8BCD68  addi r20, r11, -0x3298
	ctx.r[20].s64 = ctx.r[11].s64 + -12952;
	// 821B4EB8: 39740209  addi r11, r20, 0x209
	ctx.r[11].s64 = ctx.r[20].s64 + 521;
	// 821B4EBC: 7D7C58AE  lbzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B4EC0: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821B4EC4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821B4EC8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821B4ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B4ED0: 419A0084  beq cr6, 0x821b4f54
	if ctx.cr[6].eq {
	pc = 0x821B4F54; continue 'dispatch;
	}
	// 821B4ED4: EA7E0000  ld r19, 0(r30)
	ctx.r[19].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B4ED8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B4EDC: EA3E0008  ld r17, 8(r30)
	ctx.r[17].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B4EE0: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821B4EE4: EA5D0000  ld r18, 0(r29)
	ctx.r[18].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	pc = 0x821B4F54; continue 'dispatch;
            }
            0x821B4F54 => {
    //   block [0x821B4F54..0x821B4FC4)
	// 821B4F54: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 821B4F58: 39760810  addi r11, r22, 0x810
	ctx.r[11].s64 = ctx.r[22].s64 + 2064;
	// 821B4F5C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821B4F60: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B4F64: 4099FF54  ble cr6, 0x821b4eb8
	if !ctx.cr[6].gt {
	pc = 0x821B4EB8; continue 'dispatch;
	}
	// 821B4F68: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 821B4F6C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821B4F70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B4F74: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 821B4F78: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B4F7C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B4F80: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B4F84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B4F88: 4BFFFDF1  bl 0x821b4d78
	ctx.lr = 0x821B4F8C;
	sub_821B4D78(ctx, base);
	// 821B4F8C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B4F90: 48380148  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
	// 821B4F94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B4F98: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B4F9C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B4FA0: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B4FA4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B4FA8: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B4FAC: F93E0000  std r9, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B4FB0: F97E0008  std r11, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B4FB4: F91D0000  std r8, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B4FB8: F95D0008  std r10, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B4FBC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821B4FC0: 48380118  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B4FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B4FC8 size=140
    let mut pc: u32 = 0x821B4FC8;
    'dispatch: loop {
        match pc {
            0x821B4FC8 => {
    //   block [0x821B4FC8..0x821B504C)
	// 821B4FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B4FCC: 483800E9  bl 0x825350b4
	ctx.lr = 0x821B4FD0;
	sub_82535080(ctx, base);
	// 821B4FD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B4FD4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821B4FD8: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 821B4FDC: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821B4FE0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 821B4FE4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B4FE8: EB8B0000  ld r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B4FEC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B4FF0: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B4FF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B4FF8: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B4FFC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B5000: FB9F0000  std r28, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u64 ) };
	// 821B5004: FB7E0000  std r27, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 821B5008: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B500C: F95E0008  std r10, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B5010: 4BFFFE69  bl 0x821b4e78
	ctx.lr = 0x821B5014;
	sub_821B4E78(ctx, base);
	// 821B5014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B5018: 419A0034  beq cr6, 0x821b504c
	if ctx.cr[6].eq {
	pc = 0x821B504C; continue 'dispatch;
	}
	// 821B501C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5020: 556AA73E  rlwinm r10, r11, 0x14, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821B5024: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5028: 419A0024  beq cr6, 0x821b504c
	if ctx.cr[6].eq {
	pc = 0x821B504C; continue 'dispatch;
	}
	// 821B502C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	pc = 0x821B504C; continue 'dispatch;
            }
            0x821B504C => {
    //   block [0x821B504C..0x821B5054)
	// 821B504C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B5050: 483800B4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5058 size=500
    let mut pc: u32 = 0x821B5058;
    'dispatch: loop {
        match pc {
            0x821B5058 => {
    //   block [0x821B5058..0x821B50A8)
	// 821B5058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B505C: 48380055  bl 0x825350b0
	ctx.lr = 0x821B5060;
	sub_82535080(ctx, base);
	// 821B5060: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5064: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B5068: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B506C: 3F5D0002  addis r26, r29, 2
	ctx.r[26].s64 = ctx.r[29].s64 + 131072;
	// 821B5070: 396BA92C  addi r11, r11, -0x56d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22228;
	// 821B5074: 5506103A  slwi r6, r8, 2
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821B5078: 3B5AEB32  addi r26, r26, -0x14ce
	ctx.r[26].s64 = ctx.r[26].s64 + -5326;
	// 821B507C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B5080: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B5084: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 821B5088: 7F86582E  lwzx r28, r6, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B508C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B5090: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5098: 7F7D50AE  lbzx r27, r29, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B509C: 409A000C  bne cr6, 0x821b50a8
	if !ctx.cr[6].eq {
	pc = 0x821B50A8; continue 'dispatch;
	}
	// 821B50A0: 3960003B  li r11, 0x3b
	ctx.r[11].s64 = 59;
	// 821B50A4: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821B50A8; continue 'dispatch;
            }
            0x821B50A8 => {
    //   block [0x821B50A8..0x821B50C8)
	// 821B50A8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821B50AC: 419800E0  blt cr6, 0x821b518c
	if ctx.cr[6].lt {
	pc = 0x821B518C; continue 'dispatch;
	}
	// 821B50B0: 419A0018  beq cr6, 0x821b50c8
	if ctx.cr[6].eq {
	pc = 0x821B50C8; continue 'dispatch;
	}
	// 821B50B4: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 821B50B8: 419800D4  blt cr6, 0x821b518c
	if ctx.cr[6].lt {
	pc = 0x821B518C; continue 'dispatch;
	}
	// 821B50BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B50C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B50C4: 4838003C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821B50C8 => {
    //   block [0x821B50C8..0x821B518C)
	// 821B50C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B50CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B50D0: 3B8BCF90  addi r28, r11, -0x3070
	ctx.r[28].s64 = ctx.r[11].s64 + -12400;
	// 821B50D4: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B50D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B50DC: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 821B50E0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821B50E4: 557B103A  slwi r27, r11, 2
	ctx.r[27].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 821B50E8: 7C9BE22E  lhzx r4, r27, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821B50EC: 480028DD  bl 0x821b79c8
	ctx.lr = 0x821B50F0;
	sub_821B79C8(ctx, base);
	// 821B50F0: 397C0002  addi r11, r28, 2
	ctx.r[11].s64 = ctx.r[28].s64 + 2;
	// 821B50F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B50F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B50FC: 7C9B5A2E  lhzx r4, r27, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5100: 480028C9  bl 0x821b79c8
	ctx.lr = 0x821B5104;
	sub_821B79C8(ctx, base);
	// 821B5104: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5108: C1BC0818  lfs f13, 0x818(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2072 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B510C: C17C0808  lfs f11, 0x808(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2056 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B5110: C11E0008  lfs f8, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B5114: C15F0008  lfs f10, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B5118: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B511C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B5120: ED2D0332  fmuls f9, f13, f12
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B5124: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5128: ED8B4B3A  fmadds f12, f11, f12, f9
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B512C: ED2D0372  fmuls f9, f13, f13
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B5130: ED686028  fsubs f11, f8, f12
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B5134: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 821B5138: ED6B4AFA  fmadds f11, f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B513C: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B5140: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 821B5144: ED80603A  fmadds f12, f0, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B5148: ED80602C  fsqrts f12, f12
	ctx.f[12].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 821B514C: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 821B5150: 409900D0  ble cr6, 0x821b5220
	if !ctx.cr[6].gt {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B5154: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B5158: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B515C: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B5160: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B5164: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5168: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B516C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5170: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5174: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B5178: D1BE000C  stfs f13, 0xc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B517C: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5180: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B5184: D15E0008  stfs f10, 8(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5188: 48000098  b 0x821b5220
	pc = 0x821B5220; continue 'dispatch;
            }
            0x821B518C => {
    //   block [0x821B518C..0x821B5220)
	// 821B518C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B5190: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B5194: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B5198: 48002831  bl 0x821b79c8
	ctx.lr = 0x821B519C;
	sub_821B79C8(ctx, base);
	// 821B519C: 1D7B0031  mulli r11, r27, 0x31
	ctx.r[11].s32 = ((ctx.r[27].s32 as i64 * 49 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821B51A0: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 821B51A4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821B51A8: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B51AC: 394ACF90  addi r10, r10, -0x3070
	ctx.r[10].s64 = ctx.r[10].s64 + -12400;
	// 821B51B0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B51B4: 392A0020  addi r9, r10, 0x20
	ctx.r[9].s64 = ctx.r[10].s64 + 32;
	// 821B51B8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B51BC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B51C0: F93F0000  std r9, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B51C4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B51C8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B51CC: 409A0054  bne cr6, 0x821b5220
	if !ctx.cr[6].eq {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B51D0: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B51D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B51D8: 409A0048  bne cr6, 0x821b5220
	if !ctx.cr[6].eq {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B51DC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B51E0: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 821B51E4: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B51E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B51EC: 409A0034  bne cr6, 0x821b5220
	if !ctx.cr[6].eq {
	pc = 0x821B5220; continue 'dispatch;
	}
	// 821B51F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B51F4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B51F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B51FC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5200: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B5204: C1AA0808  lfs f13, 0x808(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5208: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B520C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B5210: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B5214: C18A0818  lfs f12, 0x818(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2072 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B5218: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B521C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x821B5220; continue 'dispatch;
            }
            0x821B5220 => {
    //   block [0x821B5220..0x821B524C)
	// 821B5220: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5224: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5228: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B522C: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5230: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B5234: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5238: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B523C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B5240: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B5244: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B5248: 4837FEB8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5250 size=452
    let mut pc: u32 = 0x821B5250;
    'dispatch: loop {
        match pc {
            0x821B5250 => {
    //   block [0x821B5250..0x821B52E8)
	// 821B5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5254: 4837FE69  bl 0x825350bc
	ctx.lr = 0x821B5258;
	sub_82535080(ctx, base);
	// 821B5258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B525C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821B5260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5264: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 821B5268: 2F1E003A  cmpwi cr6, r30, 0x3a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 58, &mut ctx.xer);
	// 821B526C: 419A00EC  beq cr6, 0x821b5358
	if ctx.cr[6].eq {
	pc = 0x821B5358; continue 'dispatch;
	}
	// 821B5270: 2F1E003B  cmpwi cr6, r30, 0x3b
	ctx.cr[6].compare_i32(ctx.r[30].s32, 59, &mut ctx.xer);
	// 821B5274: 419A0074  beq cr6, 0x821b52e8
	if ctx.cr[6].eq {
	pc = 0x821B52E8; continue 'dispatch;
	}
	// 821B5278: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821B527C: 409A0164  bne cr6, 0x821b53e0
	if !ctx.cr[6].eq {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B5280: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 821B5284: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B5288: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B528C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821B5290: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	pc = 0x821B52E8; continue 'dispatch;
            }
            0x821B52E8 => {
    //   block [0x821B52E8..0x821B5358)
	// 821B52E8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B52EC: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 821B52F0: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B52F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B52F8: 409A00E8  bne cr6, 0x821b53e0
	if !ctx.cr[6].eq {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B52FC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5300: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5304: 616BD33C  ori r11, r11, 0xd33c
	ctx.r[11].u64 = ctx.r[11].u64 | 54076;
	// 821B5308: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B530C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B5310: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B5314: C1ABD6D0  lfs f13, -0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5318: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B531C: 419900C4  bgt cr6, 0x821b53e0
	if ctx.cr[6].gt {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B5320: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B5324: C1ABD4DC  lfs f13, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5328: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B532C: 40990018  ble cr6, 0x821b5344
	if !ctx.cr[6].gt {
	pc = 0x821B5344; continue 'dispatch;
	}
	// 821B5330: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5334: 616BEB12  ori r11, r11, 0xeb12
	ctx.r[11].u64 = ctx.r[11].u64 | 60178;
	// 821B5338: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B533C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5340: 409A00A0  bne cr6, 0x821b53e0
	if !ctx.cr[6].eq {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B5344: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5348: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B534C: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5354: 4BFFFF84  b 0x821b52d8
	pc = 0x821B52D8; continue 'dispatch;
            }
            0x821B5358 => {
    //   block [0x821B5358..0x821B53E0)
	// 821B5358: 3CDF0002  addis r6, r31, 2
	ctx.r[6].s64 = ctx.r[31].s64 + 131072;
	// 821B535C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5360: 38C6EB55  addi r6, r6, -0x14ab
	ctx.r[6].s64 = ctx.r[6].s64 + -5291;
	// 821B5364: 616BEB31  ori r11, r11, 0xeb31
	ctx.r[11].u64 = ctx.r[11].u64 | 60209;
	// 821B5368: 89460000  lbz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B536C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5370: 409A0010  bne cr6, 0x821b5380
	if !ctx.cr[6].eq {
	pc = 0x821B5380; continue 'dispatch;
	}
	// 821B5374: 7D3F58AE  lbzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5378: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B537C: 409AFF60  bne cr6, 0x821b52dc
	if !ctx.cr[6].eq {
	pc = 0x821B52DC; continue 'dispatch;
	}
	// 821B5380: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B5384: 6129EB32  ori r9, r9, 0xeb32
	ctx.r[9].u64 = ctx.r[9].u64 | 60210;
	// 821B5388: 7D3F48AE  lbzx r9, r31, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B538C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B5390: 409AFF4C  bne cr6, 0x821b52dc
	if !ctx.cr[6].eq {
	pc = 0x821B52DC; continue 'dispatch;
	}
	// 821B5394: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B5398: 6129EB33  ori r9, r9, 0xeb33
	ctx.r[9].u64 = ctx.r[9].u64 | 60211;
	// 821B539C: 7D3F48AE  lbzx r9, r31, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B53A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B53A4: 409AFF38  bne cr6, 0x821b52dc
	if !ctx.cr[6].eq {
	pc = 0x821B52DC; continue 'dispatch;
	}
	// 821B53A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B53AC: 419A0034  beq cr6, 0x821b53e0
	if ctx.cr[6].eq {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B53B0: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B53B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B53B8: 419A0028  beq cr6, 0x821b53e0
	if ctx.cr[6].eq {
	pc = 0x821B53E0; continue 'dispatch;
	}
	// 821B53BC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821B53C0: 409A0018  bne cr6, 0x821b53d8
	if !ctx.cr[6].eq {
	pc = 0x821B53D8; continue 'dispatch;
	}
	// 821B53C4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821B53C8: 38A0000F  li r5, 0xf
	ctx.r[5].s64 = 15;
	// 821B53CC: 386BB460  addi r3, r11, -0x4ba0
	ctx.r[3].s64 = ctx.r[11].s64 + -19360;
	// 821B53D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B53D4: 4818B275  bl 0x82340648
	ctx.lr = 0x821B53D8;
	sub_82340648(ctx, base);
	// 821B53D8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821B53DC: 99660000  stb r11, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x821B53E0; continue 'dispatch;
            }
            0x821B53E0 => {
    //   block [0x821B53E0..0x821B5414)
	// 821B53E0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B53E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B53E8: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B53EC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B53F0: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B53F4: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B53F8: 392B0798  addi r9, r11, 0x798
	ctx.r[9].s64 = ctx.r[11].s64 + 1944;
	// 821B53FC: 390B07C0  addi r8, r11, 0x7c0
	ctx.r[8].s64 = ctx.r[11].s64 + 1984;
	// 821B5400: 554B103E  rotlwi r11, r10, 2
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B5404: 7FAB492E  stwx r29, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[29].u32) };
	// 821B5408: 7FCB412E  stwx r30, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	// 821B540C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B5410: 4837FCFC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5418 size=104
    let mut pc: u32 = 0x821B5418;
    'dispatch: loop {
        match pc {
            0x821B5418 => {
    //   block [0x821B5418..0x821B5444)
	// 821B5418: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B541C: 390BCD68  addi r8, r11, -0x3298
	ctx.r[8].s64 = ctx.r[11].s64 + -12952;
	// 821B5420: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5428: 419A004C  beq cr6, 0x821b5474
	if ctx.cr[6].eq {
	pc = 0x821B5474; continue 'dispatch;
	}
	// 821B542C: A16B002C  lhz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B5430: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B5434: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821B5438: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B543C: 40990038  ble cr6, 0x821b5474
	if !ctx.cr[6].gt {
	pc = 0x821B5474; continue 'dispatch;
	}
	// 821B5440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B5444; continue 'dispatch;
            }
            0x821B5444 => {
    //   block [0x821B5444..0x821B5474)
	// 821B5444: 81280204  lwz r9, 0x204(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(516 as u32) ) } as u64;
	// 821B5448: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B544C: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821B5450: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 821B5454: 80E9001C  lwz r7, 0x1c(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5458: 54E70626  rlwinm r7, r7, 0, 0x18, 0x13
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821B545C: 90E9001C  stw r7, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 821B5460: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5464: A129002C  lhz r9, 0x2c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B5468: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 821B546C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B5470: 4198FFD4  blt cr6, 0x821b5444
	if ctx.cr[6].lt {
	pc = 0x821B5444; continue 'dispatch;
	}
	pc = 0x821B5474; continue 'dispatch;
            }
            0x821B5474 => {
    //   block [0x821B5474..0x821B5480)
	// 821B5474: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5478: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B547C: 4BFFEB94  b 0x821b4010
	sub_821B4010(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5480 size=212
    let mut pc: u32 = 0x821B5480;
    'dispatch: loop {
        match pc {
            0x821B5480 => {
    //   block [0x821B5480..0x821B54D0)
	// 821B5480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B548C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B5490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5494: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B5498: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B549C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B54A0: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821B54A4: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B54A8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B54AC: 419A0080  beq cr6, 0x821b552c
	if ctx.cr[6].eq {
	pc = 0x821B552C; continue 'dispatch;
	}
	// 821B54B0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B54B4: 3BCBCF90  addi r30, r11, -0x3070
	ctx.r[30].s64 = ctx.r[11].s64 + -12400;
	// 821B54B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B54BC: 893E0C30  lbz r9, 0xc30(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3120 as u32) ) } as u64;
	// 821B54C0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821B54C4: 40990028  ble cr6, 0x821b54ec
	if !ctx.cr[6].gt {
	pc = 0x821B54EC; continue 'dispatch;
	}
	// 821B54C8: 5468043E  clrlwi r8, r3, 0x10
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 821B54CC: 395E0832  addi r10, r30, 0x832
	ctx.r[10].s64 = ctx.r[30].s64 + 2098;
	pc = 0x821B54D0; continue 'dispatch;
            }
            0x821B54D0 => {
    //   block [0x821B54D0..0x821B54EC)
	// 821B54D0: A0EA0000  lhz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B54D4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B54D8: 419A006C  beq cr6, 0x821b5544
	if ctx.cr[6].eq {
	pc = 0x821B5544; continue 'dispatch;
	}
	// 821B54DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B54E0: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 821B54E4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B54E8: 4198FFE8  blt cr6, 0x821b54d0
	if ctx.cr[6].lt {
	pc = 0x821B54D0; continue 'dispatch;
	}
	pc = 0x821B54EC; continue 'dispatch;
            }
            0x821B54EC => {
    //   block [0x821B54EC..0x821B54F0)
	// 821B54EC: 3BFE0830  addi r31, r30, 0x830
	ctx.r[31].s64 = ctx.r[30].s64 + 2096;
	pc = 0x821B54F0; continue 'dispatch;
            }
            0x821B54F0 => {
    //   block [0x821B54F0..0x821B552C)
	// 821B54F0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B54F4: A09F0002  lhz r4, 2(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B54F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B54FC: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B5500: 48003CD1  bl 0x821b91d0
	ctx.lr = 0x821B5504;
	sub_821B91D0(ctx, base);
	// 821B5504: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B5508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B550C: 419A0020  beq cr6, 0x821b552c
	if ctx.cr[6].eq {
	pc = 0x821B552C; continue 'dispatch;
	}
	// 821B5510: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B5514: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5518: 393E07C8  addi r9, r30, 0x7c8
	ctx.r[9].s64 = ctx.r[30].s64 + 1992;
	// 821B551C: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 821B5520: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B5524: 816B0688  lwz r11, 0x688(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B5528: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	pc = 0x821B552C; continue 'dispatch;
            }
            0x821B552C => {
    //   block [0x821B552C..0x821B5544)
	// 821B552C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B5534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B553C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B5540: 4E800020  blr
	return;
            }
            0x821B5544 => {
    //   block [0x821B5544..0x821B5554)
	// 821B5544: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B5548: 395E0830  addi r10, r30, 0x830
	ctx.r[10].s64 = ctx.r[30].s64 + 2096;
	// 821B554C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B5550: 4BFFFFA0  b 0x821b54f0
	pc = 0x821B54F0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B5558 size=1440
    let mut pc: u32 = 0x821B5558;
    'dispatch: loop {
        match pc {
            0x821B5558 => {
    //   block [0x821B5558..0x821B55B0)
	// 821B5558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B555C: 4837FB51  bl 0x825350ac
	ctx.lr = 0x821B5560;
	sub_82535080(ctx, base);
	// 821B5560: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5564: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B5568: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B556C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821B5570: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5574: 556AE73E  rlwinm r10, r11, 0x1c, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5578: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 821B557C: 419903E4  bgt cr6, 0x821b5960
	if ctx.cr[6].gt {
	pc = 0x821B5960; continue 'dispatch;
	}
	// 821B5580: 3D80821B  lis r12, -0x7de5
	ctx.r[12].s64 = -2112159744;
	// 821B5584: 398C5598  addi r12, r12, 0x5598
	ctx.r[12].s64 = ctx.r[12].s64 + 21912;
	// 821B5588: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821B558C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821B5590: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821B5594: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x821B55B0; continue 'dispatch;
		},
		1 => {
	pc = 0x821B5644; continue 'dispatch;
		},
		2 => {
	pc = 0x821B57B8; continue 'dispatch;
		},
		3 => {
	pc = 0x821B5AF0; continue 'dispatch;
		},
		4 => {
	pc = 0x821B5960; continue 'dispatch;
		},
		5 => {
	pc = 0x821B5644; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821B5598: 821B55B0  lwz r16, 0x55b0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(21936 as u32) ) } as u64;
	// 821B559C: 821B5644  lwz r16, 0x5644(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22084 as u32) ) } as u64;
	// 821B55A0: 821B57B8  lwz r16, 0x57b8(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22456 as u32) ) } as u64;
	// 821B55A4: 821B5AF0  lwz r16, 0x5af0(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(23280 as u32) ) } as u64;
	// 821B55A8: 821B5960  lwz r16, 0x5960(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22880 as u32) ) } as u64;
	// 821B55AC: 821B5644  lwz r16, 0x5644(r27)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(22084 as u32) ) } as u64;
            }
            0x821B55B0 => {
    //   block [0x821B55B0..0x821B5644)
	// 821B55B0: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B55B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B55B8: 419A0538  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55BC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B55C0: 419A0530  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55C4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B55C8: 557FE63E  rlwinm r31, r11, 0x1c, 0x18, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B55CC: 2F1F003C  cmpwi cr6, r31, 0x3c
	ctx.cr[6].compare_i32(ctx.r[31].s32, 60, &mut ctx.xer);
	// 821B55D0: 419A0520  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55D4: 2F1F003A  cmpwi cr6, r31, 0x3a
	ctx.cr[6].compare_i32(ctx.r[31].s32, 58, &mut ctx.xer);
	// 821B55D8: 419A0518  beq cr6, 0x821b5af0
	if ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B55DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B55E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B55E4: 481AC83D  bl 0x82361e20
	ctx.lr = 0x821B55E8;
	sub_82361E20(ctx, base);
	// 821B55E8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B55EC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B55F0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B55F4: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821B55F8: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B55FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B5600: 409A04F0  bne cr6, 0x821b5af0
	if !ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B5604: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 821B5608: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B560C: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 821B5610: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 821B5614: 386B45D8  addi r3, r11, 0x45d8
	ctx.r[3].s64 = ctx.r[11].s64 + 17880;
	// 821B5618: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B561C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B5620: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 821B5624: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B5628: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B562C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 821B5630: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 821B5634: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B5638: 4BFC73E1  bl 0x8217ca18
	ctx.lr = 0x821B563C;
	sub_8217CA18(ctx, base);
	// 821B563C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B5640: 4837FABC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B5644 => {
    //   block [0x821B5644..0x821B56A4)
	// 821B5644: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B5648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B564C: 409A04A4  bne cr6, 0x821b5af0
	if !ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B5650: 3FB90002  addis r29, r25, 2
	ctx.r[29].s64 = ctx.r[25].s64 + 131072;
	// 821B5654: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5658: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 821B565C: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5660: 3BBD9C30  addi r29, r29, -0x63d0
	ctx.r[29].s64 = ctx.r[29].s64 + -25552;
	// 821B5664: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5668: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B566C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B5670: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B5674: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B5678: 48136DB1  bl 0x822ec428
	ctx.lr = 0x821B567C;
	sub_822EC428(ctx, base);
	// 821B567C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5680: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5684: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5688: 419A006C  beq cr6, 0x821b56f4
	if ctx.cr[6].eq {
	pc = 0x821B56F4; continue 'dispatch;
	}
	// 821B568C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5690: 419A0014  beq cr6, 0x821b56a4
	if ctx.cr[6].eq {
	pc = 0x821B56A4; continue 'dispatch;
	}
	// 821B5694: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5698: 557BE63E  rlwinm r27, r11, 0x1c, 0x18, 0x1f
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B569C: 2F1B003C  cmpwi cr6, r27, 0x3c
	ctx.cr[6].compare_i32(ctx.r[27].s32, 60, &mut ctx.xer);
	// 821B56A0: 409A0008  bne cr6, 0x821b56a8
	if !ctx.cr[6].eq {
	pc = 0x821B56A8; continue 'dispatch;
	}
	pc = 0x821B56A4; continue 'dispatch;
            }
            0x821B56A4 => {
    //   block [0x821B56A4..0x821B56A8)
	// 821B56A4: 3B600013  li r27, 0x13
	ctx.r[27].s64 = 19;
	pc = 0x821B56A8; continue 'dispatch;
            }
            0x821B56A8 => {
    //   block [0x821B56A8..0x821B56F4)
	// 821B56A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B56AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B56B0: 481AC771  bl 0x82361e20
	ctx.lr = 0x821B56B4;
	sub_82361E20(ctx, base);
	// 821B56B4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B56B8: 3B4BBFF0  addi r26, r11, -0x4010
	ctx.r[26].s64 = ctx.r[11].s64 + -16400;
	// 821B56BC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B56C0: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 821B56C4: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B56C8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B56CC: 409A005C  bne cr6, 0x821b5728
	if !ctx.cr[6].eq {
	pc = 0x821B5728; continue 'dispatch;
	}
	// 821B56D0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B56D4: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B56D8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B56DC: 419A0028  beq cr6, 0x821b5704
	if ctx.cr[6].eq {
	pc = 0x821B5704; continue 'dispatch;
	}
	// 821B56E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B56E4: 419A0018  beq cr6, 0x821b56fc
	if ctx.cr[6].eq {
	pc = 0x821B56FC; continue 'dispatch;
	}
	// 821B56E8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B56EC: 5566E63E  rlwinm r6, r11, 0x1c, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B56F0: 48000018  b 0x821b5708
	pc = 0x821B5708; continue 'dispatch;
            }
            0x821B56F4 => {
    //   block [0x821B56F4..0x821B56FC)
	// 821B56F4: 3B60003A  li r27, 0x3a
	ctx.r[27].s64 = 58;
	// 821B56F8: 4BFFFFB0  b 0x821b56a8
	pc = 0x821B56A8; continue 'dispatch;
            }
            0x821B56FC => {
    //   block [0x821B56FC..0x821B5704)
	// 821B56FC: 38C0003C  li r6, 0x3c
	ctx.r[6].s64 = 60;
	// 821B5700: 48000008  b 0x821b5708
	pc = 0x821B5708; continue 'dispatch;
            }
            0x821B5704 => {
    //   block [0x821B5704..0x821B5708)
	// 821B5704: 38C0003A  li r6, 0x3a
	ctx.r[6].s64 = 58;
	pc = 0x821B5708; continue 'dispatch;
            }
            0x821B5708 => {
    //   block [0x821B5708..0x821B5728)
	// 821B5708: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821B570C: A0BF002E  lhz r5, 0x2e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5710: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821B5714: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821B5718: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B571C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B5720: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5724: 48001AE5  bl 0x821b7208
	ctx.lr = 0x821B5728;
	sub_821B7208(ctx, base);
	pc = 0x821B5728; continue 'dispatch;
            }
            0x821B5728 => {
    //   block [0x821B5728..0x821B57B8)
	// 821B5728: A17F002E  lhz r11, 0x2e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B572C: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 821B5730: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B5734: E8BC0008  ld r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 821B5738: 60E79460  ori r7, r7, 0x9460
	ctx.r[7].u64 = ctx.r[7].u64 | 37984;
	// 821B573C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821B5740: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821B5744: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 821B5748: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B574C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B5750: 6166BE64  ori r6, r11, 0xbe64
	ctx.r[6].u64 = ctx.r[11].u64 | 48740;
	// 821B5754: 7CFA382E  lwzx r7, r26, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B5758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B575C: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B5760: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 821B5764: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B5768: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B576C: E8FE0008  ld r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B5770: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B5774: 7D7930AE  lbzx r11, r25, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B5778: E8DC0000  ld r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821B577C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821B5780: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B5784: EBDD0000  ld r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B5788: EBBD0008  ld r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821B578C: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B5790: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B5794: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B5798: F8A90008  std r5, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B579C: FBC80000  std r30, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B57A0: FBA80008  std r29, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 821B57A4: 4BFFE7ED  bl 0x821b3f90
	ctx.lr = 0x821B57A8;
	sub_821B3F90(ctx, base);
	// 821B57A8: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B57AC: 4BFFFCD5  bl 0x821b5480
	ctx.lr = 0x821B57B0;
	sub_821B5480(ctx, base);
	// 821B57B0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B57B4: 4837F948  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B57B8 => {
    //   block [0x821B57B8..0x821B57D8)
	// 821B57B8: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B57BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B57C0: 419A0020  beq cr6, 0x821b57e0
	if ctx.cr[6].eq {
	pc = 0x821B57E0; continue 'dispatch;
	}
	// 821B57C4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B57C8: 419A0010  beq cr6, 0x821b57d8
	if ctx.cr[6].eq {
	pc = 0x821B57D8; continue 'dispatch;
	}
	// 821B57CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B57D0: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B57D4: 48000010  b 0x821b57e4
	pc = 0x821B57E4; continue 'dispatch;
            }
            0x821B57D8 => {
    //   block [0x821B57D8..0x821B57E0)
	// 821B57D8: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B57DC: 48000008  b 0x821b57e4
	pc = 0x821B57E4; continue 'dispatch;
            }
            0x821B57E0 => {
    //   block [0x821B57E0..0x821B57E4)
	// 821B57E0: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	pc = 0x821B57E4; continue 'dispatch;
            }
            0x821B57E4 => {
    //   block [0x821B57E4..0x821B5828)
	// 821B57E4: 3F990002  addis r28, r25, 2
	ctx.r[28].s64 = ctx.r[25].s64 + 131072;
	// 821B57E8: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B57EC: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 821B57F0: 3B9C9C30  addi r28, r28, -0x63d0
	ctx.r[28].s64 = ctx.r[28].s64 + -25552;
	// 821B57F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B57F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B57FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821B5800: 48136CB9  bl 0x822ec4b8
	ctx.lr = 0x821B5804;
	sub_822EC4B8(ctx, base);
	// 821B5804: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5808: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B580C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5810: 419A0020  beq cr6, 0x821b5830
	if ctx.cr[6].eq {
	pc = 0x821B5830; continue 'dispatch;
	}
	// 821B5814: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5818: 419A0010  beq cr6, 0x821b5828
	if ctx.cr[6].eq {
	pc = 0x821B5828; continue 'dispatch;
	}
	// 821B581C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5820: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5824: 48000010  b 0x821b5834
	pc = 0x821B5834; continue 'dispatch;
            }
            0x821B5828 => {
    //   block [0x821B5828..0x821B5830)
	// 821B5828: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B582C: 48000008  b 0x821b5834
	pc = 0x821B5834; continue 'dispatch;
            }
            0x821B5830 => {
    //   block [0x821B5830..0x821B5834)
	// 821B5830: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	pc = 0x821B5834; continue 'dispatch;
            }
            0x821B5834 => {
    //   block [0x821B5834..0x821B587C)
	// 821B5834: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B5838: 481AC5E9  bl 0x82361e20
	ctx.lr = 0x821B583C;
	sub_82361E20(ctx, base);
	// 821B583C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B5840: 3B6BBFF0  addi r27, r11, -0x4010
	ctx.r[27].s64 = ctx.r[11].s64 + -16400;
	// 821B5844: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B5848: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 821B584C: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5850: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B5854: 409A0078  bne cr6, 0x821b58cc
	if !ctx.cr[6].eq {
	pc = 0x821B58CC; continue 'dispatch;
	}
	// 821B5858: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B585C: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5860: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5864: 419A0020  beq cr6, 0x821b5884
	if ctx.cr[6].eq {
	pc = 0x821B5884; continue 'dispatch;
	}
	// 821B5868: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B586C: 419A0010  beq cr6, 0x821b587c
	if ctx.cr[6].eq {
	pc = 0x821B587C; continue 'dispatch;
	}
	// 821B5870: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5874: 554AE63E  rlwinm r10, r10, 0x1c, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821B5878: 48000010  b 0x821b5888
	pc = 0x821B5888; continue 'dispatch;
            }
            0x821B587C => {
    //   block [0x821B587C..0x821B5884)
	// 821B587C: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 821B5880: 48000008  b 0x821b5888
	pc = 0x821B5888; continue 'dispatch;
            }
            0x821B5884 => {
    //   block [0x821B5884..0x821B5888)
	// 821B5884: 3940003A  li r10, 0x3a
	ctx.r[10].s64 = 58;
	pc = 0x821B5888; continue 'dispatch;
            }
            0x821B5888 => {
    //   block [0x821B5888..0x821B58A4)
	// 821B5888: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B588C: 419A0020  beq cr6, 0x821b58ac
	if ctx.cr[6].eq {
	pc = 0x821B58AC; continue 'dispatch;
	}
	// 821B5890: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5894: 419A0010  beq cr6, 0x821b58a4
	if ctx.cr[6].eq {
	pc = 0x821B58A4; continue 'dispatch;
	}
	// 821B5898: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B589C: 5566E63E  rlwinm r6, r11, 0x1c, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B58A0: 48000010  b 0x821b58b0
	pc = 0x821B58B0; continue 'dispatch;
            }
            0x821B58A4 => {
    //   block [0x821B58A4..0x821B58AC)
	// 821B58A4: 38C0003C  li r6, 0x3c
	ctx.r[6].s64 = 60;
	// 821B58A8: 48000008  b 0x821b58b0
	pc = 0x821B58B0; continue 'dispatch;
            }
            0x821B58AC => {
    //   block [0x821B58AC..0x821B58B0)
	// 821B58AC: 38C0003A  li r6, 0x3a
	ctx.r[6].s64 = 58;
	pc = 0x821B58B0; continue 'dispatch;
            }
            0x821B58B0 => {
    //   block [0x821B58B0..0x821B58CC)
	// 821B58B0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821B58B4: A0BF002E  lhz r5, 0x2e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B58B8: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 821B58BC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B58C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B58C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B58C8: 48001941  bl 0x821b7208
	ctx.lr = 0x821B58CC;
	sub_821B7208(ctx, base);
	pc = 0x821B58CC; continue 'dispatch;
            }
            0x821B58CC => {
    //   block [0x821B58CC..0x821B5960)
	// 821B58CC: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 821B58D0: A17F002E  lhz r11, 0x2e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B58D4: E8DD0000  ld r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B58D8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821B58DC: 6107BE64  ori r7, r8, 0xbe64
	ctx.r[7].u64 = ctx.r[8].u64 | 48740;
	// 821B58E0: E8BD0008  ld r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821B58E4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821B58E8: EBBC0008  ld r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 821B58EC: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821B58F0: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 821B58F4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B58F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B58FC: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	// 821B5900: 3D000003  lis r8, 3
	ctx.r[8].s64 = 196608;
	// 821B5904: 61089460  ori r8, r8, 0x9460
	ctx.r[8].u64 = ctx.r[8].u64 | 37984;
	// 821B5908: 7D1B402E  lwzx r8, r27, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B590C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821B5910: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B5914: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 821B5918: 3D0082CF  lis r8, -0x7d31
	ctx.r[8].s64 = -2100363264;
	// 821B591C: 3868CF90  addi r3, r8, -0x3070
	ctx.r[3].s64 = ctx.r[8].s64 + -12400;
	// 821B5920: 7D1938AE  lbzx r8, r25, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B5924: E8FE0008  ld r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B5928: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821B592C: E91E0000  ld r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B5930: EBDC0000  ld r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821B5934: F90B0000  std r8, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821B5938: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B593C: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B5940: F8AA0008  std r5, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B5944: FBC90000  std r30, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B5948: FBA90008  std r29, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 821B594C: 4BFFE645  bl 0x821b3f90
	ctx.lr = 0x821B5950;
	sub_821B3F90(ctx, base);
	// 821B5950: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5954: 4BFFFB2D  bl 0x821b5480
	ctx.lr = 0x821B5958;
	sub_821B5480(ctx, base);
	// 821B5958: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B595C: 4837F7A0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B5960 => {
    //   block [0x821B5960..0x821B59B8)
	// 821B5960: 556B052E  rlwinm r11, r11, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B5964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5968: 409A0188  bne cr6, 0x821b5af0
	if !ctx.cr[6].eq {
	pc = 0x821B5AF0; continue 'dispatch;
	}
	// 821B596C: 3FB90002  addis r29, r25, 2
	ctx.r[29].s64 = ctx.r[25].s64 + 131072;
	// 821B5970: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5974: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 821B5978: A07F002E  lhz r3, 0x2e(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B597C: 3BBD9C30  addi r29, r29, -0x63d0
	ctx.r[29].s64 = ctx.r[29].s64 + -25552;
	// 821B5980: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5984: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821B5988: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B598C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B5990: 48136B29  bl 0x822ec4b8
	ctx.lr = 0x821B5994;
	sub_822EC4B8(ctx, base);
	// 821B5994: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5998: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B599C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B59A0: 419A0020  beq cr6, 0x821b59c0
	if ctx.cr[6].eq {
	pc = 0x821B59C0; continue 'dispatch;
	}
	// 821B59A4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B59A8: 419A0010  beq cr6, 0x821b59b8
	if ctx.cr[6].eq {
	pc = 0x821B59B8; continue 'dispatch;
	}
	// 821B59AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B59B0: 5564E63E  rlwinm r4, r11, 0x1c, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B59B4: 48000010  b 0x821b59c4
	pc = 0x821B59C4; continue 'dispatch;
            }
            0x821B59B8 => {
    //   block [0x821B59B8..0x821B59C0)
	// 821B59B8: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 821B59BC: 48000008  b 0x821b59c4
	pc = 0x821B59C4; continue 'dispatch;
            }
            0x821B59C0 => {
    //   block [0x821B59C0..0x821B59C4)
	// 821B59C0: 3880003A  li r4, 0x3a
	ctx.r[4].s64 = 58;
	pc = 0x821B59C4; continue 'dispatch;
            }
            0x821B59C4 => {
    //   block [0x821B59C4..0x821B5A0C)
	// 821B59C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B59C8: 481AC459  bl 0x82361e20
	ctx.lr = 0x821B59CC;
	sub_82361E20(ctx, base);
	// 821B59CC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B59D0: 3B6BBFF0  addi r27, r11, -0x4010
	ctx.r[27].s64 = ctx.r[11].s64 + -16400;
	// 821B59D4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821B59D8: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 821B59DC: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B59E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B59E4: 409A0078  bne cr6, 0x821b5a5c
	if !ctx.cr[6].eq {
	pc = 0x821B5A5C; continue 'dispatch;
	}
	// 821B59E8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B59EC: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B59F0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B59F4: 419A0020  beq cr6, 0x821b5a14
	if ctx.cr[6].eq {
	pc = 0x821B5A14; continue 'dispatch;
	}
	// 821B59F8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B59FC: 419A0010  beq cr6, 0x821b5a0c
	if ctx.cr[6].eq {
	pc = 0x821B5A0C; continue 'dispatch;
	}
	// 821B5A00: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5A04: 554AE63E  rlwinm r10, r10, 0x1c, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821B5A08: 48000010  b 0x821b5a18
	pc = 0x821B5A18; continue 'dispatch;
            }
            0x821B5A0C => {
    //   block [0x821B5A0C..0x821B5A14)
	// 821B5A0C: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 821B5A10: 48000008  b 0x821b5a18
	pc = 0x821B5A18; continue 'dispatch;
            }
            0x821B5A14 => {
    //   block [0x821B5A14..0x821B5A18)
	// 821B5A14: 3940003A  li r10, 0x3a
	ctx.r[10].s64 = 58;
	pc = 0x821B5A18; continue 'dispatch;
            }
            0x821B5A18 => {
    //   block [0x821B5A18..0x821B5A34)
	// 821B5A18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5A1C: 419A0020  beq cr6, 0x821b5a3c
	if ctx.cr[6].eq {
	pc = 0x821B5A3C; continue 'dispatch;
	}
	// 821B5A20: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5A24: 419A0010  beq cr6, 0x821b5a34
	if ctx.cr[6].eq {
	pc = 0x821B5A34; continue 'dispatch;
	}
	// 821B5A28: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5A2C: 5566E63E  rlwinm r6, r11, 0x1c, 0x18, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5A30: 48000010  b 0x821b5a40
	pc = 0x821B5A40; continue 'dispatch;
            }
            0x821B5A34 => {
    //   block [0x821B5A34..0x821B5A3C)
	// 821B5A34: 38C0003C  li r6, 0x3c
	ctx.r[6].s64 = 60;
	// 821B5A38: 48000008  b 0x821b5a40
	pc = 0x821B5A40; continue 'dispatch;
            }
            0x821B5A3C => {
    //   block [0x821B5A3C..0x821B5A40)
	// 821B5A3C: 38C0003A  li r6, 0x3a
	ctx.r[6].s64 = 58;
	pc = 0x821B5A40; continue 'dispatch;
            }
            0x821B5A40 => {
    //   block [0x821B5A40..0x821B5A5C)
	// 821B5A40: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 821B5A44: A0BF002E  lhz r5, 0x2e(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5A48: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821B5A4C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821B5A50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B5A54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5A58: 480017B1  bl 0x821b7208
	ctx.lr = 0x821B5A5C;
	sub_821B7208(ctx, base);
	pc = 0x821B5A5C; continue 'dispatch;
            }
            0x821B5A5C => {
    //   block [0x821B5A5C..0x821B5AF0)
	// 821B5A5C: A17F002E  lhz r11, 0x2e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5A60: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 821B5A64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821B5A68: E8BC0008  ld r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 821B5A6C: 60E79460  ori r7, r7, 0x9460
	ctx.r[7].u64 = ctx.r[7].u64 | 37984;
	// 821B5A70: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821B5A74: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821B5A78: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 821B5A7C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5A80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B5A84: 6166BE64  ori r6, r11, 0xbe64
	ctx.r[6].u64 = ctx.r[11].u64 | 48740;
	// 821B5A88: 7CFB382E  lwzx r7, r27, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B5A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5A90: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B5A94: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 821B5A98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821B5A9C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5AA0: E8FE0008  ld r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 821B5AA4: 386BCF90  addi r3, r11, -0x3070
	ctx.r[3].s64 = ctx.r[11].s64 + -12400;
	// 821B5AA8: 7D7930AE  lbzx r11, r25, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821B5AAC: E8DC0000  ld r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 821B5AB0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821B5AB4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 821B5AB8: EBDD0000  ld r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B5ABC: EBBD0008  ld r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821B5AC0: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B5AC4: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B5AC8: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821B5ACC: F8A90008  std r5, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821B5AD0: FBC80000  std r30, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B5AD4: FBA80008  std r29, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 821B5AD8: 4BFFE4B9  bl 0x821b3f90
	ctx.lr = 0x821B5ADC;
	sub_821B3F90(ctx, base);
	// 821B5ADC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5AE0: A09F002E  lhz r4, 0x2e(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(46 as u32) ) } as u64;
	// 821B5AE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B5AE8: 386BCD68  addi r3, r11, -0x3298
	ctx.r[3].s64 = ctx.r[11].s64 + -12952;
	// 821B5AEC: 480036E5  bl 0x821b91d0
	ctx.lr = 0x821B5AF0;
	sub_821B91D0(ctx, base);
	pc = 0x821B5AF0; continue 'dispatch;
            }
            0x821B5AF0 => {
    //   block [0x821B5AF0..0x821B5AF8)
	// 821B5AF0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821B5AF4: 4837F608  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5AF8 size=564
    let mut pc: u32 = 0x821B5AF8;
    'dispatch: loop {
        match pc {
            0x821B5AF8 => {
    //   block [0x821B5AF8..0x821B5B4C)
	// 821B5AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5AFC: 4837F5A1  bl 0x8253509c
	ctx.lr = 0x821B5B00;
	sub_82535080(ctx, base);
	// 821B5B00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B5B08: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5B0C: 3F3F0002  addis r25, r31, 2
	ctx.r[25].s64 = ctx.r[31].s64 + 131072;
	// 821B5B10: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B5B14: 3B39BE64  addi r25, r25, -0x419c
	ctx.r[25].s64 = ctx.r[25].s64 + -16796;
	// 821B5B18: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821B5B1C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 821B5B20: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 821B5B24: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5B28: 8B190000  lbz r24, 0(r25)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5B30: 419A001C  beq cr6, 0x821b5b4c
	if ctx.cr[6].eq {
	pc = 0x821B5B4C; continue 'dispatch;
	}
	// 821B5B34: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821B5B38: 409A0014  bne cr6, 0x821b5b4c
	if !ctx.cr[6].eq {
	pc = 0x821B5B4C; continue 'dispatch;
	}
	// 821B5B3C: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5B40: 556B0636  rlwinm r11, r11, 0, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B5B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5B48: 409A01CC  bne cr6, 0x821b5d14
	if !ctx.cr[6].eq {
	pc = 0x821B5D14; continue 'dispatch;
	}
	pc = 0x821B5B4C; continue 'dispatch;
            }
            0x821B5B4C => {
    //   block [0x821B5B4C..0x821B5BA8)
	// 821B5B4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B5B50: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B5B54: 396BA92C  addi r11, r11, -0x56d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22228;
	// 821B5B58: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821B5B5C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5B60: 409A0050  bne cr6, 0x821b5bb0
	if !ctx.cr[6].eq {
	pc = 0x821B5BB0; continue 'dispatch;
	}
	// 821B5B64: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B5B68: 614AEB27  ori r10, r10, 0xeb27
	ctx.r[10].u64 = ctx.r[10].u64 | 60199;
	// 821B5B6C: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B5B70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B5B74: 419A003C  beq cr6, 0x821b5bb0
	if ctx.cr[6].eq {
	pc = 0x821B5BB0; continue 'dispatch;
	}
	// 821B5B78: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B5B7C: 419A002C  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B80: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5B84: 419A0024  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B88: 2F0B0026  cmpwi cr6, r11, 0x26
	ctx.cr[6].compare_i32(ctx.r[11].s32, 38, &mut ctx.xer);
	// 821B5B8C: 419A001C  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B90: 2F0B0025  cmpwi cr6, r11, 0x25
	ctx.cr[6].compare_i32(ctx.r[11].s32, 37, &mut ctx.xer);
	// 821B5B94: 419A0014  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5B98: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821B5B9C: 419A000C  beq cr6, 0x821b5ba8
	if ctx.cr[6].eq {
	pc = 0x821B5BA8; continue 'dispatch;
	}
	// 821B5BA0: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 821B5BA4: 409A000C  bne cr6, 0x821b5bb0
	if !ctx.cr[6].eq {
	pc = 0x821B5BB0; continue 'dispatch;
	}
	pc = 0x821B5BA8; continue 'dispatch;
            }
            0x821B5BA8 => {
    //   block [0x821B5BA8..0x821B5BB0)
	// 821B5BA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5BAC: 48000008  b 0x821b5bb4
	pc = 0x821B5BB4; continue 'dispatch;
            }
            0x821B5BB0 => {
    //   block [0x821B5BB0..0x821B5BB4)
	// 821B5BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B5BB4; continue 'dispatch;
            }
            0x821B5BB4 => {
    //   block [0x821B5BB4..0x821B5C80)
	// 821B5BB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5BBC: 419A0168  beq cr6, 0x821b5d24
	if ctx.cr[6].eq {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5BC0: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821B5BC4: 40980160  bge cr6, 0x821b5d24
	if !ctx.cr[6].lt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5BC8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B5BCC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821B5BD0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B5BD4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B5BD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B5BDC: 4E800421  bctrl
	ctx.lr = 0x821B5BE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B5BE0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B5BE4: 571C103A  slwi r28, r24, 2
	ctx.r[28].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821B5BE8: 3B6BCF90  addi r27, r11, -0x3070
	ctx.r[27].s64 = ctx.r[11].s64 + -12400;
	// 821B5BEC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5BF0: 395B0778  addi r10, r27, 0x778
	ctx.r[10].s64 = ctx.r[27].s64 + 1912;
	// 821B5BF4: 616BD33C  ori r11, r11, 0xd33c
	ctx.r[11].u64 = ctx.r[11].u64 | 54076;
	// 821B5BF8: 7C1C542E  lfsx f0, r28, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5BFC: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B5C00: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5C08: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5C0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B5C10: C1AB2054  lfs f13, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C14: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821B5C18: 4098010C  bge cr6, 0x821b5d24
	if !ctx.cr[6].lt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5C1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5C20: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B5C28: 409900FC  ble cr6, 0x821b5d24
	if !ctx.cr[6].gt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5C2C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B5C30: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B5C34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B5C38: 409800EC  bge cr6, 0x821b5d24
	if !ctx.cr[6].lt {
	pc = 0x821B5D24; continue 'dispatch;
	}
	// 821B5C3C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B5C40: 3B5B07A0  addi r26, r27, 0x7a0
	ctx.r[26].s64 = ctx.r[27].s64 + 1952;
	// 821B5C44: 3BAB0C40  addi r29, r11, 0xc40
	ctx.r[29].s64 = ctx.r[11].s64 + 3136;
	// 821B5C48: 7D5CD02E  lwzx r10, r28, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B5C4C: 809D0688  lwz r4, 0x688(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B5C50: 7D6A2050  subf r11, r10, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 821B5C54: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 821B5C58: 40990084  ble cr6, 0x821b5cdc
	if !ctx.cr[6].gt {
	pc = 0x821B5CDC; continue 'dispatch;
	}
	// 821B5C5C: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B5C60: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5C64: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B5C68: 419A0020  beq cr6, 0x821b5c88
	if ctx.cr[6].eq {
	pc = 0x821B5C88; continue 'dispatch;
	}
	// 821B5C6C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B5C70: 419A0010  beq cr6, 0x821b5c80
	if ctx.cr[6].eq {
	pc = 0x821B5C80; continue 'dispatch;
	}
	// 821B5C74: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5C78: 557EE63E  rlwinm r30, r11, 0x1c, 0x18, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5C7C: 48000010  b 0x821b5c8c
	pc = 0x821B5C8C; continue 'dispatch;
            }
            0x821B5C80 => {
    //   block [0x821B5C80..0x821B5C88)
	// 821B5C80: 3BC0003C  li r30, 0x3c
	ctx.r[30].s64 = 60;
	// 821B5C84: 48000008  b 0x821b5c8c
	pc = 0x821B5C8C; continue 'dispatch;
            }
            0x821B5C88 => {
    //   block [0x821B5C88..0x821B5C8C)
	// 821B5C88: 3BC0003A  li r30, 0x3a
	ctx.r[30].s64 = 58;
	pc = 0x821B5C8C; continue 'dispatch;
            }
            0x821B5C8C => {
    //   block [0x821B5C8C..0x821B5CD8)
	// 821B5C8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B5C90: 88790000  lbz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5C94: 4800009D  bl 0x821b5d30
	ctx.lr = 0x821B5C98;
	sub_821B5D30(ctx, base);
	// 821B5C98: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B5C9C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821B5CA0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B5CA4: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821B5CA8: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B5CAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B5CB0: 409A0028  bne cr6, 0x821b5cd8
	if !ctx.cr[6].eq {
	pc = 0x821B5CD8; continue 'dispatch;
	}
	// 821B5CB4: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 821B5CB8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821B5CBC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821B5CC0: 386B45D8  addi r3, r11, 0x45d8
	ctx.r[3].s64 = ctx.r[11].s64 + 17880;
	// 821B5CC4: 89790000  lbz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5CC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B5CCC: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 821B5CD0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821B5CD4: 4BFC6D45  bl 0x8217ca18
	ctx.lr = 0x821B5CD8;
	sub_8217CA18(ctx, base);
	pc = 0x821B5CD8; continue 'dispatch;
            }
            0x821B5CD8 => {
    //   block [0x821B5CD8..0x821B5CDC)
	// 821B5CD8: 809D0688  lwz r4, 0x688(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	pc = 0x821B5CDC; continue 'dispatch;
            }
            0x821B5CDC => {
    //   block [0x821B5CDC..0x821B5CF4)
	// 821B5CDC: 7D7CD02E  lwzx r11, r28, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B5CE0: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 821B5CE4: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 821B5CE8: 4099000C  ble cr6, 0x821b5cf4
	if !ctx.cr[6].gt {
	pc = 0x821B5CF4; continue 'dispatch;
	}
	// 821B5CEC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B5CF0: 4BFFE011  bl 0x821b3d00
	ctx.lr = 0x821B5CF4;
	sub_821B3D00(ctx, base);
	pc = 0x821B5CF4; continue 'dispatch;
            }
            0x821B5CF4 => {
    //   block [0x821B5CF4..0x821B5D14)
	// 821B5CF4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B5CF8: 395B0788  addi r10, r27, 0x788
	ctx.r[10].s64 = ctx.r[27].s64 + 1928;
	// 821B5CFC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821B5D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B5D04: 7D7C512E  stwx r11, r28, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B5D08: 4BFFE919  bl 0x821b4620
	ctx.lr = 0x821B5D0C;
	sub_821B4620(ctx, base);
	// 821B5D0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B5D10: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821B5D14; continue 'dispatch;
            }
            0x821B5D14 => {
    //   block [0x821B5D14..0x821B5D24)
	// 821B5D14: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821B5D18: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821B5D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B5D20: 4BFFF839  bl 0x821b5558
	ctx.lr = 0x821B5D24;
	sub_821B5558(ctx, base);
	pc = 0x821B5D24; continue 'dispatch;
            }
            0x821B5D24 => {
    //   block [0x821B5D24..0x821B5D2C)
	// 821B5D24: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821B5D28: 4837F3C4  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5D30 size=100
    let mut pc: u32 = 0x821B5D30;
    'dispatch: loop {
        match pc {
            0x821B5D30 => {
    //   block [0x821B5D30..0x821B5D94)
	// 821B5D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B5D38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5D3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B5D40: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821B5D44: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B5D48: 5467103A  slwi r7, r3, 2
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821B5D4C: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 821B5D50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821B5D54: C04ABFFC  lfs f2, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B5D58: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821B5D5C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B5D60: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821B5D64: 38A000A4  li r5, 0xa4
	ctx.r[5].s64 = 164;
	// 821B5D68: 7C87582E  lwzx r4, r7, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5D6C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821B5D70: C02ABA38  lfs f1, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B5D74: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 821B5D78: 386A1090  addi r3, r10, 0x1090
	ctx.r[3].s64 = ctx.r[10].s64 + 4240;
	// 821B5D7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821B5D80: 4BFE5A89  bl 0x8219b808
	ctx.lr = 0x821B5D84;
	sub_8219B808(ctx, base);
	// 821B5D84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B5D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B5D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B5D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5D98 size=268
    let mut pc: u32 = 0x821B5D98;
    'dispatch: loop {
        match pc {
            0x821B5D98 => {
    //   block [0x821B5D98..0x821B5EA4)
	// 821B5D98: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 821B5D9C: 41980108  blt cr6, 0x821b5ea4
	if ctx.cr[6].lt {
		sub_821B5EA4(ctx, base);
		return;
	}
	// 821B5DA0: 409A017C  bne cr6, 0x821b5f1c
	if !ctx.cr[6].eq {
		sub_821B5EF4(ctx, base);
		return;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5EA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5EA4 size=80
    let mut pc: u32 = 0x821B5EA4;
    'dispatch: loop {
        match pc {
            0x821B5EA4 => {
    //   block [0x821B5EA4..0x821B5EF4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5EF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B5EF4 size=48
    let mut pc: u32 = 0x821B5EF4;
    'dispatch: loop {
        match pc {
            0x821B5EF4 => {
    //   block [0x821B5EF4..0x821B5F1C)
	// 821B5EF4: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B5EF8: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B5EFC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821B5F00: 409A001C  bne cr6, 0x821b5f1c
	if !ctx.cr[6].eq {
	pc = 0x821B5F1C; continue 'dispatch;
	}
	// 821B5F04: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B5F08: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 821B5F0C: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B5F10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5F18: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x821B5F1C; continue 'dispatch;
            }
            0x821B5F1C => {
    //   block [0x821B5F1C..0x821B5F24)
	// 821B5F1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B5F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B5F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B5F28 size=1348
    let mut pc: u32 = 0x821B5F28;
    'dispatch: loop {
        match pc {
            0x821B5F28 => {
    //   block [0x821B5F28..0x821B5F74)
	// 821B5F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B5F2C: 4837F171  bl 0x8253509c
	ctx.lr = 0x821B5F30;
	sub_82535080(ctx, base);
	// 821B5F30: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821B5F34: 483800A1  bl 0x82535fd4
	ctx.lr = 0x821B5F38;
	sub_82535FB0(ctx, base);
	// 821B5F38: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B5F3C: 3BE80030  addi r31, r8, 0x30
	ctx.r[31].s64 = ctx.r[8].s64 + 48;
	// 821B5F40: FEE00890  fmr f23, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[23].f64 = ctx.f[1].f64;
	// 821B5F44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5F48: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B5F4C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821B5F50: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B5F54: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5F58: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821B5F5C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821B5F60: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B5F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B5F68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B5F6C: 41980008  blt cr6, 0x821b5f74
	if ctx.cr[6].lt {
	pc = 0x821B5F74; continue 'dispatch;
	}
	// 821B5F70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B5F74; continue 'dispatch;
            }
            0x821B5F74 => {
    //   block [0x821B5F74..0x821B5FE0)
	// 821B5F74: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B5F78: 83C101CC  lwz r30, 0x1cc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 821B5F7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B5F80: 812101C4  lwz r9, 0x1c4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(452 as u32) ) } as u64;
	// 821B5F84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B5F88: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821B5F8C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B5F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B5F94: C06B1FF8  lfs f3, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821B5F98: 419A0048  beq cr6, 0x821b5fe0
	if ctx.cr[6].eq {
	pc = 0x821B5FE0; continue 'dispatch;
	}
	// 821B5F9C: EB0A0000  ld r24, 0(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B5FA0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821B5FA4: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B5FA8: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 821B5FAC: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B5FB0: FB0B0000  std r24, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u64 ) };
	// 821B5FB4: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B5FB8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B5FBC: 48003305  bl 0x821b92c0
	ctx.lr = 0x821B5FC0;
	sub_821B92C0(ctx, base);
	// 821B5FC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B5FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B5FC8: 409A00B8  bne cr6, 0x821b6080
	if !ctx.cr[6].eq {
	pc = 0x821B6080; continue 'dispatch;
	}
	// 821B5FCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B5FD0: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 821B5FD4: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821B5FD8: 48380049  bl 0x82536020
	ctx.lr = 0x821B5FDC;
	sub_82535FFC(ctx, base);
	// 821B5FDC: 4837F110  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            0x821B5FE0 => {
    //   block [0x821B5FE0..0x821B6080)
	// 821B5FE0: EB1F0000  ld r24, 0(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821B5FE4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821B5FE8: EAFF0008  ld r23, 8(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	pc = 0x821B6080; continue 'dispatch;
            }
            0x821B6080 => {
    //   block [0x821B6080..0x821B646C)
	// 821B6080: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6470 size=880
    let mut pc: u32 = 0x821B6470;
    'dispatch: loop {
        match pc {
            0x821B6470 => {
    //   block [0x821B6470..0x821B64F0)
	// 821B6470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6474: 4837EC19  bl 0x8253508c
	ctx.lr = 0x821B6478;
	sub_82535080(ctx, base);
	// 821B6478: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821B647C: 4837FB6D  bl 0x82535fe8
	ctx.lr = 0x821B6480;
	sub_82535FB0(ctx, base);
	// 821B6480: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6484: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821B6488: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B648C: 56EA103A  slwi r10, r23, 2
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6490: 396BA92C  addi r11, r11, -0x56d4
	ctx.r[11].s64 = ctx.r[11].s64 + -22228;
	// 821B6494: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B6498: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821B649C: 3F5F0002  addis r26, r31, 2
	ctx.r[26].s64 = ctx.r[31].s64 + 131072;
	// 821B64A0: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821B64A4: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B64A8: 3960003F  li r11, 0x3f
	ctx.r[11].s64 = 63;
	// 821B64AC: 3B5ABE64  addi r26, r26, -0x419c
	ctx.r[26].s64 = ctx.r[26].s64 + -16796;
	// 821B64B0: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 821B64B4: 7D114378  mr r17, r8
	ctx.r[17].u64 = ctx.r[8].u64;
	// 821B64B8: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 821B64BC: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821B64C0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821B64C4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821B64C8: 8ABA0000  lbz r21, 0(r26)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B64CC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821B64D0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821B64D4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821B64D8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 821B64DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B64E0: 4BFFEB79  bl 0x821b5058
	ctx.lr = 0x821B64E4;
	sub_821B5058(ctx, base);
	// 821B64E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B64E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B64EC: 409A0018  bne cr6, 0x821b6504
	if !ctx.cr[6].eq {
	pc = 0x821B6504; continue 'dispatch;
	}
	pc = 0x821B64F0; continue 'dispatch;
            }
            0x821B64F0 => {
    //   block [0x821B64F0..0x821B6504)
	// 821B64F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B64F4: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 821B64F8: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821B64FC: 4837FB39  bl 0x82536034
	ctx.lr = 0x821B6500;
	sub_82535FFC(ctx, base);
	// 821B6500: 4837EBDC  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            0x821B6504 => {
    //   block [0x821B6504..0x821B6550)
	// 821B6504: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B6508: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821B650C: 3900003F  li r8, 0x3f
	ctx.r[8].s64 = 63;
	// 821B6510: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B6514: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821B6518: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 821B651C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B6520: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6524: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821B6528: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B652C: 4BFFE94D  bl 0x821b4e78
	ctx.lr = 0x821B6530;
	sub_821B4E78(ctx, base);
	// 821B6530: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B6534: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B6538: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 821B653C: 3BABCF90  addi r29, r11, -0x3070
	ctx.r[29].s64 = ctx.r[11].s64 + -12400;
	// 821B6540: 409A0010  bne cr6, 0x821b6550
	if !ctx.cr[6].eq {
	pc = 0x821B6550; continue 'dispatch;
	}
	// 821B6544: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B654C: 4BFFD8F5  bl 0x821b3e40
	ctx.lr = 0x821B6550;
	sub_821B3E40(ctx, base);
	pc = 0x821B6550; continue 'dispatch;
            }
            0x821B6550 => {
    //   block [0x821B6550..0x821B657C)
	// 821B6550: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821B6554: 419AFF9C  beq cr6, 0x821b64f0
	if ctx.cr[6].eq {
	pc = 0x821B64F0; continue 'dispatch;
	}
	// 821B6558: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B655C: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B6560: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B6564: 419A0020  beq cr6, 0x821b6584
	if ctx.cr[6].eq {
	pc = 0x821B6584; continue 'dispatch;
	}
	// 821B6568: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B656C: 419A0010  beq cr6, 0x821b657c
	if ctx.cr[6].eq {
	pc = 0x821B657C; continue 'dispatch;
	}
	// 821B6570: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B6574: 5574E63E  rlwinm r20, r11, 0x1c, 0x18, 0x1f
	ctx.r[20].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B6578: 48000010  b 0x821b6588
	pc = 0x821B6588; continue 'dispatch;
            }
            0x821B657C => {
    //   block [0x821B657C..0x821B6584)
	// 821B657C: 3A80003C  li r20, 0x3c
	ctx.r[20].s64 = 60;
	// 821B6580: 48000008  b 0x821b6588
	pc = 0x821B6588; continue 'dispatch;
            }
            0x821B6584 => {
    //   block [0x821B6584..0x821B6588)
	// 821B6584: 3A80003A  li r20, 0x3a
	ctx.r[20].s64 = 58;
	pc = 0x821B6588; continue 'dispatch;
            }
            0x821B6588 => {
    //   block [0x821B6588..0x821B6628)
	// 821B6588: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 821B658C: 56BE103A  slwi r30, r21, 2
	ctx.r[30].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821B6590: 3B6B0C40  addi r27, r11, 0xc40
	ctx.r[27].s64 = ctx.r[11].s64 + 3136;
	// 821B6594: 3B1D07A8  addi r24, r29, 0x7a8
	ctx.r[24].s64 = ctx.r[29].s64 + 1960;
	// 821B6598: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B659C: 817B0688  lwz r11, 0x688(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B65A0: 7D5EC02E  lwzx r10, r30, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 821B65A4: C389213C  lfs f28, 0x213c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8508 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821B65A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B65AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B65B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B65B4: C3EA210C  lfs f31, 0x210c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8460 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B65B8: C3CB2254  lfs f30, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B65BC: 4098008C  bge cr6, 0x821b6648
	if !ctx.cr[6].lt {
	pc = 0x821B6648; continue 'dispatch;
	}
	// 821B65C0: C05C0038  lfs f2, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B65C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B65C8: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B65CC: EDA20372  fmuls f13, f2, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B65D0: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B65D4: C03C0030  lfs f1, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B65D8: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B65DC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B65E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B65E4: 40980064  bge cr6, 0x821b6648
	if !ctx.cr[6].lt {
	pc = 0x821B6648; continue 'dispatch;
	}
	// 821B65E8: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B65EC: 3B3D0780  addi r25, r29, 0x780
	ctx.r[25].s64 = ctx.r[29].s64 + 1920;
	// 821B65F0: 557A103E  rotlwi r26, r11, 2
	ctx.r[26].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B65F4: 4837C8B5  bl 0x82532ea8
	ctx.lr = 0x821B65F8;
	sub_82532EA8(ctx, base);
	// 821B65F8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821B65FC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6600: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 821B6604: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6608: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B660C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B6610: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821B6614: 7C1ACD2E  stfsx f0, r26, r25
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	// 821B6618: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 821B661C: 4099000C  ble cr6, 0x821b6628
	if !ctx.cr[6].gt {
	pc = 0x821B6628; continue 'dispatch;
	}
	// 821B6620: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 821B6624: 48000018  b 0x821b663c
	pc = 0x821B663C; continue 'dispatch;
            }
            0x821B6628 => {
    //   block [0x821B6628..0x821B663C)
	// 821B6628: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B662C: C1AB25B4  lfs f13, 0x25b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9652 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6630: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B6634: 4098000C  bge cr6, 0x821b6640
	if !ctx.cr[6].lt {
	pc = 0x821B6640; continue 'dispatch;
	}
	// 821B6638: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x821B663C; continue 'dispatch;
            }
            0x821B663C => {
    //   block [0x821B663C..0x821B6640)
	// 821B663C: 7C1ACD2E  stfsx f0, r26, r25
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), tmp.u32) };
	pc = 0x821B6640; continue 'dispatch;
            }
            0x821B6640 => {
    //   block [0x821B6640..0x821B6648)
	// 821B6640: 817B0688  lwz r11, 0x688(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B6644: 7D7EC12E  stwx r11, r30, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32), ctx.r[11].u32) };
	pc = 0x821B6648; continue 'dispatch;
            }
            0x821B6648 => {
    //   block [0x821B6648..0x821B674C)
	// 821B6648: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821B664C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821B6650: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 821B6654: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821B6658: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821B665C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821B6660: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 821B6664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6668: 4BFFEBE9  bl 0x821b5250
	ctx.lr = 0x821B666C;
	sub_821B5250(ctx, base);
	// 821B666C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B6670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6674: 419AFE7C  beq cr6, 0x821b64f0
	if ctx.cr[6].eq {
	pc = 0x821B64F0; continue 'dispatch;
	}
	// 821B6678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B667C: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 821B6680: 91730000  stw r11, 0(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B6684: 409A00C8  bne cr6, 0x821b674c
	if !ctx.cr[6].eq {
	pc = 0x821B674C; continue 'dispatch;
	}
	// 821B6688: 3B5D0824  addi r26, r29, 0x824
	ctx.r[26].s64 = ctx.r[29].s64 + 2084;
	// 821B668C: 817B0688  lwz r11, 0x688(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1672 as u32) ) } as u64;
	// 821B6690: 7D5ED02E  lwzx r10, r30, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 821B6694: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B6698: 409800B4  bge cr6, 0x821b674c
	if !ctx.cr[6].lt {
	pc = 0x821B674C; continue 'dispatch;
	}
	// 821B669C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B66A0: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821B66A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B66A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B66AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B66B0: 4E800421  bctrl
	ctx.lr = 0x821B66B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B66B4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B66B8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821B66BC: 393D0030  addi r9, r29, 0x30
	ctx.r[9].s64 = ctx.r[29].s64 + 48;
	// 821B66C0: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B66C4: 1D550310  mulli r10, r21, 0x310
	ctx.r[10].s32 = ((ctx.r[21].s32 as i64 * 784 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821B66C8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821B66CC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B66D0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821B66D4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B66D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821B66DC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
            }
            0x821B674C => {
    //   block [0x821B674C..0x821B67E0)
	// 821B674C: 397D0778  addi r11, r29, 0x778
	ctx.r[11].s64 = ctx.r[29].s64 + 1912;
	// 821B6750: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821B6754: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821B6758: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821B675C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 821B6760: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821B6764: 7FFE5C2E  lfsx f31, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B6768: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 821B676C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6770: 4BFFF389  bl 0x821b5af8
	ctx.lr = 0x821B6774;
	sub_821B5AF8(ctx, base);
	// 821B6774: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821B6778: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 821B677C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821B6780: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 821B6784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B6788: 4BFFF611  bl 0x821b5d98
	ctx.lr = 0x821B678C;
	sub_821B5D98(ctx, base);
	// 821B678C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B6790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6794: 419AFD5C  beq cr6, 0x821b64f0
	if ctx.cr[6].eq {
	pc = 0x821B64F0; continue 'dispatch;
	}
	// 821B6798: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821B679C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B67A0: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 821B67A4: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 821B67A8: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821B67AC: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 821B67B0: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 821B67B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821B67B8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821B67BC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B67C0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821B67C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B67C8: 4BFFF761  bl 0x821b5f28
	ctx.lr = 0x821B67CC;
	sub_821B5F28(ctx, base);
	// 821B67CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B67D0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 821B67D4: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821B67D8: 4837F85D  bl 0x82536034
	ctx.lr = 0x821B67DC;
	sub_82535FFC(ctx, base);
	// 821B67DC: 4837E900  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B67E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B67E0 size=144
    let mut pc: u32 = 0x821B67E0;
    'dispatch: loop {
        match pc {
            0x821B67E0 => {
    //   block [0x821B67E0..0x821B6804)
	// 821B67E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B67E4: 4837E8D1  bl 0x825350b4
	ctx.lr = 0x821B67E8;
	sub_82535080(ctx, base);
	// 821B67E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B67EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821B67F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B67F4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B67F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B67FC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821B6800: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	pc = 0x821B6804; continue 'dispatch;
            }
            0x821B6804 => {
    //   block [0x821B6804..0x821B683C)
	// 821B6804: 7FEB0034  cntlzw r11, r31
	ctx.r[11].u64 = if ctx.r[31].u32 == 0 { 32 } else { ctx.r[31].u32.leading_zeros() as u64 };
	// 821B6808: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B680C: 5568DFFE  rlwinm r8, r11, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821B6810: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821B6814: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821B6818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B681C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B6820: 4BFFFC51  bl 0x821b6470
	ctx.lr = 0x821B6824;
	sub_821B6470(ctx, base);
	// 821B6824: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B6828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B682C: 409A0010  bne cr6, 0x821b683c
	if !ctx.cr[6].eq {
	pc = 0x821B683C; continue 'dispatch;
	}
	// 821B6830: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821B6834: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 821B6838: 4198FFCC  blt cr6, 0x821b6804
	if ctx.cr[6].lt {
	pc = 0x821B6804; continue 'dispatch;
	}
	pc = 0x821B683C; continue 'dispatch;
            }
            0x821B683C => {
    //   block [0x821B683C..0x821B6870)
	// 821B683C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6840: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B6844: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B6848: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B684C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821B6850: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B6854: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6858: 390B0640  addi r8, r11, 0x640
	ctx.r[8].s64 = ctx.r[11].s64 + 1600;
	// 821B685C: 1D6A0031  mulli r11, r10, 0x31
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 49 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821B6860: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821B6864: 7D2B41AE  stbx r9, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u8) };
	// 821B6868: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821B686C: 4837E898  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B6870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B6870 size=2068
    let mut pc: u32 = 0x821B6870;
    'dispatch: loop {
        match pc {
            0x821B6870 => {
    //   block [0x821B6870..0x821B68D0)
	// 821B6870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B6874: 4837E80D  bl 0x82535080
	ctx.lr = 0x821B6878;
	sub_82535080(ctx, base);
	// 821B6878: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 821B687C: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821B6880: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B6884: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B6888: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B688C: 3DDA0006  addis r14, r26, 6
	ctx.r[14].s64 = ctx.r[26].s64 + 393216;
	// 821B6890: 616BEB1C  ori r11, r11, 0xeb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 60188;
	// 821B6894: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B6898: 39CEA9C0  addi r14, r14, -0x5640
	ctx.r[14].s64 = ctx.r[14].s64 + -22080;
	// 821B689C: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 821B68A0: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 821B68A4: 7D3A58AE  lbzx r9, r26, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B68A8: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821B68AC: 83EE0000  lwz r31, 0(r14)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B68B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B68B4: 7EFA50AE  lbzx r23, r26, r10
	ctx.r[23].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B68B8: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 821B68BC: 409A0014  bne cr6, 0x821b68d0
	if !ctx.cr[6].eq {
	pc = 0x821B68D0; continue 'dispatch;
	}
	// 821B68C0: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B68C4: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	// 821B68C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B68CC: 419A0008  beq cr6, 0x821b68d4
	if ctx.cr[6].eq {
	pc = 0x821B68D4; continue 'dispatch;
	}
	pc = 0x821B68D0; continue 'dispatch;
            }
            0x821B68D0 => {
    //   block [0x821B68D0..0x821B68D4)
	// 821B68D0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x821B68D4; continue 'dispatch;
            }
            0x821B68D4 => {
    //   block [0x821B68D4..0x821B68E8)
	// 821B68D4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821B68D8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 821B68DC: 419A000C  beq cr6, 0x821b68e8
	if ctx.cr[6].eq {
	pc = 0x821B68E8; continue 'dispatch;
	}
	// 821B68E0: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 821B68E4: 409A078C  bne cr6, 0x821b7070
	if !ctx.cr[6].eq {
	pc = 0x821B7070; continue 'dispatch;
	}
	pc = 0x821B68E8; continue 'dispatch;
            }
            0x821B68E8 => {
    //   block [0x821B68E8..0x821B6974)
	// 821B68E8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B68EC: 56F6103A  slwi r22, r23, 2
	ctx.r[22].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 821B68F0: 3A8BCF90  addi r20, r11, -0x3070
	ctx.r[20].s64 = ctx.r[11].s64 + -12400;
	// 821B68F4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B68F8: 393407C8  addi r9, r20, 0x7c8
	ctx.r[9].s64 = ctx.r[20].s64 + 1992;
	// 821B68FC: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B6900: 7E76492E  stwx r19, r22, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[9].u32), ctx.r[19].u32) };
	// 821B6904: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 821B6908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B690C: 419A0764  beq cr6, 0x821b7070
	if ctx.cr[6].eq {
	pc = 0x821B7070; continue 'dispatch;
	}
	// 821B6910: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B6914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6918: 419A0758  beq cr6, 0x821b7070
	if ctx.cr[6].eq {
	pc = 0x821B7070; continue 'dispatch;
	}
	// 821B691C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B6920: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821B6924: 4BFFD0CD  bl 0x821b39f0
	ctx.lr = 0x821B6928;
	sub_821B39F0(ctx, base);
	// 821B6928: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B692C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B6930: 616BEB31  ori r11, r11, 0xeb31
	ctx.r[11].u64 = ctx.r[11].u64 | 60209;
	// 821B6934: 6130EB20  ori r16, r9, 0xeb20
	ctx.r[16].u64 = ctx.r[9].u64 | 60192;
	// 821B6938: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B693C: 6135EB04  ori r21, r9, 0xeb04
	ctx.r[21].u64 = ctx.r[9].u64 | 60164;
	// 821B6940: 7D5A58AE  lbzx r10, r26, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6944: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B6948: 612FEB32  ori r15, r9, 0xeb32
	ctx.r[15].u64 = ctx.r[9].u64 | 60210;
	// 821B694C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6950: 409A0024  bne cr6, 0x821b6974
	if !ctx.cr[6].eq {
	pc = 0x821B6974; continue 'dispatch;
	}
	// 821B6954: 7D3F58AE  lbzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6958: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B695C: 409A0018  bne cr6, 0x821b6974
	if !ctx.cr[6].eq {
	pc = 0x821B6974; continue 'dispatch;
	}
	// 821B6960: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B6964: 409A0058  bne cr6, 0x821b69bc
	if !ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	// 821B6968: 7D7F78AE  lbzx r11, r31, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 821B696C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6970: 48000044  b 0x821b69b4
	pc = 0x821B69B4; continue 'dispatch;
            }
            0x821B6974 => {
    //   block [0x821B6974..0x821B6998)
	// 821B6974: 7D3F78AE  lbzx r9, r31, r15
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 821B6978: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B697C: 409A0028  bne cr6, 0x821b69a4
	if !ctx.cr[6].eq {
	pc = 0x821B69A4; continue 'dispatch;
	}
	// 821B6980: 7D3F80AE  lbzx r9, r31, r16
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6984: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6988: 409A0010  bne cr6, 0x821b6998
	if !ctx.cr[6].eq {
	pc = 0x821B6998; continue 'dispatch;
	}
	// 821B698C: 7D3FA8AE  lbzx r9, r31, r21
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821B6990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6994: 419A0028  beq cr6, 0x821b69bc
	if ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	pc = 0x821B6998; continue 'dispatch;
            }
            0x821B6998 => {
    //   block [0x821B6998..0x821B69A4)
	// 821B6998: 7D3F58AE  lbzx r9, r31, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B699C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B69A0: 419A001C  beq cr6, 0x821b69bc
	if ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	pc = 0x821B69A4; continue 'dispatch;
            }
            0x821B69A4 => {
    //   block [0x821B69A4..0x821B69B4)
	// 821B69A4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821B69A8: 419A0010  beq cr6, 0x821b69b8
	if ctx.cr[6].eq {
	pc = 0x821B69B8; continue 'dispatch;
	}
	// 821B69AC: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B69B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	pc = 0x821B69B4; continue 'dispatch;
            }
            0x821B69B4 => {
    //   block [0x821B69B4..0x821B69B8)
	// 821B69B4: 419A0008  beq cr6, 0x821b69bc
	if ctx.cr[6].eq {
	pc = 0x821B69BC; continue 'dispatch;
	}
	pc = 0x821B69B8; continue 'dispatch;
            }
            0x821B69B8 => {
    //   block [0x821B69B8..0x821B69BC)
	// 821B69B8: 7E719B78  mr r17, r19
	ctx.r[17].u64 = ctx.r[19].u64;
	pc = 0x821B69BC; continue 'dispatch;
            }
            0x821B69BC => {
    //   block [0x821B69BC..0x821B6A70)
	// 821B69BC: 3FDA0002  addis r30, r26, 2
	ctx.r[30].s64 = ctx.r[26].s64 + 131072;
	// 821B69C0: 3BDEED28  addi r30, r30, -0x12d8
	ctx.r[30].s64 = ctx.r[30].s64 + -4824;
	// 821B69C4: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B69C8: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 821B69CC: 409A00A4  bne cr6, 0x821b6a70
	if !ctx.cr[6].eq {
	pc = 0x821B6A70; continue 'dispatch;
	}
	// 821B69D0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821B69D4: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 821B69D8: 396BFA00  addi r11, r11, -0x600
	ctx.r[11].s64 = ctx.r[11].s64 + -1536;
	// 821B69DC: 39296210  addi r9, r9, 0x6210
	ctx.r[9].s64 = ctx.r[9].s64 + 25104;
	// 821B69E0: 386B0060  addi r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 + 96;
	// 821B69E4: 56EA2036  slwi r10, r23, 4
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B69E8: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 821B69EC: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 821B69F0: 388B0090  addi r4, r11, 0x90
	ctx.r[4].s64 = ctx.r[11].s64 + 144;
	// 821B69F4: 7E76492E  stwx r19, r22, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[9].u32), ctx.r[19].u32) };
	// 821B69F8: 7C6A1A14  add r3, r10, r3
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 821B69FC: 38EB0050  addi r7, r11, 0x50
	ctx.r[7].s64 = ctx.r[11].s64 + 80;
	// 821B6A00: 38CB0080  addi r6, r11, 0x80
	ctx.r[6].s64 = ctx.r[11].s64 + 128;
	// 821B6A04: 38AB00B0  addi r5, r11, 0xb0
	ctx.r[5].s64 = ctx.r[11].s64 + 176;
	// 821B6A08: 3BA90018  addi r29, r9, 0x18
	ctx.r[29].s64 = ctx.r[9].s64 + 24;
	// 821B6A0C: 3B890010  addi r28, r9, 0x10
	ctx.r[28].s64 = ctx.r[9].s64 + 16;
	// 821B6A10: 3B690008  addi r27, r9, 8
	ctx.r[27].s64 = ctx.r[9].s64 + 8;
	// 821B6A14: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B6A18: 7D2AFA14  add r9, r10, r31
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821B6A1C: 7C8A2214  add r4, r10, r4
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 821B6A20: 7E76E92E  stwx r19, r22, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[29].u32), ctx.r[19].u32) };
	// 821B6A24: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B6A28: E8680000  ld r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821B6A2C: 7E76E12E  stwx r19, r22, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[28].u32), ctx.r[19].u32) };
	// 821B6A30: 7E76D92E  stwx r19, r22, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[27].u32), ctx.r[19].u32) };
	// 821B6A34: F86B0000  std r3, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821B6A38: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821B6A3C: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821B6A40: E9670000  ld r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B6A44: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6A48: E9670008  ld r11, 8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821B6A4C: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6A50: E9660000  ld r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 821B6A54: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6A58: E9660008  ld r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 821B6A5C: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6A60: E9650000  ld r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 821B6A64: F9640000  std r11, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B6A68: E9650008  ld r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 821B6A6C: F9640008  std r11, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821B6A70; continue 'dispatch;
            }
            0x821B6A70 => {
    //   block [0x821B6A70..0x821B6AC0)
	// 821B6A70: 39540770  addi r10, r20, 0x770
	ctx.r[10].s64 = ctx.r[20].s64 + 1904;
	// 821B6A74: 7D76502E  lwzx r11, r22, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6A78: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821B6A7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6A80: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821B6A84: 3B0BA92C  addi r24, r11, -0x56d4
	ctx.r[24].s64 = ctx.r[11].s64 + -22228;
	// 821B6A88: 7D36512E  stwx r9, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 821B6A8C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B6A90: 6152EB03  ori r18, r10, 0xeb03
	ctx.r[18].u64 = ctx.r[10].u64 | 60163;
	// 821B6A94: 40990194  ble cr6, 0x821b6c28
	if !ctx.cr[6].gt {
	pc = 0x821B6C28; continue 'dispatch;
	}
	// 821B6A98: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6A9C: 616BEDAE  ori r11, r11, 0xedae
	ctx.r[11].u64 = ctx.r[11].u64 | 60846;
	// 821B6AA0: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6AA8: 419A0018  beq cr6, 0x821b6ac0
	if ctx.cr[6].eq {
	pc = 0x821B6AC0; continue 'dispatch;
	}
	// 821B6AAC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6AB0: 616BED4C  ori r11, r11, 0xed4c
	ctx.r[11].u64 = ctx.r[11].u64 | 60748;
	// 821B6AB4: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6ABC: 419A0028  beq cr6, 0x821b6ae4
	if ctx.cr[6].eq {
	pc = 0x821B6AE4; continue 'dispatch;
	}
	pc = 0x821B6AC0; continue 'dispatch;
            }
            0x821B6AC0 => {
    //   block [0x821B6AC0..0x821B6AE4)
	// 821B6AC0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6AC4: 616BED2C  ori r11, r11, 0xed2c
	ctx.r[11].u64 = ctx.r[11].u64 | 60716;
	// 821B6AC8: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6ACC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B6AD0: 40980014  bge cr6, 0x821b6ae4
	if !ctx.cr[6].lt {
	pc = 0x821B6AE4; continue 'dispatch;
	}
	// 821B6AD4: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6AD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6ADC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821B6AE0: 41990018  bgt cr6, 0x821b6af8
	if ctx.cr[6].gt {
	pc = 0x821B6AF8; continue 'dispatch;
	}
	pc = 0x821B6AE4; continue 'dispatch;
            }
            0x821B6AE4 => {
    //   block [0x821B6AE4..0x821B6AF8)
	// 821B6AE4: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 821B6AE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B6AEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821B6AF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6AF4: 4BFFFCED  bl 0x821b67e0
	ctx.lr = 0x821B6AF8;
	sub_821B67E0(ctx, base);
	pc = 0x821B6AF8; continue 'dispatch;
            }
            0x821B6AF8 => {
    //   block [0x821B6AF8..0x821B6B18)
	// 821B6AF8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6AFC: 3F3A0002  addis r25, r26, 2
	ctx.r[25].s64 = ctx.r[26].s64 + 131072;
	// 821B6B00: 617BEB3F  ori r27, r11, 0xeb3f
	ctx.r[27].u64 = ctx.r[11].u64 | 60223;
	// 821B6B04: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6B08: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	// 821B6B0C: 3B39EB27  addi r25, r25, -0x14d9
	ctx.r[25].s64 = ctx.r[25].s64 + -5337;
	// 821B6B10: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 821B6B14: 617CED3C  ori r28, r11, 0xed3c
	ctx.r[28].u64 = ctx.r[11].u64 | 60732;
	pc = 0x821B6B18; continue 'dispatch;
            }
            0x821B6B18 => {
    //   block [0x821B6B18..0x821B6B48)
	// 821B6B18: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6B1C: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 821B6B20: 409A003C  bne cr6, 0x821b6b5c
	if !ctx.cr[6].eq {
	pc = 0x821B6B5C; continue 'dispatch;
	}
	// 821B6B24: 7D7A90AE  lbzx r11, r26, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821B6B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B2C: 409A001C  bne cr6, 0x821b6b48
	if !ctx.cr[6].eq {
	pc = 0x821B6B48; continue 'dispatch;
	}
	// 821B6B30: 7D7A80AE  lbzx r11, r26, r16
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B38: 409A0010  bne cr6, 0x821b6b48
	if !ctx.cr[6].eq {
	pc = 0x821B6B48; continue 'dispatch;
	}
	// 821B6B3C: 7D7AA8AE  lbzx r11, r26, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821B6B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B44: 419A0018  beq cr6, 0x821b6b5c
	if ctx.cr[6].eq {
	pc = 0x821B6B5C; continue 'dispatch;
	}
	pc = 0x821B6B48; continue 'dispatch;
            }
            0x821B6B48 => {
    //   block [0x821B6B48..0x821B6B5C)
	// 821B6B48: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 821B6B4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821B6B50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B6B54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6B58: 4BFFFC89  bl 0x821b67e0
	ctx.lr = 0x821B6B5C;
	sub_821B67E0(ctx, base);
	pc = 0x821B6B5C; continue 'dispatch;
            }
            0x821B6B5C => {
    //   block [0x821B6B5C..0x821B6B78)
	// 821B6B5C: 89790000  lbz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B64: 419A0014  beq cr6, 0x821b6b78
	if ctx.cr[6].eq {
	pc = 0x821B6B78; continue 'dispatch;
	}
	// 821B6B68: 2F1F0021  cmpwi cr6, r31, 0x21
	ctx.cr[6].compare_i32(ctx.r[31].s32, 33, &mut ctx.xer);
	// 821B6B6C: 4198000C  blt cr6, 0x821b6b78
	if ctx.cr[6].lt {
	pc = 0x821B6B78; continue 'dispatch;
	}
	// 821B6B70: 2F1F0024  cmpwi cr6, r31, 0x24
	ctx.cr[6].compare_i32(ctx.r[31].s32, 36, &mut ctx.xer);
	// 821B6B74: 409900A0  ble cr6, 0x821b6c14
	if !ctx.cr[6].gt {
	pc = 0x821B6C14; continue 'dispatch;
	}
	pc = 0x821B6B78; continue 'dispatch;
            }
            0x821B6B78 => {
    //   block [0x821B6B78..0x821B6BD0)
	// 821B6B78: 2F1F002D  cmpwi cr6, r31, 0x2d
	ctx.cr[6].compare_i32(ctx.r[31].s32, 45, &mut ctx.xer);
	// 821B6B7C: 41980074  blt cr6, 0x821b6bf0
	if ctx.cr[6].lt {
	pc = 0x821B6BF0; continue 'dispatch;
	}
	// 821B6B80: 7D7A90AE  lbzx r11, r26, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821B6B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B88: 409A008C  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6B8C: 7D7AD8AE  lbzx r11, r26, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 821B6B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6B94: 409A0080  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6B98: 7D7AA8AE  lbzx r11, r26, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821B6B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6BA0: 409A0074  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6BA4: 7D7A80AE  lbzx r11, r26, r16
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6BAC: 409A0068  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6BB0: 562B063E  clrlwi r11, r17, 0x18
	ctx.r[11].u64 = ctx.r[17].u32 as u64 & 0x000000FFu64;
	// 821B6BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6BB8: 409A0038  bne cr6, 0x821b6bf0
	if !ctx.cr[6].eq {
	pc = 0x821B6BF0; continue 'dispatch;
	}
	// 821B6BBC: 7D7AE22E  lhzx r11, r26, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821B6BC0: 2F1F0030  cmpwi cr6, r31, 0x30
	ctx.cr[6].compare_i32(ctx.r[31].s32, 48, &mut ctx.xer);
	// 821B6BC4: 409A000C  bne cr6, 0x821b6bd0
	if !ctx.cr[6].eq {
	pc = 0x821B6BD0; continue 'dispatch;
	}
	// 821B6BC8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821B6BCC: 48000020  b 0x821b6bec
	pc = 0x821B6BEC; continue 'dispatch;
            }
            0x821B6BD0 => {
    //   block [0x821B6BD0..0x821B6BE0)
	// 821B6BD0: 2F1F002E  cmpwi cr6, r31, 0x2e
	ctx.cr[6].compare_i32(ctx.r[31].s32, 46, &mut ctx.xer);
	// 821B6BD4: 409A000C  bne cr6, 0x821b6be0
	if !ctx.cr[6].eq {
	pc = 0x821B6BE0; continue 'dispatch;
	}
	// 821B6BD8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821B6BDC: 48000010  b 0x821b6bec
	pc = 0x821B6BEC; continue 'dispatch;
            }
            0x821B6BE0 => {
    //   block [0x821B6BE0..0x821B6BEC)
	// 821B6BE0: 2F1F002F  cmpwi cr6, r31, 0x2f
	ctx.cr[6].compare_i32(ctx.r[31].s32, 47, &mut ctx.xer);
	// 821B6BE4: 409A000C  bne cr6, 0x821b6bf0
	if !ctx.cr[6].eq {
	pc = 0x821B6BF0; continue 'dispatch;
	}
	// 821B6BE8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	pc = 0x821B6BEC; continue 'dispatch;
            }
            0x821B6BEC => {
    //   block [0x821B6BEC..0x821B6BF0)
	// 821B6BEC: 419A0028  beq cr6, 0x821b6c14
	if ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	pc = 0x821B6BF0; continue 'dispatch;
            }
            0x821B6BF0 => {
    //   block [0x821B6BF0..0x821B6C14)
	// 821B6BF0: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 821B6BF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B6BF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B6BFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6C00: 4BFFFBE1  bl 0x821b67e0
	ctx.lr = 0x821B6C04;
	sub_821B67E0(ctx, base);
	// 821B6C04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B6C08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6C0C: 409A0008  bne cr6, 0x821b6c14
	if !ctx.cr[6].eq {
	pc = 0x821B6C14; continue 'dispatch;
	}
	// 821B6C10: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	pc = 0x821B6C14; continue 'dispatch;
            }
            0x821B6C14 => {
    //   block [0x821B6C14..0x821B6C28)
	// 821B6C14: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821B6C18: 3978003C  addi r11, r24, 0x3c
	ctx.r[11].s64 = ctx.r[24].s64 + 60;
	// 821B6C1C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821B6C20: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B6C24: 4198FEF4  blt cr6, 0x821b6b18
	if ctx.cr[6].lt {
	pc = 0x821B6B18; continue 'dispatch;
	}
	pc = 0x821B6C28; continue 'dispatch;
            }
            0x821B6C28 => {
    //   block [0x821B6C28..0x821B6C54)
	// 821B6C28: 56EA2036  slwi r10, r23, 4
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6C2C: 397406A2  addi r11, r20, 0x6a2
	ctx.r[11].s64 = ctx.r[20].s64 + 1698;
	// 821B6C30: 1FB70031  mulli r29, r23, 0x31
	ctx.r[29].s32 = ((ctx.r[23].s32 as i64 * 49 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 821B6C34: 39340750  addi r9, r20, 0x750
	ctx.r[9].s64 = ctx.r[20].s64 + 1872;
	// 821B6C38: 7F7D5A14  add r27, r29, r11
	ctx.r[27].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821B6C3C: 7F8A4A14  add r28, r10, r9
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B6C40: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821B6C44: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821B6C48: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 821B6C4C: C3CBD4DC  lfs f30, -0x2b24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B6C50: C3EA2190  lfs f31, 0x2190(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8592 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821B6C54; continue 'dispatch;
            }
            0x821B6C54 => {
    //   block [0x821B6C54..0x821B6CAC)
	// 821B6C54: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B6C58: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B6C5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6C60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B6C64: 48000D65  bl 0x821b79c8
	ctx.lr = 0x821B6C68;
	sub_821B79C8(ctx, base);
	// 821B6C68: 7D5DFA14  add r10, r29, r31
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821B6C6C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B6C70: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821B6C74: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B6C78: 39340020  addi r9, r20, 0x20
	ctx.r[9].s64 = ctx.r[20].s64 + 32;
	// 821B6C7C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B6C80: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821B6C84: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B6C88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B6C8C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B6C90: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B6C94: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B6C98: 4BFFD3F9  bl 0x821b4090
	ctx.lr = 0x821B6C9C;
	sub_821B4090(ctx, base);
	// 821B6C9C: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 821B6CA0: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821B6CA4: 41990008  bgt cr6, 0x821b6cac
	if ctx.cr[6].gt {
	pc = 0x821B6CAC; continue 'dispatch;
	}
	// 821B6CA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821B6CAC; continue 'dispatch;
            }
            0x821B6CAC => {
    //   block [0x821B6CAC..0x821B6CE0)
	// 821B6CAC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821B6CB0: 7D7BF9AE  stbx r11, r27, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u8) };
	// 821B6CB4: 3958003C  addi r10, r24, 0x3c
	ctx.r[10].s64 = ctx.r[24].s64 + 60;
	// 821B6CB8: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B6CBC: 4198FF98  blt cr6, 0x821b6c54
	if ctx.cr[6].lt {
	pc = 0x821B6C54; continue 'dispatch;
	}
	// 821B6CC0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6CC4: 616BED3A  ori r11, r11, 0xed3a
	ctx.r[11].u64 = ctx.r[11].u64 | 60730;
	// 821B6CC8: 7D7A5A2E  lhzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6CCC: 2F0B0011  cmpwi cr6, r11, 0x11
	ctx.cr[6].compare_i32(ctx.r[11].s32, 17, &mut ctx.xer);
	// 821B6CD0: 419A0010  beq cr6, 0x821b6ce0
	if ctx.cr[6].eq {
	pc = 0x821B6CE0; continue 'dispatch;
	}
	// 821B6CD4: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 821B6CD8: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821B6CDC: 409A0008  bne cr6, 0x821b6ce4
	if !ctx.cr[6].eq {
	pc = 0x821B6CE4; continue 'dispatch;
	}
	pc = 0x821B6CE0; continue 'dispatch;
            }
            0x821B6CE0 => {
    //   block [0x821B6CE0..0x821B6CE4)
	// 821B6CE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821B6CE4; continue 'dispatch;
            }
            0x821B6CE4 => {
    //   block [0x821B6CE4..0x821B6CF8)
	// 821B6CE4: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B6CE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B6CEC: 419A000C  beq cr6, 0x821b6cf8
	if ctx.cr[6].eq {
	pc = 0x821B6CF8; continue 'dispatch;
	}
	// 821B6CF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6CF4: 4BFFDA95  bl 0x821b4788
	ctx.lr = 0x821B6CF8;
	sub_821B4788(ctx, base);
	pc = 0x821B6CF8; continue 'dispatch;
            }
            0x821B6CF8 => {
    //   block [0x821B6CF8..0x821B6D1C)
	// 821B6CF8: 395407B0  addi r10, r20, 0x7b0
	ctx.r[10].s64 = ctx.r[20].s64 + 1968;
	// 821B6CFC: 7D76502E  lwzx r11, r22, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6D00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6D04: 409A0018  bne cr6, 0x821b6d1c
	if !ctx.cr[6].eq {
	pc = 0x821B6D1C; continue 'dispatch;
	}
	// 821B6D08: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 821B6D0C: 409A0038  bne cr6, 0x821b6d44
	if !ctx.cr[6].eq {
	pc = 0x821B6D44; continue 'dispatch;
	}
	// 821B6D10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6D14: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D18: 4800002C  b 0x821b6d44
	pc = 0x821B6D44; continue 'dispatch;
            }
            0x821B6D1C => {
    //   block [0x821B6D1C..0x821B6D34)
	// 821B6D1C: 40990018  ble cr6, 0x821b6d34
	if !ctx.cr[6].gt {
	pc = 0x821B6D34; continue 'dispatch;
	}
	// 821B6D20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B6D24: 409A0020  bne cr6, 0x821b6d44
	if !ctx.cr[6].eq {
	pc = 0x821B6D44; continue 'dispatch;
	}
	// 821B6D28: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821B6D2C: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D30: 48000014  b 0x821b6d44
	pc = 0x821B6D44; continue 'dispatch;
            }
            0x821B6D34 => {
    //   block [0x821B6D34..0x821B6D44)
	// 821B6D34: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 821B6D38: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B6D3C: 41980008  blt cr6, 0x821b6d44
	if ctx.cr[6].lt {
	pc = 0x821B6D44; continue 'dispatch;
	}
	// 821B6D40: 7E76512E  stwx r19, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[19].u32) };
	pc = 0x821B6D44; continue 'dispatch;
            }
            0x821B6D44 => {
    //   block [0x821B6D44..0x821B6D80)
	// 821B6D44: 7D76502E  lwzx r11, r22, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6D48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6D4C: 419A01E0  beq cr6, 0x821b6f2c
	if ctx.cr[6].eq {
	pc = 0x821B6F2C; continue 'dispatch;
	}
	// 821B6D50: 40990030  ble cr6, 0x821b6d80
	if !ctx.cr[6].gt {
	pc = 0x821B6D80; continue 'dispatch;
	}
	// 821B6D54: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 821B6D58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B6D5C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821B6D60: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B6D64: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821B6D68: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6D70: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B6D74: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6D78: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B6D7C: 48000034  b 0x821b6db0
	pc = 0x821B6DB0; continue 'dispatch;
            }
            0x821B6D80 => {
    //   block [0x821B6D80..0x821B6DB0)
	// 821B6D80: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 821B6D84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B6D88: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821B6D8C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821B6D90: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B6D94: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821B6D98: 7D76512E  stwx r11, r22, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821B6D9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B6DA0: C0092050  lfs f0, 0x2050(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6DA4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821B6DA8: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6DAC: EFEC683A  fmadds f31, f12, f0, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	pc = 0x821B6DB0; continue 'dispatch;
            }
            0x821B6DB0 => {
    //   block [0x821B6DB0..0x821B6DD8)
	// 821B6DB0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B6DB4: 616BEB12  ori r11, r11, 0xeb12
	ctx.r[11].u64 = ctx.r[11].u64 | 60178;
	// 821B6DB8: 7D7A58AE  lbzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6DC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6DC4: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 821B6DC8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6DCC: 419A000C  beq cr6, 0x821b6dd8
	if ctx.cr[6].eq {
	pc = 0x821B6DD8; continue 'dispatch;
	}
	// 821B6DD0: FFE06890  fmr f31, f13
	ctx.f[31].f64 = ctx.f[13].f64;
	// 821B6DD4: 48000028  b 0x821b6dfc
	pc = 0x821B6DFC; continue 'dispatch;
            }
            0x821B6DD8 => {
    //   block [0x821B6DD8..0x821B6DE8)
	// 821B6DD8: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 821B6DDC: 4098000C  bge cr6, 0x821b6de8
	if !ctx.cr[6].lt {
	pc = 0x821B6DE8; continue 'dispatch;
	}
	// 821B6DE0: FFE06890  fmr f31, f13
	ctx.f[31].f64 = ctx.f[13].f64;
	// 821B6DE4: 48000018  b 0x821b6dfc
	pc = 0x821B6DFC; continue 'dispatch;
            }
            0x821B6DE8 => {
    //   block [0x821B6DE8..0x821B6DFC)
	// 821B6DE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6DEC: C00B207C  lfs f0, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6DF0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B6DF4: 40990008  ble cr6, 0x821b6dfc
	if !ctx.cr[6].gt {
	pc = 0x821B6DFC; continue 'dispatch;
	}
	// 821B6DF8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x821B6DFC; continue 'dispatch;
            }
            0x821B6DFC => {
    //   block [0x821B6DFC..0x821B6E60)
	// 821B6DFC: 39740798  addi r11, r20, 0x798
	ctx.r[11].s64 = ctx.r[20].s64 + 1944;
	// 821B6E00: 7FF6582E  lwzx r31, r22, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6E04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B6E08: 419A0124  beq cr6, 0x821b6f2c
	if ctx.cr[6].eq {
	pc = 0x821B6F2C; continue 'dispatch;
	}
	// 821B6E0C: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 821B6E10: 4099011C  ble cr6, 0x821b6f2c
	if !ctx.cr[6].gt {
	pc = 0x821B6F2C; continue 'dispatch;
	}
	// 821B6E14: 39740788  addi r11, r20, 0x788
	ctx.r[11].s64 = ctx.r[20].s64 + 1928;
	// 821B6E18: 815A0030  lwz r10, 0x30(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B6E1C: 387A0030  addi r3, r26, 0x30
	ctx.r[3].s64 = ctx.r[26].s64 + 48;
	// 821B6E20: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821B6E24: 7D76582E  lwzx r11, r22, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6E28: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B6E2C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821B6E30: 616B8410  ori r11, r11, 0x8410
	ctx.r[11].u64 = ctx.r[11].u64 | 33808;
	// 821B6E34: 7C1A5C2E  lfsx f0, r26, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6E38: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B6E3C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B6E40: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B6E44: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B6E48: 419A0018  beq cr6, 0x821b6e60
	if ctx.cr[6].eq {
	pc = 0x821B6E60; continue 'dispatch;
	}
	// 821B6E4C: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821B6E50: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6E54: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B6E58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B6E5C: 4800001C  b 0x821b6e78
	pc = 0x821B6E78; continue 'dispatch;
            }
            0x821B6E60 => {
    //   block [0x821B6E60..0x821B6E78)
	// 821B6E60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B6E64: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B6E68: C18B2584  lfs f12, 0x2584(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9604 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B6E6C: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821B6E70: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B6E74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821B6E78; continue 'dispatch;
            }
            0x821B6E78 => {
    //   block [0x821B6E78..0x821B6F2C)
	// 821B6E78: 4E800421  bctrl
	ctx.lr = 0x821B6E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B6E7C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            0x821B6F2C => {
    //   block [0x821B6F2C..0x821B7070)
	// 821B6F2C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B6F30: 4BFFD949  bl 0x821b4878
	ctx.lr = 0x821B6F34;
	sub_821B4878(ctx, base);
	// 821B6F34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B6F38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6F3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B6F40: 409A011C  bne cr6, 0x821b705c
	if !ctx.cr[6].eq {
	pc = 0x821B705C; continue 'dispatch;
	}
	// 821B6F44: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B6F48: 614AEB3B  ori r10, r10, 0xeb3b
	ctx.r[10].u64 = ctx.r[10].u64 | 60219;
	// 821B6F4C: 7D5A50AE  lbzx r10, r26, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B6F50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6F54: 419A0020  beq cr6, 0x821b6f74
	if ctx.cr[6].eq {
	pc = 0x821B6F74; continue 'dispatch;
	}
	// 821B6F58: 7D5A78AE  lbzx r10, r26, r15
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 821B6F5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6F60: 419A0014  beq cr6, 0x821b6f74
	if ctx.cr[6].eq {
	pc = 0x821B6F74; continue 'dispatch;
	}
	// 821B6F64: 7D5A90AE  lbzx r10, r26, r18
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821B6F68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6F6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B6F70: 419A0008  beq cr6, 0x821b6f78
	if ctx.cr[6].eq {
	pc = 0x821B6F78; continue 'dispatch;
	}
	// 821B6F74: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 821B6F78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6F7C: 419A0014  beq cr6, 0x821b6f90
	if ctx.cr[6].eq {
	pc = 0x821B6F90; continue 'dispatch;
	}
	// 821B6F80: 7D7A90AE  lbzx r11, r26, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 821B6F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6F88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B6F8C: 409A0008  bne cr6, 0x821b6f94
	if !ctx.cr[6].eq {
	pc = 0x821B6F94; continue 'dispatch;
	}
	// 821B6F90: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821B6F94: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821B6F98: C0140820  lfs f0, 0x820(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(2080 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B6F9C: 61299B84  ori r9, r9, 0x9b84
	ctx.r[9].u64 = ctx.r[9].u64 | 39812;
	// 821B6FA0: 7DBA4C2E  lfsx f13, r26, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B6FA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B6FA8: 40980014  bge cr6, 0x821b6fbc
	if !ctx.cr[6].lt {
	pc = 0x821B6FBC; continue 'dispatch;
	}
	// 821B6FAC: 7D3A80AE  lbzx r9, r26, r16
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 821B6FB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B6FB4: 409A0008  bne cr6, 0x821b6fbc
	if !ctx.cr[6].eq {
	pc = 0x821B6FBC; continue 'dispatch;
	}
	// 821B6FB8: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821B6FBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B6FC0: 409A000C  bne cr6, 0x821b6fcc
	if !ctx.cr[6].eq {
	pc = 0x821B6FCC; continue 'dispatch;
	}
	// 821B6FC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B6FC8: 419A0094  beq cr6, 0x821b705c
	if ctx.cr[6].eq {
	pc = 0x821B705C; continue 'dispatch;
	}
	// 821B6FCC: 39740798  addi r11, r20, 0x798
	ctx.r[11].s64 = ctx.r[20].s64 + 1944;
	// 821B6FD0: 7D76582E  lwzx r11, r22, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B6FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B6FD8: 419A0084  beq cr6, 0x821b705c
	if ctx.cr[6].eq {
	pc = 0x821B705C; continue 'dispatch;
	}
	// 821B6FDC: 394B0030  addi r10, r11, 0x30
	ctx.r[10].s64 = ctx.r[11].s64 + 48;
	// 821B6FE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B6FE4: 419A0078  beq cr6, 0x821b705c
	if ctx.cr[6].eq {
	pc = 0x821B705C; continue 'dispatch;
	}
	// 821B6FE8: 393407C0  addi r9, r20, 0x7c0
	ctx.r[9].s64 = ctx.r[20].s64 + 1984;
	// 821B6FEC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B6FF0: 7D36482E  lwzx r9, r22, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B6FF4: 2F09003B  cmpwi cr6, r9, 0x3b
	ctx.cr[6].compare_i32(ctx.r[9].s32, 59, &mut ctx.xer);
	// 821B6FF8: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B6FFC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821B7000: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B7004: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B7008: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B700C: 409A0010  bne cr6, 0x821b701c
	if !ctx.cr[6].eq {
	pc = 0x821B701C; continue 'dispatch;
	}
	// 821B7010: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7014: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7018: 4800000C  b 0x821b7024
	pc = 0x821B7024; continue 'dispatch;
	// 821B701C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7020: C00B3274  lfs f0, 0x3274(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7024: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7028: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821B702C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7030: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821B7034: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7038: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821B703C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7040: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B7044: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7048: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821B704C: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7050: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7054: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821B7058: 4BFFD271  bl 0x821b42c8
	ctx.lr = 0x821B705C;
	sub_821B42C8(ctx, base);
	// 821B705C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B7060: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821B7064: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 821B7068: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B706C: 4837E064  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x821B7070 => {
    //   block [0x821B7070..0x821B7084)
	// 821B7070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7074: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821B7078: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 821B707C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 821B7080: 4837E050  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7088 size=380
    let mut pc: u32 = 0x821B7088;
    'dispatch: loop {
        match pc {
            0x821B7088 => {
    //   block [0x821B7088..0x821B70D4)
	// 821B7088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B708C: 4837E029  bl 0x825350b4
	ctx.lr = 0x821B7090;
	sub_82535080(ctx, base);
	// 821B7090: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7094: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7098: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B709C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B70A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B70A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B70A8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B70AC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821B70B0: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B70B4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B70B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B70BC: 40990018  ble cr6, 0x821b70d4
	if !ctx.cr[6].gt {
	pc = 0x821B70D4; continue 'dispatch;
	}
	// 821B70C0: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B70C4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B70C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B70CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B70D0: 41990008  bgt cr6, 0x821b70d8
	if ctx.cr[6].gt {
	pc = 0x821B70D8; continue 'dispatch;
	}
	pc = 0x821B70D4; continue 'dispatch;
            }
            0x821B70D4 => {
    //   block [0x821B70D4..0x821B70D8)
	// 821B70D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B70D8; continue 'dispatch;
            }
            0x821B70D8 => {
    //   block [0x821B70D8..0x821B7130)
	// 821B70D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B70DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B70E0: 419A00C4  beq cr6, 0x821b71a4
	if ctx.cr[6].eq {
	pc = 0x821B71A4; continue 'dispatch;
	}
	// 821B70E4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B70E8: 616BEB1C  ori r11, r11, 0xeb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 60188;
	// 821B70EC: 7D5E58AE  lbzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B70F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B70F4: 409A008C  bne cr6, 0x821b7180
	if !ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B70F8: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B70FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7100: 409A0080  bne cr6, 0x821b7180
	if !ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7104: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B7108: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821B710C: 6168EB03  ori r8, r11, 0xeb03
	ctx.r[8].u64 = ctx.r[11].u64 | 60163;
	// 821B7110: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7118: 392BCF90  addi r9, r11, -0x3070
	ctx.r[9].s64 = ctx.r[11].s64 + -12400;
	// 821B711C: 419A0064  beq cr6, 0x821b7180
	if ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7120: 7D7D40AE  lbzx r11, r29, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B7124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7128: 419A0024  beq cr6, 0x821b714c
	if ctx.cr[6].eq {
	pc = 0x821B714C; continue 'dispatch;
	}
	// 821B712C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7130; continue 'dispatch;
            }
            0x821B7130 => {
    //   block [0x821B7130..0x821B714C)
	// 821B7130: 38E906D3  addi r7, r9, 0x6d3
	ctx.r[7].s64 = ctx.r[9].s64 + 1747;
	// 821B7134: 7CEB38AE  lbzx r7, r11, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821B7138: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B713C: 409A0070  bne cr6, 0x821b71ac
	if !ctx.cr[6].eq {
	pc = 0x821B71AC; continue 'dispatch;
	}
	// 821B7140: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7144: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 821B7148: 4198FFE8  blt cr6, 0x821b7130
	if ctx.cr[6].lt {
	pc = 0x821B7130; continue 'dispatch;
	}
	pc = 0x821B714C; continue 'dispatch;
            }
            0x821B714C => {
    //   block [0x821B714C..0x821B7164)
	// 821B714C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7150: 419A0030  beq cr6, 0x821b7180
	if ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7154: 7D7E40AE  lbzx r11, r30, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B7158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B715C: 419A0024  beq cr6, 0x821b7180
	if ctx.cr[6].eq {
	pc = 0x821B7180; continue 'dispatch;
	}
	// 821B7160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7164; continue 'dispatch;
            }
            0x821B7164 => {
    //   block [0x821B7164..0x821B7180)
	// 821B7164: 394906A2  addi r10, r9, 0x6a2
	ctx.r[10].s64 = ctx.r[9].s64 + 1698;
	// 821B7168: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B716C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7170: 409A0068  bne cr6, 0x821b71d8
	if !ctx.cr[6].eq {
	pc = 0x821B71D8; continue 'dispatch;
	}
	// 821B7174: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7178: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 821B717C: 4198FFE8  blt cr6, 0x821b7164
	if ctx.cr[6].lt {
	pc = 0x821B7164; continue 'dispatch;
	}
	pc = 0x821B7180; continue 'dispatch;
            }
            0x821B7180 => {
    //   block [0x821B7180..0x821B71A4)
	// 821B7180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B7184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B7188: 4BFFF6E9  bl 0x821b6870
	ctx.lr = 0x821B718C;
	sub_821B6870(ctx, base);
	// 821B718C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B7190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B7194: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B7198: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B719C: 4BFFF6D5  bl 0x821b6870
	ctx.lr = 0x821B71A0;
	sub_821B6870(ctx, base);
	// 821B71A0: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821B71A4; continue 'dispatch;
            }
            0x821B71A4 => {
    //   block [0x821B71A4..0x821B71AC)
	// 821B71A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B71A8: 4837DF5C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821B71AC => {
    //   block [0x821B71AC..0x821B71D8)
	// 821B71AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B71B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B71B4: 4BFFF6BD  bl 0x821b6870
	ctx.lr = 0x821B71B8;
	sub_821B6870(ctx, base);
	// 821B71B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B71BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B71C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B71C4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B71C8: 4BFFF6A9  bl 0x821b6870
	ctx.lr = 0x821B71CC;
	sub_821B6870(ctx, base);
	// 821B71CC: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B71D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B71D4: 4837DF30  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x821B71D8 => {
    //   block [0x821B71D8..0x821B7204)
	// 821B71D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B71DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B71E0: 4BFFF691  bl 0x821b6870
	ctx.lr = 0x821B71E4;
	sub_821B6870(ctx, base);
	// 821B71E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B71E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B71EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B71F0: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B71F4: 4BFFF67D  bl 0x821b6870
	ctx.lr = 0x821B71F8;
	sub_821B6870(ctx, base);
	// 821B71F8: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821B71FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B7200: 4837DF04  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7208 size=176
    let mut pc: u32 = 0x821B7208;
    'dispatch: loop {
        match pc {
            0x821B7208 => {
    //   block [0x821B7208..0x821B728C)
	// 821B7208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B720C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B7214: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7218: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821B721C: 3FE00003  lis r31, 3
	ctx.r[31].s64 = 196608;
	// 821B7220: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821B7224: 63FF9450  ori r31, r31, 0x9450
	ctx.r[31].u64 = ctx.r[31].u64 | 37968;
	// 821B7228: 7D6BFA2E  lhzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821B722C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821B7230: 409A0074  bne cr6, 0x821b72a4
	if !ctx.cr[6].eq {
	pc = 0x821B72A4; continue 'dispatch;
	}
	// 821B7234: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B7238: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821B723C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821B7240: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821B7244: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 821B7248: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821B724C: 409A0040  bne cr6, 0x821b728c
	if !ctx.cr[6].eq {
	pc = 0x821B728C; continue 'dispatch;
	}
	// 821B7250: E8A70000  ld r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B7254: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821B7258: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 821B725C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821B7260: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821B7264: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821B7268: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821B726C: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821B7270: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821B7274: F8AB0000  std r5, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 821B7278: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 821B727C: F88A0000  std r4, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 821B7280: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 821B7284: F8660000  std r3, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821B7288: F9260008  std r9, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	pc = 0x821B728C; continue 'dispatch;
            }
            0x821B728C => {
    //   block [0x821B728C..0x821B72A4)
	// 821B728C: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 821B7290: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 821B7294: 386B45D8  addi r3, r11, 0x45d8
	ctx.r[3].s64 = ctx.r[11].s64 + 17880;
	// 821B7298: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B729C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 821B72A0: 4BFC5779  bl 0x8217ca18
	ctx.lr = 0x821B72A4;
	sub_8217CA18(ctx, base);
	pc = 0x821B72A4; continue 'dispatch;
            }
            0x821B72A4 => {
    //   block [0x821B72A4..0x821B72B8)
	// 821B72A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B72A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B72AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B72B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B72B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B72B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B72B8 size=380
    let mut pc: u32 = 0x821B72B8;
    'dispatch: loop {
        match pc {
            0x821B72B8 => {
    //   block [0x821B72B8..0x821B7300)
	// 821B72B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B72BC: 4837DDFD  bl 0x825350b8
	ctx.lr = 0x821B72C0;
	sub_82535080(ctx, base);
	// 821B72C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B72C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B72C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B72CC: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B72D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B72D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821B72D8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821B72DC: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B72E0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B72E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B72E8: 40990018  ble cr6, 0x821b7300
	if !ctx.cr[6].gt {
	pc = 0x821B7300; continue 'dispatch;
	}
	// 821B72EC: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B72F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B72F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B72F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B72FC: 41990008  bgt cr6, 0x821b7304
	if ctx.cr[6].gt {
	pc = 0x821B7304; continue 'dispatch;
	}
	pc = 0x821B7300; continue 'dispatch;
            }
            0x821B7300 => {
    //   block [0x821B7300..0x821B7304)
	// 821B7300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7304; continue 'dispatch;
            }
            0x821B7304 => {
    //   block [0x821B7304..0x821B7310)
	// 821B7304: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B730C: 409A0010  bne cr6, 0x821b731c
	if !ctx.cr[6].eq {
	pc = 0x821B731C; continue 'dispatch;
	}
	pc = 0x821B7310; continue 'dispatch;
            }
            0x821B7310 => {
    //   block [0x821B7310..0x821B731C)
	// 821B7310: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7314: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B7318: 4837DDF0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821B731C => {
    //   block [0x821B731C..0x821B7434)
	// 821B731C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7320: 3920003C  li r9, 0x3c
	ctx.r[9].s64 = 60;
	// 821B7324: 3900003A  li r8, 0x3a
	ctx.r[8].s64 = 58;
	// 821B7328: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B732C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B7330: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B7334: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821B733C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821B7340: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821B7344: 4BFFDC85  bl 0x821b4fc8
	ctx.lr = 0x821B7348;
	sub_821B4FC8(ctx, base);
	// 821B7348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B734C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7350: 419AFFC0  beq cr6, 0x821b7310
	if ctx.cr[6].eq {
	pc = 0x821B7310; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7438 size=140
    let mut pc: u32 = 0x821B7438;
    'dispatch: loop {
        match pc {
            0x821B7438 => {
    //   block [0x821B7438..0x821B7470)
	// 821B7438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B743C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7440: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7444: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B7448: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821B744C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7450: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7458: 4E800421  bctrl
	ctx.lr = 0x821B745C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B745C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7460: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7464: C18B2194  lfs f12, 0x2194(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8596 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7468: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821B746C: 4098001C  bge cr6, 0x821b7488
	if !ctx.cr[6].lt {
	pc = 0x821B7488; continue 'dispatch;
	}
            }
            0x821B7470 => {
    //   block [0x821B7470..0x821B7488)
	// 821B7470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7474: C02B2190  lfs f1, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B7478: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B747C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7484: 4E800020  blr
	return;
            }
            0x821B7488 => {
    //   block [0x821B7488..0x821B74C4)
	// 821B7488: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B748C: C1ABBA44  lfs f13, -0x45bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7490: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7494: 4199FFDC  bgt cr6, 0x821b7470
	if ctx.cr[6].gt {
	pc = 0x821B7470; continue 'dispatch;
	}
	// 821B7498: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B749C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821B74A0: 4198FFD0  blt cr6, 0x821b7470
	if ctx.cr[6].lt {
	pc = 0x821B7470; continue 'dispatch;
	}
	// 821B74A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B74A8: 4199FFC8  bgt cr6, 0x821b7470
	if ctx.cr[6].gt {
	pc = 0x821B7470; continue 'dispatch;
	}
	// 821B74AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B74B0: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B74B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B74B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B74BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B74C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B74C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B74C8 size=104
    let mut pc: u32 = 0x821B74C8;
    'dispatch: loop {
        match pc {
            0x821B74C8 => {
    //   block [0x821B74C8..0x821B74F8)
	// 821B74C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B74CC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821B74D0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B74D4: 394BBA44  addi r10, r11, -0x45bc
	ctx.r[10].s64 = ctx.r[11].s64 + -17852;
	// 821B74D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B74DC: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B74E0: 419A0018  beq cr6, 0x821b74f8
	if ctx.cr[6].eq {
	pc = 0x821B74F8; continue 'dispatch;
	}
	// 821B74E4: C1AAFFF4  lfs f13, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B74E8: D0250000  stfs f1, 0(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B74EC: D1A50004  stfs f13, 4(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B74F0: D0250008  stfs f1, 8(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B74F4: D025000C  stfs f1, 0xc(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B74F8; continue 'dispatch;
            }
            0x821B74F8 => {
    //   block [0x821B74F8..0x821B7524)
	// 821B74F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B74FC: C18B2194  lfs f12, 0x2194(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8596 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7500: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821B7504: 41980020  blt cr6, 0x821b7524
	if ctx.cr[6].lt {
	pc = 0x821B7524; continue 'dispatch;
	}
	// 821B7508: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B750C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7510: 41990014  bgt cr6, 0x821b7524
	if ctx.cr[6].gt {
	pc = 0x821B7524; continue 'dispatch;
	}
	// 821B7514: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 821B7518: 4198000C  blt cr6, 0x821b7524
	if ctx.cr[6].lt {
	pc = 0x821B7524; continue 'dispatch;
	}
	// 821B751C: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 821B7520: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x821B7524; continue 'dispatch;
            }
            0x821B7524 => {
    //   block [0x821B7524..0x821B7530)
	// 821B7524: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7528: C02B2190  lfs f1, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B752C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7530 size=100
    let mut pc: u32 = 0x821B7530;
    'dispatch: loop {
        match pc {
            0x821B7530 => {
    //   block [0x821B7530..0x821B7560)
	// 821B7530: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7534: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 821B7538: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B753C: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B7540: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B7544: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7548: 40990018  ble cr6, 0x821b7560
	if !ctx.cr[6].gt {
	pc = 0x821B7560; continue 'dispatch;
	}
	// 821B754C: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7550: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B7554: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7558: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B755C: 41990008  bgt cr6, 0x821b7564
	if ctx.cr[6].gt {
	pc = 0x821B7564; continue 'dispatch;
	}
	pc = 0x821B7560; continue 'dispatch;
            }
            0x821B7560 => {
    //   block [0x821B7560..0x821B7564)
	// 821B7560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7564; continue 'dispatch;
            }
            0x821B7564 => {
    //   block [0x821B7564..0x821B7594)
	// 821B7564: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B756C: 409A0054  bne cr6, 0x821b75c0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821B75C0);
		return;
	}
	// 821B7570: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7574: C1AB2194  lfs f13, 0x2194(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8596 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B757C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 821B7580: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B7584: 40980010  bge cr6, 0x821b7594
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x821B7594);
		return;
	}
	// 821B7588: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B758C: C02B2190  lfs f1, 0x2190(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B7590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B75D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B75D0 size=244
    let mut pc: u32 = 0x821B75D0;
    'dispatch: loop {
        match pc {
            0x821B75D0 => {
    //   block [0x821B75D0..0x821B7618)
	// 821B75D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B75D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B75D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B75DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B75E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B75E4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B75E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B75EC: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B75F0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821B75F4: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B75F8: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B75FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7600: 40990018  ble cr6, 0x821b7618
	if !ctx.cr[6].gt {
	pc = 0x821B7618; continue 'dispatch;
	}
	// 821B7604: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7608: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B760C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7614: 41990008  bgt cr6, 0x821b761c
	if ctx.cr[6].gt {
	pc = 0x821B761C; continue 'dispatch;
	}
	pc = 0x821B7618; continue 'dispatch;
            }
            0x821B7618 => {
    //   block [0x821B7618..0x821B761C)
	// 821B7618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B761C; continue 'dispatch;
            }
            0x821B761C => {
    //   block [0x821B761C..0x821B7634)
	// 821B761C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7624: 409A0010  bne cr6, 0x821b7634
	if !ctx.cr[6].eq {
	pc = 0x821B7634; continue 'dispatch;
	}
	// 821B7628: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B762C: 4BFFFE9D  bl 0x821b74c8
	ctx.lr = 0x821B7630;
	sub_821B74C8(ctx, base);
	// 821B7630: 4800007C  b 0x821b76ac
	pc = 0x821B76AC; continue 'dispatch;
            }
            0x821B7634 => {
    //   block [0x821B7634..0x821B7670)
	// 821B7634: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7638: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 821B763C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B7640: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B7644: 4BFFFEED  bl 0x821b7530
	ctx.lr = 0x821B7648;
	sub_821B7530(ctx, base);
	// 821B7648: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B764C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7650: 419A005C  beq cr6, 0x821b76ac
	if ctx.cr[6].eq {
	pc = 0x821B76AC; continue 'dispatch;
	}
	// 821B7654: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B7658: 419A0018  beq cr6, 0x821b7670
	if ctx.cr[6].eq {
	pc = 0x821B7670; continue 'dispatch;
	}
	// 821B765C: 396A0030  addi r11, r10, 0x30
	ctx.r[11].s64 = ctx.r[10].s64 + 48;
	// 821B7660: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B7664: F93F0000  std r9, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B7668: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B766C: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821B7670; continue 'dispatch;
            }
            0x821B7670 => {
    //   block [0x821B7670..0x821B769C)
	// 821B7670: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821B7674: 419A0038  beq cr6, 0x821b76ac
	if ctx.cr[6].eq {
	pc = 0x821B76AC; continue 'dispatch;
	}
	// 821B7678: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B767C: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7680: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B7684: 419A0020  beq cr6, 0x821b76a4
	if ctx.cr[6].eq {
	pc = 0x821B76A4; continue 'dispatch;
	}
	// 821B7688: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821B768C: 419A0010  beq cr6, 0x821b769c
	if ctx.cr[6].eq {
	pc = 0x821B769C; continue 'dispatch;
	}
	// 821B7690: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7694: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B7698: 48000010  b 0x821b76a8
	pc = 0x821B76A8; continue 'dispatch;
            }
            0x821B769C => {
    //   block [0x821B769C..0x821B76A4)
	// 821B769C: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 821B76A0: 48000008  b 0x821b76a8
	pc = 0x821B76A8; continue 'dispatch;
            }
            0x821B76A4 => {
    //   block [0x821B76A4..0x821B76A8)
	// 821B76A4: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	pc = 0x821B76A8; continue 'dispatch;
            }
            0x821B76A8 => {
    //   block [0x821B76A8..0x821B76AC)
	// 821B76A8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821B76AC; continue 'dispatch;
            }
            0x821B76AC => {
    //   block [0x821B76AC..0x821B76C4)
	// 821B76AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B76B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B76B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B76B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B76BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B76C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B76C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B76C8 size=148
    let mut pc: u32 = 0x821B76C8;
    'dispatch: loop {
        match pc {
            0x821B76C8 => {
    //   block [0x821B76C8..0x821B7700)
	// 821B76C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B76CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B76D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B76D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B76D8: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B76DC: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B76E0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B76E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B76E8: 40990018  ble cr6, 0x821b7700
	if !ctx.cr[6].gt {
	pc = 0x821B7700; continue 'dispatch;
	}
	// 821B76EC: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B76F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B76F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B76F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B76FC: 41990008  bgt cr6, 0x821b7704
	if ctx.cr[6].gt {
	pc = 0x821B7704; continue 'dispatch;
	}
	pc = 0x821B7700; continue 'dispatch;
            }
            0x821B7700 => {
    //   block [0x821B7700..0x821B7704)
	// 821B7700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7704; continue 'dispatch;
            }
            0x821B7704 => {
    //   block [0x821B7704..0x821B7728)
	// 821B7704: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B770C: 409A001C  bne cr6, 0x821b7728
	if !ctx.cr[6].eq {
	pc = 0x821B7728; continue 'dispatch;
	}
	// 821B7710: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B7714: 4BFFFD25  bl 0x821b7438
	ctx.lr = 0x821B7718;
	sub_821B7438(ctx, base);
	// 821B7718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B771C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7724: 4E800020  blr
	return;
            }
            0x821B7728 => {
    //   block [0x821B7728..0x821B775C)
	// 821B7728: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821B772C: 4800029D  bl 0x821b79c8
	ctx.lr = 0x821B7730;
	sub_821B79C8(ctx, base);
	// 821B7730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7734: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B7738: C0410068  lfs f2, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B773C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B7740: C0210060  lfs f1, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B7744: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B7748: 4BFFFDE9  bl 0x821b7530
	ctx.lr = 0x821B774C;
	sub_821B7530(ctx, base);
	// 821B774C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B7750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7760 size=252
    let mut pc: u32 = 0x821B7760;
    'dispatch: loop {
        match pc {
            0x821B7760 => {
    //   block [0x821B7760..0x821B7798)
	// 821B7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7768: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B776C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7770: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B7774: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B7778: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B777C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7780: 40990018  ble cr6, 0x821b7798
	if !ctx.cr[6].gt {
	pc = 0x821B7798; continue 'dispatch;
	}
	// 821B7784: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7788: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B778C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7790: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7794: 41990008  bgt cr6, 0x821b779c
	if ctx.cr[6].gt {
	pc = 0x821B779C; continue 'dispatch;
	}
	pc = 0x821B7798; continue 'dispatch;
            }
            0x821B7798 => {
    //   block [0x821B7798..0x821B779C)
	// 821B7798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B779C; continue 'dispatch;
            }
            0x821B779C => {
    //   block [0x821B779C..0x821B77BC)
	// 821B779C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B77A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B77A4: 409A0018  bne cr6, 0x821b77bc
	if !ctx.cr[6].eq {
	pc = 0x821B77BC; continue 'dispatch;
	}
	// 821B77A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B77AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B77B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B77B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B77B8: 4E800020  blr
	return;
            }
            0x821B77BC => {
    //   block [0x821B77BC..0x821B7820)
	// 821B77BC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B77C0: C0430008  lfs f2, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821B77C4: C0230000  lfs f1, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B77C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821B77CC: 396BCD68  addi r11, r11, -0x3298
	ctx.r[11].s64 = ctx.r[11].s64 + -12952;
	// 821B77D0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821B77D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821B77D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B77DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B77E0: 48001031  bl 0x821b8810
	ctx.lr = 0x821B77E4;
	sub_821B8810(ctx, base);
	// 821B77E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B77E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B77EC: 419A005C  beq cr6, 0x821b7848
	if ctx.cr[6].eq {
	pc = 0x821B7848; continue 'dispatch;
	}
	// 821B77F0: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B77F4: 554AC73E  rlwinm r10, r10, 0x18, 0x1c, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B77F8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821B77FC: 419A0038  beq cr6, 0x821b7834
	if ctx.cr[6].eq {
	pc = 0x821B7834; continue 'dispatch;
	}
	// 821B7800: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821B7804: 419A001C  beq cr6, 0x821b7820
	if ctx.cr[6].eq {
	pc = 0x821B7820; continue 'dispatch;
	}
	// 821B7808: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B780C: 5563E63E  rlwinm r3, r11, 0x1c, 0x18, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821B7810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B781C: 4E800020  blr
	return;
            }
            0x821B7820 => {
    //   block [0x821B7820..0x821B7834)
	// 821B7820: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 821B7824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B782C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7830: 4E800020  blr
	return;
            }
            0x821B7834 => {
    //   block [0x821B7834..0x821B7848)
	// 821B7834: 3860003A  li r3, 0x3a
	ctx.r[3].s64 = 58;
	// 821B7838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B783C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7844: 4E800020  blr
	return;
            }
            0x821B7848 => {
    //   block [0x821B7848..0x821B785C)
	// 821B7848: 3860003F  li r3, 0x3f
	ctx.r[3].s64 = 63;
	// 821B784C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7860 size=164
    let mut pc: u32 = 0x821B7860;
    'dispatch: loop {
        match pc {
            0x821B7860 => {
    //   block [0x821B7860..0x821B78C8)
	// 821B7860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B786C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7870: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 821B7874: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B7878: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B787C: 4BFFFCB5  bl 0x821b7530
	ctx.lr = 0x821B7880;
	sub_821B7530(ctx, base);
	// 821B7880: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7884: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7888: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821B788C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7890: 419A0038  beq cr6, 0x821b78c8
	if ctx.cr[6].eq {
	pc = 0x821B78C8; continue 'dispatch;
	}
	// 821B7894: A16B001C  lhz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B7898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B789C: 419A002C  beq cr6, 0x821b78c8
	if ctx.cr[6].eq {
	pc = 0x821B78C8; continue 'dispatch;
	}
	// 821B78A0: 556A181A  rlwinm r10, r11, 3, 0, 0xd
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B78A4: 556905BE  clrlwi r9, r11, 0x16
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B78A8: 556BB6FE  rlwinm r11, r11, 0x16, 0x1b, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 821B78AC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821B78B0: 396B0070  addi r11, r11, 0x70
	ctx.r[11].s64 = ctx.r[11].s64 + 112;
	// 821B78B4: 554A6824  slwi r10, r10, 0xd
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(13);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B78B8: 556BB850  rlwinm r11, r11, 0x17, 1, 8
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 821B78BC: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821B78C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821B78C4: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821B78C8; continue 'dispatch;
            }
            0x821B78C8 => {
    //   block [0x821B78C8..0x821B7904)
	// 821B78C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B78CC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B78D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B78D4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B78D8: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 821B78DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B78E0: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 821B78E4: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 821B78E8: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 821B78EC: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 821B78F0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821B78F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B78F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B78FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7908 size=72
    let mut pc: u32 = 0x821B7908;
    'dispatch: loop {
        match pc {
            0x821B7908 => {
    //   block [0x821B7908..0x821B7934)
	// 821B7908: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B790C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821B7910: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821B7914: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821B7918: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B791C: 40990018  ble cr6, 0x821b7934
	if !ctx.cr[6].gt {
	pc = 0x821B7934; continue 'dispatch;
	}
	// 821B7920: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821B7924: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821B7928: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B792C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7930: 41990008  bgt cr6, 0x821b7938
	if ctx.cr[6].gt {
	pc = 0x821B7938; continue 'dispatch;
	}
	pc = 0x821B7934; continue 'dispatch;
            }
            0x821B7934 => {
    //   block [0x821B7934..0x821B7938)
	// 821B7934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7938; continue 'dispatch;
            }
            0x821B7938 => {
    //   block [0x821B7938..0x821B7950)
	// 821B7938: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B793C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7940: 409A0010  bne cr6, 0x821b7950
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821B7950);
		return;
	}
	// 821B7944: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7948: C02B2190  lfs f1, 0x2190(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821B794C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7960 size=48
    let mut pc: u32 = 0x821B7960;
    'dispatch: loop {
        match pc {
            0x821B7960 => {
    //   block [0x821B7960..0x821B7990)
	// 821B7960: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821B7964: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821B7968: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B796C: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 821B7970: 7D4350AE  lbzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821B7974: 396B0798  addi r11, r11, 0x798
	ctx.r[11].s64 = ctx.r[11].s64 + 1944;
	// 821B7978: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821B797C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821B7980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7984: 409A000C  bne cr6, 0x821b7990
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821B7990);
		return;
	}
	// 821B7988: 3860003F  li r3, 0x3f
	ctx.r[3].s64 = 63;
	// 821B798C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B79C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B79C8 size=648
    let mut pc: u32 = 0x821B79C8;
    'dispatch: loop {
        match pc {
            0x821B79C8 => {
    //   block [0x821B79C8..0x821B7A80)
	// 821B79C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B79CC: 4837D6F1  bl 0x825350bc
	ctx.lr = 0x821B79D0;
	sub_82535080(ctx, base);
	// 821B79D0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 821B79D4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821B79D8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821B79DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B79E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B79E4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B79E8: 2F0400A6  cmpwi cr6, r4, 0xa6
	ctx.cr[6].compare_i32(ctx.r[4].s32, 166, &mut ctx.xer);
	// 821B79EC: 409A0094  bne cr6, 0x821b7a80
	if !ctx.cr[6].eq {
	pc = 0x821B7A80; continue 'dispatch;
	}
	// 821B79F0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B79F4: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 821B79F8: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 821B79FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B7A00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7A08: 4E800421  bctrl
	ctx.lr = 0x821B7A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7A0C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7A10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B7A14: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 821B7A18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821B7A1C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7A20: C3EB0030  lfs f31, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B7A24: C3CB0034  lfs f30, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821B7A28: C3AB0038  lfs f29, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821B7A2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B7A30: 4E800421  bctrl
	ctx.lr = 0x821B7A34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7A34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7A38: C181005C  lfs f12, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7A3C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7A40: C1630038  lfs f11, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B7A44: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7A48: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A4C: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A50: ED3E0032  fmuls f9, f30, f0
	ctx.f[9].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A54: ED1D0032  fmuls f8, f29, f0
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7A58: ECED603A  fmadds f7, f13, f0, f12
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B7A5C: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7A60: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7A64: EDAD503A  fmadds f13, f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821B7A68: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7A6C: EDAC483A  fmadds f13, f12, f0, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B7A70: D0FF000C  stfs f7, 0xc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B7A74: EC0B403A  fmadds f0, f11, f0, f8
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821B7A78: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7A7C: 48000040  b 0x821b7abc
	pc = 0x821B7ABC; continue 'dispatch;
            }
            0x821B7A80 => {
    //   block [0x821B7A80..0x821B7A90)
	// 821B7A80: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821B7A84: 4198000C  blt cr6, 0x821b7a90
	if ctx.cr[6].lt {
	pc = 0x821B7A90; continue 'dispatch;
	}
	// 821B7A88: 2F040031  cmpwi cr6, r4, 0x31
	ctx.cr[6].compare_i32(ctx.r[4].s32, 49, &mut ctx.xer);
	// 821B7A8C: 40990048  ble cr6, 0x821b7ad4
	if !ctx.cr[6].gt {
	pc = 0x821B7AD4; continue 'dispatch;
	}
	pc = 0x821B7A90; continue 'dispatch;
            }
            0x821B7A90 => {
    //   block [0x821B7A90..0x821B7ABC)
	// 821B7A90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7A94: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7A98: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B7A9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7AA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7AA4: 4E800421  bctrl
	ctx.lr = 0x821B7AA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7AA8: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7AAC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7AB0: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7AB4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7AB8: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            0x821B7ABC => {
    //   block [0x821B7ABC..0x821B7AD4)
	// 821B7ABC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7AC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7AC4: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821B7AC8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821B7ACC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821B7AD0: 4837D63C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821B7AD4 => {
    //   block [0x821B7AD4..0x821B7B80)
	// 821B7AD4: 2F04002D  cmpwi cr6, r4, 0x2d
	ctx.cr[6].compare_i32(ctx.r[4].s32, 45, &mut ctx.xer);
	// 821B7AD8: 419800A8  blt cr6, 0x821b7b80
	if ctx.cr[6].lt {
	pc = 0x821B7B80; continue 'dispatch;
	}
	// 821B7ADC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821B7AE0: 3964FFD3  addi r11, r4, -0x2d
	ctx.r[11].s64 = ctx.r[4].s64 + -45;
	// 821B7AE4: 6149BE64  ori r9, r10, 0xbe64
	ctx.r[9].u64 = ctx.r[10].u64 | 48740;
	// 821B7AE8: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B7AEC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821B7AF0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821B7AF4: 394AFA00  addi r10, r10, -0x600
	ctx.r[10].s64 = ctx.r[10].s64 + -1536;
	// 821B7AF8: 7D3E48AE  lbzx r9, r30, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B7AFC: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B7B00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7B04: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821B7B08: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B7B0C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B7B10: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B7B14: F95F0000  std r10, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821B7B18: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821B7B1C: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821B7B20: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7B24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7B28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7B2C: 4E800421  bctrl
	ctx.lr = 0x821B7B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7B30: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            0x821B7B80 => {
    //   block [0x821B7B80..0x821B7C50)
	// 821B7B80: 2F040020  cmpwi cr6, r4, 0x20
	ctx.cr[6].compare_i32(ctx.r[4].s32, 32, &mut ctx.xer);
	// 821B7B84: 4198FF10  blt cr6, 0x821b7a94
	if ctx.cr[6].lt {
	pc = 0x821B7A94; continue 'dispatch;
	}
	// 821B7B88: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821B7B8C: 3944FFE0  addi r10, r4, -0x20
	ctx.r[10].s64 = ctx.r[4].s64 + -32;
	// 821B7B90: 396BCFF0  addi r11, r11, -0x3010
	ctx.r[11].s64 = ctx.r[11].s64 + -12304;
	// 821B7B94: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B7B98: 392B0014  addi r9, r11, 0x14
	ctx.r[9].s64 = ctx.r[11].s64 + 20;
	// 821B7B9C: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 821B7BA0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B7BA4: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821B7BA8: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821B7BAC: 3D290001  addis r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 65536;
	// 821B7BB0: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7BB4: 39296104  addi r9, r9, 0x6104
	ctx.r[9].s64 = ctx.r[9].s64 + 24836;
	// 821B7BB8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B7BBC: 7C09F42E  lfsx f0, r9, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7BC0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7BC4: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7BC8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7BCC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7BD0: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7BD4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7BD8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7BDC: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7BE0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7BE4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7BE8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B7BEC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B7BF0: 7C8A402E  lwzx r4, r10, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821B7BF4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7BF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821B7BFC: 4E800421  bctrl
	ctx.lr = 0x821B7C00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7C00: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7C50 size=224
    let mut pc: u32 = 0x821B7C50;
    'dispatch: loop {
        match pc {
            0x821B7C50 => {
    //   block [0x821B7C50..0x821B7C78)
	// 821B7C50: A1430004  lhz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7C54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821B7C58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7C5C: 419A0038  beq cr6, 0x821b7c94
	if ctx.cr[6].eq {
	pc = 0x821B7C94; continue 'dispatch;
	}
	// 821B7C60: 39030018  addi r8, r3, 0x18
	ctx.r[8].s64 = ctx.r[3].s64 + 24;
	// 821B7C64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B7C68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B7C6C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B7C70: 40990024  ble cr6, 0x821b7c94
	if !ctx.cr[6].gt {
	pc = 0x821B7C94; continue 'dispatch;
	}
	// 821B7C74: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x821B7C78; continue 'dispatch;
            }
            0x821B7C78 => {
    //   block [0x821B7C78..0x821B7C94)
	// 821B7C78: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7C80: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 821B7C84: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B7C88: A1030004  lhz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7C8C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B7C90: 4198FFE8  blt cr6, 0x821b7c78
	if ctx.cr[6].lt {
	pc = 0x821B7C78; continue 'dispatch;
	}
	pc = 0x821B7C94; continue 'dispatch;
            }
            0x821B7C94 => {
    //   block [0x821B7C94..0x821B7CC4)
	// 821B7C94: A0E3000C  lhz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7C98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B7C9C: 419A0044  beq cr6, 0x821b7ce0
	if ctx.cr[6].eq {
	pc = 0x821B7CE0; continue 'dispatch;
	}
	// 821B7CA0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7CA4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B7CA8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7CAC: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B7CB0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B7CB4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B7CB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821B7CBC: 40990024  ble cr6, 0x821b7ce0
	if !ctx.cr[6].gt {
	pc = 0x821B7CE0; continue 'dispatch;
	}
	// 821B7CC0: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x821B7CC4; continue 'dispatch;
            }
            0x821B7CC4 => {
    //   block [0x821B7CC4..0x821B7CE0)
	// 821B7CC4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7CC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7CCC: 7D2A412E  stwx r9, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 821B7CD0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B7CD4: A103000C  lhz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7CD8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B7CDC: 4198FFE8  blt cr6, 0x821b7cc4
	if ctx.cr[6].lt {
	pc = 0x821B7CC4; continue 'dispatch;
	}
	pc = 0x821B7CE0; continue 'dispatch;
            }
            0x821B7CE0 => {
    //   block [0x821B7CE0..0x821B7D10)
	// 821B7CE0: A0E30014  lhz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B7CE4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B7CE8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821B7CEC: A163000C  lhz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B7CF0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B7CF4: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7CF8: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821B7CFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B7D00: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B7D04: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821B7D08: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 821B7D0C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x821B7D10; continue 'dispatch;
            }
            0x821B7D10 => {
    //   block [0x821B7D10..0x821B7D30)
	// 821B7D10: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821B7D14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821B7D18: 7D28512E  stwx r9, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 821B7D1C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821B7D20: A1030014  lhz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B7D24: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821B7D28: 4198FFE8  blt cr6, 0x821b7d10
	if ctx.cr[6].lt {
	pc = 0x821B7D10; continue 'dispatch;
	}
	// 821B7D2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7D30 size=24
    let mut pc: u32 = 0x821B7D30;
    'dispatch: loop {
        match pc {
            0x821B7D30 => {
    //   block [0x821B7D30..0x821B7D48)
	// 821B7D30: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821B7D34: 816BCD68  lwz r11, -0x3298(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12952 as u32) ) } as u64;
	// 821B7D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7D3C: 409A000C  bne cr6, 0x821b7d48
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821B7D48);
		return;
	}
	// 821B7D40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7D58 size=196
    let mut pc: u32 = 0x821B7D58;
    'dispatch: loop {
        match pc {
            0x821B7D58 => {
    //   block [0x821B7D58..0x821B7E1C)
	// 821B7D58: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7D5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7D60: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B7D64: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B7D68: ECAB0032  fmuls f5, f11, f0
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7D6C: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7D70: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7D74: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7D78: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B7D7C: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7D80: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B7D84: C0C50008  lfs f6, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B7D88: ECAA2B7A  fmadds f5, f10, f13, f5
	ctx.f[5].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7D8C: EDA7037A  fmadds f13, f7, f13, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B7D90: EC092B3A  fmadds f0, f9, f12, f5
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7D94: EDA66B3A  fmadds f13, f6, f12, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B7D98: C18B2238  lfs f12, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7D9C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B7DA0: FCA06A10  fabs f5, f13
	ctx.f[5].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B7DA4: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 821B7DA8: 41980074  blt cr6, 0x821b7e1c
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x821B7E1C);
		return;
	}
	// 821B7DAC: C183003C  lfs f12, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7DB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7DB4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B7DB8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821B7DBC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7DC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7DC4: 41980058  blt cr6, 0x821b7e1c
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x821B7E1C);
		return;
	}
	// 821B7DC8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7DCC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7DD0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821B7DD4: 41990048  bgt cr6, 0x821b7e1c
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x821B7E1C);
		return;
	}
	// 821B7DD8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821B7DDC: C184000C  lfs f12, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7DE0: C0A5000C  lfs f5, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B7DE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821B7DE8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DEC: EC8C0372  fmuls f4, f12, f13
	ctx.f[4].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DF0: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DF4: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821B7DF8: EDA8583A  fmadds f13, f8, f0, f11
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 821B7DFC: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7E00: ED65203A  fmadds f11, f5, f0, f4
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64);
	// 821B7E04: D166000C  stfs f11, 0xc(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821B7E08: ED86483A  fmadds f12, f6, f0, f9
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B7E0C: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7E10: EC07503A  fmadds f0, f7, f0, f10
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821B7E14: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B7E28 size=648
    let mut pc: u32 = 0x821B7E28;
    'dispatch: loop {
        match pc {
            0x821B7E28 => {
    //   block [0x821B7E28..0x821B80A0)
	// 821B7E28: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B7E2C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B7E30: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7E34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7E38: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821B7E3C: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821B7E40: ECAC0032  fmuls f5, f12, f0
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7E44: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7E48: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B7E4C: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821B7E50: C0E50000  lfs f7, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821B7E54: C1430038  lfs f10, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E58: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821B7E5C: C0C50008  lfs f6, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821B7E60: ECAB2B7A  fmadds f5, f11, f13, f5
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7E64: EDA7037A  fmadds f13, f7, f13, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821B7E68: EC092ABA  fmadds f0, f9, f10, f5
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7E6C: EDA66ABA  fmadds f13, f6, f10, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 821B7E70: C14B2238  lfs f10, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E74: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B7E78: FCA06A10  fabs f5, f13
	ctx.f[5].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 821B7E7C: FF055000  fcmpu cr6, f5, f10
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[10].f64);
	// 821B7E80: 41980220  blt cr6, 0x821b80a0
	if ctx.cr[6].lt {
	pc = 0x821B80A0; continue 'dispatch;
	}
	// 821B7E84: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821B7E8C: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 821B7E90: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821B7E94: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821B7E98: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 821B7E9C: 41980204  blt cr6, 0x821b80a0
	if ctx.cr[6].lt {
	pc = 0x821B80A0; continue 'dispatch;
	}
	// 821B7EA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7EA4: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7EA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821B7EAC: 419901F4  bgt cr6, 0x821b80a0
	if ctx.cr[6].gt {
	pc = 0x821B80A0; continue 'dispatch;
	}
	// 821B7EB0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821B7EB4: C0A4000C  lfs f5, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821B7EB8: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 821B7EBC: C085000C  lfs f4, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821B7EC0: 38A30020  addi r5, r3, 0x20
	ctx.r[5].s64 = ctx.r[3].s64 + 32;
	// 821B7EC4: 8121FFDC  lwz r9, -0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-36 as u32) ) } as u64;
	// 821B7EC8: 3BC1FFD0  addi r30, r1, -0x30
	ctx.r[30].s64 = ctx.r[1].s64 + -48;
	// 821B7ECC: 8101FFEC  lwz r8, -0x14(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 821B7ED0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821B7ED4: 396B6230  addi r11, r11, 0x6230
	ctx.r[11].s64 = ctx.r[11].s64 + 25136;
	// 821B7ED8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EDC: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EE0: EC6B0032  fmuls f3, f11, f0
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EE4: ECA50032  fmuls f5, f5, f0
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 821B7EE8: EC08637A  fmadds f0, f8, f13, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 821B7EEC: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821B7EF0: ED864B7A  fmadds f12, f6, f13, f9
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 821B7EF4: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B7EF8: ED271B7A  fmadds f9, f7, f13, f3
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[13].f64 + ctx.f[3].f64) as f32) as f64);
	// 821B7EFC: D1260000  stfs f9, 0(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821B7F00: ED642B7A  fmadds f11, f4, f13, f5
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 821B7F04: D166000C  stfs f11, 0xc(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821B80A0; continue 'dispatch;
            }
            0x821B80A0 => {
    //   block [0x821B80A0..0x821B80B0)
	// 821B80A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B80A4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B80A8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821B80AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B80B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821B80B0 size=100
    let mut pc: u32 = 0x821B80B0;
    'dispatch: loop {
        match pc {
            0x821B80B0 => {
    //   block [0x821B80B0..0x821B80C0)
	// 821B80B0: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 821B80B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B80B8: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 821B80BC: 7C690194  addze r3, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[3].s64 = tmp.s64;
	pc = 0x821B80C0; continue 'dispatch;
            }
            0x821B80C0 => {
    //   block [0x821B80C0..0x821B80EC)
	// 821B80C0: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B80C4: 7D29282E  lwzx r9, r9, r5
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 821B80C8: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B80CC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821B80D0: 4098001C  bge cr6, 0x821b80ec
	if !ctx.cr[6].lt {
	pc = 0x821B80EC; continue 'dispatch;
	}
	// 821B80D4: 7D235A14  add r9, r3, r11
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 821B80D8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821B80DC: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B80E0: 7C690194  addze r3, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[3].s64 = tmp.s64;
	// 821B80E4: 7F0A1800  cmpw cr6, r10, r3
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821B80E8: 48000024  b 0x821b810c
	pc = 0x821B810C; continue 'dispatch;
            }
            0x821B80EC => {
    //   block [0x821B80EC..0x821B810C)
	// 821B80EC: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B80F0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821B80F4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 821B80F8: 7D235214  add r9, r3, r10
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 821B80FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B8100: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B8104: 7C690194  addze r3, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[3].s64 = tmp.s64;
	// 821B8108: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	pc = 0x821B810C; continue 'dispatch;
            }
            0x821B810C => {
    //   block [0x821B810C..0x821B8114)
	// 821B810C: 409AFFB4  bne cr6, 0x821b80c0
	if !ctx.cr[6].eq {
	pc = 0x821B80C0; continue 'dispatch;
	}
	// 821B8110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


