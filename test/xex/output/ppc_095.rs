pub fn sub_82A57008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57008 size=640
    let mut pc: u32 = 0x82A57008;
    'dispatch: loop {
        match pc {
            0x82A57008 => {
    //   block [0x82A57008..0x82A57288)
	// 82A57008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5700C: 482523F9  bl 0x82ca9404
	ctx.lr = 0x82A57010;
	sub_82CA93D0(ctx, base);
	// 82A57010: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57014: 398000F0  li r12, 0xf0
	ctx.r[12].s64 = 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57288 size=128
    let mut pc: u32 = 0x82A57288;
    'dispatch: loop {
        match pc {
            0x82A57288 => {
    //   block [0x82A57288..0x82A572B0)
	// 82A57288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5728C: 48252181  bl 0x82ca940c
	ctx.lr = 0x82A57290;
	sub_82CA93D0(ctx, base);
	// 82A57290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57294: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A57298: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5729C: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A572A0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A572A4: 895E0021  lbz r10, 0x21(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A572A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A572AC: 409A0034  bne cr6, 0x82a572e0
	if !ctx.cr[6].eq {
	pc = 0x82A572E0; continue 'dispatch;
	}
	pc = 0x82A572B0; continue 'dispatch;
            }
            0x82A572B0 => {
    //   block [0x82A572B0..0x82A572E0)
	// 82A572B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A572B4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A572B8: 480002E1  bl 0x82a57598
	ctx.lr = 0x82A572BC;
	sub_82A57598(ctx, base);
	// 82A572BC: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 82A572C0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A572C4: 4B760855  bl 0x821b7b18
	ctx.lr = 0x82A572C8;
	sub_821B7B18(ctx, base);
	// 82A572C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A572CC: 4B7C4A6D  bl 0x8221bd38
	ctx.lr = 0x82A572D0;
	sub_8221BD38(ctx, base);
	// 82A572D0: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A572D4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A572D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A572DC: 419AFFD4  beq cr6, 0x82a572b0
	if ctx.cr[6].eq {
	pc = 0x82A572B0; continue 'dispatch;
	}
	pc = 0x82A572E0; continue 'dispatch;
            }
            0x82A572E0 => {
    //   block [0x82A572E0..0x82A57308)
	// 82A572E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A572E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A572E8: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A572EC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A572F0: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A572F4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A572F8: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A572FC: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A57300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A57304: 48252158  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57308 size=292
    let mut pc: u32 = 0x82A57308;
    'dispatch: loop {
        match pc {
            0x82A57308 => {
    //   block [0x82A57308..0x82A57334)
	// 82A57308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5730C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A57310: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57314: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A57318: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A5731C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57320: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57324: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A57328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5732C: 409A0044  bne cr6, 0x82a57370
	if !ctx.cr[6].eq {
	pc = 0x82A57370; continue 'dispatch;
	}
	// 82A57330: E8C40000  ld r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	pc = 0x82A57334; continue 'dispatch;
            }
            0x82A57334 => {
    //   block [0x82A57334..0x82A57348)
	// 82A57334: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A57338: 7F2A3040  cmpld cr6, r10, r6
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[6].u64, &mut ctx.xer);
	// 82A5733C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A57340: 41980008  blt cr6, 0x82a57348
	if ctx.cr[6].lt {
	pc = 0x82A57348; continue 'dispatch;
	}
	// 82A57344: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x82A57348; continue 'dispatch;
            }
            0x82A57348 => {
    //   block [0x82A57348..0x82A5735C)
	// 82A57348: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5734C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A57350: 419A000C  beq cr6, 0x82a5735c
	if ctx.cr[6].eq {
	pc = 0x82A5735C; continue 'dispatch;
	}
	// 82A57354: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57358: 4800000C  b 0x82a57364
	pc = 0x82A57364; continue 'dispatch;
            }
            0x82A5735C => {
    //   block [0x82A5735C..0x82A57364)
	// 82A5735C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A57360: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A57364; continue 'dispatch;
            }
            0x82A57364 => {
    //   block [0x82A57364..0x82A57370)
	// 82A57364: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A57368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5736C: 419AFFC8  beq cr6, 0x82a57334
	if ctx.cr[6].eq {
	pc = 0x82A57334; continue 'dispatch;
	}
	pc = 0x82A57370; continue 'dispatch;
            }
            0x82A57370 => {
    //   block [0x82A57370..0x82A573A0)
	// 82A57370: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57374: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A57378: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A5737C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A57380: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A57384: 419A0028  beq cr6, 0x82a573ac
	if ctx.cr[6].eq {
	pc = 0x82A573AC; continue 'dispatch;
	}
	// 82A57388: E9640000  ld r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82A5738C: E9290010  ld r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 82A57390: 7F2B4840  cmpld cr6, r11, r9
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[9].u64, &mut ctx.xer);
	// 82A57394: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A57398: 41980008  blt cr6, 0x82a573a0
	if ctx.cr[6].lt {
	pc = 0x82A573A0; continue 'dispatch;
	}
	// 82A5739C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x82A573A0; continue 'dispatch;
            }
            0x82A573A0 => {
    //   block [0x82A573A0..0x82A573AC)
	// 82A573A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A573A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A573A8: 419A0054  beq cr6, 0x82a573fc
	if ctx.cr[6].eq {
	pc = 0x82A573FC; continue 'dispatch;
	}
	pc = 0x82A573AC; continue 'dispatch;
            }
            0x82A573AC => {
    //   block [0x82A573AC..0x82A573FC)
	// 82A573AC: E9640000  ld r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82A573B0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A573B4: 90E10078  stw r7, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 82A573B8: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82A573BC: 90E1007C  stw r7, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 82A573C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A573C4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A573C8: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82A573CC: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A573D0: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A573D4: 48000225  bl 0x82a575f8
	ctx.lr = 0x82A573D8;
	sub_82A575F8(ctx, base);
	// 82A573D8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82A573DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A573E0: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A573E4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A573E8: 4B760731  bl 0x821b7b18
	ctx.lr = 0x82A573EC;
	sub_821B7B18(ctx, base);
	// 82A573EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A573F0: 4B760729  bl 0x821b7b18
	ctx.lr = 0x82A573F4;
	sub_821B7B18(ctx, base);
	// 82A573F4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A573F8: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A573FC; continue 'dispatch;
            }
            0x82A573FC => {
    //   block [0x82A573FC..0x82A57408)
	// 82A573FC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A57400: 409A0008  bne cr6, 0x82a57408
	if !ctx.cr[6].eq {
	pc = 0x82A57408; continue 'dispatch;
	}
	// 82A57404: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A57408; continue 'dispatch;
            }
            0x82A57408 => {
    //   block [0x82A57408..0x82A57418)
	// 82A57408: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5740C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A57410: 409A0008  bne cr6, 0x82a57418
	if !ctx.cr[6].eq {
	pc = 0x82A57418; continue 'dispatch;
	}
	// 82A57414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A57418; continue 'dispatch;
            }
            0x82A57418 => {
    //   block [0x82A57418..0x82A5742C)
	// 82A57418: 386A0018  addi r3, r10, 0x18
	ctx.r[3].s64 = ctx.r[10].s64 + 24;
	// 82A5741C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A57420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A57424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A57428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57430 size=136
    let mut pc: u32 = 0x82A57430;
    'dispatch: loop {
        match pc {
            0x82A57430 => {
    //   block [0x82A57430..0x82A57464)
	// 82A57430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A57434: 48251FD9  bl 0x82ca940c
	ctx.lr = 0x82A57438;
	sub_82CA93D0(ctx, base);
	// 82A57438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5743C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A57440: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A57444: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A57448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5744C: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A57450: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A57454: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82A57458: 409A000C  bne cr6, 0x82a57464
	if !ctx.cr[6].eq {
	pc = 0x82A57464; continue 'dispatch;
	}
	// 82A5745C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57460: 48000010  b 0x82a57470
	pc = 0x82A57470; continue 'dispatch;
            }
            0x82A57464 => {
    //   block [0x82A57464..0x82A57470)
	// 82A57464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A57468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5746C: 4B8C9FED  bl 0x82321458
	ctx.lr = 0x82A57470;
	sub_82321458(ctx, base);
	pc = 0x82A57470; continue 'dispatch;
            }
            0x82A57470 => {
    //   block [0x82A57470..0x82A57494)
	// 82A57470: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A57474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57478: 419A0034  beq cr6, 0x82a574ac
	if ctx.cr[6].eq {
	pc = 0x82A574AC; continue 'dispatch;
	}
	// 82A5747C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57480: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A57484: 419A001C  beq cr6, 0x82a574a0
	if ctx.cr[6].eq {
	pc = 0x82A574A0; continue 'dispatch;
	}
	// 82A57488: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A5748C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82A57490: 7FE903A6  mtctr r31
	ctx.ctr.u64 = ctx.r[31].u64;
	pc = 0x82A57494; continue 'dispatch;
            }
            0x82A57494 => {
    //   block [0x82A57494..0x82A574A0)
	// 82A57494: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A57498: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5749C: 4200FFF8  bdnz 0x82a57494
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A57494; continue 'dispatch;
	}
	pc = 0x82A574A0; continue 'dispatch;
            }
            0x82A574A0 => {
    //   block [0x82A574A0..0x82A574AC)
	// 82A574A0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A574A4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A574A8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A574AC; continue 'dispatch;
            }
            0x82A574AC => {
    //   block [0x82A574AC..0x82A574B8)
	// 82A574AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A574B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A574B4: 48251FA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A574B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A574B8 size=128
    let mut pc: u32 = 0x82A574B8;
    'dispatch: loop {
        match pc {
            0x82A574B8 => {
    //   block [0x82A574B8..0x82A57518)
	// 82A574B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A574BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A574C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A574C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A574C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A574CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A574D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A574D4: 4B760645  bl 0x821b7b18
	ctx.lr = 0x82A574D8;
	sub_821B7B18(ctx, base);
	// 82A574D8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A574DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A574E0: 419A0040  beq cr6, 0x82a57520
	if ctx.cr[6].eq {
	pc = 0x82A57520; continue 'dispatch;
	}
	// 82A574E4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A574E8: 4B7C7D71  bl 0x8221f258
	ctx.lr = 0x82A574EC;
	sub_8221F258(ctx, base);
	// 82A574EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A574F0: 419A0028  beq cr6, 0x82a57518
	if ctx.cr[6].eq {
	pc = 0x82A57518; continue 'dispatch;
	}
	// 82A574F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A574F8: 3D2082A5  lis r9, -0x7d5b
	ctx.r[9].s64 = -2103115776;
	// 82A574FC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A57500: 38E97968  addi r7, r9, 0x7968
	ctx.r[7].s64 = ctx.r[9].s64 + 31080;
	// 82A57504: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A57508: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5750C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A57510: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A57514: 48000008  b 0x82a5751c
	pc = 0x82A5751C; continue 'dispatch;
            }
            0x82A57518 => {
    //   block [0x82A57518..0x82A5751C)
	// 82A57518: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A5751C; continue 'dispatch;
            }
            0x82A5751C => {
    //   block [0x82A5751C..0x82A57520)
	// 82A5751C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A57520; continue 'dispatch;
            }
            0x82A57520 => {
    //   block [0x82A57520..0x82A57538)
	// 82A57520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A57524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A57528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5752C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A57530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A57534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57538 size=96
    let mut pc: u32 = 0x82A57538;
    'dispatch: loop {
        match pc {
            0x82A57538 => {
    //   block [0x82A57538..0x82A5757C)
	// 82A57538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5753C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A57540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A57544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A57548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5754C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A57550: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57554: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57558: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5755C: 419A0024  beq cr6, 0x82a57580
	if ctx.cr[6].eq {
	pc = 0x82A57580; continue 'dispatch;
	}
	// 82A57560: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82A57564: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A57568: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A5756C: 7FE61A14  add r31, r6, r3
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A57570: 4081000C  ble 0x82a5757c
	if !ctx.cr[0].gt {
	pc = 0x82A5757C; continue 'dispatch;
	}
	// 82A57574: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A57578: 48252AB1  bl 0x82caa028
	ctx.lr = 0x82A5757C;
	sub_82CAA028(ctx, base);
	pc = 0x82A5757C; continue 'dispatch;
            }
            0x82A5757C => {
    //   block [0x82A5757C..0x82A57580)
	// 82A5757C: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82A57580; continue 'dispatch;
            }
            0x82A57580 => {
    //   block [0x82A57580..0x82A57598)
	// 82A57580: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A57584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A57588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5758C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A57590: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A57594: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57598 size=92
    let mut pc: u32 = 0x82A57598;
    'dispatch: loop {
        match pc {
            0x82A57598 => {
    //   block [0x82A57598..0x82A575BC)
	// 82A57598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5759C: 48251E71  bl 0x82ca940c
	ctx.lr = 0x82A575A0;
	sub_82CA93D0(ctx, base);
	// 82A575A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A575A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A575A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A575AC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A575B0: 897E0021  lbz r11, 0x21(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A575B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A575B8: 409A0034  bne cr6, 0x82a575ec
	if !ctx.cr[6].eq {
	pc = 0x82A575EC; continue 'dispatch;
	}
	pc = 0x82A575BC; continue 'dispatch;
            }
            0x82A575BC => {
    //   block [0x82A575BC..0x82A575EC)
	// 82A575BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A575C0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A575C4: 4BFFFFD5  bl 0x82a57598
	ctx.lr = 0x82A575C8;
	sub_82A57598(ctx, base);
	// 82A575C8: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 82A575CC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A575D0: 4B760549  bl 0x821b7b18
	ctx.lr = 0x82A575D4;
	sub_821B7B18(ctx, base);
	// 82A575D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A575D8: 4B7C4761  bl 0x8221bd38
	ctx.lr = 0x82A575DC;
	sub_8221BD38(ctx, base);
	// 82A575DC: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A575E0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A575E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A575E8: 419AFFD4  beq cr6, 0x82a575bc
	if ctx.cr[6].eq {
	pc = 0x82A575BC; continue 'dispatch;
	}
	pc = 0x82A575EC; continue 'dispatch;
            }
            0x82A575EC => {
    //   block [0x82A575EC..0x82A575F4)
	// 82A575EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A575F0: 48251E6C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A575F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A575F8 size=660
    let mut pc: u32 = 0x82A575F8;
    'dispatch: loop {
        match pc {
            0x82A575F8 => {
    //   block [0x82A575F8..0x82A5764C)
	// 82A575F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A575FC: 48251E05  bl 0x82ca9400
	ctx.lr = 0x82A57600;
	sub_82CA93D0(ctx, base);
	// 82A57600: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57604: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A57608: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A5760C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A57610: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A57614: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A57618: FBE100C0  std r31, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u64 ) };
	// 82A5761C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A57620: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57624: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A57628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5762C: 409A0020  bne cr6, 0x82a5764c
	if !ctx.cr[6].eq {
	pc = 0x82A5764C; continue 'dispatch;
	}
	// 82A57630: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A57634: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57638: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5763C: 48000C35  bl 0x82a58270
	ctx.lr = 0x82A57640;
	sub_82A58270(ctx, base);
	// 82A57640: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57644: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A57648: 48251E08  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5764C => {
    //   block [0x82A5764C..0x82A57668)
	// 82A5764C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57650: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A57654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57658: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5765C: 419A000C  beq cr6, 0x82a57668
	if ctx.cr[6].eq {
	pc = 0x82A57668; continue 'dispatch;
	}
	// 82A57660: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A57664: 419A0008  beq cr6, 0x82a5766c
	if ctx.cr[6].eq {
	pc = 0x82A5766C; continue 'dispatch;
	}
	pc = 0x82A57668; continue 'dispatch;
            }
            0x82A57668 => {
    //   block [0x82A57668..0x82A5766C)
	// 82A57668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5766C; continue 'dispatch;
            }
            0x82A5766C => {
    //   block [0x82A5766C..0x82A57690)
	// 82A5766C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A57670: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A57674: 409A004C  bne cr6, 0x82a576c0
	if !ctx.cr[6].eq {
	pc = 0x82A576C0; continue 'dispatch;
	}
	// 82A57678: E97C0000  ld r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 82A5767C: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 82A57680: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82A57684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A57688: 41980008  blt cr6, 0x82a57690
	if ctx.cr[6].lt {
	pc = 0x82A57690; continue 'dispatch;
	}
	// 82A5768C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A57690; continue 'dispatch;
            }
            0x82A57690 => {
    //   block [0x82A57690..0x82A576C0)
	// 82A57690: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A57694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57698: 419A01C4  beq cr6, 0x82a5785c
	if ctx.cr[6].eq {
	pc = 0x82A5785C; continue 'dispatch;
	}
	// 82A5769C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A576A0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A576A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A576A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A576AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A576B0: 48000BC1  bl 0x82a58270
	ctx.lr = 0x82A576B4;
	sub_82A58270(ctx, base);
	// 82A576B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A576B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A576BC: 48251D94  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A576C0 => {
    //   block [0x82A576C0..0x82A576D0)
	// 82A576C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A576C4: 419A000C  beq cr6, 0x82a576d0
	if ctx.cr[6].eq {
	pc = 0x82A576D0; continue 'dispatch;
	}
	// 82A576C8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A576CC: 419A0008  beq cr6, 0x82a576d4
	if ctx.cr[6].eq {
	pc = 0x82A576D4; continue 'dispatch;
	}
	pc = 0x82A576D0; continue 'dispatch;
            }
            0x82A576D0 => {
    //   block [0x82A576D0..0x82A576D4)
	// 82A576D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A576D4; continue 'dispatch;
            }
            0x82A576D4 => {
    //   block [0x82A576D4..0x82A576F8)
	// 82A576D4: E97C0000  ld r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 82A576D8: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A576DC: 409A0048  bne cr6, 0x82a57724
	if !ctx.cr[6].eq {
	pc = 0x82A57724; continue 'dispatch;
	}
	// 82A576E0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A576E4: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82A576E8: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82A576EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A576F0: 41980008  blt cr6, 0x82a576f8
	if ctx.cr[6].lt {
	pc = 0x82A576F8; continue 'dispatch;
	}
	// 82A576F4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A576F8; continue 'dispatch;
            }
            0x82A576F8 => {
    //   block [0x82A576F8..0x82A57724)
	// 82A576F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A576FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57700: 419A015C  beq cr6, 0x82a5785c
	if ctx.cr[6].eq {
	pc = 0x82A5785C; continue 'dispatch;
	}
	// 82A57704: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A57708: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5770C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A57710: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57714: 48000B5D  bl 0x82a58270
	ctx.lr = 0x82A57718;
	sub_82A58270(ctx, base);
	// 82A57718: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5771C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A57720: 48251D30  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57724 => {
    //   block [0x82A57724..0x82A57738)
	// 82A57724: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 82A57728: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82A5772C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A57730: 41980008  blt cr6, 0x82a57738
	if ctx.cr[6].lt {
	pc = 0x82A57738; continue 'dispatch;
	}
	// 82A57734: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82A57738; continue 'dispatch;
            }
            0x82A57738 => {
    //   block [0x82A57738..0x82A5776C)
	// 82A57738: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5773C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A57740: 419A006C  beq cr6, 0x82a577ac
	if ctx.cr[6].eq {
	pc = 0x82A577AC; continue 'dispatch;
	}
	// 82A57744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A57748: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 82A5774C: 4B926C95  bl 0x8237e3e0
	ctx.lr = 0x82A57750;
	sub_8237E3E0(ctx, base);
	// 82A57750: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A57754: E97C0000  ld r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 82A57758: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82A5775C: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82A57760: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A57764: 41980008  blt cr6, 0x82a5776c
	if ctx.cr[6].lt {
	pc = 0x82A5776C; continue 'dispatch;
	}
	// 82A57768: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82A5776C; continue 'dispatch;
            }
            0x82A5776C => {
    //   block [0x82A5776C..0x82A57798)
	// 82A5776C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A57770: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A57774: 419A0038  beq cr6, 0x82a577ac
	if ctx.cr[6].eq {
	pc = 0x82A577AC; continue 'dispatch;
	}
	// 82A57778: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5777C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A57780: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A57784: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57788: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A5778C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A57790: 409A00B8  bne cr6, 0x82a57848
	if !ctx.cr[6].eq {
	pc = 0x82A57848; continue 'dispatch;
	}
	// 82A57794: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A57798; continue 'dispatch;
            }
            0x82A57798 => {
    //   block [0x82A57798..0x82A577AC)
	// 82A57798: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5779C: 48000AD5  bl 0x82a58270
	ctx.lr = 0x82A577A0;
	sub_82A58270(ctx, base);
	// 82A577A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A577A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A577A8: 48251CA8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A577AC => {
    //   block [0x82A577AC..0x82A577C0)
	// 82A577AC: E95B0010  ld r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	// 82A577B0: 7F2A5840  cmpld cr6, r10, r11
	ctx.cr[6].compare_u64(ctx.r[10].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82A577B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A577B8: 41980008  blt cr6, 0x82a577c0
	if ctx.cr[6].lt {
	pc = 0x82A577C0; continue 'dispatch;
	}
	// 82A577BC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A577C0; continue 'dispatch;
            }
            0x82A577C0 => {
    //   block [0x82A577C0..0x82A577F0)
	// 82A577C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A577C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A577C8: 419A0094  beq cr6, 0x82a5785c
	if ctx.cr[6].eq {
	pc = 0x82A5785C; continue 'dispatch;
	}
	// 82A577CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A577D0: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 82A577D4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A577D8: 4B8BD351  bl 0x82314b28
	ctx.lr = 0x82A577DC;
	sub_82314B28(ctx, base);
	// 82A577DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A577E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A577E4: 419A000C  beq cr6, 0x82a577f0
	if ctx.cr[6].eq {
	pc = 0x82A577F0; continue 'dispatch;
	}
	// 82A577E8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A577EC: 419A0008  beq cr6, 0x82a577f4
	if ctx.cr[6].eq {
	pc = 0x82A577F4; continue 'dispatch;
	}
	pc = 0x82A577F0; continue 'dispatch;
            }
            0x82A577F0 => {
    //   block [0x82A577F0..0x82A577F4)
	// 82A577F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A577F4; continue 'dispatch;
            }
            0x82A577F4 => {
    //   block [0x82A577F4..0x82A5781C)
	// 82A577F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A577F8: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A577FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A57800: 419A0028  beq cr6, 0x82a57828
	if ctx.cr[6].eq {
	pc = 0x82A57828; continue 'dispatch;
	}
	// 82A57804: E97C0000  ld r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 82A57808: E9460010  ld r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82A5780C: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82A57810: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A57814: 41980008  blt cr6, 0x82a5781c
	if ctx.cr[6].lt {
	pc = 0x82A5781C; continue 'dispatch;
	}
	// 82A57818: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A5781C; continue 'dispatch;
            }
            0x82A5781C => {
    //   block [0x82A5781C..0x82A57828)
	// 82A5781C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A57820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57824: 419A0038  beq cr6, 0x82a5785c
	if ctx.cr[6].eq {
	pc = 0x82A5785C; continue 'dispatch;
	}
	pc = 0x82A57828; continue 'dispatch;
            }
            0x82A57828 => {
    //   block [0x82A57828..0x82A57848)
	// 82A57828: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5782C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A57830: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A57834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57838: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A5783C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A57840: 419AFF58  beq cr6, 0x82a57798
	if ctx.cr[6].eq {
	pc = 0x82A57798; continue 'dispatch;
	}
	// 82A57844: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A57848; continue 'dispatch;
            }
            0x82A57848 => {
    //   block [0x82A57848..0x82A5785C)
	// 82A57848: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5784C: 48000A25  bl 0x82a58270
	ctx.lr = 0x82A57850;
	sub_82A58270(ctx, base);
	// 82A57850: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57854: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A57858: 48251BF8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5785C => {
    //   block [0x82A5785C..0x82A5788C)
	// 82A5785C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A57860: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A57864: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A57868: 480008B1  bl 0x82a58118
	ctx.lr = 0x82A5786C;
	sub_82A58118(ctx, base);
	// 82A5786C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A57870: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A57874: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A57878: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5787C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57880: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A57884: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A57888: 48251BC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57890 size=212
    let mut pc: u32 = 0x82A57890;
    'dispatch: loop {
        match pc {
            0x82A57890 => {
    //   block [0x82A57890..0x82A578E4)
	// 82A57890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A57894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A57898: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5789C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A578A0: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82A578A4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A578A8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A578AC: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A578B0: 7D4A3BD6  divw r10, r10, r7
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[7].s32;
	// 82A578B4: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A578B8: 4099002C  ble cr6, 0x82a578e4
	if !ctx.cr[6].gt {
	pc = 0x82A578E4; continue 'dispatch;
	}
	// 82A578BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A578C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A578C4: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82A578C8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A578CC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A578D0: 48000C41  bl 0x82a58510
	ctx.lr = 0x82A578D4;
	sub_82A58510(ctx, base);
	// 82A578D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A578D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A578DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A578E0: 4E800020  blr
	return;
            }
            0x82A578E4 => {
    //   block [0x82A578E4..0x82A57928)
	// 82A578E4: 40980070  bge cr6, 0x82a57954
	if !ctx.cr[6].lt {
	pc = 0x82A57954; continue 'dispatch;
	}
	// 82A578E8: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A578EC: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82A578F0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A578F4: 7D0A4A14  add r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A578F8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A578FC: 419A0058  beq cr6, 0x82a57954
	if ctx.cr[6].eq {
	pc = 0x82A57954; continue 'dispatch;
	}
	// 82A57900: 7D2B5850  subf r9, r11, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 82A57904: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A57908: 7D293BD6  divw r9, r9, r7
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[7].s32;
	// 82A5790C: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A57910: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A57914: 7CE93A14  add r7, r9, r7
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82A57918: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A5791C: 7CE94214  add r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82A57920: 419A0030  beq cr6, 0x82a57950
	if ctx.cr[6].eq {
	pc = 0x82A57950; continue 'dispatch;
	}
	// 82A57924: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	pc = 0x82A57928; continue 'dispatch;
            }
            0x82A57928 => {
    //   block [0x82A57928..0x82A57950)
	// 82A57928: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5792C: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A57930: 7D09512E  stwx r8, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82A57934: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57938: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A5793C: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57940: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A57944: 90860008  stw r4, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A57948: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5794C: 409AFFDC  bne cr6, 0x82a57928
	if !ctx.cr[6].eq {
	pc = 0x82A57928; continue 'dispatch;
	}
	pc = 0x82A57950; continue 'dispatch;
            }
            0x82A57950 => {
    //   block [0x82A57950..0x82A57954)
	// 82A57950: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x82A57954; continue 'dispatch;
            }
            0x82A57954 => {
    //   block [0x82A57954..0x82A57964)
	// 82A57954: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A57958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5795C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A57960: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57968 size=80
    let mut pc: u32 = 0x82A57968;
    'dispatch: loop {
        match pc {
            0x82A57968 => {
    //   block [0x82A57968..0x82A5799C)
	// 82A57968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5796C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A57970: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A57974: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57978: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5797C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A57980: 419A0024  beq cr6, 0x82a579a4
	if ctx.cr[6].eq {
	pc = 0x82A579A4; continue 'dispatch;
	}
	// 82A57984: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A57988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5798C: 419A0010  beq cr6, 0x82a5799c
	if ctx.cr[6].eq {
	pc = 0x82A5799C; continue 'dispatch;
	}
	// 82A57990: 4812FC39  bl 0x82b875c8
	ctx.lr = 0x82A57994;
	sub_82B875C8(ctx, base);
	// 82A57994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A57998: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5799C; continue 'dispatch;
            }
            0x82A5799C => {
    //   block [0x82A5799C..0x82A579A4)
	// 82A5799C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A579A0: 4B7C4399  bl 0x8221bd38
	ctx.lr = 0x82A579A4;
	sub_8221BD38(ctx, base);
	pc = 0x82A579A4; continue 'dispatch;
            }
            0x82A579A4 => {
    //   block [0x82A579A4..0x82A579B8)
	// 82A579A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A579A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A579AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A579B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A579B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A579B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A579B8 size=672
    let mut pc: u32 = 0x82A579B8;
    'dispatch: loop {
        match pc {
            0x82A579B8 => {
    //   block [0x82A579B8..0x82A579EC)
	// 82A579B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A579BC: 48251A41  bl 0x82ca93fc
	ctx.lr = 0x82A579C0;
	sub_82CA93D0(ctx, base);
	// 82A579C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A579C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A579C8: A3260000  lhz r25, 0(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A579CC: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A579D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A579D4: 3BCBFAE0  addi r30, r11, -0x520
	ctx.r[30].s64 = ctx.r[11].s64 + -1312;
	// 82A579D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A579DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A579E0: 409A000C  bne cr6, 0x82a579ec
	if !ctx.cr[6].eq {
	pc = 0x82A579EC; continue 'dispatch;
	}
	// 82A579E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A579E8: 48000010  b 0x82a579f8
	pc = 0x82A579F8; continue 'dispatch;
            }
            0x82A579EC => {
    //   block [0x82A579EC..0x82A579F8)
	// 82A579EC: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A579F0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A579F4: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	pc = 0x82A579F8; continue 'dispatch;
            }
            0x82A579F8 => {
    //   block [0x82A579F8..0x82A57A2C)
	// 82A579F8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A579FC: 419A0254  beq cr6, 0x82a57c50
	if ctx.cr[6].eq {
	pc = 0x82A57C50; continue 'dispatch;
	}
	// 82A57A00: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57A04: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 82A57A08: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57A0C: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82A57A10: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 82A57A14: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A57A18: 7F06E040  cmplw cr6, r6, r28
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A57A1C: 40980010  bge cr6, 0x82a57a2c
	if !ctx.cr[6].lt {
	pc = 0x82A57A2C; continue 'dispatch;
	}
	// 82A57A20: 4BFEFAA9  bl 0x82a474c8
	ctx.lr = 0x82A57A24;
	sub_82A474C8(ctx, base);
	// 82A57A24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A57A28: 48251A24  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57A2C => {
    //   block [0x82A57A2C..0x82A57A58)
	// 82A57A2C: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57A30: 7D080E70  srawi r8, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 82A57A34: 7CE8E214  add r7, r8, r28
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[28].u64;
	// 82A57A38: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A57A3C: 40980104  bge cr6, 0x82a57b40
	if !ctx.cr[6].lt {
	pc = 0x82A57B40; continue 'dispatch;
	}
	// 82A57A40: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A57A44: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A57A48: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A57A4C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A57A50: 41980008  blt cr6, 0x82a57a58
	if ctx.cr[6].lt {
	pc = 0x82A57A58; continue 'dispatch;
	}
	// 82A57A54: 7F485214  add r26, r8, r10
	ctx.r[26].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x82A57A58; continue 'dispatch;
            }
            0x82A57A58 => {
    //   block [0x82A57A58..0x82A57A78)
	// 82A57A58: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57A5C: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A57A60: 7D2AE214  add r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82A57A64: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A57A68: 40980010  bge cr6, 0x82a57a78
	if !ctx.cr[6].lt {
	pc = 0x82A57A78; continue 'dispatch;
	}
	// 82A57A6C: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57A70: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A57A74: 7F4BE214  add r26, r11, r28
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A57A78; continue 'dispatch;
            }
            0x82A57A78 => {
    //   block [0x82A57A78..0x82A57AB0)
	// 82A57A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A57A7C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A57A80: 48000DE9  bl 0x82a58868
	ctx.lr = 0x82A57A84;
	sub_82A58868(ctx, base);
	// 82A57A84: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57A88: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A57A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A57A90: 7D65E850  subf r11, r5, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 82A57A94: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A57A98: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A57A9C: 7F66FA14  add r27, r6, r31
	ctx.r[27].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82A57AA0: 41820010  beq 0x82a57ab0
	if ctx.cr[0].eq {
	pc = 0x82A57AB0; continue 'dispatch;
	}
	// 82A57AA4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A57AA8: 48252581  bl 0x82caa028
	ctx.lr = 0x82A57AAC;
	sub_82CAA028(ctx, base);
	// 82A57AAC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A57AB0; continue 'dispatch;
            }
            0x82A57AB0 => {
    //   block [0x82A57AB0..0x82A57AC0)
	// 82A57AB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A57AB4: 419A001C  beq cr6, 0x82a57ad0
	if ctx.cr[6].eq {
	pc = 0x82A57AD0; continue 'dispatch;
	}
	// 82A57AB8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82A57ABC: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	pc = 0x82A57AC0; continue 'dispatch;
            }
            0x82A57AC0 => {
    //   block [0x82A57AC0..0x82A57AD0)
	// 82A57AC0: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A57AC4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A57AC8: 4200FFF8  bdnz 0x82a57ac0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A57AC0; continue 'dispatch;
	}
	// 82A57ACC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A57AD0; continue 'dispatch;
            }
            0x82A57AD0 => {
    //   block [0x82A57AD0..0x82A57B00)
	// 82A57AD0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57AD4: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82A57AD8: 7D4A0E71  srawi. r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A57ADC: 41820024  beq 0x82a57b00
	if ctx.cr[0].eq {
	pc = 0x82A57B00; continue 'dispatch;
	}
	// 82A57AE0: 5544083C  slwi r4, r10, 1
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A57AE4: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A57AE8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A57AEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A57AF0: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A57AF4: 48252535  bl 0x82caa028
	ctx.lr = 0x82A57AF8;
	sub_82CAA028(ctx, base);
	// 82A57AF8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57AFC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A57B00; continue 'dispatch;
            }
            0x82A57B00 => {
    //   block [0x82A57B00..0x82A57B1C)
	// 82A57B00: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82A57B04: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A57B08: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A57B0C: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A57B10: 419A000C  beq cr6, 0x82a57b1c
	if ctx.cr[6].eq {
	pc = 0x82A57B1C; continue 'dispatch;
	}
	// 82A57B14: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A57B18: 4B7C4221  bl 0x8221bd38
	ctx.lr = 0x82A57B1C;
	sub_8221BD38(ctx, base);
	pc = 0x82A57B1C; continue 'dispatch;
            }
            0x82A57B1C => {
    //   block [0x82A57B1C..0x82A57B40)
	// 82A57B1C: 574B083C  slwi r11, r26, 1
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A57B20: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A57B24: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A57B28: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A57B2C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82A57B30: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A57B34: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A57B38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A57B3C: 48251910  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57B40 => {
    //   block [0x82A57B40..0x82A57B78)
	// 82A57B40: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A57B44: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 82A57B48: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A57B4C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A57B50: 4098008C  bge cr6, 0x82a57bdc
	if !ctx.cr[6].lt {
	pc = 0x82A57BDC; continue 'dispatch;
	}
	// 82A57B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57B58: 419A0020  beq cr6, 0x82a57b78
	if ctx.cr[6].eq {
	pc = 0x82A57B78; continue 'dispatch;
	}
	// 82A57B5C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A57B60: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A57B64: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A57B68: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A57B6C: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A57B70: 482524B9  bl 0x82caa028
	ctx.lr = 0x82A57B74;
	sub_82CAA028(ctx, base);
	// 82A57B74: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A57B78; continue 'dispatch;
            }
            0x82A57B78 => {
    //   block [0x82A57B78..0x82A57B98)
	// 82A57B78: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 82A57B7C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A57B80: 7D4AE051  subf. r10, r10, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A57B84: 41820024  beq 0x82a57ba8
	if ctx.cr[0].eq {
	pc = 0x82A57BA8; continue 'dispatch;
	}
	// 82A57B88: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A57B8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A57B90: 419A0018  beq cr6, 0x82a57ba8
	if ctx.cr[6].eq {
	pc = 0x82A57BA8; continue 'dispatch;
	}
	// 82A57B94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82A57B98; continue 'dispatch;
            }
            0x82A57B98 => {
    //   block [0x82A57B98..0x82A57BA8)
	// 82A57B98: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A57B9C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A57BA0: 4200FFF8  bdnz 0x82a57b98
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A57B98; continue 'dispatch;
	}
	// 82A57BA4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A57BA8; continue 'dispatch;
            }
            0x82A57BA8 => {
    //   block [0x82A57BA8..0x82A57BC4)
	// 82A57BA8: 5789083C  slwi r9, r28, 1
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A57BAC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A57BB0: 7D49FA14  add r10, r9, r31
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 82A57BB4: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A57BB8: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A57BBC: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A57BC0: 419A0090  beq cr6, 0x82a57c50
	if ctx.cr[6].eq {
	pc = 0x82A57C50; continue 'dispatch;
	}
	pc = 0x82A57BC4; continue 'dispatch;
            }
            0x82A57BC4 => {
    //   block [0x82A57BC4..0x82A57BDC)
	// 82A57BC4: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A57BC8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A57BCC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A57BD0: 409AFFF4  bne cr6, 0x82a57bc4
	if !ctx.cr[6].eq {
	pc = 0x82A57BC4; continue 'dispatch;
	}
	// 82A57BD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A57BD8: 48251874  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57BDC => {
    //   block [0x82A57BDC..0x82A57C08)
	// 82A57BDC: 579A083C  slwi r26, r28, 1
	ctx.r[26].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82A57BE0: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A57BE4: 7D7CF850  subf r11, r28, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	// 82A57BE8: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A57BEC: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A57BF0: 7F66FA14  add r27, r6, r31
	ctx.r[27].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82A57BF4: 41820014  beq 0x82a57c08
	if ctx.cr[0].eq {
	pc = 0x82A57C08; continue 'dispatch;
	}
	// 82A57BF8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A57BFC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A57C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A57C04: 48252425  bl 0x82caa028
	ctx.lr = 0x82A57C08;
	sub_82CAA028(ctx, base);
	pc = 0x82A57C08; continue 'dispatch;
            }
            0x82A57C08 => {
    //   block [0x82A57C08..0x82A57C30)
	// 82A57C08: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 82A57C0C: 937E0008  stw r27, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A57C10: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A57C14: 4081001C  ble 0x82a57c30
	if !ctx.cr[0].gt {
	pc = 0x82A57C30; continue 'dispatch;
	}
	// 82A57C18: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A57C1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A57C20: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A57C24: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A57C28: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57C2C: 482523FD  bl 0x82caa028
	ctx.lr = 0x82A57C30;
	sub_82CAA028(ctx, base);
	pc = 0x82A57C30; continue 'dispatch;
            }
            0x82A57C30 => {
    //   block [0x82A57C30..0x82A57C40)
	// 82A57C30: 7D5AEA14  add r10, r26, r29
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[29].u64;
	// 82A57C34: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A57C38: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A57C3C: 419A0014  beq cr6, 0x82a57c50
	if ctx.cr[6].eq {
	pc = 0x82A57C50; continue 'dispatch;
	}
	pc = 0x82A57C40; continue 'dispatch;
            }
            0x82A57C40 => {
    //   block [0x82A57C40..0x82A57C50)
	// 82A57C40: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A57C44: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A57C48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A57C4C: 409AFFF4  bne cr6, 0x82a57c40
	if !ctx.cr[6].eq {
	pc = 0x82A57C40; continue 'dispatch;
	}
	pc = 0x82A57C50; continue 'dispatch;
            }
            0x82A57C50 => {
    //   block [0x82A57C50..0x82A57C58)
	// 82A57C50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A57C54: 482517F8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57C58 size=128
    let mut pc: u32 = 0x82A57C58;
    'dispatch: loop {
        match pc {
            0x82A57C58 => {
    //   block [0x82A57C58..0x82A57CA8)
	// 82A57C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A57C5C: 482517A1  bl 0x82ca93fc
	ctx.lr = 0x82A57C60;
	sub_82CA93D0(ctx, base);
	// 82A57C60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57C64: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82A57C68: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A57C6C: FB2100B0  std r25, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[25].u64 ) };
	// 82A57C70: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A57C74: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A57C78: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A57C7C: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A57C80: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A57C84: 419A0044  beq cr6, 0x82a57cc8
	if ctx.cr[6].eq {
	pc = 0x82A57CC8; continue 'dispatch;
	}
	// 82A57C88: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57C8C: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A57C90: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A57C94: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A57C98: 552A2834  slwi r10, r9, 5
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A57C9C: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A57CA0: 419A0024  beq cr6, 0x82a57cc4
	if ctx.cr[6].eq {
	pc = 0x82A57CC4; continue 'dispatch;
	}
	// 82A57CA4: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82A57CA8; continue 'dispatch;
            }
            0x82A57CA8 => {
    //   block [0x82A57CA8..0x82A57CC4)
	// 82A57CA8: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82A57CAC: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A57CB4: 482517CD  bl 0x82ca9480
	ctx.lr = 0x82A57CB8;
	sub_82CA9480(ctx, base);
	// 82A57CB8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A57CBC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A57CC0: 409AFFE8  bne cr6, 0x82a57ca8
	if !ctx.cr[6].eq {
	pc = 0x82A57CA8; continue 'dispatch;
	}
	pc = 0x82A57CC4; continue 'dispatch;
            }
            0x82A57CC4 => {
    //   block [0x82A57CC4..0x82A57CC8)
	// 82A57CC4: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A57CC8; continue 'dispatch;
            }
            0x82A57CC8 => {
    //   block [0x82A57CC8..0x82A57CD8)
	// 82A57CC8: FB3A0000  std r25, 0(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 82A57CCC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A57CD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A57CD4: 48251778  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A57CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A57CD8 size=856
    let mut pc: u32 = 0x82A57CD8;
    'dispatch: loop {
        match pc {
            0x82A57CD8 => {
    //   block [0x82A57CD8..0x82A57D18)
	// 82A57CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A57CDC: 4825171D  bl 0x82ca93f8
	ctx.lr = 0x82A57CE0;
	sub_82CA93D0(ctx, base);
	// 82A57CE0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A57CE4: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 82A57CE8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A57CEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A57CF0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57CF4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A57CF8: 48251789  bl 0x82ca9480
	ctx.lr = 0x82A57CFC;
	sub_82CA9480(ctx, base);
	// 82A57CFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A57D00: 3B0BFB14  addi r24, r11, -0x4ec
	ctx.r[24].s64 = ctx.r[11].s64 + -1260;
	// 82A57D04: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57D0C: 409A000C  bne cr6, 0x82a57d18
	if !ctx.cr[6].eq {
	pc = 0x82A57D18; continue 'dispatch;
	}
	// 82A57D10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A57D14: 48000010  b 0x82a57d24
	pc = 0x82A57D24; continue 'dispatch;
            }
            0x82A57D18 => {
    //   block [0x82A57D18..0x82A57D24)
	// 82A57D18: 8158000C  lwz r10, 0xc(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A57D1C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A57D20: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	pc = 0x82A57D24; continue 'dispatch;
            }
            0x82A57D24 => {
    //   block [0x82A57D24..0x82A57D58)
	// 82A57D24: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A57D28: 419A0300  beq cr6, 0x82a58028
	if ctx.cr[6].eq {
	pc = 0x82A58028; continue 'dispatch;
	}
	// 82A57D2C: 83F80008  lwz r31, 8(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57D30: 3D2007FF  lis r9, 0x7ff
	ctx.r[9].s64 = 134152192;
	// 82A57D34: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57D38: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82A57D3C: 7D072E70  srawi r7, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 82A57D40: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A57D44: 7F06D040  cmplw cr6, r6, r26
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A57D48: 40980010  bge cr6, 0x82a57d58
	if !ctx.cr[6].lt {
	pc = 0x82A57D58; continue 'dispatch;
	}
	// 82A57D4C: 4BFEF77D  bl 0x82a474c8
	ctx.lr = 0x82A57D50;
	sub_82A474C8(ctx, base);
	// 82A57D50: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A57D54: 482516F4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57D58 => {
    //   block [0x82A57D58..0x82A57D84)
	// 82A57D58: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57D5C: 7D082E70  srawi r8, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 82A57D60: 7CE8D214  add r7, r8, r26
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[26].u64;
	// 82A57D64: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A57D68: 40980158  bge cr6, 0x82a57ec0
	if !ctx.cr[6].lt {
	pc = 0x82A57EC0; continue 'dispatch;
	}
	// 82A57D6C: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A57D70: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A57D74: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A57D78: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A57D7C: 41980008  blt cr6, 0x82a57d84
	if ctx.cr[6].lt {
	pc = 0x82A57D84; continue 'dispatch;
	}
	// 82A57D80: 7F285214  add r25, r8, r10
	ctx.r[25].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x82A57D84; continue 'dispatch;
            }
            0x82A57D84 => {
    //   block [0x82A57D84..0x82A57DA4)
	// 82A57D84: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57D88: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A57D8C: 7D2AD214  add r9, r10, r26
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A57D90: 7F194840  cmplw cr6, r25, r9
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A57D94: 40980010  bge cr6, 0x82a57da4
	if !ctx.cr[6].lt {
	pc = 0x82A57DA4; continue 'dispatch;
	}
	// 82A57D98: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A57D9C: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A57DA0: 7F2BD214  add r25, r11, r26
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	pc = 0x82A57DA4; continue 'dispatch;
            }
            0x82A57DA4 => {
    //   block [0x82A57DA4..0x82A57DCC)
	// 82A57DA4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A57DA8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A57DAC: 4BFB9825  bl 0x82a115d0
	ctx.lr = 0x82A57DB0;
	sub_82A115D0(ctx, base);
	// 82A57DB0: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A57DB4: 838100DC  lwz r28, 0xdc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A57DB8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A57DBC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A57DC0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A57DC4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A57DC8: 419A0030  beq cr6, 0x82a57df8
	if ctx.cr[6].eq {
	pc = 0x82A57DF8; continue 'dispatch;
	}
	pc = 0x82A57DCC; continue 'dispatch;
            }
            0x82A57DCC => {
    //   block [0x82A57DCC..0x82A57DE4)
	// 82A57DCC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A57DD0: 419A0014  beq cr6, 0x82a57de4
	if ctx.cr[6].eq {
	pc = 0x82A57DE4; continue 'dispatch;
	}
	// 82A57DD4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57DD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A57DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A57DE0: 482516A1  bl 0x82ca9480
	ctx.lr = 0x82A57DE4;
	sub_82CA9480(ctx, base);
	pc = 0x82A57DE4; continue 'dispatch;
            }
            0x82A57DE4 => {
    //   block [0x82A57DE4..0x82A57DF8)
	// 82A57DE4: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A57DE8: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A57DEC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A57DF0: 409AFFDC  bne cr6, 0x82a57dcc
	if !ctx.cr[6].eq {
	pc = 0x82A57DCC; continue 'dispatch;
	}
	// 82A57DF4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A57DF8; continue 'dispatch;
            }
            0x82A57DF8 => {
    //   block [0x82A57DF8..0x82A57E08)
	// 82A57DF8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A57DFC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A57E00: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A57E04: 419A002C  beq cr6, 0x82a57e30
	if ctx.cr[6].eq {
	pc = 0x82A57E30; continue 'dispatch;
	}
	pc = 0x82A57E08; continue 'dispatch;
            }
            0x82A57E08 => {
    //   block [0x82A57E08..0x82A57E20)
	// 82A57E08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A57E0C: 419A0014  beq cr6, 0x82a57e20
	if ctx.cr[6].eq {
	pc = 0x82A57E20; continue 'dispatch;
	}
	// 82A57E10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A57E14: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A57E1C: 48251665  bl 0x82ca9480
	ctx.lr = 0x82A57E20;
	sub_82CA9480(ctx, base);
	pc = 0x82A57E20; continue 'dispatch;
            }
            0x82A57E20 => {
    //   block [0x82A57E20..0x82A57E30)
	// 82A57E20: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A57E24: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A57E28: 4082FFE0  bne 0x82a57e08
	if !ctx.cr[0].eq {
	pc = 0x82A57E08; continue 'dispatch;
	}
	// 82A57E2C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A57E30; continue 'dispatch;
            }
            0x82A57E30 => {
    //   block [0x82A57E30..0x82A57E50)
	// 82A57E30: 83B80008  lwz r29, 8(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57E34: 574A2834  slwi r10, r26, 5
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A57E38: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A57E3C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A57E40: 419A0040  beq cr6, 0x82a57e80
	if ctx.cr[6].eq {
	pc = 0x82A57E80; continue 'dispatch;
	}
	// 82A57E44: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A57E48: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A57E4C: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82A57E50; continue 'dispatch;
            }
            0x82A57E50 => {
    //   block [0x82A57E50..0x82A57E68)
	// 82A57E50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A57E54: 419A0014  beq cr6, 0x82a57e68
	if ctx.cr[6].eq {
	pc = 0x82A57E68; continue 'dispatch;
	}
	// 82A57E58: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57E5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A57E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A57E64: 4825161D  bl 0x82ca9480
	ctx.lr = 0x82A57E68;
	sub_82CA9480(ctx, base);
	pc = 0x82A57E68; continue 'dispatch;
            }
            0x82A57E68 => {
    //   block [0x82A57E68..0x82A57E80)
	// 82A57E68: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A57E6C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A57E70: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A57E74: 409AFFDC  bne cr6, 0x82a57e50
	if !ctx.cr[6].eq {
	pc = 0x82A57E50; continue 'dispatch;
	}
	// 82A57E78: 83B80008  lwz r29, 8(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A57E7C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A57E80; continue 'dispatch;
            }
            0x82A57E80 => {
    //   block [0x82A57E80..0x82A57E9C)
	// 82A57E80: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A57E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A57E88: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A57E8C: 7FEAD214  add r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A57E90: 419A000C  beq cr6, 0x82a57e9c
	if ctx.cr[6].eq {
	pc = 0x82A57E9C; continue 'dispatch;
	}
	// 82A57E94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A57E98: 4B7C3EA1  bl 0x8221bd38
	ctx.lr = 0x82A57E9C;
	sub_8221BD38(ctx, base);
	pc = 0x82A57E9C; continue 'dispatch;
            }
            0x82A57E9C => {
    //   block [0x82A57E9C..0x82A57EC0)
	// 82A57E9C: 572B2834  slwi r11, r25, 5
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A57EA0: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A57EA4: 57EA2834  slwi r10, r31, 5
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A57EA8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A57EAC: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A57EB0: 9178000C  stw r11, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A57EB4: 91580008  stw r10, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A57EB8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A57EBC: 4825158C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57EC0 => {
    //   block [0x82A57EC0..0x82A57EE8)
	// 82A57EC0: 836100DC  lwz r27, 0xdc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A57EC4: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A57EC8: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A57ECC: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A57ED0: 409800B8  bge cr6, 0x82a57f88
	if !ctx.cr[6].lt {
	pc = 0x82A57F88; continue 'dispatch;
	}
	// 82A57ED4: 575C2834  slwi r28, r26, 5
	ctx.r[28].u32 = ctx.r[26].u32.wrapping_shl(5);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A57ED8: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A57EDC: 7FDCDA14  add r30, r28, r27
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82A57EE0: 419A0034  beq cr6, 0x82a57f14
	if ctx.cr[6].eq {
	pc = 0x82A57F14; continue 'dispatch;
	}
	// 82A57EE4: 7FBCF050  subf r29, r28, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	pc = 0x82A57EE8; continue 'dispatch;
            }
            0x82A57EE8 => {
    //   block [0x82A57EE8..0x82A57F00)
	// 82A57EE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A57EEC: 419A0014  beq cr6, 0x82a57f00
	if ctx.cr[6].eq {
	pc = 0x82A57F00; continue 'dispatch;
	}
	// 82A57EF0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57EF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A57EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A57EFC: 48251585  bl 0x82ca9480
	ctx.lr = 0x82A57F00;
	sub_82CA9480(ctx, base);
	pc = 0x82A57F00; continue 'dispatch;
            }
            0x82A57F00 => {
    //   block [0x82A57F00..0x82A57F14)
	// 82A57F00: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82A57F04: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A57F08: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A57F0C: 409AFFDC  bne cr6, 0x82a57ee8
	if !ctx.cr[6].eq {
	pc = 0x82A57EE8; continue 'dispatch;
	}
	// 82A57F10: 83F80008  lwz r31, 8(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A57F14; continue 'dispatch;
            }
            0x82A57F14 => {
    //   block [0x82A57F14..0x82A57F24)
	// 82A57F14: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A57F18: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A57F1C: 7FCAD051  subf. r30, r10, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A57F20: 4182002C  beq 0x82a57f4c
	if ctx.cr[0].eq {
	pc = 0x82A57F4C; continue 'dispatch;
	}
	pc = 0x82A57F24; continue 'dispatch;
            }
            0x82A57F24 => {
    //   block [0x82A57F24..0x82A57F3C)
	// 82A57F24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A57F28: 419A0014  beq cr6, 0x82a57f3c
	if ctx.cr[6].eq {
	pc = 0x82A57F3C; continue 'dispatch;
	}
	// 82A57F2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A57F30: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A57F38: 48251549  bl 0x82ca9480
	ctx.lr = 0x82A57F3C;
	sub_82CA9480(ctx, base);
	pc = 0x82A57F3C; continue 'dispatch;
            }
            0x82A57F3C => {
    //   block [0x82A57F3C..0x82A57F4C)
	// 82A57F3C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A57F40: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A57F44: 4082FFE0  bne 0x82a57f24
	if !ctx.cr[0].eq {
	pc = 0x82A57F24; continue 'dispatch;
	}
	// 82A57F48: 83F80008  lwz r31, 8(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A57F4C; continue 'dispatch;
            }
            0x82A57F4C => {
    //   block [0x82A57F4C..0x82A57F64)
	// 82A57F4C: 7D7CFA14  add r11, r28, r31
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 82A57F50: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A57F54: 7FDC5850  subf r30, r28, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A57F58: 91780008  stw r11, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A57F5C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A57F60: 419A00C8  beq cr6, 0x82a58028
	if ctx.cr[6].eq {
	pc = 0x82A58028; continue 'dispatch;
	}
	pc = 0x82A57F64; continue 'dispatch;
            }
            0x82A57F64 => {
    //   block [0x82A57F64..0x82A57F88)
	// 82A57F64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A57F68: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57F6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A57F70: 48251511  bl 0x82ca9480
	ctx.lr = 0x82A57F74;
	sub_82CA9480(ctx, base);
	// 82A57F74: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A57F78: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A57F7C: 409AFFE8  bne cr6, 0x82a57f64
	if !ctx.cr[6].eq {
	pc = 0x82A57F64; continue 'dispatch;
	}
	// 82A57F80: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A57F84: 482514C4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A57F88 => {
    //   block [0x82A57F88..0x82A57FA0)
	// 82A57F88: 575A2834  slwi r26, r26, 5
	ctx.r[26].u32 = ctx.r[26].u32.wrapping_shl(5);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82A57F8C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A57F90: 7F9AF850  subf r28, r26, r31
	ctx.r[28].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	// 82A57F94: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82A57F98: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A57F9C: 419A002C  beq cr6, 0x82a57fc8
	if ctx.cr[6].eq {
	pc = 0x82A57FC8; continue 'dispatch;
	}
	pc = 0x82A57FA0; continue 'dispatch;
            }
            0x82A57FA0 => {
    //   block [0x82A57FA0..0x82A57FB8)
	// 82A57FA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A57FA4: 419A0014  beq cr6, 0x82a57fb8
	if ctx.cr[6].eq {
	pc = 0x82A57FB8; continue 'dispatch;
	}
	// 82A57FA8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57FAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A57FB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A57FB4: 482514CD  bl 0x82ca9480
	ctx.lr = 0x82A57FB8;
	sub_82CA9480(ctx, base);
	pc = 0x82A57FB8; continue 'dispatch;
            }
            0x82A57FB8 => {
    //   block [0x82A57FB8..0x82A57FC8)
	// 82A57FB8: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82A57FBC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A57FC0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A57FC4: 409AFFDC  bne cr6, 0x82a57fa0
	if !ctx.cr[6].eq {
	pc = 0x82A57FA0; continue 'dispatch;
	}
	pc = 0x82A57FC8; continue 'dispatch;
            }
            0x82A57FC8 => {
    //   block [0x82A57FC8..0x82A57FDC)
	// 82A57FC8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A57FCC: 93D80008  stw r30, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A57FD0: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A57FD4: 419A0028  beq cr6, 0x82a57ffc
	if ctx.cr[6].eq {
	pc = 0x82A57FFC; continue 'dispatch;
	}
	// 82A57FD8: 7FDAFA14  add r30, r26, r31
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	pc = 0x82A57FDC; continue 'dispatch;
            }
            0x82A57FDC => {
    //   block [0x82A57FDC..0x82A57FFC)
	// 82A57FDC: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 82A57FE0: 3BDEFFE0  addi r30, r30, -0x20
	ctx.r[30].s64 = ctx.r[30].s64 + -32;
	// 82A57FE4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A57FE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A57FEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A57FF0: 48251491  bl 0x82ca9480
	ctx.lr = 0x82A57FF4;
	sub_82CA9480(ctx, base);
	// 82A57FF4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A57FF8: 409AFFE4  bne cr6, 0x82a57fdc
	if !ctx.cr[6].eq {
	pc = 0x82A57FDC; continue 'dispatch;
	}
	pc = 0x82A57FFC; continue 'dispatch;
            }
            0x82A57FFC => {
    //   block [0x82A57FFC..0x82A5800C)
	// 82A57FFC: 7FDADA14  add r30, r26, r27
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82A58000: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A58004: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A58008: 419A0020  beq cr6, 0x82a58028
	if ctx.cr[6].eq {
	pc = 0x82A58028; continue 'dispatch;
	}
	pc = 0x82A5800C; continue 'dispatch;
            }
            0x82A5800C => {
    //   block [0x82A5800C..0x82A58028)
	// 82A5800C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A58010: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A58014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58018: 48251469  bl 0x82ca9480
	ctx.lr = 0x82A5801C;
	sub_82CA9480(ctx, base);
	// 82A5801C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A58020: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A58024: 409AFFE8  bne cr6, 0x82a5800c
	if !ctx.cr[6].eq {
	pc = 0x82A5800C; continue 'dispatch;
	}
	pc = 0x82A58028; continue 'dispatch;
            }
            0x82A58028 => {
    //   block [0x82A58028..0x82A58030)
	// 82A58028: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A5802C: 4825141C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58030 size=232
    let mut pc: u32 = 0x82A58030;
    'dispatch: loop {
        match pc {
            0x82A58030 => {
    //   block [0x82A58030..0x82A58068)
	// 82A58030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58034: 482513D1  bl 0x82ca9404
	ctx.lr = 0x82A58038;
	sub_82CA93D0(ctx, base);
	// 82A58038: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5803C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A58040: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A58044: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A58048: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5804C: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A58050: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58054: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58058: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5805C: 419A000C  beq cr6, 0x82a58068
	if ctx.cr[6].eq {
	pc = 0x82A58068; continue 'dispatch;
	}
	// 82A58060: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A58064: 419A0008  beq cr6, 0x82a5806c
	if ctx.cr[6].eq {
	pc = 0x82A5806C; continue 'dispatch;
	}
	pc = 0x82A58068; continue 'dispatch;
            }
            0x82A58068 => {
    //   block [0x82A58068..0x82A5806C)
	// 82A58068: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5806C; continue 'dispatch;
            }
            0x82A5806C => {
    //   block [0x82A5806C..0x82A58090)
	// 82A5806C: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A58070: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A58074: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82A58078: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5807C: 409A0044  bne cr6, 0x82a580c0
	if !ctx.cr[6].eq {
	pc = 0x82A580C0; continue 'dispatch;
	}
	// 82A58080: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A58084: 419A000C  beq cr6, 0x82a58090
	if ctx.cr[6].eq {
	pc = 0x82A58090; continue 'dispatch;
	}
	// 82A58088: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5808C: 419A0008  beq cr6, 0x82a58094
	if ctx.cr[6].eq {
	pc = 0x82A58094; continue 'dispatch;
	}
	pc = 0x82A58090; continue 'dispatch;
            }
            0x82A58090 => {
    //   block [0x82A58090..0x82A58094)
	// 82A58090: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A58094; continue 'dispatch;
            }
            0x82A58094 => {
    //   block [0x82A58094..0x82A580C0)
	// 82A58094: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A58098: 409A0028  bne cr6, 0x82a580c0
	if !ctx.cr[6].eq {
	pc = 0x82A580C0; continue 'dispatch;
	}
	// 82A5809C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A580A0: 4BFFF1E9  bl 0x82a57288
	ctx.lr = 0x82A580A4;
	sub_82A57288(ctx, base);
	// 82A580A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A580A8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A580AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A580B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A580B4: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A580B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A580BC: 48251398  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A580C0 => {
    //   block [0x82A580C0..0x82A580D0)
	// 82A580C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A580C4: 419A000C  beq cr6, 0x82a580d0
	if ctx.cr[6].eq {
	pc = 0x82A580D0; continue 'dispatch;
	}
	// 82A580C8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A580CC: 419A0008  beq cr6, 0x82a580d4
	if ctx.cr[6].eq {
	pc = 0x82A580D4; continue 'dispatch;
	}
	pc = 0x82A580D0; continue 'dispatch;
            }
            0x82A580D0 => {
    //   block [0x82A580D0..0x82A580D4)
	// 82A580D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A580D4; continue 'dispatch;
            }
            0x82A580D4 => {
    //   block [0x82A580D4..0x82A58108)
	// 82A580D4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A580D8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A580DC: 419A002C  beq cr6, 0x82a58108
	if ctx.cr[6].eq {
	pc = 0x82A58108; continue 'dispatch;
	}
	// 82A580E0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A580E4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A580E8: 4B8BCA41  bl 0x82314b28
	ctx.lr = 0x82A580EC;
	sub_82314B28(ctx, base);
	// 82A580EC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A580F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A580F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A580F8: 480007E1  bl 0x82a588d8
	ctx.lr = 0x82A580FC;
	sub_82A588D8(ctx, base);
	// 82A580FC: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A58100: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A58104: 4BFFFFBC  b 0x82a580c0
	pc = 0x82A580C0; continue 'dispatch;
            }
            0x82A58108 => {
    //   block [0x82A58108..0x82A58118)
	// 82A58108: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A5810C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A58110: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A58114: 48251340  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58118 size=344
    let mut pc: u32 = 0x82A58118;
    'dispatch: loop {
        match pc {
            0x82A58118 => {
    //   block [0x82A58118..0x82A58150)
	// 82A58118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5811C: 482512E5  bl 0x82ca9400
	ctx.lr = 0x82A58120;
	sub_82CA93D0(ctx, base);
	// 82A58120: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A58124: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A58128: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A5812C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A58130: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A58134: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A58138: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5813C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58140: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58144: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58148: 409A0044  bne cr6, 0x82a5818c
	if !ctx.cr[6].eq {
	pc = 0x82A5818C; continue 'dispatch;
	}
	// 82A5814C: E93B0000  ld r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	pc = 0x82A58150; continue 'dispatch;
            }
            0x82A58150 => {
    //   block [0x82A58150..0x82A58168)
	// 82A58150: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A58154: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82A58158: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82A5815C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82A58160: 41980008  blt cr6, 0x82a58168
	if ctx.cr[6].lt {
	pc = 0x82A58168; continue 'dispatch;
	}
	// 82A58164: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A58168; continue 'dispatch;
            }
            0x82A58168 => {
    //   block [0x82A58168..0x82A5817C)
	// 82A58168: 555D063E  clrlwi r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5816C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A58170: 419A000C  beq cr6, 0x82a5817c
	if ctx.cr[6].eq {
	pc = 0x82A5817C; continue 'dispatch;
	}
	// 82A58174: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58178: 48000008  b 0x82a58180
	pc = 0x82A58180; continue 'dispatch;
            }
            0x82A5817C => {
    //   block [0x82A5817C..0x82A58180)
	// 82A5817C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A58180; continue 'dispatch;
            }
            0x82A58180 => {
    //   block [0x82A58180..0x82A5818C)
	// 82A58180: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58184: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58188: 419AFFC8  beq cr6, 0x82a58150
	if ctx.cr[6].eq {
	pc = 0x82A58150; continue 'dispatch;
	}
	pc = 0x82A5818C; continue 'dispatch;
            }
            0x82A5818C => {
    //   block [0x82A5818C..0x82A581EC)
	// 82A5818C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A58190: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A58194: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A58198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5819C: 419A0054  beq cr6, 0x82a581f0
	if ctx.cr[6].eq {
	pc = 0x82A581F0; continue 'dispatch;
	}
	// 82A581A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A581A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A581A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A581AC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A581B0: 409A003C  bne cr6, 0x82a581ec
	if !ctx.cr[6].eq {
	pc = 0x82A581EC; continue 'dispatch;
	}
	// 82A581B4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A581B8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A581BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A581C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A581C4: 480000AD  bl 0x82a58270
	ctx.lr = 0x82A581C8;
	sub_82A58270(ctx, base);
	// 82A581C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A581CC: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A581D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A581D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A581D8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A581DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A581E0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A581E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A581E8: 48251268  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A581EC => {
    //   block [0x82A581EC..0x82A581F0)
	// 82A581EC: 4B9261F5  bl 0x8237e3e0
	ctx.lr = 0x82A581F0;
	sub_8237E3E0(ctx, base);
	pc = 0x82A581F0; continue 'dispatch;
            }
            0x82A581F0 => {
    //   block [0x82A581F0..0x82A5820C)
	// 82A581F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A581F4: E95B0000  ld r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 82A581F8: E92B0010  ld r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82A581FC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A58200: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82A58204: 41980008  blt cr6, 0x82a5820c
	if ctx.cr[6].lt {
	pc = 0x82A5820C; continue 'dispatch;
	}
	// 82A58208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A5820C; continue 'dispatch;
            }
            0x82A5820C => {
    //   block [0x82A5820C..0x82A58254)
	// 82A5820C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A58210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58214: 419A0040  beq cr6, 0x82a58254
	if ctx.cr[6].eq {
	pc = 0x82A58254; continue 'dispatch;
	}
	// 82A58218: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A5821C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A58220: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A58224: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A58228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5822C: 48000045  bl 0x82a58270
	ctx.lr = 0x82A58230;
	sub_82A58270(ctx, base);
	// 82A58230: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A58234: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A58238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5823C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58240: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58244: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A58248: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5824C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A58250: 48251200  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A58254 => {
    //   block [0x82A58254..0x82A58270)
	// 82A58254: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A58258: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5825C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58260: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A58264: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A58268: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5826C: 482511E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58270 size=672
    let mut pc: u32 = 0x82A58270;
    'dispatch: loop {
        match pc {
            0x82A58270 => {
    //   block [0x82A58270..0x82A582E8)
	// 82A58270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58274: 48251185  bl 0x82ca93f8
	ctx.lr = 0x82A58278;
	sub_82CA93D0(ctx, base);
	// 82A58278: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5827C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A58280: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82A58284: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A58288: 6169FFFE  ori r9, r11, 0xfffe
	ctx.r[9].u64 = ctx.r[11].u64 | 65534;
	// 82A5828C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A58290: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58294: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A58298: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82A5829C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A582A0: 41980048  blt cr6, 0x82a582e8
	if ctx.cr[6].lt {
	pc = 0x82A582E8; continue 'dispatch;
	}
	// 82A582A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A582A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A582AC: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82A582B0: 4B899C91  bl 0x822f1f40
	ctx.lr = 0x82A582B4;
	sub_822F1F40(ctx, base);
	// 82A582B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A582B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A582BC: 4B899AF5  bl 0x822f1db0
	ctx.lr = 0x82A582C0;
	sub_822F1DB0(ctx, base);
	// 82A582C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A582C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A582C8: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82A582CC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A582D0: 4B899B51  bl 0x822f1e20
	ctx.lr = 0x82A582D4;
	sub_822F1E20(ctx, base);
	// 82A582D4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A582D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A582DC: 4BC23505  bl 0x8267b7e0
	ctx.lr = 0x82A582E0;
	sub_8267B7E0(ctx, base);
	// 82A582E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A582E4: 4B71952D  bl 0x82171810
	ctx.lr = 0x82A582E8;
	sub_82171810(ctx, base);
	pc = 0x82A582E8; continue 'dispatch;
            }
            0x82A582E8 => {
    //   block [0x82A582E8..0x82A58334)
	// 82A582E8: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A582EC: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A582F0: 4B7C6F69  bl 0x8221f258
	ctx.lr = 0x82A582F4;
	sub_8221F258(ctx, base);
	// 82A582F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A582F8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A582FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A58300: 419A0058  beq cr6, 0x82a58358
	if ctx.cr[6].eq {
	pc = 0x82A58358; continue 'dispatch;
	}
	// 82A58304: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A58308: 397C0010  addi r11, r28, 0x10
	ctx.r[11].s64 = ctx.r[28].s64 + 16;
	// 82A5830C: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A58310: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A58314: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82A58318: F97C0010  std r11, 0x10(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82A5831C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58320: 915C0018  stw r10, 0x18(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A58324: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A58328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5832C: 917C001C  stw r11, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A58330: 419A0020  beq cr6, 0x82a58350
	if ctx.cr[6].eq {
	pc = 0x82A58350; continue 'dispatch;
	}
	pc = 0x82A58334; continue 'dispatch;
            }
            0x82A58334 => {
    //   block [0x82A58334..0x82A58350)
	// 82A58334: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A58338: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5833C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A58340: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A58344: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A58348: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5834C: 4082FFE8  bne 0x82a58334
	if !ctx.cr[0].eq {
	pc = 0x82A58334; continue 'dispatch;
	}
	pc = 0x82A58350; continue 'dispatch;
            }
            0x82A58350 => {
    //   block [0x82A58350..0x82A58358)
	// 82A58350: 9B3C0020  stb r25, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82A58354: 9B3C0021  stb r25, 0x21(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(33 as u32), ctx.r[25].u8 ) };
	pc = 0x82A58358; continue 'dispatch;
            }
            0x82A58358 => {
    //   block [0x82A58358..0x82A58388)
	// 82A58358: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5835C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58360: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A58364: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A58368: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5836C: 409A001C  bne cr6, 0x82a58388
	if !ctx.cr[6].eq {
	pc = 0x82A58388; continue 'dispatch;
	}
	// 82A58370: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A58374: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58378: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A5837C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58380: 938A0008  stw r28, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A58384: 48000044  b 0x82a583c8
	pc = 0x82A583C8; continue 'dispatch;
            }
            0x82A58388 => {
    //   block [0x82A58388..0x82A583B0)
	// 82A58388: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A5838C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58390: 419A0020  beq cr6, 0x82a583b0
	if ctx.cr[6].eq {
	pc = 0x82A583B0; continue 'dispatch;
	}
	// 82A58394: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A58398: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5839C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A583A0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A583A4: 409A0024  bne cr6, 0x82a583c8
	if !ctx.cr[6].eq {
	pc = 0x82A583C8; continue 'dispatch;
	}
	// 82A583A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A583AC: 4800001C  b 0x82a583c8
	pc = 0x82A583C8; continue 'dispatch;
            }
            0x82A583B0 => {
    //   block [0x82A583B0..0x82A583C8)
	// 82A583B0: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A583B4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A583B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A583BC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A583C0: 409A0008  bne cr6, 0x82a583c8
	if !ctx.cr[6].eq {
	pc = 0x82A583C8; continue 'dispatch;
	}
	// 82A583C4: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82A583C8; continue 'dispatch;
            }
            0x82A583C8 => {
    //   block [0x82A583C8..0x82A583E4)
	// 82A583C8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A583CC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A583D0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A583D4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A583D8: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A583DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A583E0: 409A0110  bne cr6, 0x82a584f0
	if !ctx.cr[6].eq {
	pc = 0x82A584F0; continue 'dispatch;
	}
	pc = 0x82A583E4; continue 'dispatch;
            }
            0x82A583E4 => {
    //   block [0x82A583E4..0x82A5842C)
	// 82A583E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A583E8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A583EC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A583F0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A583F4: 409A0078  bne cr6, 0x82a5846c
	if !ctx.cr[6].eq {
	pc = 0x82A5846C; continue 'dispatch;
	}
	// 82A583F8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A583FC: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58400: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A58404: 409A0028  bne cr6, 0x82a5842c
	if !ctx.cr[6].eq {
	pc = 0x82A5842C; continue 'dispatch;
	}
	// 82A58408: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A5840C: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58410: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58414: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58418: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5841C: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82A58420: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58424: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58428: 480000B4  b 0x82a584dc
	pc = 0x82A584DC; continue 'dispatch;
            }
            0x82A5842C => {
    //   block [0x82A5842C..0x82A58444)
	// 82A5842C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58430: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A58434: 409A0010  bne cr6, 0x82a58444
	if !ctx.cr[6].eq {
	pc = 0x82A58444; continue 'dispatch;
	}
	// 82A58438: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A5843C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A58440: 4BE59441  bl 0x828b1880
	ctx.lr = 0x82A58444;
	sub_828B1880(ctx, base);
	pc = 0x82A58444; continue 'dispatch;
            }
            0x82A58444 => {
    //   block [0x82A58444..0x82A5846C)
	// 82A58444: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58448: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A5844C: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58450: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58454: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58458: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82A5845C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58460: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58464: 4B8BB695  bl 0x82313af8
	ctx.lr = 0x82A58468;
	sub_82313AF8(ctx, base);
	// 82A58468: 48000074  b 0x82a584dc
	pc = 0x82A584DC; continue 'dispatch;
            }
            0x82A5846C => {
    //   block [0x82A5846C..0x82A584A0)
	// 82A5846C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58470: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58474: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A58478: 409A0028  bne cr6, 0x82a584a0
	if !ctx.cr[6].eq {
	pc = 0x82A584A0; continue 'dispatch;
	}
	// 82A5847C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58480: 9BC90020  stb r30, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58484: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58488: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5848C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58490: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82A58494: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58498: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5849C: 48000040  b 0x82a584dc
	pc = 0x82A584DC; continue 'dispatch;
            }
            0x82A584A0 => {
    //   block [0x82A584A0..0x82A584B8)
	// 82A584A0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A584A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A584A8: 409A0010  bne cr6, 0x82a584b8
	if !ctx.cr[6].eq {
	pc = 0x82A584B8; continue 'dispatch;
	}
	// 82A584AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A584B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A584B4: 4B8BB645  bl 0x82313af8
	ctx.lr = 0x82A584B8;
	sub_82313AF8(ctx, base);
	pc = 0x82A584B8; continue 'dispatch;
            }
            0x82A584B8 => {
    //   block [0x82A584B8..0x82A584DC)
	// 82A584B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A584C0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A584C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584C8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584CC: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82A584D0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584D4: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584D8: 4BE593A9  bl 0x828b1880
	ctx.lr = 0x82A584DC;
	sub_828B1880(ctx, base);
	pc = 0x82A584DC; continue 'dispatch;
            }
            0x82A584DC => {
    //   block [0x82A584DC..0x82A584F0)
	// 82A584DC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A584E4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A584E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A584EC: 419AFEF8  beq cr6, 0x82a583e4
	if ctx.cr[6].eq {
	pc = 0x82A583E4; continue 'dispatch;
	}
	pc = 0x82A584F0; continue 'dispatch;
            }
            0x82A584F0 => {
    //   block [0x82A584F0..0x82A58510)
	// 82A584F0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A584F4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A584F8: 93980004  stw r28, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A584FC: 93780000  stw r27, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A58500: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58504: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58508: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A5850C: 48250F3C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58510 size=852
    let mut pc: u32 = 0x82A58510;
    'dispatch: loop {
        match pc {
            0x82A58510 => {
    //   block [0x82A58510..0x82A5854C)
	// 82A58510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58514: 48250EE5  bl 0x82ca93f8
	ctx.lr = 0x82A58518;
	sub_82CA93D0(ctx, base);
	// 82A58518: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5851C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A58520: 83460000  lwz r26, 0(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58524: 83260004  lwz r25, 4(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58528: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A5852C: 83060008  lwz r24, 8(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58530: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 82A58534: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A58538: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5853C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58540: 409A000C  bne cr6, 0x82a5854c
	if !ctx.cr[6].eq {
	pc = 0x82A5854C; continue 'dispatch;
	}
	// 82A58544: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A58548: 48000010  b 0x82a58558
	pc = 0x82A58558; continue 'dispatch;
            }
            0x82A5854C => {
    //   block [0x82A5854C..0x82A58558)
	// 82A5854C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A58550: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A58554: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A58558; continue 'dispatch;
            }
            0x82A58558 => {
    //   block [0x82A58558..0x82A5858C)
	// 82A58558: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5855C: 419A0300  beq cr6, 0x82a5885c
	if ctx.cr[6].eq {
	pc = 0x82A5885C; continue 'dispatch;
	}
	// 82A58560: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58564: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 82A58568: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A5856C: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 82A58570: 7D67DBD6  divw r11, r7, r27
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	// 82A58574: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A58578: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5857C: 40980010  bge cr6, 0x82a5858c
	if !ctx.cr[6].lt {
	pc = 0x82A5858C; continue 'dispatch;
	}
	// 82A58580: 4BFEEF49  bl 0x82a474c8
	ctx.lr = 0x82A58584;
	sub_82A474C8(ctx, base);
	// 82A58584: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A58588: 48250EC0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5858C => {
    //   block [0x82A5858C..0x82A585B0)
	// 82A5858C: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A58590: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A58594: 40980158  bge cr6, 0x82a586ec
	if !ctx.cr[6].lt {
	pc = 0x82A586EC; continue 'dispatch;
	}
	// 82A58598: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5859C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A585A0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A585A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A585A8: 41980008  blt cr6, 0x82a585b0
	if ctx.cr[6].lt {
	pc = 0x82A585B0; continue 'dispatch;
	}
	// 82A585AC: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A585B0; continue 'dispatch;
            }
            0x82A585B0 => {
    //   block [0x82A585B0..0x82A585BC)
	// 82A585B0: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A585B4: 40980008  bge cr6, 0x82a585bc
	if !ctx.cr[6].lt {
	pc = 0x82A585BC; continue 'dispatch;
	}
	// 82A585B8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	pc = 0x82A585BC; continue 'dispatch;
            }
            0x82A585BC => {
    //   block [0x82A585BC..0x82A585E0)
	// 82A585BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A585C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A585C4: 4B8CADED  bl 0x823233b0
	ctx.lr = 0x82A585C8;
	sub_823233B0(ctx, base);
	// 82A585C8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A585CC: 80E100BC  lwz r7, 0xbc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A585D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A585D4: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A585D8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82A585DC: 419A0034  beq cr6, 0x82a58610
	if ctx.cr[6].eq {
	pc = 0x82A58610; continue 'dispatch;
	}
	pc = 0x82A585E0; continue 'dispatch;
            }
            0x82A585E0 => {
    //   block [0x82A585E0..0x82A58600)
	// 82A585E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A585E4: 419A001C  beq cr6, 0x82a58600
	if ctx.cr[6].eq {
	pc = 0x82A58600; continue 'dispatch;
	}
	// 82A585E8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A585EC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A585F0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A585F4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A585F8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A585FC: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82A58600; continue 'dispatch;
            }
            0x82A58600 => {
    //   block [0x82A58600..0x82A58610)
	// 82A58600: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A58604: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A58608: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A5860C: 409AFFD4  bne cr6, 0x82a585e0
	if !ctx.cr[6].eq {
	pc = 0x82A585E0; continue 'dispatch;
	}
	pc = 0x82A58610; continue 'dispatch;
            }
            0x82A58610 => {
    //   block [0x82A58610..0x82A58620)
	// 82A58610: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82A58614: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A58618: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5861C: 419A0024  beq cr6, 0x82a58640
	if ctx.cr[6].eq {
	pc = 0x82A58640; continue 'dispatch;
	}
	pc = 0x82A58620; continue 'dispatch;
            }
            0x82A58620 => {
    //   block [0x82A58620..0x82A58634)
	// 82A58620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58624: 419A0010  beq cr6, 0x82a58634
	if ctx.cr[6].eq {
	pc = 0x82A58634; continue 'dispatch;
	}
	// 82A58628: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5862C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82A58630: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x82A58634; continue 'dispatch;
            }
            0x82A58634 => {
    //   block [0x82A58634..0x82A58640)
	// 82A58634: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A58638: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A5863C: 4082FFE4  bne 0x82a58620
	if !ctx.cr[0].eq {
	pc = 0x82A58620; continue 'dispatch;
	}
	pc = 0x82A58640; continue 'dispatch;
            }
            0x82A58640 => {
    //   block [0x82A58640..0x82A58668)
	// 82A58640: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A58644: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58648: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A5864C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A58650: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A58654: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A58658: 419A0040  beq cr6, 0x82a58698
	if ctx.cr[6].eq {
	pc = 0x82A58698; continue 'dispatch;
	}
	// 82A5865C: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A58660: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A58664: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	pc = 0x82A58668; continue 'dispatch;
            }
            0x82A58668 => {
    //   block [0x82A58668..0x82A58688)
	// 82A58668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5866C: 419A001C  beq cr6, 0x82a58688
	if ctx.cr[6].eq {
	pc = 0x82A58688; continue 'dispatch;
	}
	// 82A58670: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58674: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A58678: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5867C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A58680: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58684: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82A58688; continue 'dispatch;
            }
            0x82A58688 => {
    //   block [0x82A58688..0x82A58698)
	// 82A58688: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A5868C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A58690: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A58694: 409AFFD4  bne cr6, 0x82a58668
	if !ctx.cr[6].eq {
	pc = 0x82A58668; continue 'dispatch;
	}
	pc = 0x82A58698; continue 'dispatch;
            }
            0x82A58698 => {
    //   block [0x82A58698..0x82A586B8)
	// 82A58698: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5869C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A586A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A586A4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A586A8: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A586AC: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A586B0: 419A0008  beq cr6, 0x82a586b8
	if ctx.cr[6].eq {
	pc = 0x82A586B8; continue 'dispatch;
	}
	// 82A586B4: 4B7C3685  bl 0x8221bd38
	ctx.lr = 0x82A586B8;
	sub_8221BD38(ctx, base);
	pc = 0x82A586B8; continue 'dispatch;
            }
            0x82A586B8 => {
    //   block [0x82A586B8..0x82A586EC)
	// 82A586B8: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A586BC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A586C0: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A586C4: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A586C8: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82A586CC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A586D0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A586D4: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A586D8: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82A586DC: 90FE0008  stw r7, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A586E0: 911E000C  stw r8, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A586E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A586E8: 48250D60  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A586EC => {
    //   block [0x82A586EC..0x82A5871C)
	// 82A586EC: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A586F0: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A586F4: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A586F8: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A586FC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A58700: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A58704: 409800B4  bge cr6, 0x82a587b8
	if !ctx.cr[6].lt {
	pc = 0x82A587B8; continue 'dispatch;
	}
	// 82A58708: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A5870C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A58710: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82A58714: 419A0038  beq cr6, 0x82a5874c
	if ctx.cr[6].eq {
	pc = 0x82A5874C; continue 'dispatch;
	}
	// 82A58718: 7D275050  subf r9, r7, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	pc = 0x82A5871C; continue 'dispatch;
            }
            0x82A5871C => {
    //   block [0x82A5871C..0x82A5873C)
	// 82A5871C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58720: 419A001C  beq cr6, 0x82a5873c
	if ctx.cr[6].eq {
	pc = 0x82A5873C; continue 'dispatch;
	}
	// 82A58724: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58728: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A5872C: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58730: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A58734: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58738: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x82A5873C; continue 'dispatch;
            }
            0x82A5873C => {
    //   block [0x82A5873C..0x82A5874C)
	// 82A5873C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82A58740: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A58744: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A58748: 409AFFD4  bne cr6, 0x82a5871c
	if !ctx.cr[6].eq {
	pc = 0x82A5871C; continue 'dispatch;
	}
	pc = 0x82A5874C; continue 'dispatch;
            }
            0x82A5874C => {
    //   block [0x82A5874C..0x82A58760)
	// 82A5874C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58750: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A58754: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 82A58758: 7D28F851  subf. r9, r8, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A5875C: 41820024  beq 0x82a58780
	if ctx.cr[0].eq {
	pc = 0x82A58780; continue 'dispatch;
	}
	pc = 0x82A58760; continue 'dispatch;
            }
            0x82A58760 => {
    //   block [0x82A58760..0x82A58774)
	// 82A58760: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58764: 419A0010  beq cr6, 0x82a58774
	if ctx.cr[6].eq {
	pc = 0x82A58774; continue 'dispatch;
	}
	// 82A58768: 934A0000  stw r26, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5876C: 932A0004  stw r25, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82A58770: 930A0008  stw r24, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x82A58774; continue 'dispatch;
            }
            0x82A58774 => {
    //   block [0x82A58774..0x82A58780)
	// 82A58774: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A58778: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A5877C: 4082FFE4  bne 0x82a58760
	if !ctx.cr[0].eq {
	pc = 0x82A58760; continue 'dispatch;
	}
	pc = 0x82A58780; continue 'dispatch;
            }
            0x82A58780 => {
    //   block [0x82A58780..0x82A58798)
	// 82A58780: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58784: 7D275214  add r9, r7, r10
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82A58788: 7D474850  subf r10, r7, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A5878C: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A58790: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A58794: 419A00C8  beq cr6, 0x82a5885c
	if ctx.cr[6].eq {
	pc = 0x82A5885C; continue 'dispatch;
	}
	pc = 0x82A58798; continue 'dispatch;
            }
            0x82A58798 => {
    //   block [0x82A58798..0x82A587B8)
	// 82A58798: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5879C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82A587A0: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 82A587A4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A587A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A587AC: 409AFFEC  bne cr6, 0x82a58798
	if !ctx.cr[6].eq {
	pc = 0x82A58798; continue 'dispatch;
	}
	// 82A587B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A587B4: 48250C94  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A587B8 => {
    //   block [0x82A587B8..0x82A587D0)
	// 82A587B8: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A587BC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A587C0: 7D464050  subf r10, r6, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 82A587C4: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82A587C8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A587CC: 419A0034  beq cr6, 0x82a58800
	if ctx.cr[6].eq {
	pc = 0x82A58800; continue 'dispatch;
	}
	pc = 0x82A587D0; continue 'dispatch;
            }
            0x82A587D0 => {
    //   block [0x82A587D0..0x82A587F0)
	// 82A587D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A587D4: 419A001C  beq cr6, 0x82a587f0
	if ctx.cr[6].eq {
	pc = 0x82A587F0; continue 'dispatch;
	}
	// 82A587D8: 80A70000  lwz r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A587DC: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A587E0: 80870004  lwz r4, 4(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A587E4: 90890004  stw r4, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A587E8: 80670008  lwz r3, 8(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A587EC: 90690008  stw r3, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82A587F0; continue 'dispatch;
            }
            0x82A587F0 => {
    //   block [0x82A587F0..0x82A58800)
	// 82A587F0: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 82A587F4: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82A587F8: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A587FC: 409AFFD4  bne cr6, 0x82a587d0
	if !ctx.cr[6].eq {
	pc = 0x82A587D0; continue 'dispatch;
	}
	pc = 0x82A58800; continue 'dispatch;
            }
            0x82A58800 => {
    //   block [0x82A58800..0x82A58810)
	// 82A58800: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A58804: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A58808: 419A0030  beq cr6, 0x82a58838
	if ctx.cr[6].eq {
	pc = 0x82A58838; continue 'dispatch;
	}
	// 82A5880C: 7D265214  add r9, r6, r10
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	pc = 0x82A58810; continue 'dispatch;
            }
            0x82A58810 => {
    //   block [0x82A58810..0x82A58838)
	// 82A58810: 394AFFF4  addi r10, r10, -0xc
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	// 82A58814: 3929FFF4  addi r9, r9, -0xc
	ctx.r[9].s64 = ctx.r[9].s64 + -12;
	// 82A58818: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5881C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58820: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A58824: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58828: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A5882C: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58830: 90A90008  stw r5, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A58834: 409AFFDC  bne cr6, 0x82a58810
	if !ctx.cr[6].eq {
	pc = 0x82A58810; continue 'dispatch;
	}
	pc = 0x82A58838; continue 'dispatch;
            }
            0x82A58838 => {
    //   block [0x82A58838..0x82A58844)
	// 82A58838: 7D465A14  add r10, r6, r11
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A5883C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A58840: 419A001C  beq cr6, 0x82a5885c
	if ctx.cr[6].eq {
	pc = 0x82A5885C; continue 'dispatch;
	}
	pc = 0x82A58844; continue 'dispatch;
            }
            0x82A58844 => {
    //   block [0x82A58844..0x82A5885C)
	// 82A58844: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A58848: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82A5884C: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 82A58850: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A58854: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A58858: 409AFFEC  bne cr6, 0x82a58844
	if !ctx.cr[6].eq {
	pc = 0x82A58844; continue 'dispatch;
	}
	pc = 0x82A5885C; continue 'dispatch;
            }
            0x82A5885C => {
    //   block [0x82A5885C..0x82A58864)
	// 82A5885C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A58860: 48250BE8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58868 size=112
    let mut pc: u32 = 0x82A58868;
    'dispatch: loop {
        match pc {
            0x82A58868 => {
    //   block [0x82A58868..0x82A588BC)
	// 82A58868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5886C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A58870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A58874: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A58878: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5887C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A58880: 419A003C  beq cr6, 0x82a588bc
	if ctx.cr[6].eq {
	pc = 0x82A588BC; continue 'dispatch;
	}
	// 82A58884: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A58888: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A5888C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82A58890: 4098002C  bge cr6, 0x82a588bc
	if !ctx.cr[6].lt {
	pc = 0x82A588BC; continue 'dispatch;
	}
	// 82A58894: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A58898: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5889C: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82A588A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A588A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A588A8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A588AC: 4B899575  bl 0x822f1e20
	ctx.lr = 0x82A588B0;
	sub_822F1E20(ctx, base);
	// 82A588B0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A588B4: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82A588B8: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82A588BC; continue 'dispatch;
            }
            0x82A588BC => {
    //   block [0x82A588BC..0x82A588D8)
	// 82A588BC: 57E3083C  slwi r3, r31, 1
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A588C0: 4B7C6999  bl 0x8221f258
	ctx.lr = 0x82A588C4;
	sub_8221F258(ctx, base);
	// 82A588C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A588C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A588CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A588D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A588D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A588D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A588D8 size=1056
    let mut pc: u32 = 0x82A588D8;
    'dispatch: loop {
        match pc {
            0x82A588D8 => {
    //   block [0x82A588D8..0x82A58944)
	// 82A588D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A588DC: 48250B21  bl 0x82ca93fc
	ctx.lr = 0x82A588E0;
	sub_82CA93D0(ctx, base);
	// 82A588E0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A588E4: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82A588E8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A588EC: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A588F0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A588F4: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A588F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A588FC: 419A0048  beq cr6, 0x82a58944
	if ctx.cr[6].eq {
	pc = 0x82A58944; continue 'dispatch;
	}
	// 82A58900: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A58904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A58908: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82A5890C: 4B899635  bl 0x822f1f40
	ctx.lr = 0x82A58910;
	sub_822F1F40(ctx, base);
	// 82A58910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A58914: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A58918: 4B899499  bl 0x822f1db0
	ctx.lr = 0x82A5891C;
	sub_822F1DB0(ctx, base);
	// 82A5891C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A58920: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A58924: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82A58928: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A5892C: 4B8994F5  bl 0x822f1e20
	ctx.lr = 0x82A58930;
	sub_822F1E20(ctx, base);
	// 82A58930: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A58934: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A58938: 4BC22EA9  bl 0x8267b7e0
	ctx.lr = 0x82A5893C;
	sub_8267B7E0(ctx, base);
	// 82A5893C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A58940: 4B718ED1  bl 0x82171810
	ctx.lr = 0x82A58944;
	sub_82171810(ctx, base);
	pc = 0x82A58944; continue 'dispatch;
            }
            0x82A58944 => {
    //   block [0x82A58944..0x82A58968)
	// 82A58944: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A58948: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82A5894C: 4B8BC1DD  bl 0x82314b28
	ctx.lr = 0x82A58950;
	sub_82314B28(ctx, base);
	// 82A58950: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58954: 896A0021  lbz r11, 0x21(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5895C: 419A000C  beq cr6, 0x82a58968
	if ctx.cr[6].eq {
	pc = 0x82A58968; continue 'dispatch;
	}
	// 82A58960: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58964: 4800002C  b 0x82a58990
	pc = 0x82A58990; continue 'dispatch;
            }
            0x82A58968 => {
    //   block [0x82A58968..0x82A58980)
	// 82A58968: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5896C: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58970: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A58974: 419A000C  beq cr6, 0x82a58980
	if ctx.cr[6].eq {
	pc = 0x82A58980; continue 'dispatch;
	}
	// 82A58978: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82A5897C: 48000014  b 0x82a58990
	pc = 0x82A58990; continue 'dispatch;
            }
            0x82A58980 => {
    //   block [0x82A58980..0x82A58990)
	// 82A58980: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A58984: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A58988: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5898C: 409A00F0  bne cr6, 0x82a58a7c
	if !ctx.cr[6].eq {
	pc = 0x82A58A7C; continue 'dispatch;
	}
	pc = 0x82A58990; continue 'dispatch;
            }
            0x82A58990 => {
    //   block [0x82A58990..0x82A589A4)
	// 82A58990: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58994: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5899C: 409A0008  bne cr6, 0x82a589a4
	if !ctx.cr[6].eq {
	pc = 0x82A589A4; continue 'dispatch;
	}
	// 82A589A0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A589A4; continue 'dispatch;
            }
            0x82A589A4 => {
    //   block [0x82A589A4..0x82A589BC)
	// 82A589A4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A589A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A589AC: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A589B0: 409A000C  bne cr6, 0x82a589bc
	if !ctx.cr[6].eq {
	pc = 0x82A589BC; continue 'dispatch;
	}
	// 82A589B4: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A589B8: 4800001C  b 0x82a589d4
	pc = 0x82A589D4; continue 'dispatch;
            }
            0x82A589BC => {
    //   block [0x82A589BC..0x82A589D0)
	// 82A589BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A589C0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A589C4: 409A000C  bne cr6, 0x82a589d0
	if !ctx.cr[6].eq {
	pc = 0x82A589D0; continue 'dispatch;
	}
	// 82A589C8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A589CC: 48000008  b 0x82a589d4
	pc = 0x82A589D4; continue 'dispatch;
            }
            0x82A589D0 => {
    //   block [0x82A589D0..0x82A589D4)
	// 82A589D0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82A589D4; continue 'dispatch;
            }
            0x82A589D4 => {
    //   block [0x82A589D4..0x82A589F8)
	// 82A589D4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A589D8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A589DC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A589E0: 409A0044  bne cr6, 0x82a58a24
	if !ctx.cr[6].eq {
	pc = 0x82A58A24; continue 'dispatch;
	}
	// 82A589E4: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A589E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A589EC: 419A000C  beq cr6, 0x82a589f8
	if ctx.cr[6].eq {
	pc = 0x82A589F8; continue 'dispatch;
	}
	// 82A589F0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A589F4: 4800002C  b 0x82a58a20
	pc = 0x82A58A20; continue 'dispatch;
            }
            0x82A589F8 => {
    //   block [0x82A589F8..0x82A58A0C)
	// 82A589F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A589FC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A58A00: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58A04: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A58A08: 409A0018  bne cr6, 0x82a58a20
	if !ctx.cr[6].eq {
	pc = 0x82A58A20; continue 'dispatch;
	}
	pc = 0x82A58A0C; continue 'dispatch;
            }
            0x82A58A0C => {
    //   block [0x82A58A0C..0x82A58A20)
	// 82A58A0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A58A10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58A14: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58A18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A58A1C: 419AFFF0  beq cr6, 0x82a58a0c
	if ctx.cr[6].eq {
	pc = 0x82A58A0C; continue 'dispatch;
	}
	pc = 0x82A58A20; continue 'dispatch;
            }
            0x82A58A20 => {
    //   block [0x82A58A20..0x82A58A24)
	// 82A58A20: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A58A24; continue 'dispatch;
            }
            0x82A58A24 => {
    //   block [0x82A58A24..0x82A58A4C)
	// 82A58A24: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58A28: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58A2C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A58A30: 409A00E0  bne cr6, 0x82a58b10
	if !ctx.cr[6].eq {
	pc = 0x82A58B10; continue 'dispatch;
	}
	// 82A58A34: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58A3C: 419A0010  beq cr6, 0x82a58a4c
	if ctx.cr[6].eq {
	pc = 0x82A58A4C; continue 'dispatch;
	}
	// 82A58A40: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A58A44: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A58A48: 480000C8  b 0x82a58b10
	pc = 0x82A58B10; continue 'dispatch;
            }
            0x82A58A4C => {
    //   block [0x82A58A4C..0x82A58A60)
	// 82A58A4C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58A50: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A58A54: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58A58: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A58A5C: 409A0018  bne cr6, 0x82a58a74
	if !ctx.cr[6].eq {
	pc = 0x82A58A74; continue 'dispatch;
	}
	pc = 0x82A58A60; continue 'dispatch;
            }
            0x82A58A60 => {
    //   block [0x82A58A60..0x82A58A74)
	// 82A58A60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A58A64: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58A68: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58A6C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A58A70: 419AFFF0  beq cr6, 0x82a58a60
	if ctx.cr[6].eq {
	pc = 0x82A58A60; continue 'dispatch;
	}
	pc = 0x82A58A74; continue 'dispatch;
            }
            0x82A58A74 => {
    //   block [0x82A58A74..0x82A58A7C)
	// 82A58A74: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A58A78: 48000098  b 0x82a58b10
	pc = 0x82A58B10; continue 'dispatch;
            }
            0x82A58A7C => {
    //   block [0x82A58A7C..0x82A58A9C)
	// 82A58A7C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A58A80: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58A84: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A58A88: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58A8C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A58A90: 409A000C  bne cr6, 0x82a58a9c
	if !ctx.cr[6].eq {
	pc = 0x82A58A9C; continue 'dispatch;
	}
	// 82A58A94: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A58A98: 4800002C  b 0x82a58ac4
	pc = 0x82A58AC4; continue 'dispatch;
            }
            0x82A58A9C => {
    //   block [0x82A58A9C..0x82A58AB0)
	// 82A58A9C: 895C0021  lbz r10, 0x21(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58AA0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58AA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58AA8: 409A0008  bne cr6, 0x82a58ab0
	if !ctx.cr[6].eq {
	pc = 0x82A58AB0; continue 'dispatch;
	}
	// 82A58AAC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A58AB0; continue 'dispatch;
            }
            0x82A58AB0 => {
    //   block [0x82A58AB0..0x82A58AC4)
	// 82A58AB0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A58AB4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58AB8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A58ABC: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58AC0: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A58AC4; continue 'dispatch;
            }
            0x82A58AC4 => {
    //   block [0x82A58AC4..0x82A58ADC)
	// 82A58AC4: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58AC8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58ACC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A58AD0: 409A000C  bne cr6, 0x82a58adc
	if !ctx.cr[6].eq {
	pc = 0x82A58ADC; continue 'dispatch;
	}
	// 82A58AD4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A58AD8: 48000020  b 0x82a58af8
	pc = 0x82A58AF8; continue 'dispatch;
            }
            0x82A58ADC => {
    //   block [0x82A58ADC..0x82A58AF4)
	// 82A58ADC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58AE0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58AE4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A58AE8: 409A000C  bne cr6, 0x82a58af4
	if !ctx.cr[6].eq {
	pc = 0x82A58AF4; continue 'dispatch;
	}
	// 82A58AEC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A58AF0: 48000008  b 0x82a58af8
	pc = 0x82A58AF8; continue 'dispatch;
            }
            0x82A58AF4 => {
    //   block [0x82A58AF4..0x82A58AF8)
	// 82A58AF4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A58AF8; continue 'dispatch;
            }
            0x82A58AF8 => {
    //   block [0x82A58AF8..0x82A58B10)
	// 82A58AF8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58AFC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A58B00: 890B0020  lbz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B04: 893A0020  lbz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B08: 992B0020  stb r9, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 82A58B0C: 991A0020  stb r8, 0x20(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[8].u8 ) };
	pc = 0x82A58B10; continue 'dispatch;
            }
            0x82A58B10 => {
    //   block [0x82A58B10..0x82A58B34)
	// 82A58B10: 897A0020  lbz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B14: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A58B18: 409A0198  bne cr6, 0x82a58cb0
	if !ctx.cr[6].eq {
	pc = 0x82A58CB0; continue 'dispatch;
	}
	// 82A58B1C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58B20: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A58B24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58B28: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A58B2C: 419A0180  beq cr6, 0x82a58cac
	if ctx.cr[6].eq {
	pc = 0x82A58CAC; continue 'dispatch;
	}
	// 82A58B30: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82A58B34; continue 'dispatch;
            }
            0x82A58B34 => {
    //   block [0x82A58B34..0x82A58B74)
	// 82A58B34: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B38: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A58B3C: 409A0170  bne cr6, 0x82a58cac
	if !ctx.cr[6].eq {
	pc = 0x82A58CAC; continue 'dispatch;
	}
	// 82A58B40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58B44: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A58B48: 409A00A8  bne cr6, 0x82a58bf0
	if !ctx.cr[6].eq {
	pc = 0x82A58BF0; continue 'dispatch;
	}
	// 82A58B4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58B50: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58B58: 409A001C  bne cr6, 0x82a58b74
	if !ctx.cr[6].eq {
	pc = 0x82A58B74; continue 'dispatch;
	}
	// 82A58B5C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58B60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A58B64: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58B68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A58B6C: 4BE58D15  bl 0x828b1880
	ctx.lr = 0x82A58B70;
	sub_828B1880(ctx, base);
	// 82A58B70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A58B74; continue 'dispatch;
            }
            0x82A58B74 => {
    //   block [0x82A58B74..0x82A58BA0)
	// 82A58B74: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58B78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58B7C: 409A00C8  bne cr6, 0x82a58c44
	if !ctx.cr[6].eq {
	pc = 0x82A58C44; continue 'dispatch;
	}
	// 82A58B80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58B84: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B88: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A58B8C: 409A0014  bne cr6, 0x82a58ba0
	if !ctx.cr[6].eq {
	pc = 0x82A58BA0; continue 'dispatch;
	}
	// 82A58B90: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58B94: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58B98: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A58B9C: 419A00A4  beq cr6, 0x82a58c40
	if ctx.cr[6].eq {
	pc = 0x82A58C40; continue 'dispatch;
	}
	pc = 0x82A58BA0; continue 'dispatch;
            }
            0x82A58BA0 => {
    //   block [0x82A58BA0..0x82A58BCC)
	// 82A58BA0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58BA4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58BA8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A58BAC: 409A0020  bne cr6, 0x82a58bcc
	if !ctx.cr[6].eq {
	pc = 0x82A58BCC; continue 'dispatch;
	}
	// 82A58BB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58BB4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A58BB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A58BBC: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58BC0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58BC4: 4B8BAF35  bl 0x82313af8
	ctx.lr = 0x82A58BC8;
	sub_82313AF8(ctx, base);
	// 82A58BC8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A58BCC; continue 'dispatch;
            }
            0x82A58BCC => {
    //   block [0x82A58BCC..0x82A58BF0)
	// 82A58BCC: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58BD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A58BD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A58BD8: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82A58BDC: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58BE0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58BE4: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58BE8: 4BE58C99  bl 0x828b1880
	ctx.lr = 0x82A58BEC;
	sub_828B1880(ctx, base);
	// 82A58BEC: 480000C0  b 0x82a58cac
	pc = 0x82A58CAC; continue 'dispatch;
            }
            0x82A58BF0 => {
    //   block [0x82A58BF0..0x82A58C14)
	// 82A58BF0: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58BF8: 409A001C  bne cr6, 0x82a58c14
	if !ctx.cr[6].eq {
	pc = 0x82A58C14; continue 'dispatch;
	}
	// 82A58BFC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A58C04: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58C08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A58C0C: 4B8BAEED  bl 0x82313af8
	ctx.lr = 0x82A58C10;
	sub_82313AF8(ctx, base);
	// 82A58C10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A58C14; continue 'dispatch;
            }
            0x82A58C14 => {
    //   block [0x82A58C14..0x82A58C40)
	// 82A58C14: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A58C18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A58C1C: 409A0028  bne cr6, 0x82a58c44
	if !ctx.cr[6].eq {
	pc = 0x82A58C44; continue 'dispatch;
	}
	// 82A58C20: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58C24: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58C28: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A58C2C: 409A0034  bne cr6, 0x82a58c60
	if !ctx.cr[6].eq {
	pc = 0x82A58C60; continue 'dispatch;
	}
	// 82A58C30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58C34: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58C38: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A58C3C: 409A0024  bne cr6, 0x82a58c60
	if !ctx.cr[6].eq {
	pc = 0x82A58C60; continue 'dispatch;
	}
	pc = 0x82A58C40; continue 'dispatch;
            }
            0x82A58C40 => {
    //   block [0x82A58C40..0x82A58C44)
	// 82A58C40: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	pc = 0x82A58C44; continue 'dispatch;
            }
            0x82A58C44 => {
    //   block [0x82A58C44..0x82A58C60)
	// 82A58C44: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58C48: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82A58C4C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58C50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58C54: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A58C58: 409AFEDC  bne cr6, 0x82a58b34
	if !ctx.cr[6].eq {
	pc = 0x82A58B34; continue 'dispatch;
	}
	// 82A58C5C: 48000050  b 0x82a58cac
	pc = 0x82A58CAC; continue 'dispatch;
            }
            0x82A58C60 => {
    //   block [0x82A58C60..0x82A58C8C)
	// 82A58C60: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58C64: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58C68: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A58C6C: 409A0020  bne cr6, 0x82a58c8c
	if !ctx.cr[6].eq {
	pc = 0x82A58C8C; continue 'dispatch;
	}
	// 82A58C70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58C74: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A58C78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A58C7C: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58C80: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82A58C84: 4BE58BFD  bl 0x828b1880
	ctx.lr = 0x82A58C88;
	sub_828B1880(ctx, base);
	// 82A58C88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A58C8C; continue 'dispatch;
            }
            0x82A58C8C => {
    //   block [0x82A58C8C..0x82A58CAC)
	// 82A58C8C: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A58C90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A58C94: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A58C98: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82A58C9C: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58CA0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58CA4: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82A58CA8: 4B8BAE51  bl 0x82313af8
	ctx.lr = 0x82A58CAC;
	sub_82313AF8(ctx, base);
	pc = 0x82A58CAC; continue 'dispatch;
            }
            0x82A58CAC => {
    //   block [0x82A58CAC..0x82A58CB0)
	// 82A58CAC: 9BBC0020  stb r29, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	pc = 0x82A58CB0; continue 'dispatch;
            }
            0x82A58CB0 => {
    //   block [0x82A58CB0..0x82A58CE8)
	// 82A58CB0: 387A0018  addi r3, r26, 0x18
	ctx.r[3].s64 = ctx.r[26].s64 + 24;
	// 82A58CB4: 4B75EE65  bl 0x821b7b18
	ctx.lr = 0x82A58CB8;
	sub_821B7B18(ctx, base);
	// 82A58CB8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A58CBC: 4B7C307D  bl 0x8221bd38
	ctx.lr = 0x82A58CC0;
	sub_8221BD38(ctx, base);
	// 82A58CC0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58CC4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A58CC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58CCC: 419A001C  beq cr6, 0x82a58ce8
	if ctx.cr[6].eq {
	pc = 0x82A58CE8; continue 'dispatch;
	}
	// 82A58CD0: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A58CD4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82A58CD8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A58CDC: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A58CE0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A58CE4: 48250768  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A58CE8 => {
    //   block [0x82A58CE8..0x82A58CF8)
	// 82A58CE8: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A58CEC: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A58CF0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A58CF4: 48250758  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58CF8 size=212
    let mut pc: u32 = 0x82A58CF8;
    'dispatch: loop {
        match pc {
            0x82A58CF8 => {
    //   block [0x82A58CF8..0x82A58D48)
	// 82A58CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58CFC: 4825070D  bl 0x82ca9408
	ctx.lr = 0x82A58D00;
	sub_82CA93D0(ctx, base);
	// 82A58D00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A58D04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A58D08: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A58D0C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A58D10: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A58D14: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A58D18: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82A58D1C: 4B7C653D  bl 0x8221f258
	ctx.lr = 0x82A58D20;
	sub_8221F258(ctx, base);
	// 82A58D20: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A58D24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A58D28: 3BAB6CC8  addi r29, r11, 0x6cc8
	ctx.r[29].s64 = ctx.r[11].s64 + 27848;
	// 82A58D2C: 419A001C  beq cr6, 0x82a58d48
	if ctx.cr[6].eq {
	pc = 0x82A58D48; continue 'dispatch;
	}
	// 82A58D30: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A58D34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A58D38: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A58D3C: 9BC30010  stb r30, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82A58D40: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A58D44: 48000008  b 0x82a58d4c
	pc = 0x82A58D4C; continue 'dispatch;
            }
            0x82A58D48 => {
    //   block [0x82A58D48..0x82A58D4C)
	// 82A58D48: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A58D4C; continue 'dispatch;
            }
            0x82A58D4C => {
    //   block [0x82A58D4C..0x82A58D78)
	// 82A58D4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A58D50: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A58D54: 4B7C6505  bl 0x8221f258
	ctx.lr = 0x82A58D58;
	sub_8221F258(ctx, base);
	// 82A58D58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A58D5C: 419A001C  beq cr6, 0x82a58d78
	if ctx.cr[6].eq {
	pc = 0x82A58D78; continue 'dispatch;
	}
	// 82A58D60: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A58D64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A58D68: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A58D6C: 9BC30010  stb r30, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82A58D70: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A58D74: 48000008  b 0x82a58d7c
	pc = 0x82A58D7C; continue 'dispatch;
            }
            0x82A58D78 => {
    //   block [0x82A58D78..0x82A58D7C)
	// 82A58D78: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A58D7C; continue 'dispatch;
            }
            0x82A58D7C => {
    //   block [0x82A58D7C..0x82A58DCC)
	// 82A58D7C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A58D80: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58D84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58D88: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82A58D8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A58D90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A58D94: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A58D98: 48132A89  bl 0x82b8b820
	ctx.lr = 0x82A58D9C;
	sub_82B8B820(ctx, base);
	// 82A58D9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A58DA0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58DA4: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82A58DA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A58DAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A58DB0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A58DB4: 48132A6D  bl 0x82b8b820
	ctx.lr = 0x82A58DB8;
	sub_82B8B820(ctx, base);
	// 82A58DB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A58DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58DC0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A58DC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A58DC8: 48250690  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58DD0 size=112
    let mut pc: u32 = 0x82A58DD0;
    'dispatch: loop {
        match pc {
            0x82A58DD0 => {
    //   block [0x82A58DD0..0x82A58E10)
	// 82A58DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A58DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A58DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A58DE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A58DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A58DE8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82A58DEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A58DF0: 394BB00C  addi r10, r11, -0x4ff4
	ctx.r[10].s64 = ctx.r[11].s64 + -20468;
	// 82A58DF4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A58DF8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A58DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A58E00: 419A0010  beq cr6, 0x82a58e10
	if ctx.cr[6].eq {
	pc = 0x82A58E10; continue 'dispatch;
	}
	// 82A58E04: 4812E7C5  bl 0x82b875c8
	ctx.lr = 0x82A58E08;
	sub_82B875C8(ctx, base);
	// 82A58E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A58E0C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A58E10; continue 'dispatch;
            }
            0x82A58E10 => {
    //   block [0x82A58E10..0x82A58E28)
	// 82A58E10: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A58E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58E1C: 419A000C  beq cr6, 0x82a58e28
	if ctx.cr[6].eq {
	pc = 0x82A58E28; continue 'dispatch;
	}
	// 82A58E20: 4B7C2F19  bl 0x8221bd38
	ctx.lr = 0x82A58E24;
	sub_8221BD38(ctx, base);
	// 82A58E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A58E28; continue 'dispatch;
            }
            0x82A58E28 => {
    //   block [0x82A58E28..0x82A58E40)
	// 82A58E28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A58E2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A58E30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A58E34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A58E38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A58E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58E40 size=332
    let mut pc: u32 = 0x82A58E40;
    'dispatch: loop {
        match pc {
            0x82A58E40 => {
    //   block [0x82A58E40..0x82A58F74)
	// 82A58E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A58E48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A58E4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A58E50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A58E54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A58E58: 3BEB10AC  addi r31, r11, 0x10ac
	ctx.r[31].s64 = ctx.r[11].s64 + 4268;
	// 82A58E5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A58E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58E64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58E68: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58E6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A58E70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58E74: 481346ED  bl 0x82b8d560
	ctx.lr = 0x82A58E78;
	sub_82B8D560(ctx, base);
	// 82A58E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58E7C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A58E80: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A58E84: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58E88: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58E8C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A58E90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58E94: 481346CD  bl 0x82b8d560
	ctx.lr = 0x82A58E98;
	sub_82B8D560(ctx, base);
	// 82A58E98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58E9C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A58EA0: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A58EA4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58EA8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58EAC: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A58EB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58EB4: 481346AD  bl 0x82b8d560
	ctx.lr = 0x82A58EB8;
	sub_82B8D560(ctx, base);
	// 82A58EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58EBC: 481347E5  bl 0x82b8d6a0
	ctx.lr = 0x82A58EC0;
	sub_82B8D6A0(ctx, base);
	// 82A58EC0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A58EC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A58EC8: 3BEA10C0  addi r31, r10, 0x10c0
	ctx.r[31].s64 = ctx.r[10].s64 + 4288;
	// 82A58ECC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A58ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58ED4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58ED8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58EDC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A58EE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58EE4: 4813467D  bl 0x82b8d560
	ctx.lr = 0x82A58EE8;
	sub_82B8D560(ctx, base);
	// 82A58EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58EEC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A58EF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A58EF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58EF8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58EFC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A58F00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58F04: 4813465D  bl 0x82b8d560
	ctx.lr = 0x82A58F08;
	sub_82B8D560(ctx, base);
	// 82A58F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58F0C: 48134795  bl 0x82b8d6a0
	ctx.lr = 0x82A58F10;
	sub_82B8D6A0(ctx, base);
	// 82A58F10: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82A58F14: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A58F18: 3BE810D4  addi r31, r8, 0x10d4
	ctx.r[31].s64 = ctx.r[8].s64 + 4308;
	// 82A58F1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A58F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58F24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58F28: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58F2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A58F30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58F34: 4813462D  bl 0x82b8d560
	ctx.lr = 0x82A58F38;
	sub_82B8D560(ctx, base);
	// 82A58F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58F3C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A58F40: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A58F44: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A58F48: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A58F4C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A58F50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A58F54: 4813460D  bl 0x82b8d560
	ctx.lr = 0x82A58F58;
	sub_82B8D560(ctx, base);
	// 82A58F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A58F5C: 48134745  bl 0x82b8d6a0
	ctx.lr = 0x82A58F60;
	sub_82B8D6A0(ctx, base);
	// 82A58F60: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A58F64: 81676E58  lwz r11, 0x6e58(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28248 as u32) ) } as u64;
	// 82A58F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A58F6C: 409A0008  bne cr6, 0x82a58f74
	if !ctx.cr[6].eq {
	pc = 0x82A58F74; continue 'dispatch;
	}
	// 82A58F70: 48000239  bl 0x82a591a8
	ctx.lr = 0x82A58F74;
	sub_82A591A8(ctx, base);
	pc = 0x82A58F74; continue 'dispatch;
            }
            0x82A58F74 => {
    //   block [0x82A58F74..0x82A58F8C)
	// 82A58F74: 4800001D  bl 0x82a58f90
	ctx.lr = 0x82A58F78;
	sub_82A58F90(ctx, base);
	// 82A58F78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A58F7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A58F80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A58F84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A58F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A58F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A58F90 size=536
    let mut pc: u32 = 0x82A58F90;
    'dispatch: loop {
        match pc {
            0x82A58F90 => {
    //   block [0x82A58F90..0x82A59024)
	// 82A58F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A58F94: 4825045D  bl 0x82ca93f0
	ctx.lr = 0x82A58F98;
	sub_82CA93D0(ctx, base);
	// 82A58F98: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A58F9C: 4806685D  bl 0x82abf7f8
	ctx.lr = 0x82A58FA0;
	sub_82ABF7F8(ctx, base);
	// 82A58FA0: 48066989  bl 0x82abf928
	ctx.lr = 0x82A58FA4;
	sub_82ABF928(ctx, base);
	// 82A58FA4: 48066AB5  bl 0x82abfa58
	ctx.lr = 0x82A58FA8;
	sub_82ABFA58(ctx, base);
	// 82A58FA8: 48066BE1  bl 0x82abfb88
	ctx.lr = 0x82A58FAC;
	sub_82ABFB88(ctx, base);
	// 82A58FAC: 48066D0D  bl 0x82abfcb8
	ctx.lr = 0x82A58FB0;
	sub_82ABFCB8(ctx, base);
	// 82A58FB0: 48066E39  bl 0x82abfde8
	ctx.lr = 0x82A58FB4;
	sub_82ABFDE8(ctx, base);
	// 82A58FB4: 48066F65  bl 0x82abff18
	ctx.lr = 0x82A58FB8;
	sub_82ABFF18(ctx, base);
	// 82A58FB8: 48067091  bl 0x82ac0048
	ctx.lr = 0x82A58FBC;
	sub_82AC0048(ctx, base);
	// 82A58FBC: 480671BD  bl 0x82ac0178
	ctx.lr = 0x82A58FC0;
	sub_82AC0178(ctx, base);
	// 82A58FC0: 480672E9  bl 0x82ac02a8
	ctx.lr = 0x82A58FC4;
	sub_82AC02A8(ctx, base);
	// 82A58FC4: 48067415  bl 0x82ac03d8
	ctx.lr = 0x82A58FC8;
	sub_82AC03D8(ctx, base);
	// 82A58FC8: 48067541  bl 0x82ac0508
	ctx.lr = 0x82A58FCC;
	sub_82AC0508(ctx, base);
	// 82A58FCC: 4806766D  bl 0x82ac0638
	ctx.lr = 0x82A58FD0;
	sub_82AC0638(ctx, base);
	// 82A58FD0: 48067799  bl 0x82ac0768
	ctx.lr = 0x82A58FD4;
	sub_82AC0768(ctx, base);
	// 82A58FD4: 480678C5  bl 0x82ac0898
	ctx.lr = 0x82A58FD8;
	sub_82AC0898(ctx, base);
	// 82A58FD8: 480679F1  bl 0x82ac09c8
	ctx.lr = 0x82A58FDC;
	sub_82AC09C8(ctx, base);
	// 82A58FDC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A58FE0: 386B5844  addi r3, r11, 0x5844
	ctx.r[3].s64 = ctx.r[11].s64 + 22596;
	// 82A58FE4: 480BF42D  bl 0x82b18410
	ctx.lr = 0x82A58FE8;
	sub_82B18410(ctx, base);
	// 82A58FE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A58FEC: 4BA55675  bl 0x824ae660
	ctx.lr = 0x82A58FF0;
	sub_824AE660(ctx, base);
	// 82A58FF0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A58FF4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A58FF8: 3ACBF810  addi r22, r11, -0x7f0
	ctx.r[22].s64 = ctx.r[11].s64 + -2032;
	// 82A58FFC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A59000: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A59004: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A59008: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A5900C: 7F98E378  mr r24, r28
	ctx.r[24].u64 = ctx.r[28].u64;
	// 82A59010: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 82A59014: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 82A59018: 3B4A6CB0  addi r26, r10, 0x6cb0
	ctx.r[26].s64 = ctx.r[10].s64 + 27824;
	// 82A5901C: 3B296C98  addi r25, r9, 0x6c98
	ctx.r[25].s64 = ctx.r[9].s64 + 27800;
	// 82A59020: 3AE86C84  addi r23, r8, 0x6c84
	ctx.r[23].s64 = ctx.r[8].s64 + 27780;
	pc = 0x82A59024; continue 'dispatch;
            }
            0x82A59024 => {
    //   block [0x82A59024..0x82A59054)
	// 82A59024: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A59028: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A5902C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A59030: 4B7D3EA1  bl 0x8222ced0
	ctx.lr = 0x82A59034;
	sub_8222CED0(ctx, base);
	// 82A59034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A59038: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5903C: 4B8AF71D  bl 0x82308758
	ctx.lr = 0x82A59040;
	sub_82308758(ctx, base);
	// 82A59040: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A59044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A59048: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82A5904C: 4B76D71D  bl 0x821c6768
	ctx.lr = 0x82A59050;
	sub_821C6768(ctx, base);
	// 82A59050: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82A59054; continue 'dispatch;
            }
            0x82A59054 => {
    //   block [0x82A59054..0x82A59078)
	// 82A59054: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A59058: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5905C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A59060: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A59064: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A59068: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5906C: 4082FFE8  bne 0x82a59054
	if !ctx.cr[0].eq {
	pc = 0x82A59054; continue 'dispatch;
	}
	// 82A59070: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82A59074: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A59078; continue 'dispatch;
            }
            0x82A59078 => {
    //   block [0x82A59078..0x82A590A8)
	// 82A59078: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A5907C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A59080: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A59084: 4B7D3E4D  bl 0x8222ced0
	ctx.lr = 0x82A59088;
	sub_8222CED0(ctx, base);
	// 82A59088: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A5908C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A59090: 4B8AF6C9  bl 0x82308758
	ctx.lr = 0x82A59094;
	sub_82308758(ctx, base);
	// 82A59094: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A59098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5909C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A590A0: 4B76D6C9  bl 0x821c6768
	ctx.lr = 0x82A590A4;
	sub_821C6768(ctx, base);
	// 82A590A4: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82A590A8; continue 'dispatch;
            }
            0x82A590A8 => {
    //   block [0x82A590A8..0x82A590CC)
	// 82A590A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A590AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A590B0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A590B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A590B8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A590BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A590C0: 4082FFE8  bne 0x82a590a8
	if !ctx.cr[0].eq {
	pc = 0x82A590A8; continue 'dispatch;
	}
	// 82A590C4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A590C8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x82A590CC; continue 'dispatch;
            }
            0x82A590CC => {
    //   block [0x82A590CC..0x82A590FC)
	// 82A590CC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A590D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A590D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A590D8: 4B7D3DF9  bl 0x8222ced0
	ctx.lr = 0x82A590DC;
	sub_8222CED0(ctx, base);
	// 82A590DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A590E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A590E4: 4B8AF675  bl 0x82308758
	ctx.lr = 0x82A590E8;
	sub_82308758(ctx, base);
	// 82A590E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A590EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A590F0: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A590F4: 4B76D675  bl 0x821c6768
	ctx.lr = 0x82A590F8;
	sub_821C6768(ctx, base);
	// 82A590F8: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x82A590FC; continue 'dispatch;
            }
            0x82A590FC => {
    //   block [0x82A590FC..0x82A591A8)
	// 82A590FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A59100: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A59104: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A59108: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5910C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A59110: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A59114: 4082FFE8  bne 0x82a590fc
	if !ctx.cr[0].eq {
	pc = 0x82A590FC; continue 'dispatch;
	}
	// 82A59118: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5911C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82A59120: 48067D61  bl 0x82ac0e80
	ctx.lr = 0x82A59124;
	sub_82AC0E80(ctx, base);
	// 82A59124: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A59128: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A5912C: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 82A59130: E8C70004  ld r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	// 82A59134: F8C10068  std r6, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u64 ) };
	// 82A59138: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A5913C: 90BE0000  stw r5, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A59140: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A59144: 4198FF88  blt cr6, 0x82a590cc
	if ctx.cr[6].lt {
	pc = 0x82A590CC; continue 'dispatch;
	}
	// 82A59148: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82A5914C: 2F1B0002  cmpwi cr6, r27, 2
	ctx.cr[6].compare_i32(ctx.r[27].s32, 2, &mut ctx.xer);
	// 82A59150: 4198FF28  blt cr6, 0x82a59078
	if ctx.cr[6].lt {
	pc = 0x82A59078; continue 'dispatch;
	}
	// 82A59154: 39760040  addi r11, r22, 0x40
	ctx.r[11].s64 = ctx.r[22].s64 + 64;
	// 82A59158: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82A5915C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A59160: 4198FEC4  blt cr6, 0x82a59024
	if ctx.cr[6].lt {
	pc = 0x82A59024; continue 'dispatch;
	}
	// 82A59164: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82A59168: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5916C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A59170: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82A59174: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A59178: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A5917C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A59180: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A59184: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A59188: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A5918C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82A59190: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A59194: 4B8AFA8D  bl 0x82308c20
	ctx.lr = 0x82A59198;
	sub_82308C20(ctx, base);
	// 82A59198: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5919C: 4B7C2B9D  bl 0x8221bd38
	ctx.lr = 0x82A591A0;
	sub_8221BD38(ctx, base);
	// 82A591A0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A591A4: 4825029C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A591A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A591A8 size=176
    let mut pc: u32 = 0x82A591A8;
    'dispatch: loop {
        match pc {
            0x82A591A8 => {
    //   block [0x82A591A8..0x82A591E0)
	// 82A591A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A591AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A591B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A591B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A591B8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A591BC: 4B7C609D  bl 0x8221f258
	ctx.lr = 0x82A591C0;
	sub_8221F258(ctx, base);
	// 82A591C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A591C4: 419A001C  beq cr6, 0x82a591e0
	if ctx.cr[6].eq {
	pc = 0x82A591E0; continue 'dispatch;
	}
	// 82A591C8: 3C800008  lis r4, 8
	ctx.r[4].s64 = 524288;
	// 82A591CC: 4BFFFB2D  bl 0x82a58cf8
	ctx.lr = 0x82A591D0;
	sub_82A58CF8(ctx, base);
	// 82A591D0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A591D4: 3BEB6E50  addi r31, r11, 0x6e50
	ctx.r[31].s64 = ctx.r[11].s64 + 28240;
	// 82A591D8: 906B6E50  stw r3, 0x6e50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28240 as u32), ctx.r[3].u32 ) };
	// 82A591DC: 48000014  b 0x82a591f0
	pc = 0x82A591F0; continue 'dispatch;
            }
            0x82A591E0 => {
    //   block [0x82A591E0..0x82A591F0)
	// 82A591E0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A591E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A591E8: 3BEA6E50  addi r31, r10, 0x6e50
	ctx.r[31].s64 = ctx.r[10].s64 + 28240;
	// 82A591EC: 916A6E50  stw r11, 0x6e50(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28240 as u32), ctx.r[11].u32 ) };
	pc = 0x82A591F0; continue 'dispatch;
            }
            0x82A591F0 => {
    //   block [0x82A591F0..0x82A59230)
	// 82A591F0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A591F4: 4B7C6065  bl 0x8221f258
	ctx.lr = 0x82A591F8;
	sub_8221F258(ctx, base);
	// 82A591F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A591FC: 419A0034  beq cr6, 0x82a59230
	if ctx.cr[6].eq {
	pc = 0x82A59230; continue 'dispatch;
	}
	// 82A59200: 3C800001  lis r4, 1
	ctx.r[4].s64 = 65536;
	// 82A59204: 60842C00  ori r4, r4, 0x2c00
	ctx.r[4].u64 = ctx.r[4].u64 | 11264;
	// 82A59208: 4BFFFAF1  bl 0x82a58cf8
	ctx.lr = 0x82A5920C;
	sub_82A58CF8(ctx, base);
	// 82A5920C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A59210: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A59214: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A59218: 916A6E58  stw r11, 0x6e58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28248 as u32), ctx.r[11].u32 ) };
	// 82A5921C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A59220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A59224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A59228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5922C: 4E800020  blr
	return;
            }
            0x82A59230 => {
    //   block [0x82A59230..0x82A59258)
	// 82A59230: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A59234: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A59238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5923C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A59240: 91496E58  stw r10, 0x6e58(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28248 as u32), ctx.r[10].u32 ) };
	// 82A59244: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A59248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5924C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A59250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A59254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A59258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A59258 size=148
    let mut pc: u32 = 0x82A59258;
    'dispatch: loop {
        match pc {
            0x82A59258 => {
    //   block [0x82A59258..0x82A59280)
	// 82A59258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5925C: 482501AD  bl 0x82ca9408
	ctx.lr = 0x82A59260;
	sub_82CA93D0(ctx, base);
	// 82A59260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A59264: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A59268: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A5926C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A59270: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82A59274: 3BCA6E50  addi r30, r10, 0x6e50
	ctx.r[30].s64 = ctx.r[10].s64 + 28240;
	// 82A59278: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82A5927C: 91696E58  stw r11, 0x6e58(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28248 as u32), ctx.r[11].u32 ) };
	pc = 0x82A59280; continue 'dispatch;
            }
            0x82A59280 => {
    //   block [0x82A59280..0x82A592AC)
	// 82A59280: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A59284: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A59288: 419A0050  beq cr6, 0x82a592d8
	if ctx.cr[6].eq {
	pc = 0x82A592D8; continue 'dispatch;
	}
	// 82A5928C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A59290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A59294: 419A0018  beq cr6, 0x82a592ac
	if ctx.cr[6].eq {
	pc = 0x82A592AC; continue 'dispatch;
	}
	// 82A59298: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5929C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A592A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A592A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A592A8: 4E800421  bctrl
	ctx.lr = 0x82A592AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A592AC => {
    //   block [0x82A592AC..0x82A592CC)
	// 82A592AC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A592B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A592B4: 419A0018  beq cr6, 0x82a592cc
	if ctx.cr[6].eq {
	pc = 0x82A592CC; continue 'dispatch;
	}
	// 82A592B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A592BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A592C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A592C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A592C8: 4E800421  bctrl
	ctx.lr = 0x82A592CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A592CC => {
    //   block [0x82A592CC..0x82A592D8)
	// 82A592CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A592D0: 4B7C2A69  bl 0x8221bd38
	ctx.lr = 0x82A592D4;
	sub_8221BD38(ctx, base);
	// 82A592D4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A592D8; continue 'dispatch;
            }
            0x82A592D8 => {
    //   block [0x82A592D8..0x82A592EC)
	// 82A592D8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A592DC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A592E0: 4082FFA0  bne 0x82a59280
	if !ctx.cr[0].eq {
	pc = 0x82A59280; continue 'dispatch;
	}
	// 82A592E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A592E8: 48250170  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A592F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A592F0 size=812
    let mut pc: u32 = 0x82A592F0;
    'dispatch: loop {
        match pc {
            0x82A592F0 => {
    //   block [0x82A592F0..0x82A59614)
	// 82A592F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A592F4: 482500F5  bl 0x82ca93e8
	ctx.lr = 0x82A592F8;
	sub_82CA93D0(ctx, base);
	// 82A592F8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A592FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A59300: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A59304: 419A0310  beq cr6, 0x82a59614
	if ctx.cr[6].eq {
	pc = 0x82A59614; continue 'dispatch;
	}
	// 82A59308: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 82A5930C: 41980308  blt cr6, 0x82a59614
	if ctx.cr[6].lt {
	pc = 0x82A59614; continue 'dispatch;
	}
	// 82A59310: 81240024  lwz r9, 0x24(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A59314: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 82A59318: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5931C: 419802F8  blt cr6, 0x82a59614
	if ctx.cr[6].lt {
	pc = 0x82A59614; continue 'dispatch;
	}
	// 82A59320: 3BE9FFFF  addi r31, r9, -1
	ctx.r[31].s64 = ctx.r[9].s64 + -1;
	// 82A59324: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A59328: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5932C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A59330: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82A59334: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A59338: 7D3C3838  and r28, r9, r7
	ctx.r[28].u64 = ctx.r[9].u64 & ctx.r[7].u64;
	// 82A5933C: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82A59340: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 82A59344: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A59348: 39060001  addi r8, r6, 1
	ctx.r[8].s64 = ctx.r[6].s64 + 1;
	// 82A5934C: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 82A59350: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82A59354: 7CC61838  and r6, r6, r3
	ctx.r[6].u64 = ctx.r[6].u64 & ctx.r[3].u64;
	// 82A59358: 7D1D1838  and r29, r8, r3
	ctx.r[29].u64 = ctx.r[8].u64 & ctx.r[3].u64;
	// 82A5935C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A59360: 7F574838  and r23, r26, r9
	ctx.r[23].u64 = ctx.r[26].u64 & ctx.r[9].u64;
	// 82A59364: 3B09FFFF  addi r24, r9, -1
	ctx.r[24].s64 = ctx.r[9].s64 + -1;
	// 82A59368: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82A5936C: 54C92834  slwi r9, r6, 5
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A59370: 7C873838  and r7, r4, r7
	ctx.r[7].u64 = ctx.r[4].u64 & ctx.r[7].u64;
	// 82A59374: 57A62834  slwi r6, r29, 5
	ctx.r[6].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A59378: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82A5937C: 579C2834  slwi r28, r28, 5
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A59380: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 82A59384: 54E72834  slwi r7, r7, 5
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A59388: 7CC62A14  add r6, r6, r5
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 82A5938C: 5503003E  slwi r3, r8, 0
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A59390: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	pc = 0x82A59614; continue 'dispatch;
            }
            0x82A59614 => {
    //   block [0x82A59614..0x82A5961C)
	// 82A59614: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A59618: 4824FE20  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A59620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A59620 size=400
    let mut pc: u32 = 0x82A59620;
    'dispatch: loop {
        match pc {
            0x82A59620 => {
    //   block [0x82A59620..0x82A597B0)
	// 82A59620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A59624: 4824FDE1  bl 0x82ca9404
	ctx.lr = 0x82A59628;
	sub_82CA93D0(ctx, base);
	// 82A59628: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5962C: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82A59630: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82A59634: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 82A59638: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82A5963C: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82A59640: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A59644: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 82A59648: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A5964C: 938100E0  stw r28, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 82A59650: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A59654: 9B8100E4  stb r28, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[28].u8 ) };
	// 82A59658: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A5965C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A597B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A597B0 size=424
    let mut pc: u32 = 0x82A597B0;
    'dispatch: loop {
        match pc {
            0x82A597B0 => {
    //   block [0x82A597B0..0x82A59958)
	// 82A597B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A597B4: 4824FC51  bl 0x82ca9404
	ctx.lr = 0x82A597B8;
	sub_82CA93D0(ctx, base);
	// 82A597B8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A597BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A597C0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A597C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A597C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A597CC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A597D0: 4B7D2A41  bl 0x8222c210
	ctx.lr = 0x82A597D4;
	sub_8222C210(ctx, base);
	// 82A597D4: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82A597D8: 4B7AF339  bl 0x82208b10
	ctx.lr = 0x82A597DC;
	sub_82208B10(ctx, base);
	// 82A597DC: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82A597E0: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 82A597E4: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82A597E8: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82A597EC: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A597F0: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82A597F4: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 82A597F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A597FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A59800: 938100E0  stw r28, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 82A59804: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 82A59808: 9B8100E4  stb r28, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[28].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A59958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A59958 size=1144
    let mut pc: u32 = 0x82A59958;
    'dispatch: loop {
        match pc {
            0x82A59958 => {
    //   block [0x82A59958..0x82A59980)
	// 82A59958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5995C: 4824FA89  bl 0x82ca93e4
	ctx.lr = 0x82A59960;
	sub_82CA93D0(ctx, base);
	// 82A59960: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82A59964: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A59968: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82A5996C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A59970: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 82A59974: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A59978: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82A5997C: 409A0014  bne cr6, 0x82a59990
	if !ctx.cr[6].eq {
	pc = 0x82A59990; continue 'dispatch;
	}
	pc = 0x82A59980; continue 'dispatch;
            }
            0x82A59980 => {
    //   block [0x82A59980..0x82A59990)
	// 82A59980: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A59984: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 82A59988: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82A5998C: 4824FAA8  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A59990 => {
    //   block [0x82A59990..0x82A599E0)
	// 82A59990: 817400B0  lwz r11, 0xb0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A59994: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A59998: 4198FFE8  blt cr6, 0x82a59980
	if ctx.cr[6].lt {
	pc = 0x82A59980; continue 'dispatch;
	}
	// 82A5999C: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 82A599A0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A599A4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A599A8: 3AA00008  li r21, 8
	ctx.r[21].s64 = 8;
	// 82A599AC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A599B0: 817F0364  lwz r11, 0x364(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A599B4: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 82A599B8: 814A10D4  lwz r10, 0x10d4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4308 as u32) ) } as u64;
	// 82A599BC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A599C0: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82A599C4: E8A60010  ld r5, 0x10(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82A599C8: 64A40008  oris r4, r5, 8
	ctx.r[4].u64 = ctx.r[5].u64 | 524288;
	// 82A599CC: F8860010  std r4, 0x10(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 82A599D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A599D4: 396B0190  addi r11, r11, 0x190
	ctx.r[11].s64 = ctx.r[11].s64 + 400;
	// 82A599D8: 914770B8  stw r10, 0x70b8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82A599DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A599E0; continue 'dispatch;
            }
            0x82A599E0 => {
    //   block [0x82A599E0..0x82A59A40)
	// 82A599E0: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A599E4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A599E8: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A599EC: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A599F0: 4200FFF0  bdnz 0x82a599e0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A599E0; continue 'dispatch;
	}
	// 82A599F4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A599F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A599FC: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82A59A00: 4B7C1191  bl 0x8221ab90
	ctx.lr = 0x82A59A04;
	sub_8221AB90(ctx, base);
	// 82A59A04: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 82A59A08: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A59A0C: 4B8172C5  bl 0x82270cd0
	ctx.lr = 0x82A59A10;
	sub_82270CD0(ctx, base);
	// 82A59A10: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A59A14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A59A18: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 82A59A1C: 797E0004  rldicr r30, r11, 0, 0
	ctx.r[30].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 82A59A20: 2B3E0000  cmpldi cr6, r30, 0
	ctx.cr[6].compare_u64(ctx.r[30].u64, 0, &mut ctx.xer);
	// 82A59A24: 419A001C  beq cr6, 0x82a59a40
	if ctx.cr[6].eq {
	pc = 0x82A59A40; continue 'dispatch;
	}
	// 82A59A28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A59A2C: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A59A30: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A59A34: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A59A38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A59A3C: 4B7C0E45  bl 0x8221a880
	ctx.lr = 0x82A59A40;
	sub_8221A880(ctx, base);
	pc = 0x82A59A40; continue 'dispatch;
            }
            0x82A59A40 => {
    //   block [0x82A59A40..0x82A59A88)
	// 82A59A40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A59A44: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A59A48: 4B817289  bl 0x82270cd0
	ctx.lr = 0x82A59A4C;
	sub_82270CD0(ctx, base);
	// 82A59A4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A59A50: 38600162  li r3, 0x162
	ctx.r[3].s64 = 354;
	// 82A59A54: 4B76E6BD  bl 0x821c8110
	ctx.lr = 0x82A59A58;
	sub_821C8110(ctx, base);
	// 82A59A58: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A59A5C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A59A60: 4B817271  bl 0x82270cd0
	ctx.lr = 0x82A59A64;
	sub_82270CD0(ctx, base);
	// 82A59A64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A59A68: 2B3E0000  cmpldi cr6, r30, 0
	ctx.cr[6].compare_u64(ctx.r[30].u64, 0, &mut ctx.xer);
	// 82A59A6C: 419A001C  beq cr6, 0x82a59a88
	if ctx.cr[6].eq {
	pc = 0x82A59A88; continue 'dispatch;
	}
	// 82A59A70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A59A74: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A59A78: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A59A7C: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A59A80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A59A84: 4B7C0DFD  bl 0x8221a880
	ctx.lr = 0x82A59A88;
	sub_8221A880(ctx, base);
	pc = 0x82A59A88; continue 'dispatch;
            }
            0x82A59A88 => {
    //   block [0x82A59A88..0x82A59DD0)
	// 82A59A88: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 82A59A8C: 38600126  li r3, 0x126
	ctx.r[3].s64 = 294;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A59DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A59DD0 size=2628
    let mut pc: u32 = 0x82A59DD0;
    'dispatch: loop {
        match pc {
            0x82A59DD0 => {
    //   block [0x82A59DD0..0x82A59E18)
	// 82A59DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A59DD4: 4824F60D  bl 0x82ca93e0
	ctx.lr = 0x82A59DD8;
	sub_82CA93D0(ctx, base);
	// 82A59DD8: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A59DDC: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82A59DE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A59DE4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A59DE8: 3AEB9490  addi r23, r11, -0x6b70
	ctx.r[23].s64 = ctx.r[11].s64 + -27504;
	// 82A59DEC: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 82A59DF0: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A59DF4: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 82A59DF8: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 82A59DFC: 3ACB0018  addi r22, r11, 0x18
	ctx.r[22].s64 = ctx.r[11].s64 + 24;
	// 82A59E00: C017FFF4  lfs f0, -0xc(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A59E04: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82A59E08: C1AB0024  lfs f13, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A59E0C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A59E10: 41990008  bgt cr6, 0x82a59e18
	if ctx.cr[6].gt {
	pc = 0x82A59E18; continue 'dispatch;
	}
	// 82A59E14: 7E589378  mr r24, r18
	ctx.r[24].u64 = ctx.r[18].u64;
	pc = 0x82A59E18; continue 'dispatch;
            }
            0x82A59E18 => {
    //   block [0x82A59E18..0x82A5A814)
	// 82A59E18: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82A59E1C: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 82A59E20: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 82A59E24: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 82A59E28: 39010120  addi r8, r1, 0x120
	ctx.r[8].s64 = ctx.r[1].s64 + 288;
	// 82A59E2C: 92410130  stw r18, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[18].u32 ) };
	// 82A59E30: 9A410134  stb r18, 0x134(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[18].u8 ) };
	// 82A59E34: 388B002C  addi r4, r11, 0x2c
	ctx.r[4].s64 = ctx.r[11].s64 + 44;
	// 82A59E38: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 82A59E3C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5A818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5A818 size=424
    let mut pc: u32 = 0x82A5A818;
    'dispatch: loop {
        match pc {
            0x82A5A818 => {
    //   block [0x82A5A818..0x82A5A9C0)
	// 82A5A818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5A81C: 4824EBE9  bl 0x82ca9404
	ctx.lr = 0x82A5A820;
	sub_82CA93D0(ctx, base);
	// 82A5A820: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5A824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5A828: 38600032  li r3, 0x32
	ctx.r[3].s64 = 50;
	// 82A5A82C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5A830: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A5A834: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A5A838: 4B7D19D9  bl 0x8222c210
	ctx.lr = 0x82A5A83C;
	sub_8222C210(ctx, base);
	// 82A5A83C: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82A5A840: 4B7AE2D1  bl 0x82208b10
	ctx.lr = 0x82A5A844;
	sub_82208B10(ctx, base);
	// 82A5A844: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82A5A848: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 82A5A84C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82A5A850: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82A5A854: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A5A858: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82A5A85C: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 82A5A860: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A5A864: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5A868: 938100E0  stw r28, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 82A5A86C: 388B002C  addi r4, r11, 0x2c
	ctx.r[4].s64 = ctx.r[11].s64 + 44;
	// 82A5A870: 9B8100E4  stb r28, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[28].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5A9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5A9C0 size=216
    let mut pc: u32 = 0x82A5A9C0;
    'dispatch: loop {
        match pc {
            0x82A5A9C0 => {
    //   block [0x82A5A9C0..0x82A5A9FC)
	// 82A5A9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5A9C4: 4824EA49  bl 0x82ca940c
	ctx.lr = 0x82A5A9C8;
	sub_82CA93D0(ctx, base);
	// 82A5A9C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5A9CC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5A9D0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A5A9D4: 3BEBFB30  addi r31, r11, -0x4d0
	ctx.r[31].s64 = ctx.r[11].s64 + -1232;
	// 82A5A9D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5A9DC: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 82A5A9E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5A9E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5A9E8: 419A0014  beq cr6, 0x82a5a9fc
	if ctx.cr[6].eq {
	pc = 0x82A5A9FC; continue 'dispatch;
	}
	// 82A5A9EC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5A9F0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5A9F4: 7D291671  srawi. r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A5A9F8: 4082000C  bne 0x82a5aa04
	if !ctx.cr[0].eq {
	pc = 0x82A5AA04; continue 'dispatch;
	}
	pc = 0x82A5A9FC; continue 'dispatch;
            }
            0x82A5A9FC => {
    //   block [0x82A5A9FC..0x82A5AA04)
	// 82A5A9FC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A5AA00: 48000034  b 0x82a5aa34
	pc = 0x82A5AA34; continue 'dispatch;
            }
            0x82A5AA04 => {
    //   block [0x82A5AA04..0x82A5AA10)
	// 82A5AA04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5AA08: 40990008  ble cr6, 0x82a5aa10
	if !ctx.cr[6].gt {
	pc = 0x82A5AA10; continue 'dispatch;
	}
	// 82A5AA0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5AA10; continue 'dispatch;
            }
            0x82A5AA10 => {
    //   block [0x82A5AA10..0x82A5AA24)
	// 82A5AA10: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82A5AA14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5AA18: 419A000C  beq cr6, 0x82a5aa24
	if ctx.cr[6].eq {
	pc = 0x82A5AA24; continue 'dispatch;
	}
	// 82A5AA1C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5AA20: 419A0008  beq cr6, 0x82a5aa28
	if ctx.cr[6].eq {
	pc = 0x82A5AA28; continue 'dispatch;
	}
	pc = 0x82A5AA24; continue 'dispatch;
            }
            0x82A5AA24 => {
    //   block [0x82A5AA24..0x82A5AA28)
	// 82A5AA24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5AA28; continue 'dispatch;
            }
            0x82A5AA28 => {
    //   block [0x82A5AA28..0x82A5AA34)
	// 82A5AA28: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A5AA2C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5AA30: 7D3E1670  srawi r30, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x82A5AA34; continue 'dispatch;
            }
            0x82A5AA34 => {
    //   block [0x82A5AA34..0x82A5AA54)
	// 82A5AA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5AA38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5AA3C: 4800005D  bl 0x82a5aa98
	ctx.lr = 0x82A5AA40;
	sub_82A5AA98(ctx, base);
	// 82A5AA40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5AA44: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5AA48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5AA4C: 40990008  ble cr6, 0x82a5aa54
	if !ctx.cr[6].gt {
	pc = 0x82A5AA54; continue 'dispatch;
	}
	// 82A5AA50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5AA54; continue 'dispatch;
            }
            0x82A5AA54 => {
    //   block [0x82A5AA54..0x82A5AA7C)
	// 82A5AA54: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5AA58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5AA5C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A5AA60: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A5AA64: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5AA68: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A5AA6C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5AA70: 4199000C  bgt cr6, 0x82a5aa7c
	if ctx.cr[6].gt {
	pc = 0x82A5AA7C; continue 'dispatch;
	}
	// 82A5AA74: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5AA78: 40980008  bge cr6, 0x82a5aa80
	if !ctx.cr[6].lt {
	pc = 0x82A5AA80; continue 'dispatch;
	}
	pc = 0x82A5AA7C; continue 'dispatch;
            }
            0x82A5AA7C => {
    //   block [0x82A5AA7C..0x82A5AA80)
	// 82A5AA7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5AA80; continue 'dispatch;
            }
            0x82A5AA80 => {
    //   block [0x82A5AA80..0x82A5AA98)
	// 82A5AA80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A5AA84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5AA88: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5AA8C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A5AA90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5AA94: 4824E9C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5AA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5AA98 size=672
    let mut pc: u32 = 0x82A5AA98;
    'dispatch: loop {
        match pc {
            0x82A5AA98 => {
    //   block [0x82A5AA98..0x82A5AAD0)
	// 82A5AA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5AA9C: 4824E965  bl 0x82ca9400
	ctx.lr = 0x82A5AAA0;
	sub_82CA93D0(ctx, base);
	// 82A5AAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5AAA4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5AAA8: 83460000  lwz r26, 0(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5AAAC: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A5AAB0: 3B8BFB30  addi r28, r11, -0x4d0
	ctx.r[28].s64 = ctx.r[11].s64 + -1232;
	// 82A5AAB4: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5AAB8: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5AABC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5AAC0: 409A0010  bne cr6, 0x82a5aad0
	if !ctx.cr[6].eq {
	pc = 0x82A5AAD0; continue 'dispatch;
	}
	// 82A5AAC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5AAC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5AACC: 48000018  b 0x82a5aae4
	pc = 0x82A5AAE4; continue 'dispatch;
            }
            0x82A5AAD0 => {
    //   block [0x82A5AAD0..0x82A5AAE4)
	// 82A5AAD0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5AAD4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5AAD8: 7D691670  srawi r9, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A5AADC: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A5AAE0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82A5AAE4; continue 'dispatch;
            }
            0x82A5AAE4 => {
    //   block [0x82A5AAE4..0x82A5AB04)
	// 82A5AAE4: 3D003FFF  lis r8, 0x3fff
	ctx.r[8].s64 = 1073676288;
	// 82A5AAE8: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 82A5AAEC: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A5AAF0: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A5AAF4: 40980010  bge cr6, 0x82a5ab04
	if !ctx.cr[6].lt {
	pc = 0x82A5AB04; continue 'dispatch;
	}
	// 82A5AAF8: 4BA99FD9  bl 0x824f4ad0
	ctx.lr = 0x82A5AAFC;
	sub_824F4AD0(ctx, base);
	// 82A5AAFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5AB00: 4824E950  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5AB04 => {
    //   block [0x82A5AB04..0x82A5AB14)
	// 82A5AB04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5AB08: 409A000C  bne cr6, 0x82a5ab14
	if !ctx.cr[6].eq {
	pc = 0x82A5AB14; continue 'dispatch;
	}
	// 82A5AB0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5AB10: 4800000C  b 0x82a5ab1c
	pc = 0x82A5AB1C; continue 'dispatch;
            }
            0x82A5AB14 => {
    //   block [0x82A5AB14..0x82A5AB1C)
	// 82A5AB14: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A5AB18: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82A5AB1C; continue 'dispatch;
            }
            0x82A5AB1C => {
    //   block [0x82A5AB1C..0x82A5AB40)
	// 82A5AB1C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A5AB20: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5AB24: 4098010C  bge cr6, 0x82a5ac30
	if !ctx.cr[6].lt {
	pc = 0x82A5AC30; continue 'dispatch;
	}
	// 82A5AB28: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5AB2C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A5AB30: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A5AB34: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5AB38: 41980008  blt cr6, 0x82a5ab40
	if ctx.cr[6].lt {
	pc = 0x82A5AB40; continue 'dispatch;
	}
	// 82A5AB3C: 7F6B4A14  add r27, r11, r9
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A5AB40; continue 'dispatch;
            }
            0x82A5AB40 => {
    //   block [0x82A5AB40..0x82A5AB50)
	// 82A5AB40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5AB44: 409A000C  bne cr6, 0x82a5ab50
	if !ctx.cr[6].eq {
	pc = 0x82A5AB50; continue 'dispatch;
	}
	// 82A5AB48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5AB4C: 4800000C  b 0x82a5ab58
	pc = 0x82A5AB58; continue 'dispatch;
            }
            0x82A5AB50 => {
    //   block [0x82A5AB50..0x82A5AB58)
	// 82A5AB50: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A5AB54: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82A5AB58; continue 'dispatch;
            }
            0x82A5AB58 => {
    //   block [0x82A5AB58..0x82A5AB74)
	// 82A5AB58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A5AB5C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5AB60: 40980020  bge cr6, 0x82a5ab80
	if !ctx.cr[6].lt {
	pc = 0x82A5AB80; continue 'dispatch;
	}
	// 82A5AB64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5AB68: 409A000C  bne cr6, 0x82a5ab74
	if !ctx.cr[6].eq {
	pc = 0x82A5AB74; continue 'dispatch;
	}
	// 82A5AB6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5AB70: 4800000C  b 0x82a5ab7c
	pc = 0x82A5AB7C; continue 'dispatch;
            }
            0x82A5AB74 => {
    //   block [0x82A5AB74..0x82A5AB7C)
	// 82A5AB74: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A5AB78: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82A5AB7C; continue 'dispatch;
            }
            0x82A5AB7C => {
    //   block [0x82A5AB7C..0x82A5AB80)
	// 82A5AB7C: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	pc = 0x82A5AB80; continue 'dispatch;
            }
            0x82A5AB80 => {
    //   block [0x82A5AB80..0x82A5ABB4)
	// 82A5AB80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5AB84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A5AB88: 4802B491  bl 0x82a86018
	ctx.lr = 0x82A5AB8C;
	sub_82A86018(ctx, base);
	// 82A5AB8C: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5AB90: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5AB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5AB98: 7D65F050  subf r11, r5, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82A5AB9C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5ABA0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A5ABA4: 7FA6FA14  add r29, r6, r31
	ctx.r[29].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82A5ABA8: 4182000C  beq 0x82a5abb4
	if ctx.cr[0].eq {
	pc = 0x82A5ABB4; continue 'dispatch;
	}
	// 82A5ABAC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A5ABB0: 4824F479  bl 0x82caa028
	ctx.lr = 0x82A5ABB4;
	sub_82CAA028(ctx, base);
	pc = 0x82A5ABB4; continue 'dispatch;
            }
            0x82A5ABB4 => {
    //   block [0x82A5ABB4..0x82A5ABE0)
	// 82A5ABB4: 935D0000  stw r26, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5ABB8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5ABBC: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A5ABC0: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A5ABC4: 4182001C  beq 0x82a5abe0
	if ctx.cr[0].eq {
	pc = 0x82A5ABE0; continue 'dispatch;
	}
	// 82A5ABC8: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A5ABCC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5ABD0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A5ABD4: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82A5ABD8: 4824F451  bl 0x82caa028
	ctx.lr = 0x82A5ABDC;
	sub_82CAA028(ctx, base);
	// 82A5ABDC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5ABE0; continue 'dispatch;
            }
            0x82A5ABE0 => {
    //   block [0x82A5ABE0..0x82A5ABF4)
	// 82A5ABE0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5ABE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5ABE8: 409A000C  bne cr6, 0x82a5abf4
	if !ctx.cr[6].eq {
	pc = 0x82A5ABF4; continue 'dispatch;
	}
	// 82A5ABEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5ABF0: 4800000C  b 0x82a5abfc
	pc = 0x82A5ABFC; continue 'dispatch;
            }
            0x82A5ABF4 => {
    //   block [0x82A5ABF4..0x82A5ABFC)
	// 82A5ABF4: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A5ABF8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82A5ABFC; continue 'dispatch;
            }
            0x82A5ABFC => {
    //   block [0x82A5ABFC..0x82A5AC0C)
	// 82A5ABFC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82A5AC00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5AC04: 419A0008  beq cr6, 0x82a5ac0c
	if ctx.cr[6].eq {
	pc = 0x82A5AC0C; continue 'dispatch;
	}
	// 82A5AC08: 4B7C1131  bl 0x8221bd38
	ctx.lr = 0x82A5AC0C;
	sub_8221BD38(ctx, base);
	pc = 0x82A5AC0C; continue 'dispatch;
            }
            0x82A5AC0C => {
    //   block [0x82A5AC0C..0x82A5AC30)
	// 82A5AC0C: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5AC10: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A5AC14: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5AC18: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A5AC1C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82A5AC20: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A5AC24: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5AC28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5AC2C: 4824E824  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5AC30 => {
    //   block [0x82A5AC30..0x82A5AC64)
	// 82A5AC30: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5AC34: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82A5AC38: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A5AC3C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A5AC40: 40980080  bge cr6, 0x82a5acc0
	if !ctx.cr[6].lt {
	pc = 0x82A5ACC0; continue 'dispatch;
	}
	// 82A5AC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5AC48: 419A001C  beq cr6, 0x82a5ac64
	if ctx.cr[6].eq {
	pc = 0x82A5AC64; continue 'dispatch;
	}
	// 82A5AC4C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A5AC50: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5AC54: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A5AC58: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A5AC5C: 4824F3CD  bl 0x82caa028
	ctx.lr = 0x82A5AC60;
	sub_82CAA028(ctx, base);
	// 82A5AC60: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5AC64; continue 'dispatch;
            }
            0x82A5AC64 => {
    //   block [0x82A5AC64..0x82A5AC80)
	// 82A5AC64: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82A5AC68: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A5AC6C: 214A0001  subfic r10, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A5AC70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5AC74: 419A001C  beq cr6, 0x82a5ac90
	if ctx.cr[6].eq {
	pc = 0x82A5AC90; continue 'dispatch;
	}
	// 82A5AC78: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A5AC7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82A5AC80; continue 'dispatch;
            }
            0x82A5AC80 => {
    //   block [0x82A5AC80..0x82A5AC90)
	// 82A5AC80: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5AC84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5AC88: 4200FFF8  bdnz 0x82a5ac80
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A5AC80; continue 'dispatch;
	}
	// 82A5AC8C: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5AC90; continue 'dispatch;
            }
            0x82A5AC90 => {
    //   block [0x82A5AC90..0x82A5ACA8)
	// 82A5AC90: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82A5AC94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A5AC98: 392AFFFC  addi r9, r10, -4
	ctx.r[9].s64 = ctx.r[10].s64 + -4;
	// 82A5AC9C: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5ACA0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5ACA4: 419A008C  beq cr6, 0x82a5ad30
	if ctx.cr[6].eq {
	pc = 0x82A5AD30; continue 'dispatch;
	}
	pc = 0x82A5ACA8; continue 'dispatch;
            }
            0x82A5ACA8 => {
    //   block [0x82A5ACA8..0x82A5ACC0)
	// 82A5ACA8: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5ACAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5ACB0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5ACB4: 409AFFF4  bne cr6, 0x82a5aca8
	if !ctx.cr[6].eq {
	pc = 0x82A5ACA8; continue 'dispatch;
	}
	// 82A5ACB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5ACBC: 4824E794  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5ACC0 => {
    //   block [0x82A5ACC0..0x82A5ACE8)
	// 82A5ACC0: 3BBFFFFC  addi r29, r31, -4
	ctx.r[29].s64 = ctx.r[31].s64 + -4;
	// 82A5ACC4: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 82A5ACC8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5ACCC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A5ACD0: 7F66FA14  add r27, r6, r31
	ctx.r[27].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82A5ACD4: 41820014  beq 0x82a5ace8
	if ctx.cr[0].eq {
	pc = 0x82A5ACE8; continue 'dispatch;
	}
	// 82A5ACD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5ACDC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A5ACE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5ACE4: 4824F345  bl 0x82caa028
	ctx.lr = 0x82A5ACE8;
	sub_82CAA028(ctx, base);
	pc = 0x82A5ACE8; continue 'dispatch;
            }
            0x82A5ACE8 => {
    //   block [0x82A5ACE8..0x82A5AD10)
	// 82A5ACE8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A5ACEC: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A5ACF0: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5ACF4: 4081001C  ble 0x82a5ad10
	if !ctx.cr[0].gt {
	pc = 0x82A5AD10; continue 'dispatch;
	}
	// 82A5ACF8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5ACFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5AD00: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A5AD04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A5AD08: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A5AD0C: 4824F31D  bl 0x82caa028
	ctx.lr = 0x82A5AD10;
	sub_82CAA028(ctx, base);
	pc = 0x82A5AD10; continue 'dispatch;
            }
            0x82A5AD10 => {
    //   block [0x82A5AD10..0x82A5AD20)
	// 82A5AD10: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 82A5AD14: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A5AD18: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5AD1C: 419A0014  beq cr6, 0x82a5ad30
	if ctx.cr[6].eq {
	pc = 0x82A5AD30; continue 'dispatch;
	}
	pc = 0x82A5AD20; continue 'dispatch;
            }
            0x82A5AD20 => {
    //   block [0x82A5AD20..0x82A5AD30)
	// 82A5AD20: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A5AD24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5AD28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5AD2C: 409AFFF4  bne cr6, 0x82a5ad20
	if !ctx.cr[6].eq {
	pc = 0x82A5AD20; continue 'dispatch;
	}
	pc = 0x82A5AD30; continue 'dispatch;
            }
            0x82A5AD30 => {
    //   block [0x82A5AD30..0x82A5AD38)
	// 82A5AD30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5AD34: 4824E71C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5AD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5AD38 size=80
    let mut pc: u32 = 0x82A5AD38;
    'dispatch: loop {
        match pc {
            0x82A5AD38 => {
    //   block [0x82A5AD38..0x82A5AD70)
	// 82A5AD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5AD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5AD40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5AD44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5AD48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5AD4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5AD50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5AD54: 48000035  bl 0x82a5ad88
	ctx.lr = 0x82A5AD58;
	sub_82A5AD88(ctx, base);
	// 82A5AD58: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A5AD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5AD60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5AD64: 419A000C  beq cr6, 0x82a5ad70
	if ctx.cr[6].eq {
	pc = 0x82A5AD70; continue 'dispatch;
	}
	// 82A5AD68: 4B7C0FD1  bl 0x8221bd38
	ctx.lr = 0x82A5AD6C;
	sub_8221BD38(ctx, base);
	// 82A5AD6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A5AD70; continue 'dispatch;
            }
            0x82A5AD70 => {
    //   block [0x82A5AD70..0x82A5AD88)
	// 82A5AD70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5AD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5AD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5AD7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5AD80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5AD84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5AD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5AD88 size=232
    let mut pc: u32 = 0x82A5AD88;
    'dispatch: loop {
        match pc {
            0x82A5AD88 => {
    //   block [0x82A5AD88..0x82A5ADB8)
	// 82A5AD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5AD8C: 4824E681  bl 0x82ca940c
	ctx.lr = 0x82A5AD90;
	sub_82CA93D0(ctx, base);
	// 82A5AD90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5AD94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5AD98: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5AD9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A5ADA0: 394B6D00  addi r10, r11, 0x6d00
	ctx.r[10].s64 = ctx.r[11].s64 + 27904;
	// 82A5ADA4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5ADA8: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5ADAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5ADB0: 419A0040  beq cr6, 0x82a5adf0
	if ctx.cr[6].eq {
	pc = 0x82A5ADF0; continue 'dispatch;
	}
	// 82A5ADB4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5ADB8; continue 'dispatch;
            }
            0x82A5ADB8 => {
    //   block [0x82A5ADB8..0x82A5ADEC)
	// 82A5ADB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5ADBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5ADC0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5ADC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5ADC8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5ADCC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5ADD0: 4082FFE8  bne 0x82a5adb8
	if !ctx.cr[0].eq {
	pc = 0x82A5ADB8; continue 'dispatch;
	}
	// 82A5ADD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5ADD8: 409A0014  bne cr6, 0x82a5adec
	if !ctx.cr[6].eq {
	pc = 0x82A5ADEC; continue 'dispatch;
	}
	// 82A5ADDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5ADE0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5ADE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5ADE8: 4E800421  bctrl
	ctx.lr = 0x82A5ADEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5ADEC => {
    //   block [0x82A5ADEC..0x82A5ADF0)
	// 82A5ADEC: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	pc = 0x82A5ADF0; continue 'dispatch;
            }
            0x82A5ADF0 => {
    //   block [0x82A5ADF0..0x82A5AE04)
	// 82A5ADF0: 57A3003E  slwi r3, r29, 0
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A5ADF4: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82A5ADF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5ADFC: 419A0040  beq cr6, 0x82a5ae3c
	if ctx.cr[6].eq {
	pc = 0x82A5AE3C; continue 'dispatch;
	}
	// 82A5AE00: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5AE04; continue 'dispatch;
            }
            0x82A5AE04 => {
    //   block [0x82A5AE04..0x82A5AE38)
	// 82A5AE04: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5AE08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5AE0C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5AE10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5AE14: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5AE18: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5AE1C: 4082FFE8  bne 0x82a5ae04
	if !ctx.cr[0].eq {
	pc = 0x82A5AE04; continue 'dispatch;
	}
	// 82A5AE20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5AE24: 409A0014  bne cr6, 0x82a5ae38
	if !ctx.cr[6].eq {
	pc = 0x82A5AE38; continue 'dispatch;
	}
	// 82A5AE28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5AE2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5AE30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5AE34: 4E800421  bctrl
	ctx.lr = 0x82A5AE38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5AE38 => {
    //   block [0x82A5AE38..0x82A5AE3C)
	// 82A5AE38: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	pc = 0x82A5AE3C; continue 'dispatch;
            }
            0x82A5AE3C => {
    //   block [0x82A5AE3C..0x82A5AE50)
	// 82A5AE3C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5AE40: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 82A5AE44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5AE48: 419A0008  beq cr6, 0x82a5ae50
	if ctx.cr[6].eq {
	pc = 0x82A5AE50; continue 'dispatch;
	}
	// 82A5AE4C: 4B7C0EED  bl 0x8221bd38
	ctx.lr = 0x82A5AE50;
	sub_8221BD38(ctx, base);
	pc = 0x82A5AE50; continue 'dispatch;
            }
            0x82A5AE50 => {
    //   block [0x82A5AE50..0x82A5AE70)
	// 82A5AE50: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82A5AE54: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A5AE58: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A5AE5C: 394B0FD0  addi r10, r11, 0xfd0
	ctx.r[10].s64 = ctx.r[11].s64 + 4048;
	// 82A5AE60: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82A5AE64: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5AE68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5AE6C: 4824E5F0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5AE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5AE70 size=140
    let mut pc: u32 = 0x82A5AE70;
    'dispatch: loop {
        match pc {
            0x82A5AE70 => {
    //   block [0x82A5AE70..0x82A5AEAC)
	// 82A5AE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5AE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5AE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5AE7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5AE80: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5AE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5AE88: 4B750C11  bl 0x821aba98
	ctx.lr = 0x82A5AE8C;
	sub_821ABA98(ctx, base);
	// 82A5AE8C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5AE90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5AE94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5AE98: 812A0090  lwz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A5AE9C: 553FDFFE  rlwinm r31, r9, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82A5AEA0: 419A0044  beq cr6, 0x82a5aee4
	if ctx.cr[6].eq {
	pc = 0x82A5AEE4; continue 'dispatch;
	}
	// 82A5AEA4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A5AEA8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5AEAC; continue 'dispatch;
            }
            0x82A5AEAC => {
    //   block [0x82A5AEAC..0x82A5AEE4)
	// 82A5AEAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5AEB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5AEB4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5AEB8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5AEBC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5AEC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5AEC4: 4082FFE8  bne 0x82a5aeac
	if !ctx.cr[0].eq {
	pc = 0x82A5AEAC; continue 'dispatch;
	}
	// 82A5AEC8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5AECC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5AED0: 409A0014  bne cr6, 0x82a5aee4
	if !ctx.cr[6].eq {
	pc = 0x82A5AEE4; continue 'dispatch;
	}
	// 82A5AED4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5AED8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5AEDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5AEE0: 4E800421  bctrl
	ctx.lr = 0x82A5AEE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5AEE4 => {
    //   block [0x82A5AEE4..0x82A5AEFC)
	// 82A5AEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5AEE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5AEEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5AEF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5AEF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5AEF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5AF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A5AF00 size=312
    let mut pc: u32 = 0x82A5AF00;
    'dispatch: loop {
        match pc {
            0x82A5AF00 => {
    //   block [0x82A5AF00..0x82A5AF54)
	// 82A5AF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5AF04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5AF08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5AF0C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5AF10: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5AF14: 388BFFDC  addi r4, r11, -0x24
	ctx.r[4].s64 = ctx.r[11].s64 + -36;
	// 82A5AF18: 816BFFE8  lwz r11, -0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 82A5AF1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5AF20: 409A0100  bne cr6, 0x82a5b020
	if !ctx.cr[6].eq {
	pc = 0x82A5B020; continue 'dispatch;
	}
	// 82A5AF24: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5AF28: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82A5AF2C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5AF30: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A5AF34: 7CE853D6  divw r7, r8, r10
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 82A5AF38: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82A5AF3C: 419A0018  beq cr6, 0x82a5af54
	if ctx.cr[6].eq {
	pc = 0x82A5AF54; continue 'dispatch;
	}
	// 82A5AF40: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5AF44: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A5AF48: 419A0024  beq cr6, 0x82a5af6c
	if ctx.cr[6].eq {
	pc = 0x82A5AF6C; continue 'dispatch;
	}
	// 82A5AF4C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82A5AF50: 409A00D0  bne cr6, 0x82a5b020
	if !ctx.cr[6].eq {
	pc = 0x82A5B020; continue 'dispatch;
	}
	pc = 0x82A5AF54; continue 'dispatch;
            }
            0x82A5AF54 => {
    //   block [0x82A5AF54..0x82A5AF6C)
	// 82A5AF54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A5AF58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5AF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5AF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5AF64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5AF68: 4E800020  blr
	return;
            }
            0x82A5AF6C => {
    //   block [0x82A5AF6C..0x82A5AF98)
	// 82A5AF6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A5AF70: C1A40008  lfs f13, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5AF74: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A5AF78: C00B9490  lfs f0, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5AF7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5AF80: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A5AF84: C00A9054  lfs f0, -0x6fac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5AF88: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82A5AF8C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82A5AF90: 41980008  blt cr6, 0x82a5af98
	if ctx.cr[6].lt {
	pc = 0x82A5AF98; continue 'dispatch;
	}
	// 82A5AF94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A5AF98; continue 'dispatch;
            }
            0x82A5AF98 => {
    //   block [0x82A5AF98..0x82A5AFD0)
	// 82A5AF98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5AF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5AFA0: 419A0080  beq cr6, 0x82a5b020
	if ctx.cr[6].eq {
	pc = 0x82A5B020; continue 'dispatch;
	}
	// 82A5AFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5AFA8: 4B750AF1  bl 0x821aba98
	ctx.lr = 0x82A5AFAC;
	sub_821ABA98(ctx, base);
	// 82A5AFAC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5AFB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5AFB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5AFB8: 812A0090  lwz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A5AFBC: 7D2848F8  nor r8, r9, r9
	ctx.r[8].u64 = !(ctx.r[9].u64 | ctx.r[9].u64);
	// 82A5AFC0: 551FDFFE  rlwinm r31, r8, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82A5AFC4: 419A0044  beq cr6, 0x82a5b008
	if ctx.cr[6].eq {
	pc = 0x82A5B008; continue 'dispatch;
	}
	// 82A5AFC8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A5AFCC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5AFD0; continue 'dispatch;
            }
            0x82A5AFD0 => {
    //   block [0x82A5AFD0..0x82A5B008)
	// 82A5AFD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5AFD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5AFD8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5AFDC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5AFE0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5AFE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5AFE8: 4082FFE8  bne 0x82a5afd0
	if !ctx.cr[0].eq {
	pc = 0x82A5AFD0; continue 'dispatch;
	}
	// 82A5AFEC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5AFF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5AFF4: 409A0014  bne cr6, 0x82a5b008
	if !ctx.cr[6].eq {
	pc = 0x82A5B008; continue 'dispatch;
	}
	// 82A5AFF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5AFFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B000: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B004: 4E800421  bctrl
	ctx.lr = 0x82A5B008;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5B008 => {
    //   block [0x82A5B008..0x82A5B020)
	// 82A5B008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B00C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5B010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5B014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5B018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5B01C: 4E800020  blr
	return;
            }
            0x82A5B020 => {
    //   block [0x82A5B020..0x82A5B038)
	// 82A5B020: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5B024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5B028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5B02C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5B030: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5B034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5B038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A5B038 size=360
    let mut pc: u32 = 0x82A5B038;
    'dispatch: loop {
        match pc {
            0x82A5B038 => {
    //   block [0x82A5B038..0x82A5B0C8)
	// 82A5B038: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 82A5B03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B040: 409A0160  bne cr6, 0x82a5b1a0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5B1A0);
		return;
	}
	// 82A5B044: 89630026  lbz r11, 0x26(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(38 as u32) ) } as u64;
	// 82A5B048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B04C: 409A0154  bne cr6, 0x82a5b1a0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5B1A0);
		return;
	}
	// 82A5B050: 89640060  lbz r11, 0x60(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A5B054: 89430024  lbz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5B058: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5B05C: 409A0144  bne cr6, 0x82a5b1a0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5B1A0);
		return;
	}
	// 82A5B060: 81640058  lwz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5B064: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82A5B068: 81040054  lwz r8, 0x54(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5B06C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B070: 80E30010  lwz r7, 0x10(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B074: 7CC85850  subf r6, r8, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82A5B078: 7CA74850  subf r5, r7, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A5B07C: 7C8653D6  divw r4, r6, r10
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[10].s32;
	// 82A5B080: 7D6553D6  divw r11, r5, r10
	ctx.r[11].s32 = ctx.r[5].s32 / ctx.r[10].s32;
	// 82A5B084: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A5B088: 409A0118  bne cr6, 0x82a5b1a0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5B1A0);
		return;
	}
	// 82A5B08C: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5B090: 54E9003E  slwi r9, r7, 0
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A5B094: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A5B098: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A5B09C: 7CA753D7  divw. r5, r7, r10
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A5B0A0: 418200F8  beq 0x82a5b198
	if ctx.cr[0].eq {
	pc = 0x82A5B198; continue 'dispatch;
	}
	// 82A5B0A4: 80A30010  lwz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B0A8: 39680011  addi r11, r8, 0x11
	ctx.r[11].s64 = ctx.r[8].s64 + 17;
	// 82A5B0AC: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B0B0: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82A5B0B4: 7C853850  subf r4, r5, r7
	ctx.r[4].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 82A5B0B8: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 82A5B0BC: 7CA453D6  divw r5, r4, r10
	ctx.r[5].s32 = ctx.r[4].s32 / ctx.r[10].s32;
	// 82A5B0C0: 39490011  addi r10, r9, 0x11
	ctx.r[10].s64 = ctx.r[9].s64 + 17;
	// 82A5B0C4: 7D094050  subf r8, r9, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	pc = 0x82A5B0C8; continue 'dispatch;
            }
            0x82A5B0C8 => {
    //   block [0x82A5B0C8..0x82A5B14C)
	// 82A5B0C8: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B0CC: 7C87402E  lwzx r4, r7, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82A5B0D0: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5B0D4: 409A009C  bne cr6, 0x82a5b170
	if !ctx.cr[6].eq {
	pc = 0x82A5B170; continue 'dispatch;
	}
	// 82A5B0D8: 812AFFF3  lwz r9, -0xd(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13 as u32) ) } as u64;
	// 82A5B0DC: 808BFFF3  lwz r4, -0xd(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13 as u32) ) } as u64;
	// 82A5B0E0: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A5B0E4: 409A008C  bne cr6, 0x82a5b170
	if !ctx.cr[6].eq {
	pc = 0x82A5B170; continue 'dispatch;
	}
	// 82A5B0E8: C00AFFF7  lfs f0, -9(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5B0EC: C1ABFFF7  lfs f13, -9(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5B0F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A5B0F4: 409A007C  bne cr6, 0x82a5b170
	if !ctx.cr[6].eq {
	pc = 0x82A5B170; continue 'dispatch;
	}
	// 82A5B0F8: 812AFFFB  lwz r9, -5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-5 as u32) ) } as u64;
	// 82A5B0FC: 808BFFFB  lwz r4, -5(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5 as u32) ) } as u64;
	// 82A5B100: 7F092000  cmpw cr6, r9, r4
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A5B104: 409A006C  bne cr6, 0x82a5b170
	if !ctx.cr[6].eq {
	pc = 0x82A5B170; continue 'dispatch;
	}
	// 82A5B108: 892A0001  lbz r9, 1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B10C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B110: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5B114: 409A0038  bne cr6, 0x82a5b14c
	if !ctx.cr[6].eq {
	pc = 0x82A5B14C; continue 'dispatch;
	}
	// 82A5B118: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B11C: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B120: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5B124: 409A0028  bne cr6, 0x82a5b14c
	if !ctx.cr[6].eq {
	pc = 0x82A5B14C; continue 'dispatch;
	}
	// 82A5B128: 892AFFFF  lbz r9, -1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82A5B12C: 888BFFFF  lbz r4, -1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82A5B130: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5B134: 409A0018  bne cr6, 0x82a5b14c
	if !ctx.cr[6].eq {
	pc = 0x82A5B14C; continue 'dispatch;
	}
	// 82A5B138: 892A0002  lbz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B13C: 888B0002  lbz r4, 2(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B140: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5B144: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5B148: 419A0008  beq cr6, 0x82a5b150
	if ctx.cr[6].eq {
	pc = 0x82A5B150; continue 'dispatch;
	}
	pc = 0x82A5B14C; continue 'dispatch;
            }
            0x82A5B14C => {
    //   block [0x82A5B14C..0x82A5B150)
	// 82A5B14C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82A5B150; continue 'dispatch;
            }
            0x82A5B150 => {
    //   block [0x82A5B150..0x82A5B170)
	// 82A5B150: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82A5B154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5B158: 409A0018  bne cr6, 0x82a5b170
	if !ctx.cr[6].eq {
	pc = 0x82A5B170; continue 'dispatch;
	}
	// 82A5B15C: C00A0007  lfs f0, 7(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5B160: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A5B164: C1AB0007  lfs f13, 7(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5B168: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A5B16C: 419A0008  beq cr6, 0x82a5b174
	if ctx.cr[6].eq {
	pc = 0x82A5B174; continue 'dispatch;
	}
	pc = 0x82A5B170; continue 'dispatch;
            }
            0x82A5B170 => {
    //   block [0x82A5B170..0x82A5B174)
	// 82A5B170: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82A5B174; continue 'dispatch;
            }
            0x82A5B174 => {
    //   block [0x82A5B174..0x82A5B198)
	// 82A5B174: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82A5B178: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5B17C: 419A0024  beq cr6, 0x82a5b1a0
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5B1A0);
		return;
	}
	// 82A5B180: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82A5B184: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82A5B188: 38E70024  addi r7, r7, 0x24
	ctx.r[7].s64 = ctx.r[7].s64 + 36;
	// 82A5B18C: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 82A5B190: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5B194: 4198FF34  blt cr6, 0x82a5b0c8
	if ctx.cr[6].lt {
	pc = 0x82A5B0C8; continue 'dispatch;
	}
	pc = 0x82A5B198; continue 'dispatch;
            }
            0x82A5B198 => {
    //   block [0x82A5B198..0x82A5B1A0)
	// 82A5B198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5B19C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5B1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5B1A8 size=224
    let mut pc: u32 = 0x82A5B1A8;
    'dispatch: loop {
        match pc {
            0x82A5B1A8 => {
    //   block [0x82A5B1A8..0x82A5B1F8)
	// 82A5B1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5B1AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5B1B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5B1B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5B1B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5B1BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5B1C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5B1C4: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 82A5B1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B1CC: 409A00A0  bne cr6, 0x82a5b26c
	if !ctx.cr[6].eq {
	pc = 0x82A5B26C; continue 'dispatch;
	}
	// 82A5B1D0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5B1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B1D8: 419A0094  beq cr6, 0x82a5b26c
	if ctx.cr[6].eq {
	pc = 0x82A5B26C; continue 'dispatch;
	}
	// 82A5B1DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B1E0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5B1E4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5B1E8: 419A007C  beq cr6, 0x82a5b264
	if ctx.cr[6].eq {
	pc = 0x82A5B264; continue 'dispatch;
	}
	// 82A5B1EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5B1F0: 419A0044  beq cr6, 0x82a5b234
	if ctx.cr[6].eq {
	pc = 0x82A5B234; continue 'dispatch;
	}
	// 82A5B1F4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5B1F8; continue 'dispatch;
            }
            0x82A5B1F8 => {
    //   block [0x82A5B1F8..0x82A5B22C)
	// 82A5B1F8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5B1FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5B200: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5B204: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5B208: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5B20C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5B210: 4082FFE8  bne 0x82a5b1f8
	if !ctx.cr[0].eq {
	pc = 0x82A5B1F8; continue 'dispatch;
	}
	// 82A5B214: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5B218: 409A0014  bne cr6, 0x82a5b22c
	if !ctx.cr[6].eq {
	pc = 0x82A5B22C; continue 'dispatch;
	}
	// 82A5B21C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B220: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B224: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B228: 4E800421  bctrl
	ctx.lr = 0x82A5B22C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5B22C => {
    //   block [0x82A5B22C..0x82A5B234)
	// 82A5B22C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5B230: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5B234; continue 'dispatch;
            }
            0x82A5B234 => {
    //   block [0x82A5B234..0x82A5B248)
	// 82A5B234: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5B238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B23C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5B240: 419A0024  beq cr6, 0x82a5b264
	if ctx.cr[6].eq {
	pc = 0x82A5B264; continue 'dispatch;
	}
	// 82A5B244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5B248; continue 'dispatch;
            }
            0x82A5B248 => {
    //   block [0x82A5B248..0x82A5B264)
	// 82A5B248: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5B24C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5B250: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5B254: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5B258: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5B25C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5B260: 4082FFE8  bne 0x82a5b248
	if !ctx.cr[0].eq {
	pc = 0x82A5B248; continue 'dispatch;
	}
	pc = 0x82A5B264; continue 'dispatch;
            }
            0x82A5B264 => {
    //   block [0x82A5B264..0x82A5B26C)
	// 82A5B264: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A5B268: 48000008  b 0x82a5b270
	pc = 0x82A5B270; continue 'dispatch;
            }
            0x82A5B26C => {
    //   block [0x82A5B26C..0x82A5B270)
	// 82A5B26C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82A5B270; continue 'dispatch;
            }
            0x82A5B270 => {
    //   block [0x82A5B270..0x82A5B288)
	// 82A5B270: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5B274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5B278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5B27C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5B280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5B284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5B288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5B288 size=848
    let mut pc: u32 = 0x82A5B288;
    'dispatch: loop {
        match pc {
            0x82A5B288 => {
    //   block [0x82A5B288..0x82A5B2CC)
	// 82A5B288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5B28C: 4824E171  bl 0x82ca93fc
	ctx.lr = 0x82A5B290;
	sub_82CA93D0(ctx, base);
	// 82A5B290: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5B294: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5B298: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82A5B29C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5B2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B2A4: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B2A8: 813C0010  lwz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B2AC: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A5B2B0: 7FC853D6  divw r30, r8, r10
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 82A5B2B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5B2B8: 4BFC7341  bl 0x82a225f8
	ctx.lr = 0x82A5B2BC;
	sub_82A225F8(ctx, base);
	// 82A5B2BC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A5B2C0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A5B2C4: 40990024  ble cr6, 0x82a5b2e8
	if !ctx.cr[6].gt {
	pc = 0x82A5B2E8; continue 'dispatch;
	}
	// 82A5B2C8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x82A5B2CC; continue 'dispatch;
            }
            0x82A5B2CC => {
    //   block [0x82A5B2CC..0x82A5B2E8)
	// 82A5B2CC: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B2D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5B2D4: 7C7D5A14  add r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A5B2D8: 4BFEDE11  bl 0x82a490e8
	ctx.lr = 0x82A5B2DC;
	sub_82A490E8(ctx, base);
	// 82A5B2DC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A5B2E0: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 82A5B2E4: 4082FFE8  bne 0x82a5b2cc
	if !ctx.cr[0].eq {
	pc = 0x82A5B2CC; continue 'dispatch;
	}
	pc = 0x82A5B2E8; continue 'dispatch;
            }
            0x82A5B2E8 => {
    //   block [0x82A5B2E8..0x82A5B324)
	// 82A5B2E8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A5B2EC: 807C001C  lwz r3, 0x1c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5B2F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5B2F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A5B2F8: 4B7C37F9  bl 0x8221eaf0
	ctx.lr = 0x82A5B2FC;
	sub_8221EAF0(ctx, base);
	// 82A5B2FC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5B300: 3B2B2A40  addi r25, r11, 0x2a40
	ctx.r[25].s64 = ctx.r[11].s64 + 10816;
	// 82A5B304: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82A5B308: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B30C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B310: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A5B314: 419A0010  beq cr6, 0x82a5b324
	if ctx.cr[6].eq {
	pc = 0x82A5B324; continue 'dispatch;
	}
	// 82A5B318: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A5B31C: 4B7A0E5D  bl 0x821fc178
	ctx.lr = 0x82A5B320;
	sub_821FC178(ctx, base);
	// 82A5B320: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82A5B324; continue 'dispatch;
            }
            0x82A5B324 => {
    //   block [0x82A5B324..0x82A5B3A8)
	// 82A5B324: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A5B328: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5B32C: 3B6A2A30  addi r27, r10, 0x2a30
	ctx.r[27].s64 = ctx.r[10].s64 + 10800;
	// 82A5B330: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82A5B334: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A5B338: 556BD73E  rlwinm r11, r11, 0x1a, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82A5B33C: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82A5B340: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82A5B344: 4812674D  bl 0x82b81a90
	ctx.lr = 0x82A5B348;
	sub_82B81A90(ctx, base);
	// 82A5B348: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5B34C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A5B350: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5B354: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A5B358: 4B82C389  bl 0x822876e0
	ctx.lr = 0x82A5B35C;
	sub_822876E0(ctx, base);
	// 82A5B35C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82A5B360: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A5B364: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5B368: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A5B36C: 838A0000  lwz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B370: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82A5B374: 4B79F85D  bl 0x821fabd0
	ctx.lr = 0x82A5B378;
	sub_821FABD0(ctx, base);
	// 82A5B378: 893F0008  lbz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5B37C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A5B380: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5B384: 419A0024  beq cr6, 0x82a5b3a8
	if ctx.cr[6].eq {
	pc = 0x82A5B3A8; continue 'dispatch;
	}
	// 82A5B388: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B38C: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B390: 8921006B  lbz r9, 0x6b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(107 as u32) ) } as u64;
	// 82A5B394: 89010068  lbz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A5B398: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5B39C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5B3A0: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5B3A4: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5B3A8; continue 'dispatch;
            }
            0x82A5B3A8 => {
    //   block [0x82A5B3A8..0x82A5B3F4)
	// 82A5B3A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B3AC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B3B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5B3B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B3B8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B3BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B3C0: 4E800421  bctrl
	ctx.lr = 0x82A5B3C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5B3C4: 893F0008  lbz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5B3C8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A5B3CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5B3D0: 419A0024  beq cr6, 0x82a5b3f4
	if ctx.cr[6].eq {
	pc = 0x82A5B3F4; continue 'dispatch;
	}
	// 82A5B3D4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B3D8: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B3DC: 89210067  lbz r9, 0x67(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 82A5B3E0: 89010064  lbz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A5B3E4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5B3E8: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5B3EC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5B3F0: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
            }
            0x82A5B3F4 => {
    //   block [0x82A5B3F4..0x82A5B440)
	// 82A5B3F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B3F8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B3FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5B400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B404: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B408: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B40C: 4E800421  bctrl
	ctx.lr = 0x82A5B410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5B410: 893F0008  lbz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5B414: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A5B418: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5B41C: 419A0024  beq cr6, 0x82a5b440
	if ctx.cr[6].eq {
	pc = 0x82A5B440; continue 'dispatch;
	}
	// 82A5B420: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B424: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B428: 89210063  lbz r9, 0x63(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(99 as u32) ) } as u64;
	// 82A5B42C: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A5B430: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5B434: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5B438: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5B43C: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
            }
            0x82A5B440 => {
    //   block [0x82A5B440..0x82A5B490)
	// 82A5B440: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B444: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B448: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5B44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B450: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B454: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B458: 4E800421  bctrl
	ctx.lr = 0x82A5B45C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5B45C: 81210088  lwz r9, 0x88(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A5B460: 891F0008  lbz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5B464: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5B468: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A5B46C: 419A0024  beq cr6, 0x82a5b490
	if ctx.cr[6].eq {
	pc = 0x82A5B490; continue 'dispatch;
	}
	// 82A5B470: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B474: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B478: 8921008B  lbz r9, 0x8b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(139 as u32) ) } as u64;
	// 82A5B47C: 89010088  lbz r8, 0x88(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A5B480: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5B484: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5B488: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5B48C: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
            }
            0x82A5B490 => {
    //   block [0x82A5B490..0x82A5B4E0)
	// 82A5B490: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B494: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B498: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5B49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B4A0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B4A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B4A8: 4E800421  bctrl
	ctx.lr = 0x82A5B4AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5B4AC: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A5B4B0: 891F0008  lbz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5B4B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5B4B8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A5B4BC: 419A0024  beq cr6, 0x82a5b4e0
	if ctx.cr[6].eq {
	pc = 0x82A5B4E0; continue 'dispatch;
	}
	// 82A5B4C0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B4C4: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B4C8: 8921008F  lbz r9, 0x8f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(143 as u32) ) } as u64;
	// 82A5B4CC: 8901008C  lbz r8, 0x8c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A5B4D0: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5B4D4: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5B4D8: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5B4DC: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
            }
            0x82A5B4E0 => {
    //   block [0x82A5B4E0..0x82A5B5A8)
	// 82A5B4E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B4E4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B4E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5B4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B4F0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B4F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5B4F8: 4E800421  bctrl
	ctx.lr = 0x82A5B4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5B4FC: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82A5B500: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A5B504: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 82A5B508: 38E9B3F8  addi r7, r9, -0x4c08
	ctx.r[7].s64 = ctx.r[9].s64 + -19464;
	// 82A5B50C: 9341007C  stw r26, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[26].u32 ) };
	// 82A5B510: 38C82A2C  addi r6, r8, 0x2a2c
	ctx.r[6].s64 = ctx.r[8].s64 + 10796;
	// 82A5B514: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 82A5B518: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A5B51C: 90E10070  stw r7, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 82A5B520: 90C10074  stw r6, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[6].u32 ) };
	// 82A5B524: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82A5B528: 90810088  stw r4, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u32 ) };
	// 82A5B52C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A5B530: 93410084  stw r26, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 82A5B534: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A5B538: 9341008C  stw r26, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[26].u32 ) };
	// 82A5B53C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A5B540: 48131E09  bl 0x82b8d348
	ctx.lr = 0x82A5B544;
	sub_82B8D348(ctx, base);
	// 82A5B544: 3C608210  lis r3, -0x7df0
	ctx.r[3].s64 = -2112880640;
	// 82A5B548: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82A5B54C: 93410094  stw r26, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 82A5B550: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 82A5B554: 934100C0  stw r26, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u32 ) };
	// 82A5B558: 3BC39BF8  addi r30, r3, -0x6408
	ctx.r[30].s64 = ctx.r[3].s64 + -25608;
	// 82A5B55C: 808100DC  lwz r4, 0xdc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A5B560: 392BEF48  addi r9, r11, -0x10b8
	ctx.r[9].s64 = ctx.r[11].s64 + -4280;
	// 82A5B564: 390AEF50  addi r8, r10, -0x10b0
	ctx.r[8].s64 = ctx.r[10].s64 + -4272;
	// 82A5B568: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82A5B56C: 912100B8  stw r9, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 82A5B570: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82A5B574: 910100BC  stw r8, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[8].u32 ) };
	// 82A5B578: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5B57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B580: 4BFC6F81  bl 0x82a22500
	ctx.lr = 0x82A5B584;
	sub_82A22500(ctx, base);
	// 82A5B584: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A5B588: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82A5B58C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A5B590: 419A0018  beq cr6, 0x82a5b5a8
	if ctx.cr[6].eq {
	pc = 0x82A5B5A8; continue 'dispatch;
	}
	// 82A5B594: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A5B598: 409A0018  bne cr6, 0x82a5b5b0
	if !ctx.cr[6].eq {
	pc = 0x82A5B5B0; continue 'dispatch;
	}
	// 82A5B59C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A5B5A0: 480FF369  bl 0x82b5a908
	ctx.lr = 0x82A5B5A4;
	sub_82B5A908(ctx, base);
	// 82A5B5A4: 4800000C  b 0x82a5b5b0
	pc = 0x82A5B5B0; continue 'dispatch;
            }
            0x82A5B5A8 => {
    //   block [0x82A5B5A8..0x82A5B5B0)
	// 82A5B5A8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A5B5AC: 480FC735  bl 0x82b57ce0
	ctx.lr = 0x82A5B5B0;
	sub_82B57CE0(ctx, base);
	pc = 0x82A5B5B0; continue 'dispatch;
            }
            0x82A5B5B0 => {
    //   block [0x82A5B5B0..0x82A5B5D8)
	// 82A5B5B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5B5B4: 48131D1D  bl 0x82b8d2d0
	ctx.lr = 0x82A5B5B8;
	sub_82B8D2D0(ctx, base);
	// 82A5B5B8: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82A5B5BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5B5C0: 4B7A0A49  bl 0x821fc008
	ctx.lr = 0x82A5B5C4;
	sub_821FC008(ctx, base);
	// 82A5B5C4: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82A5B5C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5B5CC: 4B7A0A3D  bl 0x821fc008
	ctx.lr = 0x82A5B5D0;
	sub_821FC008(ctx, base);
	// 82A5B5D0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A5B5D4: 4824DE78  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5B5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5B5D8 size=1808
    let mut pc: u32 = 0x82A5B5D8;
    'dispatch: loop {
        match pc {
            0x82A5B5D8 => {
    //   block [0x82A5B5D8..0x82A5B658)
	// 82A5B5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5B5DC: 4824DE21  bl 0x82ca93fc
	ctx.lr = 0x82A5B5E0;
	sub_82CA93D0(ctx, base);
	// 82A5B5E0: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5B5E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5B5E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5B5EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A5B5F0: 90BB0008  stw r5, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A5B5F4: 90DB0020  stw r6, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[6].u32 ) };
	// 82A5B5F8: 9B5B0024  stb r26, 0x24(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[26].u8 ) };
	// 82A5B5FC: 9B5B0025  stb r26, 0x25(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 82A5B600: 9B5B0026  stb r26, 0x26(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(38 as u32), ctx.r[26].u8 ) };
	// 82A5B604: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B608: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5B60C: 4198004C  blt cr6, 0x82a5b658
	if ctx.cr[6].lt {
	pc = 0x82A5B658; continue 'dispatch;
	}
	// 82A5B610: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5B614: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5B618: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 82A5B61C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B620: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5B624: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5B628: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B62C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5B630: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B634: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5B638: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B63C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5B640: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5B644: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5B648: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5B64C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5B650: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5B654: 48000014  b 0x82a5b668
	pc = 0x82A5B668; continue 'dispatch;
            }
            0x82A5B658 => {
    //   block [0x82A5B658..0x82A5B668)
	// 82A5B658: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B65C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82A5B660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B664: 4BFC5885  bl 0x82a20ee8
	ctx.lr = 0x82A5B668;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5B668; continue 'dispatch;
            }
            0x82A5B668 => {
    //   block [0x82A5B668..0x82A5B6A0)
	// 82A5B668: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A5B66C: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5B670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B674: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A5B678: 419A0028  beq cr6, 0x82a5b6a0
	if ctx.cr[6].eq {
	pc = 0x82A5B6A0; continue 'dispatch;
	}
	// 82A5B67C: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B680: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B684: 89610078  lbz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A5B688: 8901007B  lbz r8, 0x7b(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(123 as u32) ) } as u64;
	// 82A5B68C: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82A5B690: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 82A5B694: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A5B698: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82A5B69C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A5B6A0; continue 'dispatch;
            }
            0x82A5B6A0 => {
    //   block [0x82A5B6A0..0x82A5B6B8)
	// 82A5B6A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5B6A4: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 82A5B6A8: 48002409  bl 0x82a5dab0
	ctx.lr = 0x82A5B6AC;
	sub_82A5DAB0(ctx, base);
	// 82A5B6AC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A5B6B0: 40990024  ble cr6, 0x82a5b6d4
	if !ctx.cr[6].gt {
	pc = 0x82A5B6D4; continue 'dispatch;
	}
	// 82A5B6B4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x82A5B6B8; continue 'dispatch;
            }
            0x82A5B6B8 => {
    //   block [0x82A5B6B8..0x82A5B6D4)
	// 82A5B6B8: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5B6BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5B6C0: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A5B6C4: 4BFEDBCD  bl 0x82a49290
	ctx.lr = 0x82A5B6C8;
	sub_82A49290(ctx, base);
	// 82A5B6C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A5B6CC: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 82A5B6D0: 4082FFE8  bne 0x82a5b6b8
	if !ctx.cr[0].eq {
	pc = 0x82A5B6B8; continue 'dispatch;
	}
	pc = 0x82A5B6D4; continue 'dispatch;
            }
            0x82A5B6D4 => {
    //   block [0x82A5B6D4..0x82A5B728)
	// 82A5B6D4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B6D8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5B6DC: 4198004C  blt cr6, 0x82a5b728
	if ctx.cr[6].lt {
	pc = 0x82A5B728; continue 'dispatch;
	}
	// 82A5B6E0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5B6E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5B6E8: 39010074  addi r8, r1, 0x74
	ctx.r[8].s64 = ctx.r[1].s64 + 116;
	// 82A5B6EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B6F0: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5B6F4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5B6F8: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B6FC: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5B700: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B704: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5B708: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B70C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5B710: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5B714: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5B718: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5B71C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5B720: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5B724: 48000014  b 0x82a5b738
	pc = 0x82A5B738; continue 'dispatch;
            }
            0x82A5B728 => {
    //   block [0x82A5B728..0x82A5B738)
	// 82A5B728: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B72C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82A5B730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B734: 4BFC57B5  bl 0x82a20ee8
	ctx.lr = 0x82A5B738;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5B738; continue 'dispatch;
            }
            0x82A5B738 => {
    //   block [0x82A5B738..0x82A5B76C)
	// 82A5B738: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5B73C: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5B740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5B744: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A5B748: 419A0024  beq cr6, 0x82a5b76c
	if ctx.cr[6].eq {
	pc = 0x82A5B76C; continue 'dispatch;
	}
	// 82A5B74C: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82A5B750: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82A5B754: 89210077  lbz r9, 0x77(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82A5B758: 89010074  lbz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5B75C: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 82A5B760: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82A5B764: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82A5B768: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5B76C; continue 'dispatch;
            }
            0x82A5B76C => {
    //   block [0x82A5B76C..0x82A5B7C0)
	// 82A5B76C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B770: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5B774: 4198004C  blt cr6, 0x82a5b7c0
	if ctx.cr[6].lt {
	pc = 0x82A5B7C0; continue 'dispatch;
	}
	// 82A5B778: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5B77C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5B780: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 82A5B784: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B788: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5B78C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5B790: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B794: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5B798: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B79C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5B7A0: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B7A4: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5B7A8: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5B7AC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5B7B0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5B7B4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5B7B8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5B7BC: 48000014  b 0x82a5b7d0
	pc = 0x82A5B7D0; continue 'dispatch;
            }
            0x82A5B7C0 => {
    //   block [0x82A5B7C0..0x82A5B7D0)
	// 82A5B7C0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B7C4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A5B7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B7CC: 4BFC571D  bl 0x82a20ee8
	ctx.lr = 0x82A5B7D0;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5B7D0; continue 'dispatch;
            }
            0x82A5B7D0 => {
    //   block [0x82A5B7D0..0x82A5B808)
	// 82A5B7D0: 83210068  lwz r25, 0x68(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A5B7D4: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5B7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5B7DC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82A5B7E0: 419A0028  beq cr6, 0x82a5b808
	if ctx.cr[6].eq {
	pc = 0x82A5B808; continue 'dispatch;
	}
	// 82A5B7E4: 89010051  lbz r8, 0x51(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B7E8: 8941006B  lbz r10, 0x6b(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(107 as u32) ) } as u64;
	// 82A5B7EC: 89210068  lbz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A5B7F0: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B7F4: 99010052  stb r8, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[8].u8 ) };
	// 82A5B7F8: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82A5B7FC: 99210053  stb r9, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[9].u8 ) };
	// 82A5B800: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82A5B804: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A5B808; continue 'dispatch;
            }
            0x82A5B808 => {
    //   block [0x82A5B808..0x82A5B85C)
	// 82A5B808: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B80C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5B810: 4198004C  blt cr6, 0x82a5b85c
	if ctx.cr[6].lt {
	pc = 0x82A5B85C; continue 'dispatch;
	}
	// 82A5B814: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5B818: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5B81C: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 82A5B820: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B824: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5B828: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5B82C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B830: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5B834: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B838: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5B83C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B840: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5B844: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5B848: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5B84C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5B850: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5B854: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5B858: 48000014  b 0x82a5b86c
	pc = 0x82A5B86C; continue 'dispatch;
            }
            0x82A5B85C => {
    //   block [0x82A5B85C..0x82A5B86C)
	// 82A5B85C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B860: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82A5B864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B868: 4BFC5681  bl 0x82a20ee8
	ctx.lr = 0x82A5B86C;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5B86C; continue 'dispatch;
            }
            0x82A5B86C => {
    //   block [0x82A5B86C..0x82A5B8A0)
	// 82A5B86C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A5B870: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5B874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5B878: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A5B87C: 419A0024  beq cr6, 0x82a5b8a0
	if ctx.cr[6].eq {
	pc = 0x82A5B8A0; continue 'dispatch;
	}
	// 82A5B880: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5B884: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5B888: 8921007F  lbz r9, 0x7f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(127 as u32) ) } as u64;
	// 82A5B88C: 8901007C  lbz r8, 0x7c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A5B890: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5B894: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5B898: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5B89C: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5B8A0; continue 'dispatch;
            }
            0x82A5B8A0 => {
    //   block [0x82A5B8A0..0x82A5B8F4)
	// 82A5B8A0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B8A4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5B8A8: 4198004C  blt cr6, 0x82a5b8f4
	if ctx.cr[6].lt {
	pc = 0x82A5B8F4; continue 'dispatch;
	}
	// 82A5B8AC: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5B8B0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5B8B4: 3901006C  addi r8, r1, 0x6c
	ctx.r[8].s64 = ctx.r[1].s64 + 108;
	// 82A5B8B8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B8BC: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5B8C0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5B8C4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B8C8: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5B8CC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B8D0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5B8D4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B8D8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5B8DC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5B8E0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5B8E4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5B8E8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5B8EC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5B8F0: 48000014  b 0x82a5b904
	pc = 0x82A5B904; continue 'dispatch;
            }
            0x82A5B8F4 => {
    //   block [0x82A5B8F4..0x82A5B904)
	// 82A5B8F4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B8F8: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82A5B8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B900: 4BFC55E9  bl 0x82a20ee8
	ctx.lr = 0x82A5B904;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5B904; continue 'dispatch;
            }
            0x82A5B904 => {
    //   block [0x82A5B904..0x82A5B938)
	// 82A5B904: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A5B908: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5B90C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5B910: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5B914: 419A0024  beq cr6, 0x82a5b938
	if ctx.cr[6].eq {
	pc = 0x82A5B938; continue 'dispatch;
	}
	// 82A5B918: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82A5B91C: 89410056  lbz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82A5B920: 8921006F  lbz r9, 0x6f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 82A5B924: 8901006C  lbz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A5B928: 99610056  stb r11, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 82A5B92C: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 82A5B930: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 82A5B934: 99010057  stb r8, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5B938; continue 'dispatch;
            }
            0x82A5B938 => {
    //   block [0x82A5B938..0x82A5B98C)
	// 82A5B938: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5B93C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5B940: 4198004C  blt cr6, 0x82a5b98c
	if ctx.cr[6].lt {
	pc = 0x82A5B98C; continue 'dispatch;
	}
	// 82A5B944: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5B948: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5B94C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82A5B950: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5B954: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5B958: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5B95C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5B960: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5B964: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5B968: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5B96C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5B970: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5B974: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5B978: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5B97C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5B980: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5B984: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5B988: 48000014  b 0x82a5b99c
	pc = 0x82A5B99C; continue 'dispatch;
            }
            0x82A5B98C => {
    //   block [0x82A5B98C..0x82A5B99C)
	// 82A5B98C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5B990: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A5B994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5B998: 4BFC5551  bl 0x82a20ee8
	ctx.lr = 0x82A5B99C;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5B99C; continue 'dispatch;
            }
            0x82A5B99C => {
    //   block [0x82A5B99C..0x82A5B9D0)
	// 82A5B99C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A5B9A0: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5B9A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5B9A8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A5B9AC: 419A0024  beq cr6, 0x82a5b9d0
	if ctx.cr[6].eq {
	pc = 0x82A5B9D0; continue 'dispatch;
	}
	// 82A5B9B0: 89610081  lbz r11, 0x81(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A5B9B4: 89410082  lbz r10, 0x82(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(130 as u32) ) } as u64;
	// 82A5B9B8: 89210073  lbz r9, 0x73(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(115 as u32) ) } as u64;
	// 82A5B9BC: 89010070  lbz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A5B9C0: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 82A5B9C4: 99410081  stb r10, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[10].u8 ) };
	// 82A5B9C8: 99210080  stb r9, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u8 ) };
	// 82A5B9CC: 99010083  stb r8, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5B9D0; continue 'dispatch;
            }
            0x82A5B9D0 => {
    //   block [0x82A5B9D0..0x82A5BA00)
	// 82A5B9D0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A5B9D4: 4B7C38ED  bl 0x8221f2c0
	ctx.lr = 0x82A5B9D8;
	sub_8221F2C0(ctx, base);
	// 82A5B9D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5B9DC: 409A0120  bne cr6, 0x82a5bafc
	if !ctx.cr[6].eq {
	pc = 0x82A5BAFC; continue 'dispatch;
	}
	// 82A5B9E0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A5B9E4: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A5B9E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5B9EC: 419A0014  beq cr6, 0x82a5ba00
	if ctx.cr[6].eq {
	pc = 0x82A5BA00; continue 'dispatch;
	}
	// 82A5B9F0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5B9F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A5B9F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A5B9FC: 4E800421  bctrl
	ctx.lr = 0x82A5BA00;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BA00 => {
    //   block [0x82A5BA00..0x82A5BA08)
	// 82A5BA00: 482669A9  bl 0x82cc23a8
	ctx.lr = 0x82A5BA04;
	sub_82CC23A8(ctx, base);
	// 82A5BA04: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x82A5BA08; continue 'dispatch;
            }
            0x82A5BA08 => {
    //   block [0x82A5BA08..0x82A5BA18)
	// 82A5BA08: 807B001C  lwz r3, 0x1c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5BA0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5BA10: 419A0040  beq cr6, 0x82a5ba50
	if ctx.cr[6].eq {
	pc = 0x82A5BA50; continue 'dispatch;
	}
	// 82A5BA14: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5BA18; continue 'dispatch;
            }
            0x82A5BA18 => {
    //   block [0x82A5BA18..0x82A5BA4C)
	// 82A5BA18: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5BA1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BA20: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5BA24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5BA28: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5BA2C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BA30: 4082FFE8  bne 0x82a5ba18
	if !ctx.cr[0].eq {
	pc = 0x82A5BA18; continue 'dispatch;
	}
	// 82A5BA34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BA38: 409A0014  bne cr6, 0x82a5ba4c
	if !ctx.cr[6].eq {
	pc = 0x82A5BA4C; continue 'dispatch;
	}
	// 82A5BA3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BA40: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BA44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5BA48: 4E800421  bctrl
	ctx.lr = 0x82A5BA4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BA4C => {
    //   block [0x82A5BA4C..0x82A5BA50)
	// 82A5BA4C: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5BA50; continue 'dispatch;
            }
            0x82A5BA50 => {
    //   block [0x82A5BA50..0x82A5BAA4)
	// 82A5BA50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5BA54: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A5BA58: 81010080  lwz r8, 0x80(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A5BA5C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A5BA60: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5BA64: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A5BA68: 93DB001C  stw r30, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82A5BA6C: 57C3003E  slwi r3, r30, 0
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A5BA70: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5BA74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A5BA78: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82A5BA7C: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82A5BA80: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BA84: 4801E3E5  bl 0x82a79e68
	ctx.lr = 0x82A5BA88;
	sub_82A79E68(ctx, base);
	// 82A5BA88: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5BA8C: 807B001C  lwz r3, 0x1c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5BA90: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A5BA94: 409A0074  bne cr6, 0x82a5bb08
	if !ctx.cr[6].eq {
	pc = 0x82A5BB08; continue 'dispatch;
	}
	// 82A5BA98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5BA9C: 419A0040  beq cr6, 0x82a5badc
	if ctx.cr[6].eq {
	pc = 0x82A5BADC; continue 'dispatch;
	}
	// 82A5BAA0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5BAA4; continue 'dispatch;
            }
            0x82A5BAA4 => {
    //   block [0x82A5BAA4..0x82A5BAD8)
	// 82A5BAA4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5BAA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BAAC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5BAB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5BAB4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5BAB8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BABC: 4082FFE8  bne 0x82a5baa4
	if !ctx.cr[0].eq {
	pc = 0x82A5BAA4; continue 'dispatch;
	}
	// 82A5BAC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BAC4: 409A0014  bne cr6, 0x82a5bad8
	if !ctx.cr[6].eq {
	pc = 0x82A5BAD8; continue 'dispatch;
	}
	// 82A5BAC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BACC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BAD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5BAD4: 4E800421  bctrl
	ctx.lr = 0x82A5BAD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BAD8 => {
    //   block [0x82A5BAD8..0x82A5BADC)
	// 82A5BAD8: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5BADC; continue 'dispatch;
            }
            0x82A5BADC => {
    //   block [0x82A5BADC..0x82A5BAF0)
	// 82A5BADC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82A5BAE0: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 82A5BAE4: 4099000C  ble cr6, 0x82a5baf0
	if !ctx.cr[6].gt {
	pc = 0x82A5BAF0; continue 'dispatch;
	}
	// 82A5BAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5BAEC: 4BFC574D  bl 0x82a21238
	ctx.lr = 0x82A5BAF0;
	sub_82A21238(ctx, base);
	pc = 0x82A5BAF0; continue 'dispatch;
            }
            0x82A5BAF0 => {
    //   block [0x82A5BAF0..0x82A5BAFC)
	// 82A5BAF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5BAF4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A5BAF8: 4824D954  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5BAFC => {
    //   block [0x82A5BAFC..0x82A5BB08)
	// 82A5BAFC: 4801DF75  bl 0x82a79a70
	ctx.lr = 0x82A5BB00;
	sub_82A79A70(ctx, base);
	// 82A5BB00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5BB04: 4BFFFF04  b 0x82a5ba08
	pc = 0x82A5BA08; continue 'dispatch;
            }
            0x82A5BB08 => {
    //   block [0x82A5BB08..0x82A5BB38)
	// 82A5BB08: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A5BB0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5BB10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A5BB14: 4B7C2FDD  bl 0x8221eaf0
	ctx.lr = 0x82A5BB18;
	sub_8221EAF0(ctx, base);
	// 82A5BB18: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5BB1C: 3B8B2A40  addi r28, r11, 0x2a40
	ctx.r[28].s64 = ctx.r[11].s64 + 10816;
	// 82A5BB20: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82A5BB24: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5BB2C: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82A5BB30: 419A0008  beq cr6, 0x82a5bb38
	if ctx.cr[6].eq {
	pc = 0x82A5BB38; continue 'dispatch;
	}
	// 82A5BB34: 4B7A0645  bl 0x821fc178
	ctx.lr = 0x82A5BB38;
	sub_821FC178(ctx, base);
	pc = 0x82A5BB38; continue 'dispatch;
            }
            0x82A5BB38 => {
    //   block [0x82A5BB38..0x82A5BBFC)
	// 82A5BB38: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5BB3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5BB40: 3BAB2A30  addi r29, r11, 0x2a30
	ctx.r[29].s64 = ctx.r[11].s64 + 10800;
	// 82A5BB44: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A5BB48: 48125F49  bl 0x82b81a90
	ctx.lr = 0x82A5BB4C;
	sub_82B81A90(ctx, base);
	// 82A5BB4C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82A5BB50: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A5BB54: 93410098  stw r26, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 82A5BB58: 392BB3F8  addi r9, r11, -0x4c08
	ctx.r[9].s64 = ctx.r[11].s64 + -19464;
	// 82A5BB5C: 9341009C  stw r26, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[26].u32 ) };
	// 82A5BB60: 390A2A2C  addi r8, r10, 0x2a2c
	ctx.r[8].s64 = ctx.r[10].s64 + 10796;
	// 82A5BB64: 934100A0  stw r26, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 82A5BB68: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82A5BB6C: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 82A5BB70: 91010094  stw r8, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 82A5BB74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A5BB78: 934100A4  stw r26, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[26].u32 ) };
	// 82A5BB7C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A5BB80: 90E100A8  stw r7, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[7].u32 ) };
	// 82A5BB84: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A5BB88: 934100AC  stw r26, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[26].u32 ) };
	// 82A5BB8C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A5BB90: 481317B9  bl 0x82b8d348
	ctx.lr = 0x82A5BB94;
	sub_82B8D348(ctx, base);
	// 82A5BB94: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82A5BB98: 3CC082B5  lis r6, -0x7d4b
	ctx.r[6].s64 = -2102067200;
	// 82A5BB9C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BBA0: 3CA082B5  lis r5, -0x7d4b
	ctx.r[5].s64 = -2102067200;
	// 82A5BBA4: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A5BBA8: 3866EF48  addi r3, r6, -0x10b8
	ctx.r[3].s64 = ctx.r[6].s64 + -4280;
	// 82A5BBAC: 934100B4  stw r26, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[26].u32 ) };
	// 82A5BBB0: 3BCB9BF8  addi r30, r11, -0x6408
	ctx.r[30].s64 = ctx.r[11].s64 + -25608;
	// 82A5BBB4: 934100E0  stw r26, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[26].u32 ) };
	// 82A5BBB8: 3965EF50  addi r11, r5, -0x10b0
	ctx.r[11].s64 = ctx.r[5].s64 + -4272;
	// 82A5BBBC: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 82A5BBC0: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5BBC4: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82A5BBC8: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82A5BBCC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A5BBD0: 916100DC  stw r11, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82A5BBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5BBD8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A5BBDC: 4E800421  bctrl
	ctx.lr = 0x82A5BBE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5BBE0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5BBE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5BBE8: 409A00A8  bne cr6, 0x82a5bc90
	if !ctx.cr[6].eq {
	pc = 0x82A5BC90; continue 'dispatch;
	}
	// 82A5BBEC: 807B001C  lwz r3, 0x1c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5BBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5BBF4: 419A0040  beq cr6, 0x82a5bc34
	if ctx.cr[6].eq {
	pc = 0x82A5BC34; continue 'dispatch;
	}
	// 82A5BBF8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
            }
            0x82A5BBFC => {
    //   block [0x82A5BBFC..0x82A5BC30)
	// 82A5BBFC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5BC00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BC04: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5BC08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5BC0C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5BC10: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BC14: 4082FFE8  bne 0x82a5bbfc
	if !ctx.cr[0].eq {
	pc = 0x82A5BBFC; continue 'dispatch;
	}
	// 82A5BC18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BC1C: 409A0014  bne cr6, 0x82a5bc30
	if !ctx.cr[6].eq {
	pc = 0x82A5BC30; continue 'dispatch;
	}
	// 82A5BC20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BC24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BC28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5BC2C: 4E800421  bctrl
	ctx.lr = 0x82A5BC30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BC30 => {
    //   block [0x82A5BC30..0x82A5BC34)
	// 82A5BC30: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5BC34; continue 'dispatch;
            }
            0x82A5BC34 => {
    //   block [0x82A5BC34..0x82A5BC5C)
	// 82A5BC34: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5BC38: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82A5BC3C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A5BC40: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 82A5BC44: 419A0018  beq cr6, 0x82a5bc5c
	if ctx.cr[6].eq {
	pc = 0x82A5BC5C; continue 'dispatch;
	}
	// 82A5BC48: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A5BC4C: 409A0018  bne cr6, 0x82a5bc64
	if !ctx.cr[6].eq {
	pc = 0x82A5BC64; continue 'dispatch;
	}
	// 82A5BC50: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A5BC54: 480FECB5  bl 0x82b5a908
	ctx.lr = 0x82A5BC58;
	sub_82B5A908(ctx, base);
	// 82A5BC58: 4800000C  b 0x82a5bc64
	pc = 0x82A5BC64; continue 'dispatch;
            }
            0x82A5BC5C => {
    //   block [0x82A5BC5C..0x82A5BC64)
	// 82A5BC5C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A5BC60: 480FC081  bl 0x82b57ce0
	ctx.lr = 0x82A5BC64;
	sub_82B57CE0(ctx, base);
	pc = 0x82A5BC64; continue 'dispatch;
            }
            0x82A5BC64 => {
    //   block [0x82A5BC64..0x82A5BC90)
	// 82A5BC64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A5BC68: 48131669  bl 0x82b8d2d0
	ctx.lr = 0x82A5BC6C;
	sub_82B8D2D0(ctx, base);
	// 82A5BC6C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A5BC70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5BC74: 4B7A0395  bl 0x821fc008
	ctx.lr = 0x82A5BC78;
	sub_821FC008(ctx, base);
	// 82A5BC78: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82A5BC7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5BC80: 4B7A0389  bl 0x821fc008
	ctx.lr = 0x82A5BC84;
	sub_821FC008(ctx, base);
	// 82A5BC84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5BC88: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A5BC8C: 4824D7C0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5BC90 => {
    //   block [0x82A5BC90..0x82A5BCB4)
	// 82A5BC90: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5BC94: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82A5BC98: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A5BC9C: 419A0018  beq cr6, 0x82a5bcb4
	if ctx.cr[6].eq {
	pc = 0x82A5BCB4; continue 'dispatch;
	}
	// 82A5BCA0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A5BCA4: 409A0018  bne cr6, 0x82a5bcbc
	if !ctx.cr[6].eq {
	pc = 0x82A5BCBC; continue 'dispatch;
	}
	// 82A5BCA8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A5BCAC: 480FEC5D  bl 0x82b5a908
	ctx.lr = 0x82A5BCB0;
	sub_82B5A908(ctx, base);
	// 82A5BCB0: 4800000C  b 0x82a5bcbc
	pc = 0x82A5BCBC; continue 'dispatch;
            }
            0x82A5BCB4 => {
    //   block [0x82A5BCB4..0x82A5BCBC)
	// 82A5BCB4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A5BCB8: 480FC029  bl 0x82b57ce0
	ctx.lr = 0x82A5BCBC;
	sub_82B57CE0(ctx, base);
	pc = 0x82A5BCBC; continue 'dispatch;
            }
            0x82A5BCBC => {
    //   block [0x82A5BCBC..0x82A5BCE8)
	// 82A5BCBC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A5BCC0: 48131611  bl 0x82b8d2d0
	ctx.lr = 0x82A5BCC4;
	sub_82B8D2D0(ctx, base);
	// 82A5BCC4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A5BCC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5BCCC: 4B7A033D  bl 0x821fc008
	ctx.lr = 0x82A5BCD0;
	sub_821FC008(ctx, base);
	// 82A5BCD0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82A5BCD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5BCD8: 4B7A0331  bl 0x821fc008
	ctx.lr = 0x82A5BCDC;
	sub_821FC008(ctx, base);
	// 82A5BCDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A5BCE0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A5BCE4: 4824D768  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5BCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A5BCE8 size=1100
    let mut pc: u32 = 0x82A5BCE8;
    'dispatch: loop {
        match pc {
            0x82A5BCE8 => {
    //   block [0x82A5BCE8..0x82A5BD28)
	// 82A5BCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5BCEC: 4824D70D  bl 0x82ca93f8
	ctx.lr = 0x82A5BCF0;
	sub_82CA93D0(ctx, base);
	// 82A5BCF0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5BCF4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A5BCF8: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82A5BCFC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A5BD00: 3B800040  li r28, 0x40
	ctx.r[28].s64 = 64;
	// 82A5BD04: 3B600040  li r27, 0x40
	ctx.r[27].s64 = 64;
	// 82A5BD08: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5BD0C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82A5BD10: 813A0010  lwz r9, 0x10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5BD14: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A5BD18: 7D6853D7  divw. r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BD1C: 408100A4  ble 0x82a5bdc0
	if !ctx.cr[0].gt {
	pc = 0x82A5BDC0; continue 'dispatch;
	}
	// 82A5BD20: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82A5BD24: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x82A5BD28; continue 'dispatch;
            }
            0x82A5BD28 => {
    //   block [0x82A5BD28..0x82A5BD7C)
	// 82A5BD28: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5BD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5BD30: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A5BD34: 4B74FD65  bl 0x821aba98
	ctx.lr = 0x82A5BD38;
	sub_821ABA98(ctx, base);
	// 82A5BD38: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5BD3C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82A5BD40: 81030094  lwz r8, 0x94(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A5BD44: 80E30098  lwz r7, 0x98(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A5BD48: 80C300A0  lwz r6, 0xa0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 82A5BD4C: 7CA8E050  subf r5, r8, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[8].s64;
	// 82A5BD50: 7C87D850  subf r4, r7, r27
	ctx.r[4].s64 = ctx.r[27].s64 - ctx.r[7].s64;
	// 82A5BD54: 7D06F850  subf r8, r6, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[6].s64;
	// 82A5BD58: 7CA7FE70  srawi r7, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 82A5BD5C: 7C86FE70  srawi r6, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 82A5BD60: 7D18FE70  srawi r24, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82A5BD64: 7CE52838  and r5, r7, r5
	ctx.r[5].u64 = ctx.r[7].u64 & ctx.r[5].u64;
	// 82A5BD68: 7CC42038  and r4, r6, r4
	ctx.r[4].u64 = ctx.r[6].u64 & ctx.r[4].u64;
	// 82A5BD6C: 7F084038  and r8, r24, r8
	ctx.r[8].u64 = ctx.r[24].u64 & ctx.r[8].u64;
	// 82A5BD70: 7F85E050  subf r28, r5, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[5].s64;
	// 82A5BD74: 7F64D850  subf r27, r4, r27
	ctx.r[27].s64 = ctx.r[27].s64 - ctx.r[4].s64;
	// 82A5BD78: 7FE8F850  subf r31, r8, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	pc = 0x82A5BD7C; continue 'dispatch;
            }
            0x82A5BD7C => {
    //   block [0x82A5BD7C..0x82A5BDB0)
	// 82A5BD7C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5BD80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BD84: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5BD88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5BD8C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5BD90: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BD94: 4082FFE8  bne 0x82a5bd7c
	if !ctx.cr[0].eq {
	pc = 0x82A5BD7C; continue 'dispatch;
	}
	// 82A5BD98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BD9C: 409A0014  bne cr6, 0x82a5bdb0
	if !ctx.cr[6].eq {
	pc = 0x82A5BDB0; continue 'dispatch;
	}
	// 82A5BDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BDA4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BDA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5BDAC: 4E800421  bctrl
	ctx.lr = 0x82A5BDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BDB0 => {
    //   block [0x82A5BDB0..0x82A5BDC0)
	// 82A5BDB0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A5BDB4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82A5BDB8: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 82A5BDBC: 4082FF6C  bne 0x82a5bd28
	if !ctx.cr[0].eq {
	pc = 0x82A5BD28; continue 'dispatch;
	}
	pc = 0x82A5BDC0; continue 'dispatch;
            }
            0x82A5BDC0 => {
    //   block [0x82A5BDC0..0x82A5BDD0)
	// 82A5BDC0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A5BDC4: 394BAB00  addi r10, r11, -0x5500
	ctx.r[10].s64 = ctx.r[11].s64 + -21760;
	// 82A5BDC8: 816BAB00  lwz r11, -0x5500(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21760 as u32) ) } as u64;
	// 82A5BDCC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5BDD0; continue 'dispatch;
            }
            0x82A5BDD0 => {
    //   block [0x82A5BDD0..0x82A5BDE0)
	// 82A5BDD0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5BDD4: 4199000C  bgt cr6, 0x82a5bde0
	if ctx.cr[6].gt {
	pc = 0x82A5BDE0; continue 'dispatch;
	}
	// 82A5BDD8: 7F1B5000  cmpw cr6, r27, r10
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A5BDDC: 4099001C  ble cr6, 0x82a5bdf8
	if !ctx.cr[6].gt {
	pc = 0x82A5BDF8; continue 'dispatch;
	}
	pc = 0x82A5BDE0; continue 'dispatch;
            }
            0x82A5BDE0 => {
    //   block [0x82A5BDE0..0x82A5BDF8)
	// 82A5BDE0: 7F890E70  srawi r9, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 82A5BDE4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82A5BDE8: 7F890194  addze r28, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[28].s64 = tmp.s64;
	// 82A5BDEC: 7F680E70  srawi r8, r27, 1
	ctx.xer.ca = (ctx.r[27].s32 < 0) && ((ctx.r[27].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[27].s32 >> 1) as i64;
	// 82A5BDF0: 7F680194  addze r27, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[27].s64 = tmp.s64;
	// 82A5BDF4: 4BFFFFDC  b 0x82a5bdd0
	pc = 0x82A5BDD0; continue 'dispatch;
            }
            0x82A5BDF8 => {
    //   block [0x82A5BDF8..0x82A5BE1C)
	// 82A5BDF8: 897A0024  lbz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5BDFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5BE00: 419A003C  beq cr6, 0x82a5be3c
	if ctx.cr[6].eq {
	pc = 0x82A5BE3C; continue 'dispatch;
	}
	// 82A5BE04: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A5BE08: 7F8BFE30  sraw r11, r28, r31
	tmp.u32 = ctx.r[31].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> tmp.u32) as i64;
	// 82A5BE0C: 390AABB0  addi r8, r10, -0x5450
	ctx.r[8].s64 = ctx.r[10].s64 + -21584;
	// 82A5BE10: 812AABB0  lwz r9, -0x5450(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21584 as u32) ) } as u64;
	// 82A5BE14: 7F6AFE30  sraw r10, r27, r31
	tmp.u32 = ctx.r[31].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[27].s32 < 0) && ((ctx.r[27].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[27].s32 >> tmp.u32) as i64;
	// 82A5BE18: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5BE1C; continue 'dispatch;
            }
            0x82A5BE1C => {
    //   block [0x82A5BE1C..0x82A5BE2C)
	// 82A5BE1C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A5BE20: 4198000C  blt cr6, 0x82a5be2c
	if ctx.cr[6].lt {
	pc = 0x82A5BE2C; continue 'dispatch;
	}
	// 82A5BE24: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A5BE28: 40980014  bge cr6, 0x82a5be3c
	if !ctx.cr[6].lt {
	pc = 0x82A5BE3C; continue 'dispatch;
	}
	pc = 0x82A5BE2C; continue 'dispatch;
            }
            0x82A5BE2C => {
    //   block [0x82A5BE2C..0x82A5BE3C)
	// 82A5BE2C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5BE30: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5BE34: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82A5BE38: 4BFFFFE4  b 0x82a5be1c
	pc = 0x82A5BE1C; continue 'dispatch;
            }
            0x82A5BE3C => {
    //   block [0x82A5BE3C..0x82A5BE74)
	// 82A5BE3C: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82A5BE40: 809A0010  lwz r4, 0x10(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5BE44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5BE48: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82A5BE4C: 7D495838  and r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82A5BE50: 7FA9F850  subf r29, r9, r31
	ctx.r[29].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	// 82A5BE54: 4B74FC45  bl 0x821aba98
	ctx.lr = 0x82A5BE58;
	sub_821ABA98(ctx, base);
	// 82A5BE58: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BE5C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5BE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5BE64: 83E8009C  lwz r31, 0x9c(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A5BE68: 419A0048  beq cr6, 0x82a5beb0
	if ctx.cr[6].eq {
	pc = 0x82A5BEB0; continue 'dispatch;
	}
	// 82A5BE6C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A5BE70: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5BE74; continue 'dispatch;
            }
            0x82A5BE74 => {
    //   block [0x82A5BE74..0x82A5BEAC)
	// 82A5BE74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5BE78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BE7C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5BE80: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5BE84: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5BE88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BE8C: 4082FFE8  bne 0x82a5be74
	if !ctx.cr[0].eq {
	pc = 0x82A5BE74; continue 'dispatch;
	}
	// 82A5BE90: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5BE94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BE98: 409A0014  bne cr6, 0x82a5beac
	if !ctx.cr[6].eq {
	pc = 0x82A5BEAC; continue 'dispatch;
	}
	// 82A5BE9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BEA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BEA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5BEA8: 4E800421  bctrl
	ctx.lr = 0x82A5BEAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BEAC => {
    //   block [0x82A5BEAC..0x82A5BEB0)
	// 82A5BEAC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	pc = 0x82A5BEB0; continue 'dispatch;
            }
            0x82A5BEB0 => {
    //   block [0x82A5BEB0..0x82A5BED4)
	// 82A5BEB0: 2F1F0028  cmpwi cr6, r31, 0x28
	ctx.cr[6].compare_i32(ctx.r[31].s32, 40, &mut ctx.xer);
	// 82A5BEB4: 409A0020  bne cr6, 0x82a5bed4
	if !ctx.cr[6].eq {
	pc = 0x82A5BED4; continue 'dispatch;
	}
	// 82A5BEB8: 897A0024  lbz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5BEBC: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82A5BEC0: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A5BEC4: 552A003A  rlwinm r10, r9, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5BEC8: 554A06F2  rlwinm r10, r10, 0, 0x1b, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5BECC: 3BCA0028  addi r30, r10, 0x28
	ctx.r[30].s64 = ctx.r[10].s64 + 40;
	// 82A5BED0: 4800003C  b 0x82a5bf0c
	pc = 0x82A5BF0C; continue 'dispatch;
            }
            0x82A5BED4 => {
    //   block [0x82A5BED4..0x82A5BF04)
	// 82A5BED4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A5BED8: 4BFFEF99  bl 0x82a5ae70
	ctx.lr = 0x82A5BEDC;
	sub_82A5AE70(ctx, base);
	// 82A5BEDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5BEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5BEE4: 897A0024  lbz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5BEE8: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 82A5BEEC: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A5BEF0: 419A0014  beq cr6, 0x82a5bf04
	if ctx.cr[6].eq {
	pc = 0x82A5BF04; continue 'dispatch;
	}
	// 82A5BEF4: 552A07FA  rlwinm r10, r9, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5BEF8: 554A06F2  rlwinm r10, r10, 0, 0x1b, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5BEFC: 3BCA0025  addi r30, r10, 0x25
	ctx.r[30].s64 = ctx.r[10].s64 + 37;
	// 82A5BF00: 4800000C  b 0x82a5bf0c
	pc = 0x82A5BF0C; continue 'dispatch;
            }
            0x82A5BF04 => {
    //   block [0x82A5BF04..0x82A5BF0C)
	// 82A5BF04: 552A07F4  rlwinm r10, r9, 0, 0x1f, 0x1a
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5BF08: 3BCA0023  addi r30, r10, 0x23
	ctx.r[30].s64 = ctx.r[10].s64 + 35;
	pc = 0x82A5BF0C; continue 'dispatch;
            }
            0x82A5BF0C => {
    //   block [0x82A5BF0C..0x82A5BF40)
	// 82A5BF0C: 815A001C  lwz r10, 0x1c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5BF10: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A5BF14: 419A0054  beq cr6, 0x82a5bf68
	if ctx.cr[6].eq {
	pc = 0x82A5BF68; continue 'dispatch;
	}
	// 82A5BF18: 892A0081  lbz r9, 0x81(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A5BF1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5BF20: 419A0048  beq cr6, 0x82a5bf68
	if ctx.cr[6].eq {
	pc = 0x82A5BF68; continue 'dispatch;
	}
	// 82A5BF24: 810A0094  lwz r8, 0x94(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A5BF28: 812A0098  lwz r9, 0x98(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A5BF2C: 7F08E000  cmpw cr6, r8, r28
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A5BF30: 409A0010  bne cr6, 0x82a5bf40
	if !ctx.cr[6].eq {
	pc = 0x82A5BF40; continue 'dispatch;
	}
	// 82A5BF34: 7F09D800  cmpw cr6, r9, r27
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82A5BF38: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A5BF3C: 419A0008  beq cr6, 0x82a5bf44
	if ctx.cr[6].eq {
	pc = 0x82A5BF44; continue 'dispatch;
	}
	pc = 0x82A5BF40; continue 'dispatch;
            }
            0x82A5BF40 => {
    //   block [0x82A5BF40..0x82A5BF44)
	// 82A5BF40: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x82A5BF44; continue 'dispatch;
            }
            0x82A5BF44 => {
    //   block [0x82A5BF44..0x82A5BF68)
	// 82A5BF44: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82A5BF48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5BF4C: 419A001C  beq cr6, 0x82a5bf68
	if ctx.cr[6].eq {
	pc = 0x82A5BF68; continue 'dispatch;
	}
	// 82A5BF50: 814A009C  lwz r10, 0x9c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A5BF54: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82A5BF58: 409A0010  bne cr6, 0x82a5bf68
	if !ctx.cr[6].eq {
	pc = 0x82A5BF68; continue 'dispatch;
	}
	// 82A5BF5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A5BF60: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5BF64: 4824D4E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5BF68 => {
    //   block [0x82A5BF68..0x82A5BF80)
	// 82A5BF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5BF6C: 409A0014  bne cr6, 0x82a5bf80
	if !ctx.cr[6].eq {
	pc = 0x82A5BF80; continue 'dispatch;
	}
	// 82A5BF70: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5BF74: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 82A5BF78: 806BFA0C  lwz r3, -0x5f4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 82A5BF7C: 4B859055  bl 0x822b4fd0
	ctx.lr = 0x82A5BF80;
	sub_822B4FD0(ctx, base);
	pc = 0x82A5BF80; continue 'dispatch;
            }
            0x82A5BF80 => {
    //   block [0x82A5BF80..0x82A5BFA8)
	// 82A5BF80: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5BF84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BF88: 419A005C  beq cr6, 0x82a5bfe4
	if ctx.cr[6].eq {
	pc = 0x82A5BFE4; continue 'dispatch;
	}
	// 82A5BF8C: 896B0081  lbz r11, 0x81(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A5BF90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5BF94: 409A0050  bne cr6, 0x82a5bfe4
	if !ctx.cr[6].eq {
	pc = 0x82A5BFE4; continue 'dispatch;
	}
	// 82A5BF98: 807A001C  lwz r3, 0x1c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5BF9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5BFA0: 419A0040  beq cr6, 0x82a5bfe0
	if ctx.cr[6].eq {
	pc = 0x82A5BFE0; continue 'dispatch;
	}
	// 82A5BFA4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5BFA8; continue 'dispatch;
            }
            0x82A5BFA8 => {
    //   block [0x82A5BFA8..0x82A5BFDC)
	// 82A5BFA8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5BFAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BFB0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5BFB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5BFB8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5BFBC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5BFC0: 4082FFE8  bne 0x82a5bfa8
	if !ctx.cr[0].eq {
	pc = 0x82A5BFA8; continue 'dispatch;
	}
	// 82A5BFC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5BFC8: 409A0014  bne cr6, 0x82a5bfdc
	if !ctx.cr[6].eq {
	pc = 0x82A5BFDC; continue 'dispatch;
	}
	// 82A5BFCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5BFD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5BFD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5BFD8: 4E800421  bctrl
	ctx.lr = 0x82A5BFDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5BFDC => {
    //   block [0x82A5BFDC..0x82A5BFE0)
	// 82A5BFDC: 933A001C  stw r25, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	pc = 0x82A5BFE0; continue 'dispatch;
            }
            0x82A5BFE0 => {
    //   block [0x82A5BFE0..0x82A5BFE4)
	// 82A5BFE0: 933A001C  stw r25, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	pc = 0x82A5BFE4; continue 'dispatch;
            }
            0x82A5BFE4 => {
    //   block [0x82A5BFE4..0x82A5C014)
	// 82A5BFE4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A5BFE8: 4B7C32D9  bl 0x8221f2c0
	ctx.lr = 0x82A5BFEC;
	sub_8221F2C0(ctx, base);
	// 82A5BFEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5BFF0: 409A0138  bne cr6, 0x82a5c128
	if !ctx.cr[6].eq {
	pc = 0x82A5C128; continue 'dispatch;
	}
	// 82A5BFF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A5BFF8: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A5BFFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5C000: 419A0014  beq cr6, 0x82a5c014
	if ctx.cr[6].eq {
	pc = 0x82A5C014; continue 'dispatch;
	}
	// 82A5C004: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5C008: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A5C00C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A5C010: 4E800421  bctrl
	ctx.lr = 0x82A5C014;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C014 => {
    //   block [0x82A5C014..0x82A5C01C)
	// 82A5C014: 48266395  bl 0x82cc23a8
	ctx.lr = 0x82A5C018;
	sub_82CC23A8(ctx, base);
	// 82A5C018: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x82A5C01C; continue 'dispatch;
            }
            0x82A5C01C => {
    //   block [0x82A5C01C..0x82A5C060)
	// 82A5C01C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A5C020: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A5C024: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82A5C028: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A5C02C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5C030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5C034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C038: 4801DE31  bl 0x82a79e68
	ctx.lr = 0x82A5C03C;
	sub_82A79E68(ctx, base);
	// 82A5C03C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5C040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C044: 419A0080  beq cr6, 0x82a5c0c4
	if ctx.cr[6].eq {
	pc = 0x82A5C0C4; continue 'dispatch;
	}
	// 82A5C048: 807A001C  lwz r3, 0x1c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5C04C: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5C050: 419A0074  beq cr6, 0x82a5c0c4
	if ctx.cr[6].eq {
	pc = 0x82A5C0C4; continue 'dispatch;
	}
	// 82A5C054: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C058: 419A0040  beq cr6, 0x82a5c098
	if ctx.cr[6].eq {
	pc = 0x82A5C098; continue 'dispatch;
	}
	// 82A5C05C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C060; continue 'dispatch;
            }
            0x82A5C060 => {
    //   block [0x82A5C060..0x82A5C094)
	// 82A5C060: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C064: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C068: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C06C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C070: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C074: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C078: 4082FFE8  bne 0x82a5c060
	if !ctx.cr[0].eq {
	pc = 0x82A5C060; continue 'dispatch;
	}
	// 82A5C07C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C080: 409A0014  bne cr6, 0x82a5c094
	if !ctx.cr[6].eq {
	pc = 0x82A5C094; continue 'dispatch;
	}
	// 82A5C084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C088: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C08C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C090: 4E800421  bctrl
	ctx.lr = 0x82A5C094;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C094 => {
    //   block [0x82A5C094..0x82A5C098)
	// 82A5C094: 933A001C  stw r25, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	pc = 0x82A5C098; continue 'dispatch;
            }
            0x82A5C098 => {
    //   block [0x82A5C098..0x82A5C0A8)
	// 82A5C098: 93FA001C  stw r31, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82A5C09C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5C0A0: 419A0024  beq cr6, 0x82a5c0c4
	if ctx.cr[6].eq {
	pc = 0x82A5C0C4; continue 'dispatch;
	}
	// 82A5C0A4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5C0A8; continue 'dispatch;
            }
            0x82A5C0A8 => {
    //   block [0x82A5C0A8..0x82A5C0C4)
	// 82A5C0A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C0AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C0B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C0B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5C0B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C0BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C0C0: 4082FFE8  bne 0x82a5c0a8
	if !ctx.cr[0].eq {
	pc = 0x82A5C0A8; continue 'dispatch;
	}
	pc = 0x82A5C0C4; continue 'dispatch;
            }
            0x82A5C0C4 => {
    //   block [0x82A5C0C4..0x82A5C0E0)
	// 82A5C0C4: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5C0C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5C0CC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A5C0D0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82A5C0D4: 693E0001  xori r30, r9, 1
	ctx.r[30].u64 = ctx.r[9].u64 ^ 1;
	// 82A5C0D8: 419A0044  beq cr6, 0x82a5c11c
	if ctx.cr[6].eq {
	pc = 0x82A5C11C; continue 'dispatch;
	}
	// 82A5C0DC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5C0E0; continue 'dispatch;
            }
            0x82A5C0E0 => {
    //   block [0x82A5C0E0..0x82A5C11C)
	// 82A5C0E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C0E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C0E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C0EC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5C0F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C0F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C0F8: 4082FFE8  bne 0x82a5c0e0
	if !ctx.cr[0].eq {
	pc = 0x82A5C0E0; continue 'dispatch;
	}
	// 82A5C0FC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5C100: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C104: 409A0018  bne cr6, 0x82a5c11c
	if !ctx.cr[6].eq {
	pc = 0x82A5C11C; continue 'dispatch;
	}
	// 82A5C108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C10C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C110: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C114: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C118: 4E800421  bctrl
	ctx.lr = 0x82A5C11C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C11C => {
    //   block [0x82A5C11C..0x82A5C128)
	// 82A5C11C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5C120: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5C124: 4824D324  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5C128 => {
    //   block [0x82A5C128..0x82A5C134)
	// 82A5C128: 4801D949  bl 0x82a79a70
	ctx.lr = 0x82A5C12C;
	sub_82A79A70(ctx, base);
	// 82A5C12C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5C130: 4BFFFEEC  b 0x82a5c01c
	pc = 0x82A5C01C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C138 size=280
    let mut pc: u32 = 0x82A5C138;
    'dispatch: loop {
        match pc {
            0x82A5C138 => {
    //   block [0x82A5C138..0x82A5C180)
	// 82A5C138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5C140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5C144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5C148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C14C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5C150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5C154: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5C158: 388BFFDC  addi r4, r11, -0x24
	ctx.r[4].s64 = ctx.r[11].s64 + -36;
	// 82A5C15C: 4B74F93D  bl 0x821aba98
	ctx.lr = 0x82A5C160;
	sub_821ABA98(ctx, base);
	// 82A5C160: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5C164: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5C168: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C16C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5C170: 419A007C  beq cr6, 0x82a5c1ec
	if ctx.cr[6].eq {
	pc = 0x82A5C1EC; continue 'dispatch;
	}
	// 82A5C174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C178: 419A0044  beq cr6, 0x82a5c1bc
	if ctx.cr[6].eq {
	pc = 0x82A5C1BC; continue 'dispatch;
	}
	// 82A5C17C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C180; continue 'dispatch;
            }
            0x82A5C180 => {
    //   block [0x82A5C180..0x82A5C1B4)
	// 82A5C180: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C188: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C18C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C190: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C194: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C198: 4082FFE8  bne 0x82a5c180
	if !ctx.cr[0].eq {
	pc = 0x82A5C180; continue 'dispatch;
	}
	// 82A5C19C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C1A0: 409A0014  bne cr6, 0x82a5c1b4
	if !ctx.cr[6].eq {
	pc = 0x82A5C1B4; continue 'dispatch;
	}
	// 82A5C1A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C1A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C1AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C1B0: 4E800421  bctrl
	ctx.lr = 0x82A5C1B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C1B4 => {
    //   block [0x82A5C1B4..0x82A5C1BC)
	// 82A5C1B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5C1B8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5C1BC; continue 'dispatch;
            }
            0x82A5C1BC => {
    //   block [0x82A5C1BC..0x82A5C1D0)
	// 82A5C1BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C1C4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A5C1C8: 419A0024  beq cr6, 0x82a5c1ec
	if ctx.cr[6].eq {
	pc = 0x82A5C1EC; continue 'dispatch;
	}
	// 82A5C1CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5C1D0; continue 'dispatch;
            }
            0x82A5C1D0 => {
    //   block [0x82A5C1D0..0x82A5C1EC)
	// 82A5C1D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C1D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C1D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C1DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5C1E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C1E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C1E8: 4082FFE8  bne 0x82a5c1d0
	if !ctx.cr[0].eq {
	pc = 0x82A5C1D0; continue 'dispatch;
	}
	pc = 0x82A5C1EC; continue 'dispatch;
            }
            0x82A5C1EC => {
    //   block [0x82A5C1EC..0x82A5C200)
	// 82A5C1EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5C1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C1F4: 419A0044  beq cr6, 0x82a5c238
	if ctx.cr[6].eq {
	pc = 0x82A5C238; continue 'dispatch;
	}
	// 82A5C1F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A5C1FC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5C200; continue 'dispatch;
            }
            0x82A5C200 => {
    //   block [0x82A5C200..0x82A5C238)
	// 82A5C200: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C204: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C208: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C20C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5C210: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C214: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C218: 4082FFE8  bne 0x82a5c200
	if !ctx.cr[0].eq {
	pc = 0x82A5C200; continue 'dispatch;
	}
	// 82A5C21C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5C220: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C224: 409A0014  bne cr6, 0x82a5c238
	if !ctx.cr[6].eq {
	pc = 0x82A5C238; continue 'dispatch;
	}
	// 82A5C228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C22C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C230: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C234: 4E800421  bctrl
	ctx.lr = 0x82A5C238;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C238 => {
    //   block [0x82A5C238..0x82A5C250)
	// 82A5C238: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5C23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5C240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5C244: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5C248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5C24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C250 size=200
    let mut pc: u32 = 0x82A5C250;
    'dispatch: loop {
        match pc {
            0x82A5C250 => {
    //   block [0x82A5C250..0x82A5C2C0)
	// 82A5C250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C254: 4824D1A9  bl 0x82ca93fc
	ctx.lr = 0x82A5C258;
	sub_82CA93D0(ctx, base);
	// 82A5C258: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C25C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5C260: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A5C264: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5C268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A5C26C: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5C270: 4B7C2881  bl 0x8221eaf0
	ctx.lr = 0x82A5C274;
	sub_8221EAF0(ctx, base);
	// 82A5C274: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5C278: 8B9E0024  lbz r28, 0x24(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5C27C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A5C280: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5C284: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82A5C288: 4BFFEBE9  bl 0x82a5ae70
	ctx.lr = 0x82A5C28C;
	sub_82A5AE70(ctx, base);
	// 82A5C28C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5C290: 3B5E000C  addi r26, r30, 0xc
	ctx.r[26].s64 = ctx.r[30].s64 + 12;
	// 82A5C294: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5C298: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A5C29C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A5C2A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A5C2A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5C2A8: 48020F49  bl 0x82a7d1f0
	ctx.lr = 0x82A5C2AC;
	sub_82A7D1F0(ctx, base);
	// 82A5C2AC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5C2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C2B4: 409A0040  bne cr6, 0x82a5c2f4
	if !ctx.cr[6].eq {
	pc = 0x82A5C2F4; continue 'dispatch;
	}
	// 82A5C2B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5C2BC: 3BEB6010  addi r31, r11, 0x6010
	ctx.r[31].s64 = ctx.r[11].s64 + 24592;
	pc = 0x82A5C2C0; continue 'dispatch;
            }
            0x82A5C2C0 => {
    //   block [0x82A5C2C0..0x82A5C2F4)
	// 82A5C2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C2C4: 4885D6A1  bl 0x832b9964
	ctx.lr = 0x82A5C2C8;
	// extern call 0x832B9964 → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82A5C2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C2CC: 4885D689  bl 0x832b9954
	ctx.lr = 0x82A5C2D0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82A5C2D0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A5C2D4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5C2D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A5C2DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A5C2E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5C2E4: 48020F0D  bl 0x82a7d1f0
	ctx.lr = 0x82A5C2E8;
	sub_82A7D1F0(ctx, base);
	// 82A5C2E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5C2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C2F0: 419AFFD0  beq cr6, 0x82a5c2c0
	if ctx.cr[6].eq {
	pc = 0x82A5C2C0; continue 'dispatch;
	}
	pc = 0x82A5C2F4; continue 'dispatch;
            }
            0x82A5C2F4 => {
    //   block [0x82A5C2F4..0x82A5C308)
	// 82A5C2F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5C2F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C2FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5C300: 41990008  bgt cr6, 0x82a5c308
	if ctx.cr[6].gt {
	pc = 0x82A5C308; continue 'dispatch;
	}
	// 82A5C304: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A5C308; continue 'dispatch;
            }
            0x82A5C308 => {
    //   block [0x82A5C308..0x82A5C318)
	// 82A5C308: 9B3E0025  stb r25, 0x25(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(37 as u32), ctx.r[25].u8 ) };
	// 82A5C30C: 997E0026  stb r11, 0x26(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 82A5C310: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A5C314: 4824D138  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C318 size=272
    let mut pc: u32 = 0x82A5C318;
    'dispatch: loop {
        match pc {
            0x82A5C318 => {
    //   block [0x82A5C318..0x82A5C370)
	// 82A5C318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C31C: 4824D0E9  bl 0x82ca9404
	ctx.lr = 0x82A5C320;
	sub_82CA93D0(ctx, base);
	// 82A5C320: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C324: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5C328: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5C32C: 93C100AC  stw r30, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 82A5C330: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A5C334: 3BEBFB48  addi r31, r11, -0x4b8
	ctx.r[31].s64 = ctx.r[11].s64 + -1208;
	// 82A5C338: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5C33C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A5C340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5C344: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5C348: 38A100AC  addi r5, r1, 0xac
	ctx.r[5].s64 = ctx.r[1].s64 + 172;
	// 82A5C34C: 996A1629  stb r11, 0x1629(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(5673 as u32), ctx.r[11].u8 ) };
	// 82A5C350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5C354: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A5C358: 48002459  bl 0x82a5e7b0
	ctx.lr = 0x82A5C35C;
	sub_82A5E7B0(ctx, base);
	// 82A5C35C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5C360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C364: 419A000C  beq cr6, 0x82a5c370
	if ctx.cr[6].eq {
	pc = 0x82A5C370; continue 'dispatch;
	}
	// 82A5C368: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5C36C: 419A0008  beq cr6, 0x82a5c374
	if ctx.cr[6].eq {
	pc = 0x82A5C374; continue 'dispatch;
	}
	pc = 0x82A5C370; continue 'dispatch;
            }
            0x82A5C370 => {
    //   block [0x82A5C370..0x82A5C374)
	// 82A5C370: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5C374; continue 'dispatch;
            }
            0x82A5C374 => {
    //   block [0x82A5C374..0x82A5C398)
	// 82A5C374: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C378: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5C37C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5C380: 419A002C  beq cr6, 0x82a5c3ac
	if ctx.cr[6].eq {
	pc = 0x82A5C3AC; continue 'dispatch;
	}
	// 82A5C384: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5C388: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5C38C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5C390: 41980008  blt cr6, 0x82a5c398
	if ctx.cr[6].lt {
	pc = 0x82A5C398; continue 'dispatch;
	}
	// 82A5C394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A5C398; continue 'dispatch;
            }
            0x82A5C398 => {
    //   block [0x82A5C398..0x82A5C3AC)
	// 82A5C398: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5C39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C3A0: 409A000C  bne cr6, 0x82a5c3ac
	if !ctx.cr[6].eq {
	pc = 0x82A5C3AC; continue 'dispatch;
	}
	// 82A5C3A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A5C3A8: 48000010  b 0x82a5c3b8
	pc = 0x82A5C3B8; continue 'dispatch;
            }
            0x82A5C3AC => {
    //   block [0x82A5C3AC..0x82A5C3B8)
	// 82A5C3AC: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A5C3B0: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82A5C3B4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x82A5C3B8; continue 'dispatch;
            }
            0x82A5C3B8 => {
    //   block [0x82A5C3B8..0x82A5C3D4)
	// 82A5C3B8: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A5C3BC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82A5C3C0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5C3C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5C3C8: 419A000C  beq cr6, 0x82a5c3d4
	if ctx.cr[6].eq {
	pc = 0x82A5C3D4; continue 'dispatch;
	}
	// 82A5C3CC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5C3D0: 419A0008  beq cr6, 0x82a5c3d8
	if ctx.cr[6].eq {
	pc = 0x82A5C3D8; continue 'dispatch;
	}
	pc = 0x82A5C3D4; continue 'dispatch;
            }
            0x82A5C3D4 => {
    //   block [0x82A5C3D4..0x82A5C3D8)
	// 82A5C3D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5C3D8; continue 'dispatch;
            }
            0x82A5C3D8 => {
    //   block [0x82A5C3D8..0x82A5C3F0)
	// 82A5C3D8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5C3DC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5C3E0: 419A003C  beq cr6, 0x82a5c41c
	if ctx.cr[6].eq {
	pc = 0x82A5C41C; continue 'dispatch;
	}
	// 82A5C3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5C3E8: 409A0008  bne cr6, 0x82a5c3f0
	if !ctx.cr[6].eq {
	pc = 0x82A5C3F0; continue 'dispatch;
	}
	// 82A5C3EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5C3F0; continue 'dispatch;
            }
            0x82A5C3F0 => {
    //   block [0x82A5C3F0..0x82A5C400)
	// 82A5C3F0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C3F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5C3F8: 409A0008  bne cr6, 0x82a5c400
	if !ctx.cr[6].eq {
	pc = 0x82A5C400; continue 'dispatch;
	}
	// 82A5C3FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5C400; continue 'dispatch;
            }
            0x82A5C400 => {
    //   block [0x82A5C400..0x82A5C41C)
	// 82A5C400: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A5C404: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5C408: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A5C40C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5C410: 48000561  bl 0x82a5c970
	ctx.lr = 0x82A5C414;
	sub_82A5C970(ctx, base);
	// 82A5C414: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5C418: 4824D03C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5C41C => {
    //   block [0x82A5C41C..0x82A5C428)
	// 82A5C41C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5C420: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5C424: 4824D030  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C428 size=116
    let mut pc: u32 = 0x82A5C428;
    'dispatch: loop {
        match pc {
            0x82A5C428 => {
    //   block [0x82A5C428..0x82A5C440)
	// 82A5C428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C42C: 4824CFE1  bl 0x82ca940c
	ctx.lr = 0x82A5C430;
	sub_82CA93D0(ctx, base);
	// 82A5C430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C434: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 82A5C438: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A5C43C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82A5C440; continue 'dispatch;
            }
            0x82A5C440 => {
    //   block [0x82A5C440..0x82A5C454)
	// 82A5C440: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A5C444: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C44C: 419A0040  beq cr6, 0x82a5c48c
	if ctx.cr[6].eq {
	pc = 0x82A5C48C; continue 'dispatch;
	}
	// 82A5C450: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C454; continue 'dispatch;
            }
            0x82A5C454 => {
    //   block [0x82A5C454..0x82A5C488)
	// 82A5C454: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C45C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C460: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C464: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C468: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C46C: 4082FFE8  bne 0x82a5c454
	if !ctx.cr[0].eq {
	pc = 0x82A5C454; continue 'dispatch;
	}
	// 82A5C470: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C474: 409A0014  bne cr6, 0x82a5c488
	if !ctx.cr[6].eq {
	pc = 0x82A5C488; continue 'dispatch;
	}
	// 82A5C478: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C47C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C480: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C484: 4E800421  bctrl
	ctx.lr = 0x82A5C488;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C488 => {
    //   block [0x82A5C488..0x82A5C48C)
	// 82A5C488: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82A5C48C; continue 'dispatch;
            }
            0x82A5C48C => {
    //   block [0x82A5C48C..0x82A5C49C)
	// 82A5C48C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A5C490: 4080FFB0  bge 0x82a5c440
	if !ctx.cr[0].lt {
	pc = 0x82A5C440; continue 'dispatch;
	}
	// 82A5C494: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5C498: 4824CFC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C4A0 size=492
    let mut pc: u32 = 0x82A5C4A0;
    'dispatch: loop {
        match pc {
            0x82A5C4A0 => {
    //   block [0x82A5C4A0..0x82A5C4E8)
	// 82A5C4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C4A4: 4824CF65  bl 0x82ca9408
	ctx.lr = 0x82A5C4A8;
	sub_82CA93D0(ctx, base);
	// 82A5C4A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C4AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5C4B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A5C4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5C4B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A5C4BC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A5C4C0: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A5C4C4: 4B74F5D5  bl 0x821aba98
	ctx.lr = 0x82A5C4C8;
	sub_821ABA98(ctx, base);
	// 82A5C4C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5C4CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C4D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C4D4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5C4D8: 419A0074  beq cr6, 0x82a5c54c
	if ctx.cr[6].eq {
	pc = 0x82A5C54C; continue 'dispatch;
	}
	// 82A5C4DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C4E0: 419A003C  beq cr6, 0x82a5c51c
	if ctx.cr[6].eq {
	pc = 0x82A5C51C; continue 'dispatch;
	}
	// 82A5C4E4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C4E8; continue 'dispatch;
            }
            0x82A5C4E8 => {
    //   block [0x82A5C4E8..0x82A5C51C)
	// 82A5C4E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C4EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C4F0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C4F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C4F8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C4FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C500: 4082FFE8  bne 0x82a5c4e8
	if !ctx.cr[0].eq {
	pc = 0x82A5C4E8; continue 'dispatch;
	}
	// 82A5C504: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C508: 409A0014  bne cr6, 0x82a5c51c
	if !ctx.cr[6].eq {
	pc = 0x82A5C51C; continue 'dispatch;
	}
	// 82A5C50C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C510: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C514: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C518: 4E800421  bctrl
	ctx.lr = 0x82A5C51C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C51C => {
    //   block [0x82A5C51C..0x82A5C530)
	// 82A5C51C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C524: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5C528: 419A0024  beq cr6, 0x82a5c54c
	if ctx.cr[6].eq {
	pc = 0x82A5C54C; continue 'dispatch;
	}
	// 82A5C52C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5C530; continue 'dispatch;
            }
            0x82A5C530 => {
    //   block [0x82A5C530..0x82A5C54C)
	// 82A5C530: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C534: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C538: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C53C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5C540: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C544: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C548: 4082FFE8  bne 0x82a5c530
	if !ctx.cr[0].eq {
	pc = 0x82A5C530; continue 'dispatch;
	}
	pc = 0x82A5C54C; continue 'dispatch;
            }
            0x82A5C54C => {
    //   block [0x82A5C54C..0x82A5C560)
	// 82A5C54C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5C550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C554: 419A0048  beq cr6, 0x82a5c59c
	if ctx.cr[6].eq {
	pc = 0x82A5C59C; continue 'dispatch;
	}
	// 82A5C558: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A5C55C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5C560; continue 'dispatch;
            }
            0x82A5C560 => {
    //   block [0x82A5C560..0x82A5C598)
	// 82A5C560: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C564: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C568: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C56C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5C570: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C574: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C578: 4082FFE8  bne 0x82a5c560
	if !ctx.cr[0].eq {
	pc = 0x82A5C560; continue 'dispatch;
	}
	// 82A5C57C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5C580: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C584: 409A0014  bne cr6, 0x82a5c598
	if !ctx.cr[6].eq {
	pc = 0x82A5C598; continue 'dispatch;
	}
	// 82A5C588: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C58C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C590: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C594: 4E800421  bctrl
	ctx.lr = 0x82A5C598;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C598 => {
    //   block [0x82A5C598..0x82A5C59C)
	// 82A5C598: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A5C59C; continue 'dispatch;
            }
            0x82A5C59C => {
    //   block [0x82A5C59C..0x82A5C5D8)
	// 82A5C59C: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5C5A0: 389D001C  addi r4, r29, 0x1c
	ctx.r[4].s64 = ctx.r[29].s64 + 28;
	// 82A5C5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C5A8: 409900D8  ble cr6, 0x82a5c680
	if !ctx.cr[6].gt {
	pc = 0x82A5C680; continue 'dispatch;
	}
	// 82A5C5AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A5C5B0: 4B74F4E9  bl 0x821aba98
	ctx.lr = 0x82A5C5B4;
	sub_821ABA98(ctx, base);
	// 82A5C5B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5C5B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C5BC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C5C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5C5C4: 419A0078  beq cr6, 0x82a5c63c
	if ctx.cr[6].eq {
	pc = 0x82A5C63C; continue 'dispatch;
	}
	// 82A5C5C8: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A5C5CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C5D0: 419A003C  beq cr6, 0x82a5c60c
	if ctx.cr[6].eq {
	pc = 0x82A5C60C; continue 'dispatch;
	}
	// 82A5C5D4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C5D8; continue 'dispatch;
            }
            0x82A5C5D8 => {
    //   block [0x82A5C5D8..0x82A5C60C)
	// 82A5C5D8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C5DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C5E0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C5E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C5E8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C5EC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C5F0: 4082FFE8  bne 0x82a5c5d8
	if !ctx.cr[0].eq {
	pc = 0x82A5C5D8; continue 'dispatch;
	}
	// 82A5C5F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C5F8: 409A0014  bne cr6, 0x82a5c60c
	if !ctx.cr[6].eq {
	pc = 0x82A5C60C; continue 'dispatch;
	}
	// 82A5C5FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C600: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C604: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C608: 4E800421  bctrl
	ctx.lr = 0x82A5C60C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C60C => {
    //   block [0x82A5C60C..0x82A5C620)
	// 82A5C60C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C614: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5C618: 419A0024  beq cr6, 0x82a5c63c
	if ctx.cr[6].eq {
	pc = 0x82A5C63C; continue 'dispatch;
	}
	// 82A5C61C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5C620; continue 'dispatch;
            }
            0x82A5C620 => {
    //   block [0x82A5C620..0x82A5C63C)
	// 82A5C620: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5C624: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C628: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5C62C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5C630: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C634: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C638: 4082FFE8  bne 0x82a5c620
	if !ctx.cr[0].eq {
	pc = 0x82A5C620; continue 'dispatch;
	}
	pc = 0x82A5C63C; continue 'dispatch;
            }
            0x82A5C63C => {
    //   block [0x82A5C63C..0x82A5C64C)
	// 82A5C63C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5C640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C644: 419A003C  beq cr6, 0x82a5c680
	if ctx.cr[6].eq {
	pc = 0x82A5C680; continue 'dispatch;
	}
	// 82A5C648: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C64C; continue 'dispatch;
            }
            0x82A5C64C => {
    //   block [0x82A5C64C..0x82A5C680)
	// 82A5C64C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C650: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C654: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C658: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C65C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C660: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C664: 4082FFE8  bne 0x82a5c64c
	if !ctx.cr[0].eq {
	pc = 0x82A5C64C; continue 'dispatch;
	}
	// 82A5C668: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C66C: 409A0014  bne cr6, 0x82a5c680
	if !ctx.cr[6].eq {
	pc = 0x82A5C680; continue 'dispatch;
	}
	// 82A5C670: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C674: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C678: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C67C: 4E800421  bctrl
	ctx.lr = 0x82A5C680;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C680 => {
    //   block [0x82A5C680..0x82A5C68C)
	// 82A5C680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C684: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5C688: 4824CDD0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C690 size=228
    let mut pc: u32 = 0x82A5C690;
    'dispatch: loop {
        match pc {
            0x82A5C690 => {
    //   block [0x82A5C690..0x82A5C6AC)
	// 82A5C690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C694: 4824CD6D  bl 0x82ca9400
	ctx.lr = 0x82A5C698;
	sub_82CA93D0(ctx, base);
	// 82A5C698: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C69C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5C6A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5C6A4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A5C6A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82A5C6AC; continue 'dispatch;
            }
            0x82A5C6AC => {
    //   block [0x82A5C6AC..0x82A5C74C)
	// 82A5C6AC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C6B0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A5C6B4: 419A0098  beq cr6, 0x82a5c74c
	if ctx.cr[6].eq {
	pc = 0x82A5C74C; continue 'dispatch;
	}
	// 82A5C6B8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C6BC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A5C6C0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C6C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A5C6C8: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 82A5C6CC: 80E30094  lwz r7, 0x94(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A5C6D0: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 82A5C6D4: 80A30098  lwz r5, 0x98(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A5C6D8: 7D7FFE70  srawi r31, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82A5C6DC: 7D5AFE70  srawi r26, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A5C6E0: 7FEB5838  and r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 & ctx.r[11].u64;
	// 82A5C6E4: 7F4A5038  and r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 & ctx.r[10].u64;
	// 82A5C6E8: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A5C6EC: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A5C6F0: 7D674BD6  divw r11, r7, r9
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 82A5C6F4: 7CE543D6  divw r7, r5, r8
	ctx.r[7].s32 = ctx.r[5].s32 / ctx.r[8].s32;
	// 82A5C6F8: 7CAB3850  subf r5, r11, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82A5C6FC: 7CAAFE70  srawi r10, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 82A5C700: 7D4A2838  and r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[5].u64;
	// 82A5C704: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A5C708: 61280001  ori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 | 1;
	// 82A5C70C: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 82A5C710: 23E7001F  subfic r31, r7, 0x1f
	ctx.xer.ca = ctx.r[7].u32 <= 31 as u32;
	ctx.r[31].s64 = (31 as i64) - ctx.r[7].s64;
	// 82A5C714: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A5C718: 4B7C23D9  bl 0x8221eaf0
	ctx.lr = 0x82A5C71C;
	sub_8221EAF0(ctx, base);
	// 82A5C71C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C720: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5C724: 80CB0058  lwz r6, 0x58(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5C728: 7CAA3050  subf r5, r10, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82A5C72C: 7CA4FE70  srawi r4, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 82A5C730: 7C892838  and r9, r4, r5
	ctx.r[9].u64 = ctx.r[4].u64 & ctx.r[5].u64;
	// 82A5C734: 7C695214  add r3, r9, r10
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A5C738: 7F03F800  cmpw cr6, r3, r31
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A5C73C: 40990010  ble cr6, 0x82a5c74c
	if !ctx.cr[6].gt {
	pc = 0x82A5C74C; continue 'dispatch;
	}
	// 82A5C740: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A5C744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5C748: 409A0020  bne cr6, 0x82a5c768
	if !ctx.cr[6].eq {
	pc = 0x82A5C768; continue 'dispatch;
	}
	pc = 0x82A5C74C; continue 'dispatch;
            }
            0x82A5C74C => {
    //   block [0x82A5C74C..0x82A5C768)
	// 82A5C74C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82A5C750: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A5C754: 2F1B0002  cmpwi cr6, r27, 2
	ctx.cr[6].compare_i32(ctx.r[27].s32, 2, &mut ctx.xer);
	// 82A5C758: 4198FF54  blt cr6, 0x82a5c6ac
	if ctx.cr[6].lt {
	pc = 0x82A5C6AC; continue 'dispatch;
	}
	// 82A5C75C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A5C760: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5C764: 4824CCEC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5C768 => {
    //   block [0x82A5C768..0x82A5C774)
	// 82A5C768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5C76C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5C770: 4824CCE0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C778 size=256
    let mut pc: u32 = 0x82A5C778;
    'dispatch: loop {
        match pc {
            0x82A5C778 => {
    //   block [0x82A5C778..0x82A5C818)
	// 82A5C778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C77C: 4824CC8D  bl 0x82ca9408
	ctx.lr = 0x82A5C780;
	sub_82CA93D0(ctx, base);
	// 82A5C780: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C784: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82A5C788: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5C78C: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82A5C790: 386BFB48  addi r3, r11, -0x4b8
	ctx.r[3].s64 = ctx.r[11].s64 + -1208;
	// 82A5C794: 4800170D  bl 0x82a5dea0
	ctx.lr = 0x82A5C798;
	sub_82A5DEA0(ctx, base);
	// 82A5C798: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5C79C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C7A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5C7A4: 409A00C8  bne cr6, 0x82a5c86c
	if !ctx.cr[6].eq {
	pc = 0x82A5C86C; continue 'dispatch;
	}
	// 82A5C7A8: 38600048  li r3, 0x48
	ctx.r[3].s64 = 72;
	// 82A5C7AC: 4B7C2AAD  bl 0x8221f258
	ctx.lr = 0x82A5C7B0;
	sub_8221F258(ctx, base);
	// 82A5C7B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5C7B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5C7B8: 419A0060  beq cr6, 0x82a5c818
	if ctx.cr[6].eq {
	pc = 0x82A5C818; continue 'dispatch;
	}
	// 82A5C7BC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5C7C0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A5C7C4: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A5C7C8: 392B6D08  addi r9, r11, 0x6d08
	ctx.r[9].s64 = ctx.r[11].s64 + 27912;
	// 82A5C7CC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A5C7D0: 3B8A6CF8  addi r28, r10, 0x6cf8
	ctx.r[28].s64 = ctx.r[10].s64 + 27896;
	// 82A5C7D4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A5C7D8: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A5C7DC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A5C7E0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A5C7E4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A5C7E8: 4BA23A51  bl 0x82480238
	ctx.lr = 0x82A5C7EC;
	sub_82480238(ctx, base);
	// 82A5C7EC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A5C7F0: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 82A5C7F4: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82A5C7F8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A5C7FC: 4BA23A3D  bl 0x82480238
	ctx.lr = 0x82A5C800;
	sub_82480238(ctx, base);
	// 82A5C800: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A5C804: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82A5C808: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A5C80C: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82A5C810: 9BDF0041  stb r30, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[30].u8 ) };
	// 82A5C814: 4800000C  b 0x82a5c820
	pc = 0x82A5C820; continue 'dispatch;
            }
            0x82A5C818 => {
    //   block [0x82A5C818..0x82A5C820)
	// 82A5C818: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A5C81C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x82A5C820; continue 'dispatch;
            }
            0x82A5C820 => {
    //   block [0x82A5C820..0x82A5C830)
	// 82A5C820: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5C828: 419A0040  beq cr6, 0x82a5c868
	if ctx.cr[6].eq {
	pc = 0x82A5C868; continue 'dispatch;
	}
	// 82A5C82C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5C830; continue 'dispatch;
            }
            0x82A5C830 => {
    //   block [0x82A5C830..0x82A5C864)
	// 82A5C830: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5C834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C838: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5C83C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C840: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5C844: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5C848: 4082FFE8  bne 0x82a5c830
	if !ctx.cr[0].eq {
	pc = 0x82A5C830; continue 'dispatch;
	}
	// 82A5C84C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C850: 409A0014  bne cr6, 0x82a5c864
	if !ctx.cr[6].eq {
	pc = 0x82A5C864; continue 'dispatch;
	}
	// 82A5C854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C858: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5C85C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5C860: 4E800421  bctrl
	ctx.lr = 0x82A5C864;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5C864 => {
    //   block [0x82A5C864..0x82A5C868)
	// 82A5C864: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A5C868; continue 'dispatch;
            }
            0x82A5C868 => {
    //   block [0x82A5C868..0x82A5C86C)
	// 82A5C868: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x82A5C86C; continue 'dispatch;
            }
            0x82A5C86C => {
    //   block [0x82A5C86C..0x82A5C878)
	// 82A5C86C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5C874: 4824CBE4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C878 size=136
    let mut pc: u32 = 0x82A5C878;
    'dispatch: loop {
        match pc {
            0x82A5C878 => {
    //   block [0x82A5C878..0x82A5C8F8)
	// 82A5C878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C87C: 4824CB89  bl 0x82ca9404
	ctx.lr = 0x82A5C880;
	sub_82CA93D0(ctx, base);
	// 82A5C880: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5C888: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A5C88C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82A5C890: 4BFEAB09  bl 0x82a47398
	ctx.lr = 0x82A5C894;
	sub_82A47398(ctx, base);
	// 82A5C894: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5C898: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82A5C89C: 3B8B6CF8  addi r28, r11, 0x6cf8
	ctx.r[28].s64 = ctx.r[11].s64 + 27896;
	// 82A5C8A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5C8A4: 939F001C  stw r28, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[28].u32 ) };
	// 82A5C8A8: 480BE149  bl 0x82b1a9f0
	ctx.lr = 0x82A5C8AC;
	sub_82B1A9F0(ctx, base);
	// 82A5C8AC: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82A5C8B0: 4BD766C1  bl 0x827d2f70
	ctx.lr = 0x82A5C8B4;
	sub_827D2F70(ctx, base);
	// 82A5C8B4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82A5C8B8: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82A5C8BC: 3B6A0FD0  addi r27, r10, 0xfd0
	ctx.r[27].s64 = ctx.r[10].s64 + 4048;
	// 82A5C8C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5C8C4: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82A5C8C8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A5C8CC: 480BE125  bl 0x82b1a9f0
	ctx.lr = 0x82A5C8D0;
	sub_82B1A9F0(ctx, base);
	// 82A5C8D0: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82A5C8D4: 4BD7669D  bl 0x827d2f70
	ctx.lr = 0x82A5C8D8;
	sub_827D2F70(ctx, base);
	// 82A5C8D8: 57A907FE  clrlwi r9, r29, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82A5C8DC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A5C8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C8E4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5C8E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5C8EC: 419A000C  beq cr6, 0x82a5c8f8
	if ctx.cr[6].eq {
	pc = 0x82A5C8F8; continue 'dispatch;
	}
	// 82A5C8F0: 4B7BF449  bl 0x8221bd38
	ctx.lr = 0x82A5C8F4;
	sub_8221BD38(ctx, base);
	// 82A5C8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A5C8F8; continue 'dispatch;
            }
            0x82A5C8F8 => {
    //   block [0x82A5C8F8..0x82A5C900)
	// 82A5C8F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5C8FC: 4824CB58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C900 size=112
    let mut pc: u32 = 0x82A5C900;
    'dispatch: loop {
        match pc {
            0x82A5C900 => {
    //   block [0x82A5C900..0x82A5C958)
	// 82A5C900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5C908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5C90C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5C910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5C918: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5C91C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5C920: 394B6CF8  addi r10, r11, 0x6cf8
	ctx.r[10].s64 = ctx.r[11].s64 + 27896;
	// 82A5C924: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5C928: 480BE0C9  bl 0x82b1a9f0
	ctx.lr = 0x82A5C92C;
	sub_82B1A9F0(ctx, base);
	// 82A5C92C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A5C930: 4BD76641  bl 0x827d2f70
	ctx.lr = 0x82A5C934;
	sub_827D2F70(ctx, base);
	// 82A5C934: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82A5C938: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A5C93C: 38E90FD0  addi r7, r9, 0xfd0
	ctx.r[7].s64 = ctx.r[9].s64 + 4048;
	// 82A5C940: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5C944: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A5C948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5C94C: 419A000C  beq cr6, 0x82a5c958
	if ctx.cr[6].eq {
	pc = 0x82A5C958; continue 'dispatch;
	}
	// 82A5C950: 4B7BF3E9  bl 0x8221bd38
	ctx.lr = 0x82A5C954;
	sub_8221BD38(ctx, base);
	// 82A5C954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A5C958; continue 'dispatch;
            }
            0x82A5C958 => {
    //   block [0x82A5C958..0x82A5C970)
	// 82A5C958: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5C95C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5C960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5C964: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5C968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5C96C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5C970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5C970 size=340
    let mut pc: u32 = 0x82A5C970;
    'dispatch: loop {
        match pc {
            0x82A5C970 => {
    //   block [0x82A5C970..0x82A5C9A4)
	// 82A5C970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5C974: 4824CA95  bl 0x82ca9408
	ctx.lr = 0x82A5C978;
	sub_82CA93D0(ctx, base);
	// 82A5C978: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5C97C: 81230034  lwz r9, 0x34(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A5C980: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A5C984: 83C30038  lwz r30, 0x38(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A5C988: 38E30030  addi r7, r3, 0x30
	ctx.r[7].s64 = ctx.r[3].s64 + 48;
	// 82A5C98C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A5C990: 7D69F050  subf r11, r9, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 82A5C994: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A5C998: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C99C: 40810044  ble 0x82a5c9e0
	if !ctx.cr[0].gt {
	pc = 0x82A5C9E0; continue 'dispatch;
	}
	// 82A5C9A0: 83E50000  lwz r31, 0(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5C9A4; continue 'dispatch;
            }
            0x82A5C9A4 => {
    //   block [0x82A5C9A4..0x82A5C9CC)
	// 82A5C9A4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A5C9A8: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A5C9AC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A5C9B0: 83890000  lwz r28, 0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C9B4: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5C9B8: 40980014  bge cr6, 0x82a5c9cc
	if !ctx.cr[6].lt {
	pc = 0x82A5C9CC; continue 'dispatch;
	}
	// 82A5C9BC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5C9C0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A5C9C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5C9C8: 4800000C  b 0x82a5c9d4
	pc = 0x82A5C9D4; continue 'dispatch;
            }
            0x82A5C9CC => {
    //   block [0x82A5C9CC..0x82A5C9D4)
	// 82A5C9CC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A5C9D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82A5C9D4; continue 'dispatch;
            }
            0x82A5C9D4 => {
    //   block [0x82A5C9D4..0x82A5C9E0)
	// 82A5C9D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5C9D8: 4199FFCC  bgt cr6, 0x82a5c9a4
	if ctx.cr[6].gt {
	pc = 0x82A5C9A4; continue 'dispatch;
	}
	// 82A5C9DC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x82A5C9E0; continue 'dispatch;
            }
            0x82A5C9E0 => {
    //   block [0x82A5C9E0..0x82A5CA08)
	// 82A5C9E0: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5C9E4: 419A0024  beq cr6, 0x82a5ca08
	if ctx.cr[6].eq {
	pc = 0x82A5CA08; continue 'dispatch;
	}
	// 82A5C9E8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C9EC: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5C9F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5C9F4: 41980014  blt cr6, 0x82a5ca08
	if ctx.cr[6].lt {
	pc = 0x82A5CA08; continue 'dispatch;
	}
	// 82A5C9F8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5C9FC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A5CA00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5CA04: 48000008  b 0x82a5ca0c
	pc = 0x82A5CA0C; continue 'dispatch;
            }
            0x82A5CA08 => {
    //   block [0x82A5CA08..0x82A5CA0C)
	// 82A5CA08: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A5CA0C; continue 'dispatch;
            }
            0x82A5CA0C => {
    //   block [0x82A5CA0C..0x82A5CA38)
	// 82A5CA0C: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A5CA10: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A5CA14: 409A00A0  bne cr6, 0x82a5cab4
	if !ctx.cr[6].eq {
	pc = 0x82A5CAB4; continue 'dispatch;
	}
	// 82A5CA18: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CA1C: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5CA20: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A5CA24: 7D692850  subf r11, r9, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 82A5CA28: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A5CA2C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CA30: 40810044  ble 0x82a5ca74
	if !ctx.cr[0].gt {
	pc = 0x82A5CA74; continue 'dispatch;
	}
	// 82A5CA34: 80E60000  lwz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5CA38; continue 'dispatch;
            }
            0x82A5CA38 => {
    //   block [0x82A5CA38..0x82A5CA60)
	// 82A5CA38: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A5CA3C: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A5CA40: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A5CA44: 83E90000  lwz r31, 0(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CA48: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A5CA4C: 40980014  bge cr6, 0x82a5ca60
	if !ctx.cr[6].lt {
	pc = 0x82A5CA60; continue 'dispatch;
	}
	// 82A5CA50: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5CA54: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A5CA58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5CA5C: 4800000C  b 0x82a5ca68
	pc = 0x82A5CA68; continue 'dispatch;
            }
            0x82A5CA60 => {
    //   block [0x82A5CA60..0x82A5CA68)
	// 82A5CA60: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A5CA64: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82A5CA68; continue 'dispatch;
            }
            0x82A5CA68 => {
    //   block [0x82A5CA68..0x82A5CA74)
	// 82A5CA68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CA6C: 4199FFCC  bgt cr6, 0x82a5ca38
	if ctx.cr[6].gt {
	pc = 0x82A5CA38; continue 'dispatch;
	}
	// 82A5CA70: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x82A5CA74; continue 'dispatch;
            }
            0x82A5CA74 => {
    //   block [0x82A5CA74..0x82A5CA9C)
	// 82A5CA74: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5CA78: 419A0024  beq cr6, 0x82a5ca9c
	if ctx.cr[6].eq {
	pc = 0x82A5CA9C; continue 'dispatch;
	}
	// 82A5CA7C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CA80: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CA84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5CA88: 41980014  blt cr6, 0x82a5ca9c
	if ctx.cr[6].lt {
	pc = 0x82A5CA9C; continue 'dispatch;
	}
	// 82A5CA8C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5CA90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A5CA94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5CA98: 48000008  b 0x82a5caa0
	pc = 0x82A5CAA0; continue 'dispatch;
            }
            0x82A5CA9C => {
    //   block [0x82A5CA9C..0x82A5CAA0)
	// 82A5CA9C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x82A5CAA0; continue 'dispatch;
            }
            0x82A5CAA0 => {
    //   block [0x82A5CAA0..0x82A5CAB4)
	// 82A5CAA0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A5CAA4: 409A0010  bne cr6, 0x82a5cab4
	if !ctx.cr[6].eq {
	pc = 0x82A5CAB4; continue 'dispatch;
	}
	// 82A5CAA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A5CAAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5CAB0: 4824C9A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5CAB4 => {
    //   block [0x82A5CAB4..0x82A5CAC4)
	// 82A5CAB4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CAB8: 4BFFE6F1  bl 0x82a5b1a8
	ctx.lr = 0x82A5CABC;
	sub_82A5B1A8(ctx, base);
	// 82A5CABC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5CAC0: 4824C998  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5CAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5CAC8 size=1908
    let mut pc: u32 = 0x82A5CAC8;
    'dispatch: loop {
        match pc {
            0x82A5CAC8 => {
    //   block [0x82A5CAC8..0x82A5CAF4)
	// 82A5CAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5CACC: 4824C919  bl 0x82ca93e4
	ctx.lr = 0x82A5CAD0;
	sub_82CA93D0(ctx, base);
	// 82A5CAD0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5CAD4: 54B3063E  clrlwi r19, r5, 0x18
	ctx.r[19].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A5CAD8: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82A5CADC: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 82A5CAE0: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A5CAE4: 419A0010  beq cr6, 0x82a5caf4
	if ctx.cr[6].eq {
	pc = 0x82A5CAF4; continue 'dispatch;
	}
	// 82A5CAE8: 89750044  lbz r11, 0x44(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A5CAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CAF0: 409A0744  bne cr6, 0x82a5d234
	if !ctx.cr[6].eq {
	pc = 0x82A5D234; continue 'dispatch;
	}
	pc = 0x82A5CAF4; continue 'dispatch;
            }
            0x82A5CAF4 => {
    //   block [0x82A5CAF4..0x82A5CB48)
	// 82A5CAF4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A5CAF8: 81750038  lwz r11, 0x38(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A5CAFC: 81550034  lwz r10, 0x34(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A5CB00: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A5CB04: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 82A5CB08: 3AD50030  addi r22, r21, 0x30
	ctx.r[22].s64 = ctx.r[21].s64 + 48;
	// 82A5CB0C: 934100C8  stw r26, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 82A5CB10: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5CB14: 934100CC  stw r26, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[26].u32 ) };
	// 82A5CB18: 9B4100D1  stb r26, 0xd1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(209 as u32), ctx.r[26].u8 ) };
	// 82A5CB1C: 7D241E70  srawi r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82A5CB20: 934100A4  stw r26, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[26].u32 ) };
	// 82A5CB24: 934100A8  stw r26, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[26].u32 ) };
	// 82A5CB28: 934100AC  stw r26, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[26].u32 ) };
	// 82A5CB2C: 9B4100B1  stb r26, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[26].u8 ) };
	// 82A5CB30: 480010E1  bl 0x82a5dc10
	ctx.lr = 0x82A5CB34;
	sub_82A5DC10(ctx, base);
	// 82A5CB34: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A5CB38: 4B7C2721  bl 0x8221f258
	ctx.lr = 0x82A5CB3C;
	sub_8221F258(ctx, base);
	// 82A5CB3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5CB40: 419A0008  beq cr6, 0x82a5cb48
	if ctx.cr[6].eq {
	pc = 0x82A5CB48; continue 'dispatch;
	}
	// 82A5CB44: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5CB48; continue 'dispatch;
            }
            0x82A5CB48 => {
    //   block [0x82A5CB48..0x82A5CB54)
	// 82A5CB48: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CB4C: 41820008  beq 0x82a5cb54
	if ctx.cr[0].eq {
	pc = 0x82A5CB54; continue 'dispatch;
	}
	// 82A5CB50: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5CB54; continue 'dispatch;
            }
            0x82A5CB54 => {
    //   block [0x82A5CB54..0x82A5CB60)
	// 82A5CB54: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CB58: 41820008  beq 0x82a5cb60
	if ctx.cr[0].eq {
	pc = 0x82A5CB60; continue 'dispatch;
	}
	// 82A5CB5C: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5CB60; continue 'dispatch;
            }
            0x82A5CB60 => {
    //   block [0x82A5CB60..0x82A5CBB8)
	// 82A5CB60: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 82A5CB64: 9AE30010  stb r23, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[23].u8 ) };
	// 82A5CB68: 9B430011  stb r26, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[26].u8 ) };
	// 82A5CB6C: 3B950024  addi r28, r21, 0x24
	ctx.r[28].s64 = ctx.r[21].s64 + 36;
	// 82A5CB70: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82A5CB74: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A5CB78: 9AE30011  stb r23, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[23].u8 ) };
	// 82A5CB7C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A5CB80: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5CB84: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82A5CB88: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5CB8C: 3B696D00  addi r27, r9, 0x6d00
	ctx.r[27].s64 = ctx.r[9].s64 + 27904;
	// 82A5CB90: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5CB94: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5CB98: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5CB9C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5CBA0: 81750028  lwz r11, 0x28(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A5CBA4: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82A5CBA8: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82A5CBAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CBB0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A5CBB4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5CBB8; continue 'dispatch;
            }
            0x82A5CBB8 => {
    //   block [0x82A5CBB8..0x82A5CBC8)
	// 82A5CBB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5CBBC: 419A000C  beq cr6, 0x82a5cbc8
	if ctx.cr[6].eq {
	pc = 0x82A5CBC8; continue 'dispatch;
	}
	// 82A5CBC0: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5CBC4: 419A0008  beq cr6, 0x82a5cbcc
	if ctx.cr[6].eq {
	pc = 0x82A5CBCC; continue 'dispatch;
	}
	pc = 0x82A5CBC8; continue 'dispatch;
            }
            0x82A5CBC8 => {
    //   block [0x82A5CBC8..0x82A5CBCC)
	// 82A5CBC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5CBCC; continue 'dispatch;
            }
            0x82A5CBCC => {
    //   block [0x82A5CBCC..0x82A5CBE0)
	// 82A5CBCC: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A5CBD0: 419A03AC  beq cr6, 0x82a5cf7c
	if ctx.cr[6].eq {
	pc = 0x82A5CF7C; continue 'dispatch;
	}
	// 82A5CBD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5CBD8: 409A0008  bne cr6, 0x82a5cbe0
	if !ctx.cr[6].eq {
	pc = 0x82A5CBE0; continue 'dispatch;
	}
	// 82A5CBDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5CBE0; continue 'dispatch;
            }
            0x82A5CBE0 => {
    //   block [0x82A5CBE0..0x82A5CBF0)
	// 82A5CBE0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CBE4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5CBE8: 409A0008  bne cr6, 0x82a5cbf0
	if !ctx.cr[6].eq {
	pc = 0x82A5CBF0; continue 'dispatch;
	}
	// 82A5CBEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5CBF0; continue 'dispatch;
            }
            0x82A5CBF0 => {
    //   block [0x82A5CBF0..0x82A5CC20)
	// 82A5CBF0: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5CBF4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CBF8: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82A5CBFC: 409A036C  bne cr6, 0x82a5cf68
	if !ctx.cr[6].eq {
	pc = 0x82A5CF68; continue 'dispatch;
	}
	// 82A5CC00: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5CC04: 83BE004C  lwz r29, 0x4c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A5CC08: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A5CC0C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CC10: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82A5CC14: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A5CC18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5CC1C: 409A002C  bne cr6, 0x82a5cc48
	if !ctx.cr[6].eq {
	pc = 0x82A5CC48; continue 'dispatch;
	}
	pc = 0x82A5CC20; continue 'dispatch;
            }
            0x82A5CC20 => {
    //   block [0x82A5CC20..0x82A5CC34)
	// 82A5CC20: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5CC24: 7F08E840  cmplw cr6, r8, r29
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5CC28: 4098000C  bge cr6, 0x82a5cc34
	if !ctx.cr[6].lt {
	pc = 0x82A5CC34; continue 'dispatch;
	}
	// 82A5CC2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5CC30: 4800000C  b 0x82a5cc3c
	pc = 0x82A5CC3C; continue 'dispatch;
            }
            0x82A5CC34 => {
    //   block [0x82A5CC34..0x82A5CC3C)
	// 82A5CC34: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A5CC38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5CC3C; continue 'dispatch;
            }
            0x82A5CC3C => {
    //   block [0x82A5CC3C..0x82A5CC48)
	// 82A5CC3C: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A5CC40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5CC44: 419AFFDC  beq cr6, 0x82a5cc20
	if ctx.cr[6].eq {
	pc = 0x82A5CC20; continue 'dispatch;
	}
	pc = 0x82A5CC48; continue 'dispatch;
            }
            0x82A5CC48 => {
    //   block [0x82A5CC48..0x82A5CC70)
	// 82A5CC48: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82A5CC4C: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 82A5CC50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5CC54: 916100D8  stw r11, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82A5CC58: 419A0018  beq cr6, 0x82a5cc70
	if ctx.cr[6].eq {
	pc = 0x82A5CC70; continue 'dispatch;
	}
	// 82A5CC5C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5CC60: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5CC64: 4198000C  blt cr6, 0x82a5cc70
	if ctx.cr[6].lt {
	pc = 0x82A5CC70; continue 'dispatch;
	}
	// 82A5CC68: 396100D8  addi r11, r1, 0xd8
	ctx.r[11].s64 = ctx.r[1].s64 + 216;
	// 82A5CC6C: 48000014  b 0x82a5cc80
	pc = 0x82A5CC80; continue 'dispatch;
            }
            0x82A5CC70 => {
    //   block [0x82A5CC70..0x82A5CC80)
	// 82A5CC70: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82A5CC74: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82A5CC78: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82A5CC7C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	pc = 0x82A5CC80; continue 'dispatch;
            }
            0x82A5CC80 => {
    //   block [0x82A5CC80..0x82A5CCA0)
	// 82A5CC80: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A5CC84: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A5CC88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5CC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CC90: 419A0010  beq cr6, 0x82a5cca0
	if ctx.cr[6].eq {
	pc = 0x82A5CCA0; continue 'dispatch;
	}
	// 82A5CC94: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82A5CC98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5CC9C: 419A0008  beq cr6, 0x82a5cca4
	if ctx.cr[6].eq {
	pc = 0x82A5CCA4; continue 'dispatch;
	}
	pc = 0x82A5CCA0; continue 'dispatch;
            }
            0x82A5CCA0 => {
    //   block [0x82A5CCA0..0x82A5CCA4)
	// 82A5CCA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5CCA4; continue 'dispatch;
            }
            0x82A5CCA4 => {
    //   block [0x82A5CCA4..0x82A5CCDC)
	// 82A5CCA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5CCA8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5CCAC: 409A02BC  bne cr6, 0x82a5cf68
	if !ctx.cr[6].eq {
	pc = 0x82A5CF68; continue 'dispatch;
	}
	// 82A5CCB0: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A5CCB4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A5CCB8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A5CCBC: 4BC2B4DD  bl 0x82688198
	ctx.lr = 0x82A5CCC0;
	sub_82688198(ctx, base);
	// 82A5CCC0: 81360004  lwz r9, 4(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CCC4: 80F60008  lwz r7, 8(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5CCC8: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 82A5CCCC: 7D693850  subf r11, r9, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82A5CCD0: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 82A5CCD4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CCD8: 40810040  ble 0x82a5cd18
	if !ctx.cr[0].gt {
	pc = 0x82A5CD18; continue 'dispatch;
	}
	pc = 0x82A5CCDC; continue 'dispatch;
            }
            0x82A5CCDC => {
    //   block [0x82A5CCDC..0x82A5CD04)
	// 82A5CCDC: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A5CCE0: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A5CCE4: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82A5CCE8: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CCEC: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5CCF0: 40980014  bge cr6, 0x82a5cd04
	if !ctx.cr[6].lt {
	pc = 0x82A5CD04; continue 'dispatch;
	}
	// 82A5CCF4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5CCF8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A5CCFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5CD00: 4800000C  b 0x82a5cd0c
	pc = 0x82A5CD0C; continue 'dispatch;
            }
            0x82A5CD04 => {
    //   block [0x82A5CD04..0x82A5CD0C)
	// 82A5CD04: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A5CD08: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82A5CD0C; continue 'dispatch;
            }
            0x82A5CD0C => {
    //   block [0x82A5CD0C..0x82A5CD18)
	// 82A5CD0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CD10: 4199FFCC  bgt cr6, 0x82a5ccdc
	if ctx.cr[6].gt {
	pc = 0x82A5CCDC; continue 'dispatch;
	}
	// 82A5CD14: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	pc = 0x82A5CD18; continue 'dispatch;
            }
            0x82A5CD18 => {
    //   block [0x82A5CD18..0x82A5CD3C)
	// 82A5CD18: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A5CD1C: 419A0020  beq cr6, 0x82a5cd3c
	if ctx.cr[6].eq {
	pc = 0x82A5CD3C; continue 'dispatch;
	}
	// 82A5CD20: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CD24: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5CD28: 41980014  blt cr6, 0x82a5cd3c
	if ctx.cr[6].lt {
	pc = 0x82A5CD3C; continue 'dispatch;
	}
	// 82A5CD2C: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A5CD30: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A5CD34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5CD38: 48000008  b 0x82a5cd40
	pc = 0x82A5CD40; continue 'dispatch;
            }
            0x82A5CD3C => {
    //   block [0x82A5CD3C..0x82A5CD40)
	// 82A5CD3C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x82A5CD40; continue 'dispatch;
            }
            0x82A5CD40 => {
    //   block [0x82A5CD40..0x82A5CD5C)
	// 82A5CD40: 81550038  lwz r10, 0x38(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A5CD44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5CD48: 419A0130  beq cr6, 0x82a5ce78
	if ctx.cr[6].eq {
	pc = 0x82A5CE78; continue 'dispatch;
	}
	// 82A5CD4C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CD50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5CD54: 419A0024  beq cr6, 0x82a5cd78
	if ctx.cr[6].eq {
	pc = 0x82A5CD78; continue 'dispatch;
	}
	// 82A5CD58: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5CD5C; continue 'dispatch;
            }
            0x82A5CD5C => {
    //   block [0x82A5CD5C..0x82A5CD78)
	// 82A5CD5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5CD60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CD64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5CD68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5CD6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5CD70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CD74: 4082FFE8  bne 0x82a5cd5c
	if !ctx.cr[0].eq {
	pc = 0x82A5CD5C; continue 'dispatch;
	}
	pc = 0x82A5CD78; continue 'dispatch;
            }
            0x82A5CD78 => {
    //   block [0x82A5CD78..0x82A5CDC8)
	// 82A5CD78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5CD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5CD80: 4BFFE2B9  bl 0x82a5b038
	ctx.lr = 0x82A5CD84;
	sub_82A5B038(ctx, base);
	// 82A5CD84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5CD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CD8C: 419A0074  beq cr6, 0x82a5ce00
	if ctx.cr[6].eq {
	pc = 0x82A5CE00; continue 'dispatch;
	}
	// 82A5CD90: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A5CD94: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82A5CD98: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82A5CD9C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A5CDA0: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5CDA4: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5CDA8: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A5CDAC: 48000B45  bl 0x82a5d8f0
	ctx.lr = 0x82A5CDB0;
	sub_82A5D8F0(ctx, base);
	// 82A5CDB0: 88BE0060  lbz r5, 0x60(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A5CDB4: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 82A5CDB8: 38DF0004  addi r6, r31, 4
	ctx.r[6].s64 = ctx.r[31].s64 + 4;
	// 82A5CDBC: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82A5CDC0: 9AFF0025  stb r23, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[23].u8 ) };
	// 82A5CDC4: 98BF0024  stb r5, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[5].u8 ) };
	pc = 0x82A5CDC8; continue 'dispatch;
            }
            0x82A5CDC8 => {
    //   block [0x82A5CDC8..0x82A5CE00)
	// 82A5CDC8: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82A5CDCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CDD0: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82A5CDD4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A5CDD8: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5CDDC: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CDE0: 4082FFE8  bne 0x82a5cdc8
	if !ctx.cr[0].eq {
	pc = 0x82A5CDC8; continue 'dispatch;
	}
	// 82A5CDE4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82A5CDE8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A5CDEC: 48000F65  bl 0x82a5dd50
	ctx.lr = 0x82A5CDF0;
	sub_82A5DD50(ctx, base);
	// 82A5CDF0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A5CDF4: 4B74FCC5  bl 0x821acab8
	ctx.lr = 0x82A5CDF8;
	sub_821ACAB8(ctx, base);
	// 82A5CDF8: 9AE100B1  stb r23, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[23].u8 ) };
	// 82A5CDFC: 4800004C  b 0x82a5ce48
	pc = 0x82A5CE48; continue 'dispatch;
            }
            0x82A5CE00 => {
    //   block [0x82A5CE00..0x82A5CE14)
	// 82A5CE00: 93A10098  stw r29, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 82A5CE04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5CE08: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82A5CE0C: 419A0024  beq cr6, 0x82a5ce30
	if ctx.cr[6].eq {
	pc = 0x82A5CE30; continue 'dispatch;
	}
	// 82A5CE10: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5CE14; continue 'dispatch;
            }
            0x82A5CE14 => {
    //   block [0x82A5CE14..0x82A5CE30)
	// 82A5CE14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5CE18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CE1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5CE20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5CE24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5CE28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CE2C: 4082FFE8  bne 0x82a5ce14
	if !ctx.cr[0].eq {
	pc = 0x82A5CE14; continue 'dispatch;
	}
	pc = 0x82A5CE30; continue 'dispatch;
            }
            0x82A5CE30 => {
    //   block [0x82A5CE30..0x82A5CE48)
	// 82A5CE30: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82A5CE34: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A5CE38: 48000F19  bl 0x82a5dd50
	ctx.lr = 0x82A5CE3C;
	sub_82A5DD50(ctx, base);
	// 82A5CE3C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A5CE40: 4B74FC79  bl 0x821acab8
	ctx.lr = 0x82A5CE44;
	sub_821ACAB8(ctx, base);
	// 82A5CE44: 9AE100D1  stb r23, 0xd1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(209 as u32), ctx.r[23].u8 ) };
	pc = 0x82A5CE48; continue 'dispatch;
            }
            0x82A5CE48 => {
    //   block [0x82A5CE48..0x82A5CE54)
	// 82A5CE48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5CE4C: 419A011C  beq cr6, 0x82a5cf68
	if ctx.cr[6].eq {
	pc = 0x82A5CF68; continue 'dispatch;
	}
	// 82A5CE50: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5CE54; continue 'dispatch;
            }
            0x82A5CE54 => {
    //   block [0x82A5CE54..0x82A5CE78)
	// 82A5CE54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5CE58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CE5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5CE60: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5CE64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5CE68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CE6C: 4082FFE8  bne 0x82a5ce54
	if !ctx.cr[0].eq {
	pc = 0x82A5CE54; continue 'dispatch;
	}
	// 82A5CE70: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5CE74: 480000D8  b 0x82a5cf4c
	pc = 0x82A5CF4C; continue 'dispatch;
            }
            0x82A5CE78 => {
    //   block [0x82A5CE78..0x82A5CEE4)
	// 82A5CE78: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A5CE7C: 4B7C23DD  bl 0x8221f258
	ctx.lr = 0x82A5CE80;
	sub_8221F258(ctx, base);
	// 82A5CE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5CE84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5CE88: 419A005C  beq cr6, 0x82a5cee4
	if ctx.cr[6].eq {
	pc = 0x82A5CEE4; continue 'dispatch;
	}
	// 82A5CE8C: 92FF0004  stw r23, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 82A5CE90: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82A5CE94: 933F0008  stw r25, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82A5CE98: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82A5CE9C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5CEA0: 935F0014  stw r26, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82A5CEA4: 935F0018  stw r26, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 82A5CEA8: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 82A5CEAC: 935F001C  stw r26, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 82A5CEB0: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 82A5CEB4: 9B5F0024  stb r26, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u8 ) };
	// 82A5CEB8: 9B5F0025  stb r26, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 82A5CEBC: 9B5F0026  stb r26, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[26].u8 ) };
	// 82A5CEC0: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A5CEC4: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A5CEC8: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5CECC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5CED0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A5CED4: 48000A1D  bl 0x82a5d8f0
	ctx.lr = 0x82A5CED8;
	sub_82A5D8F0(ctx, base);
	// 82A5CED8: 891E0060  lbz r8, 0x60(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A5CEDC: 991F0024  stb r8, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[8].u8 ) };
	// 82A5CEE0: 48000008  b 0x82a5cee8
	pc = 0x82A5CEE8; continue 'dispatch;
            }
            0x82A5CEE4 => {
    //   block [0x82A5CEE4..0x82A5CEE8)
	// 82A5CEE4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x82A5CEE8; continue 'dispatch;
            }
            0x82A5CEE8 => {
    //   block [0x82A5CEE8..0x82A5CEF8)
	// 82A5CEE8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82A5CEEC: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A5CEF0: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82A5CEF4: 9AFF0025  stb r23, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[23].u8 ) };
	pc = 0x82A5CEF8; continue 'dispatch;
            }
            0x82A5CEF8 => {
    //   block [0x82A5CEF8..0x82A5CF2C)
	// 82A5CEF8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5CEFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CF00: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5CF04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A5CF08: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5CF0C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CF10: 4082FFE8  bne 0x82a5cef8
	if !ctx.cr[0].eq {
	pc = 0x82A5CEF8; continue 'dispatch;
	}
	// 82A5CF14: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82A5CF18: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A5CF1C: 48000E35  bl 0x82a5dd50
	ctx.lr = 0x82A5CF20;
	sub_82A5DD50(ctx, base);
	// 82A5CF20: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A5CF24: 4B74FB95  bl 0x821acab8
	ctx.lr = 0x82A5CF28;
	sub_821ACAB8(ctx, base);
	// 82A5CF28: 9AE100B1  stb r23, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[23].u8 ) };
	pc = 0x82A5CF2C; continue 'dispatch;
            }
            0x82A5CF2C => {
    //   block [0x82A5CF2C..0x82A5CF4C)
	// 82A5CF2C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A5CF30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CF34: 7D20F028  lwarx r9, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A5CF38: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A5CF3C: 7D20F12D  stwcx. r9, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5CF40: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5CF44: 4082FFE8  bne 0x82a5cf2c
	if !ctx.cr[0].eq {
	pc = 0x82A5CF2C; continue 'dispatch;
	}
	// 82A5CF48: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82A5CF4C; continue 'dispatch;
            }
            0x82A5CF4C => {
    //   block [0x82A5CF4C..0x82A5CF68)
	// 82A5CF4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5CF50: 409A0018  bne cr6, 0x82a5cf68
	if !ctx.cr[6].eq {
	pc = 0x82A5CF68; continue 'dispatch;
	}
	// 82A5CF54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5CF58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5CF5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CF60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5CF64: 4E800421  bctrl
	ctx.lr = 0x82A5CF68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5CF68 => {
    //   block [0x82A5CF68..0x82A5CF7C)
	// 82A5CF68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5CF6C: 4B8A31BD  bl 0x82300128
	ctx.lr = 0x82A5CF70;
	sub_82300128(ctx, base);
	// 82A5CF70: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5CF74: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A5CF78: 4BFFFC40  b 0x82a5cbb8
	pc = 0x82A5CBB8; continue 'dispatch;
            }
            0x82A5CF7C => {
    //   block [0x82A5CF7C..0x82A5CF9C)
	// 82A5CF7C: 830100A4  lwz r24, 0xa4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A5CF80: 832100A8  lwz r25, 0xa8(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82A5CF84: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82A5CF88: 7F18C840  cmplw cr6, r24, r25
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5CF8C: 419A00C4  beq cr6, 0x82a5d050
	if ctx.cr[6].eq {
	pc = 0x82A5D050; continue 'dispatch;
	}
	// 82A5CF90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5CF94: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 82A5CF98: 3B8BFB54  addi r28, r11, -0x4ac
	ctx.r[28].s64 = ctx.r[11].s64 + -1196;
	pc = 0x82A5CF9C; continue 'dispatch;
            }
            0x82A5CF9C => {
    //   block [0x82A5CF9C..0x82A5CFC8)
	// 82A5CF9C: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5CFA0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A5CFA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5CFA8: 4BFFDF59  bl 0x82a5af00
	ctx.lr = 0x82A5CFAC;
	sub_82A5AF00(ctx, base);
	// 82A5CFAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5CFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CFB4: 419A0014  beq cr6, 0x82a5cfc8
	if ctx.cr[6].eq {
	pc = 0x82A5CFC8; continue 'dispatch;
	}
	// 82A5CFB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5CFBC: 4BFFF17D  bl 0x82a5c138
	ctx.lr = 0x82A5CFC0;
	sub_82A5C138(ctx, base);
	// 82A5CFC0: 9B5F0025  stb r26, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[26].u8 ) };
	// 82A5CFC4: 48000080  b 0x82a5d044
	pc = 0x82A5D044; continue 'dispatch;
            }
            0x82A5CFC8 => {
    //   block [0x82A5CFC8..0x82A5CFDC)
	// 82A5CFC8: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5CFCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CFD0: 409A000C  bne cr6, 0x82a5cfdc
	if !ctx.cr[6].eq {
	pc = 0x82A5CFDC; continue 'dispatch;
	}
	// 82A5CFD4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82A5CFD8: 409A006C  bne cr6, 0x82a5d044
	if !ctx.cr[6].eq {
	pc = 0x82A5D044; continue 'dispatch;
	}
	pc = 0x82A5CFDC; continue 'dispatch;
            }
            0x82A5CFDC => {
    //   block [0x82A5CFDC..0x82A5D028)
	// 82A5CFDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5CFE0: 4BFFED09  bl 0x82a5bce8
	ctx.lr = 0x82A5CFE4;
	sub_82A5BCE8(ctx, base);
	// 82A5CFE4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5CFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CFEC: 419A0058  beq cr6, 0x82a5d044
	if ctx.cr[6].eq {
	pc = 0x82A5D044; continue 'dispatch;
	}
	// 82A5CFF0: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5CFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5CFF8: 419A0030  beq cr6, 0x82a5d028
	if ctx.cr[6].eq {
	pc = 0x82A5D028; continue 'dispatch;
	}
	// 82A5CFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D000: 4BFFF251  bl 0x82a5c250
	ctx.lr = 0x82A5D004;
	sub_82A5C250(ctx, base);
	// 82A5D004: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 82A5D008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D00C: 419A0038  beq cr6, 0x82a5d044
	if ctx.cr[6].eq {
	pc = 0x82A5D044; continue 'dispatch;
	}
	// 82A5D010: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82A5D014: 4BFFF765  bl 0x82a5c778
	ctx.lr = 0x82A5D018;
	sub_82A5C778(ctx, base);
	// 82A5D018: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A5D01C: 9B430044  stb r26, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[26].u8 ) };
	// 82A5D020: 997B6E62  stb r11, 0x6e62(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28258 as u32), ctx.r[11].u8 ) };
	// 82A5D024: 48000020  b 0x82a5d044
	pc = 0x82A5D044; continue 'dispatch;
            }
            0x82A5D028 => {
    //   block [0x82A5D028..0x82A5D044)
	// 82A5D028: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D02C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5D030: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5D034: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A5D038: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5D03C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5D040: 480018D9  bl 0x82a5e918
	ctx.lr = 0x82A5D044;
	sub_82A5E918(ctx, base);
	pc = 0x82A5D044; continue 'dispatch;
            }
            0x82A5D044 => {
    //   block [0x82A5D044..0x82A5D050)
	// 82A5D044: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A5D048: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5D04C: 409AFF50  bne cr6, 0x82a5cf9c
	if !ctx.cr[6].eq {
	pc = 0x82A5CF9C; continue 'dispatch;
	}
	pc = 0x82A5D050; continue 'dispatch;
            }
            0x82A5D050 => {
    //   block [0x82A5D050..0x82A5D07C)
	// 82A5D050: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A5D054: 48000DC5  bl 0x82a5de18
	ctx.lr = 0x82A5D058;
	sub_82A5DE18(ctx, base);
	// 82A5D058: 83C100C4  lwz r30, 0xc4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A5D05C: 83A100C8  lwz r29, 0xc8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82A5D060: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A5D064: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5D068: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A5D06C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5D070: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A5D074: 419A0020  beq cr6, 0x82a5d094
	if ctx.cr[6].eq {
	pc = 0x82A5D094; continue 'dispatch;
	}
	// 82A5D078: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A5D07C; continue 'dispatch;
            }
            0x82A5D07C => {
    //   block [0x82A5D07C..0x82A5D094)
	// 82A5D07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5D080: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A5D084: 48000CCD  bl 0x82a5dd50
	ctx.lr = 0x82A5D088;
	sub_82A5DD50(ctx, base);
	// 82A5D088: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5D08C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5D090: 409AFFEC  bne cr6, 0x82a5d07c
	if !ctx.cr[6].eq {
	pc = 0x82A5D07C; continue 'dispatch;
	}
	pc = 0x82A5D094; continue 'dispatch;
            }
            0x82A5D094 => {
    //   block [0x82A5D094..0x82A5D0B0)
	// 82A5D094: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A5D098: 7F18C840  cmplw cr6, r24, r25
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5D09C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82A5D0A0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5D0A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A5D0A8: 419A0020  beq cr6, 0x82a5d0c8
	if ctx.cr[6].eq {
	pc = 0x82A5D0C8; continue 'dispatch;
	}
	// 82A5D0AC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A5D0B0; continue 'dispatch;
            }
            0x82A5D0B0 => {
    //   block [0x82A5D0B0..0x82A5D0C8)
	// 82A5D0B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5D0B4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A5D0B8: 48000C99  bl 0x82a5dd50
	ctx.lr = 0x82A5D0BC;
	sub_82A5DD50(ctx, base);
	// 82A5D0BC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5D0C0: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5D0C4: 409AFFEC  bne cr6, 0x82a5d0b0
	if !ctx.cr[6].eq {
	pc = 0x82A5D0B0; continue 'dispatch;
	}
	pc = 0x82A5D0C8; continue 'dispatch;
            }
            0x82A5D0C8 => {
    //   block [0x82A5D0C8..0x82A5D160)
	// 82A5D0C8: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D0CC: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 82A5D0D0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A5D0D4: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D0D8: 88D60010  lbz r6, 0x10(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5D0DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A5D0E0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5D0E4: 7D251E70  srawi r5, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82A5D0E8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A5D0EC: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A5D0F0: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5D0F4: 480025D5  bl 0x82a5f6c8
	ctx.lr = 0x82A5D0F8;
	sub_82A5F6C8(ctx, base);
	// 82A5D0F8: 9B560011  stb r26, 0x11(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(17 as u32), ctx.r[26].u8 ) };
	// 82A5D0FC: 38750008  addi r3, r21, 8
	ctx.r[3].s64 = ctx.r[21].s64 + 8;
	// 82A5D100: 9AF50044  stb r23, 0x44(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(68 as u32), ctx.r[23].u8 ) };
	// 82A5D104: 480BD805  bl 0x82b1a908
	ctx.lr = 0x82A5D108;
	sub_82B1A908(ctx, base);
	// 82A5D108: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5D10C: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A5D110: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A5D114: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82A5D118: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A5D11C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A5D120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5D124: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D128: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5D12C: 90A1006C  stw r5, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 82A5D130: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5D134: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A5D138: 4B8A49C9  bl 0x82301b00
	ctx.lr = 0x82A5D13C;
	sub_82301B00(ctx, base);
	// 82A5D13C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5D140: 4B7BEBF9  bl 0x8221bd38
	ctx.lr = 0x82A5D144;
	sub_8221BD38(ctx, base);
	// 82A5D144: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A5D148: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A5D14C: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82A5D150: 419A0070  beq cr6, 0x82a5d1c0
	if ctx.cr[6].eq {
	pc = 0x82A5D1C0; continue 'dispatch;
	}
	// 82A5D154: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5D158: 419A0060  beq cr6, 0x82a5d1b8
	if ctx.cr[6].eq {
	pc = 0x82A5D1B8; continue 'dispatch;
	}
	// 82A5D15C: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	pc = 0x82A5D160; continue 'dispatch;
            }
            0x82A5D160 => {
    //   block [0x82A5D160..0x82A5D170)
	// 82A5D160: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5D168: 419A0040  beq cr6, 0x82a5d1a8
	if ctx.cr[6].eq {
	pc = 0x82A5D1A8; continue 'dispatch;
	}
	// 82A5D16C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5D170; continue 'dispatch;
            }
            0x82A5D170 => {
    //   block [0x82A5D170..0x82A5D1A4)
	// 82A5D170: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5D174: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D178: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5D17C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5D180: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5D184: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D188: 4082FFE8  bne 0x82a5d170
	if !ctx.cr[0].eq {
	pc = 0x82A5D170; continue 'dispatch;
	}
	// 82A5D18C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5D190: 409A0014  bne cr6, 0x82a5d1a4
	if !ctx.cr[6].eq {
	pc = 0x82A5D1A4; continue 'dispatch;
	}
	// 82A5D194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D198: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D19C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D1A0: 4E800421  bctrl
	ctx.lr = 0x82A5D1A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5D1A4 => {
    //   block [0x82A5D1A4..0x82A5D1A8)
	// 82A5D1A4: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5D1A8; continue 'dispatch;
            }
            0x82A5D1A8 => {
    //   block [0x82A5D1A8..0x82A5D1B8)
	// 82A5D1A8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5D1AC: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82A5D1B0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5D1B4: 409AFFAC  bne cr6, 0x82a5d160
	if !ctx.cr[6].eq {
	pc = 0x82A5D160; continue 'dispatch;
	}
	pc = 0x82A5D1B8; continue 'dispatch;
            }
            0x82A5D1B8 => {
    //   block [0x82A5D1B8..0x82A5D1C0)
	// 82A5D1B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5D1BC: 4B7BEB7D  bl 0x8221bd38
	ctx.lr = 0x82A5D1C0;
	sub_8221BD38(ctx, base);
	pc = 0x82A5D1C0; continue 'dispatch;
            }
            0x82A5D1C0 => {
    //   block [0x82A5D1C0..0x82A5D1D4)
	// 82A5D1C0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82A5D1C4: 419A0070  beq cr6, 0x82a5d234
	if ctx.cr[6].eq {
	pc = 0x82A5D234; continue 'dispatch;
	}
	// 82A5D1C8: 7F18C840  cmplw cr6, r24, r25
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5D1CC: 419A0060  beq cr6, 0x82a5d22c
	if ctx.cr[6].eq {
	pc = 0x82A5D22C; continue 'dispatch;
	}
	// 82A5D1D0: 3BF80004  addi r31, r24, 4
	ctx.r[31].s64 = ctx.r[24].s64 + 4;
	pc = 0x82A5D1D4; continue 'dispatch;
            }
            0x82A5D1D4 => {
    //   block [0x82A5D1D4..0x82A5D1E4)
	// 82A5D1D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D1D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5D1DC: 419A0040  beq cr6, 0x82a5d21c
	if ctx.cr[6].eq {
	pc = 0x82A5D21C; continue 'dispatch;
	}
	// 82A5D1E0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5D1E4; continue 'dispatch;
            }
            0x82A5D1E4 => {
    //   block [0x82A5D1E4..0x82A5D218)
	// 82A5D1E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5D1E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D1EC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5D1F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5D1F4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5D1F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D1FC: 4082FFE8  bne 0x82a5d1e4
	if !ctx.cr[0].eq {
	pc = 0x82A5D1E4; continue 'dispatch;
	}
	// 82A5D200: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5D204: 409A0014  bne cr6, 0x82a5d218
	if !ctx.cr[6].eq {
	pc = 0x82A5D218; continue 'dispatch;
	}
	// 82A5D208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D20C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D210: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D214: 4E800421  bctrl
	ctx.lr = 0x82A5D218;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5D218 => {
    //   block [0x82A5D218..0x82A5D21C)
	// 82A5D218: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A5D21C; continue 'dispatch;
            }
            0x82A5D21C => {
    //   block [0x82A5D21C..0x82A5D22C)
	// 82A5D21C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5D220: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82A5D224: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5D228: 409AFFAC  bne cr6, 0x82a5d1d4
	if !ctx.cr[6].eq {
	pc = 0x82A5D1D4; continue 'dispatch;
	}
	pc = 0x82A5D22C; continue 'dispatch;
            }
            0x82A5D22C => {
    //   block [0x82A5D22C..0x82A5D234)
	// 82A5D22C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A5D230: 4B7BEB09  bl 0x8221bd38
	ctx.lr = 0x82A5D234;
	sub_8221BD38(ctx, base);
	pc = 0x82A5D234; continue 'dispatch;
            }
            0x82A5D234 => {
    //   block [0x82A5D234..0x82A5D23C)
	// 82A5D234: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82A5D238: 4824C1FC  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5D240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5D240 size=720
    let mut pc: u32 = 0x82A5D240;
    'dispatch: loop {
        match pc {
            0x82A5D240 => {
    //   block [0x82A5D240..0x82A5D2A0)
	// 82A5D240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5D244: 4824C1B1  bl 0x82ca93f4
	ctx.lr = 0x82A5D248;
	sub_82CA93D0(ctx, base);
	// 82A5D248: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5D24C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5D250: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5D254: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82A5D258: 4BFF1E89  bl 0x82a4f0e0
	ctx.lr = 0x82A5D25C;
	sub_82A4F0E0(ctx, base);
	// 82A5D25C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5D260: 4B7C17C9  bl 0x8221ea28
	ctx.lr = 0x82A5D264;
	sub_8221EA28(ctx, base);
	// 82A5D264: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D26C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D270: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D274: 4E800421  bctrl
	ctx.lr = 0x82A5D278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D278: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82A5D27C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A5D280: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A5D284: 3AEBFFDF  addi r23, r11, -0x21
	ctx.r[23].s64 = ctx.r[11].s64 + -33;
	// 82A5D288: 8169FB70  lwz r11, -0x490(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-1168 as u32) ) } as u64;
	// 82A5D28C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D290: 409A0010  bne cr6, 0x82a5d2a0
	if !ctx.cr[6].eq {
	pc = 0x82A5D2A0; continue 'dispatch;
	}
	// 82A5D294: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A5D298: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82A5D29C: 4800000C  b 0x82a5d2a8
	pc = 0x82A5D2A8; continue 'dispatch;
            }
            0x82A5D2A0 => {
    //   block [0x82A5D2A0..0x82A5D2A8)
	// 82A5D2A0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D2A4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5D2A8; continue 'dispatch;
            }
            0x82A5D2A8 => {
    //   block [0x82A5D2A8..0x82A5D2E4)
	// 82A5D2A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D2B0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5D2B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D2B8: 4E800421  bctrl
	ctx.lr = 0x82A5D2BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D2BC: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 82A5D2C0: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82A5D2C4: 9301006C  stw r24, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[24].u32 ) };
	// 82A5D2C8: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82A5D2CC: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82A5D2D0: 9B010071  stb r24, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[24].u8 ) };
	// 82A5D2D4: 83BE0034  lwz r29, 0x34(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A5D2D8: 837E0038  lwz r27, 0x38(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A5D2DC: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A5D2E0: 419A0080  beq cr6, 0x82a5d360
	if ctx.cr[6].eq {
	pc = 0x82A5D360; continue 'dispatch;
	}
            }
            0x82A5D2E4 => {
    //   block [0x82A5D2E4..0x82A5D330)
	// 82A5D2E4: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D2E8: 897E0024  lbz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A5D2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D2F0: 409A005C  bne cr6, 0x82a5d34c
	if !ctx.cr[6].eq {
	pc = 0x82A5D34C; continue 'dispatch;
	}
	// 82A5D2F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5D2F8: 4BFFDC09  bl 0x82a5af00
	ctx.lr = 0x82A5D2FC;
	sub_82A5AF00(ctx, base);
	// 82A5D2FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5D300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D304: 409A0048  bne cr6, 0x82a5d34c
	if !ctx.cr[6].eq {
	pc = 0x82A5D34C; continue 'dispatch;
	}
	// 82A5D308: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D30C: 7F0BC800  cmpw cr6, r11, r25
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82A5D310: 409A003C  bne cr6, 0x82a5d34c
	if !ctx.cr[6].eq {
	pc = 0x82A5D34C; continue 'dispatch;
	}
	// 82A5D314: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A5D318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5D31C: 419A0014  beq cr6, 0x82a5d330
	if ctx.cr[6].eq {
	pc = 0x82A5D330; continue 'dispatch;
	}
	// 82A5D320: 896B0081  lbz r11, 0x81(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(129 as u32) ) } as u64;
	// 82A5D324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5D32C: 409A0008  bne cr6, 0x82a5d334
	if !ctx.cr[6].eq {
	pc = 0x82A5D334; continue 'dispatch;
	}
	pc = 0x82A5D330; continue 'dispatch;
            }
            0x82A5D330 => {
    //   block [0x82A5D330..0x82A5D334)
	// 82A5D330: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82A5D334; continue 'dispatch;
            }
            0x82A5D334 => {
    //   block [0x82A5D334..0x82A5D34C)
	// 82A5D334: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5D338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D33C: 419A0010  beq cr6, 0x82a5d34c
	if ctx.cr[6].eq {
	pc = 0x82A5D34C; continue 'dispatch;
	}
	// 82A5D340: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5D344: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5D348: 48000A09  bl 0x82a5dd50
	ctx.lr = 0x82A5D34C;
	sub_82A5DD50(ctx, base);
	pc = 0x82A5D34C; continue 'dispatch;
            }
            0x82A5D34C => {
    //   block [0x82A5D34C..0x82A5D360)
	// 82A5D34C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A5D350: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A5D354: 409AFF90  bne cr6, 0x82a5d2e4
	if !ctx.cr[6].eq {
	pc = 0x82A5D2E4; continue 'dispatch;
	}
	// 82A5D358: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A5D35C: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x82A5D360; continue 'dispatch;
            }
            0x82A5D360 => {
    //   block [0x82A5D360..0x82A5D398)
	// 82A5D360: 7D7AE050  subf r11, r26, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[26].s64;
	// 82A5D364: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D368: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5D36C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5D370: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A5D374: 419A0024  beq cr6, 0x82a5d398
	if ctx.cr[6].eq {
	pc = 0x82A5D398; continue 'dispatch;
	}
	// 82A5D378: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5D37C: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5D380: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82A5D384: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5D388: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A5D38C: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82A5D390: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5D394: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5D398; continue 'dispatch;
            }
            0x82A5D398 => {
    //   block [0x82A5D398..0x82A5D3D0)
	// 82A5D398: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D39C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5D3A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5D3A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D3A8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5D3AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D3B0: 4E800421  bctrl
	ctx.lr = 0x82A5D3B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D3B4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A5D3B8: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82A5D3BC: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5D3C0: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5D3C4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A5D3C8: 419A0074  beq cr6, 0x82a5d43c
	if ctx.cr[6].eq {
	pc = 0x82A5D43C; continue 'dispatch;
	}
	// 82A5D3CC: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
            }
            0x82A5D3D0 => {
    //   block [0x82A5D3D0..0x82A5D408)
	// 82A5D3D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D3D4: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D3D8: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D3DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5D3E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A5D3E4: 419A0024  beq cr6, 0x82a5d408
	if ctx.cr[6].eq {
	pc = 0x82A5D408; continue 'dispatch;
	}
	// 82A5D3E8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5D3EC: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5D3F0: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82A5D3F4: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5D3F8: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A5D3FC: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82A5D400: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5D404: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5D408; continue 'dispatch;
            }
            0x82A5D408 => {
    //   block [0x82A5D408..0x82A5D43C)
	// 82A5D408: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D40C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5D410: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5D414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D418: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5D41C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D420: 4E800421  bctrl
	ctx.lr = 0x82A5D424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5D428: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5D42C: 4BFFDE5D  bl 0x82a5b288
	ctx.lr = 0x82A5D430;
	sub_82A5B288(ctx, base);
	// 82A5D430: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A5D434: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5D438: 409AFF98  bne cr6, 0x82a5d3d0
	if !ctx.cr[6].eq {
	pc = 0x82A5D3D0; continue 'dispatch;
	}
            }
            0x82A5D43C => {
    //   block [0x82A5D43C..0x82A5D458)
	// 82A5D43C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5D440: 816BFB74  lwz r11, -0x48c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1164 as u32) ) } as u64;
	// 82A5D444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D448: 409A0010  bne cr6, 0x82a5d458
	if !ctx.cr[6].eq {
	pc = 0x82A5D458; continue 'dispatch;
	}
	// 82A5D44C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A5D450: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82A5D454: 4800000C  b 0x82a5d460
	pc = 0x82A5D460; continue 'dispatch;
            }
            0x82A5D458 => {
    //   block [0x82A5D458..0x82A5D460)
	// 82A5D458: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D45C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5D460; continue 'dispatch;
            }
            0x82A5D460 => {
    //   block [0x82A5D460..0x82A5D4A4)
	// 82A5D460: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D468: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5D46C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D470: 4E800421  bctrl
	ctx.lr = 0x82A5D474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5D478: 4B7C15B1  bl 0x8221ea28
	ctx.lr = 0x82A5D47C;
	sub_8221EA28(ctx, base);
	// 82A5D47C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D484: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D488: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A5D48C: 4E800421  bctrl
	ctx.lr = 0x82A5D490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D490: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A5D494: 419A0070  beq cr6, 0x82a5d504
	if ctx.cr[6].eq {
	pc = 0x82A5D504; continue 'dispatch;
	}
	// 82A5D498: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5D49C: 419A0060  beq cr6, 0x82a5d4fc
	if ctx.cr[6].eq {
	pc = 0x82A5D4FC; continue 'dispatch;
	}
	// 82A5D4A0: 3BFA0004  addi r31, r26, 4
	ctx.r[31].s64 = ctx.r[26].s64 + 4;
            }
            0x82A5D4A4 => {
    //   block [0x82A5D4A4..0x82A5D4B4)
	// 82A5D4A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D4A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5D4AC: 419A0040  beq cr6, 0x82a5d4ec
	if ctx.cr[6].eq {
	pc = 0x82A5D4EC; continue 'dispatch;
	}
	// 82A5D4B0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5D4B4; continue 'dispatch;
            }
            0x82A5D4B4 => {
    //   block [0x82A5D4B4..0x82A5D4E8)
	// 82A5D4B4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5D4B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D4BC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5D4C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5D4C4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5D4C8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D4CC: 4082FFE8  bne 0x82a5d4b4
	if !ctx.cr[0].eq {
	pc = 0x82A5D4B4; continue 'dispatch;
	}
	// 82A5D4D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5D4D4: 409A0014  bne cr6, 0x82a5d4e8
	if !ctx.cr[6].eq {
	pc = 0x82A5D4E8; continue 'dispatch;
	}
	// 82A5D4D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D4DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D4E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D4E4: 4E800421  bctrl
	ctx.lr = 0x82A5D4E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5D4E8 => {
    //   block [0x82A5D4E8..0x82A5D4EC)
	// 82A5D4E8: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82A5D4EC; continue 'dispatch;
            }
            0x82A5D4EC => {
    //   block [0x82A5D4EC..0x82A5D4FC)
	// 82A5D4EC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5D4F0: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82A5D4F4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5D4F8: 409AFFAC  bne cr6, 0x82a5d4a4
	if !ctx.cr[6].eq {
	pc = 0x82A5D4A4; continue 'dispatch;
	}
	pc = 0x82A5D4FC; continue 'dispatch;
            }
            0x82A5D4FC => {
    //   block [0x82A5D4FC..0x82A5D504)
	// 82A5D4FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A5D500: 4B7BE839  bl 0x8221bd38
	ctx.lr = 0x82A5D504;
	sub_8221BD38(ctx, base);
	pc = 0x82A5D504; continue 'dispatch;
            }
            0x82A5D504 => {
    //   block [0x82A5D504..0x82A5D510)
	// 82A5D504: 4BFF1CD5  bl 0x82a4f1d8
	ctx.lr = 0x82A5D508;
	sub_82A4F1D8(ctx, base);
	// 82A5D508: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A5D50C: 4824BF38  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5D510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5D510 size=992
    let mut pc: u32 = 0x82A5D510;
    'dispatch: loop {
        match pc {
            0x82A5D510 => {
    //   block [0x82A5D510..0x82A5D580)
	// 82A5D510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5D514: 4824BED1  bl 0x82ca93e4
	ctx.lr = 0x82A5D518;
	sub_82CA93D0(ctx, base);
	// 82A5D518: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5D51C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 82A5D520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5D524: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82A5D528: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82A5D52C: 4BFF1BB5  bl 0x82a4f0e0
	ctx.lr = 0x82A5D530;
	sub_82A4F0E0(ctx, base);
	// 82A5D530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5D534: 4B7C14F5  bl 0x8221ea28
	ctx.lr = 0x82A5D538;
	sub_8221EA28(ctx, base);
	// 82A5D538: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D53C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5D540: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D544: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D548: 4E800421  bctrl
	ctx.lr = 0x82A5D54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D54C: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D550: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D554: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5D558: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5D55C: 419A0388  beq cr6, 0x82a5d8e4
	if ctx.cr[6].eq {
	pc = 0x82A5D8E4; continue 'dispatch;
	}
	// 82A5D560: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5D564: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A5D568: 3BEBFB70  addi r31, r11, -0x490
	ctx.r[31].s64 = ctx.r[11].s64 + -1168;
	// 82A5D56C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5D570: 816BFB70  lwz r11, -0x490(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1168 as u32) ) } as u64;
	// 82A5D574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D578: 419A0008  beq cr6, 0x82a5d580
	if ctx.cr[6].eq {
	pc = 0x82A5D580; continue 'dispatch;
	}
	// 82A5D57C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x82A5D580 => {
    //   block [0x82A5D580..0x82A5D5D0)
	// 82A5D580: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5D584: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A5D588: 4BFC3DA9  bl 0x82a21330
	ctx.lr = 0x82A5D58C;
	sub_82A21330(ctx, base);
	// 82A5D58C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5D590: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A5D594: 480E08B5  bl 0x82b3de48
	ctx.lr = 0x82A5D598;
	sub_82B3DE48(ctx, base);
	// 82A5D598: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5D59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D5A0: 419A0030  beq cr6, 0x82a5d5d0
	if ctx.cr[6].eq {
	pc = 0x82A5D5D0; continue 'dispatch;
	}
	// 82A5D5A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D5A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5D5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5D5B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D5B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D5B8: 4E800421  bctrl
	ctx.lr = 0x82A5D5BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A5D5BC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A5D5C0: 4B7B7819  bl 0x82214dd8
	ctx.lr = 0x82A5D5C4;
	sub_82214DD8(ctx, base);
	// 82A5D5C4: 4BFF1C15  bl 0x82a4f1d8
	ctx.lr = 0x82A5D5C8;
	sub_82A4F1D8(ctx, base);
	// 82A5D5C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A5D5CC: 4824BE68  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5D5D0 => {
    //   block [0x82A5D5D0..0x82A5D630)
	// 82A5D5D0: 3AF30030  addi r23, r19, 0x30
	ctx.r[23].s64 = ctx.r[19].s64 + 48;
	// 82A5D5D4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A5D5D8: 48000841  bl 0x82a5de18
	ctx.lr = 0x82A5D5DC;
	sub_82A5DE18(ctx, base);
	// 82A5D5DC: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5D5E0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5D5E4: 4198004C  blt cr6, 0x82a5d630
	if ctx.cr[6].lt {
	pc = 0x82A5D630; continue 'dispatch;
	}
	// 82A5D5E8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5D5EC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5D5F0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A5D5F4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D5F8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5D5FC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5D600: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D604: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5D608: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5D60C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5D610: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5D614: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5D618: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5D61C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5D620: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5D624: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5D628: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5D62C: 48000014  b 0x82a5d640
	pc = 0x82A5D640; continue 'dispatch;
            }
            0x82A5D630 => {
    //   block [0x82A5D630..0x82A5D640)
	// 82A5D630: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5D634: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A5D638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5D63C: 4BFC38AD  bl 0x82a20ee8
	ctx.lr = 0x82A5D640;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5D640; continue 'dispatch;
            }
            0x82A5D640 => {
    //   block [0x82A5D640..0x82A5D678)
	// 82A5D640: 82C10054  lwz r22, 0x54(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5D644: 897E0018  lbz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5D648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D64C: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82A5D650: 419A0028  beq cr6, 0x82a5d678
	if ctx.cr[6].eq {
	pc = 0x82A5D678; continue 'dispatch;
	}
	// 82A5D654: 89010057  lbz r8, 0x57(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82A5D658: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5D65C: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5D660: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5D664: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82A5D668: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82A5D66C: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 82A5D670: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A5D674: 82C10050  lwz r22, 0x50(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A5D678; continue 'dispatch;
            }
            0x82A5D678 => {
    //   block [0x82A5D678..0x82A5D698)
	// 82A5D678: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	// 82A5D67C: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82A5D680: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 82A5D684: 40990204  ble cr6, 0x82a5d888
	if !ctx.cr[6].gt {
	pc = 0x82A5D888; continue 'dispatch;
	}
	// 82A5D688: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A5D68C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A5D690: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 82A5D694: 3B6B6D00  addi r27, r11, 0x6d00
	ctx.r[27].s64 = ctx.r[11].s64 + 27904;
	pc = 0x82A5D698; continue 'dispatch;
            }
            0x82A5D698 => {
    //   block [0x82A5D698..0x82A5D6EC)
	// 82A5D698: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5D69C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A5D6A0: 4198004C  blt cr6, 0x82a5d6ec
	if ctx.cr[6].lt {
	pc = 0x82A5D6EC; continue 'dispatch;
	}
	// 82A5D6A4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A5D6A8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5D6AC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A5D6B0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D6B4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A5D6B8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A5D6BC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D6C0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A5D6C4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A5D6C8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A5D6CC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A5D6D0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A5D6D4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A5D6D8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A5D6DC: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A5D6E0: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A5D6E4: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A5D6E8: 48000014  b 0x82a5d6fc
	pc = 0x82A5D6FC; continue 'dispatch;
            }
            0x82A5D6EC => {
    //   block [0x82A5D6EC..0x82A5D6FC)
	// 82A5D6EC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A5D6F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A5D6F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5D6F8: 4BFC37F1  bl 0x82a20ee8
	ctx.lr = 0x82A5D6FC;
	sub_82A20EE8(ctx, base);
	pc = 0x82A5D6FC; continue 'dispatch;
            }
            0x82A5D6FC => {
    //   block [0x82A5D6FC..0x82A5D730)
	// 82A5D6FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5D700: 895E0018  lbz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A5D704: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5D708: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A5D70C: 419A0024  beq cr6, 0x82a5d730
	if ctx.cr[6].eq {
	pc = 0x82A5D730; continue 'dispatch;
	}
	// 82A5D710: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A5D714: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A5D718: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A5D71C: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A5D720: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A5D724: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A5D728: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A5D72C: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5D730; continue 'dispatch;
            }
            0x82A5D730 => {
    //   block [0x82A5D730..0x82A5D774)
	// 82A5D730: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A5D734: 4B7C1B25  bl 0x8221f258
	ctx.lr = 0x82A5D738;
	sub_8221F258(ctx, base);
	// 82A5D738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5D73C: 419A0038  beq cr6, 0x82a5d774
	if ctx.cr[6].eq {
	pc = 0x82A5D774; continue 'dispatch;
	}
	// 82A5D740: 93830004  stw r28, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A5D744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5D748: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5D74C: 93430008  stw r26, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82A5D750: 93A30010  stw r29, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82A5D754: 93A30014  stw r29, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82A5D758: 93A30018  stw r29, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82A5D75C: 93A3001C  stw r29, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82A5D760: 93A30020  stw r29, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82A5D764: 9BA30024  stb r29, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 82A5D768: 9BA30025  stb r29, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[29].u8 ) };
	// 82A5D76C: 9BA30026  stb r29, 0x26(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[29].u8 ) };
	// 82A5D770: 48000008  b 0x82a5d778
	pc = 0x82A5D778; continue 'dispatch;
            }
            0x82A5D774 => {
    //   block [0x82A5D774..0x82A5D778)
	// 82A5D774: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82A5D778; continue 'dispatch;
            }
            0x82A5D778 => {
    //   block [0x82A5D778..0x82A5D7B0)
	// 82A5D778: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82A5D77C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82A5D780: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5D784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D788: 4BFFDE51  bl 0x82a5b5d8
	ctx.lr = 0x82A5D78C;
	sub_82A5B5D8(ctx, base);
	// 82A5D78C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5D790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D794: 419A00AC  beq cr6, 0x82a5d840
	if ctx.cr[6].eq {
	pc = 0x82A5D840; continue 'dispatch;
	}
	// 82A5D798: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5D79C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5D7A0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82A5D7A4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A5D7A8: 419A0024  beq cr6, 0x82a5d7cc
	if ctx.cr[6].eq {
	pc = 0x82A5D7CC; continue 'dispatch;
	}
	// 82A5D7AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5D7B0; continue 'dispatch;
            }
            0x82A5D7B0 => {
    //   block [0x82A5D7B0..0x82A5D7CC)
	// 82A5D7B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5D7B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D7B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5D7BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5D7C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5D7C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D7C8: 4082FFE8  bne 0x82a5d7b0
	if !ctx.cr[0].eq {
	pc = 0x82A5D7B0; continue 'dispatch;
	}
	pc = 0x82A5D7CC; continue 'dispatch;
            }
            0x82A5D7CC => {
    //   block [0x82A5D7CC..0x82A5D7F4)
	// 82A5D7CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A5D7D0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A5D7D4: 4800057D  bl 0x82a5dd50
	ctx.lr = 0x82A5D7D8;
	sub_82A5DD50(ctx, base);
	// 82A5D7D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5D7DC: 4B74F2DD  bl 0x821acab8
	ctx.lr = 0x82A5D7E0;
	sub_821ACAB8(ctx, base);
	// 82A5D7E0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82A5D7E4: 9B970011  stb r28, 0x11(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	// 82A5D7E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5D7EC: 419A0044  beq cr6, 0x82a5d830
	if ctx.cr[6].eq {
	pc = 0x82A5D830; continue 'dispatch;
	}
	// 82A5D7F0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5D7F4; continue 'dispatch;
            }
            0x82A5D7F4 => {
    //   block [0x82A5D7F4..0x82A5D830)
	// 82A5D7F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5D7F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D7FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5D800: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5D804: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5D808: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D80C: 4082FFE8  bne 0x82a5d7f4
	if !ctx.cr[0].eq {
	pc = 0x82A5D7F4; continue 'dispatch;
	}
	// 82A5D810: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5D814: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5D818: 409A0018  bne cr6, 0x82a5d830
	if !ctx.cr[6].eq {
	pc = 0x82A5D830; continue 'dispatch;
	}
	// 82A5D81C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D824: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D828: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D82C: 4E800421  bctrl
	ctx.lr = 0x82A5D830;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5D830 => {
    //   block [0x82A5D830..0x82A5D840)
	// 82A5D830: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82A5D834: 7F18B000  cmpw cr6, r24, r22
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82A5D838: 4198FE60  blt cr6, 0x82a5d698
	if ctx.cr[6].lt {
	pc = 0x82A5D698; continue 'dispatch;
	}
	// 82A5D83C: 4800004C  b 0x82a5d888
	pc = 0x82A5D888; continue 'dispatch;
            }
            0x82A5D840 => {
    //   block [0x82A5D840..0x82A5D84C)
	// 82A5D840: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5D844: 419A0044  beq cr6, 0x82a5d888
	if ctx.cr[6].eq {
	pc = 0x82A5D888; continue 'dispatch;
	}
	// 82A5D848: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5D84C; continue 'dispatch;
            }
            0x82A5D84C => {
    //   block [0x82A5D84C..0x82A5D888)
	// 82A5D84C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5D850: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D854: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5D858: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5D85C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5D860: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5D864: 4082FFE8  bne 0x82a5d84c
	if !ctx.cr[0].eq {
	pc = 0x82A5D84C; continue 'dispatch;
	}
	// 82A5D868: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5D86C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5D870: 409A0018  bne cr6, 0x82a5d888
	if !ctx.cr[6].eq {
	pc = 0x82A5D888; continue 'dispatch;
	}
	// 82A5D874: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5D878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D87C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D880: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5D884: 4E800421  bctrl
	ctx.lr = 0x82A5D888;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5D888 => {
    //   block [0x82A5D888..0x82A5D89C)
	// 82A5D888: 89770011  lbz r11, 0x11(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A5D88C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D890: 419A000C  beq cr6, 0x82a5d89c
	if ctx.cr[6].eq {
	pc = 0x82A5D89C; continue 'dispatch;
	}
	// 82A5D894: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A5D898: 48000311  bl 0x82a5dba8
	ctx.lr = 0x82A5D89C;
	sub_82A5DBA8(ctx, base);
	pc = 0x82A5D89C; continue 'dispatch;
            }
            0x82A5D89C => {
    //   block [0x82A5D89C..0x82A5D8BC)
	// 82A5D89C: 7F19B000  cmpw cr6, r25, r22
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82A5D8A0: 409A0030  bne cr6, 0x82a5d8d0
	if !ctx.cr[6].eq {
	pc = 0x82A5D8D0; continue 'dispatch;
	}
	// 82A5D8A4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5D8A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5D8AC: 816BFB74  lwz r11, -0x48c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1164 as u32) ) } as u64;
	// 82A5D8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5D8B4: 419A0008  beq cr6, 0x82a5d8bc
	if ctx.cr[6].eq {
	pc = 0x82A5D8BC; continue 'dispatch;
	}
	// 82A5D8B8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5D8BC; continue 'dispatch;
            }
            0x82A5D8BC => {
    //   block [0x82A5D8BC..0x82A5D8D0)
	// 82A5D8BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5D8C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5D8C4: 4BFC3A6D  bl 0x82a21330
	ctx.lr = 0x82A5D8C8;
	sub_82A21330(ctx, base);
	// 82A5D8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5D8CC: 4B7B750D  bl 0x82214dd8
	ctx.lr = 0x82A5D8D0;
	sub_82214DD8(ctx, base);
	pc = 0x82A5D8D0; continue 'dispatch;
            }
            0x82A5D8D0 => {
    //   block [0x82A5D8D0..0x82A5D8E4)
	// 82A5D8D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5D8D4: 4B7C1155  bl 0x8221ea28
	ctx.lr = 0x82A5D8D8;
	sub_8221EA28(ctx, base);
	// 82A5D8D8: 9BB30044  stb r29, 0x44(r19)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[19].u32.wrapping_add(68 as u32), ctx.r[29].u8 ) };
	// 82A5D8DC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A5D8E0: 4B7B74F9  bl 0x82214dd8
	ctx.lr = 0x82A5D8E4;
	sub_82214DD8(ctx, base);
	pc = 0x82A5D8E4; continue 'dispatch;
            }
            0x82A5D8E4 => {
    //   block [0x82A5D8E4..0x82A5D8F0)
	// 82A5D8E4: 4BFF18F5  bl 0x82a4f1d8
	ctx.lr = 0x82A5D8E8;
	sub_82A4F1D8(ctx, base);
	// 82A5D8E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A5D8EC: 4824BB48  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5D8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5D8F0 size=448
    let mut pc: u32 = 0x82A5D8F0;
    'dispatch: loop {
        match pc {
            0x82A5D8F0 => {
    //   block [0x82A5D8F0..0x82A5D950)
	// 82A5D8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5D8F4: 4824BB15  bl 0x82ca9408
	ctx.lr = 0x82A5D8F8;
	sub_82CA93D0(ctx, base);
	// 82A5D8F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5D8FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5D900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5D904: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5D908: 419A019C  beq cr6, 0x82a5daa4
	if ctx.cr[6].eq {
	pc = 0x82A5DAA4; continue 'dispatch;
	}
	// 82A5D90C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D910: 3BA00024  li r29, 0x24
	ctx.r[29].s64 = 36;
	// 82A5D914: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D918: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D91C: 7D632050  subf r11, r3, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82A5D920: 7D4BEBD7  divw. r10, r11, r29
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A5D924: 4082002C  bne 0x82a5d950
	if !ctx.cr[0].eq {
	pc = 0x82A5D950; continue 'dispatch;
	}
	// 82A5D928: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D92C: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5D930: 419A0174  beq cr6, 0x82a5daa4
	if ctx.cr[6].eq {
	pc = 0x82A5DAA4; continue 'dispatch;
	}
	// 82A5D934: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A5D938: 48001BE9  bl 0x82a5f520
	ctx.lr = 0x82A5D93C;
	sub_82A5F520(ctx, base);
	// 82A5D93C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5D940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D944: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5D948: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5D94C: 4824BB0C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5D950 => {
    //   block [0x82A5D950..0x82A5D99C)
	// 82A5D950: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D954: 7D255850  subf r9, r5, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82A5D958: 7D69EBD6  divw r11, r9, r29
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[29].s32;
	// 82A5D95C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5D960: 4199003C  bgt cr6, 0x82a5d99c
	if ctx.cr[6].gt {
	pc = 0x82A5D99C; continue 'dispatch;
	}
	// 82A5D964: 48001BBD  bl 0x82a5f520
	ctx.lr = 0x82A5D968;
	sub_82A5F520(ctx, base);
	// 82A5D968: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D96C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D974: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D978: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5D97C: 7D68EBD6  divw r11, r8, r29
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[29].s32;
	// 82A5D980: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5D984: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A5D988: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5D98C: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A5D990: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A5D994: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5D998: 4824BAC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5D99C => {
    //   block [0x82A5D99C..0x82A5D9B0)
	// 82A5D99C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A5D9A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A5D9A4: 409A000C  bne cr6, 0x82a5d9b0
	if !ctx.cr[6].eq {
	pc = 0x82A5D9B0; continue 'dispatch;
	}
	// 82A5D9A8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82A5D9AC: 48000010  b 0x82a5d9bc
	pc = 0x82A5D9BC; continue 'dispatch;
            }
            0x82A5D9B0 => {
    //   block [0x82A5D9B0..0x82A5D9BC)
	// 82A5D9B0: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5D9B4: 7D054850  subf r8, r5, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 82A5D9B8: 7D28EBD6  divw r9, r8, r29
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[29].s32;
	pc = 0x82A5D9BC; continue 'dispatch;
            }
            0x82A5D9BC => {
    //   block [0x82A5D9BC..0x82A5D9F0)
	// 82A5D9BC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5D9C0: 41990060  bgt cr6, 0x82a5da20
	if ctx.cr[6].gt {
	pc = 0x82A5DA20; continue 'dispatch;
	}
	// 82A5D9C4: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5D9C8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5D9CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A5D9D0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5D9D4: 7FAB1A14  add r29, r11, r3
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82A5D9D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5D9DC: 48001B45  bl 0x82a5f520
	ctx.lr = 0x82A5D9E0;
	sub_82A5F520(ctx, base);
	// 82A5D9E0: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D9E4: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5D9E8: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5D9EC: 419A0024  beq cr6, 0x82a5da10
	if ctx.cr[6].eq {
	pc = 0x82A5DA10; continue 'dispatch;
	}
	pc = 0x82A5D9F0; continue 'dispatch;
            }
            0x82A5D9F0 => {
    //   block [0x82A5D9F0..0x82A5DA10)
	// 82A5D9F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5D9F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5D9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5D9FC: 4BB5F6F5  bl 0x825bd0f0
	ctx.lr = 0x82A5DA00;
	sub_825BD0F0(ctx, base);
	// 82A5DA00: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 82A5DA04: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 82A5DA08: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5DA0C: 409AFFE4  bne cr6, 0x82a5d9f0
	if !ctx.cr[6].eq {
	pc = 0x82A5D9F0; continue 'dispatch;
	}
	pc = 0x82A5DA10; continue 'dispatch;
            }
            0x82A5DA10 => {
    //   block [0x82A5DA10..0x82A5DA20)
	// 82A5DA10: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A5DA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5DA18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5DA1C: 4824BA3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5DA20 => {
    //   block [0x82A5DA20..0x82A5DA30)
	// 82A5DA20: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A5DA24: 419A000C  beq cr6, 0x82a5da30
	if ctx.cr[6].eq {
	pc = 0x82A5DA30; continue 'dispatch;
	}
	// 82A5DA28: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A5DA2C: 4B7BE30D  bl 0x8221bd38
	ctx.lr = 0x82A5DA30;
	sub_8221BD38(ctx, base);
	pc = 0x82A5DA30; continue 'dispatch;
            }
            0x82A5DA30 => {
    //   block [0x82A5DA30..0x82A5DA58)
	// 82A5DA30: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DA34: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DA38: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A5DA3C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5DA40: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A5DA44: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A5DA48: 7C89EBD7  divw. r4, r9, r29
	ctx.r[4].s32 = ctx.r[9].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A5DA4C: 4082000C  bne 0x82a5da58
	if !ctx.cr[0].eq {
	pc = 0x82A5DA58; continue 'dispatch;
	}
	// 82A5DA50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5DA54: 4800000C  b 0x82a5da60
	pc = 0x82A5DA60; continue 'dispatch;
            }
            0x82A5DA58 => {
    //   block [0x82A5DA58..0x82A5DA60)
	// 82A5DA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5DA5C: 4BB5D345  bl 0x825bada0
	ctx.lr = 0x82A5DA60;
	sub_825BADA0(ctx, base);
	pc = 0x82A5DA60; continue 'dispatch;
            }
            0x82A5DA60 => {
    //   block [0x82A5DA60..0x82A5DA80)
	// 82A5DA60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A5DA64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5DA68: 419A003C  beq cr6, 0x82a5daa4
	if ctx.cr[6].eq {
	pc = 0x82A5DAA4; continue 'dispatch;
	}
	// 82A5DA6C: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DA70: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DA74: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DA78: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5DA7C: 419A0024  beq cr6, 0x82a5daa0
	if ctx.cr[6].eq {
	pc = 0x82A5DAA0; continue 'dispatch;
	}
	pc = 0x82A5DA80; continue 'dispatch;
            }
            0x82A5DA80 => {
    //   block [0x82A5DA80..0x82A5DAA0)
	// 82A5DA80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5DA84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5DA88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5DA8C: 4BB5F665  bl 0x825bd0f0
	ctx.lr = 0x82A5DA90;
	sub_825BD0F0(ctx, base);
	// 82A5DA90: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 82A5DA94: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 82A5DA98: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5DA9C: 409AFFE4  bne cr6, 0x82a5da80
	if !ctx.cr[6].eq {
	pc = 0x82A5DA80; continue 'dispatch;
	}
	pc = 0x82A5DAA0; continue 'dispatch;
            }
            0x82A5DAA0 => {
    //   block [0x82A5DAA0..0x82A5DAA4)
	// 82A5DAA0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x82A5DAA4; continue 'dispatch;
            }
            0x82A5DAA4 => {
    //   block [0x82A5DAA4..0x82A5DAB0)
	// 82A5DAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5DAA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5DAAC: 4824B9AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A5DAB0 size=244
    let mut pc: u32 = 0x82A5DAB0;
    'dispatch: loop {
        match pc {
            0x82A5DAB0 => {
    //   block [0x82A5DAB0..0x82A5DB64)
	// 82A5DAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5DAB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5DABC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5DAC4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A5DAC8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82A5DACC: 38C99484  addi r6, r9, -0x6b7c
	ctx.r[6].s64 = ctx.r[9].s64 + -27516;
	// 82A5DAD0: 39000024  li r8, 0x24
	ctx.r[8].s64 = 36;
	// 82A5DAD4: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DAD8: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82A5DADC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DAE0: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5DAE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5DAE8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A5DAEC: 7CA72050  subf r5, r7, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 82A5DAF0: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5DAF4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A5DAF8: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82A5DAFC: 7D0543D6  divw r8, r5, r8
	ctx.r[8].s32 = ctx.r[5].s32 / ctx.r[8].s32;
	// 82A5DB00: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A5DB04: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82A5DB08: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82A5DB0C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5DB10: 99610072  stb r11, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[11].u8 ) };
	// 82A5DB14: 99610071  stb r11, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 82A5DB18: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82A5DB1C: 99610073  stb r11, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[11].u8 ) };
	// 82A5DB20: 99610076  stb r11, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[11].u8 ) };
	// 82A5DB24: 99610075  stb r11, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[11].u8 ) };
	// 82A5DB28: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82A5DB2C: 99610077  stb r11, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[11].u8 ) };
	// 82A5DB30: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 82A5DB34: 40980030  bge cr6, 0x82a5db64
	if !ctx.cr[6].lt {
	pc = 0x82A5DB64; continue 'dispatch;
	}
	// 82A5DB38: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A5DB3C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A5DB40: 7CA85050  subf r5, r8, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82A5DB44: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A5DB48: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5DB4C: 4BB5D2D5  bl 0x825bae20
	ctx.lr = 0x82A5DB50;
	sub_825BAE20(ctx, base);
	// 82A5DB50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A5DB54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DB58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5DB5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5DB60: 4E800020  blr
	return;
            }
            0x82A5DB64 => {
    //   block [0x82A5DB64..0x82A5DB90)
	// 82A5DB64: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A5DB68: 40980028  bge cr6, 0x82a5db90
	if !ctx.cr[6].lt {
	pc = 0x82A5DB90; continue 'dispatch;
	}
	// 82A5DB6C: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5DB70: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A5DB74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5DB78: 7CAB3A14  add r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A5DB7C: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5DB80: 419A0010  beq cr6, 0x82a5db90
	if ctx.cr[6].eq {
	pc = 0x82A5DB90; continue 'dispatch;
	}
	// 82A5DB84: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A5DB88: 48001999  bl 0x82a5f520
	ctx.lr = 0x82A5DB8C;
	sub_82A5F520(ctx, base);
	// 82A5DB8C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82A5DB90; continue 'dispatch;
            }
            0x82A5DB90 => {
    //   block [0x82A5DB90..0x82A5DBA4)
	// 82A5DB90: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A5DB94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DB98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5DB9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5DBA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5DBA8 size=104
    let mut pc: u32 = 0x82A5DBA8;
    'dispatch: loop {
        match pc {
            0x82A5DBA8 => {
    //   block [0x82A5DBA8..0x82A5DC10)
	// 82A5DBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DBAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5DBB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5DBB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5DBB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DBBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5DBC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A5DBC4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A5DBC8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A5DBCC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DBD0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DBD4: 88DE0010  lbz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5DBD8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5DBDC: 7D251E70  srawi r5, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82A5DBE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5DBE4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A5DBE8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5DBEC: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5DBF0: 48001AD9  bl 0x82a5f6c8
	ctx.lr = 0x82A5DBF4;
	sub_82A5F6C8(ctx, base);
	// 82A5DBF4: 9BFE0011  stb r31, 0x11(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(17 as u32), ctx.r[31].u8 ) };
	// 82A5DBF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5DBFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DC00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5DC04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5DC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5DC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5DC10 size=316
    let mut pc: u32 = 0x82A5DC10;
    'dispatch: loop {
        match pc {
            0x82A5DC10 => {
    //   block [0x82A5DC10..0x82A5DC40)
	// 82A5DC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DC14: 4824B7ED  bl 0x82ca9400
	ctx.lr = 0x82A5DC18;
	sub_82CA93D0(ctx, base);
	// 82A5DC18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DC1C: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82A5DC20: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82A5DC24: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82A5DC28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5DC2C: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5DC30: 40990010  ble cr6, 0x82a5dc40
	if !ctx.cr[6].gt {
	pc = 0x82A5DC40; continue 'dispatch;
	}
	// 82A5DC34: 4BFE9895  bl 0x82a474c8
	ctx.lr = 0x82A5DC38;
	sub_82A474C8(ctx, base);
	// 82A5DC38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5DC3C: 4824B814  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5DC40 => {
    //   block [0x82A5DC40..0x82A5DC58)
	// 82A5DC40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5DC48: 419A0010  beq cr6, 0x82a5dc58
	if ctx.cr[6].eq {
	pc = 0x82A5DC58; continue 'dispatch;
	}
	// 82A5DC4C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5DC50: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5DC54: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82A5DC58; continue 'dispatch;
            }
            0x82A5DC58 => {
    //   block [0x82A5DC58..0x82A5DC9C)
	// 82A5DC58: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5DC5C: 409800E8  bge cr6, 0x82a5dd44
	if !ctx.cr[6].lt {
	pc = 0x82A5DD44; continue 'dispatch;
	}
	// 82A5DC60: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A5DC64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5DC68: 48052CF1  bl 0x82ab0958
	ctx.lr = 0x82A5DC6C;
	sub_82AB0958(ctx, base);
	// 82A5DC6C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DC70: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DC74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5DC78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5DC7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A5DC80: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A5DC84: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82A5DC88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A5DC8C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5DC90: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A5DC94: 419A0058  beq cr6, 0x82a5dcec
	if ctx.cr[6].eq {
	pc = 0x82A5DCEC; continue 'dispatch;
	}
	// 82A5DC98: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A5DC9C; continue 'dispatch;
            }
            0x82A5DC9C => {
    //   block [0x82A5DC9C..0x82A5DCC0)
	// 82A5DC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5DCA0: 419A003C  beq cr6, 0x82a5dcdc
	if ctx.cr[6].eq {
	pc = 0x82A5DCDC; continue 'dispatch;
	}
	// 82A5DCA4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5DCA8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A5DCAC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DCB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5DCB4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5DCB8: 419A0024  beq cr6, 0x82a5dcdc
	if ctx.cr[6].eq {
	pc = 0x82A5DCDC; continue 'dispatch;
	}
	// 82A5DCBC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	pc = 0x82A5DCC0; continue 'dispatch;
            }
            0x82A5DCC0 => {
    //   block [0x82A5DCC0..0x82A5DCDC)
	// 82A5DCC0: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A5DCC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5DCC8: 7CE04828  lwarx r7, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82A5DCCC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82A5DCD0: 7CE0492D  stwcx. r7, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5DCD4: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5DCD8: 4082FFE8  bne 0x82a5dcc0
	if !ctx.cr[0].eq {
	pc = 0x82A5DCC0; continue 'dispatch;
	}
	pc = 0x82A5DCDC; continue 'dispatch;
            }
            0x82A5DCDC => {
    //   block [0x82A5DCDC..0x82A5DCEC)
	// 82A5DCDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A5DCE0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A5DCE4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A5DCE8: 409AFFB4  bne cr6, 0x82a5dc9c
	if !ctx.cr[6].eq {
	pc = 0x82A5DC9C; continue 'dispatch;
	}
	pc = 0x82A5DCEC; continue 'dispatch;
            }
            0x82A5DCEC => {
    //   block [0x82A5DCEC..0x82A5DD0C)
	// 82A5DCEC: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DCF0: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DCF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A5DCF8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A5DCFC: 7D7B1E70  srawi r27, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5DD00: 419A0028  beq cr6, 0x82a5dd28
	if ctx.cr[6].eq {
	pc = 0x82A5DD28; continue 'dispatch;
	}
	// 82A5DD04: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5DD08: 419A0018  beq cr6, 0x82a5dd20
	if ctx.cr[6].eq {
	pc = 0x82A5DD20; continue 'dispatch;
	}
	pc = 0x82A5DD0C; continue 'dispatch;
            }
            0x82A5DD0C => {
    //   block [0x82A5DD0C..0x82A5DD20)
	// 82A5DD0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5DD10: 4B74EDA9  bl 0x821acab8
	ctx.lr = 0x82A5DD14;
	sub_821ACAB8(ctx, base);
	// 82A5DD14: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A5DD18: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5DD1C: 409AFFF0  bne cr6, 0x82a5dd0c
	if !ctx.cr[6].eq {
	pc = 0x82A5DD0C; continue 'dispatch;
	}
	pc = 0x82A5DD20; continue 'dispatch;
            }
            0x82A5DD20 => {
    //   block [0x82A5DD20..0x82A5DD28)
	// 82A5DD20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DD24: 4B7BE015  bl 0x8221bd38
	ctx.lr = 0x82A5DD28;
	sub_8221BD38(ctx, base);
	pc = 0x82A5DD28; continue 'dispatch;
            }
            0x82A5DD28 => {
    //   block [0x82A5DD28..0x82A5DD44)
	// 82A5DD28: 574A1838  slwi r10, r26, 3
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5DD2C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A5DD30: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5DD34: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82A5DD38: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A5DD3C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82A5DD40: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82A5DD44; continue 'dispatch;
            }
            0x82A5DD44 => {
    //   block [0x82A5DD44..0x82A5DD4C)
	// 82A5DD44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5DD48: 4824B708  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5DD50 size=196
    let mut pc: u32 = 0x82A5DD50;
    'dispatch: loop {
        match pc {
            0x82A5DD50 => {
    //   block [0x82A5DD50..0x82A5DD74)
	// 82A5DD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5DD58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DD5C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DD60: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A5DD64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5DD68: 409A000C  bne cr6, 0x82a5dd74
	if !ctx.cr[6].eq {
	pc = 0x82A5DD74; continue 'dispatch;
	}
	// 82A5DD6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5DD70: 48000010  b 0x82a5dd80
	pc = 0x82A5DD80; continue 'dispatch;
            }
            0x82A5DD74 => {
    //   block [0x82A5DD74..0x82A5DD80)
	// 82A5DD74: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5DD78: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5DD7C: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82A5DD80; continue 'dispatch;
            }
            0x82A5DD80 => {
    //   block [0x82A5DD80..0x82A5DDB8)
	// 82A5DD80: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DD84: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A5DD88: 7D481E70  srawi r8, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A5DD8C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5DD90: 4098005C  bge cr6, 0x82a5ddec
	if !ctx.cr[6].lt {
	pc = 0x82A5DDEC; continue 'dispatch;
	}
	// 82A5DD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5DD98: 419A003C  beq cr6, 0x82a5ddd4
	if ctx.cr[6].eq {
	pc = 0x82A5DDD4; continue 'dispatch;
	}
	// 82A5DD9C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5DDA0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5DDA4: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DDA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5DDAC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A5DDB0: 419A0024  beq cr6, 0x82a5ddd4
	if ctx.cr[6].eq {
	pc = 0x82A5DDD4; continue 'dispatch;
	}
	// 82A5DDB4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82A5DDB8; continue 'dispatch;
            }
            0x82A5DDB8 => {
    //   block [0x82A5DDB8..0x82A5DDD4)
	// 82A5DDB8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A5DDBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5DDC0: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A5DDC4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A5DDC8: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5DDCC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5DDD0: 4082FFE8  bne 0x82a5ddb8
	if !ctx.cr[0].eq {
	pc = 0x82A5DDB8; continue 'dispatch;
	}
	pc = 0x82A5DDD4; continue 'dispatch;
            }
            0x82A5DDD4 => {
    //   block [0x82A5DDD4..0x82A5DDEC)
	// 82A5DDD4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A5DDD8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5DDDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A5DDE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DDE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5DDE8: 4E800020  blr
	return;
            }
            0x82A5DDEC => {
    //   block [0x82A5DDEC..0x82A5DE14)
	// 82A5DDEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5DDF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5DDF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5DDF8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A5DDFC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5DE00: 48000C99  bl 0x82a5ea98
	ctx.lr = 0x82A5DE04;
	sub_82A5EA98(ctx, base);
	// 82A5DE04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A5DE08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DE0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5DE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5DE18 size=136
    let mut pc: u32 = 0x82A5DE18;
    'dispatch: loop {
        match pc {
            0x82A5DE18 => {
    //   block [0x82A5DE18..0x82A5DE58)
	// 82A5DE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DE1C: 4824B5E9  bl 0x82ca9404
	ctx.lr = 0x82A5DE20;
	sub_82CA93D0(ctx, base);
	// 82A5DE20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DE24: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5DE28: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DE2C: 83FB0008  lwz r31, 8(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DE30: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5DE34: 419A0064  beq cr6, 0x82a5de98
	if ctx.cr[6].eq {
	pc = 0x82A5DE98; continue 'dispatch;
	}
	// 82A5DE38: 7D5FF850  subf r10, r31, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[31].s64;
	// 82A5DE3C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A5DE40: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A5DE44: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5DE48: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5DE4C: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A5DE50: 419A0020  beq cr6, 0x82a5de70
	if ctx.cr[6].eq {
	pc = 0x82A5DE70; continue 'dispatch;
	}
	// 82A5DE54: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82A5DE58; continue 'dispatch;
            }
            0x82A5DE58 => {
    //   block [0x82A5DE58..0x82A5DE70)
	// 82A5DE58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5DE5C: 7C7DF214  add r3, r29, r30
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82A5DE60: 48001A31  bl 0x82a5f890
	ctx.lr = 0x82A5DE64;
	sub_82A5F890(ctx, base);
	// 82A5DE64: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A5DE68: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5DE6C: 409AFFEC  bne cr6, 0x82a5de58
	if !ctx.cr[6].eq {
	pc = 0x82A5DE58; continue 'dispatch;
	}
	pc = 0x82A5DE70; continue 'dispatch;
            }
            0x82A5DE70 => {
    //   block [0x82A5DE70..0x82A5DE80)
	// 82A5DE70: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5DE74: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A5DE78: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5DE7C: 419A0018  beq cr6, 0x82a5de94
	if ctx.cr[6].eq {
	pc = 0x82A5DE94; continue 'dispatch;
	}
	pc = 0x82A5DE80; continue 'dispatch;
            }
            0x82A5DE80 => {
    //   block [0x82A5DE80..0x82A5DE94)
	// 82A5DE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5DE84: 4B74EC35  bl 0x821acab8
	ctx.lr = 0x82A5DE88;
	sub_821ACAB8(ctx, base);
	// 82A5DE88: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5DE8C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5DE90: 409AFFF0  bne cr6, 0x82a5de80
	if !ctx.cr[6].eq {
	pc = 0x82A5DE80; continue 'dispatch;
	}
	pc = 0x82A5DE94; continue 'dispatch;
            }
            0x82A5DE94 => {
    //   block [0x82A5DE94..0x82A5DE98)
	// 82A5DE94: 939B0008  stw r28, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82A5DE98; continue 'dispatch;
            }
            0x82A5DE98 => {
    //   block [0x82A5DE98..0x82A5DEA0)
	// 82A5DE98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5DE9C: 4824B5B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5DEA0 size=244
    let mut pc: u32 = 0x82A5DEA0;
    'dispatch: loop {
        match pc {
            0x82A5DEA0 => {
    //   block [0x82A5DEA0..0x82A5DEE4)
	// 82A5DEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DEA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5DEA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5DEAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5DEB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DEB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5DEB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5DEBC: 3BEBFB48  addi r31, r11, -0x4b8
	ctx.r[31].s64 = ctx.r[11].s64 + -1208;
	// 82A5DEC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5DEC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5DEC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5DECC: 480008E5  bl 0x82a5e7b0
	ctx.lr = 0x82A5DED0;
	sub_82A5E7B0(ctx, base);
	// 82A5DED0: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A5DED4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5DED8: 419A000C  beq cr6, 0x82a5dee4
	if ctx.cr[6].eq {
	pc = 0x82A5DEE4; continue 'dispatch;
	}
	// 82A5DEDC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5DEE0: 419A0008  beq cr6, 0x82a5dee8
	if ctx.cr[6].eq {
	pc = 0x82A5DEE8; continue 'dispatch;
	}
	pc = 0x82A5DEE4; continue 'dispatch;
            }
            0x82A5DEE4 => {
    //   block [0x82A5DEE4..0x82A5DEE8)
	// 82A5DEE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5DEE8; continue 'dispatch;
            }
            0x82A5DEE8 => {
    //   block [0x82A5DEE8..0x82A5DF10)
	// 82A5DEE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DEEC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5DEF0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5DEF4: 419A0028  beq cr6, 0x82a5df1c
	if ctx.cr[6].eq {
	pc = 0x82A5DF1C; continue 'dispatch;
	}
	// 82A5DEF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5DEFC: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5DF00: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A5DF04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5DF08: 41980008  blt cr6, 0x82a5df10
	if ctx.cr[6].lt {
	pc = 0x82A5DF10; continue 'dispatch;
	}
	// 82A5DF0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A5DF10; continue 'dispatch;
            }
            0x82A5DF10 => {
    //   block [0x82A5DF10..0x82A5DF1C)
	// 82A5DF10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5DF14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5DF18: 419A0044  beq cr6, 0x82a5df5c
	if ctx.cr[6].eq {
	pc = 0x82A5DF5C; continue 'dispatch;
	}
	pc = 0x82A5DF1C; continue 'dispatch;
            }
            0x82A5DF1C => {
    //   block [0x82A5DF1C..0x82A5DF5C)
	// 82A5DF1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5DF20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5DF24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5DF28: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5DF2C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A5DF30: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A5DF34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A5DF38: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A5DF3C: 480005D5  bl 0x82a5e510
	ctx.lr = 0x82A5DF40;
	sub_82A5E510(ctx, base);
	// 82A5DF40: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A5DF44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5DF48: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82A5DF4C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A5DF50: 4B74EB69  bl 0x821acab8
	ctx.lr = 0x82A5DF54;
	sub_821ACAB8(ctx, base);
	// 82A5DF54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5DF58: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A5DF5C; continue 'dispatch;
            }
            0x82A5DF5C => {
    //   block [0x82A5DF5C..0x82A5DF68)
	// 82A5DF5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5DF60: 409A0008  bne cr6, 0x82a5df68
	if !ctx.cr[6].eq {
	pc = 0x82A5DF68; continue 'dispatch;
	}
	// 82A5DF64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5DF68; continue 'dispatch;
            }
            0x82A5DF68 => {
    //   block [0x82A5DF68..0x82A5DF78)
	// 82A5DF68: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DF6C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5DF70: 409A0008  bne cr6, 0x82a5df78
	if !ctx.cr[6].eq {
	pc = 0x82A5DF78; continue 'dispatch;
	}
	// 82A5DF74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5DF78; continue 'dispatch;
            }
            0x82A5DF78 => {
    //   block [0x82A5DF78..0x82A5DF94)
	// 82A5DF78: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 82A5DF7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5DF80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DF84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5DF88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5DF8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5DF90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5DF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5DF98 size=112
    let mut pc: u32 = 0x82A5DF98;
    'dispatch: loop {
        match pc {
            0x82A5DF98 => {
    //   block [0x82A5DF98..0x82A5E008)
	// 82A5DF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5DF9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5DFA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5DFA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5DFA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5DFAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5DFB0: 3BEBFB48  addi r31, r11, -0x4b8
	ctx.r[31].s64 = ctx.r[11].s64 + -1208;
	// 82A5DFB4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A5DFB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5DFBC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A5DFC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DFC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5DFC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5DFCC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5DFD0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A5DFD4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5DFD8: 48000EA9  bl 0x82a5ee80
	ctx.lr = 0x82A5DFDC;
	sub_82A5EE80(ctx, base);
	// 82A5DFDC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5DFE0: 4B7BDD59  bl 0x8221bd38
	ctx.lr = 0x82A5DFE4;
	sub_8221BD38(ctx, base);
	// 82A5DFE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5DFE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5DFEC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5DFF0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5DFF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5DFF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5DFFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5E000: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5E004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5E008 size=1072
    let mut pc: u32 = 0x82A5E008;
    'dispatch: loop {
        match pc {
            0x82A5E008 => {
    //   block [0x82A5E008..0x82A5E070)
	// 82A5E008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5E00C: 4824B3F1  bl 0x82ca93fc
	ctx.lr = 0x82A5E010;
	sub_82CA93D0(ctx, base);
	// 82A5E010: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5E014: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82A5E018: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A5E01C: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A5E020: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E028: 419A0048  beq cr6, 0x82a5e070
	if ctx.cr[6].eq {
	pc = 0x82A5E070; continue 'dispatch;
	}
	// 82A5E02C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A5E030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5E034: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82A5E038: 4B893F09  bl 0x822f1f40
	ctx.lr = 0x82A5E03C;
	sub_822F1F40(ctx, base);
	// 82A5E03C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5E040: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5E044: 4B893D6D  bl 0x822f1db0
	ctx.lr = 0x82A5E048;
	sub_822F1DB0(ctx, base);
	// 82A5E048: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A5E04C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5E050: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82A5E054: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A5E058: 4B893DC9  bl 0x822f1e20
	ctx.lr = 0x82A5E05C;
	sub_822F1E20(ctx, base);
	// 82A5E05C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A5E060: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5E064: 4BC1D77D  bl 0x8267b7e0
	ctx.lr = 0x82A5E068;
	sub_8267B7E0(ctx, base);
	// 82A5E068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5E06C: 4B7137A5  bl 0x82171810
	ctx.lr = 0x82A5E070;
	sub_82171810(ctx, base);
	pc = 0x82A5E070; continue 'dispatch;
            }
            0x82A5E070 => {
    //   block [0x82A5E070..0x82A5E094)
	// 82A5E070: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A5E074: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82A5E078: 4BAF87E1  bl 0x82556858
	ctx.lr = 0x82A5E07C;
	sub_82556858(ctx, base);
	// 82A5E07C: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E080: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E088: 419A000C  beq cr6, 0x82a5e094
	if ctx.cr[6].eq {
	pc = 0x82A5E094; continue 'dispatch;
	}
	// 82A5E08C: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E090: 4800002C  b 0x82a5e0bc
	pc = 0x82A5E0BC; continue 'dispatch;
            }
            0x82A5E094 => {
    //   block [0x82A5E094..0x82A5E0AC)
	// 82A5E094: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E098: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E09C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5E0A0: 419A000C  beq cr6, 0x82a5e0ac
	if ctx.cr[6].eq {
	pc = 0x82A5E0AC; continue 'dispatch;
	}
	// 82A5E0A4: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82A5E0A8: 48000014  b 0x82a5e0bc
	pc = 0x82A5E0BC; continue 'dispatch;
            }
            0x82A5E0AC => {
    //   block [0x82A5E0AC..0x82A5E0BC)
	// 82A5E0AC: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A5E0B0: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E0B4: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E0B8: 409A00FC  bne cr6, 0x82a5e1b4
	if !ctx.cr[6].eq {
	pc = 0x82A5E1B4; continue 'dispatch;
	}
	pc = 0x82A5E0BC; continue 'dispatch;
            }
            0x82A5E0BC => {
    //   block [0x82A5E0BC..0x82A5E0D0)
	// 82A5E0BC: 897B0015  lbz r11, 0x15(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E0C0: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E0C8: 409A0008  bne cr6, 0x82a5e0d0
	if !ctx.cr[6].eq {
	pc = 0x82A5E0D0; continue 'dispatch;
	}
	// 82A5E0CC: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A5E0D0; continue 'dispatch;
            }
            0x82A5E0D0 => {
    //   block [0x82A5E0D0..0x82A5E0F0)
	// 82A5E0D0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5E0D4: 3B8BFB48  addi r28, r11, -0x4b8
	ctx.r[28].s64 = ctx.r[11].s64 + -1208;
	// 82A5E0D8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E0DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E0E0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E0E4: 409A000C  bne cr6, 0x82a5e0f0
	if !ctx.cr[6].eq {
	pc = 0x82A5E0F0; continue 'dispatch;
	}
	// 82A5E0E8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A5E0EC: 4800001C  b 0x82a5e108
	pc = 0x82A5E108; continue 'dispatch;
            }
            0x82A5E0F0 => {
    //   block [0x82A5E0F0..0x82A5E104)
	// 82A5E0F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E0F4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E0F8: 409A000C  bne cr6, 0x82a5e104
	if !ctx.cr[6].eq {
	pc = 0x82A5E104; continue 'dispatch;
	}
	// 82A5E0FC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5E100: 48000008  b 0x82a5e108
	pc = 0x82A5E108; continue 'dispatch;
            }
            0x82A5E104 => {
    //   block [0x82A5E104..0x82A5E108)
	// 82A5E104: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A5E108; continue 'dispatch;
            }
            0x82A5E108 => {
    //   block [0x82A5E108..0x82A5E12C)
	// 82A5E108: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E10C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E110: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E114: 409A0048  bne cr6, 0x82a5e15c
	if !ctx.cr[6].eq {
	pc = 0x82A5E15C; continue 'dispatch;
	}
	// 82A5E118: 897B0015  lbz r11, 0x15(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E11C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E120: 419A000C  beq cr6, 0x82a5e12c
	if ctx.cr[6].eq {
	pc = 0x82A5E12C; continue 'dispatch;
	}
	// 82A5E124: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A5E128: 4800002C  b 0x82a5e154
	pc = 0x82A5E154; continue 'dispatch;
            }
            0x82A5E12C => {
    //   block [0x82A5E12C..0x82A5E140)
	// 82A5E12C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E130: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A5E134: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E138: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5E13C: 409A0018  bne cr6, 0x82a5e154
	if !ctx.cr[6].eq {
	pc = 0x82A5E154; continue 'dispatch;
	}
	pc = 0x82A5E140; continue 'dispatch;
            }
            0x82A5E140 => {
    //   block [0x82A5E140..0x82A5E154)
	// 82A5E140: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A5E144: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E148: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E14C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5E150: 419AFFF0  beq cr6, 0x82a5e140
	if ctx.cr[6].eq {
	pc = 0x82A5E140; continue 'dispatch;
	}
	pc = 0x82A5E154; continue 'dispatch;
            }
            0x82A5E154 => {
    //   block [0x82A5E154..0x82A5E15C)
	// 82A5E154: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E158: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A5E15C; continue 'dispatch;
            }
            0x82A5E15C => {
    //   block [0x82A5E15C..0x82A5E184)
	// 82A5E15C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E160: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E164: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E168: 409A00E8  bne cr6, 0x82a5e250
	if !ctx.cr[6].eq {
	pc = 0x82A5E250; continue 'dispatch;
	}
	// 82A5E16C: 897B0015  lbz r11, 0x15(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E174: 419A0010  beq cr6, 0x82a5e184
	if ctx.cr[6].eq {
	pc = 0x82A5E184; continue 'dispatch;
	}
	// 82A5E178: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A5E17C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5E180: 480000D0  b 0x82a5e250
	pc = 0x82A5E250; continue 'dispatch;
            }
            0x82A5E184 => {
    //   block [0x82A5E184..0x82A5E198)
	// 82A5E184: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E188: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A5E18C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E190: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5E194: 409A0018  bne cr6, 0x82a5e1ac
	if !ctx.cr[6].eq {
	pc = 0x82A5E1AC; continue 'dispatch;
	}
	pc = 0x82A5E198; continue 'dispatch;
            }
            0x82A5E198 => {
    //   block [0x82A5E198..0x82A5E1AC)
	// 82A5E198: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A5E19C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E1A0: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E1A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A5E1A8: 419AFFF0  beq cr6, 0x82a5e198
	if ctx.cr[6].eq {
	pc = 0x82A5E198; continue 'dispatch;
	}
	pc = 0x82A5E1AC; continue 'dispatch;
            }
            0x82A5E1AC => {
    //   block [0x82A5E1AC..0x82A5E1B4)
	// 82A5E1AC: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5E1B0: 480000A0  b 0x82a5e250
	pc = 0x82A5E250; continue 'dispatch;
            }
            0x82A5E1B4 => {
    //   block [0x82A5E1B4..0x82A5E1D4)
	// 82A5E1B4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E1B8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E1BC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5E1C0: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E1C4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5E1C8: 409A000C  bne cr6, 0x82a5e1d4
	if !ctx.cr[6].eq {
	pc = 0x82A5E1D4; continue 'dispatch;
	}
	// 82A5E1CC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A5E1D0: 4800002C  b 0x82a5e1fc
	pc = 0x82A5E1FC; continue 'dispatch;
            }
            0x82A5E1D4 => {
    //   block [0x82A5E1D4..0x82A5E1E8)
	// 82A5E1D4: 895B0015  lbz r10, 0x15(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E1D8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E1DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E1E0: 409A0008  bne cr6, 0x82a5e1e8
	if !ctx.cr[6].eq {
	pc = 0x82A5E1E8; continue 'dispatch;
	}
	// 82A5E1E4: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A5E1E8; continue 'dispatch;
            }
            0x82A5E1E8 => {
    //   block [0x82A5E1E8..0x82A5E1FC)
	// 82A5E1E8: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5E1EC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E1F0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5E1F4: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E1F8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5E1FC; continue 'dispatch;
            }
            0x82A5E1FC => {
    //   block [0x82A5E1FC..0x82A5E21C)
	// 82A5E1FC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A5E200: 3B8AFB48  addi r28, r10, -0x4b8
	ctx.r[28].s64 = ctx.r[10].s64 + -1208;
	// 82A5E204: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E208: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E20C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E210: 409A000C  bne cr6, 0x82a5e21c
	if !ctx.cr[6].eq {
	pc = 0x82A5E21C; continue 'dispatch;
	}
	// 82A5E214: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E218: 48000020  b 0x82a5e238
	pc = 0x82A5E238; continue 'dispatch;
            }
            0x82A5E21C => {
    //   block [0x82A5E21C..0x82A5E234)
	// 82A5E21C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E220: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E224: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5E228: 409A000C  bne cr6, 0x82a5e234
	if !ctx.cr[6].eq {
	pc = 0x82A5E234; continue 'dispatch;
	}
	// 82A5E22C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5E230: 48000008  b 0x82a5e238
	pc = 0x82A5E238; continue 'dispatch;
            }
            0x82A5E234 => {
    //   block [0x82A5E234..0x82A5E238)
	// 82A5E234: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5E238; continue 'dispatch;
            }
            0x82A5E238 => {
    //   block [0x82A5E238..0x82A5E250)
	// 82A5E238: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E23C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A5E240: 893A0014  lbz r9, 0x14(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E244: 890B0014  lbz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E248: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 82A5E24C: 991A0014  stb r8, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	pc = 0x82A5E250; continue 'dispatch;
            }
            0x82A5E250 => {
    //   block [0x82A5E250..0x82A5E274)
	// 82A5E250: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E254: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A5E258: 409A0198  bne cr6, 0x82a5e3f0
	if !ctx.cr[6].eq {
	pc = 0x82A5E3F0; continue 'dispatch;
	}
	// 82A5E25C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E260: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A5E264: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E268: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5E26C: 419A0180  beq cr6, 0x82a5e3ec
	if ctx.cr[6].eq {
	pc = 0x82A5E3EC; continue 'dispatch;
	}
	// 82A5E270: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82A5E274; continue 'dispatch;
            }
            0x82A5E274 => {
    //   block [0x82A5E274..0x82A5E2B4)
	// 82A5E274: 897B0014  lbz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E278: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A5E27C: 409A0170  bne cr6, 0x82a5e3ec
	if !ctx.cr[6].eq {
	pc = 0x82A5E3EC; continue 'dispatch;
	}
	// 82A5E280: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E284: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5E288: 409A00A8  bne cr6, 0x82a5e330
	if !ctx.cr[6].eq {
	pc = 0x82A5E330; continue 'dispatch;
	}
	// 82A5E28C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E290: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E294: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E298: 409A001C  bne cr6, 0x82a5e2b4
	if !ctx.cr[6].eq {
	pc = 0x82A5E2B4; continue 'dispatch;
	}
	// 82A5E29C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E2A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5E2A4: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A5E2A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E2AC: 4800056D  bl 0x82a5e818
	ctx.lr = 0x82A5E2B0;
	sub_82A5E818(ctx, base);
	// 82A5E2B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5E2B4; continue 'dispatch;
            }
            0x82A5E2B4 => {
    //   block [0x82A5E2B4..0x82A5E2E0)
	// 82A5E2B4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E2B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E2BC: 409A00C8  bne cr6, 0x82a5e384
	if !ctx.cr[6].eq {
	pc = 0x82A5E384; continue 'dispatch;
	}
	// 82A5E2C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E2C4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E2C8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A5E2CC: 409A0014  bne cr6, 0x82a5e2e0
	if !ctx.cr[6].eq {
	pc = 0x82A5E2E0; continue 'dispatch;
	}
	// 82A5E2D0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E2D4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E2D8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A5E2DC: 419A00A4  beq cr6, 0x82a5e380
	if ctx.cr[6].eq {
	pc = 0x82A5E380; continue 'dispatch;
	}
	pc = 0x82A5E2E0; continue 'dispatch;
            }
            0x82A5E2E0 => {
    //   block [0x82A5E2E0..0x82A5E30C)
	// 82A5E2E0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E2E4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E2E8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A5E2EC: 409A0020  bne cr6, 0x82a5e30c
	if !ctx.cr[6].eq {
	pc = 0x82A5E30C; continue 'dispatch;
	}
	// 82A5E2F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E2F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5E2F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A5E2FC: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E300: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A5E304: 48000595  bl 0x82a5e898
	ctx.lr = 0x82A5E308;
	sub_82A5E898(ctx, base);
	// 82A5E308: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5E30C; continue 'dispatch;
            }
            0x82A5E30C => {
    //   block [0x82A5E30C..0x82A5E330)
	// 82A5E30C: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E310: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5E314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E318: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82A5E31C: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E320: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E324: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E328: 480004F1  bl 0x82a5e818
	ctx.lr = 0x82A5E32C;
	sub_82A5E818(ctx, base);
	// 82A5E32C: 480000C0  b 0x82a5e3ec
	pc = 0x82A5E3EC; continue 'dispatch;
            }
            0x82A5E330 => {
    //   block [0x82A5E330..0x82A5E354)
	// 82A5E330: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E338: 409A001C  bne cr6, 0x82a5e354
	if !ctx.cr[6].eq {
	pc = 0x82A5E354; continue 'dispatch;
	}
	// 82A5E33C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E340: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5E344: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A5E348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E34C: 4800054D  bl 0x82a5e898
	ctx.lr = 0x82A5E350;
	sub_82A5E898(ctx, base);
	// 82A5E350: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5E354; continue 'dispatch;
            }
            0x82A5E354 => {
    //   block [0x82A5E354..0x82A5E380)
	// 82A5E354: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E35C: 409A0028  bne cr6, 0x82a5e384
	if !ctx.cr[6].eq {
	pc = 0x82A5E384; continue 'dispatch;
	}
	// 82A5E360: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E364: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E368: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A5E36C: 409A0034  bne cr6, 0x82a5e3a0
	if !ctx.cr[6].eq {
	pc = 0x82A5E3A0; continue 'dispatch;
	}
	// 82A5E370: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E374: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E378: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A5E37C: 409A0024  bne cr6, 0x82a5e3a0
	if !ctx.cr[6].eq {
	pc = 0x82A5E3A0; continue 'dispatch;
	}
	pc = 0x82A5E380; continue 'dispatch;
            }
            0x82A5E380 => {
    //   block [0x82A5E380..0x82A5E384)
	// 82A5E380: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	pc = 0x82A5E384; continue 'dispatch;
            }
            0x82A5E384 => {
    //   block [0x82A5E384..0x82A5E3A0)
	// 82A5E384: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E388: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82A5E38C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E390: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E394: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5E398: 409AFEDC  bne cr6, 0x82a5e274
	if !ctx.cr[6].eq {
	pc = 0x82A5E274; continue 'dispatch;
	}
	// 82A5E39C: 48000050  b 0x82a5e3ec
	pc = 0x82A5E3EC; continue 'dispatch;
            }
            0x82A5E3A0 => {
    //   block [0x82A5E3A0..0x82A5E3CC)
	// 82A5E3A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E3A4: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E3A8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A5E3AC: 409A0020  bne cr6, 0x82a5e3cc
	if !ctx.cr[6].eq {
	pc = 0x82A5E3CC; continue 'dispatch;
	}
	// 82A5E3B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E3B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5E3B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A5E3BC: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E3C0: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82A5E3C4: 48000455  bl 0x82a5e818
	ctx.lr = 0x82A5E3C8;
	sub_82A5E818(ctx, base);
	// 82A5E3C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5E3CC; continue 'dispatch;
            }
            0x82A5E3CC => {
    //   block [0x82A5E3CC..0x82A5E3EC)
	// 82A5E3CC: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5E3D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5E3D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E3D8: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82A5E3DC: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E3E0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E3E4: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5E3E8: 480004B1  bl 0x82a5e898
	ctx.lr = 0x82A5E3EC;
	sub_82A5E898(ctx, base);
	pc = 0x82A5E3EC; continue 'dispatch;
            }
            0x82A5E3EC => {
    //   block [0x82A5E3EC..0x82A5E3F0)
	// 82A5E3EC: 9BBB0014  stb r29, 0x14(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	pc = 0x82A5E3F0; continue 'dispatch;
            }
            0x82A5E3F0 => {
    //   block [0x82A5E3F0..0x82A5E428)
	// 82A5E3F0: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 82A5E3F4: 4B74E6C5  bl 0x821acab8
	ctx.lr = 0x82A5E3F8;
	sub_821ACAB8(ctx, base);
	// 82A5E3F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A5E3FC: 4B7BD93D  bl 0x8221bd38
	ctx.lr = 0x82A5E400;
	sub_8221BD38(ctx, base);
	// 82A5E400: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E404: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A5E408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E40C: 419A001C  beq cr6, 0x82a5e428
	if ctx.cr[6].eq {
	pc = 0x82A5E428; continue 'dispatch;
	}
	// 82A5E410: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A5E414: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5E418: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5E41C: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A5E420: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A5E424: 4824B028  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5E428 => {
    //   block [0x82A5E428..0x82A5E438)
	// 82A5E428: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A5E42C: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A5E430: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A5E434: 4824B018  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5E438 size=108
    let mut pc: u32 = 0x82A5E438;
    'dispatch: loop {
        match pc {
            0x82A5E438 => {
    //   block [0x82A5E438..0x82A5E468)
	// 82A5E438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5E43C: 4824AFD1  bl 0x82ca940c
	ctx.lr = 0x82A5E440;
	sub_82CA93D0(ctx, base);
	// 82A5E440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5E444: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5E448: 3BEBFB60  addi r31, r11, -0x4a0
	ctx.r[31].s64 = ctx.r[11].s64 + -1184;
	// 82A5E44C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5E454: 419A0030  beq cr6, 0x82a5e484
	if ctx.cr[6].eq {
	pc = 0x82A5E484; continue 'dispatch;
	}
	// 82A5E458: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E45C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5E460: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5E464: 419A001C  beq cr6, 0x82a5e480
	if ctx.cr[6].eq {
	pc = 0x82A5E480; continue 'dispatch;
	}
	pc = 0x82A5E468; continue 'dispatch;
            }
            0x82A5E468 => {
    //   block [0x82A5E468..0x82A5E480)
	// 82A5E468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E46C: 4BFFDFBD  bl 0x82a5c428
	ctx.lr = 0x82A5E470;
	sub_82A5C428(ctx, base);
	// 82A5E470: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A5E474: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5E478: 409AFFF0  bne cr6, 0x82a5e468
	if !ctx.cr[6].eq {
	pc = 0x82A5E468; continue 'dispatch;
	}
	// 82A5E47C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5E480; continue 'dispatch;
            }
            0x82A5E480 => {
    //   block [0x82A5E480..0x82A5E484)
	// 82A5E480: 4B7BD8B9  bl 0x8221bd38
	ctx.lr = 0x82A5E484;
	sub_8221BD38(ctx, base);
	pc = 0x82A5E484; continue 'dispatch;
            }
            0x82A5E484 => {
    //   block [0x82A5E484..0x82A5E4A4)
	// 82A5E484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5E488: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5E48C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5E490: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E494: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5E498: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A5E49C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5E4A0: 4824AFBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5E4A8 size=100
    let mut pc: u32 = 0x82A5E4A8;
    'dispatch: loop {
        match pc {
            0x82A5E4A8 => {
    //   block [0x82A5E4A8..0x82A5E4B8)
	// 82A5E4A8: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82A5E4AC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A5E4B0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A5E4B4: 419A004C  beq cr6, 0x82a5e500
	if ctx.cr[6].eq {
	pc = 0x82A5E500; continue 'dispatch;
	}
	pc = 0x82A5E4B8; continue 'dispatch;
            }
            0x82A5E4B8 => {
    //   block [0x82A5E4B8..0x82A5E4DC)
	// 82A5E4B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E4BC: 419A003C  beq cr6, 0x82a5e4f8
	if ctx.cr[6].eq {
	pc = 0x82A5E4F8; continue 'dispatch;
	}
	// 82A5E4C0: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E4C4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5E4C8: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E4CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E4D0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A5E4D4: 419A0024  beq cr6, 0x82a5e4f8
	if ctx.cr[6].eq {
	pc = 0x82A5E4F8; continue 'dispatch;
	}
	// 82A5E4D8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82A5E4DC; continue 'dispatch;
            }
            0x82A5E4DC => {
    //   block [0x82A5E4DC..0x82A5E4F8)
	// 82A5E4DC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A5E4E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5E4E4: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A5E4E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A5E4EC: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5E4F0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5E4F4: 4082FFE8  bne 0x82a5e4dc
	if !ctx.cr[0].eq {
	pc = 0x82A5E4DC; continue 'dispatch;
	}
	pc = 0x82A5E4F8; continue 'dispatch;
            }
            0x82A5E4F8 => {
    //   block [0x82A5E4F8..0x82A5E500)
	// 82A5E4F8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A5E4FC: 4200FFBC  bdnz 0x82a5e4b8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A5E4B8; continue 'dispatch;
	}
	pc = 0x82A5E500; continue 'dispatch;
            }
            0x82A5E500 => {
    //   block [0x82A5E500..0x82A5E50C)
	// 82A5E500: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5E504: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A5E508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5E510 size=668
    let mut pc: u32 = 0x82A5E510;
    'dispatch: loop {
        match pc {
            0x82A5E510 => {
    //   block [0x82A5E510..0x82A5E56C)
	// 82A5E510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5E514: 4824AEE9  bl 0x82ca93fc
	ctx.lr = 0x82A5E518;
	sub_82CA93D0(ctx, base);
	// 82A5E518: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5E51C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5E520: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A5E524: 3BEBFB48  addi r31, r11, -0x4b8
	ctx.r[31].s64 = ctx.r[11].s64 + -1208;
	// 82A5E528: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A5E52C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82A5E530: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5E534: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82A5E538: FB4100D0  std r26, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u64 ) };
	// 82A5E53C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A5E540: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E548: 409A0024  bne cr6, 0x82a5e56c
	if !ctx.cr[6].eq {
	pc = 0x82A5E56C; continue 'dispatch;
	}
	// 82A5E54C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E550: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E554: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A5E558: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5E55C: 48000A6D  bl 0x82a5efc8
	ctx.lr = 0x82A5E560;
	sub_82A5EFC8(ctx, base);
	// 82A5E560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E564: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5E568: 4824AEE4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5E56C => {
    //   block [0x82A5E56C..0x82A5E588)
	// 82A5E56C: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E570: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A5E574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E578: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E57C: 419A000C  beq cr6, 0x82a5e588
	if ctx.cr[6].eq {
	pc = 0x82A5E588; continue 'dispatch;
	}
	// 82A5E580: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5E584: 419A0008  beq cr6, 0x82a5e58c
	if ctx.cr[6].eq {
	pc = 0x82A5E58C; continue 'dispatch;
	}
	pc = 0x82A5E588; continue 'dispatch;
            }
            0x82A5E588 => {
    //   block [0x82A5E588..0x82A5E58C)
	// 82A5E588: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5E58C; continue 'dispatch;
            }
            0x82A5E58C => {
    //   block [0x82A5E58C..0x82A5E5B0)
	// 82A5E58C: 836100D4  lwz r27, 0xd4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A5E590: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5E594: 409A004C  bne cr6, 0x82a5e5e0
	if !ctx.cr[6].eq {
	pc = 0x82A5E5E0; continue 'dispatch;
	}
	// 82A5E598: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E59C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E5A0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A5E5A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5E5A8: 41980008  blt cr6, 0x82a5e5b0
	if ctx.cr[6].lt {
	pc = 0x82A5E5B0; continue 'dispatch;
	}
	// 82A5E5AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A5E5B0; continue 'dispatch;
            }
            0x82A5E5B0 => {
    //   block [0x82A5E5B0..0x82A5E5E0)
	// 82A5E5B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5E5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E5B8: 419A01C4  beq cr6, 0x82a5e77c
	if ctx.cr[6].eq {
	pc = 0x82A5E77C; continue 'dispatch;
	}
	// 82A5E5BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E5C0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A5E5C4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A5E5C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5E5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E5D0: 480009F9  bl 0x82a5efc8
	ctx.lr = 0x82A5E5D4;
	sub_82A5EFC8(ctx, base);
	// 82A5E5D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E5D8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5E5DC: 4824AE70  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5E5E0 => {
    //   block [0x82A5E5E0..0x82A5E5F0)
	// 82A5E5E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E5E4: 419A000C  beq cr6, 0x82a5e5f0
	if ctx.cr[6].eq {
	pc = 0x82A5E5F0; continue 'dispatch;
	}
	// 82A5E5E8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5E5EC: 419A0008  beq cr6, 0x82a5e5f4
	if ctx.cr[6].eq {
	pc = 0x82A5E5F4; continue 'dispatch;
	}
	pc = 0x82A5E5F0; continue 'dispatch;
            }
            0x82A5E5F0 => {
    //   block [0x82A5E5F0..0x82A5E5F4)
	// 82A5E5F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5E5F4; continue 'dispatch;
            }
            0x82A5E5F4 => {
    //   block [0x82A5E5F4..0x82A5E618)
	// 82A5E5F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E5F8: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5E5FC: 409A0048  bne cr6, 0x82a5e644
	if !ctx.cr[6].eq {
	pc = 0x82A5E644; continue 'dispatch;
	}
	// 82A5E600: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E604: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E608: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5E60C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5E610: 41980008  blt cr6, 0x82a5e618
	if ctx.cr[6].lt {
	pc = 0x82A5E618; continue 'dispatch;
	}
	// 82A5E614: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A5E618; continue 'dispatch;
            }
            0x82A5E618 => {
    //   block [0x82A5E618..0x82A5E644)
	// 82A5E618: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5E61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E620: 419A015C  beq cr6, 0x82a5e77c
	if ctx.cr[6].eq {
	pc = 0x82A5E77C; continue 'dispatch;
	}
	// 82A5E624: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E628: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A5E62C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5E630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E634: 48000995  bl 0x82a5efc8
	ctx.lr = 0x82A5E638;
	sub_82A5EFC8(ctx, base);
	// 82A5E638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E63C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5E640: 4824AE0C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5E644 => {
    //   block [0x82A5E644..0x82A5E658)
	// 82A5E644: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E648: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A5E64C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A5E650: 41980008  blt cr6, 0x82a5e658
	if ctx.cr[6].lt {
	pc = 0x82A5E658; continue 'dispatch;
	}
	// 82A5E654: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82A5E658; continue 'dispatch;
            }
            0x82A5E658 => {
    //   block [0x82A5E658..0x82A5E68C)
	// 82A5E658: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5E65C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E660: 419A0070  beq cr6, 0x82a5e6d0
	if ctx.cr[6].eq {
	pc = 0x82A5E6D0; continue 'dispatch;
	}
	// 82A5E664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5E668: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82A5E66C: 48055E8D  bl 0x82ab44f8
	ctx.lr = 0x82A5E670;
	sub_82AB44F8(ctx, base);
	// 82A5E670: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5E674: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E678: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E67C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5E680: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A5E684: 41980008  blt cr6, 0x82a5e68c
	if ctx.cr[6].lt {
	pc = 0x82A5E68C; continue 'dispatch;
	}
	// 82A5E688: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82A5E68C; continue 'dispatch;
            }
            0x82A5E68C => {
    //   block [0x82A5E68C..0x82A5E6B8)
	// 82A5E68C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5E690: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E694: 419A0038  beq cr6, 0x82a5e6cc
	if ctx.cr[6].eq {
	pc = 0x82A5E6CC; continue 'dispatch;
	}
	// 82A5E698: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E69C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E6A0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A5E6A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E6A8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E6AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E6B0: 409A00B8  bne cr6, 0x82a5e768
	if !ctx.cr[6].eq {
	pc = 0x82A5E768; continue 'dispatch;
	}
	// 82A5E6B4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A5E6B8; continue 'dispatch;
            }
            0x82A5E6B8 => {
    //   block [0x82A5E6B8..0x82A5E6CC)
	// 82A5E6B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5E6BC: 4800090D  bl 0x82a5efc8
	ctx.lr = 0x82A5E6C0;
	sub_82A5EFC8(ctx, base);
	// 82A5E6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E6C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5E6C8: 4824AD84  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5E6CC => {
    //   block [0x82A5E6CC..0x82A5E6D0)
	// 82A5E6CC: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5E6D0; continue 'dispatch;
            }
            0x82A5E6D0 => {
    //   block [0x82A5E6D0..0x82A5E6E4)
	// 82A5E6D0: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E6D4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5E6D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5E6DC: 41980008  blt cr6, 0x82a5e6e4
	if ctx.cr[6].lt {
	pc = 0x82A5E6E4; continue 'dispatch;
	}
	// 82A5E6E0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A5E6E4; continue 'dispatch;
            }
            0x82A5E6E4 => {
    //   block [0x82A5E6E4..0x82A5E710)
	// 82A5E6E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5E6E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E6EC: 419A0090  beq cr6, 0x82a5e77c
	if ctx.cr[6].eq {
	pc = 0x82A5E77C; continue 'dispatch;
	}
	// 82A5E6F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5E6F4: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82A5E6F8: 4BAF8161  bl 0x82556858
	ctx.lr = 0x82A5E6FC;
	sub_82556858(ctx, base);
	// 82A5E6FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E704: 419A000C  beq cr6, 0x82a5e710
	if ctx.cr[6].eq {
	pc = 0x82A5E710; continue 'dispatch;
	}
	// 82A5E708: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5E70C: 419A0008  beq cr6, 0x82a5e714
	if ctx.cr[6].eq {
	pc = 0x82A5E714; continue 'dispatch;
	}
	pc = 0x82A5E710; continue 'dispatch;
            }
            0x82A5E710 => {
    //   block [0x82A5E710..0x82A5E714)
	// 82A5E710: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5E714; continue 'dispatch;
            }
            0x82A5E714 => {
    //   block [0x82A5E714..0x82A5E73C)
	// 82A5E714: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E718: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5E71C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5E720: 419A0028  beq cr6, 0x82a5e748
	if ctx.cr[6].eq {
	pc = 0x82A5E748; continue 'dispatch;
	}
	// 82A5E724: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E728: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E72C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A5E730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A5E734: 41980008  blt cr6, 0x82a5e73c
	if ctx.cr[6].lt {
	pc = 0x82A5E73C; continue 'dispatch;
	}
	// 82A5E738: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82A5E73C; continue 'dispatch;
            }
            0x82A5E73C => {
    //   block [0x82A5E73C..0x82A5E748)
	// 82A5E73C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5E740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E744: 419A0038  beq cr6, 0x82a5e77c
	if ctx.cr[6].eq {
	pc = 0x82A5E77C; continue 'dispatch;
	}
	pc = 0x82A5E748; continue 'dispatch;
            }
            0x82A5E748 => {
    //   block [0x82A5E748..0x82A5E768)
	// 82A5E748: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E74C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E750: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A5E754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E758: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E75C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E760: 419AFF58  beq cr6, 0x82a5e6b8
	if ctx.cr[6].eq {
	pc = 0x82A5E6B8; continue 'dispatch;
	}
	// 82A5E764: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A5E768; continue 'dispatch;
            }
            0x82A5E768 => {
    //   block [0x82A5E768..0x82A5E77C)
	// 82A5E768: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A5E76C: 4800085D  bl 0x82a5efc8
	ctx.lr = 0x82A5E770;
	sub_82A5EFC8(ctx, base);
	// 82A5E770: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E774: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5E778: 4824ACD4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5E77C => {
    //   block [0x82A5E77C..0x82A5E7AC)
	// 82A5E77C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5E780: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5E784: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A5E788: 48000599  bl 0x82a5ed20
	ctx.lr = 0x82A5E78C;
	sub_82A5ED20(ctx, base);
	// 82A5E78C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5E790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5E794: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E798: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5E79C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E7A0: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5E7A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A5E7A8: 4824ACA4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5E7B0 size=104
    let mut pc: u32 = 0x82A5E7B0;
    'dispatch: loop {
        match pc {
            0x82A5E7B0 => {
    //   block [0x82A5E7B0..0x82A5E7D0)
	// 82A5E7B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5E7B4: 390BFB48  addi r8, r11, -0x4b8
	ctx.r[8].s64 = ctx.r[11].s64 + -1208;
	// 82A5E7B8: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E7BC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E7C0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E7C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E7C8: 409A0044  bne cr6, 0x82a5e80c
	if !ctx.cr[6].eq {
	pc = 0x82A5E80C; continue 'dispatch;
	}
	// 82A5E7CC: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5E7D0; continue 'dispatch;
            }
            0x82A5E7D0 => {
    //   block [0x82A5E7D0..0x82A5E7E4)
	// 82A5E7D0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5E7D4: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82A5E7D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A5E7DC: 41980008  blt cr6, 0x82a5e7e4
	if ctx.cr[6].lt {
	pc = 0x82A5E7E4; continue 'dispatch;
	}
	// 82A5E7E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A5E7E4; continue 'dispatch;
            }
            0x82A5E7E4 => {
    //   block [0x82A5E7E4..0x82A5E7F8)
	// 82A5E7E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5E7E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E7EC: 419A000C  beq cr6, 0x82a5e7f8
	if ctx.cr[6].eq {
	pc = 0x82A5E7F8; continue 'dispatch;
	}
	// 82A5E7F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E7F4: 4800000C  b 0x82a5e800
	pc = 0x82A5E800; continue 'dispatch;
            }
            0x82A5E7F8 => {
    //   block [0x82A5E7F8..0x82A5E800)
	// 82A5E7F8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A5E7FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5E800; continue 'dispatch;
            }
            0x82A5E800 => {
    //   block [0x82A5E800..0x82A5E80C)
	// 82A5E800: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E804: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5E808: 419AFFC8  beq cr6, 0x82a5e7d0
	if ctx.cr[6].eq {
	pc = 0x82A5E7D0; continue 'dispatch;
	}
	pc = 0x82A5E80C; continue 'dispatch;
            }
            0x82A5E80C => {
    //   block [0x82A5E80C..0x82A5E818)
	// 82A5E80C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5E810: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A5E814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5E818 size=80
    let mut pc: u32 = 0x82A5E818;
    'dispatch: loop {
        match pc {
            0x82A5E818 => {
    //   block [0x82A5E818..0x82A5E838)
	// 82A5E818: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E81C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E820: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5E824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E828: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E82C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5E830: 409A0008  bne cr6, 0x82a5e838
	if !ctx.cr[6].eq {
	pc = 0x82A5E838; continue 'dispatch;
	}
	// 82A5E834: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A5E838; continue 'dispatch;
            }
            0x82A5E838 => {
    //   block [0x82A5E838..0x82A5E868)
	// 82A5E838: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A5E83C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E840: 390AFB48  addi r8, r10, -0x4b8
	ctx.r[8].s64 = ctx.r[10].s64 + -1208;
	// 82A5E844: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5E848: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E84C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E850: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A5E854: 409A0014  bne cr6, 0x82a5e868
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5E868);
		return;
	}
	// 82A5E858: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E85C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A5E860: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5E898 size=80
    let mut pc: u32 = 0x82A5E898;
    'dispatch: loop {
        match pc {
            0x82A5E898 => {
    //   block [0x82A5E898..0x82A5E8B8)
	// 82A5E898: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E89C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E8A0: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5E8A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E8A8: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5E8AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5E8B0: 409A0008  bne cr6, 0x82a5e8b8
	if !ctx.cr[6].eq {
	pc = 0x82A5E8B8; continue 'dispatch;
	}
	// 82A5E8B4: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A5E8B8; continue 'dispatch;
            }
            0x82A5E8B8 => {
    //   block [0x82A5E8B8..0x82A5E8E8)
	// 82A5E8B8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A5E8BC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E8C0: 390AFB48  addi r8, r10, -0x4b8
	ctx.r[8].s64 = ctx.r[10].s64 + -1208;
	// 82A5E8C4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5E8C8: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E8CC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E8D0: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A5E8D4: 409A0014  bne cr6, 0x82a5e8e8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A5E8E8);
		return;
	}
	// 82A5E8D8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E8DC: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A5E8E0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5E8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5E918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5E918 size=256
    let mut pc: u32 = 0x82A5E918;
    'dispatch: loop {
        match pc {
            0x82A5E918 => {
    //   block [0x82A5E918..0x82A5E94C)
	// 82A5E918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5E91C: 4824AAE9  bl 0x82ca9404
	ctx.lr = 0x82A5E920;
	sub_82CA93D0(ctx, base);
	// 82A5E920: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5E924: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A5E928: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A5E92C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A5E930: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A5E934: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5E938: 4B7C0921  bl 0x8221f258
	ctx.lr = 0x82A5E93C;
	sub_8221F258(ctx, base);
	// 82A5E93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5E940: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5E944: 419A0008  beq cr6, 0x82a5e94c
	if ctx.cr[6].eq {
	pc = 0x82A5E94C; continue 'dispatch;
	}
	// 82A5E948: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82A5E94C; continue 'dispatch;
            }
            0x82A5E94C => {
    //   block [0x82A5E94C..0x82A5E95C)
	// 82A5E94C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A5E950: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A5E954: 419A0008  beq cr6, 0x82a5e95c
	if ctx.cr[6].eq {
	pc = 0x82A5E95C; continue 'dispatch;
	}
	// 82A5E958: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A5E95C; continue 'dispatch;
            }
            0x82A5E95C => {
    //   block [0x82A5E95C..0x82A5E978)
	// 82A5E95C: 355F0008  addic. r10, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A5E960: 41820034  beq 0x82a5e994
	if ctx.cr[0].eq {
	pc = 0x82A5E994; continue 'dispatch;
	}
	// 82A5E964: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5E968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5E96C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5E970: 419A0024  beq cr6, 0x82a5e994
	if ctx.cr[6].eq {
	pc = 0x82A5E994; continue 'dispatch;
	}
	// 82A5E974: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5E978; continue 'dispatch;
            }
            0x82A5E978 => {
    //   block [0x82A5E978..0x82A5E994)
	// 82A5E978: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5E97C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5E980: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5E984: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5E988: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5E98C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5E990: 4082FFE8  bne 0x82a5e978
	if !ctx.cr[0].eq {
	pc = 0x82A5E978; continue 'dispatch;
	}
	pc = 0x82A5E994; continue 'dispatch;
            }
            0x82A5E994 => {
    //   block [0x82A5E994..0x82A5E9FC)
	// 82A5E994: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5E998: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82A5E99C: 3BCBFB54  addi r30, r11, -0x4ac
	ctx.r[30].s64 = ctx.r[11].s64 + -1196;
	// 82A5E9A0: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82A5E9A4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5E9A8: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A5E9AC: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82A5E9B0: 4098004C  bge cr6, 0x82a5e9fc
	if !ctx.cr[6].lt {
	pc = 0x82A5E9FC; continue 'dispatch;
	}
	// 82A5E9B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A5E9B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5E9BC: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82A5E9C0: 4B893581  bl 0x822f1f40
	ctx.lr = 0x82A5E9C4;
	sub_822F1F40(ctx, base);
	// 82A5E9C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5E9C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5E9CC: 4B8933E5  bl 0x822f1db0
	ctx.lr = 0x82A5E9D0;
	sub_822F1DB0(ctx, base);
	// 82A5E9D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A5E9D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5E9D8: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 82A5E9DC: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82A5E9E0: 4B893441  bl 0x822f1e20
	ctx.lr = 0x82A5E9E4;
	sub_822F1E20(ctx, base);
	// 82A5E9E4: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82A5E9E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5E9EC: 4BC1CDF5  bl 0x8267b7e0
	ctx.lr = 0x82A5E9F0;
	sub_8267B7E0(ctx, base);
	// 82A5E9F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5E9F4: 4B712E1D  bl 0x82171810
	ctx.lr = 0x82A5E9F8;
	sub_82171810(ctx, base);
	// 82A5E9F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5E9FC; continue 'dispatch;
            }
            0x82A5E9FC => {
    //   block [0x82A5E9FC..0x82A5EA18)
	// 82A5E9FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A5EA00: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5EA04: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A5EA08: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EA0C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A5EA10: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A5EA14: 4824AA40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5EA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5EA18 size=128
    let mut pc: u32 = 0x82A5EA18;
    'dispatch: loop {
        match pc {
            0x82A5EA18 => {
    //   block [0x82A5EA18..0x82A5EA30)
	// 82A5EA18: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82A5EA1C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82A5EA20: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82A5EA24: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A5EA28: 419A0060  beq cr6, 0x82a5ea88
	if ctx.cr[6].eq {
	pc = 0x82A5EA88; continue 'dispatch;
	}
	// 82A5EA2C: 7D062050  subf r8, r6, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	pc = 0x82A5EA30; continue 'dispatch;
            }
            0x82A5EA30 => {
    //   block [0x82A5EA30..0x82A5EA40)
	// 82A5EA30: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A5EA34: 419A0048  beq cr6, 0x82a5ea7c
	if ctx.cr[6].eq {
	pc = 0x82A5EA7C; continue 'dispatch;
	}
	// 82A5EA38: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A5EA3C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82A5EA40; continue 'dispatch;
            }
            0x82A5EA40 => {
    //   block [0x82A5EA40..0x82A5EA54)
	// 82A5EA40: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EA44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5EA48: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82A5EA4C: 419A0024  beq cr6, 0x82a5ea70
	if ctx.cr[6].eq {
	pc = 0x82A5EA70; continue 'dispatch;
	}
	// 82A5EA50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82A5EA54; continue 'dispatch;
            }
            0x82A5EA54 => {
    //   block [0x82A5EA54..0x82A5EA70)
	// 82A5EA54: 7FE000A6  mfmsr r31
	ctx.r[31].u64 = ctx.msr;
	// 82A5EA58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5EA5C: 7C605028  lwarx r3, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 82A5EA60: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82A5EA64: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5EA68: 7FE10164  mtmsrd r31, 1
	ctx.msr = (ctx.r[31].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5EA6C: 4082FFE8  bne 0x82a5ea54
	if !ctx.cr[0].eq {
	pc = 0x82A5EA54; continue 'dispatch;
	}
	pc = 0x82A5EA70; continue 'dispatch;
            }
            0x82A5EA70 => {
    //   block [0x82A5EA70..0x82A5EA7C)
	// 82A5EA70: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A5EA74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5EA78: 4080FFC8  bge 0x82a5ea40
	if !ctx.cr[0].lt {
	pc = 0x82A5EA40; continue 'dispatch;
	}
	pc = 0x82A5EA7C; continue 'dispatch;
            }
            0x82A5EA7C => {
    //   block [0x82A5EA7C..0x82A5EA88)
	// 82A5EA7C: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82A5EA80: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82A5EA84: 4200FFAC  bdnz 0x82a5ea30
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A5EA30; continue 'dispatch;
	}
	pc = 0x82A5EA88; continue 'dispatch;
            }
            0x82A5EA88 => {
    //   block [0x82A5EA88..0x82A5EA98)
	// 82A5EA88: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5EA8C: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A5EA90: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82A5EA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5EA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5EA98 size=648
    let mut pc: u32 = 0x82A5EA98;
    'dispatch: loop {
        match pc {
            0x82A5EA98 => {
    //   block [0x82A5EA98..0x82A5EAC8)
	// 82A5EA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5EA9C: 4824A965  bl 0x82ca9400
	ctx.lr = 0x82A5EAA0;
	sub_82CA93D0(ctx, base);
	// 82A5EAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5EAA4: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EAA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5EAAC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EAB0: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A5EAB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5EAB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5EABC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A5EAC0: 419A0024  beq cr6, 0x82a5eae4
	if ctx.cr[6].eq {
	pc = 0x82A5EAE4; continue 'dispatch;
	}
	// 82A5EAC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5EAC8; continue 'dispatch;
            }
            0x82A5EAC8 => {
    //   block [0x82A5EAC8..0x82A5EAE4)
	// 82A5EAC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5EACC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5EAD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5EAD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5EAD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5EADC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5EAE0: 4082FFE8  bne 0x82a5eac8
	if !ctx.cr[0].eq {
	pc = 0x82A5EAC8; continue 'dispatch;
	}
	pc = 0x82A5EAE4; continue 'dispatch;
            }
            0x82A5EAE4 => {
    //   block [0x82A5EAE4..0x82A5EAF8)
	// 82A5EAE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5EAEC: 409A000C  bne cr6, 0x82a5eaf8
	if !ctx.cr[6].eq {
	pc = 0x82A5EAF8; continue 'dispatch;
	}
	// 82A5EAF0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A5EAF4: 48000010  b 0x82a5eb04
	pc = 0x82A5EB04; continue 'dispatch;
            }
            0x82A5EAF8 => {
    //   block [0x82A5EAF8..0x82A5EB04)
	// 82A5EAF8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5EAFC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5EB00: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82A5EB04; continue 'dispatch;
            }
            0x82A5EB04 => {
    //   block [0x82A5EB04..0x82A5EB38)
	// 82A5EB04: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EB08: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 82A5EB0C: 7D0BE850  subf r8, r11, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A5EB10: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A5EB14: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A5EB18: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5EB1C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A5EB20: 40980018  bge cr6, 0x82a5eb38
	if !ctx.cr[6].lt {
	pc = 0x82A5EB38; continue 'dispatch;
	}
	// 82A5EB24: 4BFE89A5  bl 0x82a474c8
	ctx.lr = 0x82A5EB28;
	sub_82A474C8(ctx, base);
	// 82A5EB28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5EB2C: 4B74DF8D  bl 0x821acab8
	ctx.lr = 0x82A5EB30;
	sub_821ACAB8(ctx, base);
	// 82A5EB30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EB34: 4824A91C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5EB38 => {
    //   block [0x82A5EB38..0x82A5EB5C)
	// 82A5EB38: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A5EB3C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A5EB40: 409800E8  bge cr6, 0x82a5ec28
	if !ctx.cr[6].lt {
	pc = 0x82A5EC28; continue 'dispatch;
	}
	// 82A5EB44: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5EB48: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A5EB4C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5EB50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5EB54: 41980008  blt cr6, 0x82a5eb5c
	if ctx.cr[6].lt {
	pc = 0x82A5EB5C; continue 'dispatch;
	}
	// 82A5EB58: 7F6B4A14  add r27, r11, r9
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A5EB5C; continue 'dispatch;
            }
            0x82A5EB5C => {
    //   block [0x82A5EB5C..0x82A5EB68)
	// 82A5EB5C: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A5EB60: 40980008  bge cr6, 0x82a5eb68
	if !ctx.cr[6].lt {
	pc = 0x82A5EB68; continue 'dispatch;
	}
	// 82A5EB64: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	pc = 0x82A5EB68; continue 'dispatch;
            }
            0x82A5EB68 => {
    //   block [0x82A5EB68..0x82A5EBE0)
	// 82A5EB68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A5EB6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EB70: 48051DE9  bl 0x82ab0958
	ctx.lr = 0x82A5EB74;
	sub_82AB0958(ctx, base);
	// 82A5EB74: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5EB78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5EB7C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EB80: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5EB84: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A5EB88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EB8C: 48000A5D  bl 0x82a5f5e8
	ctx.lr = 0x82A5EB90;
	sub_82A5F5E8(ctx, base);
	// 82A5EB90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A5EB94: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5EB98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5EB9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EBA0: 4BFFF909  bl 0x82a5e4a8
	ctx.lr = 0x82A5EBA4;
	sub_82A5E4A8(ctx, base);
	// 82A5EBA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A5EBA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5EBAC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EBB4: 48000A35  bl 0x82a5f5e8
	ctx.lr = 0x82A5EBB8;
	sub_82A5F5E8(ctx, base);
	// 82A5EBB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EBBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5EBC0: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EBC4: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A5EBC8: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A5EBCC: 3B4A0001  addi r26, r10, 1
	ctx.r[26].s64 = ctx.r[10].s64 + 1;
	// 82A5EBD0: 419A002C  beq cr6, 0x82a5ebfc
	if ctx.cr[6].eq {
	pc = 0x82A5EBFC; continue 'dispatch;
	}
	// 82A5EBD4: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82A5EBD8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5EBDC: 419A0018  beq cr6, 0x82a5ebf4
	if ctx.cr[6].eq {
	pc = 0x82A5EBF4; continue 'dispatch;
	}
	pc = 0x82A5EBE0; continue 'dispatch;
            }
            0x82A5EBE0 => {
    //   block [0x82A5EBE0..0x82A5EBF4)
	// 82A5EBE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5EBE4: 4B74DED5  bl 0x821acab8
	ctx.lr = 0x82A5EBE8;
	sub_821ACAB8(ctx, base);
	// 82A5EBE8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82A5EBEC: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5EBF0: 409AFFF0  bne cr6, 0x82a5ebe0
	if !ctx.cr[6].eq {
	pc = 0x82A5EBE0; continue 'dispatch;
	}
	pc = 0x82A5EBF4; continue 'dispatch;
            }
            0x82A5EBF4 => {
    //   block [0x82A5EBF4..0x82A5EBFC)
	// 82A5EBF4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EBF8: 4B7BD141  bl 0x8221bd38
	ctx.lr = 0x82A5EBFC;
	sub_8221BD38(ctx, base);
	pc = 0x82A5EBFC; continue 'dispatch;
            }
            0x82A5EBFC => {
    //   block [0x82A5EBFC..0x82A5EC28)
	// 82A5EBFC: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5EC00: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A5EC04: 574A1838  slwi r10, r26, 3
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5EC08: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5EC0C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A5EC10: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A5EC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5EC18: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5EC1C: 4B74DE9D  bl 0x821acab8
	ctx.lr = 0x82A5EC20;
	sub_821ACAB8(ctx, base);
	// 82A5EC20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EC24: 4824A82C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5EC28 => {
    //   block [0x82A5EC28..0x82A5EC84)
	// 82A5EC28: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5EC2C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5EC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EC34: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A5EC38: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5EC3C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A5EC40: 4098006C  bge cr6, 0x82a5ecac
	if !ctx.cr[6].lt {
	pc = 0x82A5ECAC; continue 'dispatch;
	}
	// 82A5EC44: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A5EC48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5EC4C: 4800099D  bl 0x82a5f5e8
	ctx.lr = 0x82A5EC50;
	sub_82A5F5E8(ctx, base);
	// 82A5EC50: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EC54: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5EC58: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A5EC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EC60: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5EC64: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A5EC68: 4BFFF841  bl 0x82a5e4a8
	ctx.lr = 0x82A5EC6C;
	sub_82A5E4A8(ctx, base);
	// 82A5EC6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EC70: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A5EC74: 3BABFFF8  addi r29, r11, -8
	ctx.r[29].s64 = ctx.r[11].s64 + -8;
	// 82A5EC78: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5EC7C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5EC80: 419A0090  beq cr6, 0x82a5ed10
	if ctx.cr[6].eq {
	pc = 0x82A5ED10; continue 'dispatch;
	}
	pc = 0x82A5EC84; continue 'dispatch;
            }
            0x82A5EC84 => {
    //   block [0x82A5EC84..0x82A5ECAC)
	// 82A5EC84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5EC88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5EC8C: 48000C05  bl 0x82a5f890
	ctx.lr = 0x82A5EC90;
	sub_82A5F890(ctx, base);
	// 82A5EC90: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A5EC94: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5EC98: 409AFFEC  bne cr6, 0x82a5ec84
	if !ctx.cr[6].eq {
	pc = 0x82A5EC84; continue 'dispatch;
	}
	// 82A5EC9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5ECA0: 4B74DE19  bl 0x821acab8
	ctx.lr = 0x82A5ECA4;
	sub_821ACAB8(ctx, base);
	// 82A5ECA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5ECA8: 4824A7A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5ECAC => {
    //   block [0x82A5ECAC..0x82A5ECD0)
	// 82A5ECAC: 3B9DFFF8  addi r28, r29, -8
	ctx.r[28].s64 = ctx.r[29].s64 + -8;
	// 82A5ECB0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A5ECB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5ECB8: 48000931  bl 0x82a5f5e8
	ctx.lr = 0x82A5ECBC;
	sub_82A5F5E8(ctx, base);
	// 82A5ECBC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A5ECC0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A5ECC4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5ECC8: 419A0020  beq cr6, 0x82a5ece8
	if ctx.cr[6].eq {
	pc = 0x82A5ECE8; continue 'dispatch;
	}
	// 82A5ECCC: 7FBCE850  subf r29, r28, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	pc = 0x82A5ECD0; continue 'dispatch;
            }
            0x82A5ECD0 => {
    //   block [0x82A5ECD0..0x82A5ECE8)
	// 82A5ECD0: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A5ECD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5ECD8: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82A5ECDC: 48000BB5  bl 0x82a5f890
	ctx.lr = 0x82A5ECE0;
	sub_82A5F890(ctx, base);
	// 82A5ECE0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5ECE4: 409AFFEC  bne cr6, 0x82a5ecd0
	if !ctx.cr[6].eq {
	pc = 0x82A5ECD0; continue 'dispatch;
	}
	pc = 0x82A5ECE8; continue 'dispatch;
            }
            0x82A5ECE8 => {
    //   block [0x82A5ECE8..0x82A5ECF8)
	// 82A5ECE8: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82A5ECEC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A5ECF0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5ECF4: 419A001C  beq cr6, 0x82a5ed10
	if ctx.cr[6].eq {
	pc = 0x82A5ED10; continue 'dispatch;
	}
	pc = 0x82A5ECF8; continue 'dispatch;
            }
            0x82A5ECF8 => {
    //   block [0x82A5ECF8..0x82A5ED10)
	// 82A5ECF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5ECFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5ED00: 48000B91  bl 0x82a5f890
	ctx.lr = 0x82A5ED04;
	sub_82A5F890(ctx, base);
	// 82A5ED04: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5ED08: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5ED0C: 409AFFEC  bne cr6, 0x82a5ecf8
	if !ctx.cr[6].eq {
	pc = 0x82A5ECF8; continue 'dispatch;
	}
	pc = 0x82A5ED10; continue 'dispatch;
            }
            0x82A5ED10 => {
    //   block [0x82A5ED10..0x82A5ED20)
	// 82A5ED10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5ED14: 4B74DDA5  bl 0x821acab8
	ctx.lr = 0x82A5ED18;
	sub_821ACAB8(ctx, base);
	// 82A5ED18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5ED1C: 4824A734  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5ED20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5ED20 size=348
    let mut pc: u32 = 0x82A5ED20;
    'dispatch: loop {
        match pc {
            0x82A5ED20 => {
    //   block [0x82A5ED20..0x82A5ED60)
	// 82A5ED20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5ED24: 4824A6DD  bl 0x82ca9400
	ctx.lr = 0x82A5ED28;
	sub_82CA93D0(ctx, base);
	// 82A5ED28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5ED2C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5ED30: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A5ED34: 3B8BFB48  addi r28, r11, -0x4b8
	ctx.r[28].s64 = ctx.r[11].s64 + -1208;
	// 82A5ED38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5ED3C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A5ED40: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A5ED44: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5ED48: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82A5ED4C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5ED50: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5ED54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5ED58: 409A0044  bne cr6, 0x82a5ed9c
	if !ctx.cr[6].eq {
	pc = 0x82A5ED9C; continue 'dispatch;
	}
	// 82A5ED5C: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5ED60; continue 'dispatch;
            }
            0x82A5ED60 => {
    //   block [0x82A5ED60..0x82A5ED78)
	// 82A5ED60: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5ED64: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82A5ED68: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A5ED6C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82A5ED70: 41980008  blt cr6, 0x82a5ed78
	if ctx.cr[6].lt {
	pc = 0x82A5ED78; continue 'dispatch;
	}
	// 82A5ED74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A5ED78; continue 'dispatch;
            }
            0x82A5ED78 => {
    //   block [0x82A5ED78..0x82A5ED8C)
	// 82A5ED78: 555E063E  clrlwi r30, r10, 0x18
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A5ED7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A5ED80: 419A000C  beq cr6, 0x82a5ed8c
	if ctx.cr[6].eq {
	pc = 0x82A5ED8C; continue 'dispatch;
	}
	// 82A5ED84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5ED88: 48000008  b 0x82a5ed90
	pc = 0x82A5ED90; continue 'dispatch;
            }
            0x82A5ED8C => {
    //   block [0x82A5ED8C..0x82A5ED90)
	// 82A5ED8C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A5ED90; continue 'dispatch;
            }
            0x82A5ED90 => {
    //   block [0x82A5ED90..0x82A5ED9C)
	// 82A5ED90: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5ED94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5ED98: 419AFFC8  beq cr6, 0x82a5ed60
	if ctx.cr[6].eq {
	pc = 0x82A5ED60; continue 'dispatch;
	}
	pc = 0x82A5ED9C; continue 'dispatch;
            }
            0x82A5ED9C => {
    //   block [0x82A5ED9C..0x82A5EDF8)
	// 82A5ED9C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82A5EDA0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A5EDA4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A5EDA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5EDAC: 419A0050  beq cr6, 0x82a5edfc
	if ctx.cr[6].eq {
	pc = 0x82A5EDFC; continue 'dispatch;
	}
	// 82A5EDB0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EDB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5EDB8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5EDBC: 409A003C  bne cr6, 0x82a5edf8
	if !ctx.cr[6].eq {
	pc = 0x82A5EDF8; continue 'dispatch;
	}
	// 82A5EDC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5EDC4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A5EDC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A5EDCC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5EDD0: 480001F9  bl 0x82a5efc8
	ctx.lr = 0x82A5EDD4;
	sub_82A5EFC8(ctx, base);
	// 82A5EDD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5EDD8: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A5EDDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EDE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EDE4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EDE8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5EDEC: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5EDF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EDF4: 4824A65C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5EDF8 => {
    //   block [0x82A5EDF8..0x82A5EDFC)
	// 82A5EDF8: 48055701  bl 0x82ab44f8
	ctx.lr = 0x82A5EDFC;
	sub_82AB44F8(ctx, base);
	pc = 0x82A5EDFC; continue 'dispatch;
            }
            0x82A5EDFC => {
    //   block [0x82A5EDFC..0x82A5EE18)
	// 82A5EDFC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5EE00: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EE04: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5EE08: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A5EE0C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A5EE10: 41980008  blt cr6, 0x82a5ee18
	if ctx.cr[6].lt {
	pc = 0x82A5EE18; continue 'dispatch;
	}
	// 82A5EE14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A5EE18; continue 'dispatch;
            }
            0x82A5EE18 => {
    //   block [0x82A5EE18..0x82A5EE60)
	// 82A5EE18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A5EE1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5EE20: 419A0040  beq cr6, 0x82a5ee60
	if ctx.cr[6].eq {
	pc = 0x82A5EE60; continue 'dispatch;
	}
	// 82A5EE24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5EE28: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A5EE2C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A5EE30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5EE34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5EE38: 48000191  bl 0x82a5efc8
	ctx.lr = 0x82A5EE3C;
	sub_82A5EFC8(ctx, base);
	// 82A5EE3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A5EE40: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A5EE44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EE48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EE4C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EE50: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5EE54: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A5EE58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EE5C: 4824A5F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5EE60 => {
    //   block [0x82A5EE60..0x82A5EE7C)
	// 82A5EE60: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5EE64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5EE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EE6C: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A5EE70: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A5EE74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EE78: 4824A5D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5EE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5EE80 size=328
    let mut pc: u32 = 0x82A5EE80;
    'dispatch: loop {
        match pc {
            0x82A5EE80 => {
    //   block [0x82A5EE80..0x82A5EEBC)
	// 82A5EE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5EE84: 4824A581  bl 0x82ca9404
	ctx.lr = 0x82A5EE88;
	sub_82CA93D0(ctx, base);
	// 82A5EE88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5EE8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5EE90: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A5EE94: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A5EE98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5EE9C: 3BEBFB48  addi r31, r11, -0x4b8
	ctx.r[31].s64 = ctx.r[11].s64 + -1208;
	// 82A5EEA0: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A5EEA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5EEA8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EEAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EEB0: 419A000C  beq cr6, 0x82a5eebc
	if ctx.cr[6].eq {
	pc = 0x82A5EEBC; continue 'dispatch;
	}
	// 82A5EEB4: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5EEB8: 419A0008  beq cr6, 0x82a5eec0
	if ctx.cr[6].eq {
	pc = 0x82A5EEC0; continue 'dispatch;
	}
	pc = 0x82A5EEBC; continue 'dispatch;
            }
            0x82A5EEBC => {
    //   block [0x82A5EEBC..0x82A5EEC0)
	// 82A5EEBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5EEC0; continue 'dispatch;
            }
            0x82A5EEC0 => {
    //   block [0x82A5EEC0..0x82A5EEE4)
	// 82A5EEC0: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5EEC4: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A5EEC8: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82A5EECC: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5EED0: 409A00A0  bne cr6, 0x82a5ef70
	if !ctx.cr[6].eq {
	pc = 0x82A5EF70; continue 'dispatch;
	}
	// 82A5EED4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A5EED8: 419A000C  beq cr6, 0x82a5eee4
	if ctx.cr[6].eq {
	pc = 0x82A5EEE4; continue 'dispatch;
	}
	// 82A5EEDC: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5EEE0: 419A0008  beq cr6, 0x82a5eee8
	if ctx.cr[6].eq {
	pc = 0x82A5EEE8; continue 'dispatch;
	}
	pc = 0x82A5EEE4; continue 'dispatch;
            }
            0x82A5EEE4 => {
    //   block [0x82A5EEE4..0x82A5EEE8)
	// 82A5EEE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5EEE8; continue 'dispatch;
            }
            0x82A5EEE8 => {
    //   block [0x82A5EEE8..0x82A5EF04)
	// 82A5EEE8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5EEEC: 409A0084  bne cr6, 0x82a5ef70
	if !ctx.cr[6].eq {
	pc = 0x82A5EF70; continue 'dispatch;
	}
	// 82A5EEF0: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EEF4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82A5EEF8: 895D0015  lbz r10, 0x15(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5EEFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5EF00: 409A0038  bne cr6, 0x82a5ef38
	if !ctx.cr[6].eq {
	pc = 0x82A5EF38; continue 'dispatch;
	}
	pc = 0x82A5EF04; continue 'dispatch;
            }
            0x82A5EF04 => {
    //   block [0x82A5EF04..0x82A5EF38)
	// 82A5EF04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5EF08: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EF0C: 4BFF3FD5  bl 0x82a52ee0
	ctx.lr = 0x82A5EF10;
	sub_82A52EE0(ctx, base);
	// 82A5EF10: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 82A5EF14: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EF18: 4B74DBA1  bl 0x821acab8
	ctx.lr = 0x82A5EF1C;
	sub_821ACAB8(ctx, base);
	// 82A5EF1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5EF20: 4B7BCE19  bl 0x8221bd38
	ctx.lr = 0x82A5EF24;
	sub_8221BD38(ctx, base);
	// 82A5EF24: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A5EF28: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A5EF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5EF30: 419AFFD4  beq cr6, 0x82a5ef04
	if ctx.cr[6].eq {
	pc = 0x82A5EF04; continue 'dispatch;
	}
	// 82A5EF34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5EF38; continue 'dispatch;
            }
            0x82A5EF38 => {
    //   block [0x82A5EF38..0x82A5EF70)
	// 82A5EF38: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5EF3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5EF40: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5EF44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5EF48: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A5EF4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EF50: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5EF54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EF58: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5EF5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5EF60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5EF64: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5EF68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EF6C: 4824A4E8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5EF70 => {
    //   block [0x82A5EF70..0x82A5EF80)
	// 82A5EF70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5EF74: 419A000C  beq cr6, 0x82a5ef80
	if ctx.cr[6].eq {
	pc = 0x82A5EF80; continue 'dispatch;
	}
	// 82A5EF78: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5EF7C: 419A0008  beq cr6, 0x82a5ef84
	if ctx.cr[6].eq {
	pc = 0x82A5EF84; continue 'dispatch;
	}
	pc = 0x82A5EF80; continue 'dispatch;
            }
            0x82A5EF80 => {
    //   block [0x82A5EF80..0x82A5EF84)
	// 82A5EF80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A5EF84; continue 'dispatch;
            }
            0x82A5EF84 => {
    //   block [0x82A5EF84..0x82A5EFB8)
	// 82A5EF84: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5EF88: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5EF8C: 419A002C  beq cr6, 0x82a5efb8
	if ctx.cr[6].eq {
	pc = 0x82A5EFB8; continue 'dispatch;
	}
	// 82A5EF90: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A5EF94: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A5EF98: 4BAF78C1  bl 0x82556858
	ctx.lr = 0x82A5EF9C;
	sub_82556858(ctx, base);
	// 82A5EF9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5EFA0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A5EFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5EFA8: 4BFFF061  bl 0x82a5e008
	ctx.lr = 0x82A5EFAC;
	sub_82A5E008(ctx, base);
	// 82A5EFAC: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A5EFB0: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A5EFB4: 4BFFFFBC  b 0x82a5ef70
	pc = 0x82A5EF70; continue 'dispatch;
            }
            0x82A5EFB8 => {
    //   block [0x82A5EFB8..0x82A5EFC8)
	// 82A5EFB8: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A5EFBC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5EFC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5EFC4: 4824A490  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5EFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5EFC8 size=672
    let mut pc: u32 = 0x82A5EFC8;
    'dispatch: loop {
        match pc {
            0x82A5EFC8 => {
    //   block [0x82A5EFC8..0x82A5F044)
	// 82A5EFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5EFCC: 4824A42D  bl 0x82ca93f8
	ctx.lr = 0x82A5EFD0;
	sub_82CA93D0(ctx, base);
	// 82A5EFD0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5EFD4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5EFD8: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 82A5EFDC: 3BCBFB48  addi r30, r11, -0x4b8
	ctx.r[30].s64 = ctx.r[11].s64 + -1208;
	// 82A5EFE0: 6149FFFE  ori r9, r10, 0xfffe
	ctx.r[9].u64 = ctx.r[10].u64 | 65534;
	// 82A5EFE4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A5EFE8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A5EFEC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A5EFF0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5EFF4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A5EFF8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5EFFC: 41980048  blt cr6, 0x82a5f044
	if ctx.cr[6].lt {
	pc = 0x82A5F044; continue 'dispatch;
	}
	// 82A5F000: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A5F004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F008: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82A5F00C: 4B892F35  bl 0x822f1f40
	ctx.lr = 0x82A5F010;
	sub_822F1F40(ctx, base);
	// 82A5F010: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5F014: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5F018: 4B892D99  bl 0x822f1db0
	ctx.lr = 0x82A5F01C;
	sub_822F1DB0(ctx, base);
	// 82A5F01C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A5F020: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5F024: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82A5F028: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A5F02C: 4B892DF5  bl 0x822f1e20
	ctx.lr = 0x82A5F030;
	sub_822F1E20(ctx, base);
	// 82A5F030: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A5F034: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A5F038: 4BC1C7A9  bl 0x8267b7e0
	ctx.lr = 0x82A5F03C;
	sub_8267B7E0(ctx, base);
	// 82A5F03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F040: 4B7127D1  bl 0x82171810
	ctx.lr = 0x82A5F044;
	sub_82171810(ctx, base);
	pc = 0x82A5F044; continue 'dispatch;
            }
            0x82A5F044 => {
    //   block [0x82A5F044..0x82A5F08C)
	// 82A5F044: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A5F048: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F04C: 4B7C020D  bl 0x8221f258
	ctx.lr = 0x82A5F050;
	sub_8221F258(ctx, base);
	// 82A5F050: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5F054: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A5F058: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A5F05C: 419A0054  beq cr6, 0x82a5f0b0
	if ctx.cr[6].eq {
	pc = 0x82A5F0B0; continue 'dispatch;
	}
	// 82A5F060: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A5F064: 397B000C  addi r11, r27, 0xc
	ctx.r[11].s64 = ctx.r[27].s64 + 12;
	// 82A5F068: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A5F06C: 93BB0008  stw r29, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A5F070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F074: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A5F078: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F07C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F080: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A5F084: 419A0024  beq cr6, 0x82a5f0a8
	if ctx.cr[6].eq {
	pc = 0x82A5F0A8; continue 'dispatch;
	}
	// 82A5F088: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5F08C; continue 'dispatch;
            }
            0x82A5F08C => {
    //   block [0x82A5F08C..0x82A5F0A8)
	// 82A5F08C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5F090: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F094: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5F098: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5F09C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F0A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F0A4: 4082FFE8  bne 0x82a5f08c
	if !ctx.cr[0].eq {
	pc = 0x82A5F08C; continue 'dispatch;
	}
	pc = 0x82A5F0A8; continue 'dispatch;
            }
            0x82A5F0A8 => {
    //   block [0x82A5F0A8..0x82A5F0B0)
	// 82A5F0A8: 9B3B0014  stb r25, 0x14(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A5F0AC: 9B3B0015  stb r25, 0x15(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(21 as u32), ctx.r[25].u8 ) };
	pc = 0x82A5F0B0; continue 'dispatch;
            }
            0x82A5F0B0 => {
    //   block [0x82A5F0B0..0x82A5F0DC)
	// 82A5F0B0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F0B4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F0B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5F0BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5F0C0: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5F0C4: 409A0018  bne cr6, 0x82a5f0dc
	if !ctx.cr[6].eq {
	pc = 0x82A5F0DC; continue 'dispatch;
	}
	// 82A5F0C8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A5F0CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F0D0: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5F0D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F0D8: 48000044  b 0x82a5f11c
	pc = 0x82A5F11C; continue 'dispatch;
            }
            0x82A5F0DC => {
    //   block [0x82A5F0DC..0x82A5F108)
	// 82A5F0DC: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A5F0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F0E4: 419A0024  beq cr6, 0x82a5f108
	if ctx.cr[6].eq {
	pc = 0x82A5F108; continue 'dispatch;
	}
	// 82A5F0E8: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5F0EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F0F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F0F4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5F0F8: 409A0028  bne cr6, 0x82a5f120
	if !ctx.cr[6].eq {
	pc = 0x82A5F120; continue 'dispatch;
	}
	// 82A5F0FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5F100: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A5F104: 4800001C  b 0x82a5f120
	pc = 0x82A5F120; continue 'dispatch;
            }
            0x82A5F108 => {
    //   block [0x82A5F108..0x82A5F11C)
	// 82A5F108: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A5F10C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F110: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F114: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5F118: 409A0008  bne cr6, 0x82a5f120
	if !ctx.cr[6].eq {
	pc = 0x82A5F120; continue 'dispatch;
	}
	pc = 0x82A5F11C; continue 'dispatch;
            }
            0x82A5F11C => {
    //   block [0x82A5F11C..0x82A5F120)
	// 82A5F11C: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A5F120; continue 'dispatch;
            }
            0x82A5F120 => {
    //   block [0x82A5F120..0x82A5F13C)
	// 82A5F120: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F124: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A5F128: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A5F12C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A5F130: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5F134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5F138: 409A0110  bne cr6, 0x82a5f248
	if !ctx.cr[6].eq {
	pc = 0x82A5F248; continue 'dispatch;
	}
	pc = 0x82A5F13C; continue 'dispatch;
            }
            0x82A5F13C => {
    //   block [0x82A5F13C..0x82A5F184)
	// 82A5F13C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F140: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F144: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F148: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5F14C: 409A0078  bne cr6, 0x82a5f1c4
	if !ctx.cr[6].eq {
	pc = 0x82A5F1C4; continue 'dispatch;
	}
	// 82A5F150: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F154: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5F158: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5F15C: 409A0028  bne cr6, 0x82a5f184
	if !ctx.cr[6].eq {
	pc = 0x82A5F184; continue 'dispatch;
	}
	// 82A5F160: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A5F164: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F168: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F16C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F170: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F174: 9B270014  stb r25, 0x14(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A5F178: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F17C: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F180: 480000B4  b 0x82a5f234
	pc = 0x82A5F234; continue 'dispatch;
            }
            0x82A5F184 => {
    //   block [0x82A5F184..0x82A5F19C)
	// 82A5F184: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F188: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5F18C: 409A0010  bne cr6, 0x82a5f19c
	if !ctx.cr[6].eq {
	pc = 0x82A5F19C; continue 'dispatch;
	}
	// 82A5F190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5F194: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5F198: 4BFFF681  bl 0x82a5e818
	ctx.lr = 0x82A5F19C;
	sub_82A5E818(ctx, base);
	pc = 0x82A5F19C; continue 'dispatch;
            }
            0x82A5F19C => {
    //   block [0x82A5F19C..0x82A5F1C4)
	// 82A5F19C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5F1A4: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F1A8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1AC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1B0: 9B290014  stb r25, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A5F1B4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1B8: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1BC: 4BFFF6DD  bl 0x82a5e898
	ctx.lr = 0x82A5F1C0;
	sub_82A5E898(ctx, base);
	// 82A5F1C0: 48000074  b 0x82a5f234
	pc = 0x82A5F234; continue 'dispatch;
            }
            0x82A5F1C4 => {
    //   block [0x82A5F1C4..0x82A5F1F8)
	// 82A5F1C4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F1C8: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5F1CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5F1D0: 409A0028  bne cr6, 0x82a5f1f8
	if !ctx.cr[6].eq {
	pc = 0x82A5F1F8; continue 'dispatch;
	}
	// 82A5F1D4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F1D8: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F1DC: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F1E0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F1E4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1E8: 9B270014  stb r25, 0x14(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A5F1EC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F1F0: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F1F4: 48000040  b 0x82a5f234
	pc = 0x82A5F234; continue 'dispatch;
            }
            0x82A5F1F8 => {
    //   block [0x82A5F1F8..0x82A5F210)
	// 82A5F1F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F1FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5F200: 409A0010  bne cr6, 0x82a5f210
	if !ctx.cr[6].eq {
	pc = 0x82A5F210; continue 'dispatch;
	}
	// 82A5F204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5F208: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A5F20C: 4BFFF68D  bl 0x82a5e898
	ctx.lr = 0x82A5F210;
	sub_82A5E898(ctx, base);
	pc = 0x82A5F210; continue 'dispatch;
            }
            0x82A5F210 => {
    //   block [0x82A5F210..0x82A5F234)
	// 82A5F210: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5F218: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F21C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F220: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F224: 9B290014  stb r25, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82A5F228: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F22C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F230: 4BFFF5E9  bl 0x82a5e818
	ctx.lr = 0x82A5F234;
	sub_82A5E818(ctx, base);
	pc = 0x82A5F234; continue 'dispatch;
            }
            0x82A5F234 => {
    //   block [0x82A5F234..0x82A5F248)
	// 82A5F234: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F238: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A5F23C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A5F240: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A5F244: 419AFEF8  beq cr6, 0x82a5f13c
	if ctx.cr[6].eq {
	pc = 0x82A5F13C; continue 'dispatch;
	}
	pc = 0x82A5F248; continue 'dispatch;
            }
            0x82A5F248 => {
    //   block [0x82A5F248..0x82A5F268)
	// 82A5F248: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F24C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A5F250: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A5F254: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A5F258: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F25C: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A5F260: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A5F264: 4824A1E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5F268 size=696
    let mut pc: u32 = 0x82A5F268;
    'dispatch: loop {
        match pc {
            0x82A5F268 => {
    //   block [0x82A5F268..0x82A5F288)
	// 82A5F268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5F26C: 4824A195  bl 0x82ca9400
	ctx.lr = 0x82A5F270;
	sub_82CA93D0(ctx, base);
	// 82A5F270: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5F274: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A5F278: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A5F27C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A5F280: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A5F284: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82A5F288; continue 'dispatch;
            }
            0x82A5F288 => {
    //   block [0x82A5F288..0x82A5F29C)
	// 82A5F288: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F28C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5F290: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82A5F294: 419A0024  beq cr6, 0x82a5f2b8
	if ctx.cr[6].eq {
	pc = 0x82A5F2B8; continue 'dispatch;
	}
	// 82A5F298: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82A5F29C; continue 'dispatch;
            }
            0x82A5F29C => {
    //   block [0x82A5F29C..0x82A5F2B8)
	// 82A5F29C: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A5F2A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F2A4: 7CE05028  lwarx r7, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82A5F2A8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82A5F2AC: 7CE0512D  stwcx. r7, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F2B0: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F2B4: 4082FFE8  bne 0x82a5f29c
	if !ctx.cr[0].eq {
	pc = 0x82A5F29C; continue 'dispatch;
	}
	pc = 0x82A5F2B8; continue 'dispatch;
            }
            0x82A5F2B8 => {
    //   block [0x82A5F2B8..0x82A5F2E0)
	// 82A5F2B8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A5F2BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5F2C0: 4080FFC8  bge 0x82a5f288
	if !ctx.cr[0].lt {
	pc = 0x82A5F288; continue 'dispatch;
	}
	// 82A5F2C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A5F2C8: 3BEBFB60  addi r31, r11, -0x4a0
	ctx.r[31].s64 = ctx.r[11].s64 + -1184;
	// 82A5F2CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F2D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F2D4: 409A000C  bne cr6, 0x82a5f2e0
	if !ctx.cr[6].eq {
	pc = 0x82A5F2E0; continue 'dispatch;
	}
	// 82A5F2D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A5F2DC: 48000010  b 0x82a5f2ec
	pc = 0x82A5F2EC; continue 'dispatch;
            }
            0x82A5F2E0 => {
    //   block [0x82A5F2E0..0x82A5F2EC)
	// 82A5F2E0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A5F2E4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A5F2E8: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82A5F2EC; continue 'dispatch;
            }
            0x82A5F2EC => {
    //   block [0x82A5F2EC..0x82A5F320)
	// 82A5F2EC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F2F0: 3D201FFF  lis r9, 0x1fff
	ctx.r[9].s64 = 536805376;
	// 82A5F2F4: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A5F2F8: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82A5F2FC: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A5F300: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A5F304: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82A5F308: 40980018  bge cr6, 0x82a5f320
	if !ctx.cr[6].lt {
	pc = 0x82A5F320; continue 'dispatch;
	}
	// 82A5F30C: 4BFE81BD  bl 0x82a474c8
	ctx.lr = 0x82A5F310;
	sub_82A474C8(ctx, base);
	// 82A5F310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F314: 4BFFD115  bl 0x82a5c428
	ctx.lr = 0x82A5F318;
	sub_82A5C428(ctx, base);
	// 82A5F318: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5F31C: 4824A134  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5F320 => {
    //   block [0x82A5F320..0x82A5F34C)
	// 82A5F320: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A5F324: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A5F328: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82A5F32C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A5F330: 409800FC  bge cr6, 0x82a5f42c
	if !ctx.cr[6].lt {
	pc = 0x82A5F42C; continue 'dispatch;
	}
	// 82A5F334: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A5F338: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A5F33C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A5F340: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5F344: 41980008  blt cr6, 0x82a5f34c
	if ctx.cr[6].lt {
	pc = 0x82A5F34C; continue 'dispatch;
	}
	// 82A5F348: 7F885214  add r28, r8, r10
	ctx.r[28].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x82A5F34C; continue 'dispatch;
            }
            0x82A5F34C => {
    //   block [0x82A5F34C..0x82A5F36C)
	// 82A5F34C: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A5F350: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A5F354: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82A5F358: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5F35C: 40980010  bge cr6, 0x82a5f36c
	if !ctx.cr[6].lt {
	pc = 0x82A5F36C; continue 'dispatch;
	}
	// 82A5F360: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A5F364: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F368: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	pc = 0x82A5F36C; continue 'dispatch;
            }
            0x82A5F36C => {
    //   block [0x82A5F36C..0x82A5F3E4)
	// 82A5F36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F370: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5F374: 480515E5  bl 0x82ab0958
	ctx.lr = 0x82A5F378;
	sub_82AB0958(ctx, base);
	// 82A5F378: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5F37C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A5F380: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F388: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A5F38C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A5F390: 480002C1  bl 0x82a5f650
	ctx.lr = 0x82A5F394;
	sub_82A5F650(ctx, base);
	// 82A5F394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A5F398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F39C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5F3A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A5F3A4: 4BFFF675  bl 0x82a5ea18
	ctx.lr = 0x82A5F3A8;
	sub_82A5EA18(ctx, base);
	// 82A5F3A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A5F3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F3B0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F3B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5F3B8: 48000299  bl 0x82a5f650
	ctx.lr = 0x82A5F3BC;
	sub_82A5F650(ctx, base);
	// 82A5F3BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F3C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5F3C4: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F3C8: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 82A5F3CC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F3D0: 3B4B0001  addi r26, r11, 1
	ctx.r[26].s64 = ctx.r[11].s64 + 1;
	// 82A5F3D4: 419A002C  beq cr6, 0x82a5f400
	if ctx.cr[6].eq {
	pc = 0x82A5F400; continue 'dispatch;
	}
	// 82A5F3D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5F3DC: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F3E0: 419A001C  beq cr6, 0x82a5f3fc
	if ctx.cr[6].eq {
	pc = 0x82A5F3FC; continue 'dispatch;
	}
	pc = 0x82A5F3E4; continue 'dispatch;
            }
            0x82A5F3E4 => {
    //   block [0x82A5F3E4..0x82A5F3FC)
	// 82A5F3E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A5F3E8: 4BFFD041  bl 0x82a5c428
	ctx.lr = 0x82A5F3EC;
	sub_82A5C428(ctx, base);
	// 82A5F3EC: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82A5F3F0: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F3F4: 409AFFF0  bne cr6, 0x82a5f3e4
	if !ctx.cr[6].eq {
	pc = 0x82A5F3E4; continue 'dispatch;
	}
	// 82A5F3F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A5F3FC; continue 'dispatch;
            }
            0x82A5F3FC => {
    //   block [0x82A5F3FC..0x82A5F400)
	// 82A5F3FC: 4B7BC93D  bl 0x8221bd38
	ctx.lr = 0x82A5F400;
	sub_8221BD38(ctx, base);
	pc = 0x82A5F400; continue 'dispatch;
            }
            0x82A5F400 => {
    //   block [0x82A5F400..0x82A5F42C)
	// 82A5F400: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5F404: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A5F408: 574A1838  slwi r10, r26, 3
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5F40C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5F410: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A5F414: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A5F418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F41C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A5F420: 4BFFD009  bl 0x82a5c428
	ctx.lr = 0x82A5F424;
	sub_82A5C428(ctx, base);
	// 82A5F424: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5F428: 4824A028  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5F42C => {
    //   block [0x82A5F42C..0x82A5F484)
	// 82A5F42C: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5F430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F434: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82A5F438: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F43C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A5F440: 4098006C  bge cr6, 0x82a5f4ac
	if !ctx.cr[6].lt {
	pc = 0x82A5F4AC; continue 'dispatch;
	}
	// 82A5F444: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A5F448: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5F44C: 48000205  bl 0x82a5f650
	ctx.lr = 0x82A5F450;
	sub_82A5F650(ctx, base);
	// 82A5F450: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F458: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A5F45C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5F460: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F464: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A5F468: 4BFFF5B1  bl 0x82a5ea18
	ctx.lr = 0x82A5F46C;
	sub_82A5EA18(ctx, base);
	// 82A5F46C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F470: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A5F474: 3BABFFF8  addi r29, r11, -8
	ctx.r[29].s64 = ctx.r[11].s64 + -8;
	// 82A5F478: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A5F47C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F480: 419A0090  beq cr6, 0x82a5f510
	if ctx.cr[6].eq {
	pc = 0x82A5F510; continue 'dispatch;
	}
	pc = 0x82A5F484; continue 'dispatch;
            }
            0x82A5F484 => {
    //   block [0x82A5F484..0x82A5F4AC)
	// 82A5F484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5F488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5F48C: 480004D5  bl 0x82a5f960
	ctx.lr = 0x82A5F490;
	sub_82A5F960(ctx, base);
	// 82A5F490: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A5F494: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F498: 409AFFEC  bne cr6, 0x82a5f484
	if !ctx.cr[6].eq {
	pc = 0x82A5F484; continue 'dispatch;
	}
	// 82A5F49C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F4A0: 4BFFCF89  bl 0x82a5c428
	ctx.lr = 0x82A5F4A4;
	sub_82A5C428(ctx, base);
	// 82A5F4A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5F4A8: 48249FA8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5F4AC => {
    //   block [0x82A5F4AC..0x82A5F4D0)
	// 82A5F4AC: 3BA5FFF8  addi r29, r5, -8
	ctx.r[29].s64 = ctx.r[5].s64 + -8;
	// 82A5F4B0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A5F4B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5F4B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A5F4BC: 48000195  bl 0x82a5f650
	ctx.lr = 0x82A5F4C0;
	sub_82A5F650(ctx, base);
	// 82A5F4C0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A5F4C4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F4C8: 419A0020  beq cr6, 0x82a5f4e8
	if ctx.cr[6].eq {
	pc = 0x82A5F4E8; continue 'dispatch;
	}
	// 82A5F4CC: 7FFDE050  subf r31, r29, r28
	ctx.r[31].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	pc = 0x82A5F4D0; continue 'dispatch;
            }
            0x82A5F4D0 => {
    //   block [0x82A5F4D0..0x82A5F4E8)
	// 82A5F4D0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82A5F4D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A5F4D8: 7C7FEA14  add r3, r31, r29
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 82A5F4DC: 48000485  bl 0x82a5f960
	ctx.lr = 0x82A5F4E0;
	sub_82A5F960(ctx, base);
	// 82A5F4E0: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A5F4E4: 409AFFEC  bne cr6, 0x82a5f4d0
	if !ctx.cr[6].eq {
	pc = 0x82A5F4D0; continue 'dispatch;
	}
	pc = 0x82A5F4E8; continue 'dispatch;
            }
            0x82A5F4E8 => {
    //   block [0x82A5F4E8..0x82A5F4F8)
	// 82A5F4E8: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82A5F4EC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A5F4F0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F4F4: 419A001C  beq cr6, 0x82a5f510
	if ctx.cr[6].eq {
	pc = 0x82A5F510; continue 'dispatch;
	}
	pc = 0x82A5F4F8; continue 'dispatch;
            }
            0x82A5F4F8 => {
    //   block [0x82A5F4F8..0x82A5F510)
	// 82A5F4F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5F4FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F500: 48000461  bl 0x82a5f960
	ctx.lr = 0x82A5F504;
	sub_82A5F960(ctx, base);
	// 82A5F504: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5F508: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5F50C: 409AFFEC  bne cr6, 0x82a5f4f8
	if !ctx.cr[6].eq {
	pc = 0x82A5F4F8; continue 'dispatch;
	}
	pc = 0x82A5F510; continue 'dispatch;
            }
            0x82A5F510 => {
    //   block [0x82A5F510..0x82A5F520)
	// 82A5F510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F514: 4BFFCF15  bl 0x82a5c428
	ctx.lr = 0x82A5F518;
	sub_82A5C428(ctx, base);
	// 82A5F518: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5F51C: 48249F34  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A5F520 size=200
    let mut pc: u32 = 0x82A5F520;
    'dispatch: loop {
        match pc {
            0x82A5F520 => {
    //   block [0x82A5F520..0x82A5F554)
	// 82A5F520: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A5F524: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82A5F528: 7D692050  subf r11, r9, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82A5F52C: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5F530: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82A5F534: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5F538: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A5F53C: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5F540: 7C6B2A14  add r3, r11, r5
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A5F544: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A5F548: 3949000C  addi r10, r9, 0xc
	ctx.r[10].s64 = ctx.r[9].s64 + 12;
	// 82A5F54C: 39650008  addi r11, r5, 8
	ctx.r[11].s64 = ctx.r[5].s64 + 8;
	// 82A5F550: 7D254850  subf r9, r5, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	pc = 0x82A5F554; continue 'dispatch;
            }
            0x82A5F554 => {
    //   block [0x82A5F554..0x82A5F5E8)
	// 82A5F554: 810AFFF4  lwz r8, -0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A5F558: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 82A5F55C: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82A5F560: 80CAFFF8  lwz r6, -8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5F564: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 82A5F568: 7C095C2E  lfsx f0, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A5F56C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A5F570: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F574: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A5F578: 890A0004  lbz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F57C: 990B0008  stb r8, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 82A5F580: 88EA0005  lbz r7, 5(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 82A5F584: 98EB0009  stb r7, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[7].u8 ) };
	// 82A5F588: 88CA0006  lbz r6, 6(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82A5F58C: 98CB000A  stb r6, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[6].u8 ) };
	// 82A5F590: 88AA0007  lbz r5, 7(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) } as u64;
	// 82A5F594: 98AB000B  stb r5, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[5].u8 ) };
	// 82A5F598: 890A0008  lbz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A5F59C: 990B000C  stb r8, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 82A5F5A0: 88EA0009  lbz r7, 9(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(9 as u32) ) } as u64;
	// 82A5F5A4: 98EB000D  stb r7, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[7].u8 ) };
	// 82A5F5A8: 88CA000A  lbz r6, 0xa(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(10 as u32) ) } as u64;
	// 82A5F5AC: 98CB000E  stb r6, 0xe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[6].u8 ) };
	// 82A5F5B0: 88AA000B  lbz r5, 0xb(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(11 as u32) ) } as u64;
	// 82A5F5B4: 98AB000F  stb r5, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[5].u8 ) };
	// 82A5F5B8: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A5F5BC: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A5F5C0: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A5F5C4: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82A5F5C8: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A5F5CC: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 82A5F5D0: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A5F5D4: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82A5F5D8: 38EAFFF4  addi r7, r10, -0xc
	ctx.r[7].s64 = ctx.r[10].s64 + -12;
	// 82A5F5DC: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A5F5E0: 409AFF74  bne cr6, 0x82a5f554
	if !ctx.cr[6].eq {
	pc = 0x82A5F554; continue 'dispatch;
	}
	// 82A5F5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5F5E8 size=104
    let mut pc: u32 = 0x82A5F5E8;
    'dispatch: loop {
        match pc {
            0x82A5F5E8 => {
    //   block [0x82A5F5E8..0x82A5F5F8)
	// 82A5F5E8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A5F5EC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5F5F0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A5F5F4: 7D432050  subf r10, r3, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	pc = 0x82A5F5F8; continue 'dispatch;
            }
            0x82A5F5F8 => {
    //   block [0x82A5F5F8..0x82A5F620)
	// 82A5F5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5F5FC: 419A0040  beq cr6, 0x82a5f63c
	if ctx.cr[6].eq {
	pc = 0x82A5F63C; continue 'dispatch;
	}
	// 82A5F600: 7D2A182E  lwzx r9, r10, r3
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A5F604: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82A5F608: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A5F60C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A5F610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F614: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5F618: 419A0024  beq cr6, 0x82a5f63c
	if ctx.cr[6].eq {
	pc = 0x82A5F63C; continue 'dispatch;
	}
	// 82A5F61C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5F620; continue 'dispatch;
            }
            0x82A5F620 => {
    //   block [0x82A5F620..0x82A5F63C)
	// 82A5F620: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A5F624: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F628: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A5F62C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A5F630: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F634: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F638: 4082FFE8  bne 0x82a5f620
	if !ctx.cr[0].eq {
	pc = 0x82A5F620; continue 'dispatch;
	}
	pc = 0x82A5F63C; continue 'dispatch;
            }
            0x82A5F63C => {
    //   block [0x82A5F63C..0x82A5F650)
	// 82A5F63C: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82A5F640: 7D6A1A14  add r11, r10, r3
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82A5F644: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5F648: 409AFFB0  bne cr6, 0x82a5f5f8
	if !ctx.cr[6].eq {
	pc = 0x82A5F5F8; continue 'dispatch;
	}
	// 82A5F64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A5F650 size=116
    let mut pc: u32 = 0x82A5F650;
    'dispatch: loop {
        match pc {
            0x82A5F650 => {
    //   block [0x82A5F650..0x82A5F660)
	// 82A5F650: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82A5F654: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A5F658: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5F65C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82A5F660; continue 'dispatch;
            }
            0x82A5F660 => {
    //   block [0x82A5F660..0x82A5F674)
	// 82A5F660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5F664: 419A004C  beq cr6, 0x82a5f6b0
	if ctx.cr[6].eq {
	pc = 0x82A5F6B0; continue 'dispatch;
	}
	// 82A5F668: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A5F66C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A5F670: 7CE81850  subf r7, r8, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	pc = 0x82A5F674; continue 'dispatch;
            }
            0x82A5F674 => {
    //   block [0x82A5F674..0x82A5F688)
	// 82A5F674: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A5F67C: 7D47592E  stwx r10, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82A5F680: 419A0024  beq cr6, 0x82a5f6a4
	if ctx.cr[6].eq {
	pc = 0x82A5F6A4; continue 'dispatch;
	}
	// 82A5F684: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	pc = 0x82A5F688; continue 'dispatch;
            }
            0x82A5F688 => {
    //   block [0x82A5F688..0x82A5F6A4)
	// 82A5F688: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 82A5F68C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F690: 7CC05028  lwarx r6, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 82A5F694: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82A5F698: 7CC0512D  stwcx. r6, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F69C: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F6A0: 4082FFE8  bne 0x82a5f688
	if !ctx.cr[0].eq {
	pc = 0x82A5F688; continue 'dispatch;
	}
	pc = 0x82A5F6A4; continue 'dispatch;
            }
            0x82A5F6A4 => {
    //   block [0x82A5F6A4..0x82A5F6B0)
	// 82A5F6A4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A5F6A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A5F6AC: 4080FFC8  bge 0x82a5f674
	if !ctx.cr[0].lt {
	pc = 0x82A5F674; continue 'dispatch;
	}
	pc = 0x82A5F6B0; continue 'dispatch;
            }
            0x82A5F6B0 => {
    //   block [0x82A5F6B0..0x82A5F6C4)
	// 82A5F6B0: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82A5F6B4: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82A5F6B8: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A5F6BC: 409AFFA4  bne cr6, 0x82a5f660
	if !ctx.cr[6].eq {
	pc = 0x82A5F660; continue 'dispatch;
	}
	// 82A5F6C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A5F6C8 size=452
    let mut pc: u32 = 0x82A5F6C8;
    'dispatch: loop {
        match pc {
            0x82A5F6C8 => {
    //   block [0x82A5F6C8..0x82A5F704)
	// 82A5F6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5F6CC: 48249D31  bl 0x82ca93fc
	ctx.lr = 0x82A5F6D0;
	sub_82CA93D0(ctx, base);
	// 82A5F6D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5F6D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5F6D8: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82A5F6DC: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 82A5F6E0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A5F6E4: FB2100B8  std r25, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u64 ) };
	// 82A5F6E8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A5F6EC: 836100B4  lwz r27, 0xb4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5F6F0: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A5F6F4: 7D7BE850  subf r11, r27, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 82A5F6F8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F6FC: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A5F700: 409900A0  ble cr6, 0x82a5f7a0
	if !ctx.cr[6].gt {
	pc = 0x82A5F7A0; continue 'dispatch;
	}
	pc = 0x82A5F704; continue 'dispatch;
            }
            0x82A5F704 => {
    //   block [0x82A5F704..0x82A5F778)
	// 82A5F704: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A5F708: 409900B8  ble cr6, 0x82a5f7c0
	if !ctx.cr[6].gt {
	pc = 0x82A5F7C0; continue 'dispatch;
	}
	// 82A5F70C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A5F710: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A5F714: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5F718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A5F71C: 48000305  bl 0x82a5fa20
	ctx.lr = 0x82A5F720;
	sub_82A5FA20(ctx, base);
	// 82A5F720: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82A5F724: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5F728: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A5F72C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5F730: 7CE9E850  subf r7, r9, r29
	ctx.r[7].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	// 82A5F734: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A5F738: 7CDB4050  subf r6, r27, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[27].s64;
	// 82A5F73C: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A5F740: 54E50038  rlwinm r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5F744: 54C40038  rlwinm r4, r6, 0, 0, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5F748: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A5F74C: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A5F750: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A5F754: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A5F758: 40980020  bge cr6, 0x82a5f778
	if !ctx.cr[6].lt {
	pc = 0x82A5F778; continue 'dispatch;
	}
	// 82A5F75C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5F760: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5F764: 4BFFFF65  bl 0x82a5f6c8
	ctx.lr = 0x82A5F768;
	sub_82A5F6C8(ctx, base);
	// 82A5F768: EB810058  ld r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5F76C: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 82A5F770: 836100B4  lwz r27, 0xb4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5F774: 4800001C  b 0x82a5f790
	pc = 0x82A5F790; continue 'dispatch;
            }
            0x82A5F778 => {
    //   block [0x82A5F778..0x82A5F790)
	// 82A5F778: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A5F77C: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5F780: 4BFFFF49  bl 0x82a5f6c8
	ctx.lr = 0x82A5F784;
	sub_82A5F6C8(ctx, base);
	// 82A5F784: EB210050  ld r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5F788: FB2100B8  std r25, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u64 ) };
	// 82A5F78C: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	pc = 0x82A5F790; continue 'dispatch;
            }
            0x82A5F790 => {
    //   block [0x82A5F790..0x82A5F7A0)
	// 82A5F790: 7D7BE850  subf r11, r27, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 82A5F794: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F798: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A5F79C: 4199FF68  bgt cr6, 0x82a5f704
	if ctx.cr[6].gt {
	pc = 0x82A5F704; continue 'dispatch;
	}
	pc = 0x82A5F7A0; continue 'dispatch;
            }
            0x82A5F7A0 => {
    //   block [0x82A5F7A0..0x82A5F7B8)
	// 82A5F7A0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A5F7A4: 40990014  ble cr6, 0x82a5f7b8
	if !ctx.cr[6].gt {
	pc = 0x82A5F7B8; continue 'dispatch;
	}
	// 82A5F7A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5F7AC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A5F7B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5F7B4: 4800054D  bl 0x82a5fd00
	ctx.lr = 0x82A5F7B8;
	sub_82A5FD00(ctx, base);
	pc = 0x82A5F7B8; continue 'dispatch;
            }
            0x82A5F7B8 => {
    //   block [0x82A5F7B8..0x82A5F7C0)
	// 82A5F7B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A5F7BC: 48249C90  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A5F7C0 => {
    //   block [0x82A5F7C0..0x82A5F7EC)
	// 82A5F7C0: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A5F7C4: 4099FFDC  ble cr6, 0x82a5f7a0
	if !ctx.cr[6].gt {
	pc = 0x82A5F7A0; continue 'dispatch;
	}
	// 82A5F7C8: 7D7BE850  subf r11, r27, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 82A5F7CC: 7D7A1E70  srawi r26, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A5F7D0: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 82A5F7D4: 40990078  ble cr6, 0x82a5f84c
	if !ctx.cr[6].gt {
	pc = 0x82A5F84C; continue 'dispatch;
	}
	// 82A5F7D8: 7F4B0E70  srawi r11, r26, 1
	ctx.xer.ca = (ctx.r[26].s32 < 0) && ((ctx.r[26].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[26].s32 >> 1) as i64;
	// 82A5F7DC: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A5F7E0: 4081006C  ble 0x82a5f84c
	if !ctx.cr[0].gt {
	pc = 0x82A5F84C; continue 'dispatch;
	}
	// 82A5F7E4: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5F7E8: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82A5F7EC; continue 'dispatch;
            }
            0x82A5F7EC => {
    //   block [0x82A5F7EC..0x82A5F810)
	// 82A5F7EC: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82A5F7F0: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82A5F7F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F7F8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F7FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F800: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5F804: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A5F808: 419A0024  beq cr6, 0x82a5f82c
	if ctx.cr[6].eq {
	pc = 0x82A5F82C; continue 'dispatch;
	}
	// 82A5F80C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5F810; continue 'dispatch;
            }
            0x82A5F810 => {
    //   block [0x82A5F810..0x82A5F82C)
	// 82A5F810: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5F814: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F818: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5F81C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5F820: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F824: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F828: 4082FFE8  bne 0x82a5f810
	if !ctx.cr[0].eq {
	pc = 0x82A5F810; continue 'dispatch;
	}
	pc = 0x82A5F82C; continue 'dispatch;
            }
            0x82A5F82C => {
    //   block [0x82A5F82C..0x82A5F84C)
	// 82A5F82C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A5F830: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A5F834: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A5F838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5F83C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5F840: 480005B1  bl 0x82a5fdf0
	ctx.lr = 0x82A5F844;
	sub_82A5FDF0(ctx, base);
	// 82A5F844: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A5F848: 4199FFA4  bgt cr6, 0x82a5f7ec
	if ctx.cr[6].gt {
	pc = 0x82A5F7EC; continue 'dispatch;
	}
	pc = 0x82A5F84C; continue 'dispatch;
            }
            0x82A5F84C => {
    //   block [0x82A5F84C..0x82A5F85C)
	// 82A5F84C: FB210050  std r25, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u64 ) };
	// 82A5F850: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 82A5F854: 4099FF64  ble cr6, 0x82a5f7b8
	if !ctx.cr[6].gt {
	pc = 0x82A5F7B8; continue 'dispatch;
	}
	// 82A5F858: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A5F85C; continue 'dispatch;
            }
            0x82A5F85C => {
    //   block [0x82A5F85C..0x82A5F88C)
	// 82A5F85C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A5F860: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5F864: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5F868: 48000719  bl 0x82a5ff80
	ctx.lr = 0x82A5F86C;
	sub_82A5FF80(ctx, base);
	// 82A5F86C: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A5F870: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A5F874: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5F878: 556A0038  rlwinm r10, r11, 0, 0, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5F87C: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 82A5F880: 4199FFDC  bgt cr6, 0x82a5f85c
	if ctx.cr[6].gt {
	pc = 0x82A5F85C; continue 'dispatch;
	}
	// 82A5F884: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A5F888: 48249BC4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5F890 size=204
    let mut pc: u32 = 0x82A5F890;
    'dispatch: loop {
        match pc {
            0x82A5F890 => {
    //   block [0x82A5F890..0x82A5F8D4)
	// 82A5F890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5F894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A5F898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A5F89C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A5F8A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5F8A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A5F8A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A5F8AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F8B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5F8B4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F8B8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F8BC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A5F8C0: 419A0080  beq cr6, 0x82a5f940
	if ctx.cr[6].eq {
	pc = 0x82A5F940; continue 'dispatch;
	}
	// 82A5F8C4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A5F8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5F8CC: 419A0044  beq cr6, 0x82a5f910
	if ctx.cr[6].eq {
	pc = 0x82A5F910; continue 'dispatch;
	}
	// 82A5F8D0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5F8D4; continue 'dispatch;
            }
            0x82A5F8D4 => {
    //   block [0x82A5F8D4..0x82A5F908)
	// 82A5F8D4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5F8D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F8DC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5F8E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5F8E4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F8E8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F8EC: 4082FFE8  bne 0x82a5f8d4
	if !ctx.cr[0].eq {
	pc = 0x82A5F8D4; continue 'dispatch;
	}
	// 82A5F8F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5F8F4: 409A0014  bne cr6, 0x82a5f908
	if !ctx.cr[6].eq {
	pc = 0x82A5F908; continue 'dispatch;
	}
	// 82A5F8F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F8FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F900: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5F904: 4E800421  bctrl
	ctx.lr = 0x82A5F908;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5F908 => {
    //   block [0x82A5F908..0x82A5F910)
	// 82A5F908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A5F90C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A5F910; continue 'dispatch;
            }
            0x82A5F910 => {
    //   block [0x82A5F910..0x82A5F924)
	// 82A5F910: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F918: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A5F91C: 419A0024  beq cr6, 0x82a5f940
	if ctx.cr[6].eq {
	pc = 0x82A5F940; continue 'dispatch;
	}
	// 82A5F920: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5F924; continue 'dispatch;
            }
            0x82A5F924 => {
    //   block [0x82A5F924..0x82A5F940)
	// 82A5F924: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5F928: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F92C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5F930: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5F934: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F938: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F93C: 4082FFE8  bne 0x82a5f924
	if !ctx.cr[0].eq {
	pc = 0x82A5F924; continue 'dispatch;
	}
	pc = 0x82A5F940; continue 'dispatch;
            }
            0x82A5F940 => {
    //   block [0x82A5F940..0x82A5F95C)
	// 82A5F940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A5F944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A5F948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5F94C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A5F950: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A5F954: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A5F958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5F960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5F960 size=188
    let mut pc: u32 = 0x82A5F960;
    'dispatch: loop {
        match pc {
            0x82A5F960 => {
    //   block [0x82A5F960..0x82A5F980)
	// 82A5F960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5F964: 48249AA1  bl 0x82ca9404
	ctx.lr = 0x82A5F968;
	sub_82CA93D0(ctx, base);
	// 82A5F968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5F96C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A5F970: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82A5F974: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A5F978: 7FDC2050  subf r30, r28, r4
	ctx.r[30].s64 = ctx.r[4].s64 - ctx.r[28].s64;
	// 82A5F97C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82A5F980; continue 'dispatch;
            }
            0x82A5F980 => {
    //   block [0x82A5F980..0x82A5F99C)
	// 82A5F980: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F984: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A5F988: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5F98C: 419A0078  beq cr6, 0x82a5fa04
	if ctx.cr[6].eq {
	pc = 0x82A5FA04; continue 'dispatch;
	}
	// 82A5F990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5F994: 419A0040  beq cr6, 0x82a5f9d4
	if ctx.cr[6].eq {
	pc = 0x82A5F9D4; continue 'dispatch;
	}
	// 82A5F998: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5F99C; continue 'dispatch;
            }
            0x82A5F99C => {
    //   block [0x82A5F99C..0x82A5F9D0)
	// 82A5F99C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A5F9A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F9A4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A5F9A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A5F9AC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F9B0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F9B4: 4082FFE8  bne 0x82a5f99c
	if !ctx.cr[0].eq {
	pc = 0x82A5F99C; continue 'dispatch;
	}
	// 82A5F9B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5F9BC: 409A0014  bne cr6, 0x82a5f9d0
	if !ctx.cr[6].eq {
	pc = 0x82A5F9D0; continue 'dispatch;
	}
	// 82A5F9C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5F9C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5F9C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5F9CC: 4E800421  bctrl
	ctx.lr = 0x82A5F9D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5F9D0 => {
    //   block [0x82A5F9D0..0x82A5F9D4)
	// 82A5F9D0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82A5F9D4; continue 'dispatch;
            }
            0x82A5F9D4 => {
    //   block [0x82A5F9D4..0x82A5F9E8)
	// 82A5F9D4: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A5F9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5F9DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5F9E0: 419A0024  beq cr6, 0x82a5fa04
	if ctx.cr[6].eq {
	pc = 0x82A5FA04; continue 'dispatch;
	}
	// 82A5F9E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5F9E8; continue 'dispatch;
            }
            0x82A5F9E8 => {
    //   block [0x82A5F9E8..0x82A5FA04)
	// 82A5F9E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5F9EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5F9F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5F9F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5F9F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5F9FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FA00: 4082FFE8  bne 0x82a5f9e8
	if !ctx.cr[0].eq {
	pc = 0x82A5F9E8; continue 'dispatch;
	}
	pc = 0x82A5FA04; continue 'dispatch;
            }
            0x82A5FA04 => {
    //   block [0x82A5FA04..0x82A5FA1C)
	// 82A5FA04: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A5FA08: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A5FA0C: 4082FF74  bne 0x82a5f980
	if !ctx.cr[0].eq {
	pc = 0x82A5F980; continue 'dispatch;
	}
	// 82A5FA10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A5FA14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A5FA18: 48249A3C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5FA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A5FA20 size=736
    let mut pc: u32 = 0x82A5FA20;
    'dispatch: loop {
        match pc {
            0x82A5FA20 => {
    //   block [0x82A5FA20..0x82A5FAA4)
	// 82A5FA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5FA24: 482499D5  bl 0x82ca93f8
	ctx.lr = 0x82A5FA28;
	sub_82CA93D0(ctx, base);
	// 82A5FA28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5FA2C: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 82A5FA30: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A5FA34: F8A100E0  std r5, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[5].u64 ) };
	// 82A5FA38: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A5FA3C: 832100E4  lwz r25, 0xe4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A5FA40: 3979FFF8  addi r11, r25, -8
	ctx.r[11].s64 = ctx.r[25].s64 + -8;
	// 82A5FA44: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A5FA48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A5FA4C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A5FA50: 834100DC  lwz r26, 0xdc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A5FA54: 7D5AC850  subf r10, r26, r25
	ctx.r[10].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 82A5FA58: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A5FA5C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A5FA60: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82A5FA64: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 82A5FA68: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FA6C: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A5FA70: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A5FA74: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5FA78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A5FA7C: 4812A86D  bl 0x82b8a2e8
	ctx.lr = 0x82A5FA80;
	sub_82B8A2E8(ctx, base);
	// 82A5FA80: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 82A5FA84: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 82A5FA88: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5FA8C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A5FA90: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A5FA94: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A5FA98: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5FA9C: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82A5FAA0: 40980030  bge cr6, 0x82a5fad0
	if !ctx.cr[6].lt {
	pc = 0x82A5FAD0; continue 'dispatch;
	}
	pc = 0x82A5FAA4; continue 'dispatch;
            }
            0x82A5FAA4 => {
    //   block [0x82A5FAA4..0x82A5FAD0)
	// 82A5FAA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FAA8: 813FFFF8  lwz r9, -8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5FAAC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5FAB0: 41980020  blt cr6, 0x82a5fad0
	if ctx.cr[6].lt {
	pc = 0x82A5FAD0; continue 'dispatch;
	}
	// 82A5FAB4: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A5FAB8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5FABC: 41980014  blt cr6, 0x82a5fad0
	if ctx.cr[6].lt {
	pc = 0x82A5FAD0; continue 'dispatch;
	}
	// 82A5FAC0: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A5FAC4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5FAC8: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5FACC: 4198FFD8  blt cr6, 0x82a5faa4
	if ctx.cr[6].lt {
	pc = 0x82A5FAA4; continue 'dispatch;
	}
	pc = 0x82A5FAD0; continue 'dispatch;
            }
            0x82A5FAD0 => {
    //   block [0x82A5FAD0..0x82A5FAE0)
	// 82A5FAD0: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A5FAD4: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5FAD8: 40980028  bge cr6, 0x82a5fb00
	if !ctx.cr[6].lt {
	pc = 0x82A5FB00; continue 'dispatch;
	}
	// 82A5FADC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A5FAE0; continue 'dispatch;
            }
            0x82A5FAE0 => {
    //   block [0x82A5FAE0..0x82A5FB00)
	// 82A5FAE0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FAE4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5FAE8: 41990018  bgt cr6, 0x82a5fb00
	if ctx.cr[6].gt {
	pc = 0x82A5FB00; continue 'dispatch;
	}
	// 82A5FAEC: 41980014  blt cr6, 0x82a5fb00
	if ctx.cr[6].lt {
	pc = 0x82A5FB00; continue 'dispatch;
	}
	// 82A5FAF0: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82A5FAF4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A5FAF8: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5FAFC: 4198FFE4  blt cr6, 0x82a5fae0
	if ctx.cr[6].lt {
	pc = 0x82A5FAE0; continue 'dispatch;
	}
	pc = 0x82A5FB00; continue 'dispatch;
            }
            0x82A5FB00 => {
    //   block [0x82A5FB00..0x82A5FB18)
	// 82A5FB00: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5FB04: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5FB08: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A5FB0C: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82A5FB10: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A5FB14: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x82A5FB18; continue 'dispatch;
            }
            0x82A5FB18 => {
    //   block [0x82A5FB18..0x82A5FB20)
	// 82A5FB18: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5FB1C: 40980058  bge cr6, 0x82a5fb74
	if !ctx.cr[6].lt {
	pc = 0x82A5FB74; continue 'dispatch;
	}
	pc = 0x82A5FB20; continue 'dispatch;
            }
            0x82A5FB20 => {
    //   block [0x82A5FB20..0x82A5FB64)
	// 82A5FB20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FB24: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FB28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5FB2C: 41990038  bgt cr6, 0x82a5fb64
	if ctx.cr[6].gt {
	pc = 0x82A5FB64; continue 'dispatch;
	}
	// 82A5FB30: 41980044  blt cr6, 0x82a5fb74
	if ctx.cr[6].lt {
	pc = 0x82A5FB74; continue 'dispatch;
	}
	// 82A5FB34: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5FB38: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82A5FB3C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FB40: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82A5FB44: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A5FB48: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82A5FB4C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A5FB50: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A5FB54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FB58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5FB5C: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A5FB60: 4BB087F9  bl 0x82568358
	ctx.lr = 0x82A5FB64;
	sub_82568358(ctx, base);
	pc = 0x82A5FB64; continue 'dispatch;
            }
            0x82A5FB64 => {
    //   block [0x82A5FB64..0x82A5FB74)
	// 82A5FB64: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A5FB68: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A5FB6C: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5FB70: 4198FFB0  blt cr6, 0x82a5fb20
	if ctx.cr[6].lt {
	pc = 0x82A5FB20; continue 'dispatch;
	}
	pc = 0x82A5FB74; continue 'dispatch;
            }
            0x82A5FB74 => {
    //   block [0x82A5FB74..0x82A5FB7C)
	// 82A5FB74: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A5FB78: 40990058  ble cr6, 0x82a5fbd0
	if !ctx.cr[6].gt {
	pc = 0x82A5FBD0; continue 'dispatch;
	}
	pc = 0x82A5FB7C; continue 'dispatch;
            }
            0x82A5FB7C => {
    //   block [0x82A5FB7C..0x82A5FBC0)
	// 82A5FB7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FB80: 3BDCFFF8  addi r30, r28, -8
	ctx.r[30].s64 = ctx.r[28].s64 + -8;
	// 82A5FB84: 815CFFF8  lwz r10, -8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5FB88: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5FB8C: 41980034  blt cr6, 0x82a5fbc0
	if ctx.cr[6].lt {
	pc = 0x82A5FBC0; continue 'dispatch;
	}
	// 82A5FB90: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FB94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A5FB98: 41980034  blt cr6, 0x82a5fbcc
	if ctx.cr[6].lt {
	pc = 0x82A5FBCC; continue 'dispatch;
	}
	// 82A5FB9C: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A5FBA0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FBA4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82A5FBA8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5FBAC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A5FBB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FBB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5FBB8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5FBBC: 4BB0879D  bl 0x82568358
	ctx.lr = 0x82A5FBC0;
	sub_82568358(ctx, base);
	pc = 0x82A5FBC0; continue 'dispatch;
            }
            0x82A5FBC0 => {
    //   block [0x82A5FBC0..0x82A5FBCC)
	// 82A5FBC0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A5FBC4: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5FBC8: 4198FFB4  blt cr6, 0x82a5fb7c
	if ctx.cr[6].lt {
	pc = 0x82A5FB7C; continue 'dispatch;
	}
	pc = 0x82A5FBCC; continue 'dispatch;
            }
            0x82A5FBCC => {
    //   block [0x82A5FBCC..0x82A5FBD0)
	// 82A5FBCC: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	pc = 0x82A5FBD0; continue 'dispatch;
            }
            0x82A5FBD0 => {
    //   block [0x82A5FBD0..0x82A5FC00)
	// 82A5FBD0: 409A0080  bne cr6, 0x82a5fc50
	if !ctx.cr[6].eq {
	pc = 0x82A5FC50; continue 'dispatch;
	}
	// 82A5FBD4: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5FBD8: 419A010C  beq cr6, 0x82a5fce4
	if ctx.cr[6].eq {
	pc = 0x82A5FCE4; continue 'dispatch;
	}
	// 82A5FBDC: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5FBE0: 419A0020  beq cr6, 0x82a5fc00
	if ctx.cr[6].eq {
	pc = 0x82A5FC00; continue 'dispatch;
	}
	// 82A5FBE4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FBE8: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82A5FBEC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FBF0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A5FBF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5FBF8: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5FBFC: 4BB0875D  bl 0x82568358
	ctx.lr = 0x82A5FC00;
	sub_82568358(ctx, base);
	pc = 0x82A5FC00; continue 'dispatch;
            }
            0x82A5FC00 => {
    //   block [0x82A5FC00..0x82A5FC50)
	// 82A5FC00: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5FC04: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82A5FC08: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A5FC0C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A5FC10: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5FC14: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A5FC18: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A5FC1C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5FC20: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A5FC24: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82A5FC28: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5FC2C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A5FC30: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A5FC34: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FC38: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A5FC3C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FC40: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A5FC44: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A5FC48: 4BB08711  bl 0x82568358
	ctx.lr = 0x82A5FC4C;
	sub_82568358(ctx, base);
	// 82A5FC4C: 4BFFFECC  b 0x82a5fb18
	pc = 0x82A5FB18; continue 'dispatch;
            }
            0x82A5FC50 => {
    //   block [0x82A5FC50..0x82A5FC88)
	// 82A5FC50: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A5FC54: 3B9CFFF8  addi r28, r28, -8
	ctx.r[28].s64 = ctx.r[28].s64 + -8;
	// 82A5FC58: 409A0058  bne cr6, 0x82a5fcb0
	if !ctx.cr[6].eq {
	pc = 0x82A5FCB0; continue 'dispatch;
	}
	// 82A5FC5C: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A5FC60: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5FC64: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5FC68: 419A0020  beq cr6, 0x82a5fc88
	if ctx.cr[6].eq {
	pc = 0x82A5FC88; continue 'dispatch;
	}
	// 82A5FC6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FC70: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82A5FC74: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FC78: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82A5FC7C: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5FC80: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5FC84: 4BB086D5  bl 0x82568358
	ctx.lr = 0x82A5FC88;
	sub_82568358(ctx, base);
	pc = 0x82A5FC88; continue 'dispatch;
            }
            0x82A5FC88 => {
    //   block [0x82A5FC88..0x82A5FCB0)
	// 82A5FC88: 3B7BFFF8  addi r27, r27, -8
	ctx.r[27].s64 = ctx.r[27].s64 + -8;
	// 82A5FC8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FC90: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A5FC94: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82A5FC98: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A5FC9C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FCA0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5FCA4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A5FCA8: 4BB086B1  bl 0x82568358
	ctx.lr = 0x82A5FCAC;
	sub_82568358(ctx, base);
	// 82A5FCAC: 4BFFFE6C  b 0x82a5fb18
	pc = 0x82A5FB18; continue 'dispatch;
            }
            0x82A5FCB0 => {
    //   block [0x82A5FCB0..0x82A5FCE4)
	// 82A5FCB0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A5FCB4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A5FCB8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FCBC: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82A5FCC0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A5FCC4: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A5FCC8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A5FCCC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A5FCD0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FCD4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A5FCD8: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A5FCDC: 4BB0867D  bl 0x82568358
	ctx.lr = 0x82A5FCE0;
	sub_82568358(ctx, base);
	// 82A5FCE0: 4BFFFE38  b 0x82a5fb18
	pc = 0x82A5FB18; continue 'dispatch;
            }
            0x82A5FCE4 => {
    //   block [0x82A5FCE4..0x82A5FD00)
	// 82A5FCE4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5FCE8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A5FCEC: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5FCF0: F9780000  std r11, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A5FCF4: F9580008  std r10, 8(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82A5FCF8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A5FCFC: 4824974C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5FD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5FD00 size=236
    let mut pc: u32 = 0x82A5FD00;
    'dispatch: loop {
        match pc {
            0x82A5FD00 => {
    //   block [0x82A5FD00..0x82A5FD3C)
	// 82A5FD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5FD04: 48249705  bl 0x82ca9408
	ctx.lr = 0x82A5FD08;
	sub_82CA93D0(ctx, base);
	// 82A5FD08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5FD0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A5FD10: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 82A5FD14: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A5FD18: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A5FD1C: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A5FD20: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5FD24: 419A00C0  beq cr6, 0x82a5fde4
	if ctx.cr[6].eq {
	pc = 0x82A5FDE4; continue 'dispatch;
	}
	// 82A5FD28: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82A5FD2C: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A5FD30: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5FD34: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5FD38: 419A00AC  beq cr6, 0x82a5fde4
	if ctx.cr[6].eq {
	pc = 0x82A5FDE4; continue 'dispatch;
	}
	pc = 0x82A5FD3C; continue 'dispatch;
            }
            0x82A5FD3C => {
    //   block [0x82A5FD3C..0x82A5FD74)
	// 82A5FD3C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A5FD40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FD44: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FD48: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5FD4C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A5FD50: 40980024  bge cr6, 0x82a5fd74
	if !ctx.cr[6].lt {
	pc = 0x82A5FD74; continue 'dispatch;
	}
	// 82A5FD54: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A5FD58: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5FD5C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A5FD60: 419A0074  beq cr6, 0x82a5fdd4
	if ctx.cr[6].eq {
	pc = 0x82A5FDD4; continue 'dispatch;
	}
	// 82A5FD64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5FD68: 419A006C  beq cr6, 0x82a5fdd4
	if ctx.cr[6].eq {
	pc = 0x82A5FDD4; continue 'dispatch;
	}
	// 82A5FD6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A5FD70: 48000054  b 0x82a5fdc4
	pc = 0x82A5FDC4; continue 'dispatch;
            }
            0x82A5FD74 => {
    //   block [0x82A5FD74..0x82A5FD88)
	// 82A5FD74: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 82A5FD78: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A5FD7C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FD80: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5FD84: 40980050  bge cr6, 0x82a5fdd4
	if !ctx.cr[6].lt {
	pc = 0x82A5FDD4; continue 'dispatch;
	}
	pc = 0x82A5FD88; continue 'dispatch;
            }
            0x82A5FD88 => {
    //   block [0x82A5FD88..0x82A5FDC4)
	// 82A5FD88: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82A5FD8C: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5FD90: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A5FD94: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FD98: F8610060  std r3, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u64 ) };
	// 82A5FD9C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5FDA0: 4198FFE8  blt cr6, 0x82a5fd88
	if ctx.cr[6].lt {
	pc = 0x82A5FD88; continue 'dispatch;
	}
	// 82A5FDA4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A5FDA8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A5FDAC: 419A0028  beq cr6, 0x82a5fdd4
	if ctx.cr[6].eq {
	pc = 0x82A5FDD4; continue 'dispatch;
	}
	// 82A5FDB0: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A5FDB4: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A5FDB8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A5FDBC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A5FDC0: 419A0014  beq cr6, 0x82a5fdd4
	if ctx.cr[6].eq {
	pc = 0x82A5FDD4; continue 'dispatch;
	}
	pc = 0x82A5FDC4; continue 'dispatch;
            }
            0x82A5FDC4 => {
    //   block [0x82A5FDC4..0x82A5FDD4)
	// 82A5FDC4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A5FDC8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A5FDCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A5FDD0: 48000291  bl 0x82a60060
	ctx.lr = 0x82A5FDD4;
	sub_82A60060(ctx, base);
	pc = 0x82A5FDD4; continue 'dispatch;
            }
            0x82A5FDD4 => {
    //   block [0x82A5FDD4..0x82A5FDE4)
	// 82A5FDD4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A5FDD8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A5FDDC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A5FDE0: 409AFF5C  bne cr6, 0x82a5fd3c
	if !ctx.cr[6].eq {
	pc = 0x82A5FD3C; continue 'dispatch;
	}
	pc = 0x82A5FDE4; continue 'dispatch;
            }
            0x82A5FDE4 => {
    //   block [0x82A5FDE4..0x82A5FDEC)
	// 82A5FDE4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5FDE8: 48249670  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5FDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A5FDF0 size=400
    let mut pc: u32 = 0x82A5FDF0;
    'dispatch: loop {
        match pc {
            0x82A5FDF0 => {
    //   block [0x82A5FDF0..0x82A5FE20)
	// 82A5FDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5FDF4: 48249611  bl 0x82ca9404
	ctx.lr = 0x82A5FDF8;
	sub_82CA93D0(ctx, base);
	// 82A5FDF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5FDFC: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82A5FE00: F86100A0  std r3, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u64 ) };
	// 82A5FE04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A5FE08: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A5FE0C: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A5FE10: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A5FE14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A5FE18: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A5FE1C: 40980054  bge cr6, 0x82a5fe70
	if !ctx.cr[6].lt {
	pc = 0x82A5FE70; continue 'dispatch;
	}
	pc = 0x82A5FE20; continue 'dispatch;
            }
            0x82A5FE20 => {
    //   block [0x82A5FE20..0x82A5FE44)
	// 82A5FE20: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FE24: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5FE28: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 82A5FE2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A5FE30: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A5FE34: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FE38: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A5FE3C: 40980008  bge cr6, 0x82a5fe44
	if !ctx.cr[6].lt {
	pc = 0x82A5FE44; continue 'dispatch;
	}
	// 82A5FE40: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	pc = 0x82A5FE44; continue 'dispatch;
            }
            0x82A5FE44 => {
    //   block [0x82A5FE44..0x82A5FE70)
	// 82A5FE44: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5FE48: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FE4C: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A5FE50: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5FE54: 4BFFFA3D  bl 0x82a5f890
	ctx.lr = 0x82A5FE58;
	sub_82A5F890(ctx, base);
	// 82A5FE58: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82A5FE5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A5FE60: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A5FE64: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A5FE68: 4198FFB8  blt cr6, 0x82a5fe20
	if ctx.cr[6].lt {
	pc = 0x82A5FE20; continue 'dispatch;
	}
	// 82A5FE6C: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	pc = 0x82A5FE70; continue 'dispatch;
            }
            0x82A5FE70 => {
    //   block [0x82A5FE70..0x82A5FE90)
	// 82A5FE70: 409A0020  bne cr6, 0x82a5fe90
	if !ctx.cr[6].eq {
	pc = 0x82A5FE90; continue 'dispatch;
	}
	// 82A5FE74: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FE78: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5FE7C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5FE80: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A5FE84: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 82A5FE88: 4BFFFA09  bl 0x82a5f890
	ctx.lr = 0x82A5FE8C;
	sub_82A5F890(ctx, base);
	// 82A5FE8C: 389DFFFF  addi r4, r29, -1
	ctx.r[4].s64 = ctx.r[29].s64 + -1;
	pc = 0x82A5FE90; continue 'dispatch;
            }
            0x82A5FE90 => {
    //   block [0x82A5FE90..0x82A5FEAC)
	// 82A5FE90: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5FE94: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FE98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A5FE9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A5FEA0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A5FEA4: 419A0024  beq cr6, 0x82a5fec8
	if ctx.cr[6].eq {
	pc = 0x82A5FEC8; continue 'dispatch;
	}
	// 82A5FEA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A5FEAC; continue 'dispatch;
            }
            0x82A5FEAC => {
    //   block [0x82A5FEAC..0x82A5FEC8)
	// 82A5FEAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5FEB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FEB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5FEB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5FEBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5FEC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FEC4: 4082FFE8  bne 0x82a5feac
	if !ctx.cr[0].eq {
	pc = 0x82A5FEAC; continue 'dispatch;
	}
	pc = 0x82A5FEC8; continue 'dispatch;
            }
            0x82A5FEC8 => {
    //   block [0x82A5FEC8..0x82A5FEE0)
	// 82A5FEC8: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 82A5FECC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A5FED0: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A5FED4: 7F1C2000  cmpw cr6, r28, r4
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A5FED8: 7FE90194  addze r31, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82A5FEDC: 4098003C  bge cr6, 0x82a5ff18
	if !ctx.cr[6].lt {
	pc = 0x82A5FF18; continue 'dispatch;
	}
	pc = 0x82A5FEE0; continue 'dispatch;
            }
            0x82A5FEE0 => {
    //   block [0x82A5FEE0..0x82A5FF18)
	// 82A5FEE0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A5FEE4: 7C8AF214  add r4, r10, r30
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A5FEE8: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82A5FEEC: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A5FEF0: 40980028  bge cr6, 0x82a5ff18
	if !ctx.cr[6].lt {
	pc = 0x82A5FF18; continue 'dispatch;
	}
	// 82A5FEF4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FEF8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5FEFC: 4BFFF995  bl 0x82a5f890
	ctx.lr = 0x82A5FF00;
	sub_82A5F890(ctx, base);
	// 82A5FF00: 395FFFFF  addi r10, r31, -1
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	// 82A5FF04: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A5FF08: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A5FF0C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A5FF10: 7FE90194  addze r31, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82A5FF14: 4198FFCC  blt cr6, 0x82a5fee0
	if ctx.cr[6].lt {
	pc = 0x82A5FEE0; continue 'dispatch;
	}
	pc = 0x82A5FF18; continue 'dispatch;
            }
            0x82A5FF18 => {
    //   block [0x82A5FF18..0x82A5FF38)
	// 82A5FF18: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A5FF1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A5FF20: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A5FF24: 4BFFF96D  bl 0x82a5f890
	ctx.lr = 0x82A5FF28;
	sub_82A5F890(ctx, base);
	// 82A5FF28: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A5FF2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A5FF30: 419A0040  beq cr6, 0x82a5ff70
	if ctx.cr[6].eq {
	pc = 0x82A5FF70; continue 'dispatch;
	}
	// 82A5FF34: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A5FF38; continue 'dispatch;
            }
            0x82A5FF38 => {
    //   block [0x82A5FF38..0x82A5FF70)
	// 82A5FF38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5FF3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FF40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5FF44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A5FF48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5FF4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FF50: 4082FFE8  bne 0x82a5ff38
	if !ctx.cr[0].eq {
	pc = 0x82A5FF38; continue 'dispatch;
	}
	// 82A5FF54: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A5FF58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A5FF5C: 409A0014  bne cr6, 0x82a5ff70
	if !ctx.cr[6].eq {
	pc = 0x82A5FF70; continue 'dispatch;
	}
	// 82A5FF60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FF64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5FF68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A5FF6C: 4E800421  bctrl
	ctx.lr = 0x82A5FF70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A5FF70 => {
    //   block [0x82A5FF70..0x82A5FF80)
	// 82A5FF70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A5FF74: 4B74CB45  bl 0x821acab8
	ctx.lr = 0x82A5FF78;
	sub_821ACAB8(ctx, base);
	// 82A5FF78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A5FF7C: 482494D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A5FF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A5FF80 size=220
    let mut pc: u32 = 0x82A5FF80;
    'dispatch: loop {
        match pc {
            0x82A5FF80 => {
    //   block [0x82A5FF80..0x82A5FFD8)
	// 82A5FF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A5FF84: 4824947D  bl 0x82ca9400
	ctx.lr = 0x82A5FF88;
	sub_82CA93D0(ctx, base);
	// 82A5FF88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A5FF8C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A5FF90: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A5FF94: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82A5FF98: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A5FF9C: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A5FFA0: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A5FFA4: 7D5C5850  subf r10, r28, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A5FFA8: 55490038  rlwinm r9, r10, 0, 0, 0x1c
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A5FFAC: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 82A5FFB0: 409900A4  ble cr6, 0x82a60054
	if !ctx.cr[6].gt {
	pc = 0x82A60054; continue 'dispatch;
	}
	// 82A5FFB4: 3BCBFFF8  addi r30, r11, -8
	ctx.r[30].s64 = ctx.r[11].s64 + -8;
	// 82A5FFB8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A5FFBC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A5FFC0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A5FFC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A5FFC8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A5FFCC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A5FFD0: 419A0024  beq cr6, 0x82a5fff4
	if ctx.cr[6].eq {
	pc = 0x82A5FFF4; continue 'dispatch;
	}
	// 82A5FFD4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A5FFD8; continue 'dispatch;
            }
            0x82A5FFD8 => {
    //   block [0x82A5FFD8..0x82A5FFF4)
	// 82A5FFD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A5FFDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FFE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A5FFE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A5FFE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A5FFEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A5FFF0: 4082FFE8  bne 0x82a5ffd8
	if !ctx.cr[0].eq {
	pc = 0x82A5FFD8; continue 'dispatch;
	}
	pc = 0x82A5FFF4; continue 'dispatch;
            }
            0x82A5FFF4 => {
    //   block [0x82A5FFF4..0x82A60014)
	// 82A5FFF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A5FFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A5FFFC: 4BFFF895  bl 0x82a5f890
	ctx.lr = 0x82A60000;
	sub_82A5F890(ctx, base);
	// 82A60000: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A60004: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A60008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6000C: 419A0024  beq cr6, 0x82a60030
	if ctx.cr[6].eq {
	pc = 0x82A60030; continue 'dispatch;
	}
	// 82A60010: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A60014; continue 'dispatch;
            }
            0x82A60014 => {
    //   block [0x82A60014..0x82A60030)
	// 82A60014: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A60018: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6001C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A60020: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A60024: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A60028: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6002C: 4082FFE8  bne 0x82a60014
	if !ctx.cr[0].eq {
	pc = 0x82A60014; continue 'dispatch;
	}
	pc = 0x82A60030; continue 'dispatch;
            }
            0x82A60030 => {
    //   block [0x82A60030..0x82A60054)
	// 82A60030: 7D7CF050  subf r11, r28, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 82A60034: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A60038: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6003C: 7D651E70  srawi r5, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A60040: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A60044: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A60048: 4BFFFDA9  bl 0x82a5fdf0
	ctx.lr = 0x82A6004C;
	sub_82A5FDF0(ctx, base);
	// 82A6004C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A60050: 4B74CA69  bl 0x821acab8
	ctx.lr = 0x82A60054;
	sub_821ACAB8(ctx, base);
	pc = 0x82A60054; continue 'dispatch;
            }
            0x82A60054 => {
    //   block [0x82A60054..0x82A6005C)
	// 82A60054: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A60058: 482493F8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A60060 size=404
    let mut pc: u32 = 0x82A60060;
    'dispatch: loop {
        match pc {
            0x82A60060 => {
    //   block [0x82A60060..0x82A600A4)
	// 82A60060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A60064: 48249391  bl 0x82ca93f4
	ctx.lr = 0x82A60068;
	sub_82CA93D0(ctx, base);
	// 82A60068: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6006C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A60070: FB4100E0  std r26, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[26].u64 ) };
	// 82A60074: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 82A60078: 82E100F4  lwz r23, 0xf4(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A6007C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A60080: 836100E4  lwz r27, 0xe4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A60084: 816100EC  lwz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A60088: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82A6008C: 7D3BB850  subf r9, r27, r23
	ctx.r[9].s64 = ctx.r[23].s64 - ctx.r[27].s64;
	// 82A60090: 7D5C1E71  srawi. r28, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A60094: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82A60098: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82A6009C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82A600A0: 4182001C  beq 0x82a600bc
	if ctx.cr[0].eq {
	pc = 0x82A600BC; continue 'dispatch;
	}
	pc = 0x82A600A4; continue 'dispatch;
            }
            0x82A600A4 => {
    //   block [0x82A600A4..0x82A600BC)
	// 82A600A4: 7D585BD6  divw r10, r24, r11
	ctx.r[10].s32 = ctx.r[24].s32 / ctx.r[11].s32;
	// 82A600A8: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82A600AC: 7D48C051  subf. r10, r8, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A600B0: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82A600B4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A600B8: 4082FFEC  bne 0x82a600a4
	if !ctx.cr[0].eq {
	pc = 0x82A600A4; continue 'dispatch;
	}
	pc = 0x82A600BC; continue 'dispatch;
            }
            0x82A600BC => {
    //   block [0x82A600BC..0x82A600D8)
	// 82A600BC: 7F184800  cmpw cr6, r24, r9
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A600C0: 4098012C  bge cr6, 0x82a601ec
	if !ctx.cr[6].lt {
	pc = 0x82A601EC; continue 'dispatch;
	}
	// 82A600C4: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A600C8: 40990124  ble cr6, 0x82a601ec
	if !ctx.cr[6].gt {
	pc = 0x82A601EC; continue 'dispatch;
	}
	// 82A600CC: 570B1838  slwi r11, r24, 3
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A600D0: 57991838  slwi r25, r28, 3
	ctx.r[25].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82A600D4: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82A600D8; continue 'dispatch;
            }
            0x82A600D8 => {
    //   block [0x82A600D8..0x82A60104)
	// 82A600D8: FB410058  std r26, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u64 ) };
	// 82A600DC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A600E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A600E4: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A600E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A600EC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A600F0: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82A600F4: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A600F8: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82A600FC: 419A0024  beq cr6, 0x82a60120
	if ctx.cr[6].eq {
	pc = 0x82A60120; continue 'dispatch;
	}
	// 82A60100: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A60104; continue 'dispatch;
            }
            0x82A60104 => {
    //   block [0x82A60104..0x82A60120)
	// 82A60104: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A60108: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6010C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A60110: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A60114: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A60118: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6011C: 4082FFE8  bne 0x82a60104
	if !ctx.cr[0].eq {
	pc = 0x82A60104; continue 'dispatch;
	}
	pc = 0x82A60120; continue 'dispatch;
            }
            0x82A60120 => {
    //   block [0x82A60120..0x82A60134)
	// 82A60120: 7D7DCA14  add r11, r29, r25
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[25].u64;
	// 82A60124: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82A60128: 409A000C  bne cr6, 0x82a60134
	if !ctx.cr[6].eq {
	pc = 0x82A60134; continue 'dispatch;
	}
	// 82A6012C: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 82A60130: 48000018  b 0x82a60148
	pc = 0x82A60148; continue 'dispatch;
            }
            0x82A60134 => {
    //   block [0x82A60134..0x82A60148)
	// 82A60134: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A60138: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 82A6013C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A60140: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A60144: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	pc = 0x82A60148; continue 'dispatch;
            }
            0x82A60148 => {
    //   block [0x82A60148..0x82A6015C)
	// 82A60148: EBCA0000  ld r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A6014C: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A60150: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A60154: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A60158: 419A0074  beq cr6, 0x82a601cc
	if ctx.cr[6].eq {
	pc = 0x82A601CC; continue 'dispatch;
	}
	pc = 0x82A6015C; continue 'dispatch;
            }
            0x82A6015C => {
    //   block [0x82A6015C..0x82A60198)
	// 82A6015C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A60160: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A60164: 4BFFF72D  bl 0x82a5f890
	ctx.lr = 0x82A60168;
	sub_82A5F890(ctx, base);
	// 82A60168: 7D7FB850  subf r11, r31, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 82A6016C: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82A60170: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A60174: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A60178: 40980020  bge cr6, 0x82a60198
	if !ctx.cr[6].lt {
	pc = 0x82A60198; continue 'dispatch;
	}
	// 82A6017C: 7D59FA14  add r10, r25, r31
	ctx.r[10].u64 = ctx.r[25].u64 + ctx.r[31].u64;
	// 82A60180: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A60184: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82A60188: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A6018C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A60190: F9210070  std r9, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u64 ) };
	// 82A60194: 48000024  b 0x82a601b8
	pc = 0x82A601B8; continue 'dispatch;
            }
            0x82A60198 => {
    //   block [0x82A60198..0x82A601B8)
	// 82A60198: 7D4BE050  subf r10, r11, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A6019C: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82A601A0: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82A601A4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A601A8: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A601AC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A601B0: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A601B4: F9010078  std r8, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[8].u64 ) };
	pc = 0x82A601B8; continue 'dispatch;
            }
            0x82A601B8 => {
    //   block [0x82A601B8..0x82A601CC)
	// 82A601B8: EBCB0000  ld r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A601BC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A601C0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A601C4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A601C8: 409AFF94  bne cr6, 0x82a6015c
	if !ctx.cr[6].eq {
	pc = 0x82A6015C; continue 'dispatch;
	}
	pc = 0x82A601CC; continue 'dispatch;
            }
            0x82A601CC => {
    //   block [0x82A601CC..0x82A601EC)
	// 82A601CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A601D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A601D4: 4BFFF6BD  bl 0x82a5f890
	ctx.lr = 0x82A601D8;
	sub_82A5F890(ctx, base);
	// 82A601D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A601DC: 4B74C8DD  bl 0x821acab8
	ctx.lr = 0x82A601E0;
	sub_821ACAB8(ctx, base);
	// 82A601E0: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A601E4: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82A601E8: 4181FEF0  bgt 0x82a600d8
	if ctx.cr[0].gt {
	pc = 0x82A600D8; continue 'dispatch;
	}
	pc = 0x82A601EC; continue 'dispatch;
            }
            0x82A601EC => {
    //   block [0x82A601EC..0x82A601F4)
	// 82A601EC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A601F0: 48249254  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A601F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A601F8 size=236
    let mut pc: u32 = 0x82A601F8;
    'dispatch: loop {
        match pc {
            0x82A601F8 => {
    //   block [0x82A601F8..0x82A602B4)
	// 82A601F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A601FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A60200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A60204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A60208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6020C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A60210: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A60214: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A60218: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A6021C: 38E00026  li r7, 0x26
	ctx.r[7].s64 = 38;
	// 82A60220: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60224: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A60228: 891F000C  lbz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6022C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A60230: 554607FE  clrlwi r6, r10, 0x1f
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A60234: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A60238: 5505067E  clrlwi r5, r8, 0x19
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000007Fu64;
	// 82A6023C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A60240: 39494F60  addi r10, r9, 0x4f60
	ctx.r[10].s64 = ctx.r[9].s64 + 20320;
	// 82A60244: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A60248: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A6024C: 98BF000C  stb r5, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u8 ) };
	// 82A60250: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A60254: 909F001C  stw r4, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82A60258: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82A6025C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82A60260: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A60264: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A60268: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82A6026C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82A60270: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82A60274: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A60278: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82A6027C: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82A60280: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82A60284: 93FF0020  stw r31, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82A60288: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6028C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82A60290: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82A60294: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A60298: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A6029C: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A602A0: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A602A4: 4B7BEFB5  bl 0x8221f258
	ctx.lr = 0x82A602A8;
	sub_8221F258(ctx, base);
	// 82A602A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A602AC: 419A0008  beq cr6, 0x82a602b4
	if ctx.cr[6].eq {
	pc = 0x82A602B4; continue 'dispatch;
	}
	// 82A602B0: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A602B4; continue 'dispatch;
            }
            0x82A602B4 => {
    //   block [0x82A602B4..0x82A602C0)
	// 82A602B4: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A602B8: 41820008  beq 0x82a602c0
	if ctx.cr[0].eq {
	pc = 0x82A602C0; continue 'dispatch;
	}
	// 82A602BC: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A602C0; continue 'dispatch;
            }
            0x82A602C0 => {
    //   block [0x82A602C0..0x82A602E4)
	// 82A602C0: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82A602C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A602C8: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82A602CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A602D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A602D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A602D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A602DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A602E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A602E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A602E8 size=80
    let mut pc: u32 = 0x82A602E8;
    'dispatch: loop {
        match pc {
            0x82A602E8 => {
    //   block [0x82A602E8..0x82A60320)
	// 82A602E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A602EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A602F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A602F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A602F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A602FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A60300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A60304: 48000035  bl 0x82a60338
	ctx.lr = 0x82A60308;
	sub_82A60338(ctx, base);
	// 82A60308: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A6030C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A60310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A60314: 419A000C  beq cr6, 0x82a60320
	if ctx.cr[6].eq {
	pc = 0x82A60320; continue 'dispatch;
	}
	// 82A60318: 4B7BBA21  bl 0x8221bd38
	ctx.lr = 0x82A6031C;
	sub_8221BD38(ctx, base);
	// 82A6031C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A60320; continue 'dispatch;
            }
            0x82A60320 => {
    //   block [0x82A60320..0x82A60338)
	// 82A60320: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A60324: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A60328: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6032C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A60330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A60334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A60338 size=368
    let mut pc: u32 = 0x82A60338;
    'dispatch: loop {
        match pc {
            0x82A60338 => {
    //   block [0x82A60338..0x82A60368)
	// 82A60338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6033C: 482490C9  bl 0x82ca9404
	ctx.lr = 0x82A60340;
	sub_82CA93D0(ctx, base);
	// 82A60340: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A60344: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A60348: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6034C: 392B4F60  addi r9, r11, 0x4f60
	ctx.r[9].s64 = ctx.r[11].s64 + 20320;
	// 82A60350: 815B0068  lwz r10, 0x68(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A60354: 913B0000  stw r9, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A60358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6035C: 419A00D4  beq cr6, 0x82a60430
	if ctx.cr[6].eq {
	pc = 0x82A60430; continue 'dispatch;
	}
	// 82A60360: 3BBB0060  addi r29, r27, 0x60
	ctx.r[29].s64 = ctx.r[27].s64 + 96;
	// 82A60364: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	pc = 0x82A60368; continue 'dispatch;
            }
            0x82A60368 => {
    //   block [0x82A60368..0x82A60380)
	// 82A60368: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6036C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A60370: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60374: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A60378: 409A0008  bne cr6, 0x82a60380
	if !ctx.cr[6].eq {
	pc = 0x82A60380; continue 'dispatch;
	}
	// 82A6037C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A60380; continue 'dispatch;
            }
            0x82A60380 => {
    //   block [0x82A60380..0x82A60390)
	// 82A60380: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60384: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A60388: 419A0024  beq cr6, 0x82a603ac
	if ctx.cr[6].eq {
	pc = 0x82A603AC; continue 'dispatch;
	}
	// 82A6038C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A60390; continue 'dispatch;
            }
            0x82A60390 => {
    //   block [0x82A60390..0x82A603AC)
	// 82A60390: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A60394: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60398: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6039C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A603A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A603A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A603A8: 4082FFE8  bne 0x82a60390
	if !ctx.cr[0].eq {
	pc = 0x82A60390; continue 'dispatch;
	}
	pc = 0x82A603AC; continue 'dispatch;
            }
            0x82A603AC => {
    //   block [0x82A603AC..0x82A603E8)
	// 82A603AC: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82A603B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A603B4: 488595B1  bl 0x832b9964
	ctx.lr = 0x82A603B8;
	// extern call 0x832B9964 → crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82A603B8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A603BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A603C0: 48859595  bl 0x832b9954
	ctx.lr = 0x82A603C4;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82A603C4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A603C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A603CC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A603D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A603D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A603D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A603DC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A603E0: 48000249  bl 0x82a60628
	ctx.lr = 0x82A603E4;
	sub_82A60628(ctx, base);
	// 82A603E4: 38FF0004  addi r7, r31, 4
	ctx.r[7].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A603E8; continue 'dispatch;
            }
            0x82A603E8 => {
    //   block [0x82A603E8..0x82A60424)
	// 82A603E8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A603EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A603F0: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A603F4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A603F8: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A603FC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60400: 4082FFE8  bne 0x82a603e8
	if !ctx.cr[0].eq {
	pc = 0x82A603E8; continue 'dispatch;
	}
	// 82A60404: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A60408: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6040C: 409A0018  bne cr6, 0x82a60424
	if !ctx.cr[6].eq {
	pc = 0x82A60424; continue 'dispatch;
	}
	// 82A60410: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A60418: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6041C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A60420: 4E800421  bctrl
	ctx.lr = 0x82A60424;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A60424 => {
    //   block [0x82A60424..0x82A60430)
	// 82A60424: 817B0068  lwz r11, 0x68(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A60428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6042C: 409AFF3C  bne cr6, 0x82a60368
	if !ctx.cr[6].eq {
	pc = 0x82A60368; continue 'dispatch;
	}
	pc = 0x82A60430; continue 'dispatch;
            }
            0x82A60430 => {
    //   block [0x82A60430..0x82A60444)
	// 82A60430: 817B004C  lwz r11, 0x4c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A60434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A60438: 419A000C  beq cr6, 0x82a60444
	if ctx.cr[6].eq {
	pc = 0x82A60444; continue 'dispatch;
	}
	// 82A6043C: 387B0048  addi r3, r27, 0x48
	ctx.r[3].s64 = ctx.r[27].s64 + 72;
	// 82A60440: 4BFF08E9  bl 0x82a50d28
	ctx.lr = 0x82A60444;
	sub_82A50D28(ctx, base);
	pc = 0x82A60444; continue 'dispatch;
            }
            0x82A60444 => {
    //   block [0x82A60444..0x82A6045C)
	// 82A60444: 387B0060  addi r3, r27, 0x60
	ctx.r[3].s64 = ctx.r[27].s64 + 96;
	// 82A60448: 4BB058A1  bl 0x82565ce8
	ctx.lr = 0x82A6044C;
	sub_82565CE8(ctx, base);
	// 82A6044C: 807B004C  lwz r3, 0x4c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A60450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A60454: 419A0044  beq cr6, 0x82a60498
	if ctx.cr[6].eq {
	pc = 0x82A60498; continue 'dispatch;
	}
	// 82A60458: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A6045C; continue 'dispatch;
            }
            0x82A6045C => {
    //   block [0x82A6045C..0x82A60490)
	// 82A6045C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A60460: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60464: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A60468: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A6046C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A60470: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60474: 4082FFE8  bne 0x82a6045c
	if !ctx.cr[0].eq {
	pc = 0x82A6045C; continue 'dispatch;
	}
	// 82A60478: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6047C: 409A0014  bne cr6, 0x82a60490
	if !ctx.cr[6].eq {
	pc = 0x82A60490; continue 'dispatch;
	}
	// 82A60480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60484: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60488: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6048C: 4E800421  bctrl
	ctx.lr = 0x82A60490;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A60490 => {
    //   block [0x82A60490..0x82A60498)
	// 82A60490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A60494: 917B004C  stw r11, 0x4c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x82A60498; continue 'dispatch;
            }
            0x82A60498 => {
    //   block [0x82A60498..0x82A604A8)
	// 82A60498: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A6049C: 48019005  bl 0x82a794a0
	ctx.lr = 0x82A604A0;
	sub_82A794A0(ctx, base);
	// 82A604A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A604A4: 48248FB0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A604A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A604A8 size=120
    let mut pc: u32 = 0x82A604A8;
    'dispatch: loop {
        match pc {
            0x82A604A8 => {
    //   block [0x82A604A8..0x82A60508)
	// 82A604A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A604AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A604B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A604B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A604B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A604BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A604C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A604C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A604C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A604CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A604D0: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 82A604D4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A604D8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A604DC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A604E0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A604E4: 4E800421  bctrl
	ctx.lr = 0x82A604E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A604E8: 2F03002E  cmpwi cr6, r3, 0x2e
	ctx.cr[6].compare_i32(ctx.r[3].s32, 46, &mut ctx.xer);
	// 82A604EC: 409A001C  bne cr6, 0x82a60508
	if !ctx.cr[6].eq {
	pc = 0x82A60508; continue 'dispatch;
	}
	// 82A604F0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A604F4: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82A604F8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A604FC: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A60500: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A60504: 913F005C  stw r9, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
            }
            0x82A60508 => {
    //   block [0x82A60508..0x82A60520)
	// 82A60508: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6050C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A60510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A60514: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A60518: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6051C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A60520 size=260
    let mut pc: u32 = 0x82A60520;
    'dispatch: loop {
        match pc {
            0x82A60520 => {
    //   block [0x82A60520..0x82A60574)
	// 82A60520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A60524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A60528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6052C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A60530: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A60534: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A60538: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6053C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A60540: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A60544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A60548: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6054C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60550: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A60554: 4E800421  bctrl
	ctx.lr = 0x82A60558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A60558: 2F03001B  cmpwi cr6, r3, 0x1b
	ctx.cr[6].compare_i32(ctx.r[3].s32, 27, &mut ctx.xer);
	// 82A6055C: 419A0018  beq cr6, 0x82a60574
	if ctx.cr[6].eq {
	pc = 0x82A60574; continue 'dispatch;
	}
	// 82A60560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A60564: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A60568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6056C: 48018FCD  bl 0x82a79538
	ctx.lr = 0x82A60570;
	sub_82A79538(ctx, base);
	// 82A60570: 48000098  b 0x82a60608
	pc = 0x82A60608; continue 'dispatch;
            }
            0x82A60574 => {
    //   block [0x82A60574..0x82A60588)
	// 82A60574: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6057C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A60580: 419A0024  beq cr6, 0x82a605a4
	if ctx.cr[6].eq {
	pc = 0x82A605A4; continue 'dispatch;
	}
	// 82A60584: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A60588; continue 'dispatch;
            }
            0x82A60588 => {
    //   block [0x82A60588..0x82A605A4)
	// 82A60588: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6058C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60590: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A60594: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A60598: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6059C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A605A0: 4082FFE8  bne 0x82a60588
	if !ctx.cr[0].eq {
	pc = 0x82A60588; continue 'dispatch;
	}
	pc = 0x82A605A4; continue 'dispatch;
            }
            0x82A605A4 => {
    //   block [0x82A605A4..0x82A605CC)
	// 82A605A4: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A605A8: 387E0060  addi r3, r30, 0x60
	ctx.r[3].s64 = ctx.r[30].s64 + 96;
	// 82A605AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A605B0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82A605B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A605B8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A605BC: 4B827485  bl 0x82287a40
	ctx.lr = 0x82A605C0;
	sub_82287A40(ctx, base);
	// 82A605C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A605C4: 419A0044  beq cr6, 0x82a60608
	if ctx.cr[6].eq {
	pc = 0x82A60608; continue 'dispatch;
	}
	// 82A605C8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82A605CC; continue 'dispatch;
            }
            0x82A605CC => {
    //   block [0x82A605CC..0x82A60608)
	// 82A605CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A605D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A605D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A605D8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A605DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A605E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A605E4: 4082FFE8  bne 0x82a605cc
	if !ctx.cr[0].eq {
	pc = 0x82A605CC; continue 'dispatch;
	}
	// 82A605E8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A605EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A605F0: 409A0018  bne cr6, 0x82a60608
	if !ctx.cr[6].eq {
	pc = 0x82A60608; continue 'dispatch;
	}
	// 82A605F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A605F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A605FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60600: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A60604: 4E800421  bctrl
	ctx.lr = 0x82A60608;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A60608 => {
    //   block [0x82A60608..0x82A60624)
	// 82A60608: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6060C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A60610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A60614: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A60618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6061C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A60620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A60628 size=184
    let mut pc: u32 = 0x82A60628;
    'dispatch: loop {
        match pc {
            0x82A60628 => {
    //   block [0x82A60628..0x82A60654)
	// 82A60628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6062C: 48248DE1  bl 0x82ca940c
	ctx.lr = 0x82A60630;
	sub_82CA93D0(ctx, base);
	// 82A60630: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A60634: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 82A60638: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6063C: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82A60640: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A60644: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A60648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6064C: 409A0008  bne cr6, 0x82a60654
	if !ctx.cr[6].eq {
	pc = 0x82A60654; continue 'dispatch;
	}
	// 82A60650: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A60654; continue 'dispatch;
            }
            0x82A60654 => {
    //   block [0x82A60654..0x82A60668)
	// 82A60654: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60658: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A6065C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A60660: 409A0008  bne cr6, 0x82a60668
	if !ctx.cr[6].eq {
	pc = 0x82A60668; continue 'dispatch;
	}
	// 82A60664: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A60668; continue 'dispatch;
            }
            0x82A60668 => {
    //   block [0x82A60668..0x82A606CC)
	// 82A60668: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6066C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A60670: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60674: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A60678: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82A6067C: 419A0050  beq cr6, 0x82a606cc
	if ctx.cr[6].eq {
	pc = 0x82A606CC; continue 'dispatch;
	}
	// 82A60680: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A60688: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6068C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A60690: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A60694: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60698: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6069C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A606A0: 4BB057E1  bl 0x82565e80
	ctx.lr = 0x82A606A4;
	sub_82565E80(ctx, base);
	// 82A606A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A606A8: 4B7BB691  bl 0x8221bd38
	ctx.lr = 0x82A606AC;
	sub_8221BD38(ctx, base);
	// 82A606AC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A606B0: E8E100A0  ld r7, 0xa0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82A606B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A606B8: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82A606BC: 90DE0008  stw r6, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A606C0: F8FD0000  std r7, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82A606C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A606C8: 48248D94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A606CC => {
    //   block [0x82A606CC..0x82A606E0)
	// 82A606CC: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82A606D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A606D4: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A606D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A606DC: 48248D80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A606E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A606E0 size=268
    let mut pc: u32 = 0x82A606E0;
    'dispatch: loop {
        match pc {
            0x82A606E0 => {
    //   block [0x82A606E0..0x82A6072C)
	// 82A606E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A606E4: 48248D29  bl 0x82ca940c
	ctx.lr = 0x82A606E8;
	sub_82CA93D0(ctx, base);
	// 82A606E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A606EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A606F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A606F4: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A606F8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A606FC: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	// 82A60700: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A60704: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A60708: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A6070C: 40990020  ble cr6, 0x82a6072c
	if !ctx.cr[6].gt {
	pc = 0x82A6072C; continue 'dispatch;
	}
	// 82A60710: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A60714: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A60718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6071C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A60720: 480000D1  bl 0x82a607f0
	ctx.lr = 0x82A60724;
	sub_82A607F0(ctx, base);
	// 82A60724: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A60728: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A6072C; continue 'dispatch;
            }
            0x82A6072C => {
    //   block [0x82A6072C..0x82A6075C)
	// 82A6072C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A60730: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A60734: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60738: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A6073C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A60740: 409A0020  bne cr6, 0x82a60760
	if !ctx.cr[6].eq {
	pc = 0x82A60760; continue 'dispatch;
	}
	// 82A60744: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A60748: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A6074C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A60750: 4198000C  blt cr6, 0x82a6075c
	if ctx.cr[6].lt {
	pc = 0x82A6075C; continue 'dispatch;
	}
	// 82A60754: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A60758: 48000008  b 0x82a60760
	pc = 0x82A60760; continue 'dispatch;
            }
            0x82A6075C => {
    //   block [0x82A6075C..0x82A60760)
	// 82A6075C: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82A60760; continue 'dispatch;
            }
            0x82A60760 => {
    //   block [0x82A60760..0x82A607A0)
	// 82A60760: 7D68482E  lwzx r11, r8, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A60764: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A60768: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 82A6076C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A60770: 5566003A  rlwinm r6, r11, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A60774: 7D6A3214  add r11, r10, r6
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 82A60778: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A6077C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A60780: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A60784: 4099001C  ble cr6, 0x82a607a0
	if !ctx.cr[6].gt {
	pc = 0x82A607A0; continue 'dispatch;
	}
	// 82A60788: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6078C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A60790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A60794: 4800005D  bl 0x82a607f0
	ctx.lr = 0x82A60798;
	sub_82A607F0(ctx, base);
	// 82A60798: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6079C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A607A0; continue 'dispatch;
            }
            0x82A607A0 => {
    //   block [0x82A607A0..0x82A607D0)
	// 82A607A0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A607A4: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A607A8: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A607AC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A607B0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A607B4: 409A0020  bne cr6, 0x82a607d4
	if !ctx.cr[6].eq {
	pc = 0x82A607D4; continue 'dispatch;
	}
	// 82A607B8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A607BC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A607C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A607C4: 4198000C  blt cr6, 0x82a607d0
	if ctx.cr[6].lt {
	pc = 0x82A607D0; continue 'dispatch;
	}
	// 82A607C8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A607CC: 48000008  b 0x82a607d4
	pc = 0x82A607D4; continue 'dispatch;
            }
            0x82A607D0 => {
    //   block [0x82A607D0..0x82A607D4)
	// 82A607D0: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x82A607D4; continue 'dispatch;
            }
            0x82A607D4 => {
    //   block [0x82A607D4..0x82A607EC)
	// 82A607D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A607D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A607DC: 4B7CC6F5  bl 0x8222ced0
	ctx.lr = 0x82A607E0;
	sub_8222CED0(ctx, base);
	// 82A607E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A607E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A607E8: 48248C74  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A607F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A607F0 size=112
    let mut pc: u32 = 0x82A607F0;
    'dispatch: loop {
        match pc {
            0x82A607F0 => {
    //   block [0x82A607F0..0x82A6082C)
	// 82A607F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A607F4: 48248C15  bl 0x82ca9408
	ctx.lr = 0x82A607F8;
	sub_82CA93D0(ctx, base);
	// 82A607F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A607FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A60800: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A60804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A60808: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A6080C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60810: 4B7C9DC9  bl 0x8222a5d8
	ctx.lr = 0x82A60814;
	sub_8222A5D8(ctx, base);
	// 82A60814: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A60818: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6081C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A60820: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A60824: 409A0008  bne cr6, 0x82a6082c
	if !ctx.cr[6].eq {
	pc = 0x82A6082C; continue 'dispatch;
	}
	// 82A60828: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	pc = 0x82A6082C; continue 'dispatch;
            }
            0x82A6082C => {
    //   block [0x82A6082C..0x82A60844)
	// 82A6082C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A60830: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A60834: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A60838: 4198000C  blt cr6, 0x82a60844
	if ctx.cr[6].lt {
	pc = 0x82A60844; continue 'dispatch;
	}
	// 82A6083C: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82A60840: 48000008  b 0x82a60848
	pc = 0x82A60848; continue 'dispatch;
            }
            0x82A60844 => {
    //   block [0x82A60844..0x82A60848)
	// 82A60844: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x82A60848; continue 'dispatch;
            }
            0x82A60848 => {
    //   block [0x82A60848..0x82A60858)
	// 82A60848: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A6084C: 409A000C  bne cr6, 0x82a60858
	if !ctx.cr[6].eq {
	pc = 0x82A60858; continue 'dispatch;
	}
	// 82A60850: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A60854: 911D0000  stw r8, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82A60858; continue 'dispatch;
            }
            0x82A60858 => {
    //   block [0x82A60858..0x82A60860)
	// 82A60858: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6085C: 48248BFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A60860 size=316
    let mut pc: u32 = 0x82A60860;
    'dispatch: loop {
        match pc {
            0x82A60860 => {
    //   block [0x82A60860..0x82A6099C)
	// 82A60860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A60864: 48248B9D  bl 0x82ca9400
	ctx.lr = 0x82A60868;
	sub_82CA93D0(ctx, base);
	// 82A60868: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6086C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60870: 3BE1FFB8  addi r31, r1, -0x48
	ctx.r[31].s64 = ctx.r[1].s64 + -72;
	// 82A60874: 88C3000C  lbz r6, 0xc(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A60878: 3BC1FFBC  addi r30, r1, -0x44
	ctx.r[30].s64 = ctx.r[1].s64 + -68;
	// 82A6087C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A60880: 3B600027  li r27, 0x27
	ctx.r[27].s64 = 39;
	// 82A60884: 3C80820A  lis r4, -0x7df6
	ctx.r[4].s64 = -2113273856;
	// 82A60888: C00B16C8  lfs f0, 0x16c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6088C: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A60890: D001FFB8  stfs f0, -0x48(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), tmp.u32 ) };
	// 82A60894: 93630004  stw r27, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A60898: D001FFBC  stfs f0, -0x44(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 82A6089C: 54C6067E  clrlwi r6, r6, 0x19
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000007Fu64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A609A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A609A0 size=80
    let mut pc: u32 = 0x82A609A0;
    'dispatch: loop {
        match pc {
            0x82A609A0 => {
    //   block [0x82A609A0..0x82A609D8)
	// 82A609A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A609A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A609A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A609AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A609B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A609B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A609B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A609BC: 48000035  bl 0x82a609f0
	ctx.lr = 0x82A609C0;
	sub_82A609F0(ctx, base);
	// 82A609C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A609C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A609C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A609CC: 419A000C  beq cr6, 0x82a609d8
	if ctx.cr[6].eq {
	pc = 0x82A609D8; continue 'dispatch;
	}
	// 82A609D0: 4B7BB369  bl 0x8221bd38
	ctx.lr = 0x82A609D4;
	sub_8221BD38(ctx, base);
	// 82A609D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A609D8; continue 'dispatch;
            }
            0x82A609D8 => {
    //   block [0x82A609D8..0x82A609F0)
	// 82A609D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A609DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A609E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A609E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A609E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A609EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A609F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A609F0 size=216
    let mut pc: u32 = 0x82A609F0;
    'dispatch: loop {
        match pc {
            0x82A609F0 => {
    //   block [0x82A609F0..0x82A60A28)
	// 82A609F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A609F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A609F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A609FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A60A00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A60A04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A60A08: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A60A0C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A60A10: 394B6D30  addi r10, r11, 0x6d30
	ctx.r[10].s64 = ctx.r[11].s64 + 27952;
	// 82A60A14: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A60A18: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A60A1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A60A20: 419A0040  beq cr6, 0x82a60a60
	if ctx.cr[6].eq {
	pc = 0x82A60A60; continue 'dispatch;
	}
	// 82A60A24: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A60A28; continue 'dispatch;
            }
            0x82A60A28 => {
    //   block [0x82A60A28..0x82A60A5C)
	// 82A60A28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A60A2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60A30: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A60A34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A60A38: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A60A3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60A40: 4082FFE8  bne 0x82a60a28
	if !ctx.cr[0].eq {
	pc = 0x82A60A28; continue 'dispatch;
	}
	// 82A60A44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A60A48: 409A0014  bne cr6, 0x82a60a5c
	if !ctx.cr[6].eq {
	pc = 0x82A60A5C; continue 'dispatch;
	}
	// 82A60A4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60A50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60A54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A60A58: 4E800421  bctrl
	ctx.lr = 0x82A60A5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A60A5C => {
    //   block [0x82A60A5C..0x82A60A60)
	// 82A60A5C: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	pc = 0x82A60A60; continue 'dispatch;
            }
            0x82A60A60 => {
    //   block [0x82A60A60..0x82A60A70)
	// 82A60A60: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A60A64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A60A68: 419A0040  beq cr6, 0x82a60aa8
	if ctx.cr[6].eq {
	pc = 0x82A60AA8; continue 'dispatch;
	}
	// 82A60A6C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A60A70; continue 'dispatch;
            }
            0x82A60A70 => {
    //   block [0x82A60A70..0x82A60AA4)
	// 82A60A70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A60A74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60A78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A60A7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A60A80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A60A84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A60A88: 4082FFE8  bne 0x82a60a70
	if !ctx.cr[0].eq {
	pc = 0x82A60A70; continue 'dispatch;
	}
	// 82A60A8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A60A90: 409A0014  bne cr6, 0x82a60aa4
	if !ctx.cr[6].eq {
	pc = 0x82A60AA4; continue 'dispatch;
	}
	// 82A60A94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60A98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60A9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A60AA0: 4E800421  bctrl
	ctx.lr = 0x82A60AA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A60AA4 => {
    //   block [0x82A60AA4..0x82A60AA8)
	// 82A60AA4: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	pc = 0x82A60AA8; continue 'dispatch;
            }
            0x82A60AA8 => {
    //   block [0x82A60AA8..0x82A60AC8)
	// 82A60AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A60AAC: 480189F5  bl 0x82a794a0
	ctx.lr = 0x82A60AB0;
	sub_82A794A0(ctx, base);
	// 82A60AB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A60AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A60AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A60ABC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A60AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A60AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A60AC8 size=240
    let mut pc: u32 = 0x82A60AC8;
    'dispatch: loop {
        match pc {
            0x82A60AC8 => {
    //   block [0x82A60AC8..0x82A60B4C)
	// 82A60AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A60ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A60AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A60AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A60AD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A60ADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A60AE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A60AE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60AE8: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A60AEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A60AF0: 409A00B0  bne cr6, 0x82a60ba0
	if !ctx.cr[6].eq {
	pc = 0x82A60BA0; continue 'dispatch;
	}
	// 82A60AF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A60AF8: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82A60AFC: 806B6F1C  lwz r3, 0x6f1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28444 as u32) ) } as u64;
	// 82A60B00: 4818A6E1  bl 0x82beb1e0
	ctx.lr = 0x82A60B04;
	sub_82BEB1E0(ctx, base);
	// 82A60B04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A60B08: 419A0044  beq cr6, 0x82a60b4c
	if ctx.cr[6].eq {
	pc = 0x82A60B4C; continue 'dispatch;
	}
	// 82A60B0C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A60B10: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A60B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A60B18: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A60B1C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A60B20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A60B24: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A60B28: 38E86E98  addi r7, r8, 0x6e98
	ctx.r[7].s64 = ctx.r[8].s64 + 28312;
	// 82A60B2C: 81496F18  lwz r10, 0x6f18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28440 as u32) ) } as u64;
	// 82A60B30: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A60B34: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A60B38: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82A60B3C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A60B40: 91696F18  stw r11, 0x6f18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28440 as u32), ctx.r[11].u32 ) };
	// 82A60B44: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A60B48: 48000008  b 0x82a60b50
	pc = 0x82A60B50; continue 'dispatch;
            }
            0x82A60B4C => {
    //   block [0x82A60B4C..0x82A60B50)
	// 82A60B4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82A60B50; continue 'dispatch;
            }
            0x82A60B50 => {
    //   block [0x82A60B50..0x82A60BA0)
	// 82A60B50: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 82A60B54: 893F00E4  lbz r9, 0xe4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A60B58: 390000A0  li r8, 0xa0
	ctx.r[8].s64 = 160;
	// 82A60B5C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60B60: 38E006A0  li r7, 0x6a0
	ctx.r[7].s64 = 1696;
	// 82A60B64: 7D260034  cntlzw r6, r9
	ctx.r[6].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82A60B68: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	pc = 0x82A60BA0; continue 'dispatch;
            }
            0x82A60BA0 => {
    //   block [0x82A60BA0..0x82A60BB8)
	// 82A60BA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A60BA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A60BA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A60BAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A60BB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A60BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A60BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A60BB8 size=2300
    let mut pc: u32 = 0x82A60BB8;
    'dispatch: loop {
        match pc {
            0x82A60BB8 => {
    //   block [0x82A60BB8..0x82A60BEC)
	// 82A60BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A60BBC: 4824882D  bl 0x82ca93e8
	ctx.lr = 0x82A60BC0;
	sub_82CA93D0(ctx, base);
	// 82A60BC0: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82A60BC4: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A60BC8: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A60BCC: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 82A60BD0: 3B6B2390  addi r27, r11, 0x2390
	ctx.r[27].s64 = ctx.r[11].s64 + 9104;
	// 82A60BD4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82A60BD8: 9AA1005C  stb r21, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u8 ) };
	// 82A60BDC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82A60BE0: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 82A60BE4: 397B2004  addi r11, r27, 0x2004
	ctx.r[11].s64 = ctx.r[27].s64 + 8196;
	// 82A60BE8: 392A7E70  addi r9, r10, 0x7e70
	ctx.r[9].s64 = ctx.r[10].s64 + 32368;
	pc = 0x82A60BEC; continue 'dispatch;
            }
            0x82A60BEC => {
    //   block [0x82A60BEC..0x82A60C40)
	// 82A60BEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60BF0: 391B6014  addi r8, r27, 0x6014
	ctx.r[8].s64 = ctx.r[27].s64 + 24596;
	// 82A60BF4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A60BF8: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A60BFC: 9127DFFC  stw r9, -0x2004(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-8196 as u32), ctx.r[9].u32 ) };
	// 82A60C00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60C04: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A60C08: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A60C0C: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82A60C10: 908BFFFC  stw r4, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 82A60C14: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A60C18: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 82A60C1C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A60C20: 4198FFCC  blt cr6, 0x82a60bec
	if ctx.cr[6].lt {
	pc = 0x82A60BEC; continue 'dispatch;
	}
	// 82A60C24: 3D40834F  lis r10, -0x7cb1
	ctx.r[10].s64 = -2091974656;
	// 82A60C28: 816A7540  lwz r11, 0x7540(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30016 as u32) ) } as u64;
	// 82A60C2C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A60C30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A60C34: 409A000C  bne cr6, 0x82a60c40
	if !ctx.cr[6].eq {
	pc = 0x82A60C40; continue 'dispatch;
	}
	// 82A60C38: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A60C3C: 916A7540  stw r11, 0x7540(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(30016 as u32), ctx.r[11].u32 ) };
	pc = 0x82A60C40; continue 'dispatch;
            }
            0x82A60C40 => {
    //   block [0x82A60C40..0x82A60D50)
	// 82A60C40: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60C44: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A60C48: C82B02E8  lfd f1, 0x2e8(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(744 as u32) ) };
	// 82A60C4C: 4802162D  bl 0x82a82278
	ctx.lr = 0x82A60C50;
	sub_82A82278(ctx, base);
	// 82A60C50: 811600E0  lwz r8, 0xe0(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(224 as u32) ) } as u64;
	// 82A60C54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A60C58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A60C5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A60C60: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82A60C64: 807600C0  lwz r3, 0xc0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A60C68: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A60C6C: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A60C70: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A60C74: 4E800421  bctrl
	ctx.lr = 0x82A60C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A60C78: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A60C7C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A60C80: 419A0820  beq cr6, 0x82a614a0
	if ctx.cr[6].eq {
	pc = 0x82A614A0; continue 'dispatch;
	}
	// 82A60C84: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A60C88: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 82A60C8C: 394BDF40  addi r10, r11, -0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8384;
	// 82A60C90: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A60C94: 386000BA  li r3, 0xba
	ctx.r[3].s64 = 186;
	// 82A60C98: 81770364  lwz r11, 0x364(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A60C9C: 814A0064  lwz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A60CA0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A60CA4: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82A60CA8: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 82A60CAC: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 82A60CB0: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82A60CB4: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 82A60CB8: 4B7CB559  bl 0x8222c210
	ctx.lr = 0x82A60CBC;
	sub_8222C210(ctx, base);
	// 82A60CBC: 386000BB  li r3, 0xbb
	ctx.r[3].s64 = 187;
	// 82A60CC0: 4B7A7E51  bl 0x82208b10
	ctx.lr = 0x82A60CC4;
	sub_82208B10(ctx, base);
	// 82A60CC4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A60CC8: 88B600E4  lbz r5, 0xe4(r22)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A60CCC: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 82A60CD0: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 82A60CD4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A60CD8: 7CA30034  cntlzw r3, r5
	ctx.r[3].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 82A60CDC: 3B0B0DB8  addi r24, r11, 0xdb8
	ctx.r[24].s64 = ctx.r[11].s64 + 3512;
	// 82A60CE0: 5469DFFE  rlwinm r9, r3, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 82A60CE4: 889F00BD  lbz r4, 0xbd(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 82A60CE8: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A60CEC: 69290001  xori r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u64 ^ 1;
	// 82A60CF0: 1D642008  mulli r11, r4, 0x2008
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A60CF4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A60CF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A60CFC: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82A60D00: 419A0084  beq cr6, 0x82a60d84
	if ctx.cr[6].eq {
	pc = 0x82A60D84; continue 'dispatch;
	}
	// 82A60D04: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A60D08: 811F00B0  lwz r8, 0xb0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A60D0C: 7D075038  and r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 82A60D10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A60D14: 409A003C  bne cr6, 0x82a60d50
	if !ctx.cr[6].eq {
	pc = 0x82A60D50; continue 'dispatch;
	}
	// 82A60D18: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60D1C: 7D0A5378  or r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 82A60D20: 38DF00A8  addi r6, r31, 0xa8
	ctx.r[6].s64 = ctx.r[31].s64 + 168;
	// 82A60D24: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A60D28: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 82A60D2C: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 82A60D30: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A60D34: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60D38: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A60D3C: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82A60D40: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A60D44: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60D48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A60D4C: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
            }
            0x82A60D50 => {
    //   block [0x82A60D50..0x82A60D84)
	// 82A60D50: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A60D54: 913F00AC  stw r9, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 82A60D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A60D5C: 409A0028  bne cr6, 0x82a60d84
	if !ctx.cr[6].eq {
	pc = 0x82A60D84; continue 'dispatch;
	}
	// 82A60D60: 817A0DB0  lwz r11, 0xdb0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A60D64: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 82A60D68: 393F00A8  addi r9, r31, 0xa8
	ctx.r[9].s64 = ctx.r[31].s64 + 168;
	// 82A60D6C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A60D70: 995F00BC  stb r10, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 82A60D74: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82A60D78: 909A0DB0  stw r4, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A60D7C: 7D28C12E  stwx r9, r8, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[24].u32), ctx.r[9].u32) };
	// 82A60D80: 48000008  b 0x82a60d88
	pc = 0x82A60D88; continue 'dispatch;
            }
            0x82A60D84 => {
    //   block [0x82A60D84..0x82A60D88)
	// 82A60D84: 809A0DB0  lwz r4, 0xdb0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A60D88; continue 'dispatch;
            }
            0x82A60D88 => {
    //   block [0x82A60D88..0x82A60DFC)
	// 82A60D88: 891F0045  lbz r8, 0x45(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 82A60D8C: 893600E4  lbz r9, 0xe4(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A60D90: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A60D94: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A60D98: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82A60D9C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A60DA0: 54E8DFFE  rlwinm r8, r7, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82A60DA4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82A60DA8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A60DAC: 419A007C  beq cr6, 0x82a60e28
	if ctx.cr[6].eq {
	pc = 0x82A60E28; continue 'dispatch;
	}
	// 82A60DB0: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A60DB4: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A60DB8: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 82A60DBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A60DC0: 409A003C  bne cr6, 0x82a60dfc
	if !ctx.cr[6].eq {
	pc = 0x82A60DFC; continue 'dispatch;
	}
	// 82A60DC4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60DC8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82A60DCC: 38DF0030  addi r6, r31, 0x30
	ctx.r[6].s64 = ctx.r[31].s64 + 48;
	// 82A60DD0: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A60DD4: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82A60DD8: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 82A60DDC: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A60DE0: 806B2004  lwz r3, 0x2004(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60DE4: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A60DE8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A60DEC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A60DF0: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60DF4: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82A60DF8: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A60DFC; continue 'dispatch;
            }
            0x82A60DFC => {
    //   block [0x82A60DFC..0x82A60E28)
	// 82A60DFC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A60E00: 911F0034  stw r8, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 82A60E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A60E08: 409A0020  bne cr6, 0x82a60e28
	if !ctx.cr[6].eq {
	pc = 0x82A60E28; continue 'dispatch;
	}
	// 82A60E0C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A60E10: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82A60E14: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 82A60E18: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A60E1C: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82A60E20: 909A0DB0  stw r4, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A60E24: 7D2AC12E  stwx r9, r10, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[24].u32), ctx.r[9].u32) };
	pc = 0x82A60E28; continue 'dispatch;
            }
            0x82A60E28 => {
    //   block [0x82A60E28..0x82A60E7C)
	// 82A60E28: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A60E2C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A60E30: 3BABDED4  addi r29, r11, -0x212c
	ctx.r[29].s64 = ctx.r[11].s64 + -8492;
	// 82A60E34: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 82A60E38: 7939FFE6  rldicr r25, r9, 0x3f, 0x3f
	ctx.r[25].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A60E3C: 3B8A6F38  addi r28, r10, 0x6f38
	ctx.r[28].s64 = ctx.r[10].s64 + 28472;
	// 82A60E40: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60E44: 83C8009C  lwz r30, 0x9c(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A60E48: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82A60E4C: 419A0168  beq cr6, 0x82a60fb4
	if ctx.cr[6].eq {
	pc = 0x82A60FB4; continue 'dispatch;
	}
	// 82A60E50: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A60E54: 41980028  blt cr6, 0x82a60e7c
	if ctx.cr[6].lt {
	pc = 0x82A60E7C; continue 'dispatch;
	}
	// 82A60E58: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 82A60E5C: 814100D0  lwz r10, 0xd0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82A60E60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A60E64: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A60E68: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82A60E6C: 7F264C36  srd r6, r25, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[25].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82A60E70: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60E74: 4B75606D  bl 0x821b6ee0
	ctx.lr = 0x82A60E78;
	sub_821B6EE0(ctx, base);
	// 82A60E78: 809A0DB0  lwz r4, 0xdb0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A60E7C; continue 'dispatch;
            }
            0x82A60E7C => {
    //   block [0x82A60E7C..0x82A60F00)
	// 82A60E7C: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A60E80: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60E84: 395F0AB0  addi r10, r31, 0xab0
	ctx.r[10].s64 = ctx.r[31].s64 + 2736;
	// 82A60E88: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A60E8C: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82A60E90: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A60E94: 7D665214  add r11, r6, r10
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82A60E98: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A60E9C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60EA0: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A60EA4: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A60EA8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A60EAC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A60EB0: 419A0074  beq cr6, 0x82a60f24
	if ctx.cr[6].eq {
	pc = 0x82A60F24; continue 'dispatch;
	}
	// 82A60EB4: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A60EB8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60EBC: 7CE34038  and r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A60EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A60EC4: 409A003C  bne cr6, 0x82a60f00
	if !ctx.cr[6].eq {
	pc = 0x82A60F00; continue 'dispatch;
	}
	// 82A60EC8: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60ECC: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A60ED0: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A60ED4: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A60ED8: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A60EDC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60EE0: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A60EE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60EE8: 7D095214  add r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A60EEC: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A60EF0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60EF4: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82A60EF8: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60EFC: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A60F00; continue 'dispatch;
            }
            0x82A60F00 => {
    //   block [0x82A60F00..0x82A60F24)
	// 82A60F00: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A60F04: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A60F08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A60F0C: 409A0018  bne cr6, 0x82a60f24
	if !ctx.cr[6].eq {
	pc = 0x82A60F24; continue 'dispatch;
	}
	// 82A60F10: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A60F14: 9AAB0014  stb r21, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[21].u8 ) };
	// 82A60F18: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A60F1C: 909A0DB0  stw r4, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A60F20: 7D6AC12E  stwx r11, r10, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[24].u32), ctx.r[11].u32) };
	pc = 0x82A60F24; continue 'dispatch;
            }
            0x82A60F24 => {
    //   block [0x82A60F24..0x82A60F90)
	// 82A60F24: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 82A60F28: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A60F2C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A60F30: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60F34: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A60F38: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A60F3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A60F40: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A60F44: 419A0070  beq cr6, 0x82a60fb4
	if ctx.cr[6].eq {
	pc = 0x82A60FB4; continue 'dispatch;
	}
	// 82A60F48: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A60F4C: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A60F50: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A60F54: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A60F58: 409A0038  bne cr6, 0x82a60f90
	if !ctx.cr[6].eq {
	pc = 0x82A60F90; continue 'dispatch;
	}
	// 82A60F5C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60F60: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A60F64: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A60F68: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A60F6C: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A60F70: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60F74: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60F78: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A60F7C: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A60F80: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A60F84: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A60F88: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 82A60F8C: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x82A60F90; continue 'dispatch;
            }
            0x82A60F90 => {
    //   block [0x82A60F90..0x82A60FB4)
	// 82A60F90: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A60F94: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A60F98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A60F9C: 409A0018  bne cr6, 0x82a60fb4
	if !ctx.cr[6].eq {
	pc = 0x82A60FB4; continue 'dispatch;
	}
	// 82A60FA0: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A60FA4: 9AAB0014  stb r21, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[21].u8 ) };
	// 82A60FA8: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 82A60FAC: 915A0DB0  stw r10, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82A60FB0: 7D69C12E  stwx r11, r9, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[24].u32), ctx.r[11].u32) };
	pc = 0x82A60FB4; continue 'dispatch;
            }
            0x82A60FB4 => {
    //   block [0x82A60FB4..0x82A6100C)
	// 82A60FB4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60FB8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A60FBC: 83CB066C  lwz r30, 0x66c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1644 as u32) ) } as u64;
	// 82A60FC0: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82A60FC4: 419A0190  beq cr6, 0x82a61154
	if ctx.cr[6].eq {
	pc = 0x82A61154; continue 'dispatch;
	}
	// 82A60FC8: 807600C4  lwz r3, 0xc4(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A60FCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A60FD0: 419A0184  beq cr6, 0x82a61154
	if ctx.cr[6].eq {
	pc = 0x82A61154; continue 'dispatch;
	}
	// 82A60FD4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A60FD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A60FDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A60FE0: 4B7BDB11  bl 0x8221eaf0
	ctx.lr = 0x82A60FE4;
	sub_8221EAF0(ctx, base);
	// 82A60FE4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A60FE8: 41980024  blt cr6, 0x82a6100c
	if ctx.cr[6].lt {
	pc = 0x82A6100C; continue 'dispatch;
	}
	// 82A60FEC: 395E0020  addi r10, r30, 0x20
	ctx.r[10].s64 = ctx.r[30].s64 + 32;
	// 82A60FF0: 81770364  lwz r11, 0x364(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A60FF4: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A60FF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A60FFC: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82A61000: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A61004: 7F264C36  srd r6, r25, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[25].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82A61008: 4B755ED9  bl 0x821b6ee0
	ctx.lr = 0x82A6100C;
	sub_821B6EE0(ctx, base);
	pc = 0x82A6100C; continue 'dispatch;
            }
            0x82A6100C => {
    //   block [0x82A6100C..0x82A61090)
	// 82A6100C: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A61010: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61014: 397F0AB0  addi r11, r31, 0xab0
	ctx.r[11].s64 = ctx.r[31].s64 + 2736;
	// 82A61018: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82A6101C: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82A61020: 55461838  slwi r6, r10, 3
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A61024: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A61028: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6102C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61030: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A61034: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A61038: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6103C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A61040: 419A007C  beq cr6, 0x82a610bc
	if ctx.cr[6].eq {
	pc = 0x82A610BC; continue 'dispatch;
	}
	// 82A61044: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A61048: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6104C: 7CE44038  and r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A61050: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A61054: 409A003C  bne cr6, 0x82a61090
	if !ctx.cr[6].eq {
	pc = 0x82A61090; continue 'dispatch;
	}
	// 82A61058: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6105C: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A61060: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A61064: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A61068: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6106C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61070: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A61074: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A61078: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A6107C: 90890004  stw r4, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A61080: 813C0008  lwz r9, 8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61084: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A61088: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A6108C: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x82A61090; continue 'dispatch;
            }
            0x82A61090 => {
    //   block [0x82A61090..0x82A610BC)
	// 82A61090: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A61094: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A61098: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6109C: 409A0020  bne cr6, 0x82a610bc
	if !ctx.cr[6].eq {
	pc = 0x82A610BC; continue 'dispatch;
	}
	// 82A610A0: 815A0DB0  lwz r10, 0xdb0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A610A4: 9AAB0014  stb r21, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[21].u8 ) };
	// 82A610A8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A610AC: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82A610B0: 90BA0DB0  stw r5, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 82A610B4: 7D68C12E  stwx r11, r8, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[24].u32), ctx.r[11].u32) };
	// 82A610B8: 48000008  b 0x82a610c0
	pc = 0x82A610C0; continue 'dispatch;
            }
            0x82A610BC => {
    //   block [0x82A610BC..0x82A610C0)
	// 82A610BC: 80BA0DB0  lwz r5, 0xdb0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A610C0; continue 'dispatch;
            }
            0x82A610C0 => {
    //   block [0x82A610C0..0x82A6112C)
	// 82A610C0: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 82A610C4: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A610C8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A610CC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A610D0: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A610D4: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A610D8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A610DC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A610E0: 419A0070  beq cr6, 0x82a61150
	if ctx.cr[6].eq {
	pc = 0x82A61150; continue 'dispatch;
	}
	// 82A610E4: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A610E8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A610EC: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A610F0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A610F4: 409A0038  bne cr6, 0x82a6112c
	if !ctx.cr[6].eq {
	pc = 0x82A6112C; continue 'dispatch;
	}
	// 82A610F8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A610FC: 7CE44378  or r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A61100: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A61104: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A61108: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6110C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A61110: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61114: 54C81838  slwi r8, r6, 3
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A61118: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6111C: 90E40004  stw r7, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A61120: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A61124: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 82A61128: 906A2004  stw r3, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6112C; continue 'dispatch;
            }
            0x82A6112C => {
    //   block [0x82A6112C..0x82A61150)
	// 82A6112C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A61130: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A61134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A61138: 409A0018  bne cr6, 0x82a61150
	if !ctx.cr[6].eq {
	pc = 0x82A61150; continue 'dispatch;
	}
	// 82A6113C: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A61140: 9AAB0014  stb r21, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[21].u8 ) };
	// 82A61144: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 82A61148: 915A0DB0  stw r10, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82A6114C: 7D69C12E  stwx r11, r9, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[24].u32), ctx.r[11].u32) };
	pc = 0x82A61150; continue 'dispatch;
            }
            0x82A61150 => {
    //   block [0x82A61150..0x82A61154)
	// 82A61150: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	pc = 0x82A61154; continue 'dispatch;
            }
            0x82A61154 => {
    //   block [0x82A61154..0x82A61180)
	// 82A61154: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A61158: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 82A6115C: 796A0004  rldicr r10, r11, 0, 0
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 82A61160: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 82A61164: 419A001C  beq cr6, 0x82a61180
	if ctx.cr[6].eq {
	pc = 0x82A61180; continue 'dispatch;
	}
	// 82A61168: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82A6116C: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A61170: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A61174: 38B406B0  addi r5, r20, 0x6b0
	ctx.r[5].s64 = ctx.r[20].s64 + 1712;
	// 82A61178: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6117C: 4B7B9705  bl 0x8221a880
	ctx.lr = 0x82A61180;
	sub_8221A880(ctx, base);
	pc = 0x82A61180; continue 'dispatch;
            }
            0x82A61180 => {
    //   block [0x82A61180..0x82A614A0)
	// 82A61180: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A61184: 3860006E  li r3, 0x6e
	ctx.r[3].s64 = 110;
	// 82A61188: 4B858E59  bl 0x822b9fe0
	ctx.lr = 0x82A6118C;
	sub_822B9FE0(ctx, base);
	// 82A6118C: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 82A61190: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	pc = 0x82A614A0; continue 'dispatch;
            }
            0x82A614A0 => {
    //   block [0x82A614A0..0x82A614B4)
	// 82A614A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A614A4: 4B7BDE3D  bl 0x8221f2e0
	ctx.lr = 0x82A614A8;
	sub_8221F2E0(ctx, base);
	// 82A614A8: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 82A614AC: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82A614B0: 48247F88  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A614B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A614B8 size=728
    let mut pc: u32 = 0x82A614B8;
    'dispatch: loop {
        match pc {
            0x82A614B8 => {
    //   block [0x82A614B8..0x82A6150C)
	// 82A614B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A614BC: 48247F4D  bl 0x82ca9408
	ctx.lr = 0x82A614C0;
	sub_82CA93D0(ctx, base);
	// 82A614C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A614C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A614C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A614CC: 397F0048  addi r11, r31, 0x48
	ctx.r[11].s64 = ctx.r[31].s64 + 72;
	// 82A614D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A614D4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A614D8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A614DC: 5149083C  rlwimi r9, r10, 1, 0, 0x1e
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[9].u64 & 0xFFFFFFFF00000001);
	// 82A614E0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A614E4: C81F0050  lfd f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 82A614E8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A614EC: 40990020  ble cr6, 0x82a6150c
	if !ctx.cr[6].gt {
	pc = 0x82A6150C; continue 'dispatch;
	}
	// 82A614F0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A614F4: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 82A614F8: D82B0008  stfd f1, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[1].u64 ) };
	// 82A614FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A61500: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A61504: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A61508: 48000008  b 0x82a61510
	pc = 0x82A61510; continue 'dispatch;
            }
            0x82A6150C => {
    //   block [0x82A6150C..0x82A61510)
	// 82A6150C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x82A61510; continue 'dispatch;
            }
            0x82A61510 => {
    //   block [0x82A61510..0x82A61540)
	// 82A61510: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A61514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A61518: 419A0028  beq cr6, 0x82a61540
	if ctx.cr[6].eq {
	pc = 0x82A61540; continue 'dispatch;
	}
	// 82A6151C: E97F0080  ld r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	// 82A61520: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 82A61524: E93F0088  ld r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	// 82A61528: E91F0090  ld r8, 0x90(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	// 82A6152C: E8FF0098  ld r7, 0x98(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	// 82A61530: F97F0060  std r11, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A61534: F93F0068  std r9, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 82A61538: F91F0070  std r8, 0x70(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 82A6153C: F8FF0078  std r7, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u64 ) };
	pc = 0x82A61540; continue 'dispatch;
            }
            0x82A61540 => {
    //   block [0x82A61540..0x82A61788)
	// 82A61540: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A61544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A61548: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6154C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A61550: 4E800421  bctrl
	ctx.lr = 0x82A61554;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A61554: 2F03002F  cmpwi cr6, r3, 0x2f
	ctx.cr[6].compare_i32(ctx.r[3].s32, 47, &mut ctx.xer);
	// 82A61558: 409A0230  bne cr6, 0x82a61788
	if !ctx.cr[6].eq {
	pc = 0x82A61788; continue 'dispatch;
	}
	// 82A6155C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82A61560: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 82A61564: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 82A61568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            0x82A61788 => {
    //   block [0x82A61788..0x82A61790)
	// 82A61788: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6178C: 48247CCC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A61790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A61790 size=20
    let mut pc: u32 = 0x82A61790;
    'dispatch: loop {
        match pc {
            0x82A61790 => {
    //   block [0x82A61790..0x82A617A4)
	// 82A61790: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A61798: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A6179C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A617A0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A617A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A617A8 size=80
    let mut pc: u32 = 0x82A617A8;
    'dispatch: loop {
        match pc {
            0x82A617A8 => {
    //   block [0x82A617A8..0x82A617E0)
	// 82A617A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A617AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A617B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A617B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A617B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A617BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A617C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A617C4: 48000035  bl 0x82a617f8
	ctx.lr = 0x82A617C8;
	sub_82A617F8(ctx, base);
	// 82A617C8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A617CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A617D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A617D4: 419A000C  beq cr6, 0x82a617e0
	if ctx.cr[6].eq {
	pc = 0x82A617E0; continue 'dispatch;
	}
	// 82A617D8: 4B7BA561  bl 0x8221bd38
	ctx.lr = 0x82A617DC;
	sub_8221BD38(ctx, base);
	// 82A617DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A617E0; continue 'dispatch;
            }
            0x82A617E0 => {
    //   block [0x82A617E0..0x82A617F8)
	// 82A617E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A617E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A617E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A617EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A617F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A617F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A617F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A617F8 size=104
    let mut pc: u32 = 0x82A617F8;
    'dispatch: loop {
        match pc {
            0x82A617F8 => {
    //   block [0x82A617F8..0x82A61830)
	// 82A617F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A617FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A61800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A61804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A61808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6180C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A61810: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A61814: 3BFE0048  addi r31, r30, 0x48
	ctx.r[31].s64 = ctx.r[30].s64 + 72;
	// 82A61818: 394B6D78  addi r10, r11, 0x6d78
	ctx.r[10].s64 = ctx.r[11].s64 + 28024;
	// 82A6181C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A61820: 807E004C  lwz r3, 0x4c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A61824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A61828: 419A0008  beq cr6, 0x82a61830
	if ctx.cr[6].eq {
	pc = 0x82A61830; continue 'dispatch;
	}
	// 82A6182C: 4B7BA50D  bl 0x8221bd38
	ctx.lr = 0x82A61830;
	sub_8221BD38(ctx, base);
	pc = 0x82A61830; continue 'dispatch;
            }
            0x82A61830 => {
    //   block [0x82A61830..0x82A61860)
	// 82A61830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A61834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A61838: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A6183C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A61840: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A61844: 48017C5D  bl 0x82a794a0
	ctx.lr = 0x82A61848;
	sub_82A794A0(ctx, base);
	// 82A61848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6184C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A61850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A61854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A61858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6185C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A61860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A61860 size=964
    let mut pc: u32 = 0x82A61860;
    'dispatch: loop {
        match pc {
            0x82A61860 => {
    //   block [0x82A61860..0x82A61C24)
	// 82A61860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A61864: 48247B99  bl 0x82ca93fc
	ctx.lr = 0x82A61868;
	sub_82CA93D0(ctx, base);
	// 82A61868: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A61C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A61C28 size=360
    let mut pc: u32 = 0x82A61C28;
    'dispatch: loop {
        match pc {
            0x82A61C28 => {
    //   block [0x82A61C28..0x82A61D58)
	// 82A61C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A61C2C: 482477D5  bl 0x82ca9400
	ctx.lr = 0x82A61C30;
	sub_82CA93D0(ctx, base);
	// 82A61C30: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A61C34: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A61C38: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A61C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A61C40: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61C44: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61C48: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 82A61C4C: 915A0008  stw r10, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A61C50: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A61C54: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61C58: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A61C5C: 4E800421  bctrl
	ctx.lr = 0x82A61C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A61C60: 2F03000C  cmpwi cr6, r3, 0xc
	ctx.cr[6].compare_i32(ctx.r[3].s32, 12, &mut ctx.xer);
	// 82A61C64: 409A0124  bne cr6, 0x82a61d88
	if !ctx.cr[6].eq {
	pc = 0x82A61D88; continue 'dispatch;
	}
	// 82A61C68: 3B9A0048  addi r28, r26, 0x48
	ctx.r[28].s64 = ctx.r[26].s64 + 72;
	// 82A61C6C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A61C70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A61C74: E8C10078  ld r6, 0x78(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A61C78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A61C7C: E8E10080  ld r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A61C80: 480001E1  bl 0x82a61e60
	ctx.lr = 0x82A61C84;
	sub_82A61E60(ctx, base);
	// 82A61C84: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A61C88: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A61C8C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A61C90: 7D3F2E71  srawi. r31, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A61C94: 408100C4  ble 0x82a61d58
	if !ctx.cr[0].gt {
	pc = 0x82A61D58; continue 'dispatch;
	}
	// 82A61C98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A61C9C: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82A61CA0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A61CA4: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 82A61CA8: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82A61CAC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A61CB0: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 82A61CB4: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82A61CB8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82A61CBC: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
            }
            0x82A61D58 => {
    //   block [0x82A61D58..0x82A61D88)
	// 82A61D58: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A61D5C: 395D0018  addi r10, r29, 0x18
	ctx.r[10].s64 = ctx.r[29].s64 + 24;
	// 82A61D60: 393A0058  addi r9, r26, 0x58
	ctx.r[9].s64 = ctx.r[26].s64 + 88;
	// 82A61D64: 997A0058  stb r11, 0x58(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82A61D68: 891D0019  lbz r8, 0x19(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A61D6C: 991A0059  stb r8, 0x59(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
	// 82A61D70: 88FD001A  lbz r7, 0x1a(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(26 as u32) ) } as u64;
	// 82A61D74: 98FA005A  stb r7, 0x5a(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(90 as u32), ctx.r[7].u8 ) };
	// 82A61D78: 88DD001B  lbz r6, 0x1b(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(27 as u32) ) } as u64;
	// 82A61D7C: 98DA005B  stb r6, 0x5b(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(91 as u32), ctx.r[6].u8 ) };
	// 82A61D80: 88BD001C  lbz r5, 0x1c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A61D84: 98BA005C  stb r5, 0x5c(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(92 as u32), ctx.r[5].u8 ) };
	pc = 0x82A61D88; continue 'dispatch;
            }
            0x82A61D88 => {
    //   block [0x82A61D88..0x82A61D90)
	// 82A61D88: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A61D8C: 482476C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A61D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A61D90 size=208
    let mut pc: u32 = 0x82A61D90;
    'dispatch: loop {
        match pc {
            0x82A61D90 => {
    //   block [0x82A61D90..0x82A61DB8)
	// 82A61D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A61D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A61D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A61D9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61DA0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A61DA4: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 82A61DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A61DAC: 409A000C  bne cr6, 0x82a61db8
	if !ctx.cr[6].eq {
	pc = 0x82A61DB8; continue 'dispatch;
	}
	// 82A61DB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A61DB4: 48000010  b 0x82a61dc4
	pc = 0x82A61DC4; continue 'dispatch;
            }
            0x82A61DB8 => {
    //   block [0x82A61DB8..0x82A61DC4)
	// 82A61DB8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61DBC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A61DC0: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82A61DC4; continue 'dispatch;
            }
            0x82A61DC4 => {
    //   block [0x82A61DC4..0x82A61DFC)
	// 82A61DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A61DC8: 419A0060  beq cr6, 0x82a61e28
	if ctx.cr[6].eq {
	pc = 0x82A61E28; continue 'dispatch;
	}
	// 82A61DCC: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A61DD0: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A61DD4: 7CA74BD6  divw r5, r7, r9
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 82A61DD8: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A61DDC: 4098004C  bge cr6, 0x82a61e28
	if !ctx.cr[6].lt {
	pc = 0x82A61E28; continue 'dispatch;
	}
	// 82A61DE0: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61DE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A61DE8: 419A0028  beq cr6, 0x82a61e10
	if ctx.cr[6].eq {
	pc = 0x82A61E10; continue 'dispatch;
	}
	// 82A61DEC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A61DF0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A61DF4: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A61DF8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A61DFC; continue 'dispatch;
            }
            0x82A61DFC => {
    //   block [0x82A61DFC..0x82A61E10)
	// 82A61DFC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A61E00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A61E04: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A61E08: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A61E0C: 4200FFF0  bdnz 0x82a61dfc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A61DFC; continue 'dispatch;
	}
	pc = 0x82A61E10; continue 'dispatch;
            }
            0x82A61E10 => {
    //   block [0x82A61E10..0x82A61E28)
	// 82A61E10: 39680018  addi r11, r8, 0x18
	ctx.r[11].s64 = ctx.r[8].s64 + 24;
	// 82A61E14: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A61E18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A61E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A61E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A61E24: 4E800020  blr
	return;
            }
            0x82A61E28 => {
    //   block [0x82A61E28..0x82A61E38)
	// 82A61E28: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61E2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A61E30: 40990008  ble cr6, 0x82a61e38
	if !ctx.cr[6].gt {
	pc = 0x82A61E38; continue 'dispatch;
	}
	// 82A61E34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61E38; continue 'dispatch;
            }
            0x82A61E38 => {
    //   block [0x82A61E38..0x82A61E60)
	// 82A61E38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82A61E3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A61E40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A61E44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A61E48: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A61E4C: 480000F5  bl 0x82a61f40
	ctx.lr = 0x82A61E50;
	sub_82A61F40(ctx, base);
	// 82A61E50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A61E54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A61E58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A61E5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A61E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A61E60 size=224
    let mut pc: u32 = 0x82A61E60;
    'dispatch: loop {
        match pc {
            0x82A61E60 => {
    //   block [0x82A61E60..0x82A61E9C)
	// 82A61E60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61E64: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82A61E68: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82A61E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A61E70: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82A61E74: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A61E78: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61E7C: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 82A61E80: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A61E84: 7CE853D7  divw. r7, r8, r10
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A61E88: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82A61E8C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A61E90: 4099000C  ble cr6, 0x82a61e9c
	if !ctx.cr[6].gt {
	pc = 0x82A61E9C; continue 'dispatch;
	}
	// 82A61E94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82A61E98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61E9C; continue 'dispatch;
            }
            0x82A61E9C => {
    //   block [0x82A61E9C..0x82A61EC4)
	// 82A61E9C: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61EA0: 9061FFF0  stw r3, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[3].u32 ) };
	// 82A61EA4: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82A61EA8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A61EAC: E8E1FFF0  ld r7, -0x10(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A61EB0: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82A61EB4: 41990010  bgt cr6, 0x82a61ec4
	if ctx.cr[6].gt {
	pc = 0x82A61EC4; continue 'dispatch;
	}
	// 82A61EB8: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61EBC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A61EC0: 40980008  bge cr6, 0x82a61ec8
	if !ctx.cr[6].lt {
	pc = 0x82A61EC8; continue 'dispatch;
	}
	pc = 0x82A61EC4; continue 'dispatch;
            }
            0x82A61EC4 => {
    //   block [0x82A61EC4..0x82A61EC8)
	// 82A61EC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61EC8; continue 'dispatch;
            }
            0x82A61EC8 => {
    //   block [0x82A61EC8..0x82A61ED8)
	// 82A61EC8: 8101FFF0  lwz r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A61ECC: 7F081840  cmplw cr6, r8, r3
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A61ED0: 419A0008  beq cr6, 0x82a61ed8
	if ctx.cr[6].eq {
	pc = 0x82A61ED8; continue 'dispatch;
	}
	// 82A61ED4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61ED8; continue 'dispatch;
            }
            0x82A61ED8 => {
    //   block [0x82A61ED8..0x82A61F08)
	// 82A61ED8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A61EDC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A61EE0: 7CE94850  subf r7, r9, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[9].s64;
	// 82A61EE4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82A61EE8: 7D4753D6  divw r10, r7, r10
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	// 82A61EEC: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A61EF0: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A61EF4: 7CCA3A14  add r6, r10, r7
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82A61EF8: 54CA1838  slwi r10, r6, 3
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A61EFC: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A61F00: 419A0038  beq cr6, 0x82a61f38
	if ctx.cr[6].eq {
	pc = 0x82A61F38; continue 'dispatch;
	}
	// 82A61F04: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x82A61F08; continue 'dispatch;
            }
            0x82A61F08 => {
    //   block [0x82A61F08..0x82A61F18)
	// 82A61F08: 7D464214  add r10, r6, r8
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82A61F0C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A61F10: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A61F14: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A61F18; continue 'dispatch;
            }
            0x82A61F18 => {
    //   block [0x82A61F18..0x82A61F38)
	// 82A61F18: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A61F1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A61F20: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A61F24: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A61F28: 4200FFF0  bdnz 0x82a61f18
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A61F18; continue 'dispatch;
	}
	// 82A61F2C: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A61F30: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A61F34: 409AFFD4  bne cr6, 0x82a61f08
	if !ctx.cr[6].eq {
	pc = 0x82A61F08; continue 'dispatch;
	}
	pc = 0x82A61F38; continue 'dispatch;
            }
            0x82A61F38 => {
    //   block [0x82A61F38..0x82A61F40)
	// 82A61F38: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A61F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A61F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A61F40 size=232
    let mut pc: u32 = 0x82A61F40;
    'dispatch: loop {
        match pc {
            0x82A61F40 => {
    //   block [0x82A61F40..0x82A61F7C)
	// 82A61F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A61F44: 482474C9  bl 0x82ca940c
	ctx.lr = 0x82A61F48;
	sub_82CA93D0(ctx, base);
	// 82A61F48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A61F4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A61F50: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A61F54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A61F58: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 82A61F5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A61F64: 419A0018  beq cr6, 0x82a61f7c
	if ctx.cr[6].eq {
	pc = 0x82A61F7C; continue 'dispatch;
	}
	// 82A61F68: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61F6C: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 82A61F70: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A61F74: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A61F78: 4082000C  bne 0x82a61f84
	if !ctx.cr[0].eq {
	pc = 0x82A61F84; continue 'dispatch;
	}
	pc = 0x82A61F7C; continue 'dispatch;
            }
            0x82A61F7C => {
    //   block [0x82A61F7C..0x82A61F84)
	// 82A61F7C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A61F80: 48000034  b 0x82a61fb4
	pc = 0x82A61FB4; continue 'dispatch;
            }
            0x82A61F84 => {
    //   block [0x82A61F84..0x82A61F90)
	// 82A61F84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A61F88: 40990008  ble cr6, 0x82a61f90
	if !ctx.cr[6].gt {
	pc = 0x82A61F90; continue 'dispatch;
	}
	// 82A61F8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61F90; continue 'dispatch;
            }
            0x82A61F90 => {
    //   block [0x82A61F90..0x82A61FA4)
	// 82A61F90: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82A61F94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A61F98: 419A000C  beq cr6, 0x82a61fa4
	if ctx.cr[6].eq {
	pc = 0x82A61FA4; continue 'dispatch;
	}
	// 82A61F9C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A61FA0: 419A0008  beq cr6, 0x82a61fa8
	if ctx.cr[6].eq {
	pc = 0x82A61FA8; continue 'dispatch;
	}
	pc = 0x82A61FA4; continue 'dispatch;
            }
            0x82A61FA4 => {
    //   block [0x82A61FA4..0x82A61FA8)
	// 82A61FA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61FA8; continue 'dispatch;
            }
            0x82A61FA8 => {
    //   block [0x82A61FA8..0x82A61FB4)
	// 82A61FA8: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A61FAC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A61FB0: 7FC84BD6  divw r30, r8, r9
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82A61FB4; continue 'dispatch;
            }
            0x82A61FB4 => {
    //   block [0x82A61FB4..0x82A61FD4)
	// 82A61FB4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A61FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A61FBC: 4800006D  bl 0x82a62028
	ctx.lr = 0x82A61FC0;
	sub_82A62028(ctx, base);
	// 82A61FC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A61FC4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61FC8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A61FCC: 40990008  ble cr6, 0x82a61fd4
	if !ctx.cr[6].gt {
	pc = 0x82A61FD4; continue 'dispatch;
	}
	// 82A61FD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A61FD4; continue 'dispatch;
            }
            0x82A61FD4 => {
    //   block [0x82A61FD4..0x82A6200C)
	// 82A61FD4: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A61FD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A61FDC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A61FE0: 7D1E5214  add r8, r30, r10
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82A61FE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A61FE8: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A61FEC: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A61FF0: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82A61FF4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A61FF8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A61FFC: 41990010  bgt cr6, 0x82a6200c
	if ctx.cr[6].gt {
	pc = 0x82A6200C; continue 'dispatch;
	}
	// 82A62000: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62004: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A62008: 40980008  bge cr6, 0x82a62010
	if !ctx.cr[6].lt {
	pc = 0x82A62010; continue 'dispatch;
	}
	pc = 0x82A6200C; continue 'dispatch;
            }
            0x82A6200C => {
    //   block [0x82A6200C..0x82A62010)
	// 82A6200C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A62010; continue 'dispatch;
            }
            0x82A62010 => {
    //   block [0x82A62010..0x82A62028)
	// 82A62010: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A62014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A62018: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A6201C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A62020: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A62024: 48247438  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A62028 size=1168
    let mut pc: u32 = 0x82A62028;
    'dispatch: loop {
        match pc {
            0x82A62028 => {
    //   block [0x82A62028..0x82A62050)
	// 82A62028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6202C: 482473D9  bl 0x82ca9404
	ctx.lr = 0x82A62030;
	sub_82CA93D0(ctx, base);
	// 82A62030: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62034: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A62038: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A6203C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A62040: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A62044: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A62048: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A6204C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A62050; continue 'dispatch;
            }
            0x82A62050 => {
    //   block [0x82A62050..0x82A6207C)
	// 82A62050: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62054: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A62058: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6205C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A62060: 4200FFF0  bdnz 0x82a62050
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62050; continue 'dispatch;
	}
	// 82A62064: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62068: 3B600018  li r27, 0x18
	ctx.r[27].s64 = 24;
	// 82A6206C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62070: 409A000C  bne cr6, 0x82a6207c
	if !ctx.cr[6].eq {
	pc = 0x82A6207C; continue 'dispatch;
	}
	// 82A62074: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A62078: 48000010  b 0x82a62088
	pc = 0x82A62088; continue 'dispatch;
            }
            0x82A6207C => {
    //   block [0x82A6207C..0x82A62088)
	// 82A6207C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A62080: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A62084: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A62088; continue 'dispatch;
            }
            0x82A62088 => {
    //   block [0x82A62088..0x82A620A0)
	// 82A62088: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6208C: 419A0424  beq cr6, 0x82a624b0
	if ctx.cr[6].eq {
	pc = 0x82A624B0; continue 'dispatch;
	}
	// 82A62090: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62094: 409A000C  bne cr6, 0x82a620a0
	if !ctx.cr[6].eq {
	pc = 0x82A620A0; continue 'dispatch;
	}
	// 82A62098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6209C: 48000010  b 0x82a620ac
	pc = 0x82A620AC; continue 'dispatch;
            }
            0x82A620A0 => {
    //   block [0x82A620A0..0x82A620AC)
	// 82A620A0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A620A4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A620A8: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A620AC; continue 'dispatch;
            }
            0x82A620AC => {
    //   block [0x82A620AC..0x82A620CC)
	// 82A620AC: 3D200AAA  lis r9, 0xaaa
	ctx.r[9].s64 = 178913280;
	// 82A620B0: 6129AAAA  ori r9, r9, 0xaaaa
	ctx.r[9].u64 = ctx.r[9].u64 | 43690;
	// 82A620B4: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A620B8: 7F07F840  cmplw cr6, r7, r31
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A620BC: 40980010  bge cr6, 0x82a620cc
	if !ctx.cr[6].lt {
	pc = 0x82A620CC; continue 'dispatch;
	}
	// 82A620C0: 4BA92A11  bl 0x824f4ad0
	ctx.lr = 0x82A620C4;
	sub_824F4AD0(ctx, base);
	// 82A620C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A620C8: 4824738C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A620CC => {
    //   block [0x82A620CC..0x82A620DC)
	// 82A620CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A620D0: 409A000C  bne cr6, 0x82a620dc
	if !ctx.cr[6].eq {
	pc = 0x82A620DC; continue 'dispatch;
	}
	// 82A620D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A620D8: 48000010  b 0x82a620e8
	pc = 0x82A620E8; continue 'dispatch;
            }
            0x82A620DC => {
    //   block [0x82A620DC..0x82A620E8)
	// 82A620DC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A620E0: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A620E4: 7D67DBD6  divw r11, r7, r27
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	pc = 0x82A620E8; continue 'dispatch;
            }
            0x82A620E8 => {
    //   block [0x82A620E8..0x82A6210C)
	// 82A620E8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A620EC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A620F0: 409801D4  bge cr6, 0x82a622c4
	if !ctx.cr[6].lt {
	pc = 0x82A622C4; continue 'dispatch;
	}
	// 82A620F4: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A620F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A620FC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A62100: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A62104: 41980008  blt cr6, 0x82a6210c
	if ctx.cr[6].lt {
	pc = 0x82A6210C; continue 'dispatch;
	}
	// 82A62108: 7FAB4214  add r29, r11, r8
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	pc = 0x82A6210C; continue 'dispatch;
            }
            0x82A6210C => {
    //   block [0x82A6210C..0x82A6211C)
	// 82A6210C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62110: 409A000C  bne cr6, 0x82a6211c
	if !ctx.cr[6].eq {
	pc = 0x82A6211C; continue 'dispatch;
	}
	// 82A62114: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A62118: 48000010  b 0x82a62128
	pc = 0x82A62128; continue 'dispatch;
            }
            0x82A6211C => {
    //   block [0x82A6211C..0x82A62128)
	// 82A6211C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A62120: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A62124: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A62128; continue 'dispatch;
            }
            0x82A62128 => {
    //   block [0x82A62128..0x82A62144)
	// 82A62128: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A6212C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A62130: 40980024  bge cr6, 0x82a62154
	if !ctx.cr[6].lt {
	pc = 0x82A62154; continue 'dispatch;
	}
	// 82A62134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62138: 409A000C  bne cr6, 0x82a62144
	if !ctx.cr[6].eq {
	pc = 0x82A62144; continue 'dispatch;
	}
	// 82A6213C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A62140: 48000010  b 0x82a62150
	pc = 0x82A62150; continue 'dispatch;
            }
            0x82A62144 => {
    //   block [0x82A62144..0x82A62150)
	// 82A62144: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A62148: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A6214C: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	pc = 0x82A62150; continue 'dispatch;
            }
            0x82A62150 => {
    //   block [0x82A62150..0x82A62154)
	// 82A62150: 7FABFA14  add r29, r11, r31
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x82A62154; continue 'dispatch;
            }
            0x82A62154 => {
    //   block [0x82A62154..0x82A62178)
	// 82A62154: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A62158: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A6215C: 48021F9D  bl 0x82a840f8
	ctx.lr = 0x82A62160;
	sub_82A840F8(ctx, base);
	// 82A62160: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62164: 80A100BC  lwz r5, 0xbc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A62168: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6216C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A62170: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A62174: 419A0040  beq cr6, 0x82a621b4
	if ctx.cr[6].eq {
	pc = 0x82A621B4; continue 'dispatch;
	}
	pc = 0x82A62178; continue 'dispatch;
            }
            0x82A62178 => {
    //   block [0x82A62178..0x82A62190)
	// 82A62178: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6217C: 419A0028  beq cr6, 0x82a621a4
	if ctx.cr[6].eq {
	pc = 0x82A621A4; continue 'dispatch;
	}
	// 82A62180: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A62184: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A62188: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A6218C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A62190; continue 'dispatch;
            }
            0x82A62190 => {
    //   block [0x82A62190..0x82A621A4)
	// 82A62190: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62194: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A62198: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A6219C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A621A0: 4200FFF0  bdnz 0x82a62190
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62190; continue 'dispatch;
	}
	pc = 0x82A621A4; continue 'dispatch;
            }
            0x82A621A4 => {
    //   block [0x82A621A4..0x82A621B4)
	// 82A621A4: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A621A8: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82A621AC: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A621B0: 409AFFC8  bne cr6, 0x82a62178
	if !ctx.cr[6].eq {
	pc = 0x82A62178; continue 'dispatch;
	}
	pc = 0x82A621B4; continue 'dispatch;
            }
            0x82A621B4 => {
    //   block [0x82A621B4..0x82A621C4)
	// 82A621B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A621B8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A621BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A621C0: 419A003C  beq cr6, 0x82a621fc
	if ctx.cr[6].eq {
	pc = 0x82A621FC; continue 'dispatch;
	}
	pc = 0x82A621C4; continue 'dispatch;
            }
            0x82A621C4 => {
    //   block [0x82A621C4..0x82A621DC)
	// 82A621C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A621C8: 419A0028  beq cr6, 0x82a621f0
	if ctx.cr[6].eq {
	pc = 0x82A621F0; continue 'dispatch;
	}
	// 82A621CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A621D0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A621D4: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A621D8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A621DC; continue 'dispatch;
            }
            0x82A621DC => {
    //   block [0x82A621DC..0x82A621F0)
	// 82A621DC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A621E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A621E4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A621E8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A621EC: 4200FFF0  bdnz 0x82a621dc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A621DC; continue 'dispatch;
	}
	pc = 0x82A621F0; continue 'dispatch;
            }
            0x82A621F0 => {
    //   block [0x82A621F0..0x82A621FC)
	// 82A621F0: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A621F4: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A621F8: 4082FFCC  bne 0x82a621c4
	if !ctx.cr[0].eq {
	pc = 0x82A621C4; continue 'dispatch;
	}
	pc = 0x82A621FC; continue 'dispatch;
            }
            0x82A621FC => {
    //   block [0x82A621FC..0x82A62224)
	// 82A621FC: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62200: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A62204: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A62208: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A6220C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62210: 7D2B3A14  add r9, r11, r7
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A62214: 419A004C  beq cr6, 0x82a62260
	if ctx.cr[6].eq {
	pc = 0x82A62260; continue 'dispatch;
	}
	// 82A62218: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A6221C: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A62220: 7D0B2A14  add r8, r11, r5
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	pc = 0x82A62224; continue 'dispatch;
            }
            0x82A62224 => {
    //   block [0x82A62224..0x82A6223C)
	// 82A62224: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A62228: 419A0028  beq cr6, 0x82a62250
	if ctx.cr[6].eq {
	pc = 0x82A62250; continue 'dispatch;
	}
	// 82A6222C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82A62230: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A62234: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A62238: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A6223C; continue 'dispatch;
            }
            0x82A6223C => {
    //   block [0x82A6223C..0x82A62250)
	// 82A6223C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62240: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A62244: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A62248: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A6224C: 4200FFF0  bdnz 0x82a6223c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A6223C; continue 'dispatch;
	}
	pc = 0x82A62250; continue 'dispatch;
            }
            0x82A62250 => {
    //   block [0x82A62250..0x82A62260)
	// 82A62250: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A62254: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A62258: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A6225C: 409AFFC8  bne cr6, 0x82a62224
	if !ctx.cr[6].eq {
	pc = 0x82A62224; continue 'dispatch;
	}
	pc = 0x82A62260; continue 'dispatch;
            }
            0x82A62260 => {
    //   block [0x82A62260..0x82A62274)
	// 82A62260: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A62268: 409A000C  bne cr6, 0x82a62274
	if !ctx.cr[6].eq {
	pc = 0x82A62274; continue 'dispatch;
	}
	// 82A6226C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A62270: 48000010  b 0x82a62280
	pc = 0x82A62280; continue 'dispatch;
            }
            0x82A62274 => {
    //   block [0x82A62274..0x82A62280)
	// 82A62274: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A62278: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A6227C: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	pc = 0x82A62280; continue 'dispatch;
            }
            0x82A62280 => {
    //   block [0x82A62280..0x82A62290)
	// 82A62280: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A62284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A62288: 419A0008  beq cr6, 0x82a62290
	if ctx.cr[6].eq {
	pc = 0x82A62290; continue 'dispatch;
	}
	// 82A6228C: 4B7B9AAD  bl 0x8221bd38
	ctx.lr = 0x82A62290;
	sub_8221BD38(ctx, base);
	pc = 0x82A62290; continue 'dispatch;
            }
            0x82A62290 => {
    //   block [0x82A62290..0x82A622C4)
	// 82A62290: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62294: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A62298: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6229C: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A622A0: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A622A4: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A622A8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A622AC: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A622B0: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A622B4: 90FC0008  stw r7, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A622B8: 911C000C  stw r8, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A622BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A622C0: 48247194  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A622C4 => {
    //   block [0x82A622C4..0x82A622F8)
	// 82A622C4: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A622C8: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A622CC: 7D632850  subf r11, r3, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	// 82A622D0: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A622D4: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A622D8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A622DC: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A622E0: 409800F8  bge cr6, 0x82a623d8
	if !ctx.cr[6].lt {
	pc = 0x82A623D8; continue 'dispatch;
	}
	// 82A622E4: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A622E8: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A622EC: 7D261A14  add r9, r6, r3
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A622F0: 419A0044  beq cr6, 0x82a62334
	if ctx.cr[6].eq {
	pc = 0x82A62334; continue 'dispatch;
	}
	// 82A622F4: 7CE64850  subf r7, r6, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	pc = 0x82A622F8; continue 'dispatch;
            }
            0x82A622F8 => {
    //   block [0x82A622F8..0x82A62310)
	// 82A622F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A622FC: 419A0028  beq cr6, 0x82a62324
	if ctx.cr[6].eq {
	pc = 0x82A62324; continue 'dispatch;
	}
	// 82A62300: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A62304: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A62308: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A6230C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A62310; continue 'dispatch;
            }
            0x82A62310 => {
    //   block [0x82A62310..0x82A62324)
	// 82A62310: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62314: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A62318: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A6231C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A62320: 4200FFF0  bdnz 0x82a62310
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62310; continue 'dispatch;
	}
	pc = 0x82A62324; continue 'dispatch;
            }
            0x82A62324 => {
    //   block [0x82A62324..0x82A62334)
	// 82A62324: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82A62328: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A6232C: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A62330: 409AFFC8  bne cr6, 0x82a622f8
	if !ctx.cr[6].eq {
	pc = 0x82A622F8; continue 'dispatch;
	}
	pc = 0x82A62334; continue 'dispatch;
            }
            0x82A62334 => {
    //   block [0x82A62334..0x82A6234C)
	// 82A62334: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A62338: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A6233C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A62340: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A62344: 7CE9F851  subf. r7, r9, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A62348: 4182003C  beq 0x82a62384
	if ctx.cr[0].eq {
	pc = 0x82A62384; continue 'dispatch;
	}
	pc = 0x82A6234C; continue 'dispatch;
            }
            0x82A6234C => {
    //   block [0x82A6234C..0x82A62364)
	// 82A6234C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A62350: 419A0028  beq cr6, 0x82a62378
	if ctx.cr[6].eq {
	pc = 0x82A62378; continue 'dispatch;
	}
	// 82A62354: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A62358: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A6235C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A62360: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A62364; continue 'dispatch;
            }
            0x82A62364 => {
    //   block [0x82A62364..0x82A62378)
	// 82A62364: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62368: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6236C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A62370: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A62374: 4200FFF0  bdnz 0x82a62364
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62364; continue 'dispatch;
	}
	pc = 0x82A62378; continue 'dispatch;
            }
            0x82A62378 => {
    //   block [0x82A62378..0x82A62384)
	// 82A62378: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A6237C: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A62380: 4082FFCC  bne 0x82a6234c
	if !ctx.cr[0].eq {
	pc = 0x82A6234C; continue 'dispatch;
	}
	pc = 0x82A62384; continue 'dispatch;
            }
            0x82A62384 => {
    //   block [0x82A62384..0x82A623A0)
	// 82A62384: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A62388: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A6238C: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A62390: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A62394: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A62398: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6239C: 419A0114  beq cr6, 0x82a624b0
	if ctx.cr[6].eq {
	pc = 0x82A624B0; continue 'dispatch;
	}
	pc = 0x82A623A0; continue 'dispatch;
            }
            0x82A623A0 => {
    //   block [0x82A623A0..0x82A623B0)
	// 82A623A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A623A4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A623A8: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82A623AC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A623B0; continue 'dispatch;
            }
            0x82A623B0 => {
    //   block [0x82A623B0..0x82A623D8)
	// 82A623B0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A623B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A623B8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A623BC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A623C0: 4200FFF0  bdnz 0x82a623b0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A623B0; continue 'dispatch;
	}
	// 82A623C4: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A623C8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A623CC: 409AFFD4  bne cr6, 0x82a623a0
	if !ctx.cr[6].eq {
	pc = 0x82A623A0; continue 'dispatch;
	}
	// 82A623D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A623D4: 48247080  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A623D8 => {
    //   block [0x82A623D8..0x82A623F0)
	// 82A623D8: 55641838  slwi r4, r11, 3
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A623DC: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 82A623E0: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A623E4: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82A623E8: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A623EC: 419A0040  beq cr6, 0x82a6242c
	if ctx.cr[6].eq {
	pc = 0x82A6242C; continue 'dispatch;
	}
	pc = 0x82A623F0; continue 'dispatch;
            }
            0x82A623F0 => {
    //   block [0x82A623F0..0x82A62408)
	// 82A623F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A623F4: 419A0028  beq cr6, 0x82a6241c
	if ctx.cr[6].eq {
	pc = 0x82A6241C; continue 'dispatch;
	}
	// 82A623F8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82A623FC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A62400: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82A62404: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x82A62408; continue 'dispatch;
            }
            0x82A62408 => {
    //   block [0x82A62408..0x82A6241C)
	// 82A62408: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6240C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A62410: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A62414: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A62418: 4200FFF0  bdnz 0x82a62408
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62408; continue 'dispatch;
	}
	pc = 0x82A6241C; continue 'dispatch;
            }
            0x82A6241C => {
    //   block [0x82A6241C..0x82A6242C)
	// 82A6241C: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 82A62420: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A62424: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A62428: 409AFFC8  bne cr6, 0x82a623f0
	if !ctx.cr[6].eq {
	pc = 0x82A623F0; continue 'dispatch;
	}
	pc = 0x82A6242C; continue 'dispatch;
            }
            0x82A6242C => {
    //   block [0x82A6242C..0x82A6243C)
	// 82A6242C: 911C0008  stw r8, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A62430: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A62434: 419A003C  beq cr6, 0x82a62470
	if ctx.cr[6].eq {
	pc = 0x82A62470; continue 'dispatch;
	}
	// 82A62438: 7D045A14  add r8, r4, r11
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	pc = 0x82A6243C; continue 'dispatch;
            }
            0x82A6243C => {
    //   block [0x82A6243C..0x82A62454)
	// 82A6243C: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 82A62440: 3908FFE8  addi r8, r8, -0x18
	ctx.r[8].s64 = ctx.r[8].s64 + -24;
	// 82A62444: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A62448: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A6244C: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 82A62450: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A62454; continue 'dispatch;
            }
            0x82A62454 => {
    //   block [0x82A62454..0x82A62470)
	// 82A62454: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62458: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A6245C: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A62460: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A62464: 4200FFF0  bdnz 0x82a62454
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62454; continue 'dispatch;
	}
	// 82A62468: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A6246C: 409AFFD0  bne cr6, 0x82a6243c
	if !ctx.cr[6].eq {
	pc = 0x82A6243C; continue 'dispatch;
	}
	pc = 0x82A62470; continue 'dispatch;
            }
            0x82A62470 => {
    //   block [0x82A62470..0x82A62480)
	// 82A62470: 7CE41A14  add r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82A62474: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A62478: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6247C: 419A0034  beq cr6, 0x82a624b0
	if ctx.cr[6].eq {
	pc = 0x82A624B0; continue 'dispatch;
	}
	pc = 0x82A62480; continue 'dispatch;
            }
            0x82A62480 => {
    //   block [0x82A62480..0x82A62490)
	// 82A62480: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A62484: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A62488: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82A6248C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A62490; continue 'dispatch;
            }
            0x82A62490 => {
    //   block [0x82A62490..0x82A624B0)
	// 82A62490: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62494: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A62498: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6249C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A624A0: 4200FFF0  bdnz 0x82a62490
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A62490; continue 'dispatch;
	}
	// 82A624A4: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82A624A8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A624AC: 409AFFD4  bne cr6, 0x82a62480
	if !ctx.cr[6].eq {
	pc = 0x82A62480; continue 'dispatch;
	}
	pc = 0x82A624B0; continue 'dispatch;
            }
            0x82A624B0 => {
    //   block [0x82A624B0..0x82A624B8)
	// 82A624B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A624B4: 48246FA0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A624B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A624B8 size=144
    let mut pc: u32 = 0x82A624B8;
    'dispatch: loop {
        match pc {
            0x82A624B8 => {
    //   block [0x82A624B8..0x82A624E4)
	// 82A624B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A624BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A624C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A624C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A624C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A624CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A624D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A624D4: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A624D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A624DC: 419A0040  beq cr6, 0x82a6251c
	if ctx.cr[6].eq {
	pc = 0x82A6251C; continue 'dispatch;
	}
	// 82A624E0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A624E4; continue 'dispatch;
            }
            0x82A624E4 => {
    //   block [0x82A624E4..0x82A62518)
	// 82A624E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A624E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A624EC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A624F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A624F4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A624F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A624FC: 4082FFE8  bne 0x82a624e4
	if !ctx.cr[0].eq {
	pc = 0x82A624E4; continue 'dispatch;
	}
	// 82A62500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A62504: 409A0014  bne cr6, 0x82a62518
	if !ctx.cr[6].eq {
	pc = 0x82A62518; continue 'dispatch;
	}
	// 82A62508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6250C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62510: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A62514: 4E800421  bctrl
	ctx.lr = 0x82A62518;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A62518 => {
    //   block [0x82A62518..0x82A6251C)
	// 82A62518: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6251C; continue 'dispatch;
            }
            0x82A6251C => {
    //   block [0x82A6251C..0x82A62530)
	// 82A6251C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A62520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A62524: 419A000C  beq cr6, 0x82a62530
	if ctx.cr[6].eq {
	pc = 0x82A62530; continue 'dispatch;
	}
	// 82A62528: 481250A1  bl 0x82b875c8
	ctx.lr = 0x82A6252C;
	sub_82B875C8(ctx, base);
	// 82A6252C: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	pc = 0x82A62530; continue 'dispatch;
            }
            0x82A62530 => {
    //   block [0x82A62530..0x82A62548)
	// 82A62530: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A62534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A62538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6253C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A62540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A62544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A62548 size=272
    let mut pc: u32 = 0x82A62548;
    'dispatch: loop {
        match pc {
            0x82A62548 => {
    //   block [0x82A62548..0x82A62588)
	// 82A62548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6254C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A62550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A62554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A62558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6255C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A62560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A62564: 4B749535  bl 0x821aba98
	ctx.lr = 0x82A62568;
	sub_821ABA98(ctx, base);
	// 82A62568: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6256C: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A62570: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62574: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A62578: 419A007C  beq cr6, 0x82a625f4
	if ctx.cr[6].eq {
	pc = 0x82A625F4; continue 'dispatch;
	}
	// 82A6257C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A62580: 419A0044  beq cr6, 0x82a625c4
	if ctx.cr[6].eq {
	pc = 0x82A625C4; continue 'dispatch;
	}
	// 82A62584: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A62588; continue 'dispatch;
            }
            0x82A62588 => {
    //   block [0x82A62588..0x82A625BC)
	// 82A62588: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A6258C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A62590: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A62594: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A62598: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6259C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A625A0: 4082FFE8  bne 0x82a62588
	if !ctx.cr[0].eq {
	pc = 0x82A62588; continue 'dispatch;
	}
	// 82A625A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A625A8: 409A0014  bne cr6, 0x82a625bc
	if !ctx.cr[6].eq {
	pc = 0x82A625BC; continue 'dispatch;
	}
	// 82A625AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A625B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A625B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A625B8: 4E800421  bctrl
	ctx.lr = 0x82A625BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A625BC => {
    //   block [0x82A625BC..0x82A625C4)
	// 82A625BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A625C0: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x82A625C4; continue 'dispatch;
            }
            0x82A625C4 => {
    //   block [0x82A625C4..0x82A625D8)
	// 82A625C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A625C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A625CC: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82A625D0: 419A0024  beq cr6, 0x82a625f4
	if ctx.cr[6].eq {
	pc = 0x82A625F4; continue 'dispatch;
	}
	// 82A625D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A625D8; continue 'dispatch;
            }
            0x82A625D8 => {
    //   block [0x82A625D8..0x82A625F4)
	// 82A625D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A625DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A625E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A625E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A625E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A625EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A625F0: 4082FFE8  bne 0x82a625d8
	if !ctx.cr[0].eq {
	pc = 0x82A625D8; continue 'dispatch;
	}
	pc = 0x82A625F4; continue 'dispatch;
            }
            0x82A625F4 => {
    //   block [0x82A625F4..0x82A62608)
	// 82A625F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A625F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A625FC: 419A0044  beq cr6, 0x82a62640
	if ctx.cr[6].eq {
	pc = 0x82A62640; continue 'dispatch;
	}
	// 82A62600: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A62604: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A62608; continue 'dispatch;
            }
            0x82A62608 => {
    //   block [0x82A62608..0x82A62640)
	// 82A62608: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6260C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A62610: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A62614: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A62618: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6261C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A62620: 4082FFE8  bne 0x82a62608
	if !ctx.cr[0].eq {
	pc = 0x82A62608; continue 'dispatch;
	}
	// 82A62624: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A62628: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6262C: 409A0014  bne cr6, 0x82a62640
	if !ctx.cr[6].eq {
	pc = 0x82A62640; continue 'dispatch;
	}
	// 82A62630: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62634: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62638: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6263C: 4E800421  bctrl
	ctx.lr = 0x82A62640;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A62640 => {
    //   block [0x82A62640..0x82A62658)
	// 82A62640: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A62644: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A62648: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6264C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A62650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A62654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A62658 size=864
    let mut pc: u32 = 0x82A62658;
    'dispatch: loop {
        match pc {
            0x82A62658 => {
    //   block [0x82A62658..0x82A6273C)
	// 82A62658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6265C: 48246D99  bl 0x82ca93f4
	ctx.lr = 0x82A62660;
	sub_82CA93D0(ctx, base);
	// 82A62660: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62664: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 82A62668: 89796E63  lbz r11, 0x6e63(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(28259 as u32) ) } as u64;
	// 82A6266C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A62670: 409A0340  bne cr6, 0x82a629b0
	if !ctx.cr[6].eq {
	pc = 0x82A629B0; continue 'dispatch;
	}
	// 82A62674: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A62678: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6267C: 3BEBFBBC  addi r31, r11, -0x444
	ctx.r[31].s64 = ctx.r[11].s64 + -1092;
	// 82A62680: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82A62684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A62688: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6268C: 38C00011  li r6, 0x11
	ctx.r[6].s64 = 17;
	// 82A62690: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A62694: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A62698: 4812AEC9  bl 0x82b8d560
	ctx.lr = 0x82A6269C;
	sub_82B8D560(ctx, base);
	// 82A6269C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A626A0: 4812B001  bl 0x82b8d6a0
	ctx.lr = 0x82A626A4;
	sub_82B8D6A0(ctx, base);
	// 82A626A4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A626A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A626AC: 3BEAFBA8  addi r31, r10, -0x458
	ctx.r[31].s64 = ctx.r[10].s64 + -1112;
	// 82A626B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A626B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A626B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A626BC: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A626C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A626C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A626C8: 4812AE99  bl 0x82b8d560
	ctx.lr = 0x82A626CC;
	sub_82B8D560(ctx, base);
	// 82A626CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A626D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A626D4: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A626D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A626DC: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 82A626E0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A626E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A626E8: 4812AE79  bl 0x82b8d560
	ctx.lr = 0x82A626EC;
	sub_82B8D560(ctx, base);
	// 82A626EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A626F0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A626F4: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82A626F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A626FC: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 82A62700: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 82A62704: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A62708: 4812AE59  bl 0x82b8d560
	ctx.lr = 0x82A6270C;
	sub_82B8D560(ctx, base);
	// 82A6270C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A62710: 4812AF91  bl 0x82b8d6a0
	ctx.lr = 0x82A62714;
	sub_82B8D6A0(ctx, base);
	// 82A62714: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82A62718: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82A6271C: 39600600  li r11, 0x600
	ctx.r[11].s64 = 1536;
	// 82A62720: 3949FBD0  addi r10, r9, -0x430
	ctx.r[10].s64 = ctx.r[9].s64 + -1072;
	// 82A62724: 3BC00032  li r30, 0x32
	ctx.r[30].s64 = 50;
	// 82A62728: 3BEA0050  addi r31, r10, 0x50
	ctx.r[31].s64 = ctx.r[10].s64 + 80;
	// 82A6272C: 917D6E64  stw r11, 0x6e64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28260 as u32), ctx.r[11].u32 ) };
	// 82A62730: 3B600121  li r27, 0x121
	ctx.r[27].s64 = 289;
	// 82A62734: 3B800200  li r28, 0x200
	ctx.r[28].s64 = 512;
	// 82A62738: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	pc = 0x82A6273C; continue 'dispatch;
            }
            0x82A6273C => {
    //   block [0x82A6273C..0x82A6276C)
	// 82A6273C: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A62740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A62744: 409A0028  bne cr6, 0x82a6276c
	if !ctx.cr[6].eq {
	pc = 0x82A6276C; continue 'dispatch;
	}
	// 82A62748: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6274C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82A62750: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82A62754: 38800121  li r4, 0x121
	ctx.r[4].s64 = 289;
	// 82A62758: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 82A6275C: 481290C5  bl 0x82b8b820
	ctx.lr = 0x82A62760;
	sub_82B8B820(ctx, base);
	// 82A62760: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A62764: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A62768: 9B5F000C  stb r26, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u8 ) };
	pc = 0x82A6276C; continue 'dispatch;
            }
            0x82A6276C => {
    //   block [0x82A6276C..0x82A627E0)
	// 82A6276C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A62770: 3BFF0060  addi r31, r31, 0x60
	ctx.r[31].s64 = ctx.r[31].s64 + 96;
	// 82A62774: 4082FFC8  bne 0x82a6273c
	if !ctx.cr[0].eq {
	pc = 0x82A6273C; continue 'dispatch;
	}
	// 82A62778: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A6277C: 817D6E64  lwz r11, 0x6e64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28260 as u32) ) } as u64;
	// 82A62780: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82A62784: 3BEAAB0C  addi r31, r10, -0x54f4
	ctx.r[31].s64 = ctx.r[10].s64 + -21748;
	// 82A62788: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6278C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A62790: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A62794: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82A62798: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A6279C: 4812B00D  bl 0x82b8d7a8
	ctx.lr = 0x82A627A0;
	sub_82B8D7A8(ctx, base);
	// 82A627A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A627A4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82A627A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A627AC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A627B0: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A627B4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A627B8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A627BC: 80EB0020  lwz r7, 0x20(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A627C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A627C4: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82A627C8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A627CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A627D0: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82A627D4: 4B793B2D  bl 0x821f6300
	ctx.lr = 0x82A627D8;
	sub_821F6300(ctx, base);
	// 82A627D8: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A627DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	pc = 0x82A627E0; continue 'dispatch;
            }
            0x82A627E0 => {
    //   block [0x82A627E0..0x82A627EC)
	// 82A627E0: 54CB2036  slwi r11, r6, 4
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A627E4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A627E8: 7CEB3214  add r7, r11, r6
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	pc = 0x82A627EC; continue 'dispatch;
            }
            0x82A627EC => {
    //   block [0x82A627EC..0x82A628F0)
	// 82A627EC: 550B043E  clrlwi r11, r8, 0x10
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 82A627F0: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A627F4: 55080BFC  rlwinm r8, r8, 1, 0xf, 0x1e
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82A627F8: 3B6A0001  addi r27, r10, 1
	ctx.r[27].s64 = ctx.r[10].s64 + 1;
	// 82A627FC: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 82A62800: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 82A62804: 388B0003  addi r4, r11, 3
	ctx.r[4].s64 = ctx.r[11].s64 + 3;
	// 82A62808: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 82A6280C: 3B8B0005  addi r28, r11, 5
	ctx.r[28].s64 = ctx.r[11].s64 + 5;
	// 82A62810: 577B043E  clrlwi r27, r27, 0x10
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0x0000FFFFu64;
	// 82A62814: B1480000  sth r10, 0(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82A62818: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6281C: 3B0A0011  addi r24, r10, 0x11
	ctx.r[24].s64 = ctx.r[10].s64 + 17;
	// 82A62820: B3680002  sth r27, 2(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[27].u16 ) };
	// 82A62824: 54A5083C  slwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A62828: 5484083C  slwi r4, r4, 1
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A6282C: 57BD083C  slwi r29, r29, 1
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82A62830: 579C083C  slwi r28, r28, 1
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82A62834: 5718043E  clrlwi r24, r24, 0x10
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0x0000FFFFu64;
	// 82A62838: 3AEA0012  addi r23, r10, 0x12
	ctx.r[23].s64 = ctx.r[10].s64 + 18;
	// 82A6283C: 5529043E  clrlwi r9, r9, 0x10
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82A62840: 7F051B2E  sthx r24, r5, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[3].u32), ctx.r[24].u16) };
	// 82A62844: 390B0006  addi r8, r11, 6
	ctx.r[8].s64 = ctx.r[11].s64 + 6;
	// 82A62848: 7F041B2E  sthx r24, r4, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32), ctx.r[24].u16) };
	// 82A6284C: 7F7D1B2E  sthx r27, r29, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[3].u32), ctx.r[27].u16) };
	// 82A62850: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 82A62854: 5508043E  clrlwi r8, r8, 0x10
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 82A62858: 7EFC1B2E  sthx r23, r28, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[3].u32), ctx.r[23].u16) };
	// 82A6285C: 4198FF90  blt cr6, 0x82a627ec
	if ctx.cr[6].lt {
	pc = 0x82A627EC; continue 'dispatch;
	}
	// 82A62860: 39660001  addi r11, r6, 1
	ctx.r[11].s64 = ctx.r[6].s64 + 1;
	// 82A62864: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82A62868: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A6286C: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82A62870: 4198FF70  blt cr6, 0x82a627e0
	if ctx.cr[6].lt {
	pc = 0x82A627E0; continue 'dispatch;
	}
	// 82A62874: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62878: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A6287C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A62880: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A62884: 4B85FDAD  bl 0x822c2630
	ctx.lr = 0x82A62888;
	sub_822C2630(ctx, base);
	// 82A62888: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6288C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A62890: 3BEB0E90  addi r31, r11, 0xe90
	ctx.r[31].s64 = ctx.r[11].s64 + 3728;
	// 82A62894: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 82A62898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6289C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A628A0: 38800121  li r4, 0x121
	ctx.r[4].s64 = 289;
	// 82A628A4: 48128F7D  bl 0x82b8b820
	ctx.lr = 0x82A628A8;
	sub_82B8B820(ctx, base);
	// 82A628A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A628AC: 3D400300  lis r10, 0x300
	ctx.r[10].s64 = 50331648;
	// 82A628B0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A628B4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82A628B8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A628BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A628C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A628C4: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A628C8: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82A628CC: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A628D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A628D4: 552B003A  rlwinm r11, r9, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82A628D8: 54EA01BA  rlwinm r10, r7, 0, 6, 0x1d
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A628DC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A628E0: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82A628E4: 4B793A1D  bl 0x821f6300
	ctx.lr = 0x82A628E8;
	sub_821F6300(ctx, base);
	// 82A628E8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82A628EC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A628F0; continue 'dispatch;
            }
            0x82A628F0 => {
    //   block [0x82A628F0..0x82A62918)
	// 82A628F0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A628F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A628F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A628FC: 2F0B0121  cmpwi cr6, r11, 0x121
	ctx.cr[6].compare_i32(ctx.r[11].s32, 289, &mut ctx.xer);
	// 82A62900: 4198FFF0  blt cr6, 0x82a628f0
	if ctx.cr[6].lt {
	pc = 0x82A628F0; continue 'dispatch;
	}
	// 82A62904: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62908: 3920FF00  li r9, -0x100
	ctx.r[9].s64 = -256;
	// 82A6290C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A62910: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A62914: 54A8003A  rlwinm r8, r5, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82A62918; continue 'dispatch;
            }
            0x82A62918 => {
    //   block [0x82A62918..0x82A62988)
	// 82A62918: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A6291C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A62920: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A62924: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A62928: 7CE0592D  stwcx. r7, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6292C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A62930: 4082FFE8  bne 0x82a62918
	if !ctx.cr[0].eq {
	pc = 0x82A62918; continue 'dispatch;
	}
	// 82A62934: 7D4A5378  mr r10, r10
	ctx.r[10].u64 = ctx.r[10].u64;
	// 82A62938: 5544052E  rlwinm r4, r10, 0, 0x14, 0x17
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A6293C: 2B040100  cmplwi cr6, r4, 0x100
	ctx.cr[6].compare_u32(ctx.r[4].u32, 256 as u32, &mut ctx.xer);
	// 82A62940: 409A0064  bne cr6, 0x82a629a4
	if !ctx.cr[6].eq {
	pc = 0x82A629A4; continue 'dispatch;
	}
	// 82A62944: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A62948: 3D20FFFF  lis r9, -1
	ctx.r[9].s64 = -65536;
	// 82A6294C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A62950: 419A0054  beq cr6, 0x82a629a4
	if ctx.cr[6].eq {
	pc = 0x82A629A4; continue 'dispatch;
	}
	// 82A62954: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62958: 5547843E  srwi r7, r10, 0x10
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shr(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6295C: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A62960: 5549043E  clrlwi r9, r10, 0x10
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82A62964: 54C50294  rlwinm r5, r6, 0, 0xa, 0xa
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82A62968: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6296C: 409A001C  bne cr6, 0x82a62988
	if !ctx.cr[6].eq {
	pc = 0x82A62988; continue 'dispatch;
	}
	// 82A62970: 550B653E  srwi r11, r8, 0x14
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62974: 550A00FE  clrlwi r10, r8, 3
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x1FFFFFFFu64;
	// 82A62978: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 82A6297C: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A62980: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A62984: 3D0AC000  addis r8, r10, -0x4000
	ctx.r[8].s64 = ctx.r[10].s64 + -1073741824;
	pc = 0x82A62988; continue 'dispatch;
            }
            0x82A62988 => {
    //   block [0x82A62988..0x82A629A4)
	// 82A62988: 550B0030  rlwinm r11, r8, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82A6298C: 55293830  slwi r9, r9, 7
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(7);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A62990: 54EA3830  slwi r10, r7, 7
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(7);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A62994: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A62998: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A6299C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A629A0: 4B76EB69  bl 0x821d1508
	ctx.lr = 0x82A629A4;
	sub_821D1508(ctx, base);
	pc = 0x82A629A4; continue 'dispatch;
            }
            0x82A629A4 => {
    //   block [0x82A629A4..0x82A629B0)
	// 82A629A4: 7C0004AC  sync
	// 82A629A8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A629AC: 99796E63  stb r11, 0x6e63(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(28259 as u32), ctx.r[11].u8 ) };
	pc = 0x82A629B0; continue 'dispatch;
            }
            0x82A629B0 => {
    //   block [0x82A629B0..0x82A629B8)
	// 82A629B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A629B4: 48246A90  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A629B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A629B8 size=308
    let mut pc: u32 = 0x82A629B8;
    'dispatch: loop {
        match pc {
            0x82A629B8 => {
    //   block [0x82A629B8..0x82A62A0C)
	// 82A629B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A629BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A629C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A629C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A629C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A629CC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A629D0: 816A6E6C  lwz r11, 0x6e6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28268 as u32) ) } as u64;
	// 82A629D4: 2B0B0032  cmplwi cr6, r11, 0x32
	ctx.cr[6].compare_u32(ctx.r[11].u32, 50 as u32, &mut ctx.xer);
	// 82A629D8: 40980034  bge cr6, 0x82a62a0c
	if !ctx.cr[6].lt {
	pc = 0x82A62A0C; continue 'dispatch;
	}
	// 82A629DC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A629E0: 3D0051EB  lis r8, 0x51eb
	ctx.r[8].s64 = 1374355456;
	// 82A629E4: 6107851F  ori r7, r8, 0x851f
	ctx.r[7].u64 = ctx.r[8].u64 | 34079;
	// 82A629E8: 81296E68  lwz r9, 0x6e68(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28264 as u32) ) } as u64;
	// 82A629EC: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A629F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A629F4: 7CA63816  mulhwu r5, r6, r7
	ctx.r[5].u64 = ((ctx.r[6].u32 as u64 * ctx.r[7].u32 as u64) >> 32);
	// 82A629F8: 916A6E6C  stw r11, 0x6e6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28268 as u32), ctx.r[11].u32 ) };
	// 82A629FC: 54A4E13E  srwi r4, r5, 4
	ctx.r[4].u32 = ctx.r[5].u32.wrapping_shr(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A62A00: 1D640032  mulli r11, r4, 0x32
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 50 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A62A04: 7FCB3050  subf r30, r11, r6
	ctx.r[30].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 82A62A08: 4800002C  b 0x82a62a34
	pc = 0x82A62A34; continue 'dispatch;
            }
            0x82A62A0C => {
    //   block [0x82A62A0C..0x82A62A34)
	// 82A62A0C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A62A10: 3D2051EB  lis r9, 0x51eb
	ctx.r[9].s64 = 1374355456;
	// 82A62A14: 6128851F  ori r8, r9, 0x851f
	ctx.r[8].u64 = ctx.r[9].u64 | 34079;
	// 82A62A18: 83CA6E68  lwz r30, 0x6e68(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28264 as u32) ) } as u64;
	// 82A62A1C: 38FE0001  addi r7, r30, 1
	ctx.r[7].s64 = ctx.r[30].s64 + 1;
	// 82A62A20: 7CC74016  mulhwu r6, r7, r8
	ctx.r[6].u64 = ((ctx.r[7].u32 as u64 * ctx.r[8].u32 as u64) >> 32);
	// 82A62A24: 54C5E13E  srwi r5, r6, 4
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shr(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A62A28: 1C850032  mulli r4, r5, 0x32
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * 50 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82A62A2C: 7D643850  subf r11, r4, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 82A62A30: 916A6E68  stw r11, 0x6e68(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28264 as u32), ctx.r[11].u32 ) };
	pc = 0x82A62A34; continue 'dispatch;
            }
            0x82A62A34 => {
    //   block [0x82A62A34..0x82A62AEC)
	// 82A62A34: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62A38: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62A3C: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82A62A40: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A62A44: 3966FBD0  addi r11, r6, -0x430
	ctx.r[11].s64 = ctx.r[6].s64 + -1072;
	// 82A62A48: 54AA2834  slwi r10, r5, 5
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A62A4C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82A62A50: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A62A54: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82A62A58: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 82A62A5C: 7CEA592E  stwx r7, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82A62A60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62A64: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A62AF0 size=260
    let mut pc: u32 = 0x82A62AF0;
    'dispatch: loop {
        match pc {
            0x82A62AF0 => {
    //   block [0x82A62AF0..0x82A62B5C)
	// 82A62AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A62AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A62AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A62AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A62B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62B04: 546A083C  slwi r10, r3, 1
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A62B08: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A62B0C: 7D235214  add r9, r3, r10
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 82A62B10: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82A62B14: 3BEBFB9C  addi r31, r11, -0x464
	ctx.r[31].s64 = ctx.r[11].s64 + -1124;
	// 82A62B18: 3948FBD0  addi r10, r8, -0x430
	ctx.r[10].s64 = ctx.r[8].s64 + -1072;
	// 82A62B1C: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62B20: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82A62B24: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A62B28: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62B2C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A62B30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A62B34: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A62B38: C0079484  lfs f0, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A62B3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A62B40: 90AB0058  stw r5, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82A62B44: D00B0038  stfs f0, 0x38(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82A62B48: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A62B4C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62B50: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A62B54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A62B58: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x82A62B5C; continue 'dispatch;
            }
            0x82A62B5C => {
    //   block [0x82A62B5C..0x82A62B6C)
	// 82A62B5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62B60: 419A000C  beq cr6, 0x82a62b6c
	if ctx.cr[6].eq {
	pc = 0x82A62B6C; continue 'dispatch;
	}
	// 82A62B64: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A62B68: 419A0008  beq cr6, 0x82a62b70
	if ctx.cr[6].eq {
	pc = 0x82A62B70; continue 'dispatch;
	}
	pc = 0x82A62B6C; continue 'dispatch;
            }
            0x82A62B6C => {
    //   block [0x82A62B6C..0x82A62B70)
	// 82A62B6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A62B70; continue 'dispatch;
            }
            0x82A62B70 => {
    //   block [0x82A62B70..0x82A62B88)
	// 82A62B70: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A62B74: 419A0068  beq cr6, 0x82a62bdc
	if ctx.cr[6].eq {
	pc = 0x82A62BDC; continue 'dispatch;
	}
	// 82A62B78: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A62B7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62B80: 409A0008  bne cr6, 0x82a62b88
	if !ctx.cr[6].eq {
	pc = 0x82A62B88; continue 'dispatch;
	}
	// 82A62B84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A62B88; continue 'dispatch;
            }
            0x82A62B88 => {
    //   block [0x82A62B88..0x82A62B98)
	// 82A62B88: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A62B8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A62B90: 409A0008  bne cr6, 0x82a62b98
	if !ctx.cr[6].eq {
	pc = 0x82A62B98; continue 'dispatch;
	}
	// 82A62B94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A62B98; continue 'dispatch;
            }
            0x82A62B98 => {
    //   block [0x82A62B98..0x82A62BAC)
	// 82A62B98: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62B9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A62BA0: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A62BA4: 409A0008  bne cr6, 0x82a62bac
	if !ctx.cr[6].eq {
	pc = 0x82A62BAC; continue 'dispatch;
	}
	// 82A62BA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A62BAC; continue 'dispatch;
            }
            0x82A62BAC => {
    //   block [0x82A62BAC..0x82A62BC8)
	// 82A62BAC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A62BB0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A62BB4: 409A0014  bne cr6, 0x82a62bc8
	if !ctx.cr[6].eq {
	pc = 0x82A62BC8; continue 'dispatch;
	}
	// 82A62BB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A62BBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A62BC0: 48000F31  bl 0x82a63af0
	ctx.lr = 0x82A62BC4;
	sub_82A63AF0(ctx, base);
	// 82A62BC4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A62BC8; continue 'dispatch;
            }
            0x82A62BC8 => {
    //   block [0x82A62BC8..0x82A62BDC)
	// 82A62BC8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A62BCC: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A62BD0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A62BD4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A62BD8: 4BFFFF84  b 0x82a62b5c
	pc = 0x82A62B5C; continue 'dispatch;
            }
            0x82A62BDC => {
    //   block [0x82A62BDC..0x82A62BF4)
	// 82A62BDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A62BE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A62BE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A62BE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A62BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A62BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A62BF8 size=228
    let mut pc: u32 = 0x82A62BF8;
    'dispatch: loop {
        match pc {
            0x82A62BF8 => {
    //   block [0x82A62BF8..0x82A62C40)
	// 82A62BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A62BFC: 48246801  bl 0x82ca93fc
	ctx.lr = 0x82A62C00;
	sub_82CA93D0(ctx, base);
	// 82A62C00: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A62C04: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62C08: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 82A62C0C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A62C10: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82A62C14: 811A6E6C  lwz r8, 0x6e6c(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28268 as u32) ) } as u64;
	// 82A62C18: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A62C1C: 419A00A8  beq cr6, 0x82a62cc4
	if ctx.cr[6].eq {
	pc = 0x82A62CC4; continue 'dispatch;
	}
	// 82A62C20: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A62C24: 3D2051EB  lis r9, 0x51eb
	ctx.r[9].s64 = 1374355456;
	// 82A62C28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A62C2C: 613F851F  ori r31, r9, 0x851f
	ctx.r[31].u64 = ctx.r[9].u64 | 34079;
	// 82A62C30: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82A62C34: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A62C38: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82A62C3C: 3BABFBD0  addi r29, r11, -0x430
	ctx.r[29].s64 = ctx.r[11].s64 + -1072;
	pc = 0x82A62C40; continue 'dispatch;
            }
            0x82A62C40 => {
    //   block [0x82A62C40..0x82A62C7C)
	// 82A62C40: 817C6E68  lwz r11, 0x6e68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28264 as u32) ) } as u64;
	// 82A62C44: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A62C48: 7D4BF816  mulhwu r10, r11, r31
	ctx.r[10].u64 = ((ctx.r[11].u32 as u64 * ctx.r[31].u32 as u64) >> 32);
	// 82A62C4C: 5549E13E  srwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A62C50: 1CE90032  mulli r7, r9, 0x32
	ctx.r[7].s32 = ((ctx.r[9].s32 as i64 * 50 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82A62C54: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A62C58: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A62C5C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A62C60: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A62C64: 54CB2834  slwi r11, r6, 5
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A62C68: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A62C6C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A62C70: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A62C74: 41990008  bgt cr6, 0x82a62c7c
	if ctx.cr[6].gt {
	pc = 0x82A62C7C; continue 'dispatch;
	}
	// 82A62C78: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82A62C7C; continue 'dispatch;
            }
            0x82A62C7C => {
    //   block [0x82A62C7C..0x82A62CB8)
	// 82A62C7C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A62C80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62C84: 419A0034  beq cr6, 0x82a62cb8
	if ctx.cr[6].eq {
	pc = 0x82A62CB8; continue 'dispatch;
	}
	// 82A62C88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A62C8C: D3EB0038  stfs f31, 0x38(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82A62C90: 812B0058  lwz r9, 0x58(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A62C94: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82A62C98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62C9C: 936B0058  stw r27, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82A62CA0: 419A0018  beq cr6, 0x82a62cb8
	if ctx.cr[6].eq {
	pc = 0x82A62CB8; continue 'dispatch;
	}
	// 82A62CA4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A62CA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A62CAC: 386A01F4  addi r3, r10, 0x1f4
	ctx.r[3].s64 = ctx.r[10].s64 + 500;
	// 82A62CB0: 4B907431  bl 0x8236a0e0
	ctx.lr = 0x82A62CB4;
	sub_8236A0E0(ctx, base);
	// 82A62CB4: 811A6E6C  lwz r8, 0x6e6c(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28268 as u32) ) } as u64;
	pc = 0x82A62CB8; continue 'dispatch;
            }
            0x82A62CB8 => {
    //   block [0x82A62CB8..0x82A62CC4)
	// 82A62CB8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A62CBC: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A62CC0: 4198FF80  blt cr6, 0x82a62c40
	if ctx.cr[6].lt {
	pc = 0x82A62C40; continue 'dispatch;
	}
	pc = 0x82A62CC4; continue 'dispatch;
            }
            0x82A62CC4 => {
    //   block [0x82A62CC4..0x82A62CDC)
	// 82A62CC4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A62CC8: 386BFB9C  addi r3, r11, -0x464
	ctx.r[3].s64 = ctx.r[11].s64 + -1124;
	// 82A62CCC: 48000EE5  bl 0x82a63bb0
	ctx.lr = 0x82A62CD0;
	sub_82A63BB0(ctx, base);
	// 82A62CD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A62CD4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A62CD8: 48246774  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A62CE0 size=300
    let mut pc: u32 = 0x82A62CE0;
    'dispatch: loop {
        match pc {
            0x82A62CE0 => {
    //   block [0x82A62CE0..0x82A62DB8)
	// 82A62CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A62CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A62CE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A62CEC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62CF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A62CF4: 4B798FF5  bl 0x821fbce8
	ctx.lr = 0x82A62CF8;
	sub_821FBCE8(ctx, base);
	// 82A62CF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A62CFC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A62D00: 38C00036  li r6, 0x36
	ctx.r[6].s64 = 54;
	// 82A62D04: 38E00036  li r7, 0x36
	ctx.r[7].s64 = 54;
	// 82A62D08: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A62D0C: 38AAAB18  addi r5, r10, -0x54e8
	ctx.r[5].s64 = ctx.r[10].s64 + -21736;
	// 82A62D10: 808BF9C0  lwz r4, -0x640(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 82A62D14: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A62D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A62D1C: 4B799075  bl 0x821fbd90
	ctx.lr = 0x82A62D20;
	sub_821FBD90(ctx, base);
	// 82A62D20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A62D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A62D28: 4B798EC1  bl 0x821fbbe8
	ctx.lr = 0x82A62D2C;
	sub_821FBBE8(ctx, base);
	// 82A62D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A62D30: 4B799261  bl 0x821fbf90
	ctx.lr = 0x82A62D34;
	sub_821FBF90(ctx, base);
	// 82A62D34: 4B79980D  bl 0x821fc540
	ctx.lr = 0x82A62D38;
	sub_821FC540(ctx, base);
	// 82A62D38: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A62D3C: 4B80833D  bl 0x8226b078
	ctx.lr = 0x82A62D40;
	sub_8226B078(ctx, base);
	// 82A62D40: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A62D44: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 82A62D48: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 82A62D4C: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 82A62D50: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A62D54: 88EB002D  lbz r7, 0x2d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82A62D58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62D5C: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A62D60: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A62D64: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A62D68: 419A0090  beq cr6, 0x82a62df8
	if ctx.cr[6].eq {
	pc = 0x82A62DF8; continue 'dispatch;
	}
	// 82A62D6C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A62D70: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A62D74: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A62D78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A62D7C: 409A003C  bne cr6, 0x82a62db8
	if !ctx.cr[6].eq {
	pc = 0x82A62DB8; continue 'dispatch;
	}
	// 82A62D80: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A62D84: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A62D88: 38CB0018  addi r6, r11, 0x18
	ctx.r[6].s64 = ctx.r[11].s64 + 24;
	// 82A62D8C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A62D90: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82A62D94: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A62D98: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A62D9C: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A62DA0: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A62DA4: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A62DA8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A62DAC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A62DB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A62DB4: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A62DB8; continue 'dispatch;
            }
            0x82A62DB8 => {
    //   block [0x82A62DB8..0x82A62DF8)
	// 82A62DB8: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A62DBC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A62DC0: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82A62DC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62DC8: 409A0030  bne cr6, 0x82a62df8
	if !ctx.cr[6].eq {
	pc = 0x82A62DF8; continue 'dispatch;
	}
	// 82A62DCC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A62DD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A62DD4: 390B0018  addi r8, r11, 0x18
	ctx.r[8].s64 = ctx.r[11].s64 + 24;
	// 82A62DD8: 994B002C  stb r10, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82A62DDC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A62DE0: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A62DE4: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 82A62DE8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A62DEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A62DF0: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 82A62DF4: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x82A62DF8; continue 'dispatch;
            }
            0x82A62DF8 => {
    //   block [0x82A62DF8..0x82A62E0C)
	// 82A62DF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A62DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A62E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A62E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A62E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A62E10 size=248
    let mut pc: u32 = 0x82A62E10;
    'dispatch: loop {
        match pc {
            0x82A62E10 => {
    //   block [0x82A62E10..0x82A62EB4)
	// 82A62E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A62E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A62E18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A62E1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62E20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A62E24: 4B7DF3AD  bl 0x822421d0
	ctx.lr = 0x82A62E28;
	sub_822421D0(ctx, base);
	// 82A62E28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A62E2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A62E30: 806BF9C0  lwz r3, -0x640(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 82A62E34: 4B7D41ED  bl 0x82237020
	ctx.lr = 0x82A62E38;
	sub_82237020(ctx, base);
	// 82A62E38: 4B799619  bl 0x821fc450
	ctx.lr = 0x82A62E3C;
	sub_821FC450(ctx, base);
	// 82A62E3C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A62E40: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82A62E44: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 82A62E48: 390A2390  addi r8, r10, 0x2390
	ctx.r[8].s64 = ctx.r[10].s64 + 9104;
	// 82A62E4C: 892B002D  lbz r9, 0x2d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(45 as u32) ) } as u64;
	// 82A62E50: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A62E54: 2B0A000F  cmplwi cr6, r10, 0xf
	ctx.cr[6].compare_u32(ctx.r[10].u32, 15 as u32, &mut ctx.xer);
	// 82A62E58: 1D492008  mulli r10, r9, 0x2008
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A62E5C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A62E60: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A62E64: 419A0090  beq cr6, 0x82a62ef4
	if ctx.cr[6].eq {
	pc = 0x82A62EF4; continue 'dispatch;
	}
	// 82A62E68: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A62E6C: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A62E70: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A62E74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A62E78: 409A003C  bne cr6, 0x82a62eb4
	if !ctx.cr[6].eq {
	pc = 0x82A62EB4; continue 'dispatch;
	}
	// 82A62E7C: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A62E80: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A62E84: 38CB0018  addi r6, r11, 0x18
	ctx.r[6].s64 = ctx.r[11].s64 + 24;
	// 82A62E88: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A62E8C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82A62E90: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A62E94: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A62E98: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A62E9C: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A62EA0: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A62EA4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A62EA8: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A62EAC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A62EB0: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A62EB4; continue 'dispatch;
            }
            0x82A62EB4 => {
    //   block [0x82A62EB4..0x82A62EF4)
	// 82A62EB4: 894B002C  lbz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A62EB8: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 82A62EBC: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82A62EC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A62EC4: 409A0030  bne cr6, 0x82a62ef4
	if !ctx.cr[6].eq {
	pc = 0x82A62EF4; continue 'dispatch;
	}
	// 82A62EC8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A62ECC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A62ED0: 390B0018  addi r8, r11, 0x18
	ctx.r[8].s64 = ctx.r[11].s64 + 24;
	// 82A62ED4: 994B002C  stb r10, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82A62ED8: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A62EDC: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A62EE0: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 82A62EE4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A62EE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A62EEC: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 82A62EF0: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x82A62EF4; continue 'dispatch;
            }
            0x82A62EF4 => {
    //   block [0x82A62EF4..0x82A62F08)
	// 82A62EF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A62EF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A62EFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A62F00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A62F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A62F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A62F08 size=564
    let mut pc: u32 = 0x82A62F08;
    'dispatch: loop {
        match pc {
            0x82A62F08 => {
    //   block [0x82A62F08..0x82A6313C)
	// 82A62F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A62F0C: 482464ED  bl 0x82ca93f8
	ctx.lr = 0x82A62F10;
	sub_82CA93D0(ctx, base);
	// 82A62F10: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A62F14: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A62F18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A62F1C: C1840034  lfs f12, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A62F20: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82A62F24: C1640030  lfs f11, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A62F28: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82A62F2C: ED4B6028  fsubs f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82A62F30: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A62F34: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82A62F38: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A62F3C: 39099150  addi r8, r9, -0x6eb0
	ctx.r[8].s64 = ctx.r[9].s64 + -28336;
	// 82A62F40: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A62F44: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82A62F48: 3BE40020  addi r31, r4, 0x20
	ctx.r[31].s64 = ctx.r[4].s64 + 32;
	// 82A62F4C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A62F50: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63140 size=460
    let mut pc: u32 = 0x82A63140;
    'dispatch: loop {
        match pc {
            0x82A63140 => {
    //   block [0x82A63140..0x82A6330C)
	// 82A63140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63148: 9421F3E0  stwu r1, -0xc20(r1)
	ea = ctx.r[1].u32.wrapping_add(-3104 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6314C: 90610C34  stw r3, 0xc34(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3124 as u32), ctx.r[3].u32 ) };
	// 82A63150: 90810C3C  stw r4, 0xc3c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3132 as u32), ctx.r[4].u32 ) };
	// 82A63154: 90A10C44  stw r5, 0xc44(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3140 as u32), ctx.r[5].u32 ) };
	// 82A63158: 90C10C4C  stw r6, 0xc4c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3148 as u32), ctx.r[6].u32 ) };
	// 82A6315C: 39800C50  li r12, 0xc50
	ctx.r[12].s64 = 3152;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63310 size=2016
    let mut pc: u32 = 0x82A63310;
    'dispatch: loop {
        match pc {
            0x82A63310 => {
    //   block [0x82A63310..0x82A63AF0)
	// 82A63310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63314: 482460CD  bl 0x82ca93e0
	ctx.lr = 0x82A63318;
	sub_82CA93D0(ctx, base);
	// 82A63318: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63AF0 size=192
    let mut pc: u32 = 0x82A63AF0;
    'dispatch: loop {
        match pc {
            0x82A63AF0 => {
    //   block [0x82A63AF0..0x82A63B20)
	// 82A63AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63B00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63B04: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 82A63B08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63B0C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A63B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63B14: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A63B18: 409A0008  bne cr6, 0x82a63b20
	if !ctx.cr[6].eq {
	pc = 0x82A63B20; continue 'dispatch;
	}
	// 82A63B1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A63B20; continue 'dispatch;
            }
            0x82A63B20 => {
    //   block [0x82A63B20..0x82A63B34)
	// 82A63B20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63B24: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A63B28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A63B2C: 409A0008  bne cr6, 0x82a63b34
	if !ctx.cr[6].eq {
	pc = 0x82A63B34; continue 'dispatch;
	}
	// 82A63B30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A63B34; continue 'dispatch;
            }
            0x82A63B34 => {
    //   block [0x82A63B34..0x82A63B8C)
	// 82A63B34: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A63B38: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63B3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A63B40: 3BEAFB9C  addi r31, r10, -0x464
	ctx.r[31].s64 = ctx.r[10].s64 + -1124;
	// 82A63B44: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82A63B48: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63B4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A63B50: 419A003C  beq cr6, 0x82a63b8c
	if ctx.cr[6].eq {
	pc = 0x82A63B8C; continue 'dispatch;
	}
	// 82A63B54: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63B58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A63B5C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63B60: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A63B64: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63B68: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63B6C: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A63B70: 4B7B81C9  bl 0x8221bd38
	ctx.lr = 0x82A63B74;
	sub_8221BD38(ctx, base);
	// 82A63B74: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A63B78: E8C10090  ld r6, 0x90(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82A63B7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A63B80: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A63B84: F8DE0000  std r6, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82A63B88: 4800000C  b 0x82a63b94
	pc = 0x82A63B94; continue 'dispatch;
            }
            0x82A63B8C => {
    //   block [0x82A63B8C..0x82A63B94)
	// 82A63B8C: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82A63B90: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	pc = 0x82A63B94; continue 'dispatch;
            }
            0x82A63B94 => {
    //   block [0x82A63B94..0x82A63BB0)
	// 82A63B94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63B98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63B9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63BA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63BA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63BA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63BAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63BB0 size=116
    let mut pc: u32 = 0x82A63BB0;
    'dispatch: loop {
        match pc {
            0x82A63BB0 => {
    //   block [0x82A63BB0..0x82A63BF4)
	// 82A63BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63BC4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A63BC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A63BCC: 3BEBFB9C  addi r31, r11, -0x464
	ctx.r[31].s64 = ctx.r[11].s64 + -1124;
	// 82A63BD0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63BD4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63BD8: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63BDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63BE0: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A63BE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63BE8: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A63BEC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A63BF0: 419A001C  beq cr6, 0x82a63c0c
	if ctx.cr[6].eq {
	pc = 0x82A63C0C; continue 'dispatch;
	}
	pc = 0x82A63BF4; continue 'dispatch;
            }
            0x82A63BF4 => {
    //   block [0x82A63BF4..0x82A63C0C)
	// 82A63BF4: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63BF8: 4B7B8141  bl 0x8221bd38
	ctx.lr = 0x82A63BFC;
	sub_8221BD38(ctx, base);
	// 82A63BFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63C04: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A63C08: 409AFFEC  bne cr6, 0x82a63bf4
	if !ctx.cr[6].eq {
	pc = 0x82A63BF4; continue 'dispatch;
	}
	pc = 0x82A63C0C; continue 'dispatch;
            }
            0x82A63C0C => {
    //   block [0x82A63C0C..0x82A63C24)
	// 82A63C0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63C10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63C14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63C18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63C28 size=280
    let mut pc: u32 = 0x82A63C28;
    'dispatch: loop {
        match pc {
            0x82A63C28 => {
    //   block [0x82A63C28..0x82A63C5C)
	// 82A63C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63C2C: 482457D9  bl 0x82ca9404
	ctx.lr = 0x82A63C30;
	sub_82CA93D0(ctx, base);
	// 82A63C30: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63C34: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A63C38: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82A63C3C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A63C40: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A63C44: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63C48: 4B7BB611  bl 0x8221f258
	ctx.lr = 0x82A63C4C;
	sub_8221F258(ctx, base);
	// 82A63C4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63C50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A63C54: 419A0008  beq cr6, 0x82a63c5c
	if ctx.cr[6].eq {
	pc = 0x82A63C5C; continue 'dispatch;
	}
	// 82A63C58: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82A63C5C; continue 'dispatch;
            }
            0x82A63C5C => {
    //   block [0x82A63C5C..0x82A63C6C)
	// 82A63C5C: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 82A63C60: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A63C64: 419A0008  beq cr6, 0x82a63c6c
	if ctx.cr[6].eq {
	pc = 0x82A63C6C; continue 'dispatch;
	}
	// 82A63C68: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82A63C6C; continue 'dispatch;
            }
            0x82A63C6C => {
    //   block [0x82A63C6C..0x82A63CBC)
	// 82A63C6C: 357E0010  addic. r11, r30, 0x10
	ctx.xer.ca = (ctx.r[30].u32 > (!(16 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63C70: 4182004C  beq 0x82a63cbc
	if ctx.cr[0].eq {
	pc = 0x82A63CBC; continue 'dispatch;
	}
	// 82A63C74: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63C78: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82A63C7C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A63C80: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A63C84: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63C88: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82A63CBC; continue 'dispatch;
            }
            0x82A63CBC => {
    //   block [0x82A63CBC..0x82A63D40)
	// 82A63CBC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A63CC0: 3D4003FF  lis r10, 0x3ff
	ctx.r[10].s64 = 67043328;
	// 82A63CC4: 3BEBFB9C  addi r31, r11, -0x464
	ctx.r[31].s64 = ctx.r[11].s64 + -1124;
	// 82A63CC8: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82A63CCC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A63CD0: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A63CD4: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82A63CD8: 4098004C  bge cr6, 0x82a63d24
	if !ctx.cr[6].lt {
	pc = 0x82A63D24; continue 'dispatch;
	}
	// 82A63CDC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A63CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A63CE4: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82A63CE8: 4B88E259  bl 0x822f1f40
	ctx.lr = 0x82A63CEC;
	sub_822F1F40(ctx, base);
	// 82A63CEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A63CF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A63CF4: 4B88E0BD  bl 0x822f1db0
	ctx.lr = 0x82A63CF8;
	sub_822F1DB0(ctx, base);
	// 82A63CF8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A63CFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A63D00: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82A63D04: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A63D08: 4B88E119  bl 0x822f1e20
	ctx.lr = 0x82A63D0C;
	sub_822F1E20(ctx, base);
	// 82A63D0C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A63D10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A63D14: 4BC17ACD  bl 0x8267b7e0
	ctx.lr = 0x82A63D18;
	sub_8267B7E0(ctx, base);
	// 82A63D18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A63D1C: 4B70DAF5  bl 0x82171810
	ctx.lr = 0x82A63D20;
	sub_82171810(ctx, base);
	// 82A63D20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A63D24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A63D28: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A63D2C: 93DB0004  stw r30, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A63D30: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63D34: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A63D38: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A63D3C: 48245718  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63D40 size=1036
    let mut pc: u32 = 0x82A63D40;
    'dispatch: loop {
        match pc {
            0x82A63D40 => {
    //   block [0x82A63D40..0x82A6414C)
	// 82A63D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63D44: 482456C1  bl 0x82ca9404
	ctx.lr = 0x82A63D48;
	sub_82CA93D0(ctx, base);
	// 82A63D48: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A63D4C: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64150 size=224
    let mut pc: u32 = 0x82A64150;
    'dispatch: loop {
        match pc {
            0x82A64150 => {
    //   block [0x82A64150..0x82A641CC)
	// 82A64150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64154: 482452A5  bl 0x82ca93f8
	ctx.lr = 0x82A64158;
	sub_82CA93D0(ctx, base);
	// 82A64158: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6415C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A64160: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A64164: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A64168: 37190028  addic. r24, r25, 0x28
	ctx.xer.ca = (ctx.r[25].u32 > (!(40 as u32)));
	ctx.r[24].s64 = ctx.r[25].s64 + 40;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A6416C: 9359002C  stw r26, 0x2c(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 82A64170: 93590030  stw r26, 0x30(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(48 as u32), ctx.r[26].u32 ) };
	// 82A64174: C00BD5C8  lfs f0, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A64178: 93590034  stw r26, 0x34(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(52 as u32), ctx.r[26].u32 ) };
	// 82A6417C: D0190024  stfs f0, 0x24(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A64180: 93590038  stw r26, 0x38(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(56 as u32), ctx.r[26].u32 ) };
	// 82A64184: 41820080  beq 0x82a64204
	if ctx.cr[0].eq {
	pc = 0x82A64204; continue 'dispatch;
	}
	// 82A64188: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A6418C: 3C806480  lis r4, 0x6480
	ctx.r[4].s64 = 1686110208;
	// 82A64190: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 82A64194: 836B0364  lwz r27, 0x364(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A64198: 4B7C8839  bl 0x8222c9d0
	ctx.lr = 0x82A6419C;
	sub_8222C9D0(ctx, base);
	// 82A6419C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A641A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A641A4: 419A0078  beq cr6, 0x82a6421c
	if ctx.cr[6].eq {
	pc = 0x82A6421C; continue 'dispatch;
	}
	// 82A641A8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A641AC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A641B0: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A641B4: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A641B8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A641BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A641C0: 3BDF0058  addi r30, r31, 0x58
	ctx.r[30].s64 = ctx.r[31].s64 + 88;
	// 82A641C4: 939F0098  stw r28, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A641C8: 939F0094  stw r28, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	pc = 0x82A641CC; continue 'dispatch;
            }
            0x82A641CC => {
    //   block [0x82A641CC..0x82A64204)
	// 82A641CC: 38BEFFC4  addi r5, r30, -0x3c
	ctx.r[5].s64 = ctx.r[30].s64 + -60;
	// 82A641D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A641D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A641D8: 4813B799  bl 0x82b9f970
	ctx.lr = 0x82A641DC;
	sub_82B9F970(ctx, base);
	// 82A641DC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A641E0: 41980030  blt cr6, 0x82a64210
	if ctx.cr[6].lt {
	pc = 0x82A64210; continue 'dispatch;
	}
	// 82A641E4: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A641E8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A641EC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A641F0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A641F4: 4198FFD8  blt cr6, 0x82a641cc
	if ctx.cr[6].lt {
	pc = 0x82A641CC; continue 'dispatch;
	}
	// 82A641F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A641FC: 9B9F0010  stb r28, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 82A64200: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A64204; continue 'dispatch;
            }
            0x82A64204 => {
    //   block [0x82A64204..0x82A64210)
	// 82A64204: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A64208: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6420C: 4824523C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A64210 => {
    //   block [0x82A64210..0x82A6421C)
	// 82A64210: 93BF0098  stw r29, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 82A64214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64218: 4813B881  bl 0x82b9fa98
	ctx.lr = 0x82A6421C;
	sub_82B9FA98(ctx, base);
	pc = 0x82A6421C; continue 'dispatch;
            }
            0x82A6421C => {
    //   block [0x82A6421C..0x82A64230)
	// 82A6421C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A64220: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A64224: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64228: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6422C: 4824521C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64230 size=356
    let mut pc: u32 = 0x82A64230;
    'dispatch: loop {
        match pc {
            0x82A64230 => {
    //   block [0x82A64230..0x82A64258)
	// 82A64230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6423C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64248: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A6424C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64250: 419A0008  beq cr6, 0x82a64258
	if ctx.cr[6].eq {
	pc = 0x82A64258; continue 'dispatch;
	}
	// 82A64254: 4813B845  bl 0x82b9fa98
	ctx.lr = 0x82A64258;
	sub_82B9FA98(ctx, base);
	pc = 0x82A64258; continue 'dispatch;
            }
            0x82A64258 => {
    //   block [0x82A64258..0x82A6426C)
	// 82A64258: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A6425C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A64260: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64264: 419A0040  beq cr6, 0x82a642a4
	if ctx.cr[6].eq {
	pc = 0x82A642A4; continue 'dispatch;
	}
	// 82A64268: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A6426C; continue 'dispatch;
            }
            0x82A6426C => {
    //   block [0x82A6426C..0x82A642A0)
	// 82A6426C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A64270: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64274: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A64278: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A6427C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A64280: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64284: 4082FFE8  bne 0x82a6426c
	if !ctx.cr[0].eq {
	pc = 0x82A6426C; continue 'dispatch;
	}
	// 82A64288: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6428C: 409A0014  bne cr6, 0x82a642a0
	if !ctx.cr[6].eq {
	pc = 0x82A642A0; continue 'dispatch;
	}
	// 82A64290: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64294: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64298: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6429C: 4E800421  bctrl
	ctx.lr = 0x82A642A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A642A0 => {
    //   block [0x82A642A0..0x82A642A4)
	// 82A642A0: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	pc = 0x82A642A4; continue 'dispatch;
            }
            0x82A642A4 => {
    //   block [0x82A642A4..0x82A642B4)
	// 82A642A4: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A642A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A642AC: 419A0040  beq cr6, 0x82a642ec
	if ctx.cr[6].eq {
	pc = 0x82A642EC; continue 'dispatch;
	}
	// 82A642B0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A642B4; continue 'dispatch;
            }
            0x82A642B4 => {
    //   block [0x82A642B4..0x82A642E8)
	// 82A642B4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A642B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A642BC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A642C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A642C4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A642C8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A642CC: 4082FFE8  bne 0x82a642b4
	if !ctx.cr[0].eq {
	pc = 0x82A642B4; continue 'dispatch;
	}
	// 82A642D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A642D4: 409A0014  bne cr6, 0x82a642e8
	if !ctx.cr[6].eq {
	pc = 0x82A642E8; continue 'dispatch;
	}
	// 82A642D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A642DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A642E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A642E4: 4E800421  bctrl
	ctx.lr = 0x82A642E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A642E8 => {
    //   block [0x82A642E8..0x82A642EC)
	// 82A642E8: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	pc = 0x82A642EC; continue 'dispatch;
            }
            0x82A642EC => {
    //   block [0x82A642EC..0x82A642FC)
	// 82A642EC: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A642F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A642F4: 419A0040  beq cr6, 0x82a64334
	if ctx.cr[6].eq {
	pc = 0x82A64334; continue 'dispatch;
	}
	// 82A642F8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A642FC; continue 'dispatch;
            }
            0x82A642FC => {
    //   block [0x82A642FC..0x82A64330)
	// 82A642FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A64300: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64304: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A64308: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A6430C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A64310: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64314: 4082FFE8  bne 0x82a642fc
	if !ctx.cr[0].eq {
	pc = 0x82A642FC; continue 'dispatch;
	}
	// 82A64318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6431C: 409A0014  bne cr6, 0x82a64330
	if !ctx.cr[6].eq {
	pc = 0x82A64330; continue 'dispatch;
	}
	// 82A64320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64324: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64328: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6432C: 4E800421  bctrl
	ctx.lr = 0x82A64330;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A64330 => {
    //   block [0x82A64330..0x82A64334)
	// 82A64330: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	pc = 0x82A64334; continue 'dispatch;
            }
            0x82A64334 => {
    //   block [0x82A64334..0x82A64344)
	// 82A64334: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A64338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6433C: 419A0040  beq cr6, 0x82a6437c
	if ctx.cr[6].eq {
	pc = 0x82A6437C; continue 'dispatch;
	}
	// 82A64340: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A64344; continue 'dispatch;
            }
            0x82A64344 => {
    //   block [0x82A64344..0x82A64378)
	// 82A64344: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A64348: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6434C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A64350: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A64354: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A64358: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6435C: 4082FFE8  bne 0x82a64344
	if !ctx.cr[0].eq {
	pc = 0x82A64344; continue 'dispatch;
	}
	// 82A64360: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A64364: 409A0014  bne cr6, 0x82a64378
	if !ctx.cr[6].eq {
	pc = 0x82A64378; continue 'dispatch;
	}
	// 82A64368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6436C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64370: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A64374: 4E800421  bctrl
	ctx.lr = 0x82A64378;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A64378 => {
    //   block [0x82A64378..0x82A6437C)
	// 82A64378: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6437C; continue 'dispatch;
            }
            0x82A6437C => {
    //   block [0x82A6437C..0x82A64394)
	// 82A6437C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A64384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A64388: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6438C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64398 size=224
    let mut pc: u32 = 0x82A64398;
    'dispatch: loop {
        match pc {
            0x82A64398 => {
    //   block [0x82A64398..0x82A64414)
	// 82A64398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6439C: 4824505D  bl 0x82ca93f8
	ctx.lr = 0x82A643A0;
	sub_82CA93D0(ctx, base);
	// 82A643A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A643A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A643A8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A643AC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82A643B0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A643B4: 371A0018  addic. r24, r26, 0x18
	ctx.xer.ca = (ctx.r[26].u32 > (!(24 as u32)));
	ctx.r[24].s64 = ctx.r[26].s64 + 24;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A643B8: C00BD5C8  lfs f0, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A643BC: D01A0010  stfs f0, 0x10(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A643C0: 915A0014  stw r10, 0x14(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82A643C4: 933A001C  stw r25, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	// 82A643C8: 933A0020  stw r25, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 82A643CC: 41820080  beq 0x82a6444c
	if ctx.cr[0].eq {
	pc = 0x82A6444C; continue 'dispatch;
	}
	// 82A643D0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A643D4: 3C806480  lis r4, 0x6480
	ctx.r[4].s64 = 1686110208;
	// 82A643D8: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 82A643DC: 836B0364  lwz r27, 0x364(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A643E0: 4B7C85F1  bl 0x8222c9d0
	ctx.lr = 0x82A643E4;
	sub_8222C9D0(ctx, base);
	// 82A643E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A643E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A643EC: 419A0078  beq cr6, 0x82a64464
	if ctx.cr[6].eq {
	pc = 0x82A64464; continue 'dispatch;
	}
	// 82A643F0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A643F4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A643F8: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82A643FC: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A64400: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A64404: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A64408: 3BDF0058  addi r30, r31, 0x58
	ctx.r[30].s64 = ctx.r[31].s64 + 88;
	// 82A6440C: 939F0098  stw r28, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A64410: 939F0094  stw r28, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
	pc = 0x82A64414; continue 'dispatch;
            }
            0x82A64414 => {
    //   block [0x82A64414..0x82A6444C)
	// 82A64414: 38BEFFC4  addi r5, r30, -0x3c
	ctx.r[5].s64 = ctx.r[30].s64 + -60;
	// 82A64418: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6441C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A64420: 4813B551  bl 0x82b9f970
	ctx.lr = 0x82A64424;
	sub_82B9F970(ctx, base);
	// 82A64424: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A64428: 41980030  blt cr6, 0x82a64458
	if ctx.cr[6].lt {
	pc = 0x82A64458; continue 'dispatch;
	}
	// 82A6442C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A64430: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A64434: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A64438: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6443C: 4198FFD8  blt cr6, 0x82a64414
	if ctx.cr[6].lt {
	pc = 0x82A64414; continue 'dispatch;
	}
	// 82A64440: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A64444: 9B9F0010  stb r28, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 82A64448: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A6444C; continue 'dispatch;
            }
            0x82A6444C => {
    //   block [0x82A6444C..0x82A64458)
	// 82A6444C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A64450: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64454: 48244FF4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A64458 => {
    //   block [0x82A64458..0x82A64464)
	// 82A64458: 93BF0098  stw r29, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[29].u32 ) };
	// 82A6445C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64460: 4813B639  bl 0x82b9fa98
	ctx.lr = 0x82A64464;
	sub_82B9FA98(ctx, base);
	pc = 0x82A64464; continue 'dispatch;
            }
            0x82A64464 => {
    //   block [0x82A64464..0x82A64478)
	// 82A64464: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82A64468: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6446C: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64470: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64474: 48244FD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64478 size=212
    let mut pc: u32 = 0x82A64478;
    'dispatch: loop {
        match pc {
            0x82A64478 => {
    //   block [0x82A64478..0x82A644A0)
	// 82A64478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6447C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64480: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A64484: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6448C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64490: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A64494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64498: 419A0008  beq cr6, 0x82a644a0
	if ctx.cr[6].eq {
	pc = 0x82A644A0; continue 'dispatch;
	}
	// 82A6449C: 4813B5FD  bl 0x82b9fa98
	ctx.lr = 0x82A644A0;
	sub_82B9FA98(ctx, base);
	pc = 0x82A644A0; continue 'dispatch;
            }
            0x82A644A0 => {
    //   block [0x82A644A0..0x82A644B4)
	// 82A644A0: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A644A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A644A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A644AC: 419A0040  beq cr6, 0x82a644ec
	if ctx.cr[6].eq {
	pc = 0x82A644EC; continue 'dispatch;
	}
	// 82A644B0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A644B4; continue 'dispatch;
            }
            0x82A644B4 => {
    //   block [0x82A644B4..0x82A644E8)
	// 82A644B4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A644B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A644BC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A644C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A644C4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A644C8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A644CC: 4082FFE8  bne 0x82a644b4
	if !ctx.cr[0].eq {
	pc = 0x82A644B4; continue 'dispatch;
	}
	// 82A644D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A644D4: 409A0014  bne cr6, 0x82a644e8
	if !ctx.cr[6].eq {
	pc = 0x82A644E8; continue 'dispatch;
	}
	// 82A644D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A644DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A644E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A644E4: 4E800421  bctrl
	ctx.lr = 0x82A644E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A644E8 => {
    //   block [0x82A644E8..0x82A644EC)
	// 82A644E8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	pc = 0x82A644EC; continue 'dispatch;
            }
            0x82A644EC => {
    //   block [0x82A644EC..0x82A644FC)
	// 82A644EC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A644F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A644F4: 419A0040  beq cr6, 0x82a64534
	if ctx.cr[6].eq {
	pc = 0x82A64534; continue 'dispatch;
	}
	// 82A644F8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A644FC; continue 'dispatch;
            }
            0x82A644FC => {
    //   block [0x82A644FC..0x82A64530)
	// 82A644FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A64500: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64504: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A64508: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A6450C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A64510: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64514: 4082FFE8  bne 0x82a644fc
	if !ctx.cr[0].eq {
	pc = 0x82A644FC; continue 'dispatch;
	}
	// 82A64518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6451C: 409A0014  bne cr6, 0x82a64530
	if !ctx.cr[6].eq {
	pc = 0x82A64530; continue 'dispatch;
	}
	// 82A64520: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64524: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64528: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6452C: 4E800421  bctrl
	ctx.lr = 0x82A64530;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A64530 => {
    //   block [0x82A64530..0x82A64534)
	// 82A64530: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	pc = 0x82A64534; continue 'dispatch;
            }
            0x82A64534 => {
    //   block [0x82A64534..0x82A6454C)
	// 82A64534: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64538: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6453C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A64540: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A64544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64550 size=544
    let mut pc: u32 = 0x82A64550;
    'dispatch: loop {
        match pc {
            0x82A64550 => {
    //   block [0x82A64550..0x82A64770)
	// 82A64550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64554: 48244EAD  bl 0x82ca9400
	ctx.lr = 0x82A64558;
	sub_82CA93D0(ctx, base);
	// 82A64558: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 82A6455C: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82A64560: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A64564: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64568: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A6456C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A64570: 3BCA94CC  addi r30, r10, -0x6b34
	ctx.r[30].s64 = ctx.r[10].s64 + -27444;
	// 82A64574: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A64578: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A6457C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82A64580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64584: C01EFFC4  lfs f0, -0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A64588: 3C608200  lis r3, -0x7e00
	ctx.r[3].s64 = -2113929216;
	// 82A6458C: C3FEFFB8  lfs f31, -0x48(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-72 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A64590: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A64594: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A64598: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A6459C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A645A0: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 82A645A4: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A645A8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A645AC: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A645B0: 88DF000C  lbz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A645B4: 550807FE  clrlwi r8, r8, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 82A645B8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A645BC: 54C6067E  clrlwi r6, r6, 0x19
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x0000007Fu64;
	// 82A645C0: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82A645C4: 3B800018  li r28, 0x18
	ctx.r[28].s64 = 24;
	// 82A645C8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A645CC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A645D0: 98DF000C  stb r6, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u8 ) };
	// 82A645D4: 3B4352C8  addi r26, r3, 0x52c8
	ctx.r[26].s64 = ctx.r[3].s64 + 21192;
	// 82A645D8: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A645DC: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82A645E0: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 82A645E4: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82A645E8: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82A645EC: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82A645F0: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A645F4: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82A645F8: 93BF0024  stw r29, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 82A645FC: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82A64600: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	// 82A64604: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 82A64608: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 82A6460C: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64770 size=80
    let mut pc: u32 = 0x82A64770;
    'dispatch: loop {
        match pc {
            0x82A64770 => {
    //   block [0x82A64770..0x82A647A8)
	// 82A64770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6477C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64788: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6478C: 48000035  bl 0x82a647c0
	ctx.lr = 0x82A64790;
	sub_82A647C0(ctx, base);
	// 82A64790: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A64794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6479C: 419A000C  beq cr6, 0x82a647a8
	if ctx.cr[6].eq {
	pc = 0x82A647A8; continue 'dispatch;
	}
	// 82A647A0: 4B7B7599  bl 0x8221bd38
	ctx.lr = 0x82A647A4;
	sub_8221BD38(ctx, base);
	// 82A647A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A647A8; continue 'dispatch;
            }
            0x82A647A8 => {
    //   block [0x82A647A8..0x82A647C0)
	// 82A647A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A647AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A647B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A647B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A647B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A647BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A647C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A647C0 size=248
    let mut pc: u32 = 0x82A647C0;
    'dispatch: loop {
        match pc {
            0x82A647C0 => {
    //   block [0x82A647C0..0x82A647E4)
	// 82A647C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A647C4: 48244C49  bl 0x82ca940c
	ctx.lr = 0x82A647C8;
	sub_82CA93D0(ctx, base);
	// 82A647C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A647CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A647D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A647D4: 3BFD0100  addi r31, r29, 0x100
	ctx.r[31].s64 = ctx.r[29].s64 + 256;
	// 82A647D8: 394B52C8  addi r10, r11, 0x52c8
	ctx.r[10].s64 = ctx.r[11].s64 + 21192;
	// 82A647DC: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82A647E0: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A647E4; continue 'dispatch;
            }
            0x82A647E4 => {
    //   block [0x82A647E4..0x82A647F8)
	// 82A647E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A647E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A647EC: 419A000C  beq cr6, 0x82a647f8
	if ctx.cr[6].eq {
	pc = 0x82A647F8; continue 'dispatch;
	}
	// 82A647F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A647F4: 480000C5  bl 0x82a648b8
	ctx.lr = 0x82A647F8;
	sub_82A648B8(ctx, base);
	pc = 0x82A647F8; continue 'dispatch;
            }
            0x82A647F8 => {
    //   block [0x82A647F8..0x82A64818)
	// 82A647F8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A647FC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A64800: 4082FFE4  bne 0x82a647e4
	if !ctx.cr[0].eq {
	pc = 0x82A647E4; continue 'dispatch;
	}
	// 82A64804: 807D0114  lwz r3, 0x114(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A64808: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6480C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64810: 419A0040  beq cr6, 0x82a64850
	if ctx.cr[6].eq {
	pc = 0x82A64850; continue 'dispatch;
	}
	// 82A64814: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A64818; continue 'dispatch;
            }
            0x82A64818 => {
    //   block [0x82A64818..0x82A6484C)
	// 82A64818: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A6481C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64820: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A64824: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A64828: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6482C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64830: 4082FFE8  bne 0x82a64818
	if !ctx.cr[0].eq {
	pc = 0x82A64818; continue 'dispatch;
	}
	// 82A64834: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A64838: 409A0014  bne cr6, 0x82a6484c
	if !ctx.cr[6].eq {
	pc = 0x82A6484C; continue 'dispatch;
	}
	// 82A6483C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64840: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64844: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A64848: 4E800421  bctrl
	ctx.lr = 0x82A6484C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6484C => {
    //   block [0x82A6484C..0x82A64850)
	// 82A6484C: 93FD0114  stw r31, 0x114(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(276 as u32), ctx.r[31].u32 ) };
	pc = 0x82A64850; continue 'dispatch;
            }
            0x82A64850 => {
    //   block [0x82A64850..0x82A64860)
	// 82A64850: 807D0110  lwz r3, 0x110(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A64854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64858: 419A0040  beq cr6, 0x82a64898
	if ctx.cr[6].eq {
	pc = 0x82A64898; continue 'dispatch;
	}
	// 82A6485C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A64860; continue 'dispatch;
            }
            0x82A64860 => {
    //   block [0x82A64860..0x82A64894)
	// 82A64860: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A64864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64868: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A6486C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A64870: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A64874: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64878: 4082FFE8  bne 0x82a64860
	if !ctx.cr[0].eq {
	pc = 0x82A64860; continue 'dispatch;
	}
	// 82A6487C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A64880: 409A0014  bne cr6, 0x82a64894
	if !ctx.cr[6].eq {
	pc = 0x82A64894; continue 'dispatch;
	}
	// 82A64884: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64888: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6488C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A64890: 4E800421  bctrl
	ctx.lr = 0x82A64894;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A64894 => {
    //   block [0x82A64894..0x82A64898)
	// 82A64894: 93FD0110  stw r31, 0x110(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(272 as u32), ctx.r[31].u32 ) };
	pc = 0x82A64898; continue 'dispatch;
            }
            0x82A64898 => {
    //   block [0x82A64898..0x82A648B8)
	// 82A64898: 387D00D0  addi r3, r29, 0xd0
	ctx.r[3].s64 = ctx.r[29].s64 + 208;
	// 82A6489C: 4BFFFBDD  bl 0x82a64478
	ctx.lr = 0x82A648A0;
	sub_82A64478(ctx, base);
	// 82A648A0: 387D0090  addi r3, r29, 0x90
	ctx.r[3].s64 = ctx.r[29].s64 + 144;
	// 82A648A4: 4BFFF98D  bl 0x82a64230
	ctx.lr = 0x82A648A8;
	sub_82A64230(ctx, base);
	// 82A648A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A648AC: 48014BF5  bl 0x82a794a0
	ctx.lr = 0x82A648B0;
	sub_82A794A0(ctx, base);
	// 82A648B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A648B4: 48244BA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A648B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A648B8 size=208
    let mut pc: u32 = 0x82A648B8;
    'dispatch: loop {
        match pc {
            0x82A648B8 => {
    //   block [0x82A648B8..0x82A648E4)
	// 82A648B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A648BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A648C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A648C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A648C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A648CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A648D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A648D4: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A648D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A648DC: 419A0040  beq cr6, 0x82a6491c
	if ctx.cr[6].eq {
	pc = 0x82A6491C; continue 'dispatch;
	}
	// 82A648E0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A648E4; continue 'dispatch;
            }
            0x82A648E4 => {
    //   block [0x82A648E4..0x82A64918)
	// 82A648E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A648E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A648EC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A648F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A648F4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A648F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A648FC: 4082FFE8  bne 0x82a648e4
	if !ctx.cr[0].eq {
	pc = 0x82A648E4; continue 'dispatch;
	}
	// 82A64900: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A64904: 409A0014  bne cr6, 0x82a64918
	if !ctx.cr[6].eq {
	pc = 0x82A64918; continue 'dispatch;
	}
	// 82A64908: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6490C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64910: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A64914: 4E800421  bctrl
	ctx.lr = 0x82A64918;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A64918 => {
    //   block [0x82A64918..0x82A6491C)
	// 82A64918: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6491C; continue 'dispatch;
            }
            0x82A6491C => {
    //   block [0x82A6491C..0x82A6492C)
	// 82A6491C: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A64920: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64924: 419A0040  beq cr6, 0x82a64964
	if ctx.cr[6].eq {
	pc = 0x82A64964; continue 'dispatch;
	}
	// 82A64928: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A6492C; continue 'dispatch;
            }
            0x82A6492C => {
    //   block [0x82A6492C..0x82A64960)
	// 82A6492C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A64930: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64934: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A64938: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A6493C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A64940: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A64944: 4082FFE8  bne 0x82a6492c
	if !ctx.cr[0].eq {
	pc = 0x82A6492C; continue 'dispatch;
	}
	// 82A64948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6494C: 409A0014  bne cr6, 0x82a64960
	if !ctx.cr[6].eq {
	pc = 0x82A64960; continue 'dispatch;
	}
	// 82A64950: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64954: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64958: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6495C: 4E800421  bctrl
	ctx.lr = 0x82A64960;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A64960 => {
    //   block [0x82A64960..0x82A64964)
	// 82A64960: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	pc = 0x82A64964; continue 'dispatch;
            }
            0x82A64964 => {
    //   block [0x82A64964..0x82A64988)
	// 82A64964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64968: 4B7B73D1  bl 0x8221bd38
	ctx.lr = 0x82A6496C;
	sub_8221BD38(ctx, base);
	// 82A6496C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A64978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6497C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A64980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64988 size=360
    let mut pc: u32 = 0x82A64988;
    'dispatch: loop {
        match pc {
            0x82A64988 => {
    //   block [0x82A64988..0x82A64AF0)
	// 82A64988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6498C: 48244A79  bl 0x82ca9404
	ctx.lr = 0x82A64990;
	sub_82CA93D0(ctx, base);
	// 82A64990: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64994: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A64998: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A6499C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A649A0: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82A649A4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A649A8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A649AC: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A649B0: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82A649B4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A649B8: 38AB9484  addi r5, r11, -0x6b7c
	ctx.r[5].s64 = ctx.r[11].s64 + -27516;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64AF0 size=788
    let mut pc: u32 = 0x82A64AF0;
    'dispatch: loop {
        match pc {
            0x82A64AF0 => {
    //   block [0x82A64AF0..0x82A64B78)
	// 82A64AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64AF4: 48244901  bl 0x82ca93f4
	ctx.lr = 0x82A64AF8;
	sub_82CA93D0(ctx, base);
	// 82A64AF8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64AFC: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A64B00: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82A64B04: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 82A64B08: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A64B0C: 830100F4  lwz r24, 0xf4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A64B10: 3978FFFC  addi r11, r24, -4
	ctx.r[11].s64 = ctx.r[24].s64 + -4;
	// 82A64B14: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A64B18: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A64B1C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A64B20: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A64B24: 832100EC  lwz r25, 0xec(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A64B28: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 82A64B2C: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82A64B30: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A64B34: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82A64B38: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 82A64B3C: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A64B40: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82A64B44: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A64B48: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64B4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64B50: 480002B9  bl 0x82a64e08
	ctx.lr = 0x82A64B54;
	sub_82A64E08(ctx, base);
	// 82A64B54: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A64B58: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 82A64B5C: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A64B60: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A64B64: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A64B68: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A64B6C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A64B70: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82A64B74: 4098004C  bge cr6, 0x82a64bc0
	if !ctx.cr[6].lt {
	pc = 0x82A64BC0; continue 'dispatch;
	}
	pc = 0x82A64B78; continue 'dispatch;
            }
            0x82A64B78 => {
    //   block [0x82A64B78..0x82A64BC0)
	// 82A64B78: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64B7C: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A64B80: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64B84: 4E800421  bctrl
	ctx.lr = 0x82A64B88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64B88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64B90: 409A0030  bne cr6, 0x82a64bc0
	if !ctx.cr[6].eq {
	pc = 0x82A64BC0; continue 'dispatch;
	}
	// 82A64B94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64B98: 809FFFFC  lwz r4, -4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A64B9C: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64BA0: 4E800421  bctrl
	ctx.lr = 0x82A64BA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64BA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64BAC: 409A0014  bne cr6, 0x82a64bc0
	if !ctx.cr[6].eq {
	pc = 0x82A64BC0; continue 'dispatch;
	}
	// 82A64BB0: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A64BB4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A64BB8: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A64BBC: 4198FFBC  blt cr6, 0x82a64b78
	if ctx.cr[6].lt {
	pc = 0x82A64B78; continue 'dispatch;
	}
            }
            0x82A64BC0 => {
    //   block [0x82A64BC0..0x82A64BCC)
	// 82A64BC0: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A64BC4: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A64BC8: 4098004C  bge cr6, 0x82a64c14
	if !ctx.cr[6].lt {
	pc = 0x82A64C14; continue 'dispatch;
	}
	pc = 0x82A64BCC; continue 'dispatch;
            }
            0x82A64BCC => {
    //   block [0x82A64BCC..0x82A64C14)
	// 82A64BCC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64BD0: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64BD4: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64BD8: 4E800421  bctrl
	ctx.lr = 0x82A64BDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64BDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64BE4: 409A0030  bne cr6, 0x82a64c14
	if !ctx.cr[6].eq {
	pc = 0x82A64C14; continue 'dispatch;
	}
	// 82A64BE8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64BEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64BF0: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64BF4: 4E800421  bctrl
	ctx.lr = 0x82A64BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64BF8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64C00: 409A0014  bne cr6, 0x82a64c14
	if !ctx.cr[6].eq {
	pc = 0x82A64C14; continue 'dispatch;
	}
	// 82A64C04: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A64C08: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A64C0C: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A64C10: 4198FFBC  blt cr6, 0x82a64bcc
	if ctx.cr[6].lt {
	pc = 0x82A64BCC; continue 'dispatch;
	}
            }
            0x82A64C14 => {
    //   block [0x82A64C14..0x82A64C2C)
	// 82A64C14: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64C18: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64C1C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A64C20: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82A64C24: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A64C28: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x82A64C2C; continue 'dispatch;
            }
            0x82A64C2C => {
    //   block [0x82A64C2C..0x82A64C34)
	// 82A64C2C: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A64C30: 40980070  bge cr6, 0x82a64ca0
	if !ctx.cr[6].lt {
	pc = 0x82A64CA0; continue 'dispatch;
	}
	pc = 0x82A64C34; continue 'dispatch;
            }
            0x82A64C34 => {
    //   block [0x82A64C34..0x82A64C90)
	// 82A64C34: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64C38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64C3C: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64C40: 4E800421  bctrl
	ctx.lr = 0x82A64C44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64C44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64C4C: 409A0044  bne cr6, 0x82a64c90
	if !ctx.cr[6].eq {
	pc = 0x82A64C90; continue 'dispatch;
	}
	// 82A64C50: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64C54: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64C58: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64C5C: 4E800421  bctrl
	ctx.lr = 0x82A64C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64C60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64C68: 409A0038  bne cr6, 0x82a64ca0
	if !ctx.cr[6].eq {
	pc = 0x82A64CA0; continue 'dispatch;
	}
	// 82A64C6C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64C70: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A64C74: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64C78: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A64C7C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82A64C80: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A64C84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64C88: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A64C8C: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
            }
            0x82A64C90 => {
    //   block [0x82A64C90..0x82A64CA0)
	// 82A64C90: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A64C94: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A64C98: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A64C9C: 4198FF98  blt cr6, 0x82a64c34
	if ctx.cr[6].lt {
	pc = 0x82A64C34; continue 'dispatch;
	}
	pc = 0x82A64CA0; continue 'dispatch;
            }
            0x82A64CA0 => {
    //   block [0x82A64CA0..0x82A64CA8)
	// 82A64CA0: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A64CA4: 4099006C  ble cr6, 0x82a64d10
	if !ctx.cr[6].gt {
	pc = 0x82A64D10; continue 'dispatch;
	}
	pc = 0x82A64CA8; continue 'dispatch;
            }
            0x82A64CA8 => {
    //   block [0x82A64CA8..0x82A64D00)
	// 82A64CA8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64CAC: 3BDBFFFC  addi r30, r27, -4
	ctx.r[30].s64 = ctx.r[27].s64 + -4;
	// 82A64CB0: 807BFFFC  lwz r3, -4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A64CB4: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64CB8: 4E800421  bctrl
	ctx.lr = 0x82A64CBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64CBC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64CC4: 409A003C  bne cr6, 0x82a64d00
	if !ctx.cr[6].eq {
	pc = 0x82A64D00; continue 'dispatch;
	}
	// 82A64CC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64CCC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64CD0: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A64CD4: 4E800421  bctrl
	ctx.lr = 0x82A64CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64CD8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A64CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64CE0: 409A002C  bne cr6, 0x82a64d0c
	if !ctx.cr[6].eq {
	pc = 0x82A64D0C; continue 'dispatch;
	}
	// 82A64CE4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A64CE8: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A64CEC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A64CF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64CF4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64CF8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A64CFC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
            }
            0x82A64D00 => {
    //   block [0x82A64D00..0x82A64D0C)
	// 82A64D00: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82A64D04: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A64D08: 4198FFA0  blt cr6, 0x82a64ca8
	if ctx.cr[6].lt {
	pc = 0x82A64CA8; continue 'dispatch;
	}
	pc = 0x82A64D0C; continue 'dispatch;
            }
            0x82A64D0C => {
    //   block [0x82A64D0C..0x82A64D10)
	// 82A64D0C: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	pc = 0x82A64D10; continue 'dispatch;
            }
            0x82A64D10 => {
    //   block [0x82A64D10..0x82A64D34)
	// 82A64D10: 409A0068  bne cr6, 0x82a64d78
	if !ctx.cr[6].eq {
	pc = 0x82A64D78; continue 'dispatch;
	}
	// 82A64D14: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A64D18: 419A00D0  beq cr6, 0x82a64de8
	if ctx.cr[6].eq {
	pc = 0x82A64DE8; continue 'dispatch;
	}
	// 82A64D1C: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A64D20: 419A0014  beq cr6, 0x82a64d34
	if ctx.cr[6].eq {
	pc = 0x82A64D34; continue 'dispatch;
	}
	// 82A64D24: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D28: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64D30: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A64D34; continue 'dispatch;
            }
            0x82A64D34 => {
    //   block [0x82A64D34..0x82A64D78)
	// 82A64D34: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64D38: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A64D3C: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A64D40: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A64D44: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A64D48: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A64D4C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A64D50: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A64D54: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A64D58: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82A64D5C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A64D60: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A64D64: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D68: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D6C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A64D70: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A64D74: 4BFFFEB8  b 0x82a64c2c
	pc = 0x82A64C2C; continue 'dispatch;
            }
            0x82A64D78 => {
    //   block [0x82A64D78..0x82A64DA4)
	// 82A64D78: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A64D7C: 3B7BFFFC  addi r27, r27, -4
	ctx.r[27].s64 = ctx.r[27].s64 + -4;
	// 82A64D80: 409A0040  bne cr6, 0x82a64dc0
	if !ctx.cr[6].eq {
	pc = 0x82A64DC0; continue 'dispatch;
	}
	// 82A64D84: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A64D88: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A64D8C: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A64D90: 419A0014  beq cr6, 0x82a64da4
	if ctx.cr[6].eq {
	pc = 0x82A64DA4; continue 'dispatch;
	}
	// 82A64D94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D98: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D9C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64DA0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A64DA4; continue 'dispatch;
            }
            0x82A64DA4 => {
    //   block [0x82A64DA4..0x82A64DC0)
	// 82A64DA4: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 82A64DA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64DAC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A64DB0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64DB4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A64DB8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64DBC: 4BFFFE70  b 0x82a64c2c
	pc = 0x82A64C2C; continue 'dispatch;
            }
            0x82A64DC0 => {
    //   block [0x82A64DC0..0x82A64DE8)
	// 82A64DC0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A64DC4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A64DC8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64DCC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A64DD0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A64DD4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A64DD8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64DDC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A64DE0: 913B0000  stw r9, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A64DE4: 4BFFFE48  b 0x82a64c2c
	pc = 0x82A64C2C; continue 'dispatch;
            }
            0x82A64DE8 => {
    //   block [0x82A64DE8..0x82A64E04)
	// 82A64DE8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64DEC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A64DF0: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64DF4: F9770000  std r11, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A64DF8: F9570008  std r10, 8(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82A64DFC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A64E00: 48244644  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64E08 size=276
    let mut pc: u32 = 0x82A64E08;
    'dispatch: loop {
        match pc {
            0x82A64E08 => {
    //   block [0x82A64E08..0x82A64F08)
	// 82A64E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64E0C: 482445ED  bl 0x82ca93f8
	ctx.lr = 0x82A64E10;
	sub_82CA93D0(ctx, base);
	// 82A64E10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64E14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A64E18: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A64E1C: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 82A64E20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A64E24: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 82A64E28: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A64E2C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A64E30: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A64E34: 7D6AC050  subf r11, r10, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 82A64E38: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A64E3C: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 82A64E40: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82A64E44: 409900C4  ble cr6, 0x82a64f08
	if !ctx.cr[6].gt {
	pc = 0x82A64F08; continue 'dispatch;
	}
	// 82A64E48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A64E4C: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A64E50: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82A64E54: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A64E58: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A64E5C: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A64E60: 55791838  slwi r25, r11, 3
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82A64E64: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A64E68: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 82A64E6C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A64E70: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A64E74: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64E78: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64E7C: 4803CF3D  bl 0x82aa1db8
	ctx.lr = 0x82A64E80;
	sub_82AA1DB8(ctx, base);
	// 82A64E80: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A64E84: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A64E88: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82A64E8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A64E90: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82A64E94: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A64E98: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A64E9C: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82A64EA0: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A64EA4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64EA8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64EAC: 4803CF0D  bl 0x82aa1db8
	ctx.lr = 0x82A64EB0;
	sub_82AA1DB8(ctx, base);
	// 82A64EB0: 7C99C050  subf r4, r25, r24
	ctx.r[4].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 82A64EB4: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A64EB8: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 82A64EBC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A64EC0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A64EC4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A64EC8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A64ECC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A64ED0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64ED4: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64ED8: 4803CEE1  bl 0x82aa1db8
	ctx.lr = 0x82A64EDC;
	sub_82AA1DB8(ctx, base);
	// 82A64EDC: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A64EE0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A64EE4: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A64EE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A64EEC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A64EF0: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A64EF4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A64EF8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A64EFC: 4803CEBD  bl 0x82aa1db8
	ctx.lr = 0x82A64F00;
	sub_82AA1DB8(ctx, base);
	// 82A64F00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A64F04: 48244544  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A64F08 => {
    //   block [0x82A64F08..0x82A64F1C)
	// 82A64F08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A64F0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A64F10: 4803CEA9  bl 0x82aa1db8
	ctx.lr = 0x82A64F14;
	sub_82AA1DB8(ctx, base);
	// 82A64F14: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A64F18: 48244530  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A64F20 size=100
    let mut pc: u32 = 0x82A64F20;
    'dispatch: loop {
        match pc {
            0x82A64F20 => {
    //   block [0x82A64F20..0x82A64F84)
	// 82A64F20: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64F88 size=112
    let mut pc: u32 = 0x82A64F88;
    'dispatch: loop {
        match pc {
            0x82A64F88 => {
    //   block [0x82A64F88..0x82A64FF8)
	// 82A64F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64F90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64F94: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64FA0: 4B7A64F1  bl 0x8220b490
	ctx.lr = 0x82A64FA4;
	sub_8220B490(ctx, base);
	// 82A64FA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A64FA8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A64FAC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A64FB0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82A64FB4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82A64FB8: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64FF8 size=264
    let mut pc: u32 = 0x82A64FF8;
    'dispatch: loop {
        match pc {
            0x82A64FF8 => {
    //   block [0x82A64FF8..0x82A65100)
	// 82A64FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64FFC: 48244411  bl 0x82ca940c
	ctx.lr = 0x82A65000;
	sub_82CA93D0(ctx, base);
	// 82A65000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65008: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 82A6500C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A65010: 38DDD5C8  addi r6, r29, -0x2a38
	ctx.r[6].s64 = ctx.r[29].s64 + -10808;
	// 82A65014: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A65018: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6501C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A65020: 891F000C  lbz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A65024: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A65028: 552507FE  clrlwi r5, r9, 0x1f
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82A6502C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A65030: 5504067E  clrlwi r4, r8, 0x19
	ctx.r[4].u64 = ctx.r[8].u32 as u64 & 0x0000007Fu64;
	// 82A65034: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82A65038: 39276500  addi r9, r7, 0x6500
	ctx.r[9].s64 = ctx.r[7].s64 + 25856;
	// 82A6503C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A65040: 989F000C  stb r4, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u8 ) };
	// 82A65044: C006BEBC  lfs f0, -0x4144(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65048: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A6504C: C1A6BEC8  lfs f13, -0x4138(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A65050: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A65054: 387F01D0  addi r3, r31, 0x1d0
	ctx.r[3].s64 = ctx.r[31].s64 + 464;
	// 82A65058: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82A6505C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A65060: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A65064: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82A65068: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82A6506C: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82A65070: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82A65074: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82A65078: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A6507C: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82A65080: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82A65084: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82A65088: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A6508C: 997F00A0  stb r11, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 82A65090: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A65094: 997F00A2  stb r11, 0xa2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(162 as u32), ctx.r[11].u8 ) };
	// 82A65098: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82A6509C: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82A650A0: 93FF0020  stw r31, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82A650A4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A650A8: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A650AC: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82A650B0: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82A650B4: 4BFDB835  bl 0x82a408e8
	ctx.lr = 0x82A650B8;
	sub_82A408E8(ctx, base);
	// 82A650B8: 387F0250  addi r3, r31, 0x250
	ctx.r[3].s64 = ctx.r[31].s64 + 592;
	// 82A650BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A650C0: 4BFDB829  bl 0x82a408e8
	ctx.lr = 0x82A650C4;
	sub_82A408E8(ctx, base);
	// 82A650C4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A650C8: C01DD5C8  lfs f0, -0x2a38(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A650CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A650D0: D01F02E0  stfs f0, 0x2e0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), tmp.u32 ) };
	// 82A650D4: C8080D38  lfd f0, 0xd38(r8)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3384 as u32) ) };
	// 82A650D8: D81F02D0  stfd f0, 0x2d0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), ctx.f[0].u64 ) };
	// 82A650DC: D81F02D8  stfd f0, 0x2d8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.f[0].u64 ) };
	// 82A650E0: 93DF03F0  stw r30, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[30].u32 ) };
	// 82A650E4: 93DF05C0  stw r30, 0x5c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1472 as u32), ctx.r[30].u32 ) };
	// 82A650E8: 93DF05D0  stw r30, 0x5d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1488 as u32), ctx.r[30].u32 ) };
	// 82A650EC: 93DF05D4  stw r30, 0x5d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1492 as u32), ctx.r[30].u32 ) };
	// 82A650F0: 93DF05D8  stw r30, 0x5d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1496 as u32), ctx.r[30].u32 ) };
	// 82A650F4: 9BDF0048  stb r30, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u8 ) };
	// 82A650F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A650FC: 48244360  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65100 size=108
    let mut pc: u32 = 0x82A65100;
    'dispatch: loop {
        match pc {
            0x82A65100 => {
    //   block [0x82A65100..0x82A65154)
	// 82A65100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65108: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6510C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65110: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65118: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6511C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A65120: 392B6500  addi r9, r11, 0x6500
	ctx.r[9].s64 = ctx.r[11].s64 + 25856;
	// 82A65124: 390A6A70  addi r8, r10, 0x6a70
	ctx.r[8].s64 = ctx.r[10].s64 + 27248;
	// 82A65128: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6512C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A65130: 911F0250  stw r8, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[8].u32 ) };
	// 82A65134: 911F01D0  stw r8, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[8].u32 ) };
	// 82A65138: 48014369  bl 0x82a794a0
	ctx.lr = 0x82A6513C;
	sub_82A794A0(ctx, base);
	// 82A6513C: 57C707FE  clrlwi r7, r30, 0x1f
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A65140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65144: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A65148: 419A000C  beq cr6, 0x82a65154
	if ctx.cr[6].eq {
	pc = 0x82A65154; continue 'dispatch;
	}
	// 82A6514C: 4B7B6BED  bl 0x8221bd38
	ctx.lr = 0x82A65150;
	sub_8221BD38(ctx, base);
	// 82A65150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A65154; continue 'dispatch;
            }
            0x82A65154 => {
    //   block [0x82A65154..0x82A6516C)
	// 82A65154: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A65158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6515C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A65160: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A65164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A65168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65170 size=252
    let mut pc: u32 = 0x82A65170;
    'dispatch: loop {
        match pc {
            0x82A65170 => {
    //   block [0x82A65170..0x82A6526C)
	// 82A65170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6517C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65180: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A65184: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A65188: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A6518C: 392BCB94  addi r9, r11, -0x346c
	ctx.r[9].s64 = ctx.r[11].s64 + -13420;
	// 82A65190: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A65194: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82A65198: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6519C: C1ABCB94  lfs f13, -0x346c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A651A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A651A4: C009C8F0  lfs f0, -0x3710(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A651A8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A651AC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A651B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65270 size=244
    let mut pc: u32 = 0x82A65270;
    'dispatch: loop {
        match pc {
            0x82A65270 => {
    //   block [0x82A65270..0x82A65364)
	// 82A65270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65274: 48244199  bl 0x82ca940c
	ctx.lr = 0x82A65278;
	sub_82CA93D0(ctx, base);
	// 82A65278: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6527C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65280: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A65284: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A65288: 4BFFFEE9  bl 0x82a65170
	ctx.lr = 0x82A6528C;
	sub_82A65170(ctx, base);
	// 82A6528C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A65290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65294: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82A65298: 480B6D39  bl 0x82b1bfd0
	ctx.lr = 0x82A6529C;
	sub_82B1BFD0(ctx, base);
	// 82A6529C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A652A0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82A652A4: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 82A652A8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A652AC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82A652B0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A652B4: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A652B8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A652BC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A652C0: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A652C4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A652C8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A652CC: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A652D0: C1A9FE50  lfs f13, -0x1b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A652D4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65368 size=92
    let mut pc: u32 = 0x82A65368;
    'dispatch: loop {
        match pc {
            0x82A65368 => {
    //   block [0x82A65368..0x82A653AC)
	// 82A65368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6536C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A65374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6537C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65380: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A65384: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A65388: 394B6C48  addi r10, r11, 0x6c48
	ctx.r[10].s64 = ctx.r[11].s64 + 27720;
	// 82A6538C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A65390: 480B6D79  bl 0x82b1c108
	ctx.lr = 0x82A65394;
	sub_82B1C108(ctx, base);
	// 82A65394: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A65398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6539C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A653A0: 419A000C  beq cr6, 0x82a653ac
	if ctx.cr[6].eq {
	pc = 0x82A653AC; continue 'dispatch;
	}
	// 82A653A4: 4B7B6995  bl 0x8221bd38
	ctx.lr = 0x82A653A8;
	sub_8221BD38(ctx, base);
	// 82A653A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A653AC; continue 'dispatch;
            }
            0x82A653AC => {
    //   block [0x82A653AC..0x82A653C4)
	// 82A653AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A653B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A653B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A653B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A653BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A653C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A653C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A653C8 size=256
    let mut pc: u32 = 0x82A653C8;
    'dispatch: loop {
        match pc {
            0x82A653C8 => {
    //   block [0x82A653C8..0x82A65414)
	// 82A653C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A653CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A653D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A653D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A653D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A653DC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A653E0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82A653E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A653E8: 480B6BE9  bl 0x82b1bfd0
	ctx.lr = 0x82A653EC;
	sub_82B1BFD0(ctx, base);
	// 82A653EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A653F0: 893F0150  lbz r9, 0x150(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A653F4: 394B6548  addi r10, r11, 0x6548
	ctx.r[10].s64 = ctx.r[11].s64 + 25928;
	// 82A653F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A653FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A65400: 419A0014  beq cr6, 0x82a65414
	if ctx.cr[6].eq {
	pc = 0x82A65414; continue 'dispatch;
	}
	// 82A65404: 897F0152  lbz r11, 0x152(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(338 as u32) ) } as u64;
	// 82A65408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6540C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A65410: 419A0008  beq cr6, 0x82a65418
	if ctx.cr[6].eq {
	pc = 0x82A65418; continue 'dispatch;
	}
	pc = 0x82A65414; continue 'dispatch;
            }
            0x82A65414 => {
    //   block [0x82A65414..0x82A65418)
	// 82A65414: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A65418; continue 'dispatch;
            }
            0x82A65418 => {
    //   block [0x82A65418..0x82A65458)
	// 82A65418: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A6541C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65420: 419A008C  beq cr6, 0x82a654ac
	if ctx.cr[6].eq {
	pc = 0x82A654AC; continue 'dispatch;
	}
	// 82A65424: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 82A65428: 4B7B9E31  bl 0x8221f258
	ctx.lr = 0x82A6542C;
	sub_8221F258(ctx, base);
	// 82A6542C: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82A65430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65434: 419A0024  beq cr6, 0x82a65458
	if ctx.cr[6].eq {
	pc = 0x82A65458; continue 'dispatch;
	}
	// 82A65438: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6543C: 809EF9C4  lwz r4, -0x63c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 82A65440: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A65444: 38CBDA90  addi r6, r11, -0x2570
	ctx.r[6].s64 = ctx.r[11].s64 + -9584;
	// 82A65448: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6544C: 4803B64D  bl 0x82aa0a98
	ctx.lr = 0x82A65450;
	sub_82AA0A98(ctx, base);
	// 82A65450: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A65454: 48000008  b 0x82a6545c
	pc = 0x82A6545C; continue 'dispatch;
            }
            0x82A65458 => {
    //   block [0x82A65458..0x82A6545C)
	// 82A65458: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A6545C; continue 'dispatch;
            }
            0x82A6545C => {
    //   block [0x82A6545C..0x82A65490)
	// 82A6545C: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82A65460: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 82A65464: 4B7B9DF5  bl 0x8221f258
	ctx.lr = 0x82A65468;
	sub_8221F258(ctx, base);
	// 82A65468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6546C: 419A0024  beq cr6, 0x82a65490
	if ctx.cr[6].eq {
	pc = 0x82A65490; continue 'dispatch;
	}
	// 82A65470: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A65474: 809EF9C4  lwz r4, -0x63c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 82A65478: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6547C: 38CBDAB4  addi r6, r11, -0x254c
	ctx.r[6].s64 = ctx.r[11].s64 + -9548;
	// 82A65480: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A65484: 4803B615  bl 0x82aa0a98
	ctx.lr = 0x82A65488;
	sub_82AA0A98(ctx, base);
	// 82A65488: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6548C: 48000008  b 0x82a65494
	pc = 0x82A65494; continue 'dispatch;
            }
            0x82A65490 => {
    //   block [0x82A65490..0x82A65494)
	// 82A65490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A65494; continue 'dispatch;
            }
            0x82A65494 => {
    //   block [0x82A65494..0x82A654AC)
	// 82A65494: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A65498: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82A6549C: 916A025C  stw r11, 0x25c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 82A654A0: 813F00B4  lwz r9, 0xb4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A654A4: 811F00B0  lwz r8, 0xb0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A654A8: 91090258  stw r8, 0x258(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(600 as u32), ctx.r[8].u32 ) };
	pc = 0x82A654AC; continue 'dispatch;
            }
            0x82A654AC => {
    //   block [0x82A654AC..0x82A654C8)
	// 82A654AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A654B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A654B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A654B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A654BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A654C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A654C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A654C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A654C8 size=80
    let mut pc: u32 = 0x82A654C8;
    'dispatch: loop {
        match pc {
            0x82A654C8 => {
    //   block [0x82A654C8..0x82A65500)
	// 82A654C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A654CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A654D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A654D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A654D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A654DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A654E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A654E4: 48000035  bl 0x82a65518
	ctx.lr = 0x82A654E8;
	sub_82A65518(ctx, base);
	// 82A654E8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A654EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A654F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A654F4: 419A000C  beq cr6, 0x82a65500
	if ctx.cr[6].eq {
	pc = 0x82A65500; continue 'dispatch;
	}
	// 82A654F8: 4B7B6841  bl 0x8221bd38
	ctx.lr = 0x82A654FC;
	sub_8221BD38(ctx, base);
	// 82A654FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A65500; continue 'dispatch;
            }
            0x82A65500 => {
    //   block [0x82A65500..0x82A65518)
	// 82A65500: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A65504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A65508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6550C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A65510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A65514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65518 size=144
    let mut pc: u32 = 0x82A65518;
    'dispatch: loop {
        match pc {
            0x82A65518 => {
    //   block [0x82A65518..0x82A6555C)
	// 82A65518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6551C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65520: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65524: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6552C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A65530: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A65534: 392B6548  addi r9, r11, 0x6548
	ctx.r[9].s64 = ctx.r[11].s64 + 25928;
	// 82A65538: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6553C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A65540: 806A0E64  lwz r3, 0xe64(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3684 as u32) ) } as u64;
	// 82A65544: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A65548: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6554C: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A65550: 7CEA2E71  srawi. r10, r7, 5
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A65554: 40810038  ble 0x82a6558c
	if !ctx.cr[0].gt {
	pc = 0x82A6558C; continue 'dispatch;
	}
	// 82A65558: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	pc = 0x82A6555C; continue 'dispatch;
            }
            0x82A6555C => {
    //   block [0x82A6555C..0x82A6557C)
	// 82A6555C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65560: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A65564: 419A0018  beq cr6, 0x82a6557c
	if ctx.cr[6].eq {
	pc = 0x82A6557C; continue 'dispatch;
	}
	// 82A65568: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82A6556C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A65570: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A65574: 4198FFE8  blt cr6, 0x82a6555c
	if ctx.cr[6].lt {
	pc = 0x82A6555C; continue 'dispatch;
	}
	// 82A65578: 48000014  b 0x82a6558c
	pc = 0x82A6558C; continue 'dispatch;
            }
            0x82A6557C => {
    //   block [0x82A6557C..0x82A6558C)
	// 82A6557C: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 82A65580: 419A000C  beq cr6, 0x82a6558c
	if ctx.cr[6].eq {
	pc = 0x82A6558C; continue 'dispatch;
	}
	// 82A65584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65588: 480511D1  bl 0x82ab6758
	ctx.lr = 0x82A6558C;
	sub_82AB6758(ctx, base);
	pc = 0x82A6558C; continue 'dispatch;
            }
            0x82A6558C => {
    //   block [0x82A6558C..0x82A655A8)
	// 82A6558C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65590: 480B6B79  bl 0x82b1c108
	ctx.lr = 0x82A65594;
	sub_82B1C108(ctx, base);
	// 82A65594: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A65598: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6559C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A655A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A655A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A655A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A655A8 size=232
    let mut pc: u32 = 0x82A655A8;
    'dispatch: loop {
        match pc {
            0x82A655A8 => {
    //   block [0x82A655A8..0x82A6565C)
	// 82A655A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A655AC: 48243E55  bl 0x82ca9400
	ctx.lr = 0x82A655B0;
	sub_82CA93D0(ctx, base);
	// 82A655B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A655B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A655B8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A655BC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A655C0: 3B6A9484  addi r27, r10, -0x6b7c
	ctx.r[27].s64 = ctx.r[10].s64 + -27516;
	// 82A655C4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82A655C8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A655CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A655D0: 891F000C  lbz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A655D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A655D8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A655DC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A655E0: 552407FE  clrlwi r4, r9, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82A655E4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A655E8: 38A0001A  li r5, 0x1a
	ctx.r[5].s64 = 26;
	// 82A655EC: 935F001C  stw r26, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 82A655F0: 5503067E  clrlwi r3, r8, 0x19
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000007Fu64;
	// 82A655F4: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A655F8: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 82A655FC: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A65600: 39275080  addi r9, r7, 0x5080
	ctx.r[9].s64 = ctx.r[7].s64 + 20608;
	// 82A65604: 987F000C  stb r3, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u8 ) };
	// 82A65608: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A6560C: C8060D38  lfd f0, 0xd38(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(3384 as u32) ) };
	// 82A65610: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82A65614: C1BB4144  lfs f13, 0x4144(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A65618: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82A6561C: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A65620: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A65624: 3B9F0060  addi r28, r31, 0x60
	ctx.r[28].s64 = ctx.r[31].s64 + 96;
	// 82A65628: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82A6562C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A65630: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82A65634: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82A65638: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A6563C: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82A65640: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82A65644: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82A65648: 93FF0020  stw r31, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82A6564C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A65650: D81F0048  stfd f0, 0x48(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.f[0].u64 ) };
	// 82A65654: D81F0050  stfd f0, 0x50(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82A65658: D1BF0058  stfs f13, 0x58(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x82A6565C; continue 'dispatch;
            }
            0x82A6565C => {
    //   block [0x82A6565C..0x82A65690)
	// 82A6565C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A65660: 4BFDB869  bl 0x82a40ec8
	ctx.lr = 0x82A65664;
	sub_82A40EC8(ctx, base);
	// 82A65664: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A65668: 3B9C0210  addi r28, r28, 0x210
	ctx.r[28].s64 = ctx.r[28].s64 + 528;
	// 82A6566C: 4080FFF0  bge 0x82a6565c
	if !ctx.cr[0].lt {
	pc = 0x82A6565C; continue 'dispatch;
	}
	// 82A65670: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65678: D01F05A0  stfs f0, 0x5a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1440 as u32), tmp.u32 ) };
	// 82A6567C: 93DF05A4  stw r30, 0x5a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1444 as u32), ctx.r[30].u32 ) };
	// 82A65680: 93DF05A8  stw r30, 0x5a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1448 as u32), ctx.r[30].u32 ) };
	// 82A65684: 9B5F05B0  stb r26, 0x5b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1456 as u32), ctx.r[26].u8 ) };
	// 82A65688: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A6568C: 48243DC4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65690 size=80
    let mut pc: u32 = 0x82A65690;
    'dispatch: loop {
        match pc {
            0x82A65690 => {
    //   block [0x82A65690..0x82A656C8)
	// 82A65690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65698: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6569C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A656A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A656A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A656A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A656AC: 48000035  bl 0x82a656e0
	ctx.lr = 0x82A656B0;
	sub_82A656E0(ctx, base);
	// 82A656B0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A656B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A656B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A656BC: 419A000C  beq cr6, 0x82a656c8
	if ctx.cr[6].eq {
	pc = 0x82A656C8; continue 'dispatch;
	}
	// 82A656C0: 4B7B6679  bl 0x8221bd38
	ctx.lr = 0x82A656C4;
	sub_8221BD38(ctx, base);
	// 82A656C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A656C8; continue 'dispatch;
            }
            0x82A656C8 => {
    //   block [0x82A656C8..0x82A656E0)
	// 82A656C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A656CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A656D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A656D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A656D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A656DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A656E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A656E0 size=216
    let mut pc: u32 = 0x82A656E0;
    'dispatch: loop {
        match pc {
            0x82A656E0 => {
    //   block [0x82A656E0..0x82A65718)
	// 82A656E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A656E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A656E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A656EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A656F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A656F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A656F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A656FC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A65700: 394B5080  addi r10, r11, 0x5080
	ctx.r[10].s64 = ctx.r[11].s64 + 20608;
	// 82A65704: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A65708: 807F05A8  lwz r3, 0x5a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82A6570C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65710: 419A0040  beq cr6, 0x82a65750
	if ctx.cr[6].eq {
	pc = 0x82A65750; continue 'dispatch;
	}
	// 82A65714: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A65718; continue 'dispatch;
            }
            0x82A65718 => {
    //   block [0x82A65718..0x82A6574C)
	// 82A65718: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A6571C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65720: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A65724: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A65728: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6572C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65730: 4082FFE8  bne 0x82a65718
	if !ctx.cr[0].eq {
	pc = 0x82A65718; continue 'dispatch;
	}
	// 82A65734: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65738: 409A0014  bne cr6, 0x82a6574c
	if !ctx.cr[6].eq {
	pc = 0x82A6574C; continue 'dispatch;
	}
	// 82A6573C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65740: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65744: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65748: 4E800421  bctrl
	ctx.lr = 0x82A6574C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6574C => {
    //   block [0x82A6574C..0x82A65750)
	// 82A6574C: 93DF05A8  stw r30, 0x5a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1448 as u32), ctx.r[30].u32 ) };
	pc = 0x82A65750; continue 'dispatch;
            }
            0x82A65750 => {
    //   block [0x82A65750..0x82A65760)
	// 82A65750: 807F05A4  lwz r3, 0x5a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82A65754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65758: 419A0040  beq cr6, 0x82a65798
	if ctx.cr[6].eq {
	pc = 0x82A65798; continue 'dispatch;
	}
	// 82A6575C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A65760; continue 'dispatch;
            }
            0x82A65760 => {
    //   block [0x82A65760..0x82A65794)
	// 82A65760: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A65764: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65768: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A6576C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A65770: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65774: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65778: 4082FFE8  bne 0x82a65760
	if !ctx.cr[0].eq {
	pc = 0x82A65760; continue 'dispatch;
	}
	// 82A6577C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65780: 409A0014  bne cr6, 0x82a65794
	if !ctx.cr[6].eq {
	pc = 0x82A65794; continue 'dispatch;
	}
	// 82A65784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65788: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6578C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65790: 4E800421  bctrl
	ctx.lr = 0x82A65794;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65794 => {
    //   block [0x82A65794..0x82A65798)
	// 82A65794: 93DF05A4  stw r30, 0x5a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1444 as u32), ctx.r[30].u32 ) };
	pc = 0x82A65798; continue 'dispatch;
            }
            0x82A65798 => {
    //   block [0x82A65798..0x82A657B8)
	// 82A65798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6579C: 48013D05  bl 0x82a794a0
	ctx.lr = 0x82A657A0;
	sub_82A794A0(ctx, base);
	// 82A657A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A657A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A657A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A657AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A657B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A657B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A657C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A657C0 size=168
    let mut pc: u32 = 0x82A657C0;
    'dispatch: loop {
        match pc {
            0x82A657C0 => {
    //   block [0x82A657C0..0x82A65814)
	// 82A657C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A657C4: 48243C49  bl 0x82ca940c
	ctx.lr = 0x82A657C8;
	sub_82CA93D0(ctx, base);
	// 82A657C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A657CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A657D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A657D4: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A657D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A657DC: 409A0080  bne cr6, 0x82a6585c
	if !ctx.cr[6].eq {
	pc = 0x82A6585C; continue 'dispatch;
	}
	// 82A657E0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A657E4: 807F05A4  lwz r3, 0x5a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82A657E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A657EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A657F0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A657F4: 4B7B92FD  bl 0x8221eaf0
	ctx.lr = 0x82A657F8;
	sub_8221EAF0(ctx, base);
	// 82A657F8: 815F05A4  lwz r10, 0x5a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82A657FC: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 82A65800: 617EFFFF  ori r30, r11, 0xffff
	ctx.r[30].u64 = ctx.r[11].u64 | 65535;
	// 82A65804: 812A0054  lwz r9, 0x54(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A65808: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82A6580C: 409A0008  bne cr6, 0x82a65814
	if !ctx.cr[6].eq {
	pc = 0x82A65814; continue 'dispatch;
	}
	// 82A65810: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82A65814; continue 'dispatch;
            }
            0x82A65814 => {
    //   block [0x82A65814..0x82A6584C)
	// 82A65814: 817F0270  lwz r11, 0x270(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 82A65818: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A6581C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A65820: 419A002C  beq cr6, 0x82a6584c
	if ctx.cr[6].eq {
	pc = 0x82A6584C; continue 'dispatch;
	}
	// 82A65824: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A65828: 807F05A8  lwz r3, 0x5a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82A6582C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A65830: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A65834: 4B7B92BD  bl 0x8221eaf0
	ctx.lr = 0x82A65838;
	sub_8221EAF0(ctx, base);
	// 82A65838: 817F05A8  lwz r11, 0x5a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82A6583C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A65840: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82A65844: 409A0008  bne cr6, 0x82a6584c
	if !ctx.cr[6].eq {
	pc = 0x82A6584C; continue 'dispatch;
	}
	// 82A65848: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82A6584C; continue 'dispatch;
            }
            0x82A6584C => {
    //   block [0x82A6584C..0x82A6585C)
	// 82A6584C: 897F0478  lbz r11, 0x478(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1144 as u32) ) } as u64;
	// 82A65850: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A65854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65858: 409A0008  bne cr6, 0x82a65860
	if !ctx.cr[6].eq {
	pc = 0x82A65860; continue 'dispatch;
	}
	pc = 0x82A6585C; continue 'dispatch;
            }
            0x82A6585C => {
    //   block [0x82A6585C..0x82A65860)
	// 82A6585C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82A65860; continue 'dispatch;
            }
            0x82A65860 => {
    //   block [0x82A65860..0x82A65868)
	// 82A65860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A65864: 48243BF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A65868 size=560
    let mut pc: u32 = 0x82A65868;
    'dispatch: loop {
        match pc {
            0x82A65868 => {
    //   block [0x82A65868..0x82A65A98)
	// 82A65868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6586C: 48243B8D  bl 0x82ca93f8
	ctx.lr = 0x82A65870;
	sub_82CA93D0(ctx, base);
	// 82A65870: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A65874: D021001C  stfs f1, 0x1c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A65878: 38830060  addi r4, r3, 0x60
	ctx.r[4].s64 = ctx.r[3].s64 + 96;
	// 82A6587C: 390AB970  addi r8, r10, -0x4690
	ctx.r[8].s64 = ctx.r[10].s64 + -18064;
	// 82A65880: 3BE30270  addi r31, r3, 0x270
	ctx.r[31].s64 = ctx.r[3].s64 + 624;
	// 82A65884: 39640028  addi r11, r4, 0x28
	ctx.r[11].s64 = ctx.r[4].s64 + 40;
	// 82A65888: C00AB970  lfs f0, -0x4690(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6588C: 393F0010  addi r9, r31, 0x10
	ctx.r[9].s64 = ctx.r[31].s64 + 16;
	// 82A65890: D001FF20  stfs f0, -0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-224 as u32), tmp.u32 ) };
	// 82A65894: 39430488  addi r10, r3, 0x488
	ctx.r[10].s64 = ctx.r[3].s64 + 1160;
	// 82A65898: C008DB20  lfs f0, -0x24e0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-9440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6589C: 7CFF2050  subf r7, r31, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 82A658A0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A658A4: D001FF24  stfs f0, -0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-220 as u32), tmp.u32 ) };
	// 82A658A8: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82A658AC: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82A658B0: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65A98 size=664
    let mut pc: u32 = 0x82A65A98;
    'dispatch: loop {
        match pc {
            0x82A65A98 => {
    //   block [0x82A65A98..0x82A65AEC)
	// 82A65A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65A9C: 4824396D  bl 0x82ca9408
	ctx.lr = 0x82A65AA0;
	sub_82CA93D0(ctx, base);
	// 82A65AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65AA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A65AAC: 397F0048  addi r11, r31, 0x48
	ctx.r[11].s64 = ctx.r[31].s64 + 72;
	// 82A65AB0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A65AB4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A65AB8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65ABC: 5149083C  rlwimi r9, r10, 1, 0, 0x1e
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[9].u64 & 0xFFFFFFFF00000001);
	// 82A65AC0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A65AC4: C81F0050  lfd f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 82A65AC8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A65ACC: 40990020  ble cr6, 0x82a65aec
	if !ctx.cr[6].gt {
	pc = 0x82A65AEC; continue 'dispatch;
	}
	// 82A65AD0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A65AD4: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 82A65AD8: D82B0008  stfd f1, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[1].u64 ) };
	// 82A65ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A65AE0: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65AE4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A65AE8: 48000008  b 0x82a65af0
	pc = 0x82A65AF0; continue 'dispatch;
            }
            0x82A65AEC => {
    //   block [0x82A65AEC..0x82A65AF0)
	// 82A65AEC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x82A65AF0; continue 'dispatch;
            }
            0x82A65AF0 => {
    //   block [0x82A65AF0..0x82A65B08)
	// 82A65AF0: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A65AF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65AF8: 419A0010  beq cr6, 0x82a65b08
	if ctx.cr[6].eq {
	pc = 0x82A65B08; continue 'dispatch;
	}
	// 82A65AFC: 389F0270  addi r4, r31, 0x270
	ctx.r[4].s64 = ctx.r[31].s64 + 624;
	// 82A65B00: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82A65B04: 4BE08695  bl 0x8286e198
	ctx.lr = 0x82A65B08;
	sub_8286E198(ctx, base);
	pc = 0x82A65B08; continue 'dispatch;
            }
            0x82A65B08 => {
    //   block [0x82A65B08..0x82A65B50)
	// 82A65B08: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A65B10: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65B14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65B18: 4E800421  bctrl
	ctx.lr = 0x82A65B1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A65B1C: 2F03001F  cmpwi cr6, r3, 0x1f
	ctx.cr[6].compare_i32(ctx.r[3].s32, 31, &mut ctx.xer);
	// 82A65B20: 409A0208  bne cr6, 0x82a65d28
	if !ctx.cr[6].eq {
	pc = 0x82A65D28; continue 'dispatch;
	}
	// 82A65B24: 3BBF0270  addi r29, r31, 0x270
	ctx.r[29].s64 = ctx.r[31].s64 + 624;
	// 82A65B28: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82A65B2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A65B30: 4BE08669  bl 0x8286e198
	ctx.lr = 0x82A65B34;
	sub_8286E198(ctx, base);
	// 82A65B34: 897F05B0  lbz r11, 0x5b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1456 as u32) ) } as u64;
	// 82A65B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65B3C: 419A0014  beq cr6, 0x82a65b50
	if ctx.cr[6].eq {
	pc = 0x82A65B50; continue 'dispatch;
	}
	// 82A65B40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A65B44: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82A65B48: 4BE08651  bl 0x8286e198
	ctx.lr = 0x82A65B4C;
	sub_8286E198(ctx, base);
	// 82A65B4C: 9B9F05B0  stb r28, 0x5b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1456 as u32), ctx.r[28].u8 ) };
            }
            0x82A65B50 => {
    //   block [0x82A65B50..0x82A65B80)
	// 82A65B50: 389F0460  addi r4, r31, 0x460
	ctx.r[4].s64 = ctx.r[31].s64 + 1120;
	// 82A65B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65B58: 4B745F41  bl 0x821aba98
	ctx.lr = 0x82A65B5C;
	sub_821ABA98(ctx, base);
	// 82A65B5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A65B60: 817F05A4  lwz r11, 0x5a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82A65B64: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65B68: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A65B6C: 419A007C  beq cr6, 0x82a65be8
	if ctx.cr[6].eq {
	pc = 0x82A65BE8; continue 'dispatch;
	}
	// 82A65B70: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A65B74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65B78: 419A0040  beq cr6, 0x82a65bb8
	if ctx.cr[6].eq {
	pc = 0x82A65BB8; continue 'dispatch;
	}
	// 82A65B7C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A65B80; continue 'dispatch;
            }
            0x82A65B80 => {
    //   block [0x82A65B80..0x82A65BB4)
	// 82A65B80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A65B84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65B88: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A65B8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A65B90: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65B94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65B98: 4082FFE8  bne 0x82a65b80
	if !ctx.cr[0].eq {
	pc = 0x82A65B80; continue 'dispatch;
	}
	// 82A65B9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65BA0: 409A0014  bne cr6, 0x82a65bb4
	if !ctx.cr[6].eq {
	pc = 0x82A65BB4; continue 'dispatch;
	}
	// 82A65BA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65BA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65BAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65BB0: 4E800421  bctrl
	ctx.lr = 0x82A65BB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65BB4 => {
    //   block [0x82A65BB4..0x82A65BB8)
	// 82A65BB4: 939F05A4  stw r28, 0x5a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1444 as u32), ctx.r[28].u32 ) };
	pc = 0x82A65BB8; continue 'dispatch;
            }
            0x82A65BB8 => {
    //   block [0x82A65BB8..0x82A65BCC)
	// 82A65BB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65BC0: 917F05A4  stw r11, 0x5a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1444 as u32), ctx.r[11].u32 ) };
	// 82A65BC4: 419A0024  beq cr6, 0x82a65be8
	if ctx.cr[6].eq {
	pc = 0x82A65BE8; continue 'dispatch;
	}
	// 82A65BC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A65BCC; continue 'dispatch;
            }
            0x82A65BCC => {
    //   block [0x82A65BCC..0x82A65BE8)
	// 82A65BCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65BD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65BD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65BD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A65BDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65BE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65BE4: 4082FFE8  bne 0x82a65bcc
	if !ctx.cr[0].eq {
	pc = 0x82A65BCC; continue 'dispatch;
	}
	pc = 0x82A65BE8; continue 'dispatch;
            }
            0x82A65BE8 => {
    //   block [0x82A65BE8..0x82A65BFC)
	// 82A65BE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A65BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65BF0: 419A0048  beq cr6, 0x82a65c38
	if ctx.cr[6].eq {
	pc = 0x82A65C38; continue 'dispatch;
	}
	// 82A65BF4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A65BF8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A65BFC; continue 'dispatch;
            }
            0x82A65BFC => {
    //   block [0x82A65BFC..0x82A65C34)
	// 82A65BFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65C00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65C04: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65C08: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A65C0C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65C10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65C14: 4082FFE8  bne 0x82a65bfc
	if !ctx.cr[0].eq {
	pc = 0x82A65BFC; continue 'dispatch;
	}
	// 82A65C18: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A65C1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65C20: 409A0014  bne cr6, 0x82a65c34
	if !ctx.cr[6].eq {
	pc = 0x82A65C34; continue 'dispatch;
	}
	// 82A65C24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65C28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65C2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65C30: 4E800421  bctrl
	ctx.lr = 0x82A65C34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65C34 => {
    //   block [0x82A65C34..0x82A65C38)
	// 82A65C34: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A65C38; continue 'dispatch;
            }
            0x82A65C38 => {
    //   block [0x82A65C38..0x82A65C74)
	// 82A65C38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65C3C: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A65C44: 419A00E4  beq cr6, 0x82a65d28
	if ctx.cr[6].eq {
	pc = 0x82A65D28; continue 'dispatch;
	}
	// 82A65C48: 389F046C  addi r4, r31, 0x46c
	ctx.r[4].s64 = ctx.r[31].s64 + 1132;
	// 82A65C4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A65C50: 4B745E49  bl 0x821aba98
	ctx.lr = 0x82A65C54;
	sub_821ABA98(ctx, base);
	// 82A65C54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A65C58: 807F05A8  lwz r3, 0x5a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82A65C5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65C60: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A65C64: 419A0078  beq cr6, 0x82a65cdc
	if ctx.cr[6].eq {
	pc = 0x82A65CDC; continue 'dispatch;
	}
	// 82A65C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65C6C: 419A0040  beq cr6, 0x82a65cac
	if ctx.cr[6].eq {
	pc = 0x82A65CAC; continue 'dispatch;
	}
	// 82A65C70: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A65C74; continue 'dispatch;
            }
            0x82A65C74 => {
    //   block [0x82A65C74..0x82A65CA8)
	// 82A65C74: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A65C78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65C7C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A65C80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A65C84: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65C88: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65C8C: 4082FFE8  bne 0x82a65c74
	if !ctx.cr[0].eq {
	pc = 0x82A65C74; continue 'dispatch;
	}
	// 82A65C90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65C94: 409A0014  bne cr6, 0x82a65ca8
	if !ctx.cr[6].eq {
	pc = 0x82A65CA8; continue 'dispatch;
	}
	// 82A65C98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65C9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65CA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65CA4: 4E800421  bctrl
	ctx.lr = 0x82A65CA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65CA8 => {
    //   block [0x82A65CA8..0x82A65CAC)
	// 82A65CA8: 939F05A8  stw r28, 0x5a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1448 as u32), ctx.r[28].u32 ) };
	pc = 0x82A65CAC; continue 'dispatch;
            }
            0x82A65CAC => {
    //   block [0x82A65CAC..0x82A65CC0)
	// 82A65CAC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65CB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65CB4: 917F05A8  stw r11, 0x5a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1448 as u32), ctx.r[11].u32 ) };
	// 82A65CB8: 419A0024  beq cr6, 0x82a65cdc
	if ctx.cr[6].eq {
	pc = 0x82A65CDC; continue 'dispatch;
	}
	// 82A65CBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A65CC0; continue 'dispatch;
            }
            0x82A65CC0 => {
    //   block [0x82A65CC0..0x82A65CDC)
	// 82A65CC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65CC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65CC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65CCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A65CD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65CD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65CD8: 4082FFE8  bne 0x82a65cc0
	if !ctx.cr[0].eq {
	pc = 0x82A65CC0; continue 'dispatch;
	}
	pc = 0x82A65CDC; continue 'dispatch;
            }
            0x82A65CDC => {
    //   block [0x82A65CDC..0x82A65CF0)
	// 82A65CDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A65CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65CE4: 419A0044  beq cr6, 0x82a65d28
	if ctx.cr[6].eq {
	pc = 0x82A65D28; continue 'dispatch;
	}
	// 82A65CE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A65CEC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A65CF0; continue 'dispatch;
            }
            0x82A65CF0 => {
    //   block [0x82A65CF0..0x82A65D28)
	// 82A65CF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65CF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65CF8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65CFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A65D00: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65D04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65D08: 4082FFE8  bne 0x82a65cf0
	if !ctx.cr[0].eq {
	pc = 0x82A65CF0; continue 'dispatch;
	}
	// 82A65D0C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A65D10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65D14: 409A0014  bne cr6, 0x82a65d28
	if !ctx.cr[6].eq {
	pc = 0x82A65D28; continue 'dispatch;
	}
	// 82A65D18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65D1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65D20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65D24: 4E800421  bctrl
	ctx.lr = 0x82A65D28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65D28 => {
    //   block [0x82A65D28..0x82A65D30)
	// 82A65D28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A65D2C: 4824372C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65D30 size=1396
    let mut pc: u32 = 0x82A65D30;
    'dispatch: loop {
        match pc {
            0x82A65D30 => {
    //   block [0x82A65D30..0x82A65D7C)
	// 82A65D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65D34: 482436CD  bl 0x82ca9400
	ctx.lr = 0x82A65D38;
	sub_82CA93D0(ctx, base);
	// 82A65D38: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A65D3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65D40: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A65D44: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A65D48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A65D4C: 397C0048  addi r11, r28, 0x48
	ctx.r[11].s64 = ctx.r[28].s64 + 72;
	// 82A65D50: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A65D54: C81C0050  lfd f0, 0x50(r28)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) };
	// 82A65D58: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A65D5C: 40990020  ble cr6, 0x82a65d7c
	if !ctx.cr[6].gt {
	pc = 0x82A65D7C; continue 'dispatch;
	}
	// 82A65D60: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A65D64: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 82A65D68: DBEB0008  stfd f31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[31].u64 ) };
	// 82A65D6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A65D70: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65D74: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A65D78: 48000008  b 0x82a65d80
	pc = 0x82A65D80; continue 'dispatch;
            }
            0x82A65D7C => {
    //   block [0x82A65D7C..0x82A65D80)
	// 82A65D7C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82A65D80; continue 'dispatch;
            }
            0x82A65D80 => {
    //   block [0x82A65D80..0x82A65D98)
	// 82A65D80: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A65D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65D88: 419A0010  beq cr6, 0x82a65d98
	if ctx.cr[6].eq {
	pc = 0x82A65D98; continue 'dispatch;
	}
	// 82A65D8C: 389C0270  addi r4, r28, 0x270
	ctx.r[4].s64 = ctx.r[28].s64 + 624;
	// 82A65D90: 387C0060  addi r3, r28, 0x60
	ctx.r[3].s64 = ctx.r[28].s64 + 96;
	// 82A65D94: 4BE08405  bl 0x8286e198
	ctx.lr = 0x82A65D98;
	sub_8286E198(ctx, base);
	pc = 0x82A65D98; continue 'dispatch;
            }
            0x82A65D98 => {
    //   block [0x82A65D98..0x82A65DD4)
	// 82A65D98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65DA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65DA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65DA8: 4E800421  bctrl
	ctx.lr = 0x82A65DAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A65DAC: 2F030015  cmpwi cr6, r3, 0x15
	ctx.cr[6].compare_i32(ctx.r[3].s32, 21, &mut ctx.xer);
	// 82A65DB0: 409A033C  bne cr6, 0x82a660ec
	if !ctx.cr[6].eq {
	pc = 0x82A660EC; continue 'dispatch;
	}
	// 82A65DB4: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65DB8: 3BBC0270  addi r29, r28, 0x270
	ctx.r[29].s64 = ctx.r[28].s64 + 624;
	// 82A65DBC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82A65DC0: 576B07FE  clrlwi r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82A65DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65DC8: 419A000C  beq cr6, 0x82a65dd4
	if ctx.cr[6].eq {
	pc = 0x82A65DD4; continue 'dispatch;
	}
	// 82A65DCC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65DD0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x82A65DD4 => {
    //   block [0x82A65DD4..0x82A65DE8)
	// 82A65DD4: 576B0462  rlwinm r11, r27, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65DDC: 419A000C  beq cr6, 0x82a65de8
	if ctx.cr[6].eq {
	pc = 0x82A65DE8; continue 'dispatch;
	}
	// 82A65DE0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65DE4: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82A65DE8; continue 'dispatch;
            }
            0x82A65DE8 => {
    //   block [0x82A65DE8..0x82A65E04)
	// 82A65DE8: 576B07BC  rlwinm r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65DF0: 419A0094  beq cr6, 0x82a65e84
	if ctx.cr[6].eq {
	pc = 0x82A65E84; continue 'dispatch;
	}
	// 82A65DF4: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 82A65DF8: 395D0010  addi r10, r29, 0x10
	ctx.r[10].s64 = ctx.r[29].s64 + 16;
	// 82A65DFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A65E00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A65E04; continue 'dispatch;
            }
            0x82A65E04 => {
    //   block [0x82A65E04..0x82A65E28)
	// 82A65E04: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A65E08: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A65E0C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A65E10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A65E14: 4200FFF0  bdnz 0x82a65e04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A65E04; continue 'dispatch;
	}
	// 82A65E18: 397E0050  addi r11, r30, 0x50
	ctx.r[11].s64 = ctx.r[30].s64 + 80;
	// 82A65E1C: 395D0050  addi r10, r29, 0x50
	ctx.r[10].s64 = ctx.r[29].s64 + 80;
	// 82A65E20: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A65E24: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A65E28; continue 'dispatch;
            }
            0x82A65E28 => {
    //   block [0x82A65E28..0x82A65E4C)
	// 82A65E28: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A65E2C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A65E30: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A65E34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A65E38: 4200FFF0  bdnz 0x82a65e28
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A65E28; continue 'dispatch;
	}
	// 82A65E3C: 397E0090  addi r11, r30, 0x90
	ctx.r[11].s64 = ctx.r[30].s64 + 144;
	// 82A65E40: 395D0090  addi r10, r29, 0x90
	ctx.r[10].s64 = ctx.r[29].s64 + 144;
	// 82A65E44: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A65E48: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A65E4C; continue 'dispatch;
            }
            0x82A65E4C => {
    //   block [0x82A65E4C..0x82A65E70)
	// 82A65E4C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A65E50: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A65E54: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A65E58: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A65E5C: 4200FFF0  bdnz 0x82a65e4c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A65E4C; continue 'dispatch;
	}
	// 82A65E60: 397E00D0  addi r11, r30, 0xd0
	ctx.r[11].s64 = ctx.r[30].s64 + 208;
	// 82A65E64: 395D00D0  addi r10, r29, 0xd0
	ctx.r[10].s64 = ctx.r[29].s64 + 208;
	// 82A65E68: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A65E6C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A65E70; continue 'dispatch;
            }
            0x82A65E70 => {
    //   block [0x82A65E70..0x82A65E84)
	// 82A65E70: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A65E74: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A65E78: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A65E7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A65E80: 4200FFF0  bdnz 0x82a65e70
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A65E70; continue 'dispatch;
	}
	pc = 0x82A65E84; continue 'dispatch;
            }
            0x82A65E84 => {
    //   block [0x82A65E84..0x82A65E98)
	// 82A65E84: 576B0738  rlwinm r11, r27, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65E8C: 419A000C  beq cr6, 0x82a65e98
	if ctx.cr[6].eq {
	pc = 0x82A65E98; continue 'dispatch;
	}
	// 82A65E90: C01E0194  lfs f0, 0x194(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65E94: D01D0194  stfs f0, 0x194(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(404 as u32), tmp.u32 ) };
	pc = 0x82A65E98; continue 'dispatch;
            }
            0x82A65E98 => {
    //   block [0x82A65E98..0x82A65EB4)
	// 82A65E98: 576B0672  rlwinm r11, r27, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65EA0: 419A0028  beq cr6, 0x82a65ec8
	if ctx.cr[6].eq {
	pc = 0x82A65EC8; continue 'dispatch;
	}
	// 82A65EA4: 397E01A0  addi r11, r30, 0x1a0
	ctx.r[11].s64 = ctx.r[30].s64 + 416;
	// 82A65EA8: 395D01A0  addi r10, r29, 0x1a0
	ctx.r[10].s64 = ctx.r[29].s64 + 416;
	// 82A65EAC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A65EB0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A65EB4; continue 'dispatch;
            }
            0x82A65EB4 => {
    //   block [0x82A65EB4..0x82A65EC8)
	// 82A65EB4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A65EB8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A65EBC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A65EC0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A65EC4: 4200FFF0  bdnz 0x82a65eb4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A65EB4; continue 'dispatch;
	}
	pc = 0x82A65EC8; continue 'dispatch;
            }
            0x82A65EC8 => {
    //   block [0x82A65EC8..0x82A65EEC)
	// 82A65EC8: 576B0630  rlwinm r11, r27, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65ED0: 419A001C  beq cr6, 0x82a65eec
	if ctx.cr[6].eq {
	pc = 0x82A65EEC; continue 'dispatch;
	}
	// 82A65ED4: E97E01E0  ld r11, 0x1e0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(480 as u32) ) };
	// 82A65ED8: 395E01E0  addi r10, r30, 0x1e0
	ctx.r[10].s64 = ctx.r[30].s64 + 480;
	// 82A65EDC: 393D01E0  addi r9, r29, 0x1e0
	ctx.r[9].s64 = ctx.r[29].s64 + 480;
	// 82A65EE0: F97D01E0  std r11, 0x1e0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(480 as u32), ctx.r[11].u64 ) };
	// 82A65EE4: E91E01E8  ld r8, 0x1e8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(488 as u32) ) };
	// 82A65EE8: F91D01E8  std r8, 0x1e8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(488 as u32), ctx.r[8].u64 ) };
	pc = 0x82A65EEC; continue 'dispatch;
            }
            0x82A65EEC => {
    //   block [0x82A65EEC..0x82A65F28)
	// 82A65EEC: 576B05EE  rlwinm r11, r27, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65EF4: 419A00EC  beq cr6, 0x82a65fe0
	if ctx.cr[6].eq {
	pc = 0x82A65FE0; continue 'dispatch;
	}
	// 82A65EF8: 389E01F0  addi r4, r30, 0x1f0
	ctx.r[4].s64 = ctx.r[30].s64 + 496;
	// 82A65EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65F00: 4B745B99  bl 0x821aba98
	ctx.lr = 0x82A65F04;
	sub_821ABA98(ctx, base);
	// 82A65F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65F08: 817C05A4  lwz r11, 0x5a4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82A65F0C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65F10: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A65F14: 419A007C  beq cr6, 0x82a65f90
	if ctx.cr[6].eq {
	pc = 0x82A65F90; continue 'dispatch;
	}
	// 82A65F18: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A65F1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65F20: 419A0040  beq cr6, 0x82a65f60
	if ctx.cr[6].eq {
	pc = 0x82A65F60; continue 'dispatch;
	}
	// 82A65F24: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A65F28; continue 'dispatch;
            }
            0x82A65F28 => {
    //   block [0x82A65F28..0x82A65F5C)
	// 82A65F28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A65F2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65F30: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A65F34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A65F38: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65F3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65F40: 4082FFE8  bne 0x82a65f28
	if !ctx.cr[0].eq {
	pc = 0x82A65F28; continue 'dispatch;
	}
	// 82A65F44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65F48: 409A0014  bne cr6, 0x82a65f5c
	if !ctx.cr[6].eq {
	pc = 0x82A65F5C; continue 'dispatch;
	}
	// 82A65F4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65F50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65F54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65F58: 4E800421  bctrl
	ctx.lr = 0x82A65F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65F5C => {
    //   block [0x82A65F5C..0x82A65F60)
	// 82A65F5C: 935C05A4  stw r26, 0x5a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1444 as u32), ctx.r[26].u32 ) };
	pc = 0x82A65F60; continue 'dispatch;
            }
            0x82A65F60 => {
    //   block [0x82A65F60..0x82A65F74)
	// 82A65F60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65F68: 917C05A4  stw r11, 0x5a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1444 as u32), ctx.r[11].u32 ) };
	// 82A65F6C: 419A0024  beq cr6, 0x82a65f90
	if ctx.cr[6].eq {
	pc = 0x82A65F90; continue 'dispatch;
	}
	// 82A65F70: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A65F74; continue 'dispatch;
            }
            0x82A65F74 => {
    //   block [0x82A65F74..0x82A65F90)
	// 82A65F74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65F78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65F7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65F80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A65F84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65F88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65F8C: 4082FFE8  bne 0x82a65f74
	if !ctx.cr[0].eq {
	pc = 0x82A65F74; continue 'dispatch;
	}
	pc = 0x82A65F90; continue 'dispatch;
            }
            0x82A65F90 => {
    //   block [0x82A65F90..0x82A65FA4)
	// 82A65F90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A65F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65F98: 419A0048  beq cr6, 0x82a65fe0
	if ctx.cr[6].eq {
	pc = 0x82A65FE0; continue 'dispatch;
	}
	// 82A65F9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A65FA0: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A65FA4; continue 'dispatch;
            }
            0x82A65FA4 => {
    //   block [0x82A65FA4..0x82A65FDC)
	// 82A65FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65FAC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65FB0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A65FB4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65FBC: 4082FFE8  bne 0x82a65fa4
	if !ctx.cr[0].eq {
	pc = 0x82A65FA4; continue 'dispatch;
	}
	// 82A65FC0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A65FC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65FC8: 409A0014  bne cr6, 0x82a65fdc
	if !ctx.cr[6].eq {
	pc = 0x82A65FDC; continue 'dispatch;
	}
	// 82A65FCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65FD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65FD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A65FD8: 4E800421  bctrl
	ctx.lr = 0x82A65FDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A65FDC => {
    //   block [0x82A65FDC..0x82A65FE0)
	// 82A65FDC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	pc = 0x82A65FE0; continue 'dispatch;
            }
            0x82A65FE0 => {
    //   block [0x82A65FE0..0x82A66018)
	// 82A65FE0: 576B0528  rlwinm r11, r27, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A65FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65FE8: 419A00E4  beq cr6, 0x82a660cc
	if ctx.cr[6].eq {
	pc = 0x82A660CC; continue 'dispatch;
	}
	// 82A65FEC: 389E01FC  addi r4, r30, 0x1fc
	ctx.r[4].s64 = ctx.r[30].s64 + 508;
	// 82A65FF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A65FF4: 4B745AA5  bl 0x821aba98
	ctx.lr = 0x82A65FF8;
	sub_821ABA98(ctx, base);
	// 82A65FF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65FFC: 807C05A8  lwz r3, 0x5a8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82A66000: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66004: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A66008: 419A0078  beq cr6, 0x82a66080
	if ctx.cr[6].eq {
	pc = 0x82A66080; continue 'dispatch;
	}
	// 82A6600C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66010: 419A0040  beq cr6, 0x82a66050
	if ctx.cr[6].eq {
	pc = 0x82A66050; continue 'dispatch;
	}
	// 82A66014: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A66018; continue 'dispatch;
            }
            0x82A66018 => {
    //   block [0x82A66018..0x82A6604C)
	// 82A66018: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A6601C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66020: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A66024: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A66028: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6602C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66030: 4082FFE8  bne 0x82a66018
	if !ctx.cr[0].eq {
	pc = 0x82A66018; continue 'dispatch;
	}
	// 82A66034: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A66038: 409A0014  bne cr6, 0x82a6604c
	if !ctx.cr[6].eq {
	pc = 0x82A6604C; continue 'dispatch;
	}
	// 82A6603C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66040: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A66044: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A66048: 4E800421  bctrl
	ctx.lr = 0x82A6604C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6604C => {
    //   block [0x82A6604C..0x82A66050)
	// 82A6604C: 935C05A8  stw r26, 0x5a8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1448 as u32), ctx.r[26].u32 ) };
	pc = 0x82A66050; continue 'dispatch;
            }
            0x82A66050 => {
    //   block [0x82A66050..0x82A66064)
	// 82A66050: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A66058: 917C05A8  stw r11, 0x5a8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1448 as u32), ctx.r[11].u32 ) };
	// 82A6605C: 419A0024  beq cr6, 0x82a66080
	if ctx.cr[6].eq {
	pc = 0x82A66080; continue 'dispatch;
	}
	// 82A66060: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A66064; continue 'dispatch;
            }
            0x82A66064 => {
    //   block [0x82A66064..0x82A66080)
	// 82A66064: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A66068: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6606C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A66070: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A66074: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A66078: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6607C: 4082FFE8  bne 0x82a66064
	if !ctx.cr[0].eq {
	pc = 0x82A66064; continue 'dispatch;
	}
	pc = 0x82A66080; continue 'dispatch;
            }
            0x82A66080 => {
    //   block [0x82A66080..0x82A66094)
	// 82A66080: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A66084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A66088: 419A0044  beq cr6, 0x82a660cc
	if ctx.cr[6].eq {
	pc = 0x82A660CC; continue 'dispatch;
	}
	// 82A6608C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A66090: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A66094; continue 'dispatch;
            }
            0x82A66094 => {
    //   block [0x82A66094..0x82A660CC)
	// 82A66094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A66098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6609C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A660A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A660A4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A660A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A660AC: 4082FFE8  bne 0x82a66094
	if !ctx.cr[0].eq {
	pc = 0x82A66094; continue 'dispatch;
	}
	// 82A660B0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A660B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A660B8: 409A0014  bne cr6, 0x82a660cc
	if !ctx.cr[6].eq {
	pc = 0x82A660CC; continue 'dispatch;
	}
	// 82A660BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A660C0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A660C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A660C8: 4E800421  bctrl
	ctx.lr = 0x82A660CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A660CC => {
    //   block [0x82A660CC..0x82A660EC)
	// 82A660CC: 576B04A4  rlwinm r11, r27, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82A660D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A660D4: 419A01C4  beq cr6, 0x82a66298
	if ctx.cr[6].eq {
	pc = 0x82A66298; continue 'dispatch;
	}
	// 82A660D8: 817E0204  lwz r11, 0x204(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(516 as u32) ) } as u64;
	// 82A660DC: 917D0204  stw r11, 0x204(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(516 as u32), ctx.r[11].u32 ) };
	// 82A660E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A660E4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A660E8: 48243368  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A660EC => {
    //   block [0x82A660EC..0x82A66108)
	// 82A660EC: 2F030019  cmpwi cr6, r3, 0x19
	ctx.cr[6].compare_i32(ctx.r[3].s32, 25, &mut ctx.xer);
	// 82A660F0: 409A00A4  bne cr6, 0x82a66194
	if !ctx.cr[6].eq {
	pc = 0x82A66194; continue 'dispatch;
	}
	// 82A660F4: 397C0270  addi r11, r28, 0x270
	ctx.r[11].s64 = ctx.r[28].s64 + 624;
	// 82A660F8: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82A660FC: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82A66100: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 82A66104: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A66108; continue 'dispatch;
            }
            0x82A66108 => {
    //   block [0x82A66108..0x82A6612C)
	// 82A66108: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A6610C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A66110: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A66114: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A66118: 4200FFF0  bdnz 0x82a66108
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A66108; continue 'dispatch;
	}
	// 82A6611C: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 82A66120: 392B0050  addi r9, r11, 0x50
	ctx.r[9].s64 = ctx.r[11].s64 + 80;
	// 82A66124: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 82A66128: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A6612C; continue 'dispatch;
            }
            0x82A6612C => {
    //   block [0x82A6612C..0x82A66150)
	// 82A6612C: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A66130: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A66134: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A66138: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A6613C: 4200FFF0  bdnz 0x82a6612c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A6612C; continue 'dispatch;
	}
	// 82A66140: 395F0090  addi r10, r31, 0x90
	ctx.r[10].s64 = ctx.r[31].s64 + 144;
	// 82A66144: 392B0090  addi r9, r11, 0x90
	ctx.r[9].s64 = ctx.r[11].s64 + 144;
	// 82A66148: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 82A6614C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A66150; continue 'dispatch;
            }
            0x82A66150 => {
    //   block [0x82A66150..0x82A66174)
	// 82A66150: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A66154: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A66158: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82A6615C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82A66160: 4200FFF0  bdnz 0x82a66150
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A66150; continue 'dispatch;
	}
	// 82A66164: 394B00D0  addi r10, r11, 0xd0
	ctx.r[10].s64 = ctx.r[11].s64 + 208;
	// 82A66168: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 82A6616C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A66170: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A66174; continue 'dispatch;
            }
            0x82A66174 => {
    //   block [0x82A66174..0x82A66194)
	// 82A66174: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A66178: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A6617C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A66180: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A66184: 4200FFF0  bdnz 0x82a66174
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A66174; continue 'dispatch;
	}
	// 82A66188: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6618C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A66190: 482432C0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A66194 => {
    //   block [0x82A66194..0x82A661C8)
	// 82A66194: 2F03001A  cmpwi cr6, r3, 0x1a
	ctx.cr[6].compare_i32(ctx.r[3].s32, 26, &mut ctx.xer);
	// 82A66198: 409A00F0  bne cr6, 0x82a66288
	if !ctx.cr[6].eq {
	pc = 0x82A66288; continue 'dispatch;
	}
	// 82A6619C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82A661A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A661A4: 4B7458F5  bl 0x821aba98
	ctx.lr = 0x82A661A8;
	sub_821ABA98(ctx, base);
	// 82A661A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A661AC: 807C05A4  lwz r3, 0x5a4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82A661B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A661B4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A661B8: 419A0078  beq cr6, 0x82a66230
	if ctx.cr[6].eq {
	pc = 0x82A66230; continue 'dispatch;
	}
	// 82A661BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A661C0: 419A0040  beq cr6, 0x82a66200
	if ctx.cr[6].eq {
	pc = 0x82A66200; continue 'dispatch;
	}
	// 82A661C4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A661C8; continue 'dispatch;
            }
            0x82A661C8 => {
    //   block [0x82A661C8..0x82A661FC)
	// 82A661C8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A661CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A661D0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A661D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A661D8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A661DC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A661E0: 4082FFE8  bne 0x82a661c8
	if !ctx.cr[0].eq {
	pc = 0x82A661C8; continue 'dispatch;
	}
	// 82A661E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A661E8: 409A0014  bne cr6, 0x82a661fc
	if !ctx.cr[6].eq {
	pc = 0x82A661FC; continue 'dispatch;
	}
	// 82A661EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A661F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A661F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A661F8: 4E800421  bctrl
	ctx.lr = 0x82A661FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A661FC => {
    //   block [0x82A661FC..0x82A66200)
	// 82A661FC: 935C05A4  stw r26, 0x5a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1444 as u32), ctx.r[26].u32 ) };
	pc = 0x82A66200; continue 'dispatch;
            }
            0x82A66200 => {
    //   block [0x82A66200..0x82A66214)
	// 82A66200: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A66208: 917C05A4  stw r11, 0x5a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(1444 as u32), ctx.r[11].u32 ) };
	// 82A6620C: 419A0024  beq cr6, 0x82a66230
	if ctx.cr[6].eq {
	pc = 0x82A66230; continue 'dispatch;
	}
	// 82A66210: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A66214; continue 'dispatch;
            }
            0x82A66214 => {
    //   block [0x82A66214..0x82A66230)
	// 82A66214: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A66218: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6621C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A66220: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A66224: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A66228: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6622C: 4082FFE8  bne 0x82a66214
	if !ctx.cr[0].eq {
	pc = 0x82A66214; continue 'dispatch;
	}
	pc = 0x82A66230; continue 'dispatch;
            }
            0x82A66230 => {
    //   block [0x82A66230..0x82A66244)
	// 82A66230: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A66234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A66238: 419A0060  beq cr6, 0x82a66298
	if ctx.cr[6].eq {
	pc = 0x82A66298; continue 'dispatch;
	}
	// 82A6623C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A66240: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A66244; continue 'dispatch;
            }
            0x82A66244 => {
    //   block [0x82A66244..0x82A66288)
	// 82A66244: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A66248: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6624C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A66250: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A66254: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A66258: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6625C: 4082FFE8  bne 0x82a66244
	if !ctx.cr[0].eq {
	pc = 0x82A66244; continue 'dispatch;
	}
	// 82A66260: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A66264: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A66268: 409A0030  bne cr6, 0x82a66298
	if !ctx.cr[6].eq {
	pc = 0x82A66298; continue 'dispatch;
	}
	// 82A6626C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66270: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A66274: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A66278: 4E800421  bctrl
	ctx.lr = 0x82A6627C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6627C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A66280: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A66284: 482431CC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A66288 => {
    //   block [0x82A66288..0x82A66298)
	// 82A66288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6628C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A66290: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A66294: 480132A5  bl 0x82a79538
	ctx.lr = 0x82A66298;
	sub_82A79538(ctx, base);
	pc = 0x82A66298; continue 'dispatch;
            }
            0x82A66298 => {
    //   block [0x82A66298..0x82A662A4)
	// 82A66298: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6629C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A662A0: 482431B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A662A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A662A8 size=112
    let mut pc: u32 = 0x82A662A8;
    'dispatch: loop {
        match pc {
            0x82A662A8 => {
    //   block [0x82A662A8..0x82A66300)
	// 82A662A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A662AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A662B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A662B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A662B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A662BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A662C0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A662C4: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82A662C8: 394B6DC0  addi r10, r11, 0x6dc0
	ctx.r[10].s64 = ctx.r[11].s64 + 28096;
	// 82A662CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A662D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A662D4: 4B760525  bl 0x821c67f8
	ctx.lr = 0x82A662D8;
	sub_821C67F8(ctx, base);
	// 82A662D8: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82A662DC: 4B7CB9DD  bl 0x82231cb8
	ctx.lr = 0x82A662E0;
	sub_82231CB8(ctx, base);
	// 82A662E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A662E4: 480131BD  bl 0x82a794a0
	ctx.lr = 0x82A662E8;
	sub_82A794A0(ctx, base);
	// 82A662E8: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A662EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A662F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A662F4: 419A000C  beq cr6, 0x82a66300
	if ctx.cr[6].eq {
	pc = 0x82A66300; continue 'dispatch;
	}
	// 82A662F8: 4B7B5A41  bl 0x8221bd38
	ctx.lr = 0x82A662FC;
	sub_8221BD38(ctx, base);
	// 82A662FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A66300; continue 'dispatch;
            }
            0x82A66300 => {
    //   block [0x82A66300..0x82A66318)
	// 82A66300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A66304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A66308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6630C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A66310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A66314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66318 size=176
    let mut pc: u32 = 0x82A66318;
    'dispatch: loop {
        match pc {
            0x82A66318 => {
    //   block [0x82A66318..0x82A6639C)
	// 82A66318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6631C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A66324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6632C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66330: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A66334: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A66338: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A6633C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A66340: 409A0070  bne cr6, 0x82a663b0
	if !ctx.cr[6].eq {
	pc = 0x82A663B0; continue 'dispatch;
	}
	// 82A66344: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A66348: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82A6634C: 806B6F1C  lwz r3, 0x6f1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28444 as u32) ) } as u64;
	// 82A66350: 48184E91  bl 0x82beb1e0
	ctx.lr = 0x82A66354;
	sub_82BEB1E0(ctx, base);
	// 82A66354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66358: 419A0044  beq cr6, 0x82a6639c
	if ctx.cr[6].eq {
	pc = 0x82A6639C; continue 'dispatch;
	}
	// 82A6635C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A66360: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A66364: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A66368: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A6636C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A66370: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66374: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A66378: 38E86E98  addi r7, r8, 0x6e98
	ctx.r[7].s64 = ctx.r[8].s64 + 28312;
	// 82A6637C: 81496F18  lwz r10, 0x6f18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28440 as u32) ) } as u64;
	// 82A66380: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A66384: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A66388: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82A6638C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A66390: 91696F18  stw r11, 0x6f18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28440 as u32), ctx.r[11].u32 ) };
	// 82A66394: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A66398: 48000008  b 0x82a663a0
	pc = 0x82A663A0; continue 'dispatch;
            }
            0x82A6639C => {
    //   block [0x82A6639C..0x82A663A0)
	// 82A6639C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82A663A0; continue 'dispatch;
            }
            0x82A663A0 => {
    //   block [0x82A663A0..0x82A663B0)
	// 82A663A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A663A4: C03F0048  lfs f1, 0x48(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A663A8: 386B00A8  addi r3, r11, 0xa8
	ctx.r[3].s64 = ctx.r[11].s64 + 168;
	// 82A663AC: 4B7C5F05  bl 0x8222c2b0
	ctx.lr = 0x82A663B0;
	sub_8222C2B0(ctx, base);
	pc = 0x82A663B0; continue 'dispatch;
            }
            0x82A663B0 => {
    //   block [0x82A663B0..0x82A663C8)
	// 82A663B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A663B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A663B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A663BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A663C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A663C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A663C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A663C8 size=2984
    let mut pc: u32 = 0x82A663C8;
    'dispatch: loop {
        match pc {
            0x82A663C8 => {
    //   block [0x82A663C8..0x82A66F70)
	// 82A663C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A663CC: 48243005  bl 0x82ca93d0
	ctx.lr = 0x82A663D0;
	sub_82CA93D0(ctx, base);
	// 82A663D0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82A663D4: 482478E5  bl 0x82cadcb8
	ctx.lr = 0x82A663D8;
	sub_82CADCA0(ctx, base);
	// 82A663D8: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 82A663DC: 9421EA10  stwu r1, -0x15f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-5616 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A663E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A663E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A663E8: 395D0060  addi r10, r29, 0x60
	ctx.r[10].s64 = ctx.r[29].s64 + 96;
	// 82A663EC: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 82A663F0: 3B8BB480  addi r28, r11, -0x4b80
	ctx.r[28].s64 = ctx.r[11].s64 + -19328;
	// 82A663F4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66F70 size=168
    let mut pc: u32 = 0x82A66F70;
    'dispatch: loop {
        match pc {
            0x82A66F70 => {
    //   block [0x82A66F70..0x82A67000)
	// 82A66F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A66F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66F88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A66F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66F90: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A66F94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A66F98: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 82A66F9C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A66FA0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66FA4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A66FA8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A66FAC: 4E800421  bctrl
	ctx.lr = 0x82A66FB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A66FB0: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 82A66FB4: 409A004C  bne cr6, 0x82a67000
	if !ctx.cr[6].eq {
	pc = 0x82A67000; continue 'dispatch;
	}
	// 82A66FB8: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A66FBC: 389E0014  addi r4, r30, 0x14
	ctx.r[4].s64 = ctx.r[30].s64 + 20;
	// 82A66FC0: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82A66FC4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A66FC8: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82A66FCC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82A66FD0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A66FD4: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A66FD8: E93E0020  ld r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 82A66FDC: F93F0060  std r9, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 82A66FE0: E91E0028  ld r8, 0x28(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 82A66FE4: F91F0068  std r8, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82A66FE8: 4B726FD1  bl 0x8218dfb8
	ctx.lr = 0x82A66FEC;
	sub_8218DFB8(ctx, base);
	// 82A66FEC: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 82A66FF0: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82A66FF4: 4B8518B5  bl 0x822b88a8
	ctx.lr = 0x82A66FF8;
	sub_822B88A8(ctx, base);
	// 82A66FF8: C1BE001C  lfs f13, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A66FFC: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            0x82A67000 => {
    //   block [0x82A67000..0x82A67018)
	// 82A67000: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6700C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67018 size=80
    let mut pc: u32 = 0x82A67018;
    'dispatch: loop {
        match pc {
            0x82A67018 => {
    //   block [0x82A67018..0x82A67050)
	// 82A67018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6701C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A67020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A67024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A67028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6702C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67030: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A67034: 48000035  bl 0x82a67068
	ctx.lr = 0x82A67038;
	sub_82A67068(ctx, base);
	// 82A67038: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A6703C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67044: 419A000C  beq cr6, 0x82a67050
	if ctx.cr[6].eq {
	pc = 0x82A67050; continue 'dispatch;
	}
	// 82A67048: 4B7B4CF1  bl 0x8221bd38
	ctx.lr = 0x82A6704C;
	sub_8221BD38(ctx, base);
	// 82A6704C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A67050; continue 'dispatch;
            }
            0x82A67050 => {
    //   block [0x82A67050..0x82A67068)
	// 82A67050: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6705C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67060: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67068 size=288
    let mut pc: u32 = 0x82A67068;
    'dispatch: loop {
        match pc {
            0x82A67068 => {
    //   block [0x82A67068..0x82A670A0)
	// 82A67068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6706C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A67070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A67074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A67078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6707C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67080: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A67084: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A67088: 394B6E08  addi r10, r11, 0x6e08
	ctx.r[10].s64 = ctx.r[11].s64 + 28168;
	// 82A6708C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A67090: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A67094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67098: 419A0040  beq cr6, 0x82a670d8
	if ctx.cr[6].eq {
	pc = 0x82A670D8; continue 'dispatch;
	}
	// 82A6709C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A670A0; continue 'dispatch;
            }
            0x82A670A0 => {
    //   block [0x82A670A0..0x82A670D4)
	// 82A670A0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A670A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A670A8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A670AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A670B0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A670B4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A670B8: 4082FFE8  bne 0x82a670a0
	if !ctx.cr[0].eq {
	pc = 0x82A670A0; continue 'dispatch;
	}
	// 82A670BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A670C0: 409A0014  bne cr6, 0x82a670d4
	if !ctx.cr[6].eq {
	pc = 0x82A670D4; continue 'dispatch;
	}
	// 82A670C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A670C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A670CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A670D0: 4E800421  bctrl
	ctx.lr = 0x82A670D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A670D4 => {
    //   block [0x82A670D4..0x82A670D8)
	// 82A670D4: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x82A670D8; continue 'dispatch;
            }
            0x82A670D8 => {
    //   block [0x82A670D8..0x82A670E8)
	// 82A670D8: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A670DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A670E0: 419A0040  beq cr6, 0x82a67120
	if ctx.cr[6].eq {
	pc = 0x82A67120; continue 'dispatch;
	}
	// 82A670E4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A670E8; continue 'dispatch;
            }
            0x82A670E8 => {
    //   block [0x82A670E8..0x82A6711C)
	// 82A670E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A670EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A670F0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A670F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A670F8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A670FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67100: 4082FFE8  bne 0x82a670e8
	if !ctx.cr[0].eq {
	pc = 0x82A670E8; continue 'dispatch;
	}
	// 82A67104: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67108: 409A0014  bne cr6, 0x82a6711c
	if !ctx.cr[6].eq {
	pc = 0x82A6711C; continue 'dispatch;
	}
	// 82A6710C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67110: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67114: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67118: 4E800421  bctrl
	ctx.lr = 0x82A6711C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6711C => {
    //   block [0x82A6711C..0x82A67120)
	// 82A6711C: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	pc = 0x82A67120; continue 'dispatch;
            }
            0x82A67120 => {
    //   block [0x82A67120..0x82A67130)
	// 82A67120: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A67124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67128: 419A0040  beq cr6, 0x82a67168
	if ctx.cr[6].eq {
	pc = 0x82A67168; continue 'dispatch;
	}
	// 82A6712C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A67130; continue 'dispatch;
            }
            0x82A67130 => {
    //   block [0x82A67130..0x82A67164)
	// 82A67130: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A67134: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67138: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A6713C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A67140: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67144: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67148: 4082FFE8  bne 0x82a67130
	if !ctx.cr[0].eq {
	pc = 0x82A67130; continue 'dispatch;
	}
	// 82A6714C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67150: 409A0014  bne cr6, 0x82a67164
	if !ctx.cr[6].eq {
	pc = 0x82A67164; continue 'dispatch;
	}
	// 82A67154: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67158: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6715C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67160: 4E800421  bctrl
	ctx.lr = 0x82A67164;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A67164 => {
    //   block [0x82A67164..0x82A67168)
	// 82A67164: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	pc = 0x82A67168; continue 'dispatch;
            }
            0x82A67168 => {
    //   block [0x82A67168..0x82A67188)
	// 82A67168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6716C: 48012335  bl 0x82a794a0
	ctx.lr = 0x82A67170;
	sub_82A794A0(ctx, base);
	// 82A67170: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6717C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67180: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67188 size=236
    let mut pc: u32 = 0x82A67188;
    'dispatch: loop {
        match pc {
            0x82A67188 => {
    //   block [0x82A67188..0x82A671B4)
	// 82A67188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6718C: 48242281  bl 0x82ca940c
	ctx.lr = 0x82A67190;
	sub_82CA93D0(ctx, base);
	// 82A67190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6719C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A671A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A671A4: 419A0010  beq cr6, 0x82a671b4
	if ctx.cr[6].eq {
	pc = 0x82A671B4; continue 'dispatch;
	}
	// 82A671A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A671AC: 4800041D  bl 0x82a675c8
	ctx.lr = 0x82A671B0;
	sub_82A675C8(ctx, base);
	// 82A671B0: 48000090  b 0x82a67240
	pc = 0x82A67240; continue 'dispatch;
            }
            0x82A671B4 => {
    //   block [0x82A671B4..0x82A67240)
	// 82A671B4: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A671B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A671BC: 419A0084  beq cr6, 0x82a67240
	if ctx.cr[6].eq {
	pc = 0x82A67240; continue 'dispatch;
	}
	// 82A671C0: 80FF0058  lwz r7, 0x58(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A671C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A671C8: 83CB0094  lwz r30, 0x94(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A671CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A671D0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82A671D4: 83AB0098  lwz r29, 0x98(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A671D8: 3927FFFF  addi r9, r7, -1
	ctx.r[9].s64 = ctx.r[7].s64 + -1;
	// 82A671DC: 3948FFFF  addi r10, r8, -1
	ctx.r[10].s64 = ctx.r[8].s64 + -1;
	// 82A671E0: 7D44FE70  srawi r4, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A671E4: 7D23FE70  srawi r3, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 82A671E8: 7C8A5038  and r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 & ctx.r[10].u64;
	// 82A671EC: 7C694838  and r9, r3, r9
	ctx.r[9].u64 = ctx.r[3].u64 & ctx.r[9].u64;
	// 82A671F0: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A671F4: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82A671F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A671FC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A67200: 7FDE43D6  divw r30, r30, r8
	ctx.r[30].s32 = ctx.r[30].s32 / ctx.r[8].s32;
	// 82A67204: 7FBD3BD6  divw r29, r29, r7
	ctx.r[29].s32 = ctx.r[29].s32 / ctx.r[7].s32;
	// 82A67208: 4B7B78E9  bl 0x8221eaf0
	ctx.lr = 0x82A6720C;
	sub_8221EAF0(ctx, base);
	// 82A6720C: 7CDEE850  subf r6, r30, r29
	ctx.r[6].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A67210: 813F004C  lwz r9, 0x4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A67214: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 82A67218: 7CAB3038  and r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 82A6721C: 81090054  lwz r8, 0x54(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A67220: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A67224: 60830001  ori r3, r4, 1
	ctx.r[3].u64 = ctx.r[4].u64 | 1;
	// 82A67228: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82A6722C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A67230: 214B001F  subfic r10, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[10].s64 = (31 as i64) - ctx.r[11].s64;
	// 82A67234: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A67238: 41990008  bgt cr6, 0x82a67240
	if ctx.cr[6].gt {
	pc = 0x82A67240; continue 'dispatch;
	}
	// 82A6723C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82A67240; continue 'dispatch;
            }
            0x82A67240 => {
    //   block [0x82A67240..0x82A67254)
	// 82A67240: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A67244: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67248: 419A0024  beq cr6, 0x82a6726c
	if ctx.cr[6].eq {
	pc = 0x82A6726C; continue 'dispatch;
	}
	// 82A6724C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A67250: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	pc = 0x82A67254; continue 'dispatch;
            }
            0x82A67254 => {
    //   block [0x82A67254..0x82A6726C)
	// 82A67254: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A67258: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6725C: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A67260: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67264: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67268: 4082FFEC  bne 0x82a67254
	if !ctx.cr[0].eq {
	pc = 0x82A67254; continue 'dispatch;
	}
	pc = 0x82A6726C; continue 'dispatch;
            }
            0x82A6726C => {
    //   block [0x82A6726C..0x82A67274)
	// 82A6726C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67270: 482421EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67278 size=848
    let mut pc: u32 = 0x82A67278;
    'dispatch: loop {
        match pc {
            0x82A67278 => {
    //   block [0x82A67278..0x82A672A0)
	// 82A67278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6727C: 4824218D  bl 0x82ca9408
	ctx.lr = 0x82A67280;
	sub_82CA93D0(ctx, base);
	// 82A67280: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67284: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67288: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A6728C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A67290: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A67294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67298: 419A0040  beq cr6, 0x82a672d8
	if ctx.cr[6].eq {
	pc = 0x82A672D8; continue 'dispatch;
	}
	// 82A6729C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A672A0; continue 'dispatch;
            }
            0x82A672A0 => {
    //   block [0x82A672A0..0x82A672D4)
	// 82A672A0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A672A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A672A8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A672AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A672B0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A672B4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A672B8: 4082FFE8  bne 0x82a672a0
	if !ctx.cr[0].eq {
	pc = 0x82A672A0; continue 'dispatch;
	}
	// 82A672BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A672C0: 409A0014  bne cr6, 0x82a672d4
	if !ctx.cr[6].eq {
	pc = 0x82A672D4; continue 'dispatch;
	}
	// 82A672C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A672C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A672CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A672D0: 4E800421  bctrl
	ctx.lr = 0x82A672D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A672D4 => {
    //   block [0x82A672D4..0x82A672D8)
	// 82A672D4: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	pc = 0x82A672D8; continue 'dispatch;
            }
            0x82A672D8 => {
    //   block [0x82A672D8..0x82A672EC)
	// 82A672D8: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 82A672DC: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A672E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A672E4: 419A0040  beq cr6, 0x82a67324
	if ctx.cr[6].eq {
	pc = 0x82A67324; continue 'dispatch;
	}
	// 82A672E8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A672EC; continue 'dispatch;
            }
            0x82A672EC => {
    //   block [0x82A672EC..0x82A67320)
	// 82A672EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A672F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A672F4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A672F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A672FC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67300: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67304: 4082FFE8  bne 0x82a672ec
	if !ctx.cr[0].eq {
	pc = 0x82A672EC; continue 'dispatch;
	}
	// 82A67308: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6730C: 409A0014  bne cr6, 0x82a67320
	if !ctx.cr[6].eq {
	pc = 0x82A67320; continue 'dispatch;
	}
	// 82A67310: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67314: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67318: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6731C: 4E800421  bctrl
	ctx.lr = 0x82A67320;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A67320 => {
    //   block [0x82A67320..0x82A67324)
	// 82A67320: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	pc = 0x82A67324; continue 'dispatch;
            }
            0x82A67324 => {
    //   block [0x82A67324..0x82A67384)
	// 82A67324: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 82A67328: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6732C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67330: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67334: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67338: 4E800421  bctrl
	ctx.lr = 0x82A6733C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6733C: 2F030034  cmpwi cr6, r3, 0x34
	ctx.cr[6].compare_i32(ctx.r[3].s32, 52, &mut ctx.xer);
	// 82A67340: 409A0280  bne cr6, 0x82a675c0
	if !ctx.cr[6].eq {
	pc = 0x82A675C0; continue 'dispatch;
	}
	// 82A67344: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A67348: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A6734C: 419800F4  blt cr6, 0x82a67440
	if ctx.cr[6].lt {
	pc = 0x82A67440; continue 'dispatch;
	}
	// 82A67350: 409A01D4  bne cr6, 0x82a67524
	if !ctx.cr[6].eq {
	pc = 0x82A67524; continue 'dispatch;
	}
	// 82A67354: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82A67358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6735C: 4B74473D  bl 0x821aba98
	ctx.lr = 0x82A67360;
	sub_821ABA98(ctx, base);
	// 82A67360: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A67364: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A67368: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6736C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A67370: 419A007C  beq cr6, 0x82a673ec
	if ctx.cr[6].eq {
	pc = 0x82A673EC; continue 'dispatch;
	}
	// 82A67374: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A67378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6737C: 419A0040  beq cr6, 0x82a673bc
	if ctx.cr[6].eq {
	pc = 0x82A673BC; continue 'dispatch;
	}
	// 82A67380: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
            }
            0x82A67384 => {
    //   block [0x82A67384..0x82A673B8)
	// 82A67384: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A67388: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6738C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A67390: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A67394: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67398: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6739C: 4082FFE8  bne 0x82a67384
	if !ctx.cr[0].eq {
	pc = 0x82A67384; continue 'dispatch;
	}
	// 82A673A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A673A4: 409A0014  bne cr6, 0x82a673b8
	if !ctx.cr[6].eq {
	pc = 0x82A673B8; continue 'dispatch;
	}
	// 82A673A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A673AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A673B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A673B4: 4E800421  bctrl
	ctx.lr = 0x82A673B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A673B8 => {
    //   block [0x82A673B8..0x82A673BC)
	// 82A673B8: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	pc = 0x82A673BC; continue 'dispatch;
            }
            0x82A673BC => {
    //   block [0x82A673BC..0x82A673D0)
	// 82A673BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A673C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A673C4: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82A673C8: 419A0024  beq cr6, 0x82a673ec
	if ctx.cr[6].eq {
	pc = 0x82A673EC; continue 'dispatch;
	}
	// 82A673CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A673D0; continue 'dispatch;
            }
            0x82A673D0 => {
    //   block [0x82A673D0..0x82A673EC)
	// 82A673D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A673D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A673D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A673DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A673E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A673E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A673E8: 4082FFE8  bne 0x82a673d0
	if !ctx.cr[0].eq {
	pc = 0x82A673D0; continue 'dispatch;
	}
	pc = 0x82A673EC; continue 'dispatch;
            }
            0x82A673EC => {
    //   block [0x82A673EC..0x82A67400)
	// 82A673EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A673F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A673F4: 419A0130  beq cr6, 0x82a67524
	if ctx.cr[6].eq {
	pc = 0x82A67524; continue 'dispatch;
	}
	// 82A673F8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A673FC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A67400; continue 'dispatch;
            }
            0x82A67400 => {
    //   block [0x82A67400..0x82A67438)
	// 82A67400: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67404: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67408: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6740C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A67410: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67414: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67418: 4082FFE8  bne 0x82a67400
	if !ctx.cr[0].eq {
	pc = 0x82A67400; continue 'dispatch;
	}
	// 82A6741C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A67420: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67424: 409A0014  bne cr6, 0x82a67438
	if !ctx.cr[6].eq {
	pc = 0x82A67438; continue 'dispatch;
	}
	// 82A67428: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6742C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67430: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67434: 4E800421  bctrl
	ctx.lr = 0x82A67438;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A67438 => {
    //   block [0x82A67438..0x82A67440)
	// 82A67438: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A6743C: 480000E8  b 0x82a67524
	pc = 0x82A67524; continue 'dispatch;
            }
            0x82A67440 => {
    //   block [0x82A67440..0x82A6746C)
	// 82A67440: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82A67444: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A67448: 4BFE9A49  bl 0x82a50e90
	ctx.lr = 0x82A6744C;
	sub_82A50E90(ctx, base);
	// 82A6744C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A67450: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A67454: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67458: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A6745C: 419A0078  beq cr6, 0x82a674d4
	if ctx.cr[6].eq {
	pc = 0x82A674D4; continue 'dispatch;
	}
	// 82A67460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67464: 419A0040  beq cr6, 0x82a674a4
	if ctx.cr[6].eq {
	pc = 0x82A674A4; continue 'dispatch;
	}
	// 82A67468: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A6746C; continue 'dispatch;
            }
            0x82A6746C => {
    //   block [0x82A6746C..0x82A674A0)
	// 82A6746C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A67470: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67474: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A67478: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A6747C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67480: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67484: 4082FFE8  bne 0x82a6746c
	if !ctx.cr[0].eq {
	pc = 0x82A6746C; continue 'dispatch;
	}
	// 82A67488: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6748C: 409A0014  bne cr6, 0x82a674a0
	if !ctx.cr[6].eq {
	pc = 0x82A674A0; continue 'dispatch;
	}
	// 82A67490: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67494: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67498: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6749C: 4E800421  bctrl
	ctx.lr = 0x82A674A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A674A0 => {
    //   block [0x82A674A0..0x82A674A4)
	// 82A674A0: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	pc = 0x82A674A4; continue 'dispatch;
            }
            0x82A674A4 => {
    //   block [0x82A674A4..0x82A674B8)
	// 82A674A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A674A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A674AC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82A674B0: 419A0024  beq cr6, 0x82a674d4
	if ctx.cr[6].eq {
	pc = 0x82A674D4; continue 'dispatch;
	}
	// 82A674B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A674B8; continue 'dispatch;
            }
            0x82A674B8 => {
    //   block [0x82A674B8..0x82A674D4)
	// 82A674B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A674BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A674C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A674C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A674C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A674CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A674D0: 4082FFE8  bne 0x82a674b8
	if !ctx.cr[0].eq {
	pc = 0x82A674B8; continue 'dispatch;
	}
	pc = 0x82A674D4; continue 'dispatch;
            }
            0x82A674D4 => {
    //   block [0x82A674D4..0x82A674E8)
	// 82A674D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A674D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A674DC: 419A0048  beq cr6, 0x82a67524
	if ctx.cr[6].eq {
	pc = 0x82A67524; continue 'dispatch;
	}
	// 82A674E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A674E4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A674E8; continue 'dispatch;
            }
            0x82A674E8 => {
    //   block [0x82A674E8..0x82A67520)
	// 82A674E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A674EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A674F0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A674F4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A674F8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A674FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67500: 4082FFE8  bne 0x82a674e8
	if !ctx.cr[0].eq {
	pc = 0x82A674E8; continue 'dispatch;
	}
	// 82A67504: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A67508: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6750C: 409A0014  bne cr6, 0x82a67520
	if !ctx.cr[6].eq {
	pc = 0x82A67520; continue 'dispatch;
	}
	// 82A67510: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67514: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67518: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6751C: 4E800421  bctrl
	ctx.lr = 0x82A67520;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A67520 => {
    //   block [0x82A67520..0x82A67524)
	// 82A67520: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82A67524; continue 'dispatch;
            }
            0x82A67524 => {
    //   block [0x82A67524..0x82A67558)
	// 82A67524: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A67528: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6752C: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A67530: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A67534: 813D001C  lwz r9, 0x1c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A67538: 913F005C  stw r9, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A6753C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A67540: 811D0010  lwz r8, 0x10(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A67544: 7F034000  cmpw cr6, r3, r8
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A67548: 419A0078  beq cr6, 0x82a675c0
	if ctx.cr[6].eq {
	pc = 0x82A675C0; continue 'dispatch;
	}
	// 82A6754C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67550: 419A0040  beq cr6, 0x82a67590
	if ctx.cr[6].eq {
	pc = 0x82A67590; continue 'dispatch;
	}
	// 82A67554: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A67558; continue 'dispatch;
            }
            0x82A67558 => {
    //   block [0x82A67558..0x82A6758C)
	// 82A67558: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A6755C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67560: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A67564: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A67568: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6756C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67570: 4082FFE8  bne 0x82a67558
	if !ctx.cr[0].eq {
	pc = 0x82A67558; continue 'dispatch;
	}
	// 82A67574: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67578: 409A0014  bne cr6, 0x82a6758c
	if !ctx.cr[6].eq {
	pc = 0x82A6758C; continue 'dispatch;
	}
	// 82A6757C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67580: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67584: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67588: 4E800421  bctrl
	ctx.lr = 0x82A6758C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6758C => {
    //   block [0x82A6758C..0x82A67590)
	// 82A6758C: 939F0050  stw r28, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A67590; continue 'dispatch;
            }
            0x82A67590 => {
    //   block [0x82A67590..0x82A675A4)
	// 82A67590: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A67594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67598: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6759C: 419A0024  beq cr6, 0x82a675c0
	if ctx.cr[6].eq {
	pc = 0x82A675C0; continue 'dispatch;
	}
	// 82A675A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A675A4; continue 'dispatch;
            }
            0x82A675A4 => {
    //   block [0x82A675A4..0x82A675C0)
	// 82A675A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A675A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A675AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A675B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A675B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A675B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A675BC: 4082FFE8  bne 0x82a675a4
	if !ctx.cr[0].eq {
	pc = 0x82A675A4; continue 'dispatch;
	}
	pc = 0x82A675C0; continue 'dispatch;
            }
            0x82A675C0 => {
    //   block [0x82A675C0..0x82A675C8)
	// 82A675C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A675C4: 48241E94  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A675C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A675C8 size=312
    let mut pc: u32 = 0x82A675C8;
    'dispatch: loop {
        match pc {
            0x82A675C8 => {
    //   block [0x82A675C8..0x82A675FC)
	// 82A675C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A675CC: 48241E19  bl 0x82ca93e4
	ctx.lr = 0x82A675D0;
	sub_82CA93D0(ctx, base);
	// 82A675D0: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A675D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A675D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A675DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A675E0: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A675E4: 4B7B5A05  bl 0x8221cfe8
	ctx.lr = 0x82A675E8;
	sub_8221CFE8(ctx, base);
	// 82A675E8: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82A675EC: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82A675F0: 409A000C  bne cr6, 0x82a675fc
	if !ctx.cr[6].eq {
	pc = 0x82A675FC; continue 'dispatch;
	}
	// 82A675F4: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82A675F8: 48241E3C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A675FC => {
    //   block [0x82A675FC..0x82A6761C)
	// 82A675FC: 82F50028  lwz r23, 0x28(r21)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A67600: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 82A67604: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A67608: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82A6760C: 409900E8  ble cr6, 0x82a676f4
	if !ctx.cr[6].gt {
	pc = 0x82A676F4; continue 'dispatch;
	}
	// 82A67610: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A67614: 3A8000B4  li r20, 0xb4
	ctx.r[20].s64 = 180;
	// 82A67618: 3E60834A  lis r19, -0x7cb6
	ctx.r[19].s64 = -2092302336;
	pc = 0x82A6761C; continue 'dispatch;
            }
            0x82A6761C => {
    //   block [0x82A6761C..0x82A67630)
	// 82A6761C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82A67620: 41980010  blt cr6, 0x82a67630
	if ctx.cr[6].lt {
	pc = 0x82A67630; continue 'dispatch;
	}
	// 82A67624: 81750058  lwz r11, 0x58(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A67628: 7F8BC02E  lwzx r28, r11, r24
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 82A6762C: 48000008  b 0x82a67634
	pc = 0x82A67634; continue 'dispatch;
            }
            0x82A67630 => {
    //   block [0x82A67630..0x82A67634)
	// 82A67630: 83935760  lwz r28, 0x5760(r19)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x82A67634; continue 'dispatch;
            }
            0x82A67634 => {
    //   block [0x82A67634..0x82A67650)
	// 82A67634: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A67638: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6763C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A67640: 7D69A3D7  divw. r11, r9, r20
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[20].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67644: 408100A0  ble 0x82a676e4
	if !ctx.cr[0].gt {
	pc = 0x82A676E4; continue 'dispatch;
	}
	// 82A67648: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6764C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x82A67650; continue 'dispatch;
            }
            0x82A67650 => {
    //   block [0x82A67650..0x82A6768C)
	// 82A67650: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A67654: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A67658: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A6765C: 480370ED  bl 0x82a9e748
	ctx.lr = 0x82A67660;
	sub_82A9E748(ctx, base);
	// 82A67660: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67664: 83FB005C  lwz r31, 0x5c(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A67668: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82A6766C: 419A0020  beq cr6, 0x82a6768c
	if ctx.cr[6].eq {
	pc = 0x82A6768C; continue 'dispatch;
	}
	// 82A67670: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A67674: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A67678: 48038249  bl 0x82a9f8c0
	ctx.lr = 0x82A6767C;
	sub_82A9F8C0(ctx, base);
	// 82A6767C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A67680: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A67684: 480380F5  bl 0x82a9f778
	ctx.lr = 0x82A67688;
	sub_82A9F778(ctx, base);
	// 82A67688: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82A6768C; continue 'dispatch;
            }
            0x82A6768C => {
    //   block [0x82A6768C..0x82A676A0)
	// 82A6768C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A67690: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A67694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67698: 409A0008  bne cr6, 0x82a676a0
	if !ctx.cr[6].eq {
	pc = 0x82A676A0; continue 'dispatch;
	}
	// 82A6769C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82A676A0; continue 'dispatch;
            }
            0x82A676A0 => {
    //   block [0x82A676A0..0x82A676D0)
	// 82A676A0: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A676A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A676A8: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A676AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A676B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A676B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A676B8: 80AA00B0  lwz r5, 0xb0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A676BC: 480385DD  bl 0x82a9fc98
	ctx.lr = 0x82A676C0;
	sub_82A9FC98(ctx, base);
	// 82A676C0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A676C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A676C8: 409A0008  bne cr6, 0x82a676d0
	if !ctx.cr[6].eq {
	pc = 0x82A676D0; continue 'dispatch;
	}
	// 82A676CC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	pc = 0x82A676D0; continue 'dispatch;
            }
            0x82A676D0 => {
    //   block [0x82A676D0..0x82A676E4)
	// 82A676D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A676D4: 4800002D  bl 0x82a67700
	ctx.lr = 0x82A676D8;
	sub_82A67700(ctx, base);
	// 82A676D8: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82A676DC: 3BBD00B4  addi r29, r29, 0xb4
	ctx.r[29].s64 = ctx.r[29].s64 + 180;
	// 82A676E0: 4082FF70  bne 0x82a67650
	if !ctx.cr[0].eq {
	pc = 0x82A67650; continue 'dispatch;
	}
	pc = 0x82A676E4; continue 'dispatch;
            }
            0x82A676E4 => {
    //   block [0x82A676E4..0x82A676F4)
	// 82A676E4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82A676E8: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 82A676EC: 7F19B800  cmpw cr6, r25, r23
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82A676F0: 4198FF2C  blt cr6, 0x82a6761c
	if ctx.cr[6].lt {
	pc = 0x82A6761C; continue 'dispatch;
	}
	pc = 0x82A676F4; continue 'dispatch;
            }
            0x82A676F4 => {
    //   block [0x82A676F4..0x82A67700)
	// 82A676F4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A676F8: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82A676FC: 48241D38  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67700 size=192
    let mut pc: u32 = 0x82A67700;
    'dispatch: loop {
        match pc {
            0x82A67700 => {
    //   block [0x82A67700..0x82A67724)
	// 82A67700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67704: 48241D09  bl 0x82ca940c
	ctx.lr = 0x82A67708;
	sub_82CA93D0(ctx, base);
	// 82A67708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6770C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67710: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A67714: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A67718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6771C: 419A0040  beq cr6, 0x82a6775c
	if ctx.cr[6].eq {
	pc = 0x82A6775C; continue 'dispatch;
	}
	// 82A67720: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A67724; continue 'dispatch;
            }
            0x82A67724 => {
    //   block [0x82A67724..0x82A67758)
	// 82A67724: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A67728: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6772C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A67730: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A67734: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67738: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6773C: 4082FFE8  bne 0x82a67724
	if !ctx.cr[0].eq {
	pc = 0x82A67724; continue 'dispatch;
	}
	// 82A67740: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67744: 409A0014  bne cr6, 0x82a67758
	if !ctx.cr[6].eq {
	pc = 0x82A67758; continue 'dispatch;
	}
	// 82A67748: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6774C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67750: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67754: 4E800421  bctrl
	ctx.lr = 0x82A67758;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A67758 => {
    //   block [0x82A67758..0x82A6775C)
	// 82A67758: 93BF0094  stw r29, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	pc = 0x82A6775C; continue 'dispatch;
            }
            0x82A6775C => {
    //   block [0x82A6775C..0x82A67764)
	// 82A6775C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82A67760: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	pc = 0x82A67764; continue 'dispatch;
            }
            0x82A67764 => {
    //   block [0x82A67764..0x82A67778)
	// 82A67764: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A67768: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6776C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67770: 419A0040  beq cr6, 0x82a677b0
	if ctx.cr[6].eq {
	pc = 0x82A677B0; continue 'dispatch;
	}
	// 82A67774: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A67778; continue 'dispatch;
            }
            0x82A67778 => {
    //   block [0x82A67778..0x82A677AC)
	// 82A67778: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A6777C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67780: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A67784: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A67788: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6778C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67790: 4082FFE8  bne 0x82a67778
	if !ctx.cr[0].eq {
	pc = 0x82A67778; continue 'dispatch;
	}
	// 82A67794: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67798: 409A0014  bne cr6, 0x82a677ac
	if !ctx.cr[6].eq {
	pc = 0x82A677AC; continue 'dispatch;
	}
	// 82A6779C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A677A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A677A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A677A8: 4E800421  bctrl
	ctx.lr = 0x82A677AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A677AC => {
    //   block [0x82A677AC..0x82A677B0)
	// 82A677AC: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82A677B0; continue 'dispatch;
            }
            0x82A677B0 => {
    //   block [0x82A677B0..0x82A677C0)
	// 82A677B0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A677B4: 4080FFB0  bge 0x82a67764
	if !ctx.cr[0].lt {
	pc = 0x82A67764; continue 'dispatch;
	}
	// 82A677B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A677BC: 48241CA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A677C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A677C0 size=80
    let mut pc: u32 = 0x82A677C0;
    'dispatch: loop {
        match pc {
            0x82A677C0 => {
    //   block [0x82A677C0..0x82A677F8)
	// 82A677C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A677C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A677C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A677CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A677D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A677D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A677D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A677DC: 48000035  bl 0x82a67810
	ctx.lr = 0x82A677E0;
	sub_82A67810(ctx, base);
	// 82A677E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A677E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A677E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A677EC: 419A000C  beq cr6, 0x82a677f8
	if ctx.cr[6].eq {
	pc = 0x82A677F8; continue 'dispatch;
	}
	// 82A677F0: 4B7B4549  bl 0x8221bd38
	ctx.lr = 0x82A677F4;
	sub_8221BD38(ctx, base);
	// 82A677F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A677F8; continue 'dispatch;
            }
            0x82A677F8 => {
    //   block [0x82A677F8..0x82A67810)
	// 82A677F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A677FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6780C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67810 size=136
    let mut pc: u32 = 0x82A67810;
    'dispatch: loop {
        match pc {
            0x82A67810 => {
    //   block [0x82A67810..0x82A67840)
	// 82A67810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A67818: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6781C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67820: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67824: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A67828: 394B6E50  addi r10, r11, 0x6e50
	ctx.r[10].s64 = ctx.r[11].s64 + 28240;
	// 82A6782C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A67830: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A67834: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67838: 419A0044  beq cr6, 0x82a6787c
	if ctx.cr[6].eq {
	pc = 0x82A6787C; continue 'dispatch;
	}
	// 82A6783C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A67840; continue 'dispatch;
            }
            0x82A67840 => {
    //   block [0x82A67840..0x82A67874)
	// 82A67840: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A67844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67848: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A6784C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A67850: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67854: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67858: 4082FFE8  bne 0x82a67840
	if !ctx.cr[0].eq {
	pc = 0x82A67840; continue 'dispatch;
	}
	// 82A6785C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67860: 409A0014  bne cr6, 0x82a67874
	if !ctx.cr[6].eq {
	pc = 0x82A67874; continue 'dispatch;
	}
	// 82A67864: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67868: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6786C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A67870: 4E800421  bctrl
	ctx.lr = 0x82A67874;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A67874 => {
    //   block [0x82A67874..0x82A6787C)
	// 82A67874: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67878: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x82A6787C; continue 'dispatch;
            }
            0x82A6787C => {
    //   block [0x82A6787C..0x82A67898)
	// 82A6787C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67880: 48011C21  bl 0x82a794a0
	ctx.lr = 0x82A67884;
	sub_82A794A0(ctx, base);
	// 82A67884: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A67888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6788C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A67898 size=296
    let mut pc: u32 = 0x82A67898;
    'dispatch: loop {
        match pc {
            0x82A67898 => {
    //   block [0x82A67898..0x82A679C0)
	// 82A67898: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A6789C: C0030070  lfs f0, 0x70(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A678A0: 81430064  lwz r10, 0x64(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A678A4: C1A30084  lfs f13, 0x84(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A678A8: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 82A678AC: 81230078  lwz r9, 0x78(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A678B0: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 82A678B4: 80E30068  lwz r7, 0x68(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A678B8: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82A678BC: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A678C0: 7D2407B4  extsw r4, r9
	ctx.r[4].s64 = ctx.r[9].s32 as i64;
	// 82A678C4: 80A3007C  lwz r5, 0x7c(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A678C8: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82A678CC: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A678D0: 7CEA07B4  extsw r10, r7
	ctx.r[10].s64 = ctx.r[7].s32 as i64;
	// 82A678D4: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A678D8: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82A678DC: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A678E0: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 82A678E4: 81230080  lwz r9, 0x80(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A678E8: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82A678EC: C921FFF0  lfd f9, -0x10(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A678F0: 7D6507B4  extsw r5, r11
	ctx.r[5].s64 = ctx.r[11].s32 as i64;
	// 82A678F4: 81430060  lwz r10, 0x60(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A678F8: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82A678FC: C901FFF0  lfd f8, -0x10(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67900: 7D2B07B4  extsw r11, r9
	ctx.r[11].s64 = ctx.r[9].s32 as i64;
	// 82A67904: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 82A67908: C8E1FFF0  lfd f7, -0x10(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6790C: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82A67910: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82A67914: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67918: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82A6791C: C881FFF0  lfd f4, -0x10(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67920: ECAD0028  fsubs f5, f13, f0
	ctx.f[5].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A67924: 39200088  li r9, 0x88
	ctx.r[9].s64 = 136;
	// 82A67928: FC40669C  fcfid f2, f12
	ctx.f[2].f64 = (ctx.f[12].s64 as f64);
	// 82A6792C: 38E0008C  li r7, 0x8c
	ctx.r[7].s64 = 140;
	// 82A67930: 38C00090  li r6, 0x90
	ctx.r[6].s64 = 144;
	// 82A67934: FDA05E9C  fcfid f13, f11
	ctx.f[13].f64 = (ctx.f[11].s64 as f64);
	// 82A67938: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 82A6793C: FD80569C  fcfid f12, f10
	ctx.f[12].f64 = (ctx.f[10].s64 as f64);
	// 82A67940: FD604E9C  fcfid f11, f9
	ctx.f[11].f64 = (ctx.f[9].s64 as f64);
	// 82A67944: FD40469C  fcfid f10, f8
	ctx.f[10].f64 = (ctx.f[8].s64 as f64);
	// 82A67948: FD203E9C  fcfid f9, f7
	ctx.f[9].f64 = (ctx.f[7].s64 as f64);
	// 82A6794C: FD00369C  fcfid f8, f6
	ctx.f[8].f64 = (ctx.f[6].s64 as f64);
	// 82A67950: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 82A67954: ECC5007A  fmadds f6, f5, f1, f0
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A67958: D0C30098  stfs f6, 0x98(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A6795C: FCA01018  frsp f5, f2
	ctx.f[5].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82A67960: FC806818  frsp f4, f13
	ctx.f[4].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A67964: FC405818  frsp f2, f11
	ctx.f[2].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82A67968: FC005018  frsp f0, f10
	ctx.f[0].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82A6796C: FDA04818  frsp f13, f9
	ctx.f[13].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82A67970: FCE01818  frsp f7, f3
	ctx.f[7].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82A67974: FC606018  frsp f3, f12
	ctx.f[3].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A67978: FD804018  frsp f12, f8
	ctx.f[12].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A6797C: ED201028  fsubs f9, f0, f2
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 82A67980: ED653828  fsubs f11, f5, f7
	ctx.f[11].f64 = (((ctx.f[5].f64 - ctx.f[7].f64) as f32) as f64);
	// 82A67984: ED432028  fsubs f10, f3, f4
	ctx.f[10].f64 = (((ctx.f[3].f64 - ctx.f[4].f64) as f32) as f64);
	// 82A67988: ED0C6828  fsubs f8, f12, f13
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A6798C: ECA9107A  fmadds f5, f9, f1, f2
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64);
	// 82A67990: ECEB387A  fmadds f7, f11, f1, f7
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[1].f64 + ctx.f[7].f64) as f32) as f64);
	// 82A67994: ECCA207A  fmadds f6, f10, f1, f4
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 + ctx.f[4].f64) as f32) as f64);
	// 82A67998: EC88687A  fmadds f4, f8, f1, f13
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 82A6799C: FC20281E  fctiwz f1, f5
	ctx.f[1].s64 = if ctx.f[5].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[5].f64.trunc() as i32 as i64 };
	// 82A679A0: FC60381E  fctiwz f3, f7
	ctx.f[3].s64 = if ctx.f[7].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[7].f64.trunc() as i32 as i64 };
	// 82A679A4: 7C634FAE  stfiwx f3, r3, r9
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82A679A8: FC40301E  fctiwz f2, f6
	ctx.f[2].s64 = if ctx.f[6].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[6].f64.trunc() as i32 as i64 };
	// 82A679AC: 7C433FAE  stfiwx f2, r3, r7
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82A679B0: 7C2337AE  stfiwx f1, r3, r6
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82A679B4: FC00201E  fctiwz f0, f4
	ctx.f[0].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 82A679B8: 7C032FAE  stfiwx f0, r3, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82A679BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A679C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A679C0 size=180
    let mut pc: u32 = 0x82A679C0;
    'dispatch: loop {
        match pc {
            0x82A679C0 => {
    //   block [0x82A679C0..0x82A67A34)
	// 82A679C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A679C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A679C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A679CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A679D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A679D4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A679D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A679DC: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82A679E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A679E4: 806B6F1C  lwz r3, 0x6f1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28444 as u32) ) } as u64;
	// 82A679E8: 481837F9  bl 0x82beb1e0
	ctx.lr = 0x82A679EC;
	sub_82BEB1E0(ctx, base);
	// 82A679EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A679F0: 419A0044  beq cr6, 0x82a67a34
	if ctx.cr[6].eq {
	pc = 0x82A67A34; continue 'dispatch;
	}
	// 82A679F4: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A679F8: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A679FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67A00: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A67A04: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A67A08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A67A0C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A67A10: 38E86E98  addi r7, r8, 0x6e98
	ctx.r[7].s64 = ctx.r[8].s64 + 28312;
	// 82A67A14: 81496F18  lwz r10, 0x6f18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28440 as u32) ) } as u64;
	// 82A67A18: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A67A1C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A67A20: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82A67A24: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A67A28: 91696F18  stw r11, 0x6f18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28440 as u32), ctx.r[11].u32 ) };
	// 82A67A2C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82A67A30: 48000008  b 0x82a67a38
	pc = 0x82A67A38; continue 'dispatch;
            }
            0x82A67A34 => {
    //   block [0x82A67A34..0x82A67A38)
	// 82A67A34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82A67A38; continue 'dispatch;
            }
            0x82A67A38 => {
    //   block [0x82A67A38..0x82A67A74)
	// 82A67A38: 815F00A0  lwz r10, 0xa0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82A67A3C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67A40: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 82A67A44: 386B0150  addi r3, r11, 0x150
	ctx.r[3].s64 = ctx.r[11].s64 + 336;
	// 82A67A48: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A67A4C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A67A50: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A67A54: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A67A58: 4B7C4859  bl 0x8222c2b0
	ctx.lr = 0x82A67A5C;
	sub_8222C2B0(ctx, base);
	// 82A67A5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67A60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67A64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67A68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67A6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67A70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A67A78 size=2872
    let mut pc: u32 = 0x82A67A78;
    'dispatch: loop {
        match pc {
            0x82A67A78 => {
    //   block [0x82A67A78..0x82A685B0)
	// 82A67A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67A7C: 48241979  bl 0x82ca93f4
	ctx.lr = 0x82A67A80;
	sub_82CA93D0(ctx, base);
	// 82A67A80: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82A67A84: 48246255  bl 0x82cadcd8
	ctx.lr = 0x82A67A88;
	sub_82CADCA0(ctx, base);
	// 82A67A88: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A685B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A685B0 size=60
    let mut pc: u32 = 0x82A685B0;
    'dispatch: loop {
        match pc {
            0x82A685B0 => {
    //   block [0x82A685B0..0x82A685EC)
	// 82A685B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A685B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A685B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A685BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A685C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A685C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A685C8: 388B1780  addi r4, r11, 0x1780
	ctx.r[4].s64 = ctx.r[11].s64 + 6016;
	// 82A685CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A685D0: 4B7C4901  bl 0x8222ced0
	ctx.lr = 0x82A685D4;
	sub_8222CED0(ctx, base);
	// 82A685D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A685D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A685DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A685E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A685E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A685E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A685F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A685F0 size=772
    let mut pc: u32 = 0x82A685F0;
    'dispatch: loop {
        match pc {
            0x82A685F0 => {
    //   block [0x82A685F0..0x82A68648)
	// 82A685F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A685F4: 48240E11  bl 0x82ca9404
	ctx.lr = 0x82A685F8;
	sub_82CA93D0(ctx, base);
	// 82A685F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A685FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68600: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A68604: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A68608: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A6860C: 397F0048  addi r11, r31, 0x48
	ctx.r[11].s64 = ctx.r[31].s64 + 72;
	// 82A68610: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A68614: 3B8A9484  addi r28, r10, -0x6b7c
	ctx.r[28].s64 = ctx.r[10].s64 + -27516;
	// 82A68618: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6861C: 5128083C  rlwimi r8, r9, 1, 0, 0x1e
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[8].u64 & 0xFFFFFFFF00000001);
	// 82A68620: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A68624: C81F0050  lfd f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	// 82A68628: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A6862C: 4099001C  ble cr6, 0x82a68648
	if !ctx.cr[6].gt {
	pc = 0x82A68648; continue 'dispatch;
	}
	// 82A68630: C1BC4144  lfs f13, 0x4144(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A68634: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A68638: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 82A6863C: D82B0008  stfd f1, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[1].u64 ) };
	// 82A68640: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A68644: 48000008  b 0x82a6864c
	pc = 0x82A6864C; continue 'dispatch;
            }
            0x82A68648 => {
    //   block [0x82A68648..0x82A6864C)
	// 82A68648: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x82A6864C; continue 'dispatch;
            }
            0x82A6864C => {
    //   block [0x82A6864C..0x82A68668)
	// 82A6864C: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A68650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68654: 419A0028  beq cr6, 0x82a6867c
	if ctx.cr[6].eq {
	pc = 0x82A6867C; continue 'dispatch;
	}
	// 82A68658: 397F0074  addi r11, r31, 0x74
	ctx.r[11].s64 = ctx.r[31].s64 + 116;
	// 82A6865C: 395F0060  addi r10, r31, 0x60
	ctx.r[10].s64 = ctx.r[31].s64 + 96;
	// 82A68660: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A68664: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A68668; continue 'dispatch;
            }
            0x82A68668 => {
    //   block [0x82A68668..0x82A6867C)
	// 82A68668: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6866C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68670: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A68674: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A68678: 4200FFF0  bdnz 0x82a68668
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A68668; continue 'dispatch;
	}
	pc = 0x82A6867C; continue 'dispatch;
            }
            0x82A6867C => {
    //   block [0x82A6867C..0x82A686A0)
	// 82A6867C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68684: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68688: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6868C: 4E800421  bctrl
	ctx.lr = 0x82A68690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A68690: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 82A68694: 419A000C  beq cr6, 0x82a686a0
	if ctx.cr[6].eq {
	pc = 0x82A686A0; continue 'dispatch;
	}
	// 82A68698: 2F03000F  cmpwi cr6, r3, 0xf
	ctx.cr[6].compare_i32(ctx.r[3].s32, 15, &mut ctx.xer);
	// 82A6869C: 409A0250  bne cr6, 0x82a688ec
	if !ctx.cr[6].eq {
	pc = 0x82A688EC; continue 'dispatch;
	}
            }
            0x82A686A0 => {
    //   block [0x82A686A0..0x82A68720)
	// 82A686A0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A686A4: 395F00B0  addi r10, r31, 0xb0
	ctx.r[10].s64 = ctx.r[31].s64 + 176;
	// 82A686A8: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82A686AC: 917F00A0  stw r11, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82A686B0: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A686B4: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82A686B8: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A686BC: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 82A686C0: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A686C4: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 82A686C8: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A686CC: 90DF0080  stw r6, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 82A686D0: C01E001C  lfs f0, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A686D4: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A686D8: E8BE0030  ld r5, 0x30(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 82A686DC: F8BF00B0  std r5, 0xb0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A686E0: E87E0038  ld r3, 0x38(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 82A686E4: F87F00B8  std r3, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[3].u64 ) };
	// 82A686E8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A686EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A686F0: 409900EC  ble cr6, 0x82a687dc
	if !ctx.cr[6].gt {
	pc = 0x82A687DC; continue 'dispatch;
	}
	// 82A686F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A686F8: 4B7433A1  bl 0x821aba98
	ctx.lr = 0x82A686FC;
	sub_821ABA98(ctx, base);
	// 82A686FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A68700: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A68704: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68708: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A6870C: 419A007C  beq cr6, 0x82a68788
	if ctx.cr[6].eq {
	pc = 0x82A68788; continue 'dispatch;
	}
	// 82A68710: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A68714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68718: 419A0040  beq cr6, 0x82a68758
	if ctx.cr[6].eq {
	pc = 0x82A68758; continue 'dispatch;
	}
	// 82A6871C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A68720; continue 'dispatch;
            }
            0x82A68720 => {
    //   block [0x82A68720..0x82A68754)
	// 82A68720: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A68724: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68728: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A6872C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A68730: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68734: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68738: 4082FFE8  bne 0x82a68720
	if !ctx.cr[0].eq {
	pc = 0x82A68720; continue 'dispatch;
	}
	// 82A6873C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A68740: 409A0014  bne cr6, 0x82a68754
	if !ctx.cr[6].eq {
	pc = 0x82A68754; continue 'dispatch;
	}
	// 82A68744: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68748: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6874C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A68750: 4E800421  bctrl
	ctx.lr = 0x82A68754;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A68754 => {
    //   block [0x82A68754..0x82A68758)
	// 82A68754: 937F009C  stw r27, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[27].u32 ) };
	pc = 0x82A68758; continue 'dispatch;
            }
            0x82A68758 => {
    //   block [0x82A68758..0x82A6876C)
	// 82A68758: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6875C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68760: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82A68764: 419A0024  beq cr6, 0x82a68788
	if ctx.cr[6].eq {
	pc = 0x82A68788; continue 'dispatch;
	}
	// 82A68768: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A6876C; continue 'dispatch;
            }
            0x82A6876C => {
    //   block [0x82A6876C..0x82A68788)
	// 82A6876C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68770: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68774: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68778: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6877C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68780: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68784: 4082FFE8  bne 0x82a6876c
	if !ctx.cr[0].eq {
	pc = 0x82A6876C; continue 'dispatch;
	}
	pc = 0x82A68788; continue 'dispatch;
            }
            0x82A68788 => {
    //   block [0x82A68788..0x82A6879C)
	// 82A68788: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6878C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68790: 419A0098  beq cr6, 0x82a68828
	if ctx.cr[6].eq {
	pc = 0x82A68828; continue 'dispatch;
	}
	// 82A68794: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A68798: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A6879C; continue 'dispatch;
            }
            0x82A6879C => {
    //   block [0x82A6879C..0x82A687D4)
	// 82A6879C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A687A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A687A4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A687A8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A687AC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A687B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A687B4: 4082FFE8  bne 0x82a6879c
	if !ctx.cr[0].eq {
	pc = 0x82A6879C; continue 'dispatch;
	}
	// 82A687B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A687BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A687C0: 409A0014  bne cr6, 0x82a687d4
	if !ctx.cr[6].eq {
	pc = 0x82A687D4; continue 'dispatch;
	}
	// 82A687C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A687C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A687CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A687D0: 4E800421  bctrl
	ctx.lr = 0x82A687D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A687D4 => {
    //   block [0x82A687D4..0x82A687DC)
	// 82A687D4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A687D8: 48000050  b 0x82a68828
	pc = 0x82A68828; continue 'dispatch;
            }
            0x82A687DC => {
    //   block [0x82A687DC..0x82A687EC)
	// 82A687DC: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A687E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A687E4: 419A0040  beq cr6, 0x82a68824
	if ctx.cr[6].eq {
	pc = 0x82A68824; continue 'dispatch;
	}
	// 82A687E8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A687EC; continue 'dispatch;
            }
            0x82A687EC => {
    //   block [0x82A687EC..0x82A68820)
	// 82A687EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A687F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A687F4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A687F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A687FC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68800: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68804: 4082FFE8  bne 0x82a687ec
	if !ctx.cr[0].eq {
	pc = 0x82A687EC; continue 'dispatch;
	}
	// 82A68808: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6880C: 409A0014  bne cr6, 0x82a68820
	if !ctx.cr[6].eq {
	pc = 0x82A68820; continue 'dispatch;
	}
	// 82A68810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68814: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68818: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6881C: 4E800421  bctrl
	ctx.lr = 0x82A68820;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A68820 => {
    //   block [0x82A68820..0x82A68824)
	// 82A68820: 937F009C  stw r27, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[27].u32 ) };
	pc = 0x82A68824; continue 'dispatch;
            }
            0x82A68824 => {
    //   block [0x82A68824..0x82A68828)
	// 82A68824: 937F009C  stw r27, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[27].u32 ) };
	pc = 0x82A68828; continue 'dispatch;
            }
            0x82A68828 => {
    //   block [0x82A68828..0x82A6888C)
	// 82A68828: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6882C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68830: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68834: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A68838: 4E800421  bctrl
	ctx.lr = 0x82A6883C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6883C: 2F03000F  cmpwi cr6, r3, 0xf
	ctx.cr[6].compare_i32(ctx.r[3].s32, 15, &mut ctx.xer);
	// 82A68840: 409A004C  bne cr6, 0x82a6888c
	if !ctx.cr[6].eq {
	pc = 0x82A6888C; continue 'dispatch;
	}
	// 82A68844: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A68848: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82A6884C: 815E0044  lwz r10, 0x44(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A68850: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 82A68854: 813E0050  lwz r9, 0x50(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A68858: 913F00C8  stw r9, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 82A6885C: 811E0054  lwz r8, 0x54(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A68860: 911F00CC  stw r8, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[8].u32 ) };
	// 82A68864: 80FE0058  lwz r7, 0x58(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A68868: 90FF00D0  stw r7, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[7].u32 ) };
	// 82A6886C: 80DE005C  lwz r6, 0x5c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A68870: 90DF00D4  stw r6, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[6].u32 ) };
	// 82A68874: 80BE0048  lwz r5, 0x48(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A68878: 90BF00D8  stw r5, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[5].u32 ) };
	// 82A6887C: 809E004C  lwz r4, 0x4c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A68880: 909F00DC  stw r4, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[4].u32 ) };
	// 82A68884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A68888: 48240BCC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A6888C => {
    //   block [0x82A6888C..0x82A688B0)
	// 82A6888C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A68890: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A68894: C19C000C  lfs f12, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A68898: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6889C: 556A03DE  rlwinm r10, r11, 0, 0xf, 0xf
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A688A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A688A4: 419A000C  beq cr6, 0x82a688b0
	if ctx.cr[6].eq {
	pc = 0x82A688B0; continue 'dispatch;
	}
	// 82A688A8: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 82A688AC: 48000008  b 0x82a688b4
	pc = 0x82A688B4; continue 'dispatch;
            }
            0x82A688B0 => {
    //   block [0x82A688B0..0x82A688B4)
	// 82A688B0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82A688B4; continue 'dispatch;
            }
            0x82A688B4 => {
    //   block [0x82A688B4..0x82A688C4)
	// 82A688B4: 556B039C  rlwinm r11, r11, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A688B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A688BC: 419A0008  beq cr6, 0x82a688c4
	if ctx.cr[6].eq {
	pc = 0x82A688C4; continue 'dispatch;
	}
	// 82A688C0: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82A688C4; continue 'dispatch;
            }
            0x82A688C4 => {
    //   block [0x82A688C4..0x82A688EC)
	// 82A688C4: D1BF00C0  stfs f13, 0xc0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82A688C8: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A688CC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82A688D0: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A688D4: D1BF00C8  stfs f13, 0xc8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82A688D8: D17F00CC  stfs f11, 0xcc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82A688DC: D15F00D0  stfs f10, 0xd0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82A688E0: D17F00D4  stfs f11, 0xd4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82A688E4: D15F00D8  stfs f10, 0xd8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82A688E8: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x82A688EC; continue 'dispatch;
            }
            0x82A688EC => {
    //   block [0x82A688EC..0x82A688F4)
	// 82A688EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A688F0: 48240B64  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A688F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A688F8 size=264
    let mut pc: u32 = 0x82A688F8;
    'dispatch: loop {
        match pc {
            0x82A688F8 => {
    //   block [0x82A688F8..0x82A689AC)
	// 82A688F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A688FC: 48240B09  bl 0x82ca9404
	ctx.lr = 0x82A68900;
	sub_82CA93D0(ctx, base);
	// 82A68900: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68908: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A6890C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A68910: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A68914: 38E00012  li r7, 0x12
	ctx.r[7].s64 = 18;
	// 82A68918: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6891C: 38800800  li r4, 0x800
	ctx.r[4].s64 = 2048;
	// 82A68920: 891F000C  lbz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A68924: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A68928: 554607FE  clrlwi r6, r10, 0x1f
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A6892C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A68930: 5505067E  clrlwi r5, r8, 0x19
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000007Fu64;
	// 82A68934: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A68938: 394951E0  addi r10, r9, 0x51e0
	ctx.r[10].s64 = ctx.r[9].s64 + 20960;
	// 82A6893C: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82A68940: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A68944: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 82A68948: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A6894C: 3BBF0048  addi r29, r31, 0x48
	ctx.r[29].s64 = ctx.r[31].s64 + 72;
	// 82A68950: 98BF000C  stb r5, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u8 ) };
	// 82A68954: 909F0018  stw r4, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 82A68958: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82A6895C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82A68960: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A68964: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A68968: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82A6896C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82A68970: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82A68974: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A68978: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82A6897C: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82A68980: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82A68984: 93FF0020  stw r31, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82A68988: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6898C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82A68990: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82A68994: 4B7B68C5  bl 0x8221f258
	ctx.lr = 0x82A68998;
	sub_8221F258(ctx, base);
	// 82A68998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6899C: 419A0010  beq cr6, 0x82a689ac
	if ctx.cr[6].eq {
	pc = 0x82A689AC; continue 'dispatch;
	}
	// 82A689A0: 480B3B91  bl 0x82b1c530
	ctx.lr = 0x82A689A4;
	sub_82B1C530(ctx, base);
	// 82A689A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A689A8: 48000008  b 0x82a689b0
	pc = 0x82A689B0; continue 'dispatch;
            }
            0x82A689AC => {
    //   block [0x82A689AC..0x82A689B0)
	// 82A689AC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x82A689B0; continue 'dispatch;
            }
            0x82A689B0 => {
    //   block [0x82A689B0..0x82A689F0)
	// 82A689B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A689B4: 4B74F165  bl 0x821b7b18
	ctx.lr = 0x82A689B8;
	sub_821B7B18(ctx, base);
	// 82A689B8: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A689BC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A689C0: 419A0034  beq cr6, 0x82a689f4
	if ctx.cr[6].eq {
	pc = 0x82A689F4; continue 'dispatch;
	}
	// 82A689C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A689C8: 4B7B6891  bl 0x8221f258
	ctx.lr = 0x82A689CC;
	sub_8221F258(ctx, base);
	// 82A689CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A689D0: 419A0020  beq cr6, 0x82a689f0
	if ctx.cr[6].eq {
	pc = 0x82A689F0; continue 'dispatch;
	}
	// 82A689D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A689D8: 3D4082A7  lis r10, -0x7d59
	ctx.r[10].s64 = -2102984704;
	// 82A689DC: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A689E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A689E4: 392A8AD8  addi r9, r10, -0x7528
	ctx.r[9].s64 = ctx.r[10].s64 + -29992;
	// 82A689E8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A689EC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A689F0; continue 'dispatch;
            }
            0x82A689F0 => {
    //   block [0x82A689F0..0x82A689F4)
	// 82A689F0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82A689F4; continue 'dispatch;
            }
            0x82A689F4 => {
    //   block [0x82A689F4..0x82A68A00)
	// 82A689F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A689F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A689FC: 48240A58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68A00 size=104
    let mut pc: u32 = 0x82A68A00;
    'dispatch: loop {
        match pc {
            0x82A68A00 => {
    //   block [0x82A68A00..0x82A68A50)
	// 82A68A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A68A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A68A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68A18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A68A1C: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 82A68A20: 394B51E0  addi r10, r11, 0x51e0
	ctx.r[10].s64 = ctx.r[11].s64 + 20960;
	// 82A68A24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A68A28: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A68A2C: 4B74F0ED  bl 0x821b7b18
	ctx.lr = 0x82A68A30;
	sub_821B7B18(ctx, base);
	// 82A68A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68A34: 48010A6D  bl 0x82a794a0
	ctx.lr = 0x82A68A38;
	sub_82A794A0(ctx, base);
	// 82A68A38: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A68A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68A40: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A68A44: 419A000C  beq cr6, 0x82a68a50
	if ctx.cr[6].eq {
	pc = 0x82A68A50; continue 'dispatch;
	}
	// 82A68A48: 4B7B32F1  bl 0x8221bd38
	ctx.lr = 0x82A68A4C;
	sub_8221BD38(ctx, base);
	// 82A68A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A68A50; continue 'dispatch;
            }
            0x82A68A50 => {
    //   block [0x82A68A50..0x82A68A68)
	// 82A68A50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A68A54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A68A58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A68A5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A68A60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A68A64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68A68 size=112
    let mut pc: u32 = 0x82A68A68;
    'dispatch: loop {
        match pc {
            0x82A68A68 => {
    //   block [0x82A68A68..0x82A68AC0)
	// 82A68A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68A70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A68A74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A68A78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68A7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68A80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A68A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68A88: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A68A8C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68A90: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 82A68A94: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A68A98: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68A9C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68AA0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A68AA4: 4E800421  bctrl
	ctx.lr = 0x82A68AA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A68AA8: 2F030011  cmpwi cr6, r3, 0x11
	ctx.cr[6].compare_i32(ctx.r[3].s32, 17, &mut ctx.xer);
	// 82A68AAC: 409A0014  bne cr6, 0x82a68ac0
	if !ctx.cr[6].eq {
	pc = 0x82A68AC0; continue 'dispatch;
	}
	// 82A68AB0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A68AB4: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A68AB8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A68ABC: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
            }
            0x82A68AC0 => {
    //   block [0x82A68AC0..0x82A68AD8)
	// 82A68AC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A68AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A68AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A68ACC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A68AD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A68AD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68AD8 size=60
    let mut pc: u32 = 0x82A68AD8;
    'dispatch: loop {
        match pc {
            0x82A68AD8 => {
    //   block [0x82A68AD8..0x82A68B00)
	// 82A68AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A68AE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68AE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68AEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A68AF0: 419A0010  beq cr6, 0x82a68b00
	if ctx.cr[6].eq {
	pc = 0x82A68B00; continue 'dispatch;
	}
	// 82A68AF4: 4B834FA5  bl 0x8229da98
	ctx.lr = 0x82A68AF8;
	sub_8229DA98(ctx, base);
	// 82A68AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68AFC: 4B7B323D  bl 0x8221bd38
	ctx.lr = 0x82A68B00;
	sub_8221BD38(ctx, base);
	pc = 0x82A68B00; continue 'dispatch;
            }
            0x82A68B00 => {
    //   block [0x82A68B00..0x82A68B14)
	// 82A68B00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A68B04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A68B08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A68B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A68B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68B18 size=112
    let mut pc: u32 = 0x82A68B18;
    'dispatch: loop {
        match pc {
            0x82A68B18 => {
    //   block [0x82A68B18..0x82A68B70)
	// 82A68B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A68B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A68B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68B30: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A68B34: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82A68B38: 394B6EA8  addi r10, r11, 0x6ea8
	ctx.r[10].s64 = ctx.r[11].s64 + 28328;
	// 82A68B3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A68B40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A68B44: 4B75DCB5  bl 0x821c67f8
	ctx.lr = 0x82A68B48;
	sub_821C67F8(ctx, base);
	// 82A68B48: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82A68B4C: 4B7C916D  bl 0x82231cb8
	ctx.lr = 0x82A68B50;
	sub_82231CB8(ctx, base);
	// 82A68B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68B54: 4801094D  bl 0x82a794a0
	ctx.lr = 0x82A68B58;
	sub_82A794A0(ctx, base);
	// 82A68B58: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A68B5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68B60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A68B64: 419A000C  beq cr6, 0x82a68b70
	if ctx.cr[6].eq {
	pc = 0x82A68B70; continue 'dispatch;
	}
	// 82A68B68: 4B7B31D1  bl 0x8221bd38
	ctx.lr = 0x82A68B6C;
	sub_8221BD38(ctx, base);
	// 82A68B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A68B70; continue 'dispatch;
            }
            0x82A68B70 => {
    //   block [0x82A68B70..0x82A68B88)
	// 82A68B70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A68B74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A68B78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A68B7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A68B80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A68B84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68B88 size=3464
    let mut pc: u32 = 0x82A68B88;
    'dispatch: loop {
        match pc {
            0x82A68B88 => {
    //   block [0x82A68B88..0x82A68BC4)
	// 82A68B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68B8C: 48240845  bl 0x82ca93d0
	ctx.lr = 0x82A68B90;
	sub_82CA93D0(ctx, base);
	// 82A68B90: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82A68B94: 48245119  bl 0x82cadcac
	ctx.lr = 0x82A68B98;
	sub_82CADCA0(ctx, base);
	// 82A68B98: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 82A68B9C: 9421E990  stwu r1, -0x1670(r1)
	ea = ctx.r[1].u32.wrapping_add(-5744 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68BA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A68BA4: 90611684  stw r3, 0x1684(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(5764 as u32), ctx.r[3].u32 ) };
	// 82A68BA8: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A68BAC: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82A68BB0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82A68BB4: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 82A68BB8: 392A7E70  addi r9, r10, 0x7e70
	ctx.r[9].s64 = ctx.r[10].s64 + 32368;
	// 82A68BBC: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82A68BC0: 397F2004  addi r11, r31, 0x2004
	ctx.r[11].s64 = ctx.r[31].s64 + 8196;
	pc = 0x82A68BC4; continue 'dispatch;
            }
            0x82A68BC4 => {
    //   block [0x82A68BC4..0x82A68C7C)
	// 82A68BC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68BC8: 391F6014  addi r8, r31, 0x6014
	ctx.r[8].s64 = ctx.r[31].s64 + 24596;
	// 82A68BCC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A68BD0: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A68BD4: 9127DFFC  stw r9, -0x2004(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-8196 as u32), ctx.r[9].u32 ) };
	// 82A68BD8: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A68BDC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68BE0: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82A68BE4: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A68BE8: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A68BEC: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82A68BF0: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 82A68BF4: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A68BF8: 4198FFCC  blt cr6, 0x82a68bc4
	if ctx.cr[6].lt {
	pc = 0x82A68BC4; continue 'dispatch;
	}
	// 82A68BFC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A68C00: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 82A68C04: 3B8B63A0  addi r28, r11, 0x63a0
	ctx.r[28].s64 = ctx.r[11].s64 + 25504;
	// 82A68C08: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A68C0C: 38AB0DB8  addi r5, r11, 0xdb8
	ctx.r[5].s64 = ctx.r[11].s64 + 3512;
	// 82A68C10: 897C00ED  lbz r11, 0xed(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(237 as u32) ) } as u64;
	// 82A68C14: 815C00DC  lwz r10, 0xdc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A68C18: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A68C1C: 90A10074  stw r5, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[5].u32 ) };
	// 82A68C20: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A68C24: 2B0A0080  cmplwi cr6, r10, 0x80
	ctx.cr[6].compare_u32(ctx.r[10].u32, 128 as u32, &mut ctx.xer);
	// 82A68C28: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82A68C2C: 419A0088  beq cr6, 0x82a68cb4
	if ctx.cr[6].eq {
	pc = 0x82A68CB4; continue 'dispatch;
	}
	// 82A68C30: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A68C34: 813C00E0  lwz r9, 0xe0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(224 as u32) ) } as u64;
	// 82A68C38: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82A68C3C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A68C40: 409A003C  bne cr6, 0x82a68c7c
	if !ctx.cr[6].eq {
	pc = 0x82A68C7C; continue 'dispatch;
	}
	// 82A68C44: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68C48: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82A68C4C: 38FC00D8  addi r7, r28, 0xd8
	ctx.r[7].s64 = ctx.r[28].s64 + 216;
	// 82A68C50: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A68C54: 915C00E0  stw r10, 0xe0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(224 as u32), ctx.r[10].u32 ) };
	// 82A68C58: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82A68C5C: 815C00DC  lwz r10, 0xdc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A68C60: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68C64: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A68C68: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A68C6C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A68C70: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68C74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68C78: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82A68C7C; continue 'dispatch;
            }
            0x82A68C7C => {
    //   block [0x82A68C7C..0x82A68CB4)
	// 82A68C7C: 897C00EC  lbz r11, 0xec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A68C80: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 82A68C84: 915C00DC  stw r10, 0xdc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 82A68C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68C8C: 409A0028  bne cr6, 0x82a68cb4
	if !ctx.cr[6].eq {
	pc = 0x82A68CB4; continue 'dispatch;
	}
	// 82A68C90: 81660DB0  lwz r11, 0xdb0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A68C94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A68C98: 393C00D8  addi r9, r28, 0xd8
	ctx.r[9].s64 = ctx.r[28].s64 + 216;
	// 82A68C9C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A68CA0: 995C00EC  stb r10, 0xec(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(236 as u32), ctx.r[10].u8 ) };
	// 82A68CA4: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A68CA8: 91060DB0  stw r8, 0xdb0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 82A68CAC: 7D27292E  stwx r9, r7, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[5].u32), ctx.r[9].u32) };
	// 82A68CB0: 48000008  b 0x82a68cb8
	pc = 0x82A68CB8; continue 'dispatch;
            }
            0x82A68CB4 => {
    //   block [0x82A68CB4..0x82A68CB8)
	// 82A68CB4: 81060DB0  lwz r8, 0xdb0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A68CB8; continue 'dispatch;
            }
            0x82A68CB8 => {
    //   block [0x82A68CB8..0x82A68D2C)
	// 82A68CB8: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 82A68CBC: 88FC00A5  lbz r7, 0xa5(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(165 as u32) ) } as u64;
	// 82A68CC0: 815C0094  lwz r10, 0x94(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A68CC4: 39296F4C  addi r9, r9, 0x6f4c
	ctx.r[9].s64 = ctx.r[9].s64 + 28492;
	// 82A68CC8: 1D672008  mulli r11, r7, 0x2008
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A68CCC: 80E90018  lwz r7, 0x18(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A68CD0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A68CD4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A68CD8: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82A68CDC: 419A007C  beq cr6, 0x82a68d58
	if ctx.cr[6].eq {
	pc = 0x82A68D58; continue 'dispatch;
	}
	// 82A68CE0: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A68CE4: 813C0098  lwz r9, 0x98(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A68CE8: 7D5E4838  and r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82A68CEC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A68CF0: 409A003C  bne cr6, 0x82a68d2c
	if !ctx.cr[6].eq {
	pc = 0x82A68D2C; continue 'dispatch;
	}
	// 82A68CF4: 83CB2004  lwz r30, 0x2004(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68CF8: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82A68CFC: 393C0090  addi r9, r28, 0x90
	ctx.r[9].s64 = ctx.r[28].s64 + 144;
	// 82A68D00: 57DE1838  slwi r30, r30, 3
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82A68D04: 915C0098  stw r10, 0x98(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82A68D08: 7D3E592E  stwx r9, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82A68D0C: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68D10: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A68D14: 815C0094  lwz r10, 0x94(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A68D18: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A68D1C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A68D20: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68D24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68D28: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x82A68D2C; continue 'dispatch;
            }
            0x82A68D2C => {
    //   block [0x82A68D2C..0x82A68D58)
	// 82A68D2C: 897C00A4  lbz r11, 0xa4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A68D30: 90FC0094  stw r7, 0x94(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82A68D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68D38: 409A0020  bne cr6, 0x82a68d58
	if !ctx.cr[6].eq {
	pc = 0x82A68D58; continue 'dispatch;
	}
	// 82A68D3C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A68D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A68D44: 393C0090  addi r9, r28, 0x90
	ctx.r[9].s64 = ctx.r[28].s64 + 144;
	// 82A68D48: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A68D4C: 997C00A4  stb r11, 0xa4(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(164 as u32), ctx.r[11].u8 ) };
	// 82A68D50: 91060DB0  stw r8, 0xdb0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 82A68D54: 7D2A292E  stwx r9, r10, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[9].u32) };
	pc = 0x82A68D58; continue 'dispatch;
            }
            0x82A68D58 => {
    //   block [0x82A68D58..0x82A68DC0)
	// 82A68D58: 897C00D5  lbz r11, 0xd5(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(213 as u32) ) } as u64;
	// 82A68D5C: 815C00C4  lwz r10, 0xc4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A68D60: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A68D64: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A68D68: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A68D6C: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 82A68D70: 419A0080  beq cr6, 0x82a68df0
	if ctx.cr[6].eq {
	pc = 0x82A68DF0; continue 'dispatch;
	}
	// 82A68D74: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A68D78: 813C00C8  lwz r9, 0xc8(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 82A68D7C: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 82A68D80: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A68D84: 409A003C  bne cr6, 0x82a68dc0
	if !ctx.cr[6].eq {
	pc = 0x82A68DC0; continue 'dispatch;
	}
	// 82A68D88: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68D8C: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82A68D90: 393C00C0  addi r9, r28, 0xc0
	ctx.r[9].s64 = ctx.r[28].s64 + 192;
	// 82A68D94: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A68D98: 915C00C8  stw r10, 0xc8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 82A68D9C: 7D27592E  stwx r9, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82A68DA0: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68DA4: 55491838  slwi r9, r10, 3
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A68DA8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A68DAC: 815C00C4  lwz r10, 0xc4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A68DB0: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A68DB4: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A68DB8: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82A68DBC: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A68DC0; continue 'dispatch;
            }
            0x82A68DC0 => {
    //   block [0x82A68DC0..0x82A68DF0)
	// 82A68DC0: 897C00D4  lbz r11, 0xd4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A68DC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A68DC8: 915C00C4  stw r10, 0xc4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 82A68DCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68DD0: 409A0020  bne cr6, 0x82a68df0
	if !ctx.cr[6].eq {
	pc = 0x82A68DF0; continue 'dispatch;
	}
	// 82A68DD4: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A68DD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A68DDC: 38FC00C0  addi r7, r28, 0xc0
	ctx.r[7].s64 = ctx.r[28].s64 + 192;
	// 82A68DE0: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 82A68DE4: 997C00D4  stb r11, 0xd4(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(212 as u32), ctx.r[11].u8 ) };
	// 82A68DE8: 91460DB0  stw r10, 0xdb0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82A68DEC: 7CE9292E  stwx r7, r9, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), ctx.r[7].u32) };
	pc = 0x82A68DF0; continue 'dispatch;
            }
            0x82A68DF0 => {
    //   block [0x82A68DF0..0x82A69910)
	// 82A68DF0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68DF4: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82A68DF8: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82A68DFC: 390B0190  addi r8, r11, 0x190
	ctx.r[8].s64 = ctx.r[11].s64 + 400;
	// 82A68E00: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82A68E04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A68E08: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A68E0C: 38EAB480  addi r7, r10, -0x4b80
	ctx.r[7].s64 = ctx.r[10].s64 + -19328;
	// 82A68E10: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69910 size=168
    let mut pc: u32 = 0x82A69910;
    'dispatch: loop {
        match pc {
            0x82A69910 => {
    //   block [0x82A69910..0x82A699A0)
	// 82A69910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6991C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69928: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6992C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69930: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A69934: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A69938: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 82A6993C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A69940: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69944: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A69948: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A6994C: 4E800421  bctrl
	ctx.lr = 0x82A69950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A69950: 2F03000D  cmpwi cr6, r3, 0xd
	ctx.cr[6].compare_i32(ctx.r[3].s32, 13, &mut ctx.xer);
	// 82A69954: 409A004C  bne cr6, 0x82a699a0
	if !ctx.cr[6].eq {
	pc = 0x82A699A0; continue 'dispatch;
	}
	// 82A69958: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82A6995C: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 82A69960: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82A69964: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82A69968: 393E0030  addi r9, r30, 0x30
	ctx.r[9].s64 = ctx.r[30].s64 + 48;
            }
            0x82A699A0 => {
    //   block [0x82A699A0..0x82A699B8)
	// 82A699A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A699A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A699A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A699AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A699B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A699B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A699B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A699B8 size=468
    let mut pc: u32 = 0x82A699B8;
    'dispatch: loop {
        match pc {
            0x82A699B8 => {
    //   block [0x82A699B8..0x82A69A08)
	// 82A699B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A699BC: 4823FA4D  bl 0x82ca9408
	ctx.lr = 0x82A699C0;
	sub_82CA93D0(ctx, base);
	// 82A699C0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82A699C4: 48244315  bl 0x82cadcd8
	ctx.lr = 0x82A699C8;
	sub_82CADCA0(ctx, base);
	// 82A699C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A699CC: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82A699D0: 897C6E71  lbz r11, 0x6e71(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28273 as u32) ) } as u64;
	// 82A699D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A699D8: 409A01A4  bne cr6, 0x82a69b7c
	if !ctx.cr[6].eq {
	pc = 0x82A69B7C; continue 'dispatch;
	}
	// 82A699DC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A699E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A699E4: 3BAA0FB0  addi r29, r10, 0xfb0
	ctx.r[29].s64 = ctx.r[10].s64 + 4016;
	// 82A699E8: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 82A699EC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82A699F0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A699F4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82A699F8: C3EBFFF4  lfs f31, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A699FC: C3AB3804  lfs f29, 0x3804(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14340 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A69A00: C3CB0000  lfs f30, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A69A04: C38A1558  lfs f28, 0x1558(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5464 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	pc = 0x82A69A08; continue 'dispatch;
            }
            0x82A69A08 => {
    //   block [0x82A69A08..0x82A69A58)
	// 82A69A08: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 82A69A0C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82A69A10: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A69A14: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A69A18: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A69A1C: ED6CE828  fsubs f11, f12, f29
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[29].f64) as f32) as f64);
	// 82A69A20: ED4B02F2  fmuls f10, f11, f11
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82A69A24: EC2A0732  fmuls f1, f10, f28
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[28].f64) as f32) as f64);
	// 82A69A28: 4B794539  bl 0x821fdf60
	ctx.lr = 0x82A69A2C;
	sub_821FDF60(ctx, base);
	// 82A69A2C: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A69A30: 395D003C  addi r10, r29, 0x3c
	ctx.r[10].s64 = ctx.r[29].s64 + 60;
	// 82A69A34: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A69A38: ED1E4824  fdivs f8, f30, f9
	ctx.f[8].f64 = ((ctx.f[30].f64 / ctx.f[9].f64) as f32) as f64;
	// 82A69A3C: D11F0000  stfs f8, 0(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A69A40: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A69A44: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A69A48: EFE8F82A  fadds f31, f8, f31
	ctx.f[31].f64 = ((ctx.f[8].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A69A4C: 4198FFBC  blt cr6, 0x82a69a08
	if ctx.cr[6].lt {
	pc = 0x82A69A08; continue 'dispatch;
	}
	// 82A69A50: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82A69A54: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	pc = 0x82A69A58; continue 'dispatch;
            }
            0x82A69A58 => {
    //   block [0x82A69A58..0x82A69B10)
	// 82A69A58: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A69A5C: 395D0044  addi r10, r29, 0x44
	ctx.r[10].s64 = ctx.r[29].s64 + 68;
	// 82A69A60: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A69A64: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69A68: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A69A6C: ED2C0032  fmuls f9, f12, f0
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69A70: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A69A74: ECEA0032  fmuls f7, f10, f0
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69A78: C0CB0008  lfs f6, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A69A7C: ECA80032  fmuls f5, f8, f0
	ctx.f[5].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69A80: EC8001B2  fmuls f4, f0, f6
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82A69A84: D16BFFF8  stfs f11, -8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82A69A88: D12BFFFC  stfs f9, -4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82A69A8C: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A69A90: D0AB0004  stfs f5, 4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A69A94: D08B0008  stfs f4, 8(r11)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A69A98: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82A69A9C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A69AA0: 4198FFB8  blt cr6, 0x82a69a58
	if ctx.cr[6].lt {
	pc = 0x82A69A58; continue 'dispatch;
	}
	// 82A69AA4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A69AA8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A69AAC: 392B5FE8  addi r9, r11, 0x5fe8
	ctx.r[9].s64 = ctx.r[11].s64 + 24552;
	// 82A69AB0: 38AADAD8  addi r5, r10, -0x2528
	ctx.r[5].s64 = ctx.r[10].s64 + -9512;
	// 82A69AB4: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 82A69AB8: 816B5FE8  lwz r11, 0x5fe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24552 as u32) ) } as u64;
	// 82A69ABC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A69AC0: 7D640E70  srawi r4, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A69AC4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A69AC8: 810500E0  lwz r8, 0xe0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(224 as u32) ) } as u64;
	// 82A69ACC: 7D440194  addze r10, r4
	tmp.s64 = ctx.r[4].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[4].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A69AD0: 7D630E70  srawi r3, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A69AD4: 396A004F  addi r11, r10, 0x4f
	ctx.r[11].s64 = ctx.r[10].s64 + 79;
	// 82A69AD8: 7D230194  addze r9, r3
	tmp.s64 = ctx.r[3].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[3].u32);
	ctx.r[9].s64 = tmp.s64;
	// 82A69ADC: 7D6B3B96  divwu r11, r11, r7
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[7].u32;
	// 82A69AE0: 550806BE  clrlwi r8, r8, 0x1a
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000003Fu64;
	// 82A69AE4: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A69AE8: 38A9000F  addi r5, r9, 0xf
	ctx.r[5].s64 = ctx.r[9].s64 + 15;
	// 82A69AEC: 7C8B3A14  add r4, r11, r7
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A69AF0: 2F080015  cmpwi cr6, r8, 0x15
	ctx.cr[6].compare_i32(ctx.r[8].s32, 21, &mut ctx.xer);
	// 82A69AF4: 54AB0036  rlwinm r11, r5, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82A69AF8: 54872036  slwi r7, r4, 4
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A69AFC: 419A0014  beq cr6, 0x82a69b10
	if ctx.cr[6].eq {
	pc = 0x82A69B10; continue 'dispatch;
	}
	// 82A69B00: 2F080020  cmpwi cr6, r8, 0x20
	ctx.cr[6].compare_i32(ctx.r[8].s32, 32, &mut ctx.xer);
	// 82A69B04: 419A000C  beq cr6, 0x82a69b10
	if ctx.cr[6].eq {
	pc = 0x82A69B10; continue 'dispatch;
	}
	// 82A69B08: 2F080025  cmpwi cr6, r8, 0x25
	ctx.cr[6].compare_i32(ctx.r[8].s32, 37, &mut ctx.xer);
	// 82A69B0C: 409A0008  bne cr6, 0x82a69b14
	if !ctx.cr[6].eq {
	pc = 0x82A69B14; continue 'dispatch;
	}
	pc = 0x82A69B10; continue 'dispatch;
            }
            0x82A69B10 => {
    //   block [0x82A69B10..0x82A69B14)
	// 82A69B10: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	pc = 0x82A69B14; continue 'dispatch;
            }
            0x82A69B14 => {
    //   block [0x82A69B14..0x82A69B7C)
	// 82A69B14: 39000036  li r8, 0x36
	ctx.r[8].s64 = 54;
	// 82A69B18: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A69B1C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A69B20: 7CEB39D6  mullw r7, r11, r7
	ctx.r[7].s32 = ((ctx.r[11].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82A69B24: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A69B28: 7CC731D6  mullw r6, r7, r6
	ctx.r[6].s32 = ((ctx.r[7].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82A69B2C: 38A01400  li r5, 0x1400
	ctx.r[5].s64 = 5120;
	// 82A69B30: 3C808332  lis r4, -0x7cce
	ctx.r[4].s64 = -2093875200;
	// 82A69B34: 7CE62B96  divwu r7, r6, r5
	ctx.r[7].u32 = ctx.r[6].u32 / ctx.r[5].u32;
	// 82A69B38: 3864AB50  addi r3, r4, -0x54b0
	ctx.r[3].s64 = ctx.r[4].s64 + -21680;
	// 82A69B3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A69B40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A69B44: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A69B48: 4B82B839  bl 0x82295380
	ctx.lr = 0x82A69B4C;
	sub_82295380(ctx, base);
	// 82A69B4C: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 82A69B50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A69B54: 38630FFC  addi r3, r3, 0xffc
	ctx.r[3].s64 = ctx.r[3].s64 + 4092;
	// 82A69B58: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82A69B5C: 4B838B5D  bl 0x822a26b8
	ctx.lr = 0x82A69B60;
	sub_822A26B8(ctx, base);
	// 82A69B60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A69B64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A69B68: 386B1048  addi r3, r11, 0x1048
	ctx.r[3].s64 = ctx.r[11].s64 + 4168;
	// 82A69B6C: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82A69B70: 4B838B49  bl 0x822a26b8
	ctx.lr = 0x82A69B74;
	sub_822A26B8(ctx, base);
	// 82A69B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A69B78: 997C6E71  stb r11, 0x6e71(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28273 as u32), ctx.r[11].u8 ) };
	pc = 0x82A69B7C; continue 'dispatch;
            }
            0x82A69B7C => {
    //   block [0x82A69B7C..0x82A69B8C)
	// 82A69B7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A69B80: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82A69B84: 482441A1  bl 0x82cadd24
	ctx.lr = 0x82A69B88;
	sub_82CADCEC(ctx, base);
	// 82A69B88: 4823F8D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A69BB0 size=400
    let mut pc: u32 = 0x82A69BB0;
    'dispatch: loop {
        match pc {
            0x82A69BB0 => {
    //   block [0x82A69BB0..0x82A69D40)
	// 82A69BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69BB4: 4823F859  bl 0x82ca940c
	ctx.lr = 0x82A69BB8;
	sub_82CA93D0(ctx, base);
	// 82A69BB8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A69BBC: 4824410D  bl 0x82cadcc8
	ctx.lr = 0x82A69BC0;
	sub_82CADCA0(ctx, base);
	// 82A69BC0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69BC8: F8810108  std r4, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[4].u64 ) };
	// 82A69BCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A69BD0: F8A10110  std r5, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[5].u64 ) };
	// 82A69BD4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A69BD8: 4BD58221  bl 0x827c1df8
	ctx.lr = 0x82A69BDC;
	sub_827C1DF8(ctx, base);
	// 82A69BDC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A69BE0: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 82A69BE4: C0010108  lfs f0, 0x108(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69BE8: 394B5FE8  addi r10, r11, 0x5fe8
	ctx.r[10].s64 = ctx.r[11].s64 + 24552;
	// 82A69BEC: 393D9410  addi r9, r29, -0x6bf0
	ctx.r[9].s64 = ctx.r[29].s64 + -27632;
	// 82A69BF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A69BF4: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82A69BF8: C3E90080  lfs f31, 0x80(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A69BFC: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A69C00: C3C9FEC4  lfs f30, -0x13c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-316 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A69C04: ED2D07B2  fmuls f9, f13, f30
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A69C08: 816B5FE8  lwz r11, 0x5fe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24552 as u32) ) } as u64;
	// 82A69C0C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A69C10: 7D670E70  srawi r7, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A69C14: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A69C18: 7D460E70  srawi r6, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A69C1C: 7D6507B4  extsw r5, r11
	ctx.r[5].s64 = ctx.r[11].s32 as i64;
	// 82A69C20: 7D460194  addze r10, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A69C24: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A69C28: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A69C2C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82A69C30: 7D4407B4  extsw r4, r10
	ctx.r[4].s64 = ctx.r[10].s32 as i64;
	// 82A69C34: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82A69C38: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A69C3C: FFA05818  frsp f29, f11
	ctx.f[29].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82A69C40: FD00569C  fcfid f8, f10
	ctx.f[8].f64 = (ctx.f[10].s64 as f64);
	// 82A69C44: FF804018  frsp f28, f8
	ctx.f[28].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A69C48: EF7FE824  fdivs f27, f31, f29
	ctx.f[27].f64 = ((ctx.f[31].f64 / ctx.f[29].f64) as f32) as f64;
	// 82A69C4C: EC290772  fmuls f1, f9, f29
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[29].f64) as f32) as f64);
	// 82A69C50: 4B7C2741  bl 0x8222c390
	ctx.lr = 0x82A69C54;
	sub_8222C390(ctx, base);
	// 82A69C54: C0E1010C  lfs f7, 0x10c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A69C58: FCC00818  frsp f6, f1
	ctx.f[6].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A69C5C: ECA7F82A  fadds f5, f7, f31
	ctx.f[5].f64 = ((ctx.f[7].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A69C60: EF5FE024  fdivs f26, f31, f28
	ctx.f[26].f64 = ((ctx.f[31].f64 / ctx.f[28].f64) as f32) as f64;
	// 82A69C64: EF2606F2  fmuls f25, f6, f27
	ctx.f[25].f64 = (((ctx.f[6].f64 * ctx.f[27].f64) as f32) as f64);
	// 82A69C68: EC8507B2  fmuls f4, f5, f30
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A69C6C: EC240732  fmuls f1, f4, f28
	ctx.f[1].f64 = (((ctx.f[4].f64 * ctx.f[28].f64) as f32) as f64);
	// 82A69C70: 4B7C2721  bl 0x8222c390
	ctx.lr = 0x82A69C74;
	sub_8222C390(ctx, base);
	// 82A69C74: C0610110  lfs f3, 0x110(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A69C78: FC400818  frsp f2, f1
	ctx.f[2].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A69C7C: EC23F82A  fadds f1, f3, f31
	ctx.f[1].f64 = ((ctx.f[3].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A69C80: EF0206B2  fmuls f24, f2, f26
	ctx.f[24].f64 = (((ctx.f[2].f64 * ctx.f[26].f64) as f32) as f64);
	// 82A69C84: EC0107B2  fmuls f0, f1, f30
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A69C88: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82A69C8C: 4B82BD7D  bl 0x82295a08
	ctx.lr = 0x82A69C90;
	sub_82295A08(ctx, base);
	// 82A69C90: C1A10114  lfs f13, 0x114(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A69C94: FD800818  frsp f12, f1
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A69C98: ED6DF82A  fadds f11, f13, f31
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82A69C9C: C01D9410  lfs f0, -0x6bf0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69CA0: ED5B0032  fmuls f10, f27, f0
	ctx.f[10].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69CA4: EFFA0032  fmuls f31, f26, f0
	ctx.f[31].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69CA8: ED2C06F2  fmuls f9, f12, f27
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82A69CAC: ED0B07B2  fmuls f8, f11, f30
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A69CB0: ECF95028  fsubs f7, f25, f10
	ctx.f[7].f64 = (((ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82A69CB4: D0E10060  stfs f7, 0x60(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A69CB8: ECD8F828  fsubs f6, f24, f31
	ctx.f[6].f64 = (((ctx.f[24].f64 - ctx.f[31].f64) as f32) as f64);
	// 82A69CBC: D0C10064  stfs f6, 0x64(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A69CC0: ECAA482A  fadds f5, f10, f9
	ctx.f[5].f64 = ((ctx.f[10].f64 + ctx.f[9].f64) as f32) as f64;
	// 82A69CC4: D0A10068  stfs f5, 0x68(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A69CC8: EC280732  fmuls f1, f8, f28
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[28].f64) as f32) as f64);
	// 82A69CCC: 4B82BD3D  bl 0x82295a08
	ctx.lr = 0x82A69CD0;
	sub_82295A08(ctx, base);
	// 82A69CD0: FC800818  frsp f4, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A69CD4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A69CD8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A69CDC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A69CE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A69CE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A69CE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A69CEC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A69CF0: EC64FEBA  fmadds f3, f4, f26, f31
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[26].f64 + ctx.f[31].f64) as f32) as f64);
	// 82A69CF4: D061006C  stfs f3, 0x6c(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A69CF8: 48002289  bl 0x82a6bf80
	ctx.lr = 0x82A69CFC;
	sub_82A6BF80(ctx, base);
	// 82A69CFC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82A69D00: 39090FF0  addi r8, r9, 0xff0
	ctx.r[8].s64 = ctx.r[9].s64 + 4080;
	// 82A69D04: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82A69D08: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A69D0C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A69D10: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82A69D14: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A69D18: FBC10080  std r30, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u64 ) };
	// 82A69D1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A69D20: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A69D24: 4800234D  bl 0x82a6c070
	ctx.lr = 0x82A69D28;
	sub_82A6C070(ctx, base);
	// 82A69D28: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A69D2C: 4BBD095D  bl 0x8263a688
	ctx.lr = 0x82A69D30;
	sub_8263A688(ctx, base);
	// 82A69D30: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A69D34: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82A69D38: 48243FDD  bl 0x82cadd14
	ctx.lr = 0x82A69D3C;
	sub_82CADCEC(ctx, base);
	// 82A69D3C: 4823F720  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A69D40 size=1160
    let mut pc: u32 = 0x82A69D40;
    'dispatch: loop {
        match pc {
            0x82A69D40 => {
    //   block [0x82A69D40..0x82A6A1C8)
	// 82A69D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69D44: 4823F6BD  bl 0x82ca9400
	ctx.lr = 0x82A69D48;
	sub_82CA93D0(ctx, base);
	// 82A69D48: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82A69D4C: 48243F7D  bl 0x82cadcc8
	ctx.lr = 0x82A69D50;
	sub_82CADCA0(ctx, base);
	// 82A69D50: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69D54: 3F60820A  lis r27, -0x7df6
	ctx.r[27].s64 = -2113273856;
	// 82A69D58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69D5C: 3B5B9484  addi r26, r27, -0x6b7c
	ctx.r[26].s64 = ctx.r[27].s64 + -27516;
	// 82A69D60: 3BBE06B0  addi r29, r30, 0x6b0
	ctx.r[29].s64 = ctx.r[30].s64 + 1712;
	// 82A69D64: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A69D68: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A69D6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A69D70: C3FA000C  lfs f31, 0xc(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A69D74: 3BFC0050  addi r31, r28, 0x50
	ctx.r[31].s64 = ctx.r[28].s64 + 80;
	// 82A69D78: C3DA4144  lfs f30, 0x4144(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16708 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A69D7C: FF60F890  fmr f27, f31
	ctx.f[27].f64 = ctx.f[31].f64;
	// 82A69D80: FF20F090  fmr f25, f30
	ctx.f[25].f64 = ctx.f[30].f64;
	// 82A69D84: FF80F890  fmr f28, f31
	ctx.f[28].f64 = ctx.f[31].f64;
	// 82A69D88: FF40F090  fmr f26, f30
	ctx.f[26].f64 = ctx.f[30].f64;
	// 82A69D8C: 4B738705  bl 0x821a2490
	ctx.lr = 0x82A69D90;
	sub_821A2490(ctx, base);
	// 82A69D90: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A69D94: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A69D98: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A1D0 size=420
    let mut pc: u32 = 0x82A6A1D0;
    'dispatch: loop {
        match pc {
            0x82A6A1D0 => {
    //   block [0x82A6A1D0..0x82A6A270)
	// 82A6A1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A1D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A1DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A1E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6A1E4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A6A1E8: 38AB5FE8  addi r5, r11, 0x5fe8
	ctx.r[5].s64 = ctx.r[11].s64 + 24552;
	// 82A6A1EC: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82A6A1F0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82A6A1F4: 816B5FE8  lwz r11, 0x5fe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24552 as u32) ) } as u64;
	// 82A6A1F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6A1FC: 808AF9C0  lwz r4, -0x640(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 82A6A200: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6A204: 7D630E70  srawi r3, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A6A208: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A20C: 7D430194  addze r10, r3
	tmp.s64 = ctx.r[3].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[3].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A6A210: 7D650E70  srawi r5, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A6A214: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6A218: 7C650194  addze r3, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[3].s64 = tmp.s64;
	// 82A6A21C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6A220: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A6A224: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6A228: 4B791B69  bl 0x821fbd90
	ctx.lr = 0x82A6A22C;
	sub_821FBD90(ctx, base);
	// 82A6A22C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6A230: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6A234: 3BEBAB2C  addi r31, r11, -0x54d4
	ctx.r[31].s64 = ctx.r[11].s64 + -21716;
	// 82A6A238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A23C: 4B7919AD  bl 0x821fbbe8
	ctx.lr = 0x82A6A240;
	sub_821FBBE8(ctx, base);
	// 82A6A240: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6A244: 4B791D4D  bl 0x821fbf90
	ctx.lr = 0x82A6A248;
	sub_821FBF90(ctx, base);
	// 82A6A248: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6A24C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6A250: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A6A254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A258: 392A2A2C  addi r9, r10, 0x2a2c
	ctx.r[9].s64 = ctx.r[10].s64 + 10796;
	// 82A6A25C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A6A260: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A6A264: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6A268: 419A0008  beq cr6, 0x82a6a270
	if ctx.cr[6].eq {
	pc = 0x82A6A270; continue 'dispatch;
	}
	// 82A6A26C: 4B791F0D  bl 0x821fc178
	ctx.lr = 0x82A6A270;
	sub_821FC178(ctx, base);
	pc = 0x82A6A270; continue 'dispatch;
            }
            0x82A6A270 => {
    //   block [0x82A6A270..0x82A6A320)
	// 82A6A270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A274: 4B79212D  bl 0x821fc3a0
	ctx.lr = 0x82A6A278;
	sub_821FC3A0(ctx, base);
	// 82A6A278: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6A27C: 386BAB50  addi r3, r11, -0x54b0
	ctx.r[3].s64 = ctx.r[11].s64 + -21680;
	// 82A6A280: 4B800DF9  bl 0x8226b078
	ctx.lr = 0x82A6A284;
	sub_8226B078(ctx, base);
	// 82A6A284: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A288: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A6A28C: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A6A290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A294: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82A6A298: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A6A29C: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A6A2A0: C02A9490  lfs f1, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6A2A4: 4B778965  bl 0x821e2c08
	ctx.lr = 0x82A6A2A8;
	sub_821E2C08(ctx, base);
	// 82A6A2A8: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A6A2AC: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 82A6A2B0: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 82A6A2B4: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 82A6A2B8: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6A2BC: 88EB005D  lbz r7, 0x5d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(93 as u32) ) } as u64;
	// 82A6A2C0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A6A2C4: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6A2C8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A6A2CC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6A2D0: 419A0090  beq cr6, 0x82a6a360
	if ctx.cr[6].eq {
	pc = 0x82A6A360; continue 'dispatch;
	}
	// 82A6A2D4: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6A2D8: 810B0050  lwz r8, 0x50(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6A2DC: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6A2E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6A2E4: 409A003C  bne cr6, 0x82a6a320
	if !ctx.cr[6].eq {
	pc = 0x82A6A320; continue 'dispatch;
	}
	// 82A6A2E8: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6A2EC: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6A2F0: 38CB0048  addi r6, r11, 0x48
	ctx.r[6].s64 = ctx.r[11].s64 + 72;
	// 82A6A2F4: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6A2F8: 912B0050  stw r9, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A6A2FC: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6A300: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6A304: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6A308: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6A30C: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6A310: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6A314: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6A318: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6A31C: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6A320; continue 'dispatch;
            }
            0x82A6A320 => {
    //   block [0x82A6A320..0x82A6A360)
	// 82A6A320: 894B005C  lbz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6A324: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6A328: 912B004C  stw r9, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 82A6A32C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6A330: 409A0030  bne cr6, 0x82a6a360
	if !ctx.cr[6].eq {
	pc = 0x82A6A360; continue 'dispatch;
	}
	// 82A6A334: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A6A338: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6A33C: 390B0048  addi r8, r11, 0x48
	ctx.r[8].s64 = ctx.r[11].s64 + 72;
	// 82A6A340: 994B005C  stb r10, 0x5c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 82A6A344: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A6A348: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A6A34C: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 82A6A350: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6A354: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A6A358: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 82A6A35C: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x82A6A360; continue 'dispatch;
            }
            0x82A6A360 => {
    //   block [0x82A6A360..0x82A6A374)
	// 82A6A360: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6A364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A36C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A378 size=220
    let mut pc: u32 = 0x82A6A378;
    'dispatch: loop {
        match pc {
            0x82A6A378 => {
    //   block [0x82A6A378..0x82A6A3CC)
	// 82A6A378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A37C: 4823F091  bl 0x82ca940c
	ctx.lr = 0x82A6A380;
	sub_82CA93D0(ctx, base);
	// 82A6A380: 9421F460  stwu r1, -0xba0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2976 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A384: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6A388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A38C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A390: 4B8219C9  bl 0x8228bd58
	ctx.lr = 0x82A6A394;
	sub_8228BD58(ctx, base);
	// 82A6A394: 81610408  lwz r11, 0x408(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82A6A398: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A6A39C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6A3A0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82A6A3A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6A3A8: 91410408  stw r10, 0x408(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1032 as u32), ctx.r[10].u32 ) };
	// 82A6A3AC: 38610410  addi r3, r1, 0x410
	ctx.r[3].s64 = ctx.r[1].s64 + 1040;
	// 82A6A3B0: 4B803161  bl 0x8226d510
	ctx.lr = 0x82A6A3B4;
	sub_8226D510(ctx, base);
	// 82A6A3B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6A3B8: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82A6A3BC: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 82A6A3C0: 91210B0C  stw r9, 0xb0c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2828 as u32), ctx.r[9].u32 ) };
	// 82A6A3C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A3C8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A6A3CC; continue 'dispatch;
            }
            0x82A6A3CC => {
    //   block [0x82A6A3CC..0x82A6A3FC)
	// 82A6A3CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6A3D0: 38810410  addi r4, r1, 0x410
	ctx.r[4].s64 = ctx.r[1].s64 + 1040;
	// 82A6A3D4: 419A0030  beq cr6, 0x82a6a404
	if ctx.cr[6].eq {
	pc = 0x82A6A404; continue 'dispatch;
	}
	// 82A6A3D8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6A3DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A3E0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6A3E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6A3E8: 4E800421  bctrl
	ctx.lr = 0x82A6A3EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A3EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A3F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6A3F4: 409A0008  bne cr6, 0x82a6a3fc
	if !ctx.cr[6].eq {
	pc = 0x82A6A3FC; continue 'dispatch;
	}
	// 82A6A3F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
            }
            0x82A6A3FC => {
    //   block [0x82A6A3FC..0x82A6A404)
	// 82A6A3FC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A400: 4BFFFFCC  b 0x82a6a3cc
	pc = 0x82A6A3CC; continue 'dispatch;
            }
            0x82A6A404 => {
    //   block [0x82A6A404..0x82A6A42C)
	// 82A6A404: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6A408: 386B1048  addi r3, r11, 0x1048
	ctx.r[3].s64 = ctx.r[11].s64 + 4168;
	// 82A6A40C: 4B7D2B95  bl 0x8223cfa0
	ctx.lr = 0x82A6A410;
	sub_8223CFA0(ctx, base);
	// 82A6A410: 81410408  lwz r10, 0x408(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82A6A414: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6A418: 91610408  stw r11, 0x408(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1032 as u32), ctx.r[11].u32 ) };
	// 82A6A41C: 40820028  bne 0x82a6a444
	if !ctx.cr[0].eq {
	pc = 0x82A6A444; continue 'dispatch;
	}
	// 82A6A420: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82A6A424: 3BC00011  li r30, 0x11
	ctx.r[30].s64 = 17;
	// 82A6A428: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82A6A42C; continue 'dispatch;
            }
            0x82A6A42C => {
    //   block [0x82A6A42C..0x82A6A444)
	// 82A6A42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A430: 4B7CF819  bl 0x82239c48
	ctx.lr = 0x82A6A434;
	sub_82239C48(ctx, base);
	// 82A6A434: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82A6A438: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6A43C: 3BFF0038  addi r31, r31, 0x38
	ctx.r[31].s64 = ctx.r[31].s64 + 56;
	// 82A6A440: 4082FFEC  bne 0x82a6a42c
	if !ctx.cr[0].eq {
	pc = 0x82A6A42C; continue 'dispatch;
	}
	pc = 0x82A6A444; continue 'dispatch;
            }
            0x82A6A444 => {
    //   block [0x82A6A444..0x82A6A454)
	// 82A6A444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A448: 4B80AEC1  bl 0x82275308
	ctx.lr = 0x82A6A44C;
	sub_82275308(ctx, base);
	// 82A6A44C: 38210BA0  addi r1, r1, 0xba0
	ctx.r[1].s64 = ctx.r[1].s64 + 2976;
	// 82A6A450: 4823F00C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A458 size=316
    let mut pc: u32 = 0x82A6A458;
    'dispatch: loop {
        match pc {
            0x82A6A458 => {
    //   block [0x82A6A458..0x82A6A4C0)
	// 82A6A458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A468: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A46C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6A470: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A6A474: 3BEBAB2C  addi r31, r11, -0x54d4
	ctx.r[31].s64 = ctx.r[11].s64 + -21716;
	// 82A6A478: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A480: 419A0040  beq cr6, 0x82a6a4c0
	if ctx.cr[6].eq {
	pc = 0x82A6A4C0; continue 'dispatch;
	}
	// 82A6A484: 4B7C7E45  bl 0x822322c8
	ctx.lr = 0x82A6A488;
	sub_822322C8(ctx, base);
	// 82A6A488: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82A6A48C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A6A490: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A494: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6A498: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A6A49C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6A4A0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A6A4A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6A4A8: C0259484  lfs f1, -0x6b7c(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6A4AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6A4B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A6A4B4: 806B0364  lwz r3, 0x364(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6A4B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6A4BC: 4B79C3CD  bl 0x82206888
	ctx.lr = 0x82A6A4C0;
	sub_82206888(ctx, base);
	pc = 0x82A6A4C0; continue 'dispatch;
            }
            0x82A6A4C0 => {
    //   block [0x82A6A4C0..0x82A6A53C)
	// 82A6A4C0: 4B7D7D11  bl 0x822421d0
	ctx.lr = 0x82A6A4C4;
	sub_822421D0(ctx, base);
	// 82A6A4C4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A6A4C8: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82A6A4CC: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 82A6A4D0: 390A2390  addi r8, r10, 0x2390
	ctx.r[8].s64 = ctx.r[10].s64 + 9104;
	// 82A6A4D4: 892B005D  lbz r9, 0x5d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(93 as u32) ) } as u64;
	// 82A6A4D8: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6A4DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6A4E0: 1D492008  mulli r10, r9, 0x2008
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6A4E4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A6A4E8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6A4EC: 419A0090  beq cr6, 0x82a6a57c
	if ctx.cr[6].eq {
	pc = 0x82A6A57C; continue 'dispatch;
	}
	// 82A6A4F0: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6A4F4: 810B0050  lwz r8, 0x50(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6A4F8: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6A4FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6A500: 409A003C  bne cr6, 0x82a6a53c
	if !ctx.cr[6].eq {
	pc = 0x82A6A53C; continue 'dispatch;
	}
	// 82A6A504: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6A508: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6A50C: 38CB0048  addi r6, r11, 0x48
	ctx.r[6].s64 = ctx.r[11].s64 + 72;
	// 82A6A510: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6A514: 912B0050  stw r9, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A6A518: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6A51C: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6A520: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6A524: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6A528: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6A52C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6A530: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6A534: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6A538: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6A53C; continue 'dispatch;
            }
            0x82A6A53C => {
    //   block [0x82A6A53C..0x82A6A57C)
	// 82A6A53C: 894B005C  lbz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6A540: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A6A544: 912B004C  stw r9, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 82A6A548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6A54C: 409A0030  bne cr6, 0x82a6a57c
	if !ctx.cr[6].eq {
	pc = 0x82A6A57C; continue 'dispatch;
	}
	// 82A6A550: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A6A554: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6A558: 390B0048  addi r8, r11, 0x48
	ctx.r[8].s64 = ctx.r[11].s64 + 72;
	// 82A6A55C: 994B005C  stb r10, 0x5c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 82A6A560: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 82A6A564: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A6A568: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 82A6A56C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6A570: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A6A574: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 82A6A578: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x82A6A57C; continue 'dispatch;
            }
            0x82A6A57C => {
    //   block [0x82A6A57C..0x82A6A594)
	// 82A6A57C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6A580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A588: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A58C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6A598 size=1268
    let mut pc: u32 = 0x82A6A598;
    'dispatch: loop {
        match pc {
            0x82A6A598 => {
    //   block [0x82A6A598..0x82A6AA8C)
	// 82A6A598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A59C: 4823EE59  bl 0x82ca93f4
	ctx.lr = 0x82A6A5A0;
	sub_82CA93D0(ctx, base);
	// 82A6A5A0: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 82A6A5A4: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82A6A5A8: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6AA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6AA90 size=1268
    let mut pc: u32 = 0x82A6AA90;
    'dispatch: loop {
        match pc {
            0x82A6AA90 => {
    //   block [0x82A6AA90..0x82A6AF84)
	// 82A6AA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6AA94: 4823E961  bl 0x82ca93f4
	ctx.lr = 0x82A6AA98;
	sub_82CA93D0(ctx, base);
	// 82A6AA98: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 82A6AA9C: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82A6AAA0: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6AF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6AF88 size=3096
    let mut pc: u32 = 0x82A6AF88;
    'dispatch: loop {
        match pc {
            0x82A6AF88 => {
    //   block [0x82A6AF88..0x82A6AFEC)
	// 82A6AF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6AF8C: 4823E475  bl 0x82ca9400
	ctx.lr = 0x82A6AF90;
	sub_82CA93D0(ctx, base);
	// 82A6AF90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6AF94: 386000AA  li r3, 0xaa
	ctx.r[3].s64 = 170;
	// 82A6AF98: 4B7C1279  bl 0x8222c210
	ctx.lr = 0x82A6AF9C;
	sub_8222C210(ctx, base);
	// 82A6AF9C: 386000AB  li r3, 0xab
	ctx.r[3].s64 = 171;
	// 82A6AFA0: 4B79DB71  bl 0x82208b10
	ctx.lr = 0x82A6AFA4;
	sub_82208B10(ctx, base);
	// 82A6AFA4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A6AFA8: 394BDED4  addi r10, r11, -0x212c
	ctx.r[10].s64 = ctx.r[11].s64 + -8492;
	// 82A6AFAC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6AFB0: 83EB0BD0  lwz r31, 0xbd0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3024 as u32) ) } as u64;
	// 82A6AFB4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6AFB8: 41980034  blt cr6, 0x82a6afec
	if ctx.cr[6].lt {
	pc = 0x82A6AFEC; continue 'dispatch;
	}
	// 82A6AFBC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6AFC0: 391F0020  addi r8, r31, 0x20
	ctx.r[8].s64 = ctx.r[31].s64 + 32;
	// 82A6AFC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A6AFC8: 392BAB2C  addi r9, r11, -0x54d4
	ctx.r[9].s64 = ctx.r[11].s64 + -21716;
	// 82A6AFCC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A6AFD0: 79060020  clrldi r6, r8, 0x20
	ctx.r[6].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 82A6AFD4: 78EBFFE6  rldicr r11, r7, 0x3f, 0x3f
	ctx.r[11].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A6AFD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6AFDC: 7D663436  srd r6, r11, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[11].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 82A6AFE0: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6AFE4: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6AFE8: 4B74BEF9  bl 0x821b6ee0
	ctx.lr = 0x82A6AFEC;
	sub_821B6EE0(ctx, base);
	pc = 0x82A6AFEC; continue 'dispatch;
            }
            0x82A6AFEC => {
    //   block [0x82A6AFEC..0x82A6B098)
	// 82A6AFEC: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6AFF0: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A6AFF4: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A6AFF8: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 82A6AFFC: 55431838  slwi r3, r10, 3
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6B000: 394B0AB0  addi r10, r11, 0xab0
	ctx.r[10].s64 = ctx.r[11].s64 + 2736;
	// 82A6B004: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 82A6B008: 7D435214  add r10, r3, r10
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 82A6B00C: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 82A6B010: 3BC92390  addi r30, r9, 0x2390
	ctx.r[30].s64 = ctx.r[9].s64 + 9104;
	// 82A6B014: 38E86F38  addi r7, r8, 0x6f38
	ctx.r[7].s64 = ctx.r[8].s64 + 28472;
	// 82A6B018: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 82A6B01C: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6B020: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A6B024: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B028: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82A6B02C: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A6B030: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B034: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A6B038: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82A6B03C: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6B040: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 82A6B044: 3B860DB8  addi r28, r6, 0xdb8
	ctx.r[28].s64 = ctx.r[6].s64 + 3512;
	// 82A6B048: 419A007C  beq cr6, 0x82a6b0c4
	if ctx.cr[6].eq {
	pc = 0x82A6B0C4; continue 'dispatch;
	}
	// 82A6B04C: 80C92000  lwz r6, 0x2000(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B050: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B054: 7CBF3038  and r31, r5, r6
	ctx.r[31].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 82A6B058: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6B05C: 409A003C  bne cr6, 0x82a6b098
	if !ctx.cr[6].eq {
	pc = 0x82A6B098; continue 'dispatch;
	}
	// 82A6B060: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B064: 7CA63378  or r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 | ctx.r[6].u64;
	// 82A6B068: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B06C: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A6B070: 7D45492E  stwx r10, r5, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82A6B074: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B078: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B07C: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B080: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A6B084: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6B088: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B08C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82A6B090: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B094: 90C92004  stw r6, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x82A6B098; continue 'dispatch;
            }
            0x82A6B098 => {
    //   block [0x82A6B098..0x82A6B0C4)
	// 82A6B098: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6B09C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A6B0A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B0A4: 409A0020  bne cr6, 0x82a6b0c4
	if !ctx.cr[6].eq {
	pc = 0x82A6B0C4; continue 'dispatch;
	}
	// 82A6B0A8: 813D0DB0  lwz r9, 0xdb0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A6B0AC: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82A6B0B0: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6B0B4: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 82A6B0B8: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B0BC: 7D47E12E  stwx r10, r7, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	// 82A6B0C0: 48000008  b 0x82a6b0c8
	pc = 0x82A6B0C8; continue 'dispatch;
            }
            0x82A6B0C4 => {
    //   block [0x82A6B0C4..0x82A6B0C8)
	// 82A6B0C4: 809D0DB0  lwz r4, 0xdb0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A6B0C8; continue 'dispatch;
            }
            0x82A6B0C8 => {
    //   block [0x82A6B0C8..0x82A6B134)
	// 82A6B0C8: 394B0C90  addi r10, r11, 0xc90
	ctx.r[10].s64 = ctx.r[11].s64 + 3216;
	// 82A6B0CC: 7D435214  add r10, r3, r10
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 82A6B0D0: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6B0D4: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B0D8: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A6B0DC: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A6B0E0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6B0E4: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 82A6B0E8: 419A0070  beq cr6, 0x82a6b158
	if ctx.cr[6].eq {
	pc = 0x82A6B158; continue 'dispatch;
	}
	// 82A6B0EC: 80E92000  lwz r7, 0x2000(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B0F0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B0F4: 7CC53838  and r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 82A6B0F8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6B0FC: 409A0038  bne cr6, 0x82a6b134
	if !ctx.cr[6].eq {
	pc = 0x82A6B134; continue 'dispatch;
	}
	// 82A6B100: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B104: 7CC73B78  or r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 82A6B108: 54A61838  slwi r6, r5, 3
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A6B10C: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A6B110: 7D46492E  stwx r10, r6, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82A6B114: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B118: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B11C: 54A71838  slwi r7, r5, 3
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6B120: 7CA74A14  add r5, r7, r9
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A6B124: 90C50004  stw r6, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6B128: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B12C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82A6B130: 90E92004  stw r7, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B134; continue 'dispatch;
            }
            0x82A6B134 => {
    //   block [0x82A6B134..0x82A6B158)
	// 82A6B134: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6B138: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A6B13C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B140: 409A0018  bne cr6, 0x82a6b158
	if !ctx.cr[6].eq {
	pc = 0x82A6B158; continue 'dispatch;
	}
	// 82A6B144: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B148: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82A6B14C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B150: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B154: 7D49E12E  stwx r10, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	pc = 0x82A6B158; continue 'dispatch;
            }
            0x82A6B158 => {
    //   block [0x82A6B158..0x82A6B1D8)
	// 82A6B158: 394B1230  addi r10, r11, 0x1230
	ctx.r[10].s64 = ctx.r[11].s64 + 4656;
	// 82A6B15C: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 82A6B160: 7D435214  add r10, r3, r10
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 82A6B164: 38E96FC0  addi r7, r9, 0x6fc0
	ctx.r[7].s64 = ctx.r[9].s64 + 28608;
	// 82A6B168: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6B16C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B170: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A6B174: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B178: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A6B17C: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 82A6B180: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6B184: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 82A6B188: 419A0074  beq cr6, 0x82a6b1fc
	if ctx.cr[6].eq {
	pc = 0x82A6B1FC; continue 'dispatch;
	}
	// 82A6B18C: 80C92000  lwz r6, 0x2000(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B190: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B194: 7CBA3038  and r26, r5, r6
	ctx.r[26].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 82A6B198: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A6B19C: 409A003C  bne cr6, 0x82a6b1d8
	if !ctx.cr[6].eq {
	pc = 0x82A6B1D8; continue 'dispatch;
	}
	// 82A6B1A0: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B1A4: 7CA63378  or r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 | ctx.r[6].u64;
	// 82A6B1A8: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B1AC: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A6B1B0: 7D45492E  stwx r10, r5, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82A6B1B4: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B1B8: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B1BC: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B1C0: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A6B1C4: 90C50004  stw r6, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6B1C8: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B1CC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82A6B1D0: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B1D4: 90C92004  stw r6, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x82A6B1D8; continue 'dispatch;
            }
            0x82A6B1D8 => {
    //   block [0x82A6B1D8..0x82A6B1FC)
	// 82A6B1D8: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6B1DC: 93EA0004  stw r31, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A6B1E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B1E4: 409A0018  bne cr6, 0x82a6b1fc
	if !ctx.cr[6].eq {
	pc = 0x82A6B1FC; continue 'dispatch;
	}
	// 82A6B1E8: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B1EC: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82A6B1F0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B1F4: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B1F8: 7D49E12E  stwx r10, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	pc = 0x82A6B1FC; continue 'dispatch;
            }
            0x82A6B1FC => {
    //   block [0x82A6B1FC..0x82A6B268)
	// 82A6B1FC: 394B1050  addi r10, r11, 0x1050
	ctx.r[10].s64 = ctx.r[11].s64 + 4176;
	// 82A6B200: 7D435214  add r10, r3, r10
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 82A6B204: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6B208: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B20C: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A6B210: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A6B214: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6B218: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 82A6B21C: 419A0070  beq cr6, 0x82a6b28c
	if ctx.cr[6].eq {
	pc = 0x82A6B28C; continue 'dispatch;
	}
	// 82A6B220: 80E92000  lwz r7, 0x2000(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B224: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B228: 7CC53838  and r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 82A6B22C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6B230: 409A0038  bne cr6, 0x82a6b268
	if !ctx.cr[6].eq {
	pc = 0x82A6B268; continue 'dispatch;
	}
	// 82A6B234: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B238: 7CC73B78  or r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 82A6B23C: 54A61838  slwi r6, r5, 3
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A6B240: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A6B244: 7D46492E  stwx r10, r6, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82A6B248: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B24C: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B250: 54A71838  slwi r7, r5, 3
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6B254: 7CA74A14  add r5, r7, r9
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82A6B258: 90C50004  stw r6, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6B25C: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B260: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82A6B264: 90E92004  stw r7, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B268; continue 'dispatch;
            }
            0x82A6B268 => {
    //   block [0x82A6B268..0x82A6B28C)
	// 82A6B268: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6B26C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A6B270: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B274: 409A0018  bne cr6, 0x82a6b28c
	if !ctx.cr[6].eq {
	pc = 0x82A6B28C; continue 'dispatch;
	}
	// 82A6B278: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B27C: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82A6B280: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B284: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B288: 7D49E12E  stwx r10, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	pc = 0x82A6B28C; continue 'dispatch;
            }
            0x82A6B28C => {
    //   block [0x82A6B28C..0x82A6B304)
	// 82A6B28C: 394B08D0  addi r10, r11, 0x8d0
	ctx.r[10].s64 = ctx.r[11].s64 + 2256;
	// 82A6B290: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 82A6B294: 7D435214  add r10, r3, r10
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[10].u64;
	// 82A6B298: 39096FCC  addi r8, r9, 0x6fcc
	ctx.r[8].s64 = ctx.r[9].s64 + 28620;
	// 82A6B29C: 88EA0015  lbz r7, 0x15(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6B2A0: 80C80008  lwz r6, 8(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B2A4: 1D272008  mulli r9, r7, 0x2008
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A6B2A8: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B2AC: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A6B2B0: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A6B2B4: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 82A6B2B8: 419A0070  beq cr6, 0x82a6b328
	if ctx.cr[6].eq {
	pc = 0x82A6B328; continue 'dispatch;
	}
	// 82A6B2BC: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B2C0: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6B2C4: 7CE54038  and r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6B2C8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6B2CC: 409A0038  bne cr6, 0x82a6b304
	if !ctx.cr[6].eq {
	pc = 0x82A6B304; continue 'dispatch;
	}
	// 82A6B2D0: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B2D4: 7CE34378  or r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6B2D8: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B2DC: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A6B2E0: 7D48492E  stwx r10, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82A6B2E4: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B2E8: 80A92004  lwz r5, 0x2004(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B2EC: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B2F0: 7C684A14  add r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A6B2F4: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A6B2F8: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B2FC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A6B300: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x82A6B304; continue 'dispatch;
            }
            0x82A6B304 => {
    //   block [0x82A6B304..0x82A6B328)
	// 82A6B304: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6B308: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6B30C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B310: 409A0018  bne cr6, 0x82a6b328
	if !ctx.cr[6].eq {
	pc = 0x82A6B328; continue 'dispatch;
	}
	// 82A6B314: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B318: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82A6B31C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B320: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B324: 7D49E12E  stwx r10, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[10].u32) };
	pc = 0x82A6B328; continue 'dispatch;
            }
            0x82A6B328 => {
    //   block [0x82A6B328..0x82A6B390)
	// 82A6B328: 894B005D  lbz r10, 0x5d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(93 as u32) ) } as u64;
	// 82A6B32C: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6B330: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B334: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B338: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A6B33C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B340: 419A0080  beq cr6, 0x82a6b3c0
	if ctx.cr[6].eq {
	pc = 0x82A6B3C0; continue 'dispatch;
	}
	// 82A6B344: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B348: 810B0050  lwz r8, 0x50(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B34C: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B350: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B354: 409A003C  bne cr6, 0x82a6b390
	if !ctx.cr[6].eq {
	pc = 0x82A6B390; continue 'dispatch;
	}
	// 82A6B358: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B35C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B360: 38CB0048  addi r6, r11, 0x48
	ctx.r[6].s64 = ctx.r[11].s64 + 72;
	// 82A6B364: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B368: 912B0050  stw r9, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A6B36C: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6B370: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B374: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6B378: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B37C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B380: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B384: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B388: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B38C: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B390; continue 'dispatch;
            }
            0x82A6B390 => {
    //   block [0x82A6B390..0x82A6B3C0)
	// 82A6B390: 894B005C  lbz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6B394: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82A6B398: 912B004C  stw r9, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 82A6B39C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B3A0: 409A0020  bne cr6, 0x82a6b3c0
	if !ctx.cr[6].eq {
	pc = 0x82A6B3C0; continue 'dispatch;
	}
	// 82A6B3A4: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B3A8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B3AC: 390B0048  addi r8, r11, 0x48
	ctx.r[8].s64 = ctx.r[11].s64 + 72;
	// 82A6B3B0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B3B4: 994B005C  stb r10, 0x5c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 82A6B3B8: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B3BC: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B3C0; continue 'dispatch;
            }
            0x82A6B3C0 => {
    //   block [0x82A6B3C0..0x82A6B428)
	// 82A6B3C0: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 82A6B3C4: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6B3C8: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B3CC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B3D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B3D4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B3D8: 419A0080  beq cr6, 0x82a6b458
	if ctx.cr[6].eq {
	pc = 0x82A6B458; continue 'dispatch;
	}
	// 82A6B3DC: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B3E0: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A6B3E4: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B3E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B3EC: 409A003C  bne cr6, 0x82a6b428
	if !ctx.cr[6].eq {
	pc = 0x82A6B428; continue 'dispatch;
	}
	// 82A6B3F0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B3F4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B3F8: 38CB0030  addi r6, r11, 0x30
	ctx.r[6].s64 = ctx.r[11].s64 + 48;
	// 82A6B3FC: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B400: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82A6B404: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6B408: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B40C: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6B410: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B414: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B418: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B41C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B420: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B424: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B428; continue 'dispatch;
            }
            0x82A6B428 => {
    //   block [0x82A6B428..0x82A6B458)
	// 82A6B428: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A6B42C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6B430: 912B0034  stw r9, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82A6B434: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B438: 409A0020  bne cr6, 0x82a6b458
	if !ctx.cr[6].eq {
	pc = 0x82A6B458; continue 'dispatch;
	}
	// 82A6B43C: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B440: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B444: 390B0030  addi r8, r11, 0x30
	ctx.r[8].s64 = ctx.r[11].s64 + 48;
	// 82A6B448: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B44C: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82A6B450: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B454: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B458; continue 'dispatch;
            }
            0x82A6B458 => {
    //   block [0x82A6B458..0x82A6B4C0)
	// 82A6B458: 894B00BD  lbz r10, 0xbd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(189 as u32) ) } as u64;
	// 82A6B45C: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A6B460: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B464: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B468: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A6B46C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B470: 419A0080  beq cr6, 0x82a6b4f0
	if ctx.cr[6].eq {
	pc = 0x82A6B4F0; continue 'dispatch;
	}
	// 82A6B474: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B478: 810B00B0  lwz r8, 0xb0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A6B47C: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B480: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B484: 409A003C  bne cr6, 0x82a6b4c0
	if !ctx.cr[6].eq {
	pc = 0x82A6B4C0; continue 'dispatch;
	}
	// 82A6B488: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B48C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B490: 38CB00A8  addi r6, r11, 0xa8
	ctx.r[6].s64 = ctx.r[11].s64 + 168;
	// 82A6B494: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B498: 912B00B0  stw r9, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 82A6B49C: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6B4A0: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A6B4A4: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B4A8: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B4AC: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B4B0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B4B4: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B4B8: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B4BC: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B4C0; continue 'dispatch;
            }
            0x82A6B4C0 => {
    //   block [0x82A6B4C0..0x82A6B4F0)
	// 82A6B4C0: 894B00BC  lbz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A6B4C4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82A6B4C8: 912B00AC  stw r9, 0xac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 82A6B4CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B4D0: 409A0020  bne cr6, 0x82a6b4f0
	if !ctx.cr[6].eq {
	pc = 0x82A6B4F0; continue 'dispatch;
	}
	// 82A6B4D4: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B4D8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B4DC: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 82A6B4E0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B4E4: 994B00BC  stb r10, 0xbc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 82A6B4E8: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B4EC: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B4F0; continue 'dispatch;
            }
            0x82A6B4F0 => {
    //   block [0x82A6B4F0..0x82A6B558)
	// 82A6B4F0: 894B00D5  lbz r10, 0xd5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(213 as u32) ) } as u64;
	// 82A6B4F4: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A6B4F8: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B4FC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B500: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B504: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B508: 419A0080  beq cr6, 0x82a6b588
	if ctx.cr[6].eq {
	pc = 0x82A6B588; continue 'dispatch;
	}
	// 82A6B50C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B510: 810B00C8  lwz r8, 0xc8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 82A6B514: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B518: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B51C: 409A003C  bne cr6, 0x82a6b558
	if !ctx.cr[6].eq {
	pc = 0x82A6B558; continue 'dispatch;
	}
	// 82A6B520: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B524: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B528: 38CB00C0  addi r6, r11, 0xc0
	ctx.r[6].s64 = ctx.r[11].s64 + 192;
	// 82A6B52C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B530: 912B00C8  stw r9, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 82A6B534: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6B538: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B53C: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A6B540: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B544: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B548: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B54C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B550: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B554: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B558; continue 'dispatch;
            }
            0x82A6B558 => {
    //   block [0x82A6B558..0x82A6B588)
	// 82A6B558: 894B00D4  lbz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A6B55C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6B560: 912B00C4  stw r9, 0xc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 82A6B564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B568: 409A0020  bne cr6, 0x82a6b588
	if !ctx.cr[6].eq {
	pc = 0x82A6B588; continue 'dispatch;
	}
	// 82A6B56C: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B570: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B574: 390B00C0  addi r8, r11, 0xc0
	ctx.r[8].s64 = ctx.r[11].s64 + 192;
	// 82A6B578: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B57C: 994B00D4  stb r10, 0xd4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[10].u8 ) };
	// 82A6B580: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B584: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B588; continue 'dispatch;
            }
            0x82A6B588 => {
    //   block [0x82A6B588..0x82A6B5FC)
	// 82A6B588: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 82A6B58C: 894B0105  lbz r10, 0x105(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(261 as u32) ) } as u64;
	// 82A6B590: 812B00F4  lwz r9, 0xf4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A6B594: 38C8701C  addi r6, r8, 0x701c
	ctx.r[6].s64 = ctx.r[8].s64 + 28700;
	// 82A6B598: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B59C: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B5A0: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B5A4: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6B5A8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B5AC: 419A007C  beq cr6, 0x82a6b628
	if ctx.cr[6].eq {
	pc = 0x82A6B628; continue 'dispatch;
	}
	// 82A6B5B0: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B5B4: 810B00F8  lwz r8, 0xf8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A6B5B8: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B5BC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6B5C0: 409A003C  bne cr6, 0x82a6b5fc
	if !ctx.cr[6].eq {
	pc = 0x82A6B5FC; continue 'dispatch;
	}
	// 82A6B5C4: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B5C8: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B5CC: 386B00F0  addi r3, r11, 0xf0
	ctx.r[3].s64 = ctx.r[11].s64 + 240;
	// 82A6B5D0: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B5D4: 912B00F8  stw r9, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[9].u32 ) };
	// 82A6B5D8: 7C68512E  stwx r3, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82A6B5DC: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B5E0: 812B00F4  lwz r9, 0xf4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A6B5E4: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B5E8: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B5EC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B5F0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B5F4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6B5F8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6B5FC; continue 'dispatch;
            }
            0x82A6B5FC => {
    //   block [0x82A6B5FC..0x82A6B628)
	// 82A6B5FC: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A6B600: 90EB00F4  stw r7, 0xf4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), ctx.r[7].u32 ) };
	// 82A6B604: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B608: 409A0020  bne cr6, 0x82a6b628
	if !ctx.cr[6].eq {
	pc = 0x82A6B628; continue 'dispatch;
	}
	// 82A6B60C: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B610: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B614: 390B00F0  addi r8, r11, 0xf0
	ctx.r[8].s64 = ctx.r[11].s64 + 240;
	// 82A6B618: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B61C: 994B0104  stb r10, 0x104(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 82A6B620: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B624: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B628; continue 'dispatch;
            }
            0x82A6B628 => {
    //   block [0x82A6B628..0x82A6B694)
	// 82A6B628: 894B011D  lbz r10, 0x11d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(285 as u32) ) } as u64;
	// 82A6B62C: 80E60014  lwz r7, 0x14(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6B630: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B634: 812B010C  lwz r9, 0x10c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A6B638: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B63C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6B640: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B644: 419A007C  beq cr6, 0x82a6b6c0
	if ctx.cr[6].eq {
	pc = 0x82A6B6C0; continue 'dispatch;
	}
	// 82A6B648: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B64C: 810B0110  lwz r8, 0x110(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A6B650: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B654: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A6B658: 409A003C  bne cr6, 0x82a6b694
	if !ctx.cr[6].eq {
	pc = 0x82A6B694; continue 'dispatch;
	}
	// 82A6B65C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B660: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B664: 38AB0108  addi r5, r11, 0x108
	ctx.r[5].s64 = ctx.r[11].s64 + 264;
	// 82A6B668: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6B66C: 912B0110  stw r9, 0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[9].u32 ) };
	// 82A6B670: 7CA3512E  stwx r5, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 82A6B674: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B678: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B67C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B680: 812B010C  lwz r9, 0x10c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A6B684: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B688: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B68C: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 82A6B690: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x82A6B694; continue 'dispatch;
            }
            0x82A6B694 => {
    //   block [0x82A6B694..0x82A6B6C0)
	// 82A6B694: 894B011C  lbz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A6B698: 90EB010C  stw r7, 0x10c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), ctx.r[7].u32 ) };
	// 82A6B69C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B6A0: 409A0020  bne cr6, 0x82a6b6c0
	if !ctx.cr[6].eq {
	pc = 0x82A6B6C0; continue 'dispatch;
	}
	// 82A6B6A4: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B6A8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B6AC: 390B0108  addi r8, r11, 0x108
	ctx.r[8].s64 = ctx.r[11].s64 + 264;
	// 82A6B6B0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B6B4: 994B011C  stb r10, 0x11c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), ctx.r[10].u8 ) };
	// 82A6B6B8: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B6BC: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B6C0; continue 'dispatch;
            }
            0x82A6B6C0 => {
    //   block [0x82A6B6C0..0x82A6B728)
	// 82A6B6C0: 894B020D  lbz r10, 0x20d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(525 as u32) ) } as u64;
	// 82A6B6C4: 812B01FC  lwz r9, 0x1fc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(508 as u32) ) } as u64;
	// 82A6B6C8: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B6CC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B6D0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A6B6D4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B6D8: 419A0080  beq cr6, 0x82a6b758
	if ctx.cr[6].eq {
	pc = 0x82A6B758; continue 'dispatch;
	}
	// 82A6B6DC: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B6E0: 810B0200  lwz r8, 0x200(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82A6B6E4: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B6E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B6EC: 409A003C  bne cr6, 0x82a6b728
	if !ctx.cr[6].eq {
	pc = 0x82A6B728; continue 'dispatch;
	}
	// 82A6B6F0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B6F4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B6F8: 38CB01F8  addi r6, r11, 0x1f8
	ctx.r[6].s64 = ctx.r[11].s64 + 504;
	// 82A6B6FC: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B700: 912B0200  stw r9, 0x200(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(512 as u32), ctx.r[9].u32 ) };
	// 82A6B704: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6B708: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B70C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B710: 812B01FC  lwz r9, 0x1fc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(508 as u32) ) } as u64;
	// 82A6B714: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B718: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B71C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B720: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B724: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B728; continue 'dispatch;
            }
            0x82A6B728 => {
    //   block [0x82A6B728..0x82A6B758)
	// 82A6B728: 894B020C  lbz r10, 0x20c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(524 as u32) ) } as u64;
	// 82A6B72C: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82A6B730: 912B01FC  stw r9, 0x1fc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(508 as u32), ctx.r[9].u32 ) };
	// 82A6B734: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B738: 409A0020  bne cr6, 0x82a6b758
	if !ctx.cr[6].eq {
	pc = 0x82A6B758; continue 'dispatch;
	}
	// 82A6B73C: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B740: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B744: 390B01F8  addi r8, r11, 0x1f8
	ctx.r[8].s64 = ctx.r[11].s64 + 504;
	// 82A6B748: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B74C: 994B020C  stb r10, 0x20c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(524 as u32), ctx.r[10].u8 ) };
	// 82A6B750: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B754: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B758; continue 'dispatch;
            }
            0x82A6B758 => {
    //   block [0x82A6B758..0x82A6B7C0)
	// 82A6B758: 894B02B5  lbz r10, 0x2b5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(693 as u32) ) } as u64;
	// 82A6B75C: 812B02A4  lwz r9, 0x2a4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) } as u64;
	// 82A6B760: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B764: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B768: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6B76C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B770: 419A0080  beq cr6, 0x82a6b7f0
	if ctx.cr[6].eq {
	pc = 0x82A6B7F0; continue 'dispatch;
	}
	// 82A6B774: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B778: 810B02A8  lwz r8, 0x2a8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(680 as u32) ) } as u64;
	// 82A6B77C: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B780: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B784: 409A003C  bne cr6, 0x82a6b7c0
	if !ctx.cr[6].eq {
	pc = 0x82A6B7C0; continue 'dispatch;
	}
	// 82A6B788: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B78C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6B790: 38CB02A0  addi r6, r11, 0x2a0
	ctx.r[6].s64 = ctx.r[11].s64 + 672;
	// 82A6B794: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B798: 912B02A8  stw r9, 0x2a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(680 as u32), ctx.r[9].u32 ) };
	// 82A6B79C: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 82A6B7A0: 812B02A4  lwz r9, 0x2a4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(676 as u32) ) } as u64;
	// 82A6B7A4: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B7A8: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B7AC: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B7B0: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B7B4: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B7B8: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B7BC: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B7C0; continue 'dispatch;
            }
            0x82A6B7C0 => {
    //   block [0x82A6B7C0..0x82A6B7F0)
	// 82A6B7C0: 894B02B4  lbz r10, 0x2b4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 82A6B7C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6B7C8: 912B02A4  stw r9, 0x2a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(676 as u32), ctx.r[9].u32 ) };
	// 82A6B7CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B7D0: 409A0020  bne cr6, 0x82a6b7f0
	if !ctx.cr[6].eq {
	pc = 0x82A6B7F0; continue 'dispatch;
	}
	// 82A6B7D4: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6B7D8: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B7DC: 390B02A0  addi r8, r11, 0x2a0
	ctx.r[8].s64 = ctx.r[11].s64 + 672;
	// 82A6B7E0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B7E4: 994B02B4  stb r10, 0x2b4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(692 as u32), ctx.r[10].u8 ) };
	// 82A6B7E8: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B7EC: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6B7F0; continue 'dispatch;
            }
            0x82A6B7F0 => {
    //   block [0x82A6B7F0..0x82A6B85C)
	// 82A6B7F0: 890B029D  lbz r8, 0x29d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(669 as u32) ) } as u64;
	// 82A6B7F4: 812B028C  lwz r9, 0x28c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(652 as u32) ) } as u64;
	// 82A6B7F8: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B7FC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B800: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 82A6B804: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B808: 419A0080  beq cr6, 0x82a6b888
	if ctx.cr[6].eq {
	pc = 0x82A6B888; continue 'dispatch;
	}
	// 82A6B80C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B810: 810B0290  lwz r8, 0x290(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(656 as u32) ) } as u64;
	// 82A6B814: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6B818: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6B81C: 409A0040  bne cr6, 0x82a6b85c
	if !ctx.cr[6].eq {
	pc = 0x82A6B85C; continue 'dispatch;
	}
	// 82A6B820: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B824: 38EB0288  addi r7, r11, 0x288
	ctx.r[7].s64 = ctx.r[11].s64 + 648;
	// 82A6B828: 80CB0290  lwz r6, 0x290(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(656 as u32) ) } as u64;
	// 82A6B82C: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6B830: 7D293378  or r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[6].u64;
	// 82A6B834: 912B0290  stw r9, 0x290(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(656 as u32), ctx.r[9].u32 ) };
	// 82A6B838: 7CE5512E  stwx r7, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 82A6B83C: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B840: 812B028C  lwz r9, 0x28c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(652 as u32) ) } as u64;
	// 82A6B844: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B848: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B84C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B850: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B854: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6B858: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B85C; continue 'dispatch;
            }
            0x82A6B85C => {
    //   block [0x82A6B85C..0x82A6B888)
	// 82A6B85C: 890B029C  lbz r8, 0x29c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) } as u64;
	// 82A6B860: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82A6B864: 912B028C  stw r9, 0x28c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(652 as u32), ctx.r[9].u32 ) };
	// 82A6B868: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A6B86C: 409A001C  bne cr6, 0x82a6b888
	if !ctx.cr[6].eq {
	pc = 0x82A6B888; continue 'dispatch;
	}
	// 82A6B870: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6B874: 9B6B029C  stb r27, 0x29c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), ctx.r[27].u8 ) };
	// 82A6B878: 392B0288  addi r9, r11, 0x288
	ctx.r[9].s64 = ctx.r[11].s64 + 648;
	// 82A6B87C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B880: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B884: 7D2AE12E  stwx r9, r10, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x82A6B888; continue 'dispatch;
            }
            0x82A6B888 => {
    //   block [0x82A6B888..0x82A6B900)
	// 82A6B888: 894B0225  lbz r10, 0x225(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(549 as u32) ) } as u64;
	// 82A6B88C: 3CC08331  lis r6, -0x7ccf
	ctx.r[6].s64 = -2093940736;
	// 82A6B890: 810B0214  lwz r8, 0x214(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(532 as u32) ) } as u64;
	// 82A6B894: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B898: 81266FFC  lwz r9, 0x6ffc(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28668 as u32) ) } as u64;
	// 82A6B89C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B8A0: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82A6B8A4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6B8A8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B8AC: 419A0080  beq cr6, 0x82a6b92c
	if ctx.cr[6].eq {
	pc = 0x82A6B92C; continue 'dispatch;
	}
	// 82A6B8B0: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B8B4: 80EB0218  lwz r7, 0x218(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(536 as u32) ) } as u64;
	// 82A6B8B8: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82A6B8BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B8C0: 409A0040  bne cr6, 0x82a6b900
	if !ctx.cr[6].eq {
	pc = 0x82A6B900; continue 'dispatch;
	}
	// 82A6B8C4: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B8C8: 7D093B78  or r9, r8, r7
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82A6B8CC: 390B0210  addi r8, r11, 0x210
	ctx.r[8].s64 = ctx.r[11].s64 + 528;
	// 82A6B8D0: 54671838  slwi r7, r3, 3
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6B8D4: 912B0218  stw r9, 0x218(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(536 as u32), ctx.r[9].u32 ) };
	// 82A6B8D8: 7D07512E  stwx r8, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82A6B8DC: 812B0214  lwz r9, 0x214(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(532 as u32) ) } as u64;
	// 82A6B8E0: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B8E4: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B8E8: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B8EC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B8F0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B8F4: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82A6B8F8: 81266FFC  lwz r9, 0x6ffc(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28668 as u32) ) } as u64;
	// 82A6B8FC: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B900; continue 'dispatch;
            }
            0x82A6B900 => {
    //   block [0x82A6B900..0x82A6B92C)
	// 82A6B900: 894B0224  lbz r10, 0x224(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(548 as u32) ) } as u64;
	// 82A6B904: 90AB0214  stw r5, 0x214(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(532 as u32), ctx.r[5].u32 ) };
	// 82A6B908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B90C: 409A0020  bne cr6, 0x82a6b92c
	if !ctx.cr[6].eq {
	pc = 0x82A6B92C; continue 'dispatch;
	}
	// 82A6B910: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B914: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B918: 38EB0210  addi r7, r11, 0x210
	ctx.r[7].s64 = ctx.r[11].s64 + 528;
	// 82A6B91C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B920: 994B0224  stb r10, 0x224(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(548 as u32), ctx.r[10].u8 ) };
	// 82A6B924: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B928: 7CE8E12E  stwx r7, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	pc = 0x82A6B92C; continue 'dispatch;
            }
            0x82A6B92C => {
    //   block [0x82A6B92C..0x82A6B99C)
	// 82A6B92C: 894B023D  lbz r10, 0x23d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(573 as u32) ) } as u64;
	// 82A6B930: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82A6B934: 810B022C  lwz r8, 0x22c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(556 as u32) ) } as u64;
	// 82A6B938: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B93C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B940: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6B944: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B948: 419A0080  beq cr6, 0x82a6b9c8
	if ctx.cr[6].eq {
	pc = 0x82A6B9C8; continue 'dispatch;
	}
	// 82A6B94C: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B950: 80EB0230  lwz r7, 0x230(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(560 as u32) ) } as u64;
	// 82A6B954: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82A6B958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B95C: 409A0040  bne cr6, 0x82a6b99c
	if !ctx.cr[6].eq {
	pc = 0x82A6B99C; continue 'dispatch;
	}
	// 82A6B960: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B964: 7D093B78  or r9, r8, r7
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82A6B968: 390B0228  addi r8, r11, 0x228
	ctx.r[8].s64 = ctx.r[11].s64 + 552;
	// 82A6B96C: 54671838  slwi r7, r3, 3
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6B970: 912B0230  stw r9, 0x230(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(560 as u32), ctx.r[9].u32 ) };
	// 82A6B974: 7D07512E  stwx r8, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 82A6B978: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B97C: 812B022C  lwz r9, 0x22c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(556 as u32) ) } as u64;
	// 82A6B980: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B984: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6B988: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6B98C: 81266FFC  lwz r9, 0x6ffc(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28668 as u32) ) } as u64;
	// 82A6B990: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B994: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 82A6B998: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6B99C; continue 'dispatch;
            }
            0x82A6B99C => {
    //   block [0x82A6B99C..0x82A6B9C8)
	// 82A6B99C: 894B023C  lbz r10, 0x23c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(572 as u32) ) } as u64;
	// 82A6B9A0: 90AB022C  stw r5, 0x22c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(556 as u32), ctx.r[5].u32 ) };
	// 82A6B9A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6B9A8: 409A0020  bne cr6, 0x82a6b9c8
	if !ctx.cr[6].eq {
	pc = 0x82A6B9C8; continue 'dispatch;
	}
	// 82A6B9AC: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6B9B0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6B9B4: 38EB0228  addi r7, r11, 0x228
	ctx.r[7].s64 = ctx.r[11].s64 + 552;
	// 82A6B9B8: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6B9BC: 994B023C  stb r10, 0x23c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(572 as u32), ctx.r[10].u8 ) };
	// 82A6B9C0: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6B9C4: 7CE8E12E  stwx r7, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	pc = 0x82A6B9C8; continue 'dispatch;
            }
            0x82A6B9C8 => {
    //   block [0x82A6B9C8..0x82A6BA30)
	// 82A6B9C8: 894B0255  lbz r10, 0x255(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(597 as u32) ) } as u64;
	// 82A6B9CC: 810B0244  lwz r8, 0x244(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(580 as u32) ) } as u64;
	// 82A6B9D0: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6B9D4: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6B9D8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6B9DC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6B9E0: 419A007C  beq cr6, 0x82a6ba5c
	if ctx.cr[6].eq {
	pc = 0x82A6BA5C; continue 'dispatch;
	}
	// 82A6B9E4: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6B9E8: 80EB0248  lwz r7, 0x248(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(584 as u32) ) } as u64;
	// 82A6B9EC: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82A6B9F0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A6B9F4: 409A003C  bne cr6, 0x82a6ba30
	if !ctx.cr[6].eq {
	pc = 0x82A6BA30; continue 'dispatch;
	}
	// 82A6B9F8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6B9FC: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 82A6BA00: 38AB0240  addi r5, r11, 0x240
	ctx.r[5].s64 = ctx.r[11].s64 + 576;
	// 82A6BA04: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6BA08: 910B0248  stw r8, 0x248(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(584 as u32), ctx.r[8].u32 ) };
	// 82A6BA0C: 7CA3512E  stwx r5, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 82A6BA10: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BA14: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6BA18: 810B0244  lwz r8, 0x244(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(580 as u32) ) } as u64;
	// 82A6BA1C: 7CC75214  add r6, r7, r10
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82A6BA20: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A6BA24: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BA28: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 82A6BA2C: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x82A6BA30; continue 'dispatch;
            }
            0x82A6BA30 => {
    //   block [0x82A6BA30..0x82A6BA5C)
	// 82A6BA30: 894B0254  lbz r10, 0x254(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 82A6BA34: 912B0244  stw r9, 0x244(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(580 as u32), ctx.r[9].u32 ) };
	// 82A6BA38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6BA3C: 409A0020  bne cr6, 0x82a6ba5c
	if !ctx.cr[6].eq {
	pc = 0x82A6BA5C; continue 'dispatch;
	}
	// 82A6BA40: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6BA44: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6BA48: 390B0240  addi r8, r11, 0x240
	ctx.r[8].s64 = ctx.r[11].s64 + 576;
	// 82A6BA4C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6BA50: 994B0254  stb r10, 0x254(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(596 as u32), ctx.r[10].u8 ) };
	// 82A6BA54: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6BA58: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6BA5C; continue 'dispatch;
            }
            0x82A6BA5C => {
    //   block [0x82A6BA5C..0x82A6BAD0)
	// 82A6BA5C: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 82A6BA60: 88EB026D  lbz r7, 0x26d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(621 as u32) ) } as u64;
	// 82A6BA64: 812B025C  lwz r9, 0x25c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 82A6BA68: 38C86F8C  addi r6, r8, 0x6f8c
	ctx.r[6].s64 = ctx.r[8].s64 + 28556;
	// 82A6BA6C: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6BA70: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6BA74: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6BA78: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6BA7C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6BA80: 419A007C  beq cr6, 0x82a6bafc
	if ctx.cr[6].eq {
	pc = 0x82A6BAFC; continue 'dispatch;
	}
	// 82A6BA84: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6BA88: 810B0260  lwz r8, 0x260(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(608 as u32) ) } as u64;
	// 82A6BA8C: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6BA90: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A6BA94: 409A003C  bne cr6, 0x82a6bad0
	if !ctx.cr[6].eq {
	pc = 0x82A6BAD0; continue 'dispatch;
	}
	// 82A6BA98: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BA9C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6BAA0: 38AB0258  addi r5, r11, 0x258
	ctx.r[5].s64 = ctx.r[11].s64 + 600;
	// 82A6BAA4: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6BAA8: 912B0260  stw r9, 0x260(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(608 as u32), ctx.r[9].u32 ) };
	// 82A6BAAC: 7CA3512E  stwx r5, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 82A6BAB0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BAB4: 812B025C  lwz r9, 0x25c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 82A6BAB8: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6BABC: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6BAC0: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6BAC4: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BAC8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 82A6BACC: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x82A6BAD0; continue 'dispatch;
            }
            0x82A6BAD0 => {
    //   block [0x82A6BAD0..0x82A6BAFC)
	// 82A6BAD0: 894B026C  lbz r10, 0x26c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 82A6BAD4: 90EB025C  stw r7, 0x25c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(604 as u32), ctx.r[7].u32 ) };
	// 82A6BAD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6BADC: 409A0020  bne cr6, 0x82a6bafc
	if !ctx.cr[6].eq {
	pc = 0x82A6BAFC; continue 'dispatch;
	}
	// 82A6BAE0: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6BAE4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6BAE8: 390B0258  addi r8, r11, 0x258
	ctx.r[8].s64 = ctx.r[11].s64 + 600;
	// 82A6BAEC: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6BAF0: 994B026C  stb r10, 0x26c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(620 as u32), ctx.r[10].u8 ) };
	// 82A6BAF4: 909D0DB0  stw r4, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6BAF8: 7D09E12E  stwx r8, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[8].u32) };
	pc = 0x82A6BAFC; continue 'dispatch;
            }
            0x82A6BAFC => {
    //   block [0x82A6BAFC..0x82A6BB68)
	// 82A6BAFC: 890B029D  lbz r8, 0x29d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(669 as u32) ) } as u64;
	// 82A6BB00: 812B028C  lwz r9, 0x28c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(652 as u32) ) } as u64;
	// 82A6BB04: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6BB08: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6BB0C: 2B090030  cmplwi cr6, r9, 0x30
	ctx.cr[6].compare_u32(ctx.r[9].u32, 48 as u32, &mut ctx.xer);
	// 82A6BB10: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6BB14: 419A0084  beq cr6, 0x82a6bb98
	if ctx.cr[6].eq {
	pc = 0x82A6BB98; continue 'dispatch;
	}
	// 82A6BB18: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6BB1C: 810B0290  lwz r8, 0x290(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(656 as u32) ) } as u64;
	// 82A6BB20: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6BB24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6BB28: 409A0040  bne cr6, 0x82a6bb68
	if !ctx.cr[6].eq {
	pc = 0x82A6BB68; continue 'dispatch;
	}
	// 82A6BB2C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BB30: 38EB0288  addi r7, r11, 0x288
	ctx.r[7].s64 = ctx.r[11].s64 + 648;
	// 82A6BB34: 80CB0290  lwz r6, 0x290(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(656 as u32) ) } as u64;
	// 82A6BB38: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6BB3C: 7D293378  or r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[6].u64;
	// 82A6BB40: 912B0290  stw r9, 0x290(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(656 as u32), ctx.r[9].u32 ) };
	// 82A6BB44: 7CE5512E  stwx r7, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 82A6BB48: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BB4C: 812B028C  lwz r9, 0x28c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(652 as u32) ) } as u64;
	// 82A6BB50: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6BB54: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6BB58: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6BB5C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6BB60: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 82A6BB64: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x82A6BB68; continue 'dispatch;
            }
            0x82A6BB68 => {
    //   block [0x82A6BB68..0x82A6BB98)
	// 82A6BB68: 890B029C  lbz r8, 0x29c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) } as u64;
	// 82A6BB6C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82A6BB70: 914B028C  stw r10, 0x28c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(652 as u32), ctx.r[10].u32 ) };
	// 82A6BB74: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A6BB78: 409A0020  bne cr6, 0x82a6bb98
	if !ctx.cr[6].eq {
	pc = 0x82A6BB98; continue 'dispatch;
	}
	// 82A6BB7C: 5488103A  slwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6BB80: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82A6BB84: 38EB0288  addi r7, r11, 0x288
	ctx.r[7].s64 = ctx.r[11].s64 + 648;
	// 82A6BB88: 39240001  addi r9, r4, 1
	ctx.r[9].s64 = ctx.r[4].s64 + 1;
	// 82A6BB8C: 994B029C  stb r10, 0x29c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(668 as u32), ctx.r[10].u8 ) };
	// 82A6BB90: 913D0DB0  stw r9, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 82A6BB94: 7CE8E12E  stwx r7, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	pc = 0x82A6BB98; continue 'dispatch;
            }
            0x82A6BB98 => {
    //   block [0x82A6BB98..0x82A6BBA0)
	// 82A6BB98: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A6BB9C: 4823D8B4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6BBA0 size=988
    let mut pc: u32 = 0x82A6BBA0;
    'dispatch: loop {
        match pc {
            0x82A6BBA0 => {
    //   block [0x82A6BBA0..0x82A6BF6C)
	// 82A6BBA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BBA4: 4823D845  bl 0x82ca93e8
	ctx.lr = 0x82A6BBA8;
	sub_82CA93D0(ctx, base);
	// 82A6BBA8: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82A6BBAC: 48242129  bl 0x82cadcd4
	ctx.lr = 0x82A6BBB0;
	sub_82CADCA0(ctx, base);
	// 82A6BBB0: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BBB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6BBB8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82A6BBBC: 3A8B0FF0  addi r20, r11, 0xff0
	ctx.r[20].s64 = ctx.r[11].s64 + 4080;
	// 82A6BBC0: 38A79484  addi r5, r7, -0x6b7c
	ctx.r[5].s64 = ctx.r[7].s64 + -27516;
	// 82A6BBC4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A6BBC8: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 82A6BBCC: C3879484  lfs f28, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A6BBD0: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 82A6BBD4: 80D40004  lwz r6, 4(r20)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6BBD8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A6BBDC: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 82A6BBE0: C365FE50  lfs f27, -0x1b0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-432 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82A6BBE4: C3E5000C  lfs f31, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6BBE8: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82A6BBEC: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 82A6BBF0: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82A6BBF4: 83260000  lwz r25, 0(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6BBF8: 3B4B0DB8  addi r26, r11, 0xdb8
	ctx.r[26].s64 = ctx.r[11].s64 + 3512;
	// 82A6BBFC: 3B6A2390  addi r27, r10, 0x2390
	ctx.r[27].s64 = ctx.r[10].s64 + 9104;
	// 82A6BC00: 3BE963A0  addi r31, r9, 0x63a0
	ctx.r[31].s64 = ctx.r[9].s64 + 25504;
	// 82A6BC04: 3AC89190  addi r22, r8, -0x6e70
	ctx.r[22].s64 = ctx.r[8].s64 + -28272;
	// 82A6BC08: 3B0791A0  addi r24, r7, -0x6e60
	ctx.r[24].s64 = ctx.r[7].s64 + -28256;
	// 82A6BC0C: 7F193040  cmplw cr6, r25, r6
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A6BC10: 419A035C  beq cr6, 0x82a6bf6c
	if ctx.cr[6].eq {
	pc = 0x82A6BF6C; continue 'dispatch;
	}
	// 82A6BC14: 389506B0  addi r4, r21, 0x6b0
	ctx.r[4].s64 = ctx.r[21].s64 + 1712;
	// 82A6BC18: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A6BC1C: 3BB90008  addi r29, r25, 8
	ctx.r[29].s64 = ctx.r[25].s64 + 8;
	// 82A6BC20: 4B736871  bl 0x821a2490
	ctx.lr = 0x82A6BC24;
	sub_821A2490(ctx, base);
	// 82A6BC24: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82A6BC28: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A6BC2C: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6BC30: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A6BC34: D3610050  stfs f27, 0x50(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A6BC38: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	pc = 0x82A6BF6C; continue 'dispatch;
            }
            0x82A6BF6C => {
    //   block [0x82A6BF6C..0x82A6BF7C)
	// 82A6BF6C: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82A6BF70: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82A6BF74: 48241DAD  bl 0x82cadd20
	ctx.lr = 0x82A6BF78;
	sub_82CADCEC(ctx, base);
	// 82A6BF78: 4823D4C0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6BF80 size=236
    let mut pc: u32 = 0x82A6BF80;
    'dispatch: loop {
        match pc {
            0x82A6BF80 => {
    //   block [0x82A6BF80..0x82A6BFB8)
	// 82A6BF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BF84: 4823D47D  bl 0x82ca9400
	ctx.lr = 0x82A6BF88;
	sub_82CA93D0(ctx, base);
	// 82A6BF88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BF8C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A6BF90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BF94: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6BF98: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A6BF9C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A6BFA0: 835B0004  lwz r26, 4(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6BFA4: 4B7B32B5  bl 0x8221f258
	ctx.lr = 0x82A6BFA8;
	sub_8221F258(ctx, base);
	// 82A6BFA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BFAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6BFB0: 419A0008  beq cr6, 0x82a6bfb8
	if ctx.cr[6].eq {
	pc = 0x82A6BFB8; continue 'dispatch;
	}
	// 82A6BFB4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82A6BFB8; continue 'dispatch;
            }
            0x82A6BFB8 => {
    //   block [0x82A6BFB8..0x82A6BFC8)
	// 82A6BFB8: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A6BFBC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6BFC0: 419A0008  beq cr6, 0x82a6bfc8
	if ctx.cr[6].eq {
	pc = 0x82A6BFC8; continue 'dispatch;
	}
	// 82A6BFC4: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82A6BFC8; continue 'dispatch;
            }
            0x82A6BFC8 => {
    //   block [0x82A6BFC8..0x82A6BFF0)
	// 82A6BFC8: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6BFCC: 41820024  beq 0x82a6bff0
	if ctx.cr[0].eq {
	pc = 0x82A6BFF0; continue 'dispatch;
	}
	// 82A6BFD0: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6BFD4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A6BFD8: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6BFDC: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A6BFE0: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6BFE4: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A6BFE8: C17C000C  lfs f11, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6BFEC: D16B000C  stfs f11, 0xc(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82A6BFF0; continue 'dispatch;
            }
            0x82A6BFF0 => {
    //   block [0x82A6BFF0..0x82A6C04C)
	// 82A6BFF0: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82A6BFF4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6BFF8: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82A6BFFC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A6C000: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82A6C004: 40980048  bge cr6, 0x82a6c04c
	if !ctx.cr[6].lt {
	pc = 0x82A6C04C; continue 'dispatch;
	}
	// 82A6C008: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A6C00C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C010: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82A6C014: 4B885F2D  bl 0x822f1f40
	ctx.lr = 0x82A6C018;
	sub_822F1F40(ctx, base);
	// 82A6C018: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C01C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C020: 4B885D91  bl 0x822f1db0
	ctx.lr = 0x82A6C024;
	sub_822F1DB0(ctx, base);
	// 82A6C024: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A6C028: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C02C: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 82A6C030: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82A6C034: 4B885DED  bl 0x822f1e20
	ctx.lr = 0x82A6C038;
	sub_822F1E20(ctx, base);
	// 82A6C038: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82A6C03C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C040: 4BC0F7A1  bl 0x8267b7e0
	ctx.lr = 0x82A6C044;
	sub_8267B7E0(ctx, base);
	// 82A6C044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C048: 4B7057C9  bl 0x82171810
	ctx.lr = 0x82A6C04C;
	sub_82171810(ctx, base);
	pc = 0x82A6C04C; continue 'dispatch;
            }
            0x82A6C04C => {
    //   block [0x82A6C04C..0x82A6C06C)
	// 82A6C04C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C050: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A6C054: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A6C058: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A6C05C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C060: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6C064: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A6C068: 4823D3E8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6C070 size=148
    let mut pc: u32 = 0x82A6C070;
    'dispatch: loop {
        match pc {
            0x82A6C070 => {
    //   block [0x82A6C070..0x82A6C0A8)
	// 82A6C070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C074: 4823D38D  bl 0x82ca9400
	ctx.lr = 0x82A6C078;
	sub_82CA93D0(ctx, base);
	// 82A6C078: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C07C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A6C080: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A6C084: 836100AC  lwz r27, 0xac(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A6C088: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A6C08C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A6C090: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C094: 4B7B31C5  bl 0x8221f258
	ctx.lr = 0x82A6C098;
	sub_8221F258(ctx, base);
	// 82A6C098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C09C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6C0A0: 419A0008  beq cr6, 0x82a6c0a8
	if ctx.cr[6].eq {
	pc = 0x82A6C0A8; continue 'dispatch;
	}
	// 82A6C0A4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82A6C0A8; continue 'dispatch;
            }
            0x82A6C0A8 => {
    //   block [0x82A6C0A8..0x82A6C0B8)
	// 82A6C0A8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A6C0AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6C0B0: 419A0008  beq cr6, 0x82a6c0b8
	if ctx.cr[6].eq {
	pc = 0x82A6C0B8; continue 'dispatch;
	}
	// 82A6C0B4: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6C0B8; continue 'dispatch;
            }
            0x82A6C0B8 => {
    //   block [0x82A6C0B8..0x82A6C0E4)
	// 82A6C0B8: 37DF0008  addic. r30, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6C0BC: 41820028  beq 0x82a6c0e4
	if ctx.cr[0].eq {
	pc = 0x82A6C0E4; continue 'dispatch;
	}
	// 82A6C0C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6C0C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6C0C8: 48000391  bl 0x82a6c458
	ctx.lr = 0x82A6C0CC;
	sub_82A6C458(ctx, base);
	// 82A6C0CC: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6C0D0: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A6C0D4: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6C0D8: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A6C0DC: 813C0014  lwz r9, 0x14(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6C0E0: 913E0014  stw r9, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6C0E4; continue 'dispatch;
            }
            0x82A6C0E4 => {
    //   block [0x82A6C0E4..0x82A6C104)
	// 82A6C0E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6C0E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6C0EC: 4800001D  bl 0x82a6c108
	ctx.lr = 0x82A6C0F0;
	sub_82A6C108(ctx, base);
	// 82A6C0F0: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A6C0F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C0F8: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6C0FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A6C100: 4823D350  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6C108 size=132
    let mut pc: u32 = 0x82A6C108;
    'dispatch: loop {
        match pc {
            0x82A6C108 => {
    //   block [0x82A6C108..0x82A6C178)
	// 82A6C108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C10C: 4823D301  bl 0x82ca940c
	ctx.lr = 0x82A6C110;
	sub_82CA93D0(ctx, base);
	// 82A6C110: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C118: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 82A6C11C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6C120: 6169AAAA  ori r9, r11, 0xaaaa
	ctx.r[9].u64 = ctx.r[11].u64 | 43690;
	// 82A6C124: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C128: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A6C12C: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A6C130: 40980048  bge cr6, 0x82a6c178
	if !ctx.cr[6].lt {
	pc = 0x82A6C178; continue 'dispatch;
	}
	// 82A6C134: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A6C138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C13C: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82A6C140: 4B885E01  bl 0x822f1f40
	ctx.lr = 0x82A6C144;
	sub_822F1F40(ctx, base);
	// 82A6C144: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C148: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C14C: 4B885C65  bl 0x822f1db0
	ctx.lr = 0x82A6C150;
	sub_822F1DB0(ctx, base);
	// 82A6C150: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A6C154: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C158: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82A6C15C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A6C160: 4B885CC1  bl 0x822f1e20
	ctx.lr = 0x82A6C164;
	sub_822F1E20(ctx, base);
	// 82A6C164: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A6C168: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C16C: 4BC0F675  bl 0x8267b7e0
	ctx.lr = 0x82A6C170;
	sub_8267B7E0(ctx, base);
	// 82A6C170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C174: 4B70569D  bl 0x82171810
	ctx.lr = 0x82A6C178;
	sub_82171810(ctx, base);
	pc = 0x82A6C178; continue 'dispatch;
            }
            0x82A6C178 => {
    //   block [0x82A6C178..0x82A6C18C)
	// 82A6C178: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C17C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A6C180: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A6C184: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A6C188: 4823D2D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6C190 size=712
    let mut pc: u32 = 0x82A6C190;
    'dispatch: loop {
        match pc {
            0x82A6C190 => {
    //   block [0x82A6C190..0x82A6C1CC)
	// 82A6C190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C194: 4823D269  bl 0x82ca93fc
	ctx.lr = 0x82A6C198;
	sub_82CA93D0(ctx, base);
	// 82A6C198: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C19C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6C1A0: 3D4082A7  lis r10, -0x7d59
	ctx.r[10].s64 = -2102984704;
	// 82A6C1A4: 3B6B0FF0  addi r27, r11, 0xff0
	ctx.r[27].s64 = ctx.r[11].s64 + 4080;
	// 82A6C1A8: 3B4A9B90  addi r26, r10, -0x6470
	ctx.r[26].s64 = ctx.r[10].s64 + -25712;
	// 82A6C1AC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C1B0: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82A6C1B4: 4198029C  blt cr6, 0x82a6c450
	if ctx.cr[6].lt {
	pc = 0x82A6C450; continue 'dispatch;
	}
	// 82A6C1B8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A6C1BC: 4B7B309D  bl 0x8221f258
	ctx.lr = 0x82A6C1C0;
	sub_8221F258(ctx, base);
	// 82A6C1C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6C1C4: 419A0008  beq cr6, 0x82a6c1cc
	if ctx.cr[6].eq {
	pc = 0x82A6C1CC; continue 'dispatch;
	}
	// 82A6C1C8: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6C1CC; continue 'dispatch;
            }
            0x82A6C1CC => {
    //   block [0x82A6C1CC..0x82A6C1D8)
	// 82A6C1CC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C1D0: 41820008  beq 0x82a6c1d8
	if ctx.cr[0].eq {
	pc = 0x82A6C1D8; continue 'dispatch;
	}
	// 82A6C1D4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6C1D8; continue 'dispatch;
            }
            0x82A6C1D8 => {
    //   block [0x82A6C1D8..0x82A6C1F0)
	// 82A6C1D8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A6C1DC: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A6C1E0: 3BA00019  li r29, 0x19
	ctx.r[29].s64 = 25;
	// 82A6C1E4: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82A6C1E8: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	// 82A6C1EC: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82A6C1F0; continue 'dispatch;
            }
            0x82A6C1F0 => {
    //   block [0x82A6C1F0..0x82A6C220)
	// 82A6C1F0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A6C1F4: 4B7B30CD  bl 0x8221f2c0
	ctx.lr = 0x82A6C1F8;
	sub_8221F2C0(ctx, base);
	// 82A6C1F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6C1FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6C200: 409A0028  bne cr6, 0x82a6c228
	if !ctx.cr[6].eq {
	pc = 0x82A6C228; continue 'dispatch;
	}
	// 82A6C204: 817C6F6C  lwz r11, 0x6f6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A6C208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6C20C: 419A0014  beq cr6, 0x82a6c220
	if ctx.cr[6].eq {
	pc = 0x82A6C220; continue 'dispatch;
	}
	// 82A6C210: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6C214: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6C218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6C21C: 4E800421  bctrl
	ctx.lr = 0x82A6C220;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6C220 => {
    //   block [0x82A6C220..0x82A6C228)
	// 82A6C220: 48256189  bl 0x82cc23a8
	ctx.lr = 0x82A6C224;
	sub_82CC23A8(ctx, base);
	// 82A6C224: 48000008  b 0x82a6c22c
	pc = 0x82A6C22C; continue 'dispatch;
            }
            0x82A6C228 => {
    //   block [0x82A6C228..0x82A6C22C)
	// 82A6C228: 93DE0000  stw r30, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6C22C; continue 'dispatch;
            }
            0x82A6C22C => {
    //   block [0x82A6C22C..0x82A6C238)
	// 82A6C22C: 357E0004  addic. r11, r30, 4
	ctx.xer.ca = (ctx.r[30].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C230: 41820008  beq 0x82a6c238
	if ctx.cr[0].eq {
	pc = 0x82A6C238; continue 'dispatch;
	}
	// 82A6C234: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6C238; continue 'dispatch;
            }
            0x82A6C238 => {
    //   block [0x82A6C238..0x82A6C26C)
	// 82A6C238: 93DFFFFC  stw r30, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 82A6C23C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6C240: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82A6C244: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A6C248: 4080FFA8  bge 0x82a6c1f0
	if !ctx.cr[0].lt {
	pc = 0x82A6C1F0; continue 'dispatch;
	}
	// 82A6C24C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C250: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A6C254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6C258: 419A0128  beq cr6, 0x82a6c380
	if ctx.cr[6].eq {
	pc = 0x82A6C380; continue 'dispatch;
	}
	// 82A6C25C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A6C260: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A6C264: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82A6C268: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82A6C26C; continue 'dispatch;
            }
            0x82A6C26C => {
    //   block [0x82A6C26C..0x82A6C280)
	// 82A6C26C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C270: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C274: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6C278: 409A0008  bne cr6, 0x82a6c280
	if !ctx.cr[6].eq {
	pc = 0x82A6C280; continue 'dispatch;
	}
	// 82A6C27C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C280; continue 'dispatch;
            }
            0x82A6C280 => {
    //   block [0x82A6C280..0x82A6C2CC)
	// 82A6C280: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6C284: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A6C288: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C28C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6C290: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C294: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A6C298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C29C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C2A0: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 82A6C2A4: 90C10074  stw r6, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[6].u32 ) };
	// 82A6C2A8: E8E10070  ld r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A6C2AC: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A6C2B0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6C2B4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A6C2B8: 48000281  bl 0x82a6c538
	ctx.lr = 0x82A6C2BC;
	sub_82A6C538(ctx, base);
	// 82A6C2BC: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82A6C2C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6C2C4: 419A0070  beq cr6, 0x82a6c334
	if ctx.cr[6].eq {
	pc = 0x82A6C334; continue 'dispatch;
	}
	// 82A6C2C8: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	pc = 0x82A6C2CC; continue 'dispatch;
            }
            0x82A6C2CC => {
    //   block [0x82A6C2CC..0x82A6C318)
	// 82A6C2CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C2D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6C2D4: 419A0044  beq cr6, 0x82a6c318
	if ctx.cr[6].eq {
	pc = 0x82A6C318; continue 'dispatch;
	}
	// 82A6C2D8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A6C2DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C2E0: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 82A6C2E4: 480002ED  bl 0x82a6c5d0
	ctx.lr = 0x82A6C2E8;
	sub_82A6C5D0(ctx, base);
	// 82A6C2E8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A6C2EC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6C2F0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A6C2F4: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A6C2F8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A6C2FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6C300: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82A6C304: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C308: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6C30C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A6C310: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6C314: 4198FFB8  blt cr6, 0x82a6c2cc
	if ctx.cr[6].lt {
	pc = 0x82A6C2CC; continue 'dispatch;
	}
	pc = 0x82A6C318; continue 'dispatch;
            }
            0x82A6C318 => {
    //   block [0x82A6C318..0x82A6C334)
	// 82A6C318: 2B1E0019  cmplwi cr6, r30, 0x19
	ctx.cr[6].compare_u32(ctx.r[30].u32, 25 as u32, &mut ctx.xer);
	// 82A6C31C: 409A0018  bne cr6, 0x82a6c334
	if !ctx.cr[6].eq {
	pc = 0x82A6C334; continue 'dispatch;
	}
	// 82A6C320: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A6C324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C328: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82A6C32C: 480002A5  bl 0x82a6c5d0
	ctx.lr = 0x82A6C330;
	sub_82A6C5D0(ctx, base);
	// 82A6C330: 48000044  b 0x82a6c374
	pc = 0x82A6C374; continue 'dispatch;
            }
            0x82A6C334 => {
    //   block [0x82A6C334..0x82A6C374)
	// 82A6C334: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6C338: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6C33C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A6C340: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A6C344: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A6C348: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A6C34C: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6C350: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A6C354: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C358: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6C35C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A6C360: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C364: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A6C368: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 82A6C36C: 409A0008  bne cr6, 0x82a6c374
	if !ctx.cr[6].eq {
	pc = 0x82A6C374; continue 'dispatch;
	}
	// 82A6C370: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	pc = 0x82A6C374; continue 'dispatch;
            }
            0x82A6C374 => {
    //   block [0x82A6C374..0x82A6C380)
	// 82A6C374: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6C37C: 409AFEF0  bne cr6, 0x82a6c26c
	if !ctx.cr[6].eq {
	pc = 0x82A6C26C; continue 'dispatch;
	}
	pc = 0x82A6C380; continue 'dispatch;
            }
            0x82A6C380 => {
    //   block [0x82A6C380..0x82A6C390)
	// 82A6C380: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 82A6C384: 40990028  ble cr6, 0x82a6c3ac
	if !ctx.cr[6].gt {
	pc = 0x82A6C3AC; continue 'dispatch;
	}
	// 82A6C388: 3BE1008C  addi r31, r1, 0x8c
	ctx.r[31].s64 = ctx.r[1].s64 + 140;
	// 82A6C38C: 3BDDFFFF  addi r30, r29, -1
	ctx.r[30].s64 = ctx.r[29].s64 + -1;
	pc = 0x82A6C390; continue 'dispatch;
            }
            0x82A6C390 => {
    //   block [0x82A6C390..0x82A6C3AC)
	// 82A6C390: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A6C394: 389FFFF4  addi r4, r31, -0xc
	ctx.r[4].s64 = ctx.r[31].s64 + -12;
	// 82A6C398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C39C: 48000235  bl 0x82a6c5d0
	ctx.lr = 0x82A6C3A0;
	sub_82A6C5D0(ctx, base);
	// 82A6C3A0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6C3A4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A6C3A8: 4082FFE8  bne 0x82a6c390
	if !ctx.cr[0].eq {
	pc = 0x82A6C390; continue 'dispatch;
	}
	pc = 0x82A6C3AC; continue 'dispatch;
            }
            0x82A6C3AC => {
    //   block [0x82A6C3AC..0x82A6C418)
	// 82A6C3AC: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6C3B0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C3B4: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82A6C3B8: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82A6C3BC: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82A6C3C0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6C3C4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C3C8: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A6C3CC: 38ABFFF4  addi r5, r11, -0xc
	ctx.r[5].s64 = ctx.r[11].s64 + -12;
	// 82A6C3D0: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82A6C3D4: 7F1B2840  cmplw cr6, r27, r5
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A6C3D8: 419A0040  beq cr6, 0x82a6c418
	if ctx.cr[6].eq {
	pc = 0x82A6C418; continue 'dispatch;
	}
	// 82A6C3DC: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C3E0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A6C3E4: 419A0034  beq cr6, 0x82a6c418
	if ctx.cr[6].eq {
	pc = 0x82A6C418; continue 'dispatch;
	}
	// 82A6C3E8: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C3EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A6C3F0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6C3F4: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 82A6C3F8: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 82A6C3FC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A6C400: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C404: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A6C408: E8E10068  ld r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A6C40C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82A6C410: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A6C414: 48000125  bl 0x82a6c538
	ctx.lr = 0x82A6C418;
	sub_82A6C538(ctx, base);
	pc = 0x82A6C418; continue 'dispatch;
            }
            0x82A6C418 => {
    //   block [0x82A6C418..0x82A6C420)
	// 82A6C418: 3BC00019  li r30, 0x19
	ctx.r[30].s64 = 25;
	// 82A6C41C: 3BE101BC  addi r31, r1, 0x1bc
	ctx.r[31].s64 = ctx.r[1].s64 + 444;
	pc = 0x82A6C420; continue 'dispatch;
            }
            0x82A6C420 => {
    //   block [0x82A6C420..0x82A6C450)
	// 82A6C420: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 82A6C424: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82A6C428: 4B710A51  bl 0x8217ce78
	ctx.lr = 0x82A6C42C;
	sub_8217CE78(ctx, base);
	// 82A6C42C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C430: 4B7AF909  bl 0x8221bd38
	ctx.lr = 0x82A6C434;
	sub_8221BD38(ctx, base);
	// 82A6C434: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6C438: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82A6C43C: 4080FFE4  bge 0x82a6c420
	if !ctx.cr[0].lt {
	pc = 0x82A6C420; continue 'dispatch;
	}
	// 82A6C440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C444: 4B710A35  bl 0x8217ce78
	ctx.lr = 0x82A6C448;
	sub_8217CE78(ctx, base);
	// 82A6C448: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6C44C: 4B7AF8ED  bl 0x8221bd38
	ctx.lr = 0x82A6C450;
	sub_8221BD38(ctx, base);
	pc = 0x82A6C450; continue 'dispatch;
            }
            0x82A6C450 => {
    //   block [0x82A6C450..0x82A6C458)
	// 82A6C450: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A6C454: 4823CFF8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6C458 size=220
    let mut pc: u32 = 0x82A6C458;
    'dispatch: loop {
        match pc {
            0x82A6C458 => {
    //   block [0x82A6C458..0x82A6C480)
	// 82A6C458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C45C: 4823CFA5  bl 0x82ca9400
	ctx.lr = 0x82A6C460;
	sub_82CA93D0(ctx, base);
	// 82A6C460: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C464: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6C468: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A6C46C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82A6C470: 4B7B2DE9  bl 0x8221f258
	ctx.lr = 0x82A6C474;
	sub_8221F258(ctx, base);
	// 82A6C474: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6C478: 419A0008  beq cr6, 0x82a6c480
	if ctx.cr[6].eq {
	pc = 0x82A6C480; continue 'dispatch;
	}
	// 82A6C47C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6C480; continue 'dispatch;
            }
            0x82A6C480 => {
    //   block [0x82A6C480..0x82A6C48C)
	// 82A6C480: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C484: 41820008  beq 0x82a6c48c
	if ctx.cr[0].eq {
	pc = 0x82A6C48C; continue 'dispatch;
	}
	// 82A6C488: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6C48C; continue 'dispatch;
            }
            0x82A6C48C => {
    //   block [0x82A6C48C..0x82A6C4C8)
	// 82A6C48C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6C490: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A6C494: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A6C498: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A6C49C: 837A0004  lwz r27, 4(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C4A0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C4A4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A6C4A8: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C4AC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A6C4B0: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A6C4B4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A6C4B8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A6C4BC: EB810058  ld r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A6C4C0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6C4C4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A6C4C8; continue 'dispatch;
            }
            0x82A6C4C8 => {
    //   block [0x82A6C4C8..0x82A6C4D8)
	// 82A6C4C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6C4CC: 419A000C  beq cr6, 0x82a6c4d8
	if ctx.cr[6].eq {
	pc = 0x82A6C4D8; continue 'dispatch;
	}
	// 82A6C4D0: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A6C4D4: 419A0008  beq cr6, 0x82a6c4dc
	if ctx.cr[6].eq {
	pc = 0x82A6C4DC; continue 'dispatch;
	}
	pc = 0x82A6C4D8; continue 'dispatch;
            }
            0x82A6C4D8 => {
    //   block [0x82A6C4D8..0x82A6C4DC)
	// 82A6C4D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C4DC; continue 'dispatch;
            }
            0x82A6C4DC => {
    //   block [0x82A6C4DC..0x82A6C4F0)
	// 82A6C4DC: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A6C4E0: 419A0048  beq cr6, 0x82a6c528
	if ctx.cr[6].eq {
	pc = 0x82A6C528; continue 'dispatch;
	}
	// 82A6C4E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6C4E8: 409A0008  bne cr6, 0x82a6c4f0
	if !ctx.cr[6].eq {
	pc = 0x82A6C4F0; continue 'dispatch;
	}
	// 82A6C4EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C4F0; continue 'dispatch;
            }
            0x82A6C4F0 => {
    //   block [0x82A6C4F0..0x82A6C500)
	// 82A6C4F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C4F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6C4F8: 409A0008  bne cr6, 0x82a6c500
	if !ctx.cr[6].eq {
	pc = 0x82A6C500; continue 'dispatch;
	}
	// 82A6C4FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C500; continue 'dispatch;
            }
            0x82A6C500 => {
    //   block [0x82A6C500..0x82A6C520)
	// 82A6C500: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82A6C504: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6C508: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6C50C: 4BFFFA75  bl 0x82a6bf80
	ctx.lr = 0x82A6C510;
	sub_82A6BF80(ctx, base);
	// 82A6C510: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6C518: 409A0008  bne cr6, 0x82a6c520
	if !ctx.cr[6].eq {
	pc = 0x82A6C520; continue 'dispatch;
	}
	// 82A6C51C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C520; continue 'dispatch;
            }
            0x82A6C520 => {
    //   block [0x82A6C520..0x82A6C528)
	// 82A6C520: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C524: 4BFFFFA4  b 0x82a6c4c8
	pc = 0x82A6C4C8; continue 'dispatch;
            }
            0x82A6C528 => {
    //   block [0x82A6C528..0x82A6C534)
	// 82A6C528: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6C52C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6C530: 4823CF20  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6C538 size=152
    let mut pc: u32 = 0x82A6C538;
    'dispatch: loop {
        match pc {
            0x82A6C538 => {
    //   block [0x82A6C538..0x82A6C57C)
	// 82A6C538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6C540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6C544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6C548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C54C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A6C550: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 82A6C554: F8C10098  std r6, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u64 ) };
	// 82A6C558: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82A6C55C: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 82A6C560: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A6C564: 419A0018  beq cr6, 0x82a6c57c
	if ctx.cr[6].eq {
	pc = 0x82A6C57C; continue 'dispatch;
	}
	// 82A6C568: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6C56C: 4BFFFB9D  bl 0x82a6c108
	ctx.lr = 0x82A6C570;
	sub_82A6C108(ctx, base);
	// 82A6C570: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C574: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A6C578: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82A6C57C; continue 'dispatch;
            }
            0x82A6C57C => {
    //   block [0x82A6C57C..0x82A6C5D0)
	// 82A6C57C: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A6C580: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A6C584: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A6C588: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C58C: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6C590: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C594: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6C598: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C59C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6C5A0: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C5A4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C5A8: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A6C5AC: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C5B0: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A6C5B4: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A6C5B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6C5BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6C5C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6C5C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6C5C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6C5CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6C5D0 size=368
    let mut pc: u32 = 0x82A6C5D0;
    'dispatch: loop {
        match pc {
            0x82A6C5D0 => {
    //   block [0x82A6C5D0..0x82A6C628)
	// 82A6C5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C5D4: 4823CE2D  bl 0x82ca9400
	ctx.lr = 0x82A6C5D8;
	sub_82CA93D0(ctx, base);
	// 82A6C5D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C5DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6C5E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6C5E4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A6C5E8: 419A0150  beq cr6, 0x82a6c738
	if ctx.cr[6].eq {
	pc = 0x82A6C738; continue 'dispatch;
	}
	// 82A6C5EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C5F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A6C5F4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C5F8: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82A6C5FC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A6C600: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82A6C604: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A6C608: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82A6C60C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C610: 838A0000  lwz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C614: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A6C618: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A6C61C: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82A6C620: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A6C624: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x82A6C628; continue 'dispatch;
            }
            0x82A6C628 => {
    //   block [0x82A6C628..0x82A6C62C)
	// 82A6C628: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	pc = 0x82A6C62C; continue 'dispatch;
            }
            0x82A6C62C => {
    //   block [0x82A6C62C..0x82A6C644)
	// 82A6C62C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A6C630: 419A00D0  beq cr6, 0x82a6c700
	if ctx.cr[6].eq {
	pc = 0x82A6C700; continue 'dispatch;
	}
	// 82A6C634: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6C638: 419A000C  beq cr6, 0x82a6c644
	if ctx.cr[6].eq {
	pc = 0x82A6C644; continue 'dispatch;
	}
	// 82A6C63C: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A6C640: 419A0008  beq cr6, 0x82a6c648
	if ctx.cr[6].eq {
	pc = 0x82A6C648; continue 'dispatch;
	}
	pc = 0x82A6C644; continue 'dispatch;
            }
            0x82A6C644 => {
    //   block [0x82A6C644..0x82A6C648)
	// 82A6C644: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C648; continue 'dispatch;
            }
            0x82A6C648 => {
    //   block [0x82A6C648..0x82A6C660)
	// 82A6C648: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A6C64C: 419A00B4  beq cr6, 0x82a6c700
	if ctx.cr[6].eq {
	pc = 0x82A6C700; continue 'dispatch;
	}
	// 82A6C650: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C654: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6C658: 409A0008  bne cr6, 0x82a6c660
	if !ctx.cr[6].eq {
	pc = 0x82A6C660; continue 'dispatch;
	}
	// 82A6C65C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C660; continue 'dispatch;
            }
            0x82A6C660 => {
    //   block [0x82A6C660..0x82A6C66C)
	// 82A6C660: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6C664: 409A0008  bne cr6, 0x82a6c66c
	if !ctx.cr[6].eq {
	pc = 0x82A6C66C; continue 'dispatch;
	}
	// 82A6C668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C66C; continue 'dispatch;
            }
            0x82A6C66C => {
    //   block [0x82A6C66C..0x82A6C67C)
	// 82A6C66C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C670: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A6C674: 409A0008  bne cr6, 0x82a6c67c
	if !ctx.cr[6].eq {
	pc = 0x82A6C67C; continue 'dispatch;
	}
	// 82A6C678: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C67C; continue 'dispatch;
            }
            0x82A6C67C => {
    //   block [0x82A6C67C..0x82A6C694)
	// 82A6C67C: C0090018  lfs f0, 0x18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6C680: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A6C684: C1BC0018  lfs f13, 0x18(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6C688: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A6C68C: 41980008  blt cr6, 0x82a6c694
	if ctx.cr[6].lt {
	pc = 0x82A6C694; continue 'dispatch;
	}
	// 82A6C690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A6C694; continue 'dispatch;
            }
            0x82A6C694 => {
    //   block [0x82A6C694..0x82A6C6B0)
	// 82A6C694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A6C698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6C69C: 419A0050  beq cr6, 0x82a6c6ec
	if ctx.cr[6].eq {
	pc = 0x82A6C6EC; continue 'dispatch;
	}
	// 82A6C6A0: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A6C6A4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A6C6A8: 409A0008  bne cr6, 0x82a6c6b0
	if !ctx.cr[6].eq {
	pc = 0x82A6C6B0; continue 'dispatch;
	}
	// 82A6C6AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C6B0; continue 'dispatch;
            }
            0x82A6C6B0 => {
    //   block [0x82A6C6B0..0x82A6C6EC)
	// 82A6C6B0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C6B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6C6B8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A6C6BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A6C6C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A6C6C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6C6C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6C6CC: EBE10050  ld r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A6C6D0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A6C6D4: 4BFFFE65  bl 0x82a6c538
	ctx.lr = 0x82A6C6D8;
	sub_82A6C538(ctx, base);
	// 82A6C6D8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A6C6DC: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A6C6E0: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6C6E4: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6C6E8: 4BFFFF44  b 0x82a6c62c
	pc = 0x82A6C62C; continue 'dispatch;
            }
            0x82A6C6EC => {
    //   block [0x82A6C6EC..0x82A6C6F8)
	// 82A6C6EC: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6C6F0: 409A0008  bne cr6, 0x82a6c6f8
	if !ctx.cr[6].eq {
	pc = 0x82A6C6F8; continue 'dispatch;
	}
	// 82A6C6F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C6F8; continue 'dispatch;
            }
            0x82A6C6F8 => {
    //   block [0x82A6C6F8..0x82A6C700)
	// 82A6C6F8: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C6FC: 4BFFFF2C  b 0x82a6c628
	pc = 0x82A6C628; continue 'dispatch;
            }
            0x82A6C700 => {
    //   block [0x82A6C700..0x82A6C710)
	// 82A6C700: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A6C704: 419A000C  beq cr6, 0x82a6c710
	if ctx.cr[6].eq {
	pc = 0x82A6C710; continue 'dispatch;
	}
	// 82A6C708: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A6C70C: 419A0008  beq cr6, 0x82a6c714
	if ctx.cr[6].eq {
	pc = 0x82A6C714; continue 'dispatch;
	}
	pc = 0x82A6C710; continue 'dispatch;
            }
            0x82A6C710 => {
    //   block [0x82A6C710..0x82A6C714)
	// 82A6C710: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6C714; continue 'dispatch;
            }
            0x82A6C714 => {
    //   block [0x82A6C714..0x82A6C738)
	// 82A6C714: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A6C718: 419A0020  beq cr6, 0x82a6c738
	if ctx.cr[6].eq {
	pc = 0x82A6C738; continue 'dispatch;
	}
	// 82A6C71C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6C720: E8E10060  ld r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A6C724: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A6C728: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6C72C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6C730: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A6C734: 4BFFFE05  bl 0x82a6c538
	ctx.lr = 0x82A6C738;
	sub_82A6C538(ctx, base);
	pc = 0x82A6C738; continue 'dispatch;
            }
            0x82A6C738 => {
    //   block [0x82A6C738..0x82A6C740)
	// 82A6C738: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A6C73C: 4823CD14  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6C740 size=220
    let mut pc: u32 = 0x82A6C740;
    'dispatch: loop {
        match pc {
            0x82A6C740 => {
    //   block [0x82A6C740..0x82A6C81C)
	// 82A6C740: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6C820 size=760
    let mut pc: u32 = 0x82A6C820;
    'dispatch: loop {
        match pc {
            0x82A6C820 => {
    //   block [0x82A6C820..0x82A6CB18)
	// 82A6C820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C824: 4823CBD9  bl 0x82ca93fc
	ctx.lr = 0x82A6C828;
	sub_82CA93D0(ctx, base);
	// 82A6C828: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A6C82C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CB18 size=248
    let mut pc: u32 = 0x82A6CB18;
    'dispatch: loop {
        match pc {
            0x82A6CB18 => {
    //   block [0x82A6CB18..0x82A6CB6C)
	// 82A6CB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CB20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6CB24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CB28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CB2C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A6CB30: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82A6CB34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CB38: 480AF499  bl 0x82b1bfd0
	ctx.lr = 0x82A6CB3C;
	sub_82B1BFD0(ctx, base);
	// 82A6CB3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6CB40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A6CB44: 394B68E0  addi r10, r11, 0x68e0
	ctx.r[10].s64 = ctx.r[11].s64 + 26848;
	// 82A6CB48: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6CB4C: 93DF0330  stw r30, 0x330(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(816 as u32), ctx.r[30].u32 ) };
	// 82A6CB50: 893F0150  lbz r9, 0x150(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A6CB54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6CB58: 419A0014  beq cr6, 0x82a6cb6c
	if ctx.cr[6].eq {
	pc = 0x82A6CB6C; continue 'dispatch;
	}
	// 82A6CB5C: 897F0152  lbz r11, 0x152(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(338 as u32) ) } as u64;
	// 82A6CB60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CB64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A6CB68: 419A0008  beq cr6, 0x82a6cb70
	if ctx.cr[6].eq {
	pc = 0x82A6CB70; continue 'dispatch;
	}
	pc = 0x82A6CB6C; continue 'dispatch;
            }
            0x82A6CB6C => {
    //   block [0x82A6CB6C..0x82A6CB70)
	// 82A6CB6C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82A6CB70; continue 'dispatch;
            }
            0x82A6CB70 => {
    //   block [0x82A6CB70..0x82A6CBE8)
	// 82A6CB70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A6CB74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CB78: 419A007C  beq cr6, 0x82a6cbf4
	if ctx.cr[6].eq {
	pc = 0x82A6CBF4; continue 'dispatch;
	}
	// 82A6CB7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A6CB80: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6CB84: 39400200  li r10, 0x200
	ctx.r[10].s64 = 512;
	// 82A6CB88: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A6CB8C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6CB90: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6CB94: 38600260  li r3, 0x260
	ctx.r[3].s64 = 608;
	// 82A6CB98: C19F0110  lfs f12, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6CB9C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A6CBA0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A6CBA4: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6CBA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A6CBAC: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A6CBB0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A6CBB4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A6CBB8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A6CBBC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A6CBC0: 4B7B2699  bl 0x8221f258
	ctx.lr = 0x82A6CBC4;
	sub_8221F258(ctx, base);
	// 82A6CBC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CBC8: 419A0020  beq cr6, 0x82a6cbe8
	if ctx.cr[6].eq {
	pc = 0x82A6CBE8; continue 'dispatch;
	}
	// 82A6CBCC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6CBD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6CBD4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6CBD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6CBDC: 808BF9C4  lwz r4, -0x63c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 82A6CBE0: 48033EB9  bl 0x82aa0a98
	ctx.lr = 0x82A6CBE4;
	sub_82AA0A98(ctx, base);
	// 82A6CBE4: 48000008  b 0x82a6cbec
	pc = 0x82A6CBEC; continue 'dispatch;
            }
            0x82A6CBE8 => {
    //   block [0x82A6CBE8..0x82A6CBEC)
	// 82A6CBE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82A6CBEC; continue 'dispatch;
            }
            0x82A6CBEC => {
    //   block [0x82A6CBEC..0x82A6CBF4)
	// 82A6CBEC: 907F00B0  stw r3, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82A6CBF0: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6CBF4; continue 'dispatch;
            }
            0x82A6CBF4 => {
    //   block [0x82A6CBF4..0x82A6CC10)
	// 82A6CBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6CBF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A6CBFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CC00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CC04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6CC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6CC10 size=92
    let mut pc: u32 = 0x82A6CC10;
    'dispatch: loop {
        match pc {
            0x82A6CC10 => {
    //   block [0x82A6CC10..0x82A6CC54)
	// 82A6CC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CC14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CC18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6CC1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CC20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CC24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CC28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6CC2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6CC30: 394B68E0  addi r10, r11, 0x68e0
	ctx.r[10].s64 = ctx.r[11].s64 + 26848;
	// 82A6CC34: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6CC38: 480AF4D1  bl 0x82b1c108
	ctx.lr = 0x82A6CC3C;
	sub_82B1C108(ctx, base);
	// 82A6CC3C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A6CC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6CC44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6CC48: 419A000C  beq cr6, 0x82a6cc54
	if ctx.cr[6].eq {
	pc = 0x82A6CC54; continue 'dispatch;
	}
	// 82A6CC4C: 4B7AF0ED  bl 0x8221bd38
	ctx.lr = 0x82A6CC50;
	sub_8221BD38(ctx, base);
	// 82A6CC50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A6CC54; continue 'dispatch;
            }
            0x82A6CC54 => {
    //   block [0x82A6CC54..0x82A6CC6C)
	// 82A6CC54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6CC58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CC5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CC60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6CC64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CC68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6CC80 size=20
    let mut pc: u32 = 0x82A6CC80;
    'dispatch: loop {
        match pc {
            0x82A6CC80 => {
    //   block [0x82A6CC80..0x82A6CC94)
	// 82A6CC80: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6CC98 size=16
    let mut pc: u32 = 0x82A6CC98;
    'dispatch: loop {
        match pc {
            0x82A6CC98 => {
    //   block [0x82A6CC98..0x82A6CCA8)
	// 82A6CC98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CC9C: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6CCA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6CCA4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CCA8 size=292
    let mut pc: u32 = 0x82A6CCA8;
    'dispatch: loop {
        match pc {
            0x82A6CCA8 => {
    //   block [0x82A6CCA8..0x82A6CDCC)
	// 82A6CCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CCAC: 4823C761  bl 0x82ca940c
	ctx.lr = 0x82A6CCB0;
	sub_82CA93D0(ctx, base);
	// 82A6CCB0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6CCB4: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CCB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CCBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6CCC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A6CCC4: 809F01A0  lwz r4, 0x1a0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82A6CCC8: 4803ABB9  bl 0x82aa7880
	ctx.lr = 0x82A6CCCC;
	sub_82AA7880(ctx, base);
	// 82A6CCCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6CCD0: 4B7CF0E1  bl 0x8223bdb0
	ctx.lr = 0x82A6CCD4;
	sub_8223BDB0(ctx, base);
	// 82A6CCD4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A6CCD8: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 82A6CCDC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 82A6CCE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6CCE4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6CCE8: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6CCEC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A6CCF0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CDD0 size=504
    let mut pc: u32 = 0x82A6CDD0;
    'dispatch: loop {
        match pc {
            0x82A6CDD0 => {
    //   block [0x82A6CDD0..0x82A6CFC8)
	// 82A6CDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CDD4: 4823C62D  bl 0x82ca9400
	ctx.lr = 0x82A6CDD8;
	sub_82CA93D0(ctx, base);
	// 82A6CDD8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A6CDDC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CDE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A6CDE4: 101F038C  vspltisw v0, -1
	for i in 0..4 {
		ctx.v[0].u32[i] = 4294967295;
	}
	// 82A6CDE8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A6CDEC: 390B9484  addi r8, r11, -0x6b7c
	ctx.r[8].s64 = ctx.r[11].s64 + -27516;
	// 82A6CDF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6CDF4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A6CDF8: 11A00184  vslw v13, v0, v0
	ctx.v[13].u32[0] = ctx.v[0].u32[0] << (ctx.v[0].u8[0] & 0x1F);
	ctx.v[13].u32[1] = ctx.v[0].u32[1] << (ctx.v[0].u8[4] & 0x1F);
	ctx.v[13].u32[2] = ctx.v[0].u32[2] << (ctx.v[0].u8[8] & 0x1F);
	ctx.v[13].u32[3] = ctx.v[0].u32[3] << (ctx.v[0].u8[12] & 0x1F);
	// 82A6CDFC: 38EA91A0  addi r7, r10, -0x6e60
	ctx.r[7].s64 = ctx.r[10].s64 + -28256;
	// 82A6CE00: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6CE04: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6CE08: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A6CE0C: C3E8000C  lfs f31, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6CE10: 38800120  li r4, 0x120
	ctx.r[4].s64 = 288;
	// 82A6CE14: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A6CE18: 386001C0  li r3, 0x1c0
	ctx.r[3].s64 = 448;
	// 82A6CE1C: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6CFC8 size=80
    let mut pc: u32 = 0x82A6CFC8;
    'dispatch: loop {
        match pc {
            0x82A6CFC8 => {
    //   block [0x82A6CFC8..0x82A6D000)
	// 82A6CFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6CFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CFE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6CFE4: 48000385  bl 0x82a6d368
	ctx.lr = 0x82A6CFE8;
	sub_82A6D368(ctx, base);
	// 82A6CFE8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A6CFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6CFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CFF4: 419A000C  beq cr6, 0x82a6d000
	if ctx.cr[6].eq {
	pc = 0x82A6D000; continue 'dispatch;
	}
	// 82A6CFF8: 4B7AED41  bl 0x8221bd38
	ctx.lr = 0x82A6CFFC;
	sub_8221BD38(ctx, base);
	// 82A6CFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A6D000; continue 'dispatch;
            }
            0x82A6D000 => {
    //   block [0x82A6D000..0x82A6D018)
	// 82A6D000: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6D004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6D008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6D00C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6D010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6D014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D018 size=848
    let mut pc: u32 = 0x82A6D018;
    'dispatch: loop {
        match pc {
            0x82A6D018 => {
    //   block [0x82A6D018..0x82A6D100)
	// 82A6D018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D01C: 4823C3ED  bl 0x82ca9408
	ctx.lr = 0x82A6D020;
	sub_82CA93D0(ctx, base);
	// 82A6D020: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6D028: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6D02C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6D030: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6D034: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6D038: 516A083C  rlwimi r10, r11, 1, 0, 0x1e
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(1) as u64) & 0x00000000FFFFFFFE) | (ctx.r[10].u64 & 0xFFFFFFFF00000001);
	// 82A6D03C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6D040: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6D044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D048: 419A00D0  beq cr6, 0x82a6d118
	if ctx.cr[6].eq {
	pc = 0x82A6D118; continue 'dispatch;
	}
	// 82A6D04C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A6D050: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A6D054: 481FBD35  bl 0x82c68d88
	ctx.lr = 0x82A6D058;
	sub_82C68D88(ctx, base);
	// 82A6D058: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82A6D05C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82A6D060: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6D064: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82A6D068: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D06C: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82A6D070: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6D074: 4B893A0D  bl 0x82300a80
	ctx.lr = 0x82A6D078;
	sub_82300A80(ctx, base);
	// 82A6D078: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6D07C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6D080: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6D084: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D088: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6D08C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A6D090: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A6D094: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82A6D098: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D09C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6D0A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6D0A4: 4E800421  bctrl
	ctx.lr = 0x82A6D0A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6D0A8: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A6D0AC: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A6D0B0: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82A6D0B4: 7CFF4850  subf r7, r31, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[31].s64;
	// 82A6D0B8: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82A6D0BC: 38C82B60  addi r6, r8, 0x2b60
	ctx.r[6].s64 = ctx.r[8].s64 + 11104;
	// 82A6D0C0: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82A6D0C4: 90E10088  stw r7, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 82A6D0C8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A6D0CC: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82A6D0D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D0D4: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82A6D0D8: 9BA10098  stb r29, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u8 ) };
	// 82A6D0DC: 90C10080  stw r6, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 82A6D0E0: 480027E9  bl 0x82a6f8c8
	ctx.lr = 0x82A6D0E4;
	sub_82A6F8C8(ctx, base);
	// 82A6D0E4: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 82A6D0E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6D0EC: 38852B90  addi r4, r5, 0x2b90
	ctx.r[4].s64 = ctx.r[5].s64 + 11152;
	// 82A6D0F0: 90810080  stw r4, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[4].u32 ) };
	// 82A6D0F4: 419A000C  beq cr6, 0x82a6d100
	if ctx.cr[6].eq {
	pc = 0x82A6D100; continue 'dispatch;
	}
	// 82A6D0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6D0FC: 4B7AEC3D  bl 0x8221bd38
	ctx.lr = 0x82A6D100;
	sub_8221BD38(ctx, base);
            }
            0x82A6D100 => {
    //   block [0x82A6D100..0x82A6D118)
	// 82A6D100: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D108: 419A0250  beq cr6, 0x82a6d358
	if ctx.cr[6].eq {
	pc = 0x82A6D358; continue 'dispatch;
	}
	// 82A6D10C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D110: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6D114: 4800023C  b 0x82a6d350
	pc = 0x82A6D350; continue 'dispatch;
            }
            0x82A6D118 => {
    //   block [0x82A6D118..0x82A6D350)
	// 82A6D118: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A6D11C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A6D120: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 82A6D124: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 82A6D128: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82A6D12C: 38E00040  li r7, 0x40
	ctx.r[7].s64 = 64;
	pc = 0x82A6D350; continue 'dispatch;
            }
            0x82A6D350 => {
    //   block [0x82A6D350..0x82A6D358)
	// 82A6D350: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6D354: 4E800421  bctrl
	ctx.lr = 0x82A6D358;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6D358 => {
    //   block [0x82A6D358..0x82A6D368)
	// 82A6D358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D35C: 480000E5  bl 0x82a6d440
	ctx.lr = 0x82A6D360;
	sub_82A6D440(ctx, base);
	// 82A6D360: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A6D364: 4823C0F4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D368 size=212
    let mut pc: u32 = 0x82A6D368;
    'dispatch: loop {
        match pc {
            0x82A6D368 => {
    //   block [0x82A6D368..0x82A6D3A4)
	// 82A6D368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D36C: 4823C0A1  bl 0x82ca940c
	ctx.lr = 0x82A6D370;
	sub_82CA93D0(ctx, base);
	// 82A6D370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D378: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A6D37C: 394B6F30  addi r10, r11, 0x6f30
	ctx.r[10].s64 = ctx.r[11].s64 + 28464;
	// 82A6D380: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A6D384: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6D388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D38C: 419A0018  beq cr6, 0x82a6d3a4
	if ctx.cr[6].eq {
	pc = 0x82A6D3A4; continue 'dispatch;
	}
	// 82A6D390: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D394: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6D398: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D39C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6D3A0: 4E800421  bctrl
	ctx.lr = 0x82A6D3A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6D3A4 => {
    //   block [0x82A6D3A4..0x82A6D3CC)
	// 82A6D3A4: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A6D3A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6D3AC: 93BF00B4  stw r29, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 82A6D3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D3B4: 419A0018  beq cr6, 0x82a6d3cc
	if ctx.cr[6].eq {
	pc = 0x82A6D3CC; continue 'dispatch;
	}
	// 82A6D3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D3BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6D3C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D3C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A6D3C8: 4E800421  bctrl
	ctx.lr = 0x82A6D3CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6D3CC => {
    //   block [0x82A6D3CC..0x82A6D3EC)
	// 82A6D3CC: 93BF00B0  stw r29, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[29].u32 ) };
	// 82A6D3D0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6D3D4: 4800033D  bl 0x82a6d710
	ctx.lr = 0x82A6D3D8;
	sub_82A6D710(ctx, base);
	// 82A6D3D8: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82A6D3DC: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 82A6D3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D3E4: 419A0008  beq cr6, 0x82a6d3ec
	if ctx.cr[6].eq {
	pc = 0x82A6D3EC; continue 'dispatch;
	}
	// 82A6D3E8: 4B7AE951  bl 0x8221bd38
	ctx.lr = 0x82A6D3EC;
	sub_8221BD38(ctx, base);
	pc = 0x82A6D3EC; continue 'dispatch;
            }
            0x82A6D3EC => {
    //   block [0x82A6D3EC..0x82A6D43C)
	// 82A6D3EC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A6D3F0: 387F0118  addi r3, r31, 0x118
	ctx.r[3].s64 = ctx.r[31].s64 + 280;
	// 82A6D3F4: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A6D3F8: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82A6D3FC: 4B78EB95  bl 0x821fbf90
	ctx.lr = 0x82A6D400;
	sub_821FBF90(ctx, base);
	// 82A6D400: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A6D404: 3BDF0110  addi r30, r31, 0x110
	ctx.r[30].s64 = ctx.r[31].s64 + 272;
	// 82A6D408: 394B2A30  addi r10, r11, 0x2a30
	ctx.r[10].s64 = ctx.r[11].s64 + 10800;
	// 82A6D40C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D410: 915F0110  stw r10, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[10].u32 ) };
	// 82A6D414: 4B78EBF5  bl 0x821fc008
	ctx.lr = 0x82A6D418;
	sub_821FC008(ctx, base);
	// 82A6D418: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A6D41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D420: 39092A40  addi r8, r9, 0x2a40
	ctx.r[8].s64 = ctx.r[9].s64 + 10816;
	// 82A6D424: 911F0110  stw r8, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[8].u32 ) };
	// 82A6D428: 4B78EBE1  bl 0x821fc008
	ctx.lr = 0x82A6D42C;
	sub_821FC008(ctx, base);
	// 82A6D42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6D430: 480ADA99  bl 0x82b1aec8
	ctx.lr = 0x82A6D434;
	sub_82B1AEC8(ctx, base);
	// 82A6D434: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6D438: 4823C024  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D440 size=636
    let mut pc: u32 = 0x82A6D440;
    'dispatch: loop {
        match pc {
            0x82A6D440 => {
    //   block [0x82A6D440..0x82A6D6BC)
	// 82A6D440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D444: 4823BFC5  bl 0x82ca9408
	ctx.lr = 0x82A6D448;
	sub_82CA93D0(ctx, base);
	// 82A6D448: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A6D44C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A6D450: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D458: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A6D45C: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 82A6D460: 3BBF00E0  addi r29, r31, 0xe0
	ctx.r[29].s64 = ctx.r[31].s64 + 224;
	// 82A6D464: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 82A6D468: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A6D46C: 390991A0  addi r8, r9, -0x6e60
	ctx.r[8].s64 = ctx.r[9].s64 + -28256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D6C0 size=80
    let mut pc: u32 = 0x82A6D6C0;
    'dispatch: loop {
        match pc {
            0x82A6D6C0 => {
    //   block [0x82A6D6C0..0x82A6D6F4)
	// 82A6D6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D6D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6D6D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6D6DC: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6D6E0: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A6D6E4: 419A0010  beq cr6, 0x82a6d6f4
	if ctx.cr[6].eq {
	pc = 0x82A6D6F4; continue 'dispatch;
	}
	// 82A6D6E8: 48000029  bl 0x82a6d710
	ctx.lr = 0x82A6D6EC;
	sub_82A6D710(ctx, base);
	// 82A6D6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6D6F0: 48000021  bl 0x82a6d710
	ctx.lr = 0x82A6D6F4;
	sub_82A6D710(ctx, base);
	pc = 0x82A6D6F4; continue 'dispatch;
            }
            0x82A6D6F4 => {
    //   block [0x82A6D6F4..0x82A6D710)
	// 82A6D6F4: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82A6D6F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6D6FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6D700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6D704: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6D708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6D70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D710 size=408
    let mut pc: u32 = 0x82A6D710;
    'dispatch: loop {
        match pc {
            0x82A6D710 => {
    //   block [0x82A6D710..0x82A6D754)
	// 82A6D710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D71C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D728: 419A0168  beq cr6, 0x82a6d890
	if ctx.cr[6].eq {
	pc = 0x82A6D890; continue 'dispatch;
	}
	// 82A6D72C: 3BC30D54  addi r30, r3, 0xd54
	ctx.r[30].s64 = ctx.r[3].s64 + 3412;
	// 82A6D730: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 82A6D734: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6D738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6D73C: 4B765A85  bl 0x821d31c0
	ctx.lr = 0x82A6D740;
	sub_821D31C0(ctx, base);
	// 82A6D740: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D744: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D748: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6D74C: 419A0054  beq cr6, 0x82a6d7a0
	if ctx.cr[6].eq {
	pc = 0x82A6D7A0; continue 'dispatch;
	}
	// 82A6D750: 3BE000FF  li r31, 0xff
	ctx.r[31].s64 = 255;
	pc = 0x82A6D754; continue 'dispatch;
            }
            0x82A6D754 => {
    //   block [0x82A6D754..0x82A6D778)
	// 82A6D754: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6D758: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D75C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D760: 419A0018  beq cr6, 0x82a6d778
	if ctx.cr[6].eq {
	pc = 0x82A6D778; continue 'dispatch;
	}
	// 82A6D764: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6D768: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A6D76C: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82A6D770: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A6D774: 41980008  blt cr6, 0x82a6d77c
	if ctx.cr[6].lt {
	pc = 0x82A6D77C; continue 'dispatch;
	}
	pc = 0x82A6D778; continue 'dispatch;
            }
            0x82A6D778 => {
    //   block [0x82A6D778..0x82A6D77C)
	// 82A6D778: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6D77C; continue 'dispatch;
            }
            0x82A6D77C => {
    //   block [0x82A6D77C..0x82A6D7A0)
	// 82A6D77C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6D780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6D784: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6D788: 9BE90084  stb r31, 0x84(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(132 as u32), ctx.r[31].u8 ) };
	// 82A6D78C: 4B791FB5  bl 0x821ff740
	ctx.lr = 0x82A6D790;
	sub_821FF740(ctx, base);
	// 82A6D790: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D794: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D798: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6D79C: 409AFFB8  bne cr6, 0x82a6d754
	if !ctx.cr[6].eq {
	pc = 0x82A6D754; continue 'dispatch;
	}
	pc = 0x82A6D7A0; continue 'dispatch;
            }
            0x82A6D7A0 => {
    //   block [0x82A6D7A0..0x82A6D7C0)
	// 82A6D7A0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82A6D7A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6D7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6D7AC: 4B786CD5  bl 0x821f4480
	ctx.lr = 0x82A6D7B0;
	sub_821F4480(ctx, base);
	// 82A6D7B0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D7B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D7B8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6D7BC: 419A0058  beq cr6, 0x82a6d814
	if ctx.cr[6].eq {
	pc = 0x82A6D814; continue 'dispatch;
	}
	pc = 0x82A6D7C0; continue 'dispatch;
            }
            0x82A6D7C0 => {
    //   block [0x82A6D7C0..0x82A6D7E4)
	// 82A6D7C0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6D7C4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D7C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D7CC: 419A0018  beq cr6, 0x82a6d7e4
	if ctx.cr[6].eq {
	pc = 0x82A6D7E4; continue 'dispatch;
	}
	// 82A6D7D0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6D7D4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A6D7D8: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82A6D7DC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A6D7E0: 41980008  blt cr6, 0x82a6d7e8
	if ctx.cr[6].lt {
	pc = 0x82A6D7E8; continue 'dispatch;
	}
	pc = 0x82A6D7E4; continue 'dispatch;
            }
            0x82A6D7E4 => {
    //   block [0x82A6D7E4..0x82A6D7E8)
	// 82A6D7E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6D7E8; continue 'dispatch;
            }
            0x82A6D7E8 => {
    //   block [0x82A6D7E8..0x82A6D814)
	// 82A6D7E8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6D7EC: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6D7F0: 806900F0  lwz r3, 0xf0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A6D7F4: 4B7B8B05  bl 0x822262f8
	ctx.lr = 0x82A6D7F8;
	sub_822262F8(ctx, base);
	// 82A6D7F8: 48023D21  bl 0x82a91518
	ctx.lr = 0x82A6D7FC;
	sub_82A91518(ctx, base);
	// 82A6D7FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6D800: 4B792579  bl 0x821ffd78
	ctx.lr = 0x82A6D804;
	sub_821FFD78(ctx, base);
	// 82A6D804: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D808: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D80C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6D810: 409AFFB0  bne cr6, 0x82a6d7c0
	if !ctx.cr[6].eq {
	pc = 0x82A6D7C0; continue 'dispatch;
	}
	pc = 0x82A6D814; continue 'dispatch;
            }
            0x82A6D814 => {
    //   block [0x82A6D814..0x82A6D834)
	// 82A6D814: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 82A6D818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6D81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6D820: 4B786C61  bl 0x821f4480
	ctx.lr = 0x82A6D824;
	sub_821F4480(ctx, base);
	// 82A6D824: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D828: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D82C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6D830: 419A0060  beq cr6, 0x82a6d890
	if ctx.cr[6].eq {
	pc = 0x82A6D890; continue 'dispatch;
	}
	pc = 0x82A6D834; continue 'dispatch;
            }
            0x82A6D834 => {
    //   block [0x82A6D834..0x82A6D858)
	// 82A6D834: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6D838: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D83C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D840: 419A0018  beq cr6, 0x82a6d858
	if ctx.cr[6].eq {
	pc = 0x82A6D858; continue 'dispatch;
	}
	// 82A6D844: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6D848: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A6D84C: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82A6D850: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A6D854: 41980008  blt cr6, 0x82a6d85c
	if ctx.cr[6].lt {
	pc = 0x82A6D85C; continue 'dispatch;
	}
	pc = 0x82A6D858; continue 'dispatch;
            }
            0x82A6D858 => {
    //   block [0x82A6D858..0x82A6D85C)
	// 82A6D858: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82A6D85C; continue 'dispatch;
            }
            0x82A6D85C => {
    //   block [0x82A6D85C..0x82A6D890)
	// 82A6D85C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6D860: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6D864: 806B017C  lwz r3, 0x17c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(380 as u32) ) } as u64;
	// 82A6D868: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D86C: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6D870: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A6D874: 4E800421  bctrl
	ctx.lr = 0x82A6D878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6D878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6D87C: 4B7924FD  bl 0x821ffd78
	ctx.lr = 0x82A6D880;
	sub_821FFD78(ctx, base);
	// 82A6D880: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D884: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D888: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6D88C: 409AFFA8  bne cr6, 0x82a6d834
	if !ctx.cr[6].eq {
	pc = 0x82A6D834; continue 'dispatch;
	}
            }
            0x82A6D890 => {
    //   block [0x82A6D890..0x82A6D8A8)
	// 82A6D890: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6D894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6D898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6D89C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6D8A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6D8A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D8A8 size=560
    let mut pc: u32 = 0x82A6D8A8;
    'dispatch: loop {
        match pc {
            0x82A6D8A8 => {
    //   block [0x82A6D8A8..0x82A6DAD8)
	// 82A6D8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D8AC: 4823BB59  bl 0x82ca9404
	ctx.lr = 0x82A6D8B0;
	sub_82CA93D0(ctx, base);
	// 82A6D8B0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82A6D8B4: 48599119  bl 0x830069cc
	ctx.lr = 0x82A6D8B8;
	sub_83006760(ctx, base);
	// 82A6D8B8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D8BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D8C0: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 82A6D8C4: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 82A6D8C8: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82A6D8CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6DAD8 size=596
    let mut pc: u32 = 0x82A6DAD8;
    'dispatch: loop {
        match pc {
            0x82A6DAD8 => {
    //   block [0x82A6DAD8..0x82A6DD2C)
	// 82A6DAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6DADC: 4823B905  bl 0x82ca93e0
	ctx.lr = 0x82A6DAE0;
	sub_82CA93D0(ctx, base);
	// 82A6DAE0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6DAE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6DAE8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82A6DAEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A6DAF0: 389E0110  addi r4, r30, 0x110
	ctx.r[4].s64 = ctx.r[30].s64 + 272;
	// 82A6DAF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6DAF8: 4B8228F1  bl 0x822903e8
	ctx.lr = 0x82A6DAFC;
	sub_822903E8(ctx, base);
	// 82A6DAFC: 3BFE00E0  addi r31, r30, 0xe0
	ctx.r[31].s64 = ctx.r[30].s64 + 224;
	// 82A6DB00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A6DB04: 807E0114  lwz r3, 0x114(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A6DB08: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A6DB0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6DD30 size=532
    let mut pc: u32 = 0x82A6DD30;
    'dispatch: loop {
        match pc {
            0x82A6DD30 => {
    //   block [0x82A6DD30..0x82A6DF44)
	// 82A6DD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6DD34: 4823B6D5  bl 0x82ca9408
	ctx.lr = 0x82A6DD38;
	sub_82CA93D0(ctx, base);
	// 82A6DD38: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82A6DD3C: 4823FF9D  bl 0x82cadcd8
	ctx.lr = 0x82A6DD40;
	sub_82CADCA0(ctx, base);
	// 82A6DD40: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6DD44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6DF48 size=24
    let mut pc: u32 = 0x82A6DF48;
    'dispatch: loop {
        match pc {
            0x82A6DF48 => {
    //   block [0x82A6DF48..0x82A6DF60)
	// 82A6DF48: 39630050  addi r11, r3, 0x50
	ctx.r[11].s64 = ctx.r[3].s64 + 80;
	// 82A6DF4C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A6DF50: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6DF60 size=1240
    let mut pc: u32 = 0x82A6DF60;
    'dispatch: loop {
        match pc {
            0x82A6DF60 => {
    //   block [0x82A6DF60..0x82A6DFD4)
	// 82A6DF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6DF64: 4823B49D  bl 0x82ca9400
	ctx.lr = 0x82A6DF68;
	sub_82CA93D0(ctx, base);
	// 82A6DF68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6DF6C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A6DF70: 39600017  li r11, 0x17
	ctx.r[11].s64 = 23;
	// 82A6DF74: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A6DF78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6DF7C: 4B7B12DD  bl 0x8221f258
	ctx.lr = 0x82A6DF80;
	sub_8221F258(ctx, base);
	// 82A6DF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6DF84: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A6DF88: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A6DF8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6DF90: 3B8B2A30  addi r28, r11, 0x2a30
	ctx.r[28].s64 = ctx.r[11].s64 + 10800;
	// 82A6DF94: 419A0040  beq cr6, 0x82a6dfd4
	if ctx.cr[6].eq {
	pc = 0x82A6DFD4; continue 'dispatch;
	}
	// 82A6DF98: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 82A6DF9C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A6DFA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6DFA4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A6DFA8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6DFAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6DFB0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6DFB4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6DFB8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6DFBC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6DFC0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6DFC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A6DFC8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6DFCC: 48113B5D  bl 0x82b81b28
	ctx.lr = 0x82A6DFD0;
	sub_82B81B28(ctx, base);
	// 82A6DFD0: 48000008  b 0x82a6dfd8
	pc = 0x82A6DFD8; continue 'dispatch;
            }
            0x82A6DFD4 => {
    //   block [0x82A6DFD4..0x82A6DFD8)
	// 82A6DFD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82A6DFD8; continue 'dispatch;
            }
            0x82A6DFD8 => {
    //   block [0x82A6DFD8..0x82A6DFF8)
	// 82A6DFD8: 93FA00B0  stw r31, 0xb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 82A6DFDC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A6DFE0: 4B7B1279  bl 0x8221f258
	ctx.lr = 0x82A6DFE4;
	sub_8221F258(ctx, base);
	// 82A6DFE4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A6DFE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6DFEC: 3BCB8498  addi r30, r11, -0x7b68
	ctx.r[30].s64 = ctx.r[11].s64 + -31592;
	// 82A6DFF0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A6DFF4: 397EFC00  addi r11, r30, -0x400
	ctx.r[11].s64 = ctx.r[30].s64 + -1024;
	pc = 0x82A6DFF8; continue 'dispatch;
            }
            0x82A6DFF8 => {
    //   block [0x82A6DFF8..0x82A6E068)
	// 82A6DFF8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DFFC: 393EFC00  addi r9, r30, -0x400
	ctx.r[9].s64 = ctx.r[30].s64 + -1024;
	// 82A6E000: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6E004: 38C90400  addi r6, r9, 0x400
	ctx.r[6].s64 = ctx.r[9].s64 + 1024;
	// 82A6E008: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82A6E00C: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82A6E010: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6E014: 4198FFE4  blt cr6, 0x82a6dff8
	if ctx.cr[6].lt {
	pc = 0x82A6DFF8; continue 'dispatch;
	}
	// 82A6E018: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6E01C: 807A00B0  lwz r3, 0xb0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A6E020: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82A6E024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E028: 48113841  bl 0x82b81868
	ctx.lr = 0x82A6E02C;
	sub_82B81868(ctx, base);
	// 82A6E02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E030: 4B7ADD09  bl 0x8221bd38
	ctx.lr = 0x82A6E034;
	sub_8221BD38(ctx, base);
	// 82A6E034: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A6E038: 4B7B1289  bl 0x8221f2c0
	ctx.lr = 0x82A6E03C;
	sub_8221F2C0(ctx, base);
	// 82A6E03C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E040: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82A6E044: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6E048: 409A03A8  bne cr6, 0x82a6e3f0
	if !ctx.cr[6].eq {
	pc = 0x82A6E3F0; continue 'dispatch;
	}
	// 82A6E04C: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A6E050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6E054: 419A0014  beq cr6, 0x82a6e068
	if ctx.cr[6].eq {
	pc = 0x82A6E068; continue 'dispatch;
	}
	// 82A6E058: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6E05C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6E060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6E064: 4E800421  bctrl
	ctx.lr = 0x82A6E068;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6E068 => {
    //   block [0x82A6E068..0x82A6E070)
	// 82A6E068: 48254341  bl 0x82cc23a8
	ctx.lr = 0x82A6E06C;
	sub_82CC23A8(ctx, base);
	// 82A6E06C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82A6E070; continue 'dispatch;
            }
            0x82A6E070 => {
    //   block [0x82A6E070..0x82A6E0A4)
	// 82A6E070: 93FA00B4  stw r31, 0xb4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 82A6E074: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82A6E078: 4B7B1249  bl 0x8221f2c0
	ctx.lr = 0x82A6E07C;
	sub_8221F2C0(ctx, base);
	// 82A6E07C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6E084: 409A0024  bne cr6, 0x82a6e0a8
	if !ctx.cr[6].eq {
	pc = 0x82A6E0A8; continue 'dispatch;
	}
	// 82A6E088: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A6E08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6E090: 419A0014  beq cr6, 0x82a6e0a4
	if ctx.cr[6].eq {
	pc = 0x82A6E0A4; continue 'dispatch;
	}
	// 82A6E094: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6E098: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6E09C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6E0A0: 4E800421  bctrl
	ctx.lr = 0x82A6E0A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A6E0A4 => {
    //   block [0x82A6E0A4..0x82A6E0A8)
	// 82A6E0A4: 48254305  bl 0x82cc23a8
	ctx.lr = 0x82A6E0A8;
	sub_82CC23A8(ctx, base);
	pc = 0x82A6E0A8; continue 'dispatch;
            }
            0x82A6E0A8 => {
    //   block [0x82A6E0A8..0x82A6E0BC)
	// 82A6E0A8: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 82A6E0AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A6E0B0: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 82A6E0B4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82A6E0B8: C00817C8  lfs f0, 0x17c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82A6E0BC; continue 'dispatch;
            }
            0x82A6E0BC => {
    //   block [0x82A6E0BC..0x82A6E3F0)
	// 82A6E0BC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E0C0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E0C4: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6E0C8: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E0CC: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A6E0D0: C10B0000  lfs f8, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A6E0D4: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E0D8: ECC80032  fmuls f6, f8, f0
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E0DC: FCA0601E  fctiwz f5, f12
	ctx.f[5].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A6E0E0: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82A6E0E4: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E0E8: FC80501E  fctiwz f4, f10
	ctx.f[4].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82A6E0EC: D8810058  stfd f4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[4].u64 ) };
	// 82A6E0F0: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E0F4: FC60381E  fctiwz f3, f7
	ctx.f[3].s64 = if ctx.f[7].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[7].f64.trunc() as i32 as i64 };
	// 82A6E0F8: D8610058  stfd f3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[3].u64 ) };
	// 82A6E0FC: FC40301E  fctiwz f2, f6
	ctx.f[2].s64 = if ctx.f[6].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[6].f64.trunc() as i32 as i64 };
	// 82A6E100: D8410050  stfd f2, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[2].u64 ) };
	// 82A6E104: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E108: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E10C: 50A6402E  rlwimi r6, r5, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82A6E110: 50C8402E  rlwimi r8, r6, 8, 0, 0x17
	ctx.r[8].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[8].u64 & 0xFFFFFFFF000000FF);
	// 82A6E114: 5107402E  rlwimi r7, r8, 8, 0, 0x17
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[7].u64 & 0xFFFFFFFF000000FF);
	// 82A6E118: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 82A6E11C: C02B0018  lfs f1, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6E120: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E124: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6E128: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6E12C: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E130: ED210032  fmuls f9, f1, f0
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E134: FD00501E  fctiwz f8, f10
	ctx.f[8].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82A6E138: D9010058  stfd f8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[8].u64 ) };
	// 82A6E13C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E140: ECED0032  fmuls f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E144: ECCC0032  fmuls f6, f12, f0
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E148: FCA0481E  fctiwz f5, f9
	ctx.f[5].s64 = if ctx.f[9].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[9].f64.trunc() as i32 as i64 };
	// 82A6E14C: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82A6E150: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E154: FC80381E  fctiwz f4, f7
	ctx.f[4].s64 = if ctx.f[7].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[7].f64.trunc() as i32 as i64 };
	// 82A6E158: D8810058  stfd f4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[4].u64 ) };
	// 82A6E15C: FC60301E  fctiwz f3, f6
	ctx.f[3].s64 = if ctx.f[6].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[6].f64.trunc() as i32 as i64 };
	// 82A6E160: D8610050  stfd f3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[3].u64 ) };
	// 82A6E164: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E168: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E16C: 50E8402E  rlwimi r8, r7, 8, 0, 0x17
	ctx.r[8].u64 = (((ctx.r[7].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[8].u64 & 0xFFFFFFFF000000FF);
	// 82A6E170: 5104402E  rlwimi r4, r8, 8, 0, 0x17
	ctx.r[4].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[4].u64 & 0xFFFFFFFF000000FF);
	// 82A6E174: 5083402E  rlwimi r3, r4, 8, 0, 0x17
	ctx.r[3].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[3].u64 & 0xFFFFFFFF000000FF);
	// 82A6E178: 906AFFFC  stw r3, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 82A6E17C: C04B0024  lfs f2, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6E180: C02B001C  lfs f1, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6E184: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E188: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6E18C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E190: ED420032  fmuls f10, f2, f0
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E194: FD20581E  fctiwz f9, f11
	ctx.f[9].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A6E198: D9210058  stfd f9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[9].u64 ) };
	// 82A6E19C: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E1A0: ED010032  fmuls f8, f1, f0
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E1A4: ECED0032  fmuls f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E1A8: FCC0501E  fctiwz f6, f10
	ctx.f[6].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82A6E1AC: D8C10058  stfd f6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[6].u64 ) };
	// 82A6E1B0: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E1B4: FCA0401E  fctiwz f5, f8
	ctx.f[5].s64 = if ctx.f[8].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[8].f64.trunc() as i32 as i64 };
	// 82A6E1B8: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82A6E1BC: FC80381E  fctiwz f4, f7
	ctx.f[4].s64 = if ctx.f[7].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[7].f64.trunc() as i32 as i64 };
	// 82A6E1C0: D8810050  stfd f4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[4].u64 ) };
	// 82A6E1C4: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E1C8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E1CC: 5064402E  rlwimi r4, r3, 8, 0, 0x17
	ctx.r[4].u64 = (((ctx.r[3].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[4].u64 & 0xFFFFFFFF000000FF);
	// 82A6E1D0: 5086402E  rlwimi r6, r4, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82A6E1D4: 50C5402E  rlwimi r5, r6, 8, 0, 0x17
	ctx.r[5].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[5].u64 & 0xFFFFFFFF000000FF);
	// 82A6E1D8: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A6E1DC: C06B002C  lfs f3, 0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A6E1E0: C04B0030  lfs f2, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6E1E4: C02B0028  lfs f1, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6E1E8: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E1EC: FD80681E  fctiwz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82A6E1F0: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 82A6E1F4: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E1F8: ED630032  fmuls f11, f3, f0
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E1FC: ED420032  fmuls f10, f2, f0
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E200: FD00581E  fctiwz f8, f11
	ctx.f[8].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A6E204: D9010050  stfd f8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[8].u64 ) };
	// 82A6E208: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E20C: FD20501E  fctiwz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82A6E210: D9210058  stfd f9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[9].u64 ) };
	// 82A6E214: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E218: C0EB0024  lfs f7, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A6E21C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A6E220: ECC70032  fmuls f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E224: FCA0301E  fctiwz f5, f6
	ctx.f[5].s64 = if ctx.f[6].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[6].f64.trunc() as i32 as i64 };
	// 82A6E228: D8A10058  stfd f5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[5].u64 ) };
	// 82A6E22C: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E230: 50C8402E  rlwimi r8, r6, 8, 0, 0x17
	ctx.r[8].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[8].u64 & 0xFFFFFFFF000000FF);
	// 82A6E234: 5105402E  rlwimi r5, r8, 8, 0, 0x17
	ctx.r[5].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[5].u64 & 0xFFFFFFFF000000FF);
	// 82A6E238: 50A7402E  rlwimi r7, r5, 8, 0, 0x17
	ctx.r[7].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[7].u64 & 0xFFFFFFFF000000FF);
	// 82A6E23C: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A6E240: C06B0030  lfs f3, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A6E244: C08B003C  lfs f4, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82A6E248: ED840032  fmuls f12, f4, f0
	ctx.f[12].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E24C: C02B0038  lfs f1, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6E250: FD00601E  fctiwz f8, f12
	ctx.f[8].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A6E254: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E258: C04B0034  lfs f2, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6E25C: ED430032  fmuls f10, f3, f0
	ctx.f[10].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E260: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E264: FD60681E  fctiwz f11, f13
	ctx.f[11].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82A6E268: D9610058  stfd f11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[11].u64 ) };
	// 82A6E26C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E270: D9010058  stfd f8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[8].u64 ) };
	// 82A6E274: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E278: FCE0501E  fctiwz f7, f10
	ctx.f[7].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82A6E27C: FCC0481E  fctiwz f6, f9
	ctx.f[6].s64 = if ctx.f[9].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[9].f64.trunc() as i32 as i64 };
	// 82A6E280: D8E10050  stfd f7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[7].u64 ) };
	// 82A6E284: D8C10058  stfd f6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[6].u64 ) };
	// 82A6E288: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E28C: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E290: 50E8402E  rlwimi r8, r7, 8, 0, 0x17
	ctx.r[8].u64 = (((ctx.r[7].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[8].u64 & 0xFFFFFFFF000000FF);
	// 82A6E294: 5104402E  rlwimi r4, r8, 8, 0, 0x17
	ctx.r[4].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[4].u64 & 0xFFFFFFFF000000FF);
	// 82A6E298: 5083402E  rlwimi r3, r4, 8, 0, 0x17
	ctx.r[3].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[3].u64 & 0xFFFFFFFF000000FF);
	// 82A6E29C: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A6E2A0: C0AB0040  lfs f5, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A6E2A4: C06B003C  lfs f3, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A6E2A8: C08B0048  lfs f4, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82A6E2AC: ED640032  fmuls f11, f4, f0
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E2B0: C04B0044  lfs f2, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6E2B4: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E2B8: FDA0081E  fctiwz f13, f1
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82A6E2BC: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82A6E2C0: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E2C4: FD00581E  fctiwz f8, f11
	ctx.f[8].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A6E2C8: D9010060  stfd f8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[8].u64 ) };
	// 82A6E2CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6E2D0: ED850032  fmuls f12, f5, f0
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E2D4: ED430032  fmuls f10, f3, f0
	ctx.f[10].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E2D8: FD20601E  fctiwz f9, f12
	ctx.f[9].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A6E2DC: D9210050  stfd f9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[9].u64 ) };
	// 82A6E2E0: FCE0501E  fctiwz f7, f10
	ctx.f[7].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82A6E2E4: D8E10058  stfd f7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[7].u64 ) };
	// 82A6E2E8: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E2EC: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E2F0: 50A4402E  rlwimi r4, r5, 8, 0, 0x17
	ctx.r[4].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[4].u64 & 0xFFFFFFFF000000FF);
	// 82A6E2F4: 5086402E  rlwimi r6, r4, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[4].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82A6E2F8: 50C3402E  rlwimi r3, r6, 8, 0, 0x17
	ctx.r[3].u64 = (((ctx.r[6].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[3].u64 & 0xFFFFFFFF000000FF);
	// 82A6E2FC: 906A000C  stw r3, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82A6E300: C06B004C  lfs f3, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A6E304: C0AB0054  lfs f5, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A6E308: C08B0050  lfs f4, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82A6E30C: C0CB0048  lfs f6, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A6E310: EDA60032  fmuls f13, f6, f0
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E314: FD40681E  fctiwz f10, f13
	ctx.f[10].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82A6E318: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A6E31C: EC430032  fmuls f2, f3, f0
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E320: ED850032  fmuls f12, f5, f0
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E324: ED640032  fmuls f11, f4, f0
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E328: FC20101E  fctiwz f1, f2
	ctx.f[1].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82A6E32C: D8210058  stfd f1, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[1].u64 ) };
	// 82A6E330: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E334: FD20601E  fctiwz f9, f12
	ctx.f[9].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A6E338: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6E33C: D9210060  stfd f9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[9].u64 ) };
	// 82A6E340: 5107402E  rlwimi r7, r8, 8, 0, 0x17
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[7].u64 & 0xFFFFFFFF000000FF);
	// 82A6E344: 80C10064  lwz r6, 0x64(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6E348: FD00581E  fctiwz f8, f11
	ctx.f[8].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A6E34C: D9010060  stfd f8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[8].u64 ) };
	// 82A6E350: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6E354: 50E5402E  rlwimi r5, r7, 8, 0, 0x17
	ctx.r[5].u64 = (((ctx.r[7].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[5].u64 & 0xFFFFFFFF000000FF);
	// 82A6E358: 50A6402E  rlwimi r6, r5, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[5].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82A6E35C: 90CA0010  stw r6, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82A6E360: C0AB0054  lfs f5, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A6E364: C0EB0058  lfs f7, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A6E368: EC670032  fmuls f3, f7, f0
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E36C: C0CB005C  lfs f6, 0x5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A6E370: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E374: EC260032  fmuls f1, f6, f0
	ctx.f[1].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E378: C04B0060  lfs f2, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6E37C: ED820032  fmuls f12, f2, f0
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E380: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 82A6E384: FD60181E  fctiwz f11, f3
	ctx.f[11].s64 = if ctx.f[3].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[3].f64.trunc() as i32 as i64 };
	// 82A6E388: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 82A6E38C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6E390: FDA0201E  fctiwz f13, f4
	ctx.f[13].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 82A6E394: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82A6E398: FD40081E  fctiwz f10, f1
	ctx.f[10].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82A6E39C: D9410068  stfd f10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[10].u64 ) };
	// 82A6E3A0: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6E3A4: FD20601E  fctiwz f9, f12
	ctx.f[9].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A6E3A8: D9210060  stfd f9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[9].u64 ) };
	// 82A6E3AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E3B0: 5068402E  rlwimi r8, r3, 8, 0, 0x17
	ctx.r[8].u64 = (((ctx.r[3].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[8].u64 & 0xFFFFFFFF000000FF);
	// 82A6E3B4: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6E3B8: 5107402E  rlwimi r7, r8, 8, 0, 0x17
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[7].u64 & 0xFFFFFFFF000000FF);
	// 82A6E3BC: 50E4402E  rlwimi r4, r7, 8, 0, 0x17
	ctx.r[4].u64 = (((ctx.r[7].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[4].u64 & 0xFFFFFFFF000000FF);
	// 82A6E3C0: 908A0014  stw r4, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 82A6E3C4: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 82A6E3C8: 4082FCF4  bne 0x82a6e0bc
	if !ctx.cr[0].eq {
	pc = 0x82A6E0BC; continue 'dispatch;
	}
	// 82A6E3CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6E3D0: 807A00B4  lwz r3, 0xb4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A6E3D4: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82A6E3D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E3DC: 4811348D  bl 0x82b81868
	ctx.lr = 0x82A6E3E0;
	sub_82B81868(ctx, base);
	// 82A6E3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E3E4: 4B7AD955  bl 0x8221bd38
	ctx.lr = 0x82A6E3E8;
	sub_8221BD38(ctx, base);
	// 82A6E3E8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A6E3EC: 4823B064  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A6E3F0 => {
    //   block [0x82A6E3F0..0x82A6E438)
	// 82A6E3F0: 3960001C  li r11, 0x1c
	ctx.r[11].s64 = 28;
	// 82A6E3F4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A6E3F8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A6E3FC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A6E400: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6E404: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6E408: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A6E40C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6E410: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6E414: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6E418: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6E41C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6E420: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6E424: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A6E428: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6E42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E430: 481136F9  bl 0x82b81b28
	ctx.lr = 0x82A6E434;
	sub_82B81B28(ctx, base);
	// 82A6E434: 4BFFFC3C  b 0x82a6e070
	pc = 0x82A6E070; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6E438 size=204
    let mut pc: u32 = 0x82A6E438;
    'dispatch: loop {
        match pc {
            0x82A6E438 => {
    //   block [0x82A6E438..0x82A6E504)
	// 82A6E438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E43C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6E440: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6E444: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E448: E9640000  ld r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82A6E44C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A6E450: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A6E454: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A6E458: 3BEA9490  addi r31, r10, -0x6b70
	ctx.r[31].s64 = ctx.r[10].s64 + -27504;
	// 82A6E45C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 82A6E460: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82A6E464: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A6E468: C0E10064  lfs f7, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A6E46C: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 82A6E470: C0C1006C  lfs f6, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A6E474: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A6E478: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6E47C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A6E480: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A6E484: C1210054  lfs f9, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A6E488: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82A6E48C: C101005C  lfs f8, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A6E490: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A6E494: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6E498: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6E49C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E4A0: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A6E4A4: ECA73028  fsubs f5, f7, f6
	ctx.f[5].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82A6E4A8: C01FFFF4  lfs f0, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6E4AC: EC4C0032  fmuls f2, f12, f0
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E4B0: C1AA9490  lfs f13, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E4B4: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A6E4B8: EC2B602A  fadds f1, f11, f12
	ctx.f[1].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82A6E4BC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A6E4C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6E4C4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A6E4C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A6E4CC: D0210068  stfs f1, 0x68(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A6E4D0: EC850032  fmuls f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6E4D4: EC65482A  fadds f3, f5, f9
	ctx.f[3].f64 = ((ctx.f[5].f64 + ctx.f[9].f64) as f32) as f64;
	// 82A6E4D8: D061006C  stfs f3, 0x6c(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A6E4DC: EDAA102A  fadds f13, f10, f2
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[2].f64) as f32) as f64;
	// 82A6E4E0: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A6E4E4: EC04402A  fadds f0, f4, f8
	ctx.f[0].f64 = ((ctx.f[4].f64 + ctx.f[8].f64) as f32) as f64;
	// 82A6E4E8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A6E4EC: 4800001D  bl 0x82a6e508
	ctx.lr = 0x82A6E4F0;
	sub_82A6E508(ctx, base);
	// 82A6E4F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6E4F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6E4F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6E4FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6E500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6E508 size=396
    let mut pc: u32 = 0x82A6E508;
    'dispatch: loop {
        match pc {
            0x82A6E508 => {
    //   block [0x82A6E508..0x82A6E694)
	// 82A6E508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E50C: 4823AEF9  bl 0x82ca9404
	ctx.lr = 0x82A6E510;
	sub_82CA93D0(ctx, base);
	// 82A6E510: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E514: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A6E518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6E51C: 3B6B6088  addi r27, r11, 0x6088
	ctx.r[27].s64 = ctx.r[11].s64 + 24712;
	// 82A6E520: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82A6E524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E528: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A6E52C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A6E530: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6E534: 4B78BB3D  bl 0x821fa070
	ctx.lr = 0x82A6E538;
	sub_821FA070(ctx, base);
	// 82A6E538: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82A6E53C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6E540: 4B78BB31  bl 0x821fa070
	ctx.lr = 0x82A6E544;
	sub_821FA070(ctx, base);
	// 82A6E544: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82A6E548: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82A6E54C: 80C100DC  lwz r6, 0xdc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A6E550: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A6E554: C11F0000  lfs f8, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A6E558: 38EADF40  addi r7, r10, -0x20c0
	ctx.r[7].s64 = ctx.r[10].s64 + -8384;
	// 82A6E55C: C0DE0004  lfs f6, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A6E560: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6E564: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 82A6E568: B1610058  sth r11, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u16 ) };
	// 82A6E56C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82A6E570: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82A6E574: C0BE0000  lfs f5, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A6E578: B1410056  sth r10, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u16 ) };
	// 82A6E57C: 38859484  addi r4, r5, -0x6b7c
	ctx.r[4].s64 = ctx.r[5].s64 + -27516;
	// 82A6E580: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 82A6E584: C09F0004  lfs f4, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82A6E588: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82A6E58C: C07D0000  lfs f3, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A6E590: C1A59484  lfs f13, -0x6b7c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E594: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A6E598: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82A6E59C: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A6E5A0: C1841FFC  lfs f12, 0x1ffc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6E5A4: B0C10052  sth r6, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[6].u16 ) };
	// 82A6E5A8: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A6E5AC: B061005A  sth r3, 0x5a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[3].u16 ) };
	// 82A6E5B0: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A6E5B4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A6E5B8: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82A6E5BC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82A6E5C0: C05D0004  lfs f2, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6E5C4: C1A44144  lfs f13, 0x4144(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E5C8: C03C0000  lfs f1, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6E5CC: D061007C  stfs f3, 0x7c(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A6E5D0: 81690364  lwz r11, 0x364(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6E5D4: D0410080  stfs f2, 0x80(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A6E5D8: 8147003C  lwz r10, 0x3c(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) } as u64;
	// 82A6E5DC: D0410094  stfs f2, 0x94(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A6E5E0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A6E5E4: 80A100F8  lwz r5, 0xf8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A6E5E8: D06100A4  stfs f3, 0xa4(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A6E5EC: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82A6E5F0: D0210090  stfs f1, 0x90(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A6E5F4: D02100B8  stfs f1, 0xb8(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82A6E5F8: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 82A6E5FC: E9690010  ld r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 82A6E600: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A6E604: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A6E608: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A6E60C: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 82A6E610: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82A6E614: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6E618: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82A6E61C: 656B0008  oris r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 524288;
	// 82A6E620: ED280338  fmsubs f9, f8, f12, f0
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A6E624: C15C0004  lfs f10, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A6E628: ED06033C  fnmsubs f8, f6, f12, f0
	ctx.f[8].f64 = -(((ctx.f[6].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A6E62C: D14100A8  stfs f10, 0xa8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A6E630: ECC50338  fmsubs f6, f5, f12, f0
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A6E634: D14100BC  stfs f10, 0xbc(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82A6E638: ECA4033C  fnmsubs f5, f4, f12, f0
	ctx.f[5].f64 = -(((ctx.f[4].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A6E63C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6E640: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A6E644: F9690010  std r11, 0x10(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82A6E648: 914870B8  stw r10, 0x70b8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 82A6E64C: FC805818  frsp f4, f11
	ctx.f[4].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82A6E650: EC6D3824  fdivs f3, f13, f7
	ctx.f[3].f64 = ((ctx.f[13].f64 / ctx.f[7].f64) as f32) as f64;
	// 82A6E654: EC402024  fdivs f2, f0, f4
	ctx.f[2].f64 = ((ctx.f[0].f64 / ctx.f[4].f64) as f32) as f64;
	// 82A6E658: EC23482A  fadds f1, f3, f9
	ctx.f[1].f64 = ((ctx.f[3].f64 + ctx.f[9].f64) as f32) as f64;
	// 82A6E65C: D0210070  stfs f1, 0x70(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A6E660: EC03302A  fadds f0, f3, f6
	ctx.f[0].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82A6E664: D0210098  stfs f1, 0x98(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A6E668: EDA2402A  fadds f13, f2, f8
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82A6E66C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A6E670: ED82282A  fadds f12, f2, f5
	ctx.f[12].f64 = ((ctx.f[2].f64 + ctx.f[5].f64) as f32) as f64;
	// 82A6E674: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A6E678: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A6E67C: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A6E680: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A6E684: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82A6E688: 4B79BD69  bl 0x8220a3f0
	ctx.lr = 0x82A6E68C;
	sub_8220A3F0(ctx, base);
	// 82A6E68C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A6E690: 4823ADC4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6E698 size=1036
    let mut pc: u32 = 0x82A6E698;
    'dispatch: loop {
        match pc {
            0x82A6E698 => {
    //   block [0x82A6E698..0x82A6E6CC)
	// 82A6E698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E69C: 4823AD71  bl 0x82ca940c
	ctx.lr = 0x82A6E6A0;
	sub_82CA93D0(ctx, base);
	// 82A6E6A0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A6E6A4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6E6A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E6AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6E6B0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 82A6E6B4: 817D011C  lwz r11, 0x11c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A6E6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6E6BC: 419A0010  beq cr6, 0x82a6e6cc
	if ctx.cr[6].eq {
	pc = 0x82A6E6CC; continue 'dispatch;
	}
	// 82A6E6C0: 389D0118  addi r4, r29, 0x118
	ctx.r[4].s64 = ctx.r[29].s64 + 280;
	// 82A6E6C4: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 82A6E6C8: 4B7C8959  bl 0x82237020
	ctx.lr = 0x82A6E6CC;
	sub_82237020(ctx, base);
	pc = 0x82A6E6CC; continue 'dispatch;
            }
            0x82A6E6CC => {
    //   block [0x82A6E6CC..0x82A6E834)
	// 82A6E6CC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A6E6D0: 894BCBD2  lbz r10, -0x342e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-13358 as u32) ) } as u64;
	// 82A6E6D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6E6D8: 419A03BC  beq cr6, 0x82a6ea94
	if ctx.cr[6].eq {
	pc = 0x82A6EA94; continue 'dispatch;
	}
	// 82A6E6DC: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82A6E6E0: 809FF9C0  lwz r4, -0x640(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 82A6E6E4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A6E6E8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82A6E6EC: 38E00017  li r7, 0x17
	ctx.r[7].s64 = 23;
	// 82A6E6F0: 91010078  stw r8, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 82A6E6F4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6E6F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6E6FC: 90E10080  stw r7, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 82A6E700: 38BD0100  addi r5, r29, 0x100
	ctx.r[5].s64 = ctx.r[29].s64 + 256;
	// 82A6E704: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6E708: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A6E70C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6E710: 3BDD0118  addi r30, r29, 0x118
	ctx.r[30].s64 = ctx.r[29].s64 + 280;
	// 82A6E714: 4B78D67D  bl 0x821fbd90
	ctx.lr = 0x82A6E718;
	sub_821FBD90(ctx, base);
	// 82A6E718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E71C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6E720: 4B78D4C9  bl 0x821fbbe8
	ctx.lr = 0x82A6E724;
	sub_821FBBE8(ctx, base);
	// 82A6E724: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A6E728: 4B78D869  bl 0x821fbf90
	ctx.lr = 0x82A6E72C;
	sub_821FBF90(ctx, base);
	// 82A6E72C: 4B78D5BD  bl 0x821fbce8
	ctx.lr = 0x82A6E730;
	sub_821FBCE8(ctx, base);
	// 82A6E730: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A6E734: 3CC0834B  lis r6, -0x7cb5
	ctx.r[6].s64 = -2092236800;
	// 82A6E738: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 82A6E73C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A6E740: 38A67E70  addi r5, r6, 0x7e70
	ctx.r[5].s64 = ctx.r[6].s64 + 32368;
	// 82A6E744: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82A6E748: 389F2008  addi r4, r31, 0x2008
	ctx.r[4].s64 = ctx.r[31].s64 + 8200;
	// 82A6E74C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6E750: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E754: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6E758: 7CAAF92E  stwx r5, r10, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	// 82A6E75C: 815F2004  lwz r10, 0x2004(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E760: 813F2000  lwz r9, 0x2000(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6E764: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 82A6E768: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6E76C: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82A6E770: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6E774: 917F2004  stw r11, 0x2004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 82A6E778: 915F2000  stw r10, 0x2000(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 82A6E77C: 7CA8212E  stwx r5, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[5].u32) };
	// 82A6E780: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 82A6E784: 815F4008  lwz r10, 0x4008(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16392 as u32) ) } as u64;
	// 82A6E788: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6E78C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A6E790: 915F4008  stw r10, 0x4008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 82A6E794: 917F400C  stw r11, 0x400c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 82A6E798: 4B773061  bl 0x821e17f8
	ctx.lr = 0x82A6E79C;
	sub_821E17F8(ctx, base);
	// 82A6E79C: 4B7D3A35  bl 0x822421d0
	ctx.lr = 0x82A6E7A0;
	sub_822421D0(ctx, base);
	// 82A6E7A0: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 82A6E7A4: 3867B158  addi r3, r7, -0x4ea8
	ctx.r[3].s64 = ctx.r[7].s64 + -20136;
	// 82A6E7A8: 4B73F5A9  bl 0x821add50
	ctx.lr = 0x82A6E7AC;
	sub_821ADD50(ctx, base);
	// 82A6E7AC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A6E7B0: 3C808331  lis r4, -0x7ccf
	ctx.r[4].s64 = -2093940736;
	// 82A6E7B4: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 82A6E7B8: 38647064  addi r3, r4, 0x7064
	ctx.r[3].s64 = ctx.r[4].s64 + 28772;
	// 82A6E7BC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A6E7C0: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 82A6E7C4: 38AA0DB8  addi r5, r10, 0xdb8
	ctx.r[5].s64 = ctx.r[10].s64 + 3512;
	// 82A6E7C8: 892B008D  lbz r9, 0x8d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 82A6E7CC: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6E7D0: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A6E7D4: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 82A6E7D8: 814B007C  lwz r10, 0x7c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6E7DC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A6E7E0: 3949DFF8  addi r10, r9, -0x2008
	ctx.r[10].s64 = ctx.r[9].s64 + -8200;
	// 82A6E7E4: 419A0084  beq cr6, 0x82a6e868
	if ctx.cr[6].eq {
	pc = 0x82A6E868; continue 'dispatch;
	}
	// 82A6E7E8: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6E7EC: 80EB0080  lwz r7, 0x80(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A6E7F0: 7D243838  and r4, r9, r7
	ctx.r[4].u64 = ctx.r[9].u64 & ctx.r[7].u64;
	// 82A6E7F4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A6E7F8: 409A003C  bne cr6, 0x82a6e834
	if !ctx.cr[6].eq {
	pc = 0x82A6E834; continue 'dispatch;
	}
	// 82A6E7FC: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E800: 7D293B78  or r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 82A6E804: 386B0078  addi r3, r11, 0x78
	ctx.r[3].s64 = ctx.r[11].s64 + 120;
	// 82A6E808: 54871838  slwi r7, r4, 3
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6E80C: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82A6E810: 7C67512E  stwx r3, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82A6E814: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6E818: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E81C: 54871838  slwi r7, r4, 3
	ctx.r[7].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6E820: 7C675214  add r3, r7, r10
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82A6E824: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6E828: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E82C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6E830: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6E834; continue 'dispatch;
            }
            0x82A6E834 => {
    //   block [0x82A6E834..0x82A6E868)
	// 82A6E834: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A6E838: 910B007C  stw r8, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82A6E83C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6E840: 409A0028  bne cr6, 0x82a6e868
	if !ctx.cr[6].eq {
	pc = 0x82A6E868; continue 'dispatch;
	}
	// 82A6E844: 81460DB0  lwz r10, 0xdb0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A6E848: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A6E84C: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 82A6E850: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A6E854: 992B008C  stb r9, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[9].u8 ) };
	// 82A6E858: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82A6E85C: 90E60DB0  stw r7, 0xdb0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 82A6E860: 7D04292E  stwx r8, r4, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[5].u32), ctx.r[8].u32) };
	// 82A6E864: 48000008  b 0x82a6e86c
	pc = 0x82A6E86C; continue 'dispatch;
            }
            0x82A6E868 => {
    //   block [0x82A6E868..0x82A6E86C)
	// 82A6E868: 80E60DB0  lwz r7, 0xdb0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A6E86C; continue 'dispatch;
            }
            0x82A6E86C => {
    //   block [0x82A6E86C..0x82A6E8D8)
	// 82A6E86C: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 82A6E870: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A6E874: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6E878: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6E87C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82A6E880: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6E884: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6E888: 419A0080  beq cr6, 0x82a6e908
	if ctx.cr[6].eq {
	pc = 0x82A6E908; continue 'dispatch;
	}
	// 82A6E88C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6E890: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A6E894: 7D244038  and r4, r9, r8
	ctx.r[4].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6E898: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A6E89C: 409A003C  bne cr6, 0x82a6e8d8
	if !ctx.cr[6].eq {
	pc = 0x82A6E8D8; continue 'dispatch;
	}
	// 82A6E8A0: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E8A4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6E8A8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82A6E8AC: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6E8B0: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82A6E8B4: 7C68512E  stwx r3, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82A6E8B8: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6E8BC: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E8C0: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6E8C4: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6E8C8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6E8CC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E8D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6E8D4: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6E8D8; continue 'dispatch;
            }
            0x82A6E8D8 => {
    //   block [0x82A6E8D8..0x82A6E908)
	// 82A6E8D8: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A6E8DC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A6E8E0: 912B0034  stw r9, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 82A6E8E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6E8E8: 409A0020  bne cr6, 0x82a6e908
	if !ctx.cr[6].eq {
	pc = 0x82A6E908; continue 'dispatch;
	}
	// 82A6E8EC: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6E8F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6E8F4: 390B0030  addi r8, r11, 0x30
	ctx.r[8].s64 = ctx.r[11].s64 + 48;
	// 82A6E8F8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82A6E8FC: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82A6E900: 90E60DB0  stw r7, 0xdb0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 82A6E904: 7D09292E  stwx r8, r9, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), ctx.r[8].u32) };
	pc = 0x82A6E908; continue 'dispatch;
            }
            0x82A6E908 => {
    //   block [0x82A6E908..0x82A6E970)
	// 82A6E908: 894B005D  lbz r10, 0x5d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(93 as u32) ) } as u64;
	// 82A6E90C: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6E910: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6E914: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82A6E918: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6E91C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6E920: 419A0080  beq cr6, 0x82a6e9a0
	if ctx.cr[6].eq {
	pc = 0x82A6E9A0; continue 'dispatch;
	}
	// 82A6E924: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6E928: 810B0050  lwz r8, 0x50(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6E92C: 7D244038  and r4, r9, r8
	ctx.r[4].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82A6E930: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A6E934: 409A003C  bne cr6, 0x82a6e970
	if !ctx.cr[6].eq {
	pc = 0x82A6E970; continue 'dispatch;
	}
	// 82A6E938: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E93C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 82A6E940: 386B0048  addi r3, r11, 0x48
	ctx.r[3].s64 = ctx.r[11].s64 + 72;
	// 82A6E944: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6E948: 912B0050  stw r9, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A6E94C: 7C68512E  stwx r3, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82A6E950: 812B004C  lwz r9, 0x4c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A6E954: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E958: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6E95C: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6E960: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6E964: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6E968: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6E96C: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6E970; continue 'dispatch;
            }
            0x82A6E970 => {
    //   block [0x82A6E970..0x82A6E9A0)
	// 82A6E970: 894B005C  lbz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6E974: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A6E978: 912B004C  stw r9, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 82A6E97C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6E980: 409A0020  bne cr6, 0x82a6e9a0
	if !ctx.cr[6].eq {
	pc = 0x82A6E9A0; continue 'dispatch;
	}
	// 82A6E984: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6E988: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6E98C: 388B0048  addi r4, r11, 0x48
	ctx.r[4].s64 = ctx.r[11].s64 + 72;
	// 82A6E990: 39270001  addi r9, r7, 1
	ctx.r[9].s64 = ctx.r[7].s64 + 1;
	// 82A6E994: 994B005C  stb r10, 0x5c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 82A6E998: 91260DB0  stw r9, 0xdb0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 82A6E99C: 7C88292E  stwx r4, r8, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32), ctx.r[4].u32) };
	pc = 0x82A6E9A0; continue 'dispatch;
            }
            0x82A6E9A0 => {
    //   block [0x82A6E9A0..0x82A6EA94)
	// 82A6E9A0: 38600055  li r3, 0x55
	ctx.r[3].s64 = 85;
	// 82A6E9A4: 4B7BD86D  bl 0x8222c210
	ctx.lr = 0x82A6E9A8;
	sub_8222C210(ctx, base);
	// 82A6E9A8: 38600056  li r3, 0x56
	ctx.r[3].s64 = 86;
	// 82A6E9AC: 4B79A165  bl 0x82208b10
	ctx.lr = 0x82A6E9B0;
	sub_82208B10(ctx, base);
	// 82A6E9B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A6E9B4: C1BD00DC  lfs f13, 0xdc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6E9B8: 3FE0820A  lis r31, -0x7df6
	ctx.r[31].s64 = -2113273856;
	// 82A6E9BC: 3940010C  li r10, 0x10c
	ctx.r[10].s64 = 268;
	// 82A6E9C0: 39200108  li r9, 0x108
	ctx.r[9].s64 = 264;
	// 82A6E9C4: 38FF9484  addi r7, r31, -0x6b7c
	ctx.r[7].s64 = ctx.r[31].s64 + -27516;
	// 82A6E9C8: C80B6E18  lfd f0, 0x6e18(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28184 as u32) ) };
	// 82A6E9CC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82A6E9D0: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82A6E9D4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	pc = 0x82A6EA94; continue 'dispatch;
            }
            0x82A6EA94 => {
    //   block [0x82A6EA94..0x82A6EAA4)
	// 82A6EA94: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A6EA98: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A6EA9C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A6EAA0: 4823A9BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6EAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6EAA8 size=2184
    let mut pc: u32 = 0x82A6EAA8;
    'dispatch: loop {
        match pc {
            0x82A6EAA8 => {
    //   block [0x82A6EAA8..0x82A6EB0C)
	// 82A6EAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6EAAC: 4823A949  bl 0x82ca93f4
	ctx.lr = 0x82A6EAB0;
	sub_82CA93D0(ctx, base);
	// 82A6EAB0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6EAB4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A6EAB8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A6EABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6EAC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6EAC4: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 82A6EAC8: 894ACBD2  lbz r10, -0x342e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-13358 as u32) ) } as u64;
	// 82A6EACC: 892B05A1  lbz r9, 0x5a1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1441 as u32) ) } as u64;
	// 82A6EAD0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6EAD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6EAD8: 419A0034  beq cr6, 0x82a6eb0c
	if ctx.cr[6].eq {
	pc = 0x82A6EB0C; continue 'dispatch;
	}
	// 82A6EADC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A6EAE0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82A6EAE4: 38EB16B8  addi r7, r11, 0x16b8
	ctx.r[7].s64 = ctx.r[11].s64 + 5816;
	// 82A6EAE8: 81280DB4  lwz r9, 0xdb4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3508 as u32) ) } as u64;
	// 82A6EAEC: 81670010  lwz r11, 0x10(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6EAF0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A6EAF4: 514B0FBC  rlwimi r11, r10, 1, 0x1e, 0x1e
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(1) as u64) & 0x0000000000000002) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFFD);
	// 82A6EAF8: 7CC55A78  xor r5, r6, r11
	ctx.r[5].u64 = ctx.r[6].u64 ^ ctx.r[11].u64;
	// 82A6EAFC: 91670010  stw r11, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A6EB00: 7CAB4B78  or r11, r5, r9
	ctx.r[11].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 82A6EB04: 91680DB4  stw r11, 0xdb4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(3508 as u32), ctx.r[11].u32 ) };
	// 82A6EB08: 48000018  b 0x82a6eb20
	pc = 0x82A6EB20; continue 'dispatch;
            }
            0x82A6EB0C => {
    //   block [0x82A6EB0C..0x82A6EB20)
	// 82A6EB0C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A6EB10: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6EB14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6EB18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6EB1C: 4B7FF605  bl 0x8226e120
	ctx.lr = 0x82A6EB20;
	sub_8226E120(ctx, base);
	pc = 0x82A6EB20; continue 'dispatch;
            }
            0x82A6EB20 => {
    //   block [0x82A6EB20..0x82A6F330)
	// 82A6EB20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6EB24: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82A6EB28: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A6EB2C: C1BE0158  lfs f13, 0x158(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6EB30: 392000E0  li r9, 0xe0
	ctx.r[9].s64 = 224;
	// 82A6EB34: C19E00B8  lfs f12, 0xb8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6EB38: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82A6EB3C: C17E013C  lfs f11, 0x13c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6EB40: 38C00BE0  li r6, 0xbe0
	ctx.r[6].s64 = 3040;
	// 82A6EB44: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6EB48: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6F330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6F330 size=1428
    let mut pc: u32 = 0x82A6F330;
    'dispatch: loop {
        match pc {
            0x82A6F330 => {
    //   block [0x82A6F330..0x82A6F434)
	// 82A6F330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6F334: 4823A0B5  bl 0x82ca93e8
	ctx.lr = 0x82A6F338;
	sub_82CA93D0(ctx, base);
	// 82A6F338: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6F33C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A6F340: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A6F344: 3B0BDED4  addi r24, r11, -0x212c
	ctx.r[24].s64 = ctx.r[11].s64 + -8492;
	// 82A6F348: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82A6F34C: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 82A6F350: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 82A6F354: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 82A6F358: 80D80004  lwz r6, 4(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F35C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A6F360: 78FCFFE6  rldicr r28, r7, 0x3f, 0x3f
	ctx.r[28].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82A6F364: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82A6F368: 3EE08331  lis r23, -0x7ccf
	ctx.r[23].s64 = -2093940736;
	// 82A6F36C: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 82A6F370: 83E60804  lwz r31, 0x804(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2052 as u32) ) } as u64;
	// 82A6F374: 3F208336  lis r25, -0x7cca
	ctx.r[25].s64 = -2093613056;
	// 82A6F378: 3AA80DB8  addi r21, r8, 0xdb8
	ctx.r[21].s64 = ctx.r[8].s64 + 3512;
	// 82A6F37C: 3BC92390  addi r30, r9, 0x2390
	ctx.r[30].s64 = ctx.r[9].s64 + 9104;
	// 82A6F380: 3B6A6F38  addi r27, r10, 0x6f38
	ctx.r[27].s64 = ctx.r[10].s64 + 28472;
	// 82A6F384: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6F388: 3BAB63A0  addi r29, r11, 0x63a0
	ctx.r[29].s64 = ctx.r[11].s64 + 25504;
	// 82A6F38C: 41980294  blt cr6, 0x82a6f620
	if ctx.cr[6].lt {
	pc = 0x82A6F620; continue 'dispatch;
	}
	// 82A6F390: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A6F394: 815A00B0  lwz r10, 0xb0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A6F398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6F39C: 80790364  lwz r3, 0x364(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6F3A0: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82A6F3A4: 7F864C36  srd r6, r28, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[28].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82A6F3A8: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F3AC: 4B747B35  bl 0x821b6ee0
	ctx.lr = 0x82A6F3B0;
	sub_821B6EE0(ctx, base);
	// 82A6F3B0: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6F3B4: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F3B8: 397D0AB0  addi r11, r29, 0xab0
	ctx.r[11].s64 = ctx.r[29].s64 + 2736;
	// 82A6F3BC: 7D1F5214  add r8, r31, r10
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A6F3C0: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82A6F3C4: 55051838  slwi r5, r8, 3
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A6F3C8: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A6F3CC: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F3D0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F3D4: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F3D8: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F3DC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F3E0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F3E4: 419A007C  beq cr6, 0x82a6f460
	if ctx.cr[6].eq {
	pc = 0x82A6F460; continue 'dispatch;
	}
	// 82A6F3E8: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F3EC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F3F0: 7CE44038  and r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F3F4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A6F3F8: 409A003C  bne cr6, 0x82a6f434
	if !ctx.cr[6].eq {
	pc = 0x82A6F434; continue 'dispatch;
	}
	// 82A6F3FC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F400: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F404: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6F408: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A6F40C: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F410: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F414: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F418: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F41C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A6F420: 90890004  stw r4, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A6F424: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F428: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A6F42C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F430: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x82A6F434; continue 'dispatch;
            }
            0x82A6F434 => {
    //   block [0x82A6F434..0x82A6F460)
	// 82A6F434: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F438: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6F43C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F440: 409A0020  bne cr6, 0x82a6f460
	if !ctx.cr[6].eq {
	pc = 0x82A6F460; continue 'dispatch;
	}
	// 82A6F444: 81560DB0  lwz r10, 0xdb0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A6F448: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F44C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6F450: 388A0001  addi r4, r10, 1
	ctx.r[4].s64 = ctx.r[10].s64 + 1;
	// 82A6F454: 90960DB0  stw r4, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6F458: 7D68A92E  stwx r11, r8, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	// 82A6F45C: 48000008  b 0x82a6f464
	pc = 0x82A6F464; continue 'dispatch;
            }
            0x82A6F460 => {
    //   block [0x82A6F460..0x82A6F464)
	// 82A6F460: 80960DB0  lwz r4, 0xdb0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A6F464; continue 'dispatch;
            }
            0x82A6F464 => {
    //   block [0x82A6F464..0x82A6F4D0)
	// 82A6F464: 397D0C90  addi r11, r29, 0xc90
	ctx.r[11].s64 = ctx.r[29].s64 + 3216;
	// 82A6F468: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A6F46C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F470: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F474: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F478: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F47C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F480: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F484: 419A0070  beq cr6, 0x82a6f4f4
	if ctx.cr[6].eq {
	pc = 0x82A6F4F4; continue 'dispatch;
	}
	// 82A6F488: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F48C: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F490: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F494: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A6F498: 409A0038  bne cr6, 0x82a6f4d0
	if !ctx.cr[6].eq {
	pc = 0x82A6F4D0; continue 'dispatch;
	}
	// 82A6F49C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F4A0: 7CE34378  or r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F4A4: 54C81838  slwi r8, r6, 3
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6F4A8: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A6F4AC: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F4B0: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F4B4: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F4B8: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6F4BC: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6F4C0: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6F4C4: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F4C8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A6F4CC: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x82A6F4D0; continue 'dispatch;
            }
            0x82A6F4D0 => {
    //   block [0x82A6F4D0..0x82A6F4F4)
	// 82A6F4D0: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F4D4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6F4D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F4DC: 409A0018  bne cr6, 0x82a6f4f4
	if !ctx.cr[6].eq {
	pc = 0x82A6F4F4; continue 'dispatch;
	}
	// 82A6F4E0: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6F4E4: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F4E8: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6F4EC: 90960DB0  stw r4, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6F4F0: 7D6AA92E  stwx r11, r10, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	pc = 0x82A6F4F4; continue 'dispatch;
            }
            0x82A6F4F4 => {
    //   block [0x82A6F4F4..0x82A6F56C)
	// 82A6F4F4: 397D1230  addi r11, r29, 0x1230
	ctx.r[11].s64 = ctx.r[29].s64 + 4656;
	// 82A6F4F8: 81376FC0  lwz r9, 0x6fc0(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28608 as u32) ) } as u64;
	// 82A6F4FC: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A6F500: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82A6F504: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F508: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F50C: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F510: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F514: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F518: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F51C: 419A0074  beq cr6, 0x82a6f590
	if ctx.cr[6].eq {
	pc = 0x82A6F590; continue 'dispatch;
	}
	// 82A6F520: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F524: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F528: 7CE34038  and r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F52C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F530: 409A003C  bne cr6, 0x82a6f56c
	if !ctx.cr[6].eq {
	pc = 0x82A6F56C; continue 'dispatch;
	}
	// 82A6F534: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F538: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F53C: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6F540: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A6F544: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F548: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F54C: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F550: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F554: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A6F558: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A6F55C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F560: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 82A6F564: 81376FC0  lwz r9, 0x6fc0(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28608 as u32) ) } as u64;
	// 82A6F568: 906A2004  stw r3, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6F56C; continue 'dispatch;
            }
            0x82A6F56C => {
    //   block [0x82A6F56C..0x82A6F590)
	// 82A6F56C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F570: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A6F574: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F578: 409A0018  bne cr6, 0x82a6f590
	if !ctx.cr[6].eq {
	pc = 0x82A6F590; continue 'dispatch;
	}
	// 82A6F57C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6F580: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F584: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6F588: 90960DB0  stw r4, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6F58C: 7D6AA92E  stwx r11, r10, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	pc = 0x82A6F590; continue 'dispatch;
            }
            0x82A6F590 => {
    //   block [0x82A6F590..0x82A6F5FC)
	// 82A6F590: 397D1050  addi r11, r29, 0x1050
	ctx.r[11].s64 = ctx.r[29].s64 + 4176;
	// 82A6F594: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A6F598: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F59C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F5A0: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F5A4: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F5A8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F5AC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F5B0: 419A0070  beq cr6, 0x82a6f620
	if ctx.cr[6].eq {
	pc = 0x82A6F620; continue 'dispatch;
	}
	// 82A6F5B4: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F5B8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F5BC: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F5C0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A6F5C4: 409A0038  bne cr6, 0x82a6f5fc
	if !ctx.cr[6].eq {
	pc = 0x82A6F5FC; continue 'dispatch;
	}
	// 82A6F5C8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F5CC: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F5D0: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6F5D4: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A6F5D8: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F5DC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F5E0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F5E4: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6F5E8: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6F5EC: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A6F5F0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F5F4: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 82A6F5F8: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x82A6F5FC; continue 'dispatch;
            }
            0x82A6F5FC => {
    //   block [0x82A6F5FC..0x82A6F620)
	// 82A6F5FC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F600: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6F604: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F608: 409A0018  bne cr6, 0x82a6f620
	if !ctx.cr[6].eq {
	pc = 0x82A6F620; continue 'dispatch;
	}
	// 82A6F60C: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F610: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F614: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 82A6F618: 91560DB0  stw r10, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82A6F61C: 7D69A92E  stwx r11, r9, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	pc = 0x82A6F620; continue 'dispatch;
            }
            0x82A6F620 => {
    //   block [0x82A6F620..0x82A6F6CC)
	// 82A6F620: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F624: 83EB04BC  lwz r31, 0x4bc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1212 as u32) ) } as u64;
	// 82A6F628: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6F62C: 41980290  blt cr6, 0x82a6f8bc
	if ctx.cr[6].lt {
	pc = 0x82A6F8BC; continue 'dispatch;
	}
	// 82A6F630: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A6F634: 815A00B4  lwz r10, 0xb4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A6F638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6F63C: 80790364  lwz r3, 0x364(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(868 as u32) ) } as u64;
	// 82A6F640: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82A6F644: 7F864C36  srd r6, r28, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[28].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82A6F648: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F64C: 4B747895  bl 0x821b6ee0
	ctx.lr = 0x82A6F650;
	sub_821B6EE0(ctx, base);
	// 82A6F650: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6F654: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F658: 397D0AB0  addi r11, r29, 0xab0
	ctx.r[11].s64 = ctx.r[29].s64 + 2736;
	// 82A6F65C: 7D1F5214  add r8, r31, r10
	ctx.r[8].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A6F660: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A6F664: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A6F668: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F66C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F670: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F674: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F678: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F67C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F680: 419A0078  beq cr6, 0x82a6f6f8
	if ctx.cr[6].eq {
	pc = 0x82A6F6F8; continue 'dispatch;
	}
	// 82A6F684: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F688: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F68C: 7CE54038  and r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F690: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6F694: 409A0038  bne cr6, 0x82a6f6cc
	if !ctx.cr[6].eq {
	pc = 0x82A6F6CC; continue 'dispatch;
	}
	// 82A6F698: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F69C: 7CE44378  or r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F6A0: 54A31838  slwi r3, r5, 3
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6F6A4: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A6F6A8: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F6AC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F6B0: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F6B4: 54A81838  slwi r8, r5, 3
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6F6B8: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6F6BC: 90E40004  stw r7, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A6F6C0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F6C4: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 82A6F6C8: 906A2004  stw r3, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6F6CC; continue 'dispatch;
            }
            0x82A6F6CC => {
    //   block [0x82A6F6CC..0x82A6F6F8)
	// 82A6F6CC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F6D0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6F6D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F6D8: 409A0020  bne cr6, 0x82a6f6f8
	if !ctx.cr[6].eq {
	pc = 0x82A6F6F8; continue 'dispatch;
	}
	// 82A6F6DC: 81560DB0  lwz r10, 0xdb0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(3504 as u32) ) } as u64;
	// 82A6F6E0: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F6E4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F6E8: 388A0001  addi r4, r10, 1
	ctx.r[4].s64 = ctx.r[10].s64 + 1;
	// 82A6F6EC: 90960DB0  stw r4, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6F6F0: 7D69A92E  stwx r11, r9, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	// 82A6F6F4: 48000008  b 0x82a6f6fc
	pc = 0x82A6F6FC; continue 'dispatch;
            }
            0x82A6F6F8 => {
    //   block [0x82A6F6F8..0x82A6F6FC)
	// 82A6F6F8: 80960DB0  lwz r4, 0xdb0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x82A6F6FC; continue 'dispatch;
            }
            0x82A6F6FC => {
    //   block [0x82A6F6FC..0x82A6F76C)
	// 82A6F6FC: 397D0C90  addi r11, r29, 0xc90
	ctx.r[11].s64 = ctx.r[29].s64 + 3216;
	// 82A6F700: 80FB0008  lwz r7, 8(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F704: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A6F708: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F70C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F710: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F714: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F718: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A6F71C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F720: 419A0070  beq cr6, 0x82a6f790
	if ctx.cr[6].eq {
	pc = 0x82A6F790; continue 'dispatch;
	}
	// 82A6F724: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F728: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F72C: 7D054838  and r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A6F730: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A6F734: 409A0038  bne cr6, 0x82a6f76c
	if !ctx.cr[6].eq {
	pc = 0x82A6F76C; continue 'dispatch;
	}
	// 82A6F738: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F73C: 7D034B78  or r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 82A6F740: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F744: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A6F748: 7D69512E  stwx r11, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F74C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F750: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F754: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F758: 7C695214  add r3, r9, r10
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A6F75C: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A6F760: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F764: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A6F768: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x82A6F76C; continue 'dispatch;
            }
            0x82A6F76C => {
    //   block [0x82A6F76C..0x82A6F790)
	// 82A6F76C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F770: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A6F774: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F778: 409A0018  bne cr6, 0x82a6f790
	if !ctx.cr[6].eq {
	pc = 0x82A6F790; continue 'dispatch;
	}
	// 82A6F77C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6F780: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F784: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6F788: 90960DB0  stw r4, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6F78C: 7D6AA92E  stwx r11, r10, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	pc = 0x82A6F790; continue 'dispatch;
            }
            0x82A6F790 => {
    //   block [0x82A6F790..0x82A6F808)
	// 82A6F790: 397D1230  addi r11, r29, 0x1230
	ctx.r[11].s64 = ctx.r[29].s64 + 4656;
	// 82A6F794: 81376FC0  lwz r9, 0x6fc0(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28608 as u32) ) } as u64;
	// 82A6F798: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A6F79C: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82A6F7A0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F7A4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F7A8: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F7AC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F7B0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F7B4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F7B8: 419A0074  beq cr6, 0x82a6f82c
	if ctx.cr[6].eq {
	pc = 0x82A6F82C; continue 'dispatch;
	}
	// 82A6F7BC: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F7C0: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F7C4: 7CE34038  and r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F7C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F7CC: 409A003C  bne cr6, 0x82a6f808
	if !ctx.cr[6].eq {
	pc = 0x82A6F808; continue 'dispatch;
	}
	// 82A6F7D0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F7D4: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F7D8: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A6F7DC: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A6F7E0: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F7E4: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F7E8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F7EC: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F7F0: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A6F7F4: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A6F7F8: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F7FC: 81376FC0  lwz r9, 0x6fc0(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28608 as u32) ) } as u64;
	// 82A6F800: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 82A6F804: 906A2004  stw r3, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x82A6F808; continue 'dispatch;
            }
            0x82A6F808 => {
    //   block [0x82A6F808..0x82A6F82C)
	// 82A6F808: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F80C: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A6F810: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F814: 409A0018  bne cr6, 0x82a6f82c
	if !ctx.cr[6].eq {
	pc = 0x82A6F82C; continue 'dispatch;
	}
	// 82A6F818: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6F81C: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F820: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A6F824: 90960DB0  stw r4, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 82A6F828: 7D6AA92E  stwx r11, r10, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	pc = 0x82A6F82C; continue 'dispatch;
            }
            0x82A6F82C => {
    //   block [0x82A6F82C..0x82A6F898)
	// 82A6F82C: 397D1050  addi r11, r29, 0x1050
	ctx.r[11].s64 = ctx.r[29].s64 + 4176;
	// 82A6F830: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82A6F834: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A6F838: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F83C: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A6F840: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A6F844: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A6F848: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 82A6F84C: 419A0070  beq cr6, 0x82a6f8bc
	if ctx.cr[6].eq {
	pc = 0x82A6F8BC; continue 'dispatch;
	}
	// 82A6F850: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 82A6F854: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F858: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A6F85C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A6F860: 409A0038  bne cr6, 0x82a6f898
	if !ctx.cr[6].eq {
	pc = 0x82A6F898; continue 'dispatch;
	}
	// 82A6F864: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F868: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 82A6F86C: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A6F870: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A6F874: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82A6F878: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F87C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6F880: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A6F884: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A6F888: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A6F88C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 82A6F890: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 82A6F894: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x82A6F898; continue 'dispatch;
            }
            0x82A6F898 => {
    //   block [0x82A6F898..0x82A6F8BC)
	// 82A6F898: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A6F89C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6F8A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6F8A4: 409A0018  bne cr6, 0x82a6f8bc
	if !ctx.cr[6].eq {
	pc = 0x82A6F8BC; continue 'dispatch;
	}
	// 82A6F8A8: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A6F8AC: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 82A6F8B0: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 82A6F8B4: 91560DB0  stw r10, 0xdb0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 82A6F8B8: 7D69A92E  stwx r11, r9, r21
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[21].u32), ctx.r[11].u32) };
	pc = 0x82A6F8BC; continue 'dispatch;
            }
            0x82A6F8BC => {
    //   block [0x82A6F8BC..0x82A6F8C4)
	// 82A6F8BC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A6F8C0: 48239B78  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6F8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6F8C8 size=1616
    let mut pc: u32 = 0x82A6F8C8;
    'dispatch: loop {
        match pc {
            0x82A6F8C8 => {
    //   block [0x82A6F8C8..0x82A6FF18)
	// 82A6F8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6F8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6F8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6F8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6F8D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6F8DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6F8E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6F8E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6F8E8: 4BFB2029  bl 0x82a21910
	ctx.lr = 0x82A6F8EC;
	sub_82A21910(ctx, base);
	// 82A6F8EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6F8F0: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82A6F8F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6F8F8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6FF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6FF18 size=160
    let mut pc: u32 = 0x82A6FF18;
    'dispatch: loop {
        match pc {
            0x82A6FF18 => {
    //   block [0x82A6FF18..0x82A6FF6C)
	// 82A6FF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6FF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6FF20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6FF24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6FF28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6FF2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6FF30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6FF34: B1210050  sth r9, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u16 ) };
	// 82A6FF38: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6FF3C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6FF40: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82A6FF44: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A6FF48: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6FF4C: 40990020  ble cr6, 0x82a6ff6c
	if !ctx.cr[6].gt {
	pc = 0x82A6FF6C; continue 'dispatch;
	}
	// 82A6FF50: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82A6FF54: 7CAB2050  subf r5, r11, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82A6FF58: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6FF5C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82A6FF60: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A6FF64: 48000055  bl 0x82a6ffb8
	ctx.lr = 0x82A6FF68;
	sub_82A6FFB8(ctx, base);
	// 82A6FF68: 48000038  b 0x82a6ffa0
	pc = 0x82A6FFA0; continue 'dispatch;
            }
            0x82A6FF6C => {
    //   block [0x82A6FF6C..0x82A6FF9C)
	// 82A6FF6C: 40980034  bge cr6, 0x82a6ffa0
	if !ctx.cr[6].lt {
	pc = 0x82A6FFA0; continue 'dispatch;
	}
	// 82A6FF70: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6FF74: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A6FF78: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A6FF7C: 419A0024  beq cr6, 0x82a6ffa0
	if ctx.cr[6].eq {
	pc = 0x82A6FFA0; continue 'dispatch;
	}
	// 82A6FF80: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82A6FF84: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6FF88: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A6FF8C: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A6FF90: 4081000C  ble 0x82a6ff9c
	if !ctx.cr[0].gt {
	pc = 0x82A6FF9C; continue 'dispatch;
	}
	// 82A6FF94: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A6FF98: 4823A091  bl 0x82caa028
	ctx.lr = 0x82A6FF9C;
	sub_82CAA028(ctx, base);
	pc = 0x82A6FF9C; continue 'dispatch;
            }
            0x82A6FF9C => {
    //   block [0x82A6FF9C..0x82A6FFA0)
	// 82A6FF9C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82A6FFA0; continue 'dispatch;
            }
            0x82A6FFA0 => {
    //   block [0x82A6FFA0..0x82A6FFB8)
	// 82A6FFA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6FFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6FFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6FFAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6FFB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6FFB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6FFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6FFB8 size=624
    let mut pc: u32 = 0x82A6FFB8;
    'dispatch: loop {
        match pc {
            0x82A6FFB8 => {
    //   block [0x82A6FFB8..0x82A6FFE8)
	// 82A6FFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6FFBC: 48239441  bl 0x82ca93fc
	ctx.lr = 0x82A6FFC0;
	sub_82CA93D0(ctx, base);
	// 82A6FFC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6FFC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6FFC8: A3260000  lhz r25, 0(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6FFCC: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A6FFD0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A6FFD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6FFD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6FFDC: 409A000C  bne cr6, 0x82a6ffe8
	if !ctx.cr[6].eq {
	pc = 0x82A6FFE8; continue 'dispatch;
	}
	// 82A6FFE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A6FFE4: 48000010  b 0x82a6fff4
	pc = 0x82A6FFF4; continue 'dispatch;
            }
            0x82A6FFE8 => {
    //   block [0x82A6FFE8..0x82A6FFF4)
	// 82A6FFE8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6FFEC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A6FFF0: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	pc = 0x82A6FFF4; continue 'dispatch;
            }
            0x82A6FFF4 => {
    //   block [0x82A6FFF4..0x82A70028)
	// 82A6FFF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6FFF8: 419A0228  beq cr6, 0x82a70220
	if ctx.cr[6].eq {
	pc = 0x82A70220; continue 'dispatch;
	}
	// 82A6FFFC: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A70000: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 82A70004: 7D0BE050  subf r8, r11, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A70008: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A7000C: 7D0B0E70  srawi r11, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 82A70010: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A70014: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A70018: 40980010  bge cr6, 0x82a70028
	if !ctx.cr[6].lt {
	pc = 0x82A70028; continue 'dispatch;
	}
	// 82A7001C: 4BFD74AD  bl 0x82a474c8
	ctx.lr = 0x82A70020;
	sub_82A474C8(ctx, base);
	// 82A70020: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A70024: 48239428  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A70028 => {
    //   block [0x82A70028..0x82A7004C)
	// 82A70028: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A7002C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A70030: 409800E4  bge cr6, 0x82a70114
	if !ctx.cr[6].lt {
	pc = 0x82A70114; continue 'dispatch;
	}
	// 82A70034: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A70038: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A7003C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A70040: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A70044: 41980008  blt cr6, 0x82a7004c
	if ctx.cr[6].lt {
	pc = 0x82A7004C; continue 'dispatch;
	}
	// 82A70048: 7F4B4A14  add r26, r11, r9
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A7004C; continue 'dispatch;
            }
            0x82A7004C => {
    //   block [0x82A7004C..0x82A70058)
	// 82A7004C: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A70050: 40980008  bge cr6, 0x82a70058
	if !ctx.cr[6].lt {
	pc = 0x82A70058; continue 'dispatch;
	}
	// 82A70054: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	pc = 0x82A70058; continue 'dispatch;
            }
            0x82A70058 => {
    //   block [0x82A70058..0x82A7008C)
	// 82A70058: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A7005C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70060: 4BFE8809  bl 0x82a58868
	ctx.lr = 0x82A70064;
	sub_82A58868(ctx, base);
	// 82A70064: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70068: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A7006C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A70070: 7D65E050  subf r11, r5, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[5].s64;
	// 82A70074: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70078: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A7007C: 7F66F214  add r27, r6, r30
	ctx.r[27].u64 = ctx.r[6].u64 + ctx.r[30].u64;
	// 82A70080: 4182000C  beq 0x82a7008c
	if ctx.cr[0].eq {
	pc = 0x82A7008C; continue 'dispatch;
	}
	// 82A70084: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A70088: 48239FA1  bl 0x82caa028
	ctx.lr = 0x82A7008C;
	sub_82CAA028(ctx, base);
	pc = 0x82A7008C; continue 'dispatch;
            }
            0x82A7008C => {
    //   block [0x82A7008C..0x82A7009C)
	// 82A7008C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A70090: 419A0018  beq cr6, 0x82a700a8
	if ctx.cr[6].eq {
	pc = 0x82A700A8; continue 'dispatch;
	}
	// 82A70094: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82A70098: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	pc = 0x82A7009C; continue 'dispatch;
            }
            0x82A7009C => {
    //   block [0x82A7009C..0x82A700A8)
	// 82A7009C: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A700A0: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A700A4: 4200FFF8  bdnz 0x82a7009c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A7009C; continue 'dispatch;
	}
	pc = 0x82A700A8; continue 'dispatch;
            }
            0x82A700A8 => {
    //   block [0x82A700A8..0x82A700D0)
	// 82A700A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A700AC: 7D5C5850  subf r10, r28, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82A700B0: 7D4B0E71  srawi. r11, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A700B4: 4182001C  beq 0x82a700d0
	if ctx.cr[0].eq {
	pc = 0x82A700D0; continue 'dispatch;
	}
	// 82A700B8: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A700BC: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A700C0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A700C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A700C8: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A700CC: 48239F5D  bl 0x82caa028
	ctx.lr = 0x82A700D0;
	sub_82CAA028(ctx, base);
	pc = 0x82A700D0; continue 'dispatch;
            }
            0x82A700D0 => {
    //   block [0x82A700D0..0x82A700F0)
	// 82A700D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A700D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A700D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A700DC: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A700E0: 7D4B0E70  srawi r11, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A700E4: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A700E8: 419A0008  beq cr6, 0x82a700f0
	if ctx.cr[6].eq {
	pc = 0x82A700F0; continue 'dispatch;
	}
	// 82A700EC: 4B7ABC4D  bl 0x8221bd38
	ctx.lr = 0x82A700F0;
	sub_8221BD38(ctx, base);
	pc = 0x82A700F0; continue 'dispatch;
            }
            0x82A700F0 => {
    //   block [0x82A700F0..0x82A70114)
	// 82A700F0: 574B083C  slwi r11, r26, 1
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A700F4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A700F8: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A700FC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A70100: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A70104: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A70108: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7010C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A70110: 4823933C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A70114 => {
    //   block [0x82A70114..0x82A70148)
	// 82A70114: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A70118: 7D7EE050  subf r11, r30, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 82A7011C: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A70120: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A70124: 40980088  bge cr6, 0x82a701ac
	if !ctx.cr[6].lt {
	pc = 0x82A701AC; continue 'dispatch;
	}
	// 82A70128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7012C: 419A001C  beq cr6, 0x82a70148
	if ctx.cr[6].eq {
	pc = 0x82A70148; continue 'dispatch;
	}
	// 82A70130: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A70134: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A70138: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A7013C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A70140: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A70144: 48239EE5  bl 0x82caa028
	ctx.lr = 0x82A70148;
	sub_82CAA028(ctx, base);
	pc = 0x82A70148; continue 'dispatch;
            }
            0x82A70148 => {
    //   block [0x82A70148..0x82A70168)
	// 82A70148: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A7014C: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A70150: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82A70154: 7D49E851  subf. r10, r9, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A70158: 4182001C  beq 0x82a70174
	if ctx.cr[0].eq {
	pc = 0x82A70174; continue 'dispatch;
	}
	// 82A7015C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A70160: 419A0014  beq cr6, 0x82a70174
	if ctx.cr[6].eq {
	pc = 0x82A70174; continue 'dispatch;
	}
	// 82A70164: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82A70168; continue 'dispatch;
            }
            0x82A70168 => {
    //   block [0x82A70168..0x82A70174)
	// 82A70168: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A7016C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A70170: 4200FFF8  bdnz 0x82a70168
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A70168; continue 'dispatch;
	}
	pc = 0x82A70174; continue 'dispatch;
            }
            0x82A70174 => {
    //   block [0x82A70174..0x82A70194)
	// 82A70174: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A70178: 57A9083C  slwi r9, r29, 1
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A7017C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A70180: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A70184: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A70188: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A7018C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A70190: 419A0090  beq cr6, 0x82a70220
	if ctx.cr[6].eq {
	pc = 0x82A70220; continue 'dispatch;
	}
	pc = 0x82A70194; continue 'dispatch;
            }
            0x82A70194 => {
    //   block [0x82A70194..0x82A701AC)
	// 82A70194: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A70198: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A7019C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A701A0: 409AFFF4  bne cr6, 0x82a70194
	if !ctx.cr[6].eq {
	pc = 0x82A70194; continue 'dispatch;
	}
	// 82A701A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A701A8: 482392A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A701AC => {
    //   block [0x82A701AC..0x82A701D8)
	// 82A701AC: 57BB083C  slwi r27, r29, 1
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82A701B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A701B4: 7FBBE050  subf r29, r27, r28
	ctx.r[29].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	// 82A701B8: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 82A701BC: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A701C0: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A701C4: 7F461A14  add r26, r6, r3
	ctx.r[26].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A701C8: 41820010  beq 0x82a701d8
	if ctx.cr[0].eq {
	pc = 0x82A701D8; continue 'dispatch;
	}
	// 82A701CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A701D0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A701D4: 48239E55  bl 0x82caa028
	ctx.lr = 0x82A701D8;
	sub_82CAA028(ctx, base);
	pc = 0x82A701D8; continue 'dispatch;
            }
            0x82A701D8 => {
    //   block [0x82A701D8..0x82A70200)
	// 82A701D8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A701DC: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82A701E0: 7D6B0E71  srawi. r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A701E4: 4081001C  ble 0x82a70200
	if !ctx.cr[0].gt {
	pc = 0x82A70200; continue 'dispatch;
	}
	// 82A701E8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A701EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A701F0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A701F4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A701F8: 7C6BE050  subf r3, r11, r28
	ctx.r[3].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A701FC: 48239E2D  bl 0x82caa028
	ctx.lr = 0x82A70200;
	sub_82CAA028(ctx, base);
	pc = 0x82A70200; continue 'dispatch;
            }
            0x82A70200 => {
    //   block [0x82A70200..0x82A70210)
	// 82A70200: 7D5BF214  add r10, r27, r30
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 82A70204: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A70208: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A7020C: 419A0014  beq cr6, 0x82a70220
	if ctx.cr[6].eq {
	pc = 0x82A70220; continue 'dispatch;
	}
	pc = 0x82A70210; continue 'dispatch;
            }
            0x82A70210 => {
    //   block [0x82A70210..0x82A70220)
	// 82A70210: B32B0000  sth r25, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u16 ) };
	// 82A70214: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A70218: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A7021C: 409AFFF4  bne cr6, 0x82a70210
	if !ctx.cr[6].eq {
	pc = 0x82A70210; continue 'dispatch;
	}
	pc = 0x82A70220; continue 'dispatch;
            }
            0x82A70220 => {
    //   block [0x82A70220..0x82A70228)
	// 82A70220: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A70224: 48239228  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70228 size=80
    let mut pc: u32 = 0x82A70228;
    'dispatch: loop {
        match pc {
            0x82A70228 => {
    //   block [0x82A70228..0x82A70260)
	// 82A70228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7022C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A70234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7023C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70240: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A70244: 48000105  bl 0x82a70348
	ctx.lr = 0x82A70248;
	sub_82A70348(ctx, base);
	// 82A70248: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A7024C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70254: 419A000C  beq cr6, 0x82a70260
	if ctx.cr[6].eq {
	pc = 0x82A70260; continue 'dispatch;
	}
	// 82A70258: 4B7ABAE1  bl 0x8221bd38
	ctx.lr = 0x82A7025C;
	sub_8221BD38(ctx, base);
	// 82A7025C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A70260; continue 'dispatch;
            }
            0x82A70260 => {
    //   block [0x82A70260..0x82A70278)
	// 82A70260: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A70264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7026C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A70270: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A70278 size=204
    let mut pc: u32 = 0x82A70278;
    'dispatch: loop {
        match pc {
            0x82A70278 => {
    //   block [0x82A70278..0x82A70324)
	// 82A70278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7027C: 48239191  bl 0x82ca940c
	ctx.lr = 0x82A70280;
	sub_82CA93D0(ctx, base);
	// 82A70280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70284: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70288: 480AAA91  bl 0x82b1ad18
	ctx.lr = 0x82A7028C;
	sub_82B1AD18(ctx, base);
	// 82A7028C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A70290: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A70294: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A70298: 390A5670  addi r8, r10, 0x5670
	ctx.r[8].s64 = ctx.r[10].s64 + 22128;
	// 82A7029C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A702A0: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82A702A4: 38C99490  addi r6, r9, -0x6b70
	ctx.r[6].s64 = ctx.r[9].s64 + -27504;
	// 82A702A8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A702AC: 917F00B4  stw r11, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82A702B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A702B4: 917F00B8  stw r11, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82A702B8: C1A99490  lfs f13, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A702BC: F97F00C0  std r11, 0xc0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 82A702C0: 393F00B8  addi r9, r31, 0xb8
	ctx.r[9].s64 = ctx.r[31].s64 + 184;
	// 82A702C4: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82A702C8: C8070D38  lfd f0, 0xd38(r7)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(3384 as u32) ) };
	// 82A702CC: 915F00CC  stw r10, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82A702D0: C1864138  lfs f12, 0x4138(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16696 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A702D4: 995F00D0  stb r10, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u8 ) };
	// 82A702D8: 3BBF0100  addi r29, r31, 0x100
	ctx.r[29].s64 = ctx.r[31].s64 + 256;
	// 82A702DC: 995F00D1  stb r10, 0xd1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(209 as u32), ctx.r[10].u8 ) };
	// 82A702E0: D81F00D8  stfd f0, 0xd8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.f[0].u64 ) };
	// 82A702E4: D81F00E0  stfd f0, 0xe0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.f[0].u64 ) };
	// 82A702E8: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 82A702EC: D19F00E8  stfs f12, 0xe8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82A702F0: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 82A702F4: C006FFF4  lfs f0, -0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A702F8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A702FC: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82A70300: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A70304: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82A70308: 997F0198  stb r11, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u8 ) };
	// 82A7030C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82A70310: 997F0199  stb r11, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[11].u8 ) };
	// 82A70314: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82A70318: D1BF0190  stfs f13, 0x190(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82A7031C: D1BF0194  stfs f13, 0x194(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82A70320: 917F019C  stw r11, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	pc = 0x82A70324; continue 'dispatch;
            }
            0x82A70324 => {
    //   block [0x82A70324..0x82A70344)
	// 82A70324: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A70328: 4B7CBA89  bl 0x8223bdb0
	ctx.lr = 0x82A7032C;
	sub_8223BDB0(ctx, base);
	// 82A7032C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A70330: 3BBD0040  addi r29, r29, 0x40
	ctx.r[29].s64 = ctx.r[29].s64 + 64;
	// 82A70334: 4082FFF0  bne 0x82a70324
	if !ctx.cr[0].eq {
	pc = 0x82A70324; continue 'dispatch;
	}
	// 82A70338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7033C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A70340: 4823911C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70348 size=108
    let mut pc: u32 = 0x82A70348;
    'dispatch: loop {
        match pc {
            0x82A70348 => {
    //   block [0x82A70348..0x82A70374)
	// 82A70348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7034C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70354: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A7035C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A70360: 392A5670  addi r9, r10, 0x5670
	ctx.r[9].s64 = ctx.r[10].s64 + 22128;
	// 82A70364: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A70368: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A7036C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70370: 419A0020  beq cr6, 0x82a70390
	if ctx.cr[6].eq {
	pc = 0x82A70390; continue 'dispatch;
	}
	pc = 0x82A70374; continue 'dispatch;
            }
            0x82A70374 => {
    //   block [0x82A70374..0x82A70390)
	// 82A70374: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A70378: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A7037C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A70380: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A70384: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70388: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A7038C: 4082FFE8  bne 0x82a70374
	if !ctx.cr[0].eq {
	pc = 0x82A70374; continue 'dispatch;
	}
	pc = 0x82A70390; continue 'dispatch;
            }
            0x82A70390 => {
    //   block [0x82A70390..0x82A703B4)
	// 82A70390: 387F00B8  addi r3, r31, 0xb8
	ctx.r[3].s64 = ctx.r[31].s64 + 184;
	// 82A70394: 480ADCBD  bl 0x82b1e050
	ctx.lr = 0x82A70398;
	sub_82B1E050(ctx, base);
	// 82A70398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7039C: 480AAB2D  bl 0x82b1aec8
	ctx.lr = 0x82A703A0;
	sub_82B1AEC8(ctx, base);
	// 82A703A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A703A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A703A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A703AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A703B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A703B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A703B8 size=48
    let mut pc: u32 = 0x82A703B8;
    'dispatch: loop {
        match pc {
            0x82A703B8 => {
    //   block [0x82A703B8..0x82A703E8)
	// 82A703B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A703BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A703C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A703C4: 396300B8  addi r11, r3, 0xb8
	ctx.r[11].s64 = ctx.r[3].s64 + 184;
	// 82A703C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A703CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A703D0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A703D4: 4B76B92D  bl 0x821dbd00
	ctx.lr = 0x82A703D8;
	sub_821DBD00(ctx, base);
	// 82A703D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A703DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A703E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A703E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A703E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A703E8 size=296
    let mut pc: u32 = 0x82A703E8;
    'dispatch: loop {
        match pc {
            0x82A703E8 => {
    //   block [0x82A703E8..0x82A70448)
	// 82A703E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A703EC: 4823901D  bl 0x82ca9408
	ctx.lr = 0x82A703F0;
	sub_82CA93D0(ctx, base);
	// 82A703F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A703F4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A703F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A703FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A70400: 816BF800  lwz r11, -0x800(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2048 as u32) ) } as u64;
	// 82A70404: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A70408: 556906F6  rlwinm r9, r11, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A7040C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A70410: 409A00C0  bne cr6, 0x82a704d0
	if !ctx.cr[6].eq {
	pc = 0x82A704D0; continue 'dispatch;
	}
	// 82A70414: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A70418: 839D000C  lwz r28, 0xc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A7041C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70420: 409A0090  bne cr6, 0x82a704b0
	if !ctx.cr[6].eq {
	pc = 0x82A704B0; continue 'dispatch;
	}
	// 82A70424: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A70428: 4B7AEE31  bl 0x8221f258
	ctx.lr = 0x82A7042C;
	sub_8221F258(ctx, base);
	// 82A7042C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A70430: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A70434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70438: 419A0010  beq cr6, 0x82a70448
	if ctx.cr[6].eq {
	pc = 0x82A70448; continue 'dispatch;
	}
	// 82A7043C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A70440: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A70444: 48000008  b 0x82a7044c
	pc = 0x82A7044C; continue 'dispatch;
            }
            0x82A70448 => {
    //   block [0x82A70448..0x82A7044C)
	// 82A70448: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A7044C; continue 'dispatch;
            }
            0x82A7044C => {
    //   block [0x82A7044C..0x82A704A4)
	// 82A7044C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A70450: 917E00B4  stw r11, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82A70454: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A70458: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A7045C: 4B7AEDFD  bl 0x8221f258
	ctx.lr = 0x82A70460;
	sub_8221F258(ctx, base);
	// 82A70460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70464: 419A0040  beq cr6, 0x82a704a4
	if ctx.cr[6].eq {
	pc = 0x82A704A4; continue 'dispatch;
	}
	// 82A70468: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82A7046C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A70470: 392AFF08  addi r9, r10, -0xf8
	ctx.r[9].s64 = ctx.r[10].s64 + -248;
	// 82A70474: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A70478: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A7047C: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A70480: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82A70484: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82A70488: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82A7048C: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82A70490: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82A70494: 93E30024  stw r31, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 82A70498: 93E30028  stw r31, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 82A7049C: 93E3002C  stw r31, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 82A704A0: 48000008  b 0x82a704a8
	pc = 0x82A704A8; continue 'dispatch;
            }
            0x82A704A4 => {
    //   block [0x82A704A4..0x82A704A8)
	// 82A704A4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82A704A8; continue 'dispatch;
            }
            0x82A704A8 => {
    //   block [0x82A704A8..0x82A704B0)
	// 82A704A8: 815E00B4  lwz r10, 0xb4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A704AC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A704B0; continue 'dispatch;
            }
            0x82A704B0 => {
    //   block [0x82A704B0..0x82A704D0)
	// 82A704B0: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A704B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A704B8: 80DD0014  lwz r6, 0x14(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A704BC: 809D001C  lwz r4, 0x1c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A704C0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A704C4: 4817A845  bl 0x82bead08
	ctx.lr = 0x82A704C8;
	sub_82BEAD08(ctx, base);
	// 82A704C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A704CC: 48238F8C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A704D0 => {
    //   block [0x82A704D0..0x82A704E8)
	// 82A704D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A704D4: 409A0034  bne cr6, 0x82a70508
	if !ctx.cr[6].eq {
	pc = 0x82A70508; continue 'dispatch;
	}
	// 82A704D8: 817E00B4  lwz r11, 0xb4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A704DC: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A704E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A704E4: 419A0020  beq cr6, 0x82a70504
	if ctx.cr[6].eq {
	pc = 0x82A70504; continue 'dispatch;
	}
	pc = 0x82A704E8; continue 'dispatch;
            }
            0x82A704E8 => {
    //   block [0x82A704E8..0x82A70504)
	// 82A704E8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A704EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A704F0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A704F4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A704F8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A704FC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70500: 4082FFE8  bne 0x82a704e8
	if !ctx.cr[0].eq {
	pc = 0x82A704E8; continue 'dispatch;
	}
	pc = 0x82A70504; continue 'dispatch;
            }
            0x82A70504 => {
    //   block [0x82A70504..0x82A70508)
	// 82A70504: 915E00B4  stw r10, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[10].u32 ) };
	pc = 0x82A70508; continue 'dispatch;
            }
            0x82A70508 => {
    //   block [0x82A70508..0x82A70510)
	// 82A70508: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A7050C: 48238F4C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70510 size=260
    let mut pc: u32 = 0x82A70510;
    'dispatch: loop {
        match pc {
            0x82A70510 => {
    //   block [0x82A70510..0x82A70614)
	// 82A70510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A7051C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70524: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A70528: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A7052C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A70530: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82A70534: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A70538: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7053C: 4811D025  bl 0x82b8d560
	ctx.lr = 0x82A70540;
	sub_82B8D560(ctx, base);
	// 82A70540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70544: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A70548: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7054C: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82A70550: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A70554: 38C0002A  li r6, 0x2a
	ctx.r[6].s64 = 42;
	// 82A70558: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7055C: 4811D005  bl 0x82b8d560
	ctx.lr = 0x82A70560;
	sub_82B8D560(ctx, base);
	// 82A70560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70564: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A70568: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7056C: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A70570: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A70574: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 82A70578: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7057C: 4811CFE5  bl 0x82b8d560
	ctx.lr = 0x82A70580;
	sub_82B8D560(ctx, base);
	// 82A70580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70584: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A70588: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7058C: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A70590: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A70594: 38C00026  li r6, 0x26
	ctx.r[6].s64 = 38;
	// 82A70598: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A7059C: 4811CFC5  bl 0x82b8d560
	ctx.lr = 0x82A705A0;
	sub_82B8D560(ctx, base);
	// 82A705A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A705A4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A705A8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A705AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A705B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A705B4: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 82A705B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A705BC: 4811CFA5  bl 0x82b8d560
	ctx.lr = 0x82A705C0;
	sub_82B8D560(ctx, base);
	// 82A705C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A705C4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A705C8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A705CC: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A705D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A705D4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A705D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A705DC: 4811CF85  bl 0x82b8d560
	ctx.lr = 0x82A705E0;
	sub_82B8D560(ctx, base);
	// 82A705E0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82A705E4: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A705E8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A705EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A705F0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A705F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A705F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A705FC: 4811CF65  bl 0x82b8d560
	ctx.lr = 0x82A70600;
	sub_82B8D560(ctx, base);
	// 82A70600: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A70604: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70608: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A7060C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70618 size=388
    let mut pc: u32 = 0x82A70618;
    'dispatch: loop {
        match pc {
            0x82A70618 => {
    //   block [0x82A70618..0x82A70650)
	// 82A70618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7061C: 48238DD5  bl 0x82ca93f0
	ctx.lr = 0x82A70620;
	sub_82CA93D0(ctx, base);
	// 82A70620: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70624: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A70628: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A7062C: 3AEB10F0  addi r23, r11, 0x10f0
	ctx.r[23].s64 = ctx.r[11].s64 + 4336;
	// 82A70630: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A70634: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A70638: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 82A7063C: 3AC000FF  li r22, 0xff
	ctx.r[22].s64 = 255;
	// 82A70640: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82A70644: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 82A70648: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 82A7064C: 3B6B1790  addi r27, r11, 0x1790
	ctx.r[27].s64 = ctx.r[11].s64 + 6032;
	pc = 0x82A70650; continue 'dispatch;
            }
            0x82A70650 => {
    //   block [0x82A70650..0x82A70664)
	// 82A70650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70654: 4BFFFEBD  bl 0x82a70510
	ctx.lr = 0x82A70658;
	sub_82A70510(ctx, base);
	// 82A70658: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A7065C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A70660: 40990030  ble cr6, 0x82a70690
	if !ctx.cr[6].gt {
	pc = 0x82A70690; continue 'dispatch;
	}
	pc = 0x82A70664; continue 'dispatch;
            }
            0x82A70664 => {
    //   block [0x82A70664..0x82A70690)
	// 82A70664: 393C0002  addi r9, r28, 2
	ctx.r[9].s64 = ctx.r[28].s64 + 2;
	// 82A70668: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A7066C: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A70670: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A70674: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82A70678: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A7067C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70680: 4811CEE1  bl 0x82b8d560
	ctx.lr = 0x82A70684;
	sub_82B8D560(ctx, base);
	// 82A70684: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82A70688: 7F1CE800  cmpw cr6, r28, r29
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A7068C: 4198FFD8  blt cr6, 0x82a70664
	if ctx.cr[6].lt {
	pc = 0x82A70664; continue 'dispatch;
	}
	pc = 0x82A70690; continue 'dispatch;
            }
            0x82A70690 => {
    //   block [0x82A70690..0x82A7079C)
	// 82A70690: 817A178C  lwz r11, 0x178c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(6028 as u32) ) } as u64;
	// 82A70694: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A70698: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A7069C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A706A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A706A4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A706A8: B2CB0000  sth r22, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u16 ) };
	// 82A706AC: B3CB0002  sth r30, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[30].u16 ) };
	// 82A706B0: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 82A706B4: 9BCB0008  stb r30, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 82A706B8: 9BCB0009  stb r30, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[30].u8 ) };
	// 82A706BC: 9BCB000A  stb r30, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[30].u8 ) };
	// 82A706C0: 48129061  bl 0x82b99720
	ctx.lr = 0x82A706C4;
	sub_82B99720(ctx, base);
	// 82A706C4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A706C8: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82A706CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A706D0: 39370050  addi r9, r23, 0x50
	ctx.r[9].s64 = ctx.r[23].s64 + 80;
	// 82A706D4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82A706D8: 9178711C  stw r11, 0x711c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(28956 as u32), ctx.r[11].u32 ) };
	// 82A706DC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A706E0: 915A178C  stw r10, 0x178c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(6028 as u32), ctx.r[10].u32 ) };
	// 82A706E4: 7F1F4800  cmpw cr6, r31, r9
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A706E8: 4198FF68  blt cr6, 0x82a70650
	if ctx.cr[6].lt {
	pc = 0x82A70650; continue 'dispatch;
	}
	// 82A706EC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A706F0: 3BEB1140  addi r31, r11, 0x1140
	ctx.r[31].s64 = ctx.r[11].s64 + 4416;
	// 82A706F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A706F8: 4BFFFE19  bl 0x82a70510
	ctx.lr = 0x82A706FC;
	sub_82A70510(ctx, base);
	// 82A706FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70700: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A70704: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 82A70708: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A7070C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82A70710: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A70714: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A70718: 4811CE49  bl 0x82b8d560
	ctx.lr = 0x82A7071C;
	sub_82B8D560(ctx, base);
	// 82A7071C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70720: 4811CF81  bl 0x82b8d6a0
	ctx.lr = 0x82A70724;
	sub_82B8D6A0(ctx, base);
	// 82A70724: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A70728: 3BEA1154  addi r31, r10, 0x1154
	ctx.r[31].s64 = ctx.r[10].s64 + 4436;
	// 82A7072C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70730: 4BFFFDE1  bl 0x82a70510
	ctx.lr = 0x82A70734;
	sub_82A70510(ctx, base);
	// 82A70734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70738: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82A7073C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A70740: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82A70744: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A70748: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 82A7074C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A70750: 4811CE11  bl 0x82b8d560
	ctx.lr = 0x82A70754;
	sub_82B8D560(ctx, base);
	// 82A70754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70758: 4811CF49  bl 0x82b8d6a0
	ctx.lr = 0x82A7075C;
	sub_82B8D6A0(ctx, base);
	// 82A7075C: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82A70760: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 82A70764: 38C81168  addi r6, r8, 0x1168
	ctx.r[6].s64 = ctx.r[8].s64 + 4456;
	// 82A70768: 39400029  li r10, 0x29
	ctx.r[10].s64 = 41;
	// 82A7076C: 3920001D  li r9, 0x1d
	ctx.r[9].s64 = 29;
	// 82A70770: 91681168  stw r11, 0x1168(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4456 as u32), ctx.r[11].u32 ) };
	// 82A70774: 3900002A  li r8, 0x2a
	ctx.r[8].s64 = 42;
	// 82A70778: 3960002B  li r11, 0x2b
	ctx.r[11].s64 = 43;
	// 82A7077C: 38E0001D  li r7, 0x1d
	ctx.r[7].s64 = 29;
	// 82A70780: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A70784: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A70788: 91060014  stw r8, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82A7078C: 91660018  stw r11, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A70790: 90E6001C  stw r7, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82A70794: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A70798: 48238CA8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A707A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A707A0 size=80
    let mut pc: u32 = 0x82A707A0;
    'dispatch: loop {
        match pc {
            0x82A707A0 => {
    //   block [0x82A707A0..0x82A707D8)
	// 82A707A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A707A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A707A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A707AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A707B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A707B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A707B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A707BC: 4800004D  bl 0x82a70808
	ctx.lr = 0x82A707C0;
	sub_82A70808(ctx, base);
	// 82A707C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A707C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A707C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A707CC: 419A000C  beq cr6, 0x82a707d8
	if ctx.cr[6].eq {
	pc = 0x82A707D8; continue 'dispatch;
	}
	// 82A707D0: 4B7AB569  bl 0x8221bd38
	ctx.lr = 0x82A707D4;
	sub_8221BD38(ctx, base);
	// 82A707D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A707D8; continue 'dispatch;
            }
            0x82A707D8 => {
    //   block [0x82A707D8..0x82A707F0)
	// 82A707D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A707DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A707E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A707E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A707E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A707EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A707F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A707F0 size=24
    let mut pc: u32 = 0x82A707F0;
    'dispatch: loop {
        match pc {
            0x82A707F0 => {
    //   block [0x82A707F0..0x82A70808)
	// 82A707F0: 81630274  lwz r11, 0x274(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(628 as u32) ) } as u64;
	// 82A707F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A707F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A707FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A70800: 914B00C0  stw r10, 0xc0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 82A70804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70808 size=204
    let mut pc: u32 = 0x82A70808;
    'dispatch: loop {
        match pc {
            0x82A70808 => {
    //   block [0x82A70808..0x82A70848)
	// 82A70808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7080C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A70814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7081C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70820: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A70824: 394B5D58  addi r10, r11, 0x5d58
	ctx.r[10].s64 = ctx.r[11].s64 + 23896;
	// 82A70828: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A7082C: 807F0274  lwz r3, 0x274(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82A70830: 4B7AB509  bl 0x8221bd38
	ctx.lr = 0x82A70834;
	sub_8221BD38(ctx, base);
	// 82A70834: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A70838: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A7083C: 394BF850  addi r10, r11, -0x7b0
	ctx.r[10].s64 = ctx.r[11].s64 + -1968;
	// 82A70840: 93DF0274  stw r30, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[30].u32 ) };
	// 82A70844: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82A70848; continue 'dispatch;
            }
            0x82A70848 => {
    //   block [0x82A70848..0x82A7085C)
	// 82A70848: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7084C: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A70850: 409A000C  bne cr6, 0x82a7085c
	if !ctx.cr[6].eq {
	pc = 0x82A7085C; continue 'dispatch;
	}
	// 82A70854: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A70858: 9BCB0004  stb r30, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	pc = 0x82A7085C; continue 'dispatch;
            }
            0x82A7085C => {
    //   block [0x82A7085C..0x82A7087C)
	// 82A7085C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A70860: 392A00B8  addi r9, r10, 0xb8
	ctx.r[9].s64 = ctx.r[10].s64 + 184;
	// 82A70864: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A70868: 4198FFE0  blt cr6, 0x82a70848
	if ctx.cr[6].lt {
	pc = 0x82A70848; continue 'dispatch;
	}
	// 82A7086C: 807F0270  lwz r3, 0x270(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 82A70870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70874: 419A0040  beq cr6, 0x82a708b4
	if ctx.cr[6].eq {
	pc = 0x82A708B4; continue 'dispatch;
	}
	// 82A70878: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A7087C; continue 'dispatch;
            }
            0x82A7087C => {
    //   block [0x82A7087C..0x82A708B0)
	// 82A7087C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A70880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70884: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A70888: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A7088C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70890: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70894: 4082FFE8  bne 0x82a7087c
	if !ctx.cr[0].eq {
	pc = 0x82A7087C; continue 'dispatch;
	}
	// 82A70898: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A7089C: 409A0014  bne cr6, 0x82a708b0
	if !ctx.cr[6].eq {
	pc = 0x82A708B0; continue 'dispatch;
	}
	// 82A708A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A708A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A708A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A708AC: 4E800421  bctrl
	ctx.lr = 0x82A708B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A708B0 => {
    //   block [0x82A708B0..0x82A708B4)
	// 82A708B0: 93DF0270  stw r30, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[30].u32 ) };
	pc = 0x82A708B4; continue 'dispatch;
            }
            0x82A708B4 => {
    //   block [0x82A708B4..0x82A708D4)
	// 82A708B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A708B8: 48000711  bl 0x82a70fc8
	ctx.lr = 0x82A708BC;
	sub_82A70FC8(ctx, base);
	// 82A708BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A708C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A708C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A708C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A708CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A708D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A708D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A708D8 size=8
    let mut pc: u32 = 0x82A708D8;
    'dispatch: loop {
        match pc {
            0x82A708D8 => {
    //   block [0x82A708D8..0x82A708E0)
	// 82A708D8: C0230124  lfs f1, 0x124(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A708DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A708E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A708E0 size=856
    let mut pc: u32 = 0x82A708E0;
    'dispatch: loop {
        match pc {
            0x82A708E0 => {
    //   block [0x82A708E0..0x82A7092C)
	// 82A708E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A708E4: 48238B25  bl 0x82ca9408
	ctx.lr = 0x82A708E8;
	sub_82CA93D0(ctx, base);
	// 82A708E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A708EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A708F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A708F4: 4800076D  bl 0x82a71060
	ctx.lr = 0x82A708F8;
	sub_82A71060(ctx, base);
	// 82A708F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A708FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A70900: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70904: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70908: 4E800421  bctrl
	ctx.lr = 0x82A7090C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7090C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82A70910: 409A0320  bne cr6, 0x82a70c30
	if !ctx.cr[6].eq {
	pc = 0x82A70C30; continue 'dispatch;
	}
	// 82A70914: C01D0048  lfs f0, 0x48(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A70918: C1BF0124  lfs f13, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A7091C: D01F0258  stfs f0, 0x258(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), tmp.u32 ) };
	// 82A70920: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A70924: 41980008  blt cr6, 0x82a7092c
	if ctx.cr[6].lt {
	pc = 0x82A7092C; continue 'dispatch;
	}
	// 82A70928: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
            }
            0x82A7092C => {
    //   block [0x82A7092C..0x82A70948)
	// 82A7092C: C01D004C  lfs f0, 0x4c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A70930: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A70934: D01F025C  stfs f0, 0x25c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), tmp.u32 ) };
	// 82A70938: 807F0270  lwz r3, 0x270(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 82A7093C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70940: 419A0040  beq cr6, 0x82a70980
	if ctx.cr[6].eq {
	pc = 0x82A70980; continue 'dispatch;
	}
	// 82A70944: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A70948; continue 'dispatch;
            }
            0x82A70948 => {
    //   block [0x82A70948..0x82A7097C)
	// 82A70948: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A7094C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70950: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A70954: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A70958: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A7095C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70960: 4082FFE8  bne 0x82a70948
	if !ctx.cr[0].eq {
	pc = 0x82A70948; continue 'dispatch;
	}
	// 82A70964: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70968: 409A0014  bne cr6, 0x82a7097c
	if !ctx.cr[6].eq {
	pc = 0x82A7097C; continue 'dispatch;
	}
	// 82A7096C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70970: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70974: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70978: 4E800421  bctrl
	ctx.lr = 0x82A7097C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A7097C => {
    //   block [0x82A7097C..0x82A70980)
	// 82A7097C: 939F0270  stw r28, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[28].u32 ) };
	pc = 0x82A70980; continue 'dispatch;
            }
            0x82A70980 => {
    //   block [0x82A70980..0x82A709BC)
	// 82A70980: 939F0270  stw r28, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[28].u32 ) };
	// 82A70984: 389D0074  addi r4, r29, 0x74
	ctx.r[4].s64 = ctx.r[29].s64 + 116;
	// 82A70988: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A7098C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70990: 409900E4  ble cr6, 0x82a70a74
	if !ctx.cr[6].gt {
	pc = 0x82A70A74; continue 'dispatch;
	}
	// 82A70994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A70998: 4BFE04F9  bl 0x82a50e90
	ctx.lr = 0x82A7099C;
	sub_82A50E90(ctx, base);
	// 82A7099C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A709A0: 807F0270  lwz r3, 0x270(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 82A709A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A709A8: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A709AC: 419A0078  beq cr6, 0x82a70a24
	if ctx.cr[6].eq {
	pc = 0x82A70A24; continue 'dispatch;
	}
	// 82A709B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A709B4: 419A0040  beq cr6, 0x82a709f4
	if ctx.cr[6].eq {
	pc = 0x82A709F4; continue 'dispatch;
	}
	// 82A709B8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A709BC; continue 'dispatch;
            }
            0x82A709BC => {
    //   block [0x82A709BC..0x82A709F0)
	// 82A709BC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A709C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A709C4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A709C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A709CC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A709D0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A709D4: 4082FFE8  bne 0x82a709bc
	if !ctx.cr[0].eq {
	pc = 0x82A709BC; continue 'dispatch;
	}
	// 82A709D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A709DC: 409A0014  bne cr6, 0x82a709f0
	if !ctx.cr[6].eq {
	pc = 0x82A709F0; continue 'dispatch;
	}
	// 82A709E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A709E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A709E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A709EC: 4E800421  bctrl
	ctx.lr = 0x82A709F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A709F0 => {
    //   block [0x82A709F0..0x82A709F4)
	// 82A709F0: 939F0270  stw r28, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[28].u32 ) };
	pc = 0x82A709F4; continue 'dispatch;
            }
            0x82A709F4 => {
    //   block [0x82A709F4..0x82A70A08)
	// 82A709F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A709F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A709FC: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 82A70A00: 419A0024  beq cr6, 0x82a70a24
	if ctx.cr[6].eq {
	pc = 0x82A70A24; continue 'dispatch;
	}
	// 82A70A04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A70A08; continue 'dispatch;
            }
            0x82A70A08 => {
    //   block [0x82A70A08..0x82A70A24)
	// 82A70A08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A70A0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70A10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A70A14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A70A18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70A1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70A20: 4082FFE8  bne 0x82a70a08
	if !ctx.cr[0].eq {
	pc = 0x82A70A08; continue 'dispatch;
	}
	pc = 0x82A70A24; continue 'dispatch;
            }
            0x82A70A24 => {
    //   block [0x82A70A24..0x82A70A38)
	// 82A70A24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A70A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70A2C: 419A0048  beq cr6, 0x82a70a74
	if ctx.cr[6].eq {
	pc = 0x82A70A74; continue 'dispatch;
	}
	// 82A70A30: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A70A34: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A70A38; continue 'dispatch;
            }
            0x82A70A38 => {
    //   block [0x82A70A38..0x82A70A70)
	// 82A70A38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A70A3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70A40: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A70A44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A70A48: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70A4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70A50: 4082FFE8  bne 0x82a70a38
	if !ctx.cr[0].eq {
	pc = 0x82A70A38; continue 'dispatch;
	}
	// 82A70A54: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A70A58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70A5C: 409A0014  bne cr6, 0x82a70a70
	if !ctx.cr[6].eq {
	pc = 0x82A70A70; continue 'dispatch;
	}
	// 82A70A60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70A64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70A68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70A6C: 4E800421  bctrl
	ctx.lr = 0x82A70A70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A70A70 => {
    //   block [0x82A70A70..0x82A70A74)
	// 82A70A70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A70A74; continue 'dispatch;
            }
            0x82A70A74 => {
    //   block [0x82A70A74..0x82A70A84)
	// 82A70A74: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82A70A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70A7C: 419A0040  beq cr6, 0x82a70abc
	if ctx.cr[6].eq {
	pc = 0x82A70ABC; continue 'dispatch;
	}
	// 82A70A80: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A70A84; continue 'dispatch;
            }
            0x82A70A84 => {
    //   block [0x82A70A84..0x82A70AB8)
	// 82A70A84: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A70A88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70A8C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A70A90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A70A94: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70A98: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70A9C: 4082FFE8  bne 0x82a70a84
	if !ctx.cr[0].eq {
	pc = 0x82A70A84; continue 'dispatch;
	}
	// 82A70AA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70AA4: 409A0014  bne cr6, 0x82a70ab8
	if !ctx.cr[6].eq {
	pc = 0x82A70AB8; continue 'dispatch;
	}
	// 82A70AA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70AAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70AB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70AB4: 4E800421  bctrl
	ctx.lr = 0x82A70AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A70AB8 => {
    //   block [0x82A70AB8..0x82A70ABC)
	// 82A70AB8: 939F00D8  stw r28, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	pc = 0x82A70ABC; continue 'dispatch;
            }
            0x82A70ABC => {
    //   block [0x82A70ABC..0x82A70AFC)
	// 82A70ABC: 939F00D8  stw r28, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 82A70AC0: 389D0078  addi r4, r29, 0x78
	ctx.r[4].s64 = ctx.r[29].s64 + 120;
	// 82A70AC4: 817D0078  lwz r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A70AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70ACC: 409900E8  ble cr6, 0x82a70bb4
	if !ctx.cr[6].gt {
	pc = 0x82A70BB4; continue 'dispatch;
	}
	// 82A70AD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A70AD4: 4BFE03BD  bl 0x82a50e90
	ctx.lr = 0x82A70AD8;
	sub_82A50E90(ctx, base);
	// 82A70AD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A70ADC: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82A70AE0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70AE4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A70AE8: 419A007C  beq cr6, 0x82a70b64
	if ctx.cr[6].eq {
	pc = 0x82A70B64; continue 'dispatch;
	}
	// 82A70AEC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A70AF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70AF4: 419A0040  beq cr6, 0x82a70b34
	if ctx.cr[6].eq {
	pc = 0x82A70B34; continue 'dispatch;
	}
	// 82A70AF8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A70AFC; continue 'dispatch;
            }
            0x82A70AFC => {
    //   block [0x82A70AFC..0x82A70B30)
	// 82A70AFC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A70B00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70B04: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A70B08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A70B0C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70B10: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70B14: 4082FFE8  bne 0x82a70afc
	if !ctx.cr[0].eq {
	pc = 0x82A70AFC; continue 'dispatch;
	}
	// 82A70B18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70B1C: 409A0014  bne cr6, 0x82a70b30
	if !ctx.cr[6].eq {
	pc = 0x82A70B30; continue 'dispatch;
	}
	// 82A70B20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70B24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70B28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70B2C: 4E800421  bctrl
	ctx.lr = 0x82A70B30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A70B30 => {
    //   block [0x82A70B30..0x82A70B34)
	// 82A70B30: 939F00D8  stw r28, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	pc = 0x82A70B34; continue 'dispatch;
            }
            0x82A70B34 => {
    //   block [0x82A70B34..0x82A70B48)
	// 82A70B34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70B3C: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82A70B40: 419A0024  beq cr6, 0x82a70b64
	if ctx.cr[6].eq {
	pc = 0x82A70B64; continue 'dispatch;
	}
	// 82A70B44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A70B48; continue 'dispatch;
            }
            0x82A70B48 => {
    //   block [0x82A70B48..0x82A70B64)
	// 82A70B48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A70B4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70B50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A70B54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A70B58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70B5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70B60: 4082FFE8  bne 0x82a70b48
	if !ctx.cr[0].eq {
	pc = 0x82A70B48; continue 'dispatch;
	}
	pc = 0x82A70B64; continue 'dispatch;
            }
            0x82A70B64 => {
    //   block [0x82A70B64..0x82A70B78)
	// 82A70B64: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A70B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70B6C: 419A0048  beq cr6, 0x82a70bb4
	if ctx.cr[6].eq {
	pc = 0x82A70BB4; continue 'dispatch;
	}
	// 82A70B70: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A70B74: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A70B78; continue 'dispatch;
            }
            0x82A70B78 => {
    //   block [0x82A70B78..0x82A70BB0)
	// 82A70B78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A70B7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70B80: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A70B84: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A70B88: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70B8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70B90: 4082FFE8  bne 0x82a70b78
	if !ctx.cr[0].eq {
	pc = 0x82A70B78; continue 'dispatch;
	}
	// 82A70B94: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A70B98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70B9C: 409A0014  bne cr6, 0x82a70bb0
	if !ctx.cr[6].eq {
	pc = 0x82A70BB0; continue 'dispatch;
	}
	// 82A70BA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70BA4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70BA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70BAC: 4E800421  bctrl
	ctx.lr = 0x82A70BB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A70BB0 => {
    //   block [0x82A70BB0..0x82A70BB4)
	// 82A70BB0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82A70BB4; continue 'dispatch;
            }
            0x82A70BB4 => {
    //   block [0x82A70BB4..0x82A70C30)
	// 82A70BB4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82A70BB8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A70BBC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A70BC0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A70BC4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	pc = 0x82A70C30; continue 'dispatch;
            }
            0x82A70C30 => {
    //   block [0x82A70C30..0x82A70C38)
	// 82A70C30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A70C34: 48238824  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70C40 size=92
    let mut pc: u32 = 0x82A70C40;
    'dispatch: loop {
        match pc {
            0x82A70C40 => {
    //   block [0x82A70C40..0x82A70C74)
	// 82A70C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70C48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70C4C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82A70C50: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A70C54: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A70C58: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A70C5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A70C60: 4B7A9F31  bl 0x8221ab90
	ctx.lr = 0x82A70C64;
	sub_8221AB90(ctx, base);
	// 82A70C64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A70C68: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A70C6C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82A70C70: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A70C74; continue 'dispatch;
            }
            0x82A70C74 => {
    //   block [0x82A70C74..0x82A70C9C)
	// 82A70C74: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A70C78: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A70C7C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82A70C80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A70C84: 4200FFF0  bdnz 0x82a70c74
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A70C74; continue 'dispatch;
	}
	// 82A70C88: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82A70C8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A70C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70CA0 size=128
    let mut pc: u32 = 0x82A70CA0;
    'dispatch: loop {
        match pc {
            0x82A70CA0 => {
    //   block [0x82A70CA0..0x82A70CC4)
	// 82A70CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70CA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70CAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70CB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70CB4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70CBC: 419A0048  beq cr6, 0x82a70d04
	if ctx.cr[6].eq {
	pc = 0x82A70D04; continue 'dispatch;
	}
	// 82A70CC0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A70CC4; continue 'dispatch;
            }
            0x82A70CC4 => {
    //   block [0x82A70CC4..0x82A70CF8)
	// 82A70CC4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A70CC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70CCC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A70CD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A70CD4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A70CD8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A70CDC: 4082FFE8  bne 0x82a70cc4
	if !ctx.cr[0].eq {
	pc = 0x82A70CC4; continue 'dispatch;
	}
	// 82A70CE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70CE4: 409A0014  bne cr6, 0x82a70cf8
	if !ctx.cr[6].eq {
	pc = 0x82A70CF8; continue 'dispatch;
	}
	// 82A70CE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70CEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70CF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A70CF4: 4E800421  bctrl
	ctx.lr = 0x82A70CF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A70CF8 => {
    //   block [0x82A70CF8..0x82A70D04)
	// 82A70CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A70CFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A70D00: 48000008  b 0x82a70d08
	pc = 0x82A70D08; continue 'dispatch;
            }
            0x82A70D04 => {
    //   block [0x82A70D04..0x82A70D08)
	// 82A70D04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A70D08; continue 'dispatch;
            }
            0x82A70D08 => {
    //   block [0x82A70D08..0x82A70D20)
	// 82A70D08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A70D0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A70D10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70D14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70D18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70D20 size=196
    let mut pc: u32 = 0x82A70D20;
    'dispatch: loop {
        match pc {
            0x82A70D20 => {
    //   block [0x82A70D20..0x82A70D4C)
	// 82A70D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70D2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70D34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A70D38: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A70D3C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A70D40: 40820090  bne 0x82a70dd0
	if !ctx.cr[0].eq {
	pc = 0x82A70DD0; continue 'dispatch;
	}
	// 82A70D44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A70D48: 395F0024  addi r10, r31, 0x24
	ctx.r[10].s64 = ctx.r[31].s64 + 36;
	pc = 0x82A70D4C; continue 'dispatch;
            }
            0x82A70D4C => {
    //   block [0x82A70D4C..0x82A70D6C)
	// 82A70D4C: 7D2A58AE  lbzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A70D50: 5528077C  rlwinm r8, r9, 0, 0x1d, 0x1e
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82A70D54: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A70D58: 409A0068  bne cr6, 0x82a70dc0
	if !ctx.cr[6].eq {
	pc = 0x82A70DC0; continue 'dispatch;
	}
	// 82A70D5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A70D60: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A70D64: 4198FFE8  blt cr6, 0x82a70d4c
	if ctx.cr[6].lt {
	pc = 0x82A70D4C; continue 'dispatch;
	}
	// 82A70D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A70D6C; continue 'dispatch;
            }
            0x82A70D6C => {
    //   block [0x82A70D6C..0x82A70DA8)
	// 82A70D6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A70D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70D74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70D78: 419A0050  beq cr6, 0x82a70dc8
	if ctx.cr[6].eq {
	pc = 0x82A70DC8; continue 'dispatch;
	}
	// 82A70D7C: 4801903D  bl 0x82a89db8
	ctx.lr = 0x82A70D80;
	sub_82A89DB8(ctx, base);
	// 82A70D80: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A70D84: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82A70D88: 394A6EBC  addi r10, r10, 0x6ebc
	ctx.r[10].s64 = ctx.r[10].s64 + 28348;
	// 82A70D8C: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82A70D90: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70D94: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A70D98: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A70D9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A70DA0: 419A0008  beq cr6, 0x82a70da8
	if ctx.cr[6].eq {
	pc = 0x82A70DA8; continue 'dispatch;
	}
	// 82A70DA4: 9169002C  stw r11, 0x2c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x82A70DA8; continue 'dispatch;
            }
            0x82A70DA8 => {
    //   block [0x82A70DA8..0x82A70DC0)
	// 82A70DA8: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A70DAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A70DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70DB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70DBC: 4E800020  blr
	return;
            }
            0x82A70DC0 => {
    //   block [0x82A70DC0..0x82A70DC8)
	// 82A70DC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A70DC4: 4BFFFFA8  b 0x82a70d6c
	pc = 0x82A70D6C; continue 'dispatch;
            }
            0x82A70DC8 => {
    //   block [0x82A70DC8..0x82A70DD0)
	// 82A70DC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A70DCC: 4800001D  bl 0x82a70de8
	ctx.lr = 0x82A70DD0;
	sub_82A70DE8(ctx, base);
	pc = 0x82A70DD0; continue 'dispatch;
            }
            0x82A70DD0 => {
    //   block [0x82A70DD0..0x82A70DE4)
	// 82A70DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A70DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70DE8 size=104
    let mut pc: u32 = 0x82A70DE8;
    'dispatch: loop {
        match pc {
            0x82A70DE8 => {
    //   block [0x82A70DE8..0x82A70E10)
	// 82A70DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70DEC: 48238621  bl 0x82ca940c
	ctx.lr = 0x82A70DF0;
	sub_82CA93D0(ctx, base);
	// 82A70DF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70DF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A70DF8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A70DFC: 394B7B64  addi r10, r11, 0x7b64
	ctx.r[10].s64 = ctx.r[11].s64 + 31588;
	// 82A70E00: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A70E04: 48018FB5  bl 0x82a89db8
	ctx.lr = 0x82A70E08;
	sub_82A89DB8(ctx, base);
	// 82A70E08: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 82A70E0C: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	pc = 0x82A70E10; continue 'dispatch;
            }
            0x82A70E10 => {
    //   block [0x82A70E10..0x82A70E24)
	// 82A70E10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A70E14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70E18: 419A000C  beq cr6, 0x82a70e24
	if ctx.cr[6].eq {
	pc = 0x82A70E24; continue 'dispatch;
	}
	// 82A70E1C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A70E20: 48019B69  bl 0x82a8a988
	ctx.lr = 0x82A70E24;
	sub_82A8A988(ctx, base);
	pc = 0x82A70E24; continue 'dispatch;
            }
            0x82A70E24 => {
    //   block [0x82A70E24..0x82A70E50)
	// 82A70E24: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A70E28: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A70E2C: 4082FFE4  bne 0x82a70e10
	if !ctx.cr[0].eq {
	pc = 0x82A70E10; continue 'dispatch;
	}
	// 82A70E30: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82A70E34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A70E38: 394BE738  addi r10, r11, -0x18c8
	ctx.r[10].s64 = ctx.r[11].s64 + -6344;
	// 82A70E3C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A70E40: 4B7AAEF9  bl 0x8221bd38
	ctx.lr = 0x82A70E44;
	sub_8221BD38(ctx, base);
	// 82A70E44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A70E48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A70E4C: 48238610  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70E50 size=148
    let mut pc: u32 = 0x82A70E50;
    'dispatch: loop {
        match pc {
            0x82A70E50 => {
    //   block [0x82A70E50..0x82A70ED0)
	// 82A70E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70E58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70E5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70E60: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A70E64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70E68: 480317F1  bl 0x82aa2658
	ctx.lr = 0x82A70E6C;
	sub_82AA2658(ctx, base);
	// 82A70E6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A70E70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A70E74: 392A5F40  addi r9, r10, 0x5f40
	ctx.r[9].s64 = ctx.r[10].s64 + 24384;
	// 82A70E78: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A70E7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A70E80: 395F0208  addi r10, r31, 0x208
	ctx.r[10].s64 = ctx.r[31].s64 + 520;
	// 82A70E84: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82A70E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70E8C: 997F020C  stb r11, 0x20c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u8 ) };
	// 82A70E90: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 82A70E94: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82A70E98: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82A70E9C: 911F0220  stw r8, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[8].u32 ) };
	// 82A70EA0: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 82A70EA4: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82A70EA8: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82A70EAC: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 82A70EB0: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 82A70EB4: 917F0200  stw r11, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82A70EB8: 917F0204  stw r11, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[11].u32 ) };
	// 82A70EBC: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82A70EC0: 815F01B0  lwz r10, 0x1b0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A70EC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A70EC8: 419A0008  beq cr6, 0x82a70ed0
	if ctx.cr[6].eq {
	pc = 0x82A70ED0; continue 'dispatch;
	}
	// 82A70ECC: 916A00C0  stw r11, 0xc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x82A70ED0; continue 'dispatch;
            }
            0x82A70ED0 => {
    //   block [0x82A70ED0..0x82A70EE4)
	// 82A70ED0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A70ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70EDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70EE8 size=80
    let mut pc: u32 = 0x82A70EE8;
    'dispatch: loop {
        match pc {
            0x82A70EE8 => {
    //   block [0x82A70EE8..0x82A70F20)
	// 82A70EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A70EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70EFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70F00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A70F04: 480000C5  bl 0x82a70fc8
	ctx.lr = 0x82A70F08;
	sub_82A70FC8(ctx, base);
	// 82A70F08: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A70F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A70F14: 419A000C  beq cr6, 0x82a70f20
	if ctx.cr[6].eq {
	pc = 0x82A70F20; continue 'dispatch;
	}
	// 82A70F18: 4B7AAE21  bl 0x8221bd38
	ctx.lr = 0x82A70F1C;
	sub_8221BD38(ctx, base);
	// 82A70F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A70F20; continue 'dispatch;
            }
            0x82A70F20 => {
    //   block [0x82A70F20..0x82A70F38)
	// 82A70F20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A70F24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70F28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70F2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A70F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70F38 size=144
    let mut pc: u32 = 0x82A70F38;
    'dispatch: loop {
        match pc {
            0x82A70F38 => {
    //   block [0x82A70F38..0x82A70FB4)
	// 82A70F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A70F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A70F44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70F4C: 4803170D  bl 0x82aa2658
	ctx.lr = 0x82A70F50;
	sub_82AA2658(ctx, base);
	// 82A70F50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A70F54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A70F58: 392A5F40  addi r9, r10, 0x5f40
	ctx.r[9].s64 = ctx.r[10].s64 + 24384;
	// 82A70F5C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A70F60: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A70F64: 395F0208  addi r10, r31, 0x208
	ctx.r[10].s64 = ctx.r[31].s64 + 520;
	// 82A70F68: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82A70F6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A70F70: 997F020C  stb r11, 0x20c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u8 ) };
	// 82A70F74: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 82A70F78: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82A70F7C: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82A70F80: 911F0220  stw r8, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[8].u32 ) };
	// 82A70F84: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 82A70F88: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82A70F8C: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82A70F90: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 82A70F94: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 82A70F98: 917F0200  stw r11, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82A70F9C: 917F0204  stw r11, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[11].u32 ) };
	// 82A70FA0: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82A70FA4: 815F01B0  lwz r10, 0x1b0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A70FA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A70FAC: 419A0008  beq cr6, 0x82a70fb4
	if ctx.cr[6].eq {
	pc = 0x82A70FB4; continue 'dispatch;
	}
	// 82A70FB0: 916A00C0  stw r11, 0xc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x82A70FB4; continue 'dispatch;
            }
            0x82A70FB4 => {
    //   block [0x82A70FB4..0x82A70FC8)
	// 82A70FB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A70FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A70FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A70FC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A70FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A70FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A70FC8 size=112
    let mut pc: u32 = 0x82A70FC8;
    'dispatch: loop {
        match pc {
            0x82A70FC8 => {
    //   block [0x82A70FC8..0x82A71004)
	// 82A70FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A70FCC: 48238441  bl 0x82ca940c
	ctx.lr = 0x82A70FD0;
	sub_82CA93D0(ctx, base);
	// 82A70FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A70FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A70FD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A70FDC: 394B5F40  addi r10, r11, 0x5f40
	ctx.r[10].s64 = ctx.r[11].s64 + 24384;
	// 82A70FE0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A70FE4: 48000465  bl 0x82a71448
	ctx.lr = 0x82A70FE8;
	sub_82A71448(ctx, base);
	// 82A70FE8: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82A70FEC: 4B7C0CCD  bl 0x82231cb8
	ctx.lr = 0x82A70FF0;
	sub_82231CB8(ctx, base);
	// 82A70FF0: 807F0234  lwz r3, 0x234(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82A70FF4: 3BDF0230  addi r30, r31, 0x230
	ctx.r[30].s64 = ctx.r[31].s64 + 560;
	// 82A70FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A70FFC: 419A0008  beq cr6, 0x82a71004
	if ctx.cr[6].eq {
	pc = 0x82A71004; continue 'dispatch;
	}
	// 82A71000: 4B7AAD39  bl 0x8221bd38
	ctx.lr = 0x82A71004;
	sub_8221BD38(ctx, base);
	pc = 0x82A71004; continue 'dispatch;
            }
            0x82A71004 => {
    //   block [0x82A71004..0x82A71038)
	// 82A71004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A71008: 3BBF0208  addi r29, r31, 0x208
	ctx.r[29].s64 = ctx.r[31].s64 + 520;
	// 82A7100C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A71010: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A71014: 387D001C  addi r3, r29, 0x1c
	ctx.r[3].s64 = ctx.r[29].s64 + 28;
	// 82A71018: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A7101C: 4B7C0C9D  bl 0x82231cb8
	ctx.lr = 0x82A71020;
	sub_82231CB8(ctx, base);
	// 82A71020: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 82A71024: 480005C5  bl 0x82a715e8
	ctx.lr = 0x82A71028;
	sub_82A715E8(ctx, base);
	// 82A71028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7102C: 480317E5  bl 0x82aa2810
	ctx.lr = 0x82A71030;
	sub_82AA2810(ctx, base);
	// 82A71030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A71034: 48238428  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A71038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A71038 size=36
    let mut pc: u32 = 0x82A71038;
    'dispatch: loop {
        match pc {
            0x82A71038 => {
    //   block [0x82A71038..0x82A7105C)
	// 82A71038: 814301B0  lwz r10, 0x1b0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A7103C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A71040: 91630200  stw r11, 0x200(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82A71044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A71048: 91630204  stw r11, 0x204(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(516 as u32), ctx.r[11].u32 ) };
	// 82A7104C: 916301B8  stw r11, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82A71050: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A71054: 916A00C0  stw r11, 0xc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82A71058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A71060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A71060 size=672
    let mut pc: u32 = 0x82A71060;
    'dispatch: loop {
        match pc {
            0x82A71060 => {
    //   block [0x82A71060..0x82A7109C)
	// 82A71060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A71064: 482383A1  bl 0x82ca9404
	ctx.lr = 0x82A71068;
	sub_82CA93D0(ctx, base);
	// 82A71068: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A7106C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A71070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A71074: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A71078: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A7107C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A71080: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82A71084: 937F0200  stw r27, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[27].u32 ) };
	// 82A71088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A7108C: 937F0204  stw r27, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[27].u32 ) };
	// 82A71090: 937F01B8  stw r27, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[27].u32 ) };
	// 82A71094: 419A0008  beq cr6, 0x82a7109c
	if ctx.cr[6].eq {
	pc = 0x82A7109C; continue 'dispatch;
	}
	// 82A71098: 936B00C0  stw r27, 0xc0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	pc = 0x82A7109C; continue 'dispatch;
            }
            0x82A7109C => {
    //   block [0x82A7109C..0x82A710F4)
	// 82A7109C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A710A0: 48031FE1  bl 0x82aa3080
	ctx.lr = 0x82A710A4;
	sub_82AA3080(ctx, base);
	// 82A710A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A710A8: 48032069  bl 0x82aa3110
	ctx.lr = 0x82A710AC;
	sub_82AA3110(ctx, base);
	// 82A710AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A710B0: 480320C1  bl 0x82aa3170
	ctx.lr = 0x82A710B4;
	sub_82AA3170(ctx, base);
	// 82A710B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A710B8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A710BC: 4B7B59B5  bl 0x82226a70
	ctx.lr = 0x82A710C0;
	sub_82226A70(ctx, base);
	// 82A710C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A710C4: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82A710C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A710CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A710D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A710D4: 4E800421  bctrl
	ctx.lr = 0x82A710D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A710D8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A710DC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82A710E0: 419A0014  beq cr6, 0x82a710f4
	if ctx.cr[6].eq {
	pc = 0x82A710F4; continue 'dispatch;
	}
	// 82A710E4: 2F030013  cmpwi cr6, r3, 0x13
	ctx.cr[6].compare_i32(ctx.r[3].s32, 19, &mut ctx.xer);
	// 82A710E8: 419A01AC  beq cr6, 0x82a71294
	if ctx.cr[6].eq {
	pc = 0x82A71294; continue 'dispatch;
	}
	// 82A710EC: 2F030028  cmpwi cr6, r3, 0x28
	ctx.cr[6].compare_i32(ctx.r[3].s32, 40, &mut ctx.xer);
	// 82A710F0: 409A014C  bne cr6, 0x82a7123c
	if !ctx.cr[6].eq {
	pc = 0x82A7123C; continue 'dispatch;
	}
            }
            0x82A710F4 => {
    //   block [0x82A710F4..0x82A71120)
	// 82A710F4: 389D0070  addi r4, r29, 0x70
	ctx.r[4].s64 = ctx.r[29].s64 + 112;
	// 82A710F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A710FC: 4BFDFD95  bl 0x82a50e90
	ctx.lr = 0x82A71100;
	sub_82A50E90(ctx, base);
	// 82A71100: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A71104: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A71108: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7110C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A71110: 419A0078  beq cr6, 0x82a71188
	if ctx.cr[6].eq {
	pc = 0x82A71188; continue 'dispatch;
	}
	// 82A71114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A71118: 419A0040  beq cr6, 0x82a71158
	if ctx.cr[6].eq {
	pc = 0x82A71158; continue 'dispatch;
	}
	// 82A7111C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x82A71120; continue 'dispatch;
            }
            0x82A71120 => {
    //   block [0x82A71120..0x82A71154)
	// 82A71120: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A71124: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A71128: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A7112C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A71130: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A71134: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A71138: 4082FFE8  bne 0x82a71120
	if !ctx.cr[0].eq {
	pc = 0x82A71120; continue 'dispatch;
	}
	// 82A7113C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A71140: 409A0014  bne cr6, 0x82a71154
	if !ctx.cr[6].eq {
	pc = 0x82A71154; continue 'dispatch;
	}
	// 82A71144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A71148: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A7114C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A71150: 4E800421  bctrl
	ctx.lr = 0x82A71154;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A71154 => {
    //   block [0x82A71154..0x82A71158)
	// 82A71154: 937F00D4  stw r27, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[27].u32 ) };
	pc = 0x82A71158; continue 'dispatch;
            }
            0x82A71158 => {
    //   block [0x82A71158..0x82A7116C)
	// 82A71158: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7115C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A71160: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82A71164: 419A0024  beq cr6, 0x82a71188
	if ctx.cr[6].eq {
	pc = 0x82A71188; continue 'dispatch;
	}
	// 82A71168: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A7116C; continue 'dispatch;
            }
            0x82A7116C => {
    //   block [0x82A7116C..0x82A71188)
	// 82A7116C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A71170: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A71174: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A71178: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A7117C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A71180: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A71184: 4082FFE8  bne 0x82a7116c
	if !ctx.cr[0].eq {
	pc = 0x82A7116C; continue 'dispatch;
	}
	pc = 0x82A71188; continue 'dispatch;
            }
            0x82A71188 => {
    //   block [0x82A71188..0x82A7119C)
	// 82A71188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A7118C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A71190: 419A0048  beq cr6, 0x82a711d8
	if ctx.cr[6].eq {
	pc = 0x82A711D8; continue 'dispatch;
	}
	// 82A71194: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A71198: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x82A7119C; continue 'dispatch;
            }
            0x82A7119C => {
    //   block [0x82A7119C..0x82A711D4)
	// 82A7119C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A711A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A711A4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A711A8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A711AC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A711B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A711B4: 4082FFE8  bne 0x82a7119c
	if !ctx.cr[0].eq {
	pc = 0x82A7119C; continue 'dispatch;
	}
	// 82A711B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A711BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A711C0: 409A0014  bne cr6, 0x82a711d4
	if !ctx.cr[6].eq {
	pc = 0x82A711D4; continue 'dispatch;
	}
	// 82A711C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A711C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A711CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A711D0: 4E800421  bctrl
	ctx.lr = 0x82A711D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A711D4 => {
    //   block [0x82A711D4..0x82A711D8)
	// 82A711D4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	pc = 0x82A711D8; continue 'dispatch;
            }
            0x82A711D8 => {
    //   block [0x82A711D8..0x82A71218)
	// 82A711D8: E97D0080  ld r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) };
	// 82A711DC: 391F0208  addi r8, r31, 0x208
	ctx.r[8].s64 = ctx.r[31].s64 + 520;
	// 82A711E0: F97F0228  std r11, 0x228(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u64 ) };
	// 82A711E4: 83DD0034  lwz r30, 0x34(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A711E8: 815D0038  lwz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A711EC: 915F0130  stw r10, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[10].u32 ) };
	// 82A711F0: 80FD0064  lwz r7, 0x64(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A711F4: 893F020C  lbz r9, 0x20c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82A711F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A711FC: 90FF0220  stw r7, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[7].u32 ) };
	// 82A71200: 419A003C  beq cr6, 0x82a7123c
	if ctx.cr[6].eq {
	pc = 0x82A7123C; continue 'dispatch;
	}
	// 82A71204: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A71208: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A7120C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A71210: 419A002C  beq cr6, 0x82a7123c
	if ctx.cr[6].eq {
	pc = 0x82A7123C; continue 'dispatch;
	}
	// 82A71214: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	pc = 0x82A71218; continue 'dispatch;
            }
            0x82A71218 => {
    //   block [0x82A71218..0x82A7123C)
	// 82A71218: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A7121C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A71220: 80C80018  lwz r6, 0x18(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A71224: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A71228: 392900A0  addi r9, r9, 0xa0
	ctx.r[9].s64 = ctx.r[9].s64 + 160;
	// 82A7122C: 38EB0080  addi r7, r11, 0x80
	ctx.r[7].s64 = ctx.r[11].s64 + 128;
	// 82A71230: 90CB0094  stw r6, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[6].u32 ) };
	// 82A71234: 9B8B0098  stb r28, 0x98(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[28].u8 ) };
	// 82A71238: 4082FFE0  bne 0x82a71218
	if !ctx.cr[0].eq {
	pc = 0x82A71218; continue 'dispatch;
	}
	pc = 0x82A7123C; continue 'dispatch;
            }
            0x82A7123C => {
    //   block [0x82A7123C..0x82A71274)
	// 82A7123C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A71240: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A71244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A71248: 48031821  bl 0x82aa2a68
	ctx.lr = 0x82A7124C;
	sub_82AA2A68(ctx, base);
	// 82A7124C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A71250: 4B7CA3D1  bl 0x8223b620
	ctx.lr = 0x82A71254;
	sub_8223B620(ctx, base);
	// 82A71254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A71258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7125C: 4803210D  bl 0x82aa3368
	ctx.lr = 0x82A71260;
	sub_82AA3368(ctx, base);
	// 82A71260: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A71264: 556A05EE  rlwinm r10, r11, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A71268: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A7126C: 419A0008  beq cr6, 0x82a71274
	if ctx.cr[6].eq {
	pc = 0x82A71274; continue 'dispatch;
	}
	// 82A71270: 9B9F0110  stb r28, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[28].u8 ) };
	pc = 0x82A71274; continue 'dispatch;
            }
            0x82A71274 => {
    //   block [0x82A71274..0x82A71294)
	// 82A71274: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A71278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A7127C: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A71280: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A71284: 4E800421  bctrl
	ctx.lr = 0x82A71288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A71288: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A7128C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A71290: 482381C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A71294 => {
    //   block [0x82A71294..0x82A712D8)
	// 82A71294: 389D0070  addi r4, r29, 0x70
	ctx.r[4].s64 = ctx.r[29].s64 + 112;
	// 82A71298: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 82A7129C: 480AEC8D  bl 0x82b1ff28
	ctx.lr = 0x82A712A0;
	sub_82B1FF28(ctx, base);
	// 82A712A0: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A712A4: 391F0208  addi r8, r31, 0x208
	ctx.r[8].s64 = ctx.r[31].s64 + 520;
	// 82A712A8: 83DD0034  lwz r30, 0x34(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A712AC: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82A712B0: 813D0064  lwz r9, 0x64(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A712B4: 913F0220  stw r9, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[9].u32 ) };
	// 82A712B8: 895F020C  lbz r10, 0x20c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82A712BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A712C0: 419AFF7C  beq cr6, 0x82a7123c
	if ctx.cr[6].eq {
	pc = 0x82A7123C; continue 'dispatch;
	}
	// 82A712C4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A712C8: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A712CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A712D0: 419AFF6C  beq cr6, 0x82a7123c
	if ctx.cr[6].eq {
	pc = 0x82A7123C; continue 'dispatch;
	}
	// 82A712D4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	pc = 0x82A712D8; continue 'dispatch;
            }
            0x82A712D8 => {
    //   block [0x82A712D8..0x82A71300)
	// 82A712D8: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A712DC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A712E0: 80C80018  lwz r6, 0x18(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A712E4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A712E8: 392900A0  addi r9, r9, 0xa0
	ctx.r[9].s64 = ctx.r[9].s64 + 160;
	// 82A712EC: 38EB0080  addi r7, r11, 0x80
	ctx.r[7].s64 = ctx.r[11].s64 + 128;
	// 82A712F0: 90CB0094  stw r6, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[6].u32 ) };
	// 82A712F4: 9B8B0098  stb r28, 0x98(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[28].u8 ) };
	// 82A712F8: 4082FFE0  bne 0x82a712d8
	if !ctx.cr[0].eq {
	pc = 0x82A712D8; continue 'dispatch;
	}
	// 82A712FC: 4BFFFF40  b 0x82a7123c
	pc = 0x82A7123C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A71300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A71300 size=176
    let mut pc: u32 = 0x82A71300;
    'dispatch: loop {
        match pc {
            0x82A71300 => {
    //   block [0x82A71300..0x82A71354)
	// 82A71300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A71304: 482380FD  bl 0x82ca9400
	ctx.lr = 0x82A71308;
	sub_82CA93D0(ctx, base);
	// 82A71308: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A7130C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A71310: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A71314: 397F01C0  addi r11, r31, 0x1c0
	ctx.r[11].s64 = ctx.r[31].s64 + 448;
	// 82A71318: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A7131C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A71320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A71324: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A71328: 4B76A9D9  bl 0x821dbd00
	ctx.lr = 0x82A7132C;
	sub_821DBD00(ctx, base);
	// 82A7132C: 895F020C  lbz r10, 0x20c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 82A71330: 3B9F0208  addi r28, r31, 0x208
	ctx.r[28].s64 = ctx.r[31].s64 + 520;
	// 82A71334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A71338: 419A0070  beq cr6, 0x82a713a8
	if ctx.cr[6].eq {
	pc = 0x82A713A8; continue 'dispatch;
	}
	// 82A7133C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A71340: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A71344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A71348: 419A0060  beq cr6, 0x82a713a8
	if ctx.cr[6].eq {
	pc = 0x82A713A8; continue 'dispatch;
	}
	// 82A7134C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A71350: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	pc = 0x82A71354; continue 'dispatch;
            }
            0x82A71354 => {
    //   block [0x82A71354..0x82A71388)
	// 82A71354: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A71358: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A7135C: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A71360: 419A0028  beq cr6, 0x82a71388
	if ctx.cr[6].eq {
	pc = 0x82A71388; continue 'dispatch;
	}
	// 82A71364: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A71368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A7136C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A71370: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A71374: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A71378: 4E800421  bctrl
	ctx.lr = 0x82A7137C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A7137C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A71380: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A71384: 419A0018  beq cr6, 0x82a7139c
	if ctx.cr[6].eq {
	pc = 0x82A7139C; continue 'dispatch;
	}
            }
            0x82A71388 => {
    //   block [0x82A71388..0x82A7139C)
	// 82A71388: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82A7138C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A71390: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A71394: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A71398: 4B76A969  bl 0x821dbd00
	ctx.lr = 0x82A7139C;
	sub_821DBD00(ctx, base);
	pc = 0x82A7139C; continue 'dispatch;
            }
            0x82A7139C => {
    //   block [0x82A7139C..0x82A713A8)
	// 82A7139C: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82A713A0: 3BDE00A0  addi r30, r30, 0xa0
	ctx.r[30].s64 = ctx.r[30].s64 + 160;
	// 82A713A4: 4082FFB0  bne 0x82a71354
	if !ctx.cr[0].eq {
	pc = 0x82A71354; continue 'dispatch;
	}
	pc = 0x82A713A8; continue 'dispatch;
            }
            0x82A713A8 => {
    //   block [0x82A713A8..0x82A713B0)
	// 82A713A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A713AC: 482380A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A713B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A713B0 size=148
    let mut pc: u32 = 0x82A713B0;
    'dispatch: loop {
        match pc {
            0x82A713B0 => {
    //   block [0x82A713B0..0x82A71444)
	// 82A713B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A713B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A713B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A713BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A713C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A713C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A713C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A713CC: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A713D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A713D4: 4E800421  bctrl
	ctx.lr = 0x82A713D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A713D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A713DC: 48031D95  bl 0x82aa3170
	ctx.lr = 0x82A713E0;
	sub_82AA3170(ctx, base);
	// 82A713E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A713E4: 48032955  bl 0x82aa3d38
	ctx.lr = 0x82A713E8;
	sub_82AA3D38(ctx, base);
	// 82A713E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A713EC: 3BDF0208  addi r30, r31, 0x208
	ctx.r[30].s64 = ctx.r[31].s64 + 520;
	// 82A713F0: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82A713F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A713F8: 997F020C  stb r11, 0x20c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u8 ) };
	// 82A713FC: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 82A71400: 811F0214  lwz r8, 0x214(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82A71404: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A71408: 813F0218  lwz r9, 0x218(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 82A7140C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A71410: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A71414: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82A71418: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A7141C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A71420: 480AE271  bl 0x82b1f690
	ctx.lr = 0x82A71424;
	sub_82B1F690(ctx, base);
	// 82A71424: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 82A71428: 4BFFF879  bl 0x82a70ca0
	ctx.lr = 0x82A7142C;
	sub_82A70CA0(ctx, base);
	// 82A7142C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A71430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A71434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A71438: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A7143C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A71440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A71448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A71448 size=148
    let mut pc: u32 = 0x82A71448;
    'dispatch: loop {
        match pc {
            0x82A71448 => {
    //   block [0x82A71448..0x82A71480)
	// 82A71448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7144C: 48237FBD  bl 0x82ca9408
	ctx.lr = 0x82A71450;
	sub_82CA93D0(ctx, base);
	// 82A71450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A71454: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A71458: 387D0240  addi r3, r29, 0x240
	ctx.r[3].s64 = ctx.r[29].s64 + 576;
	// 82A7145C: 4BFFF845  bl 0x82a70ca0
	ctx.lr = 0x82A71460;
	sub_82A70CA0(ctx, base);
	// 82A71460: 817D0238  lwz r11, 0x238(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(568 as u32) ) } as u64;
	// 82A71464: 815D0234  lwz r10, 0x234(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(564 as u32) ) } as u64;
	// 82A71468: 3B9D0230  addi r28, r29, 0x230
	ctx.r[28].s64 = ctx.r[29].s64 + 560;
	// 82A7146C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A71470: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A71474: 40810030  ble 0x82a714a4
	if !ctx.cr[0].gt {
	pc = 0x82A714A4; continue 'dispatch;
	}
	// 82A71478: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A7147C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x82A71480; continue 'dispatch;
            }
            0x82A71480 => {
    //   block [0x82A71480..0x82A71498)
	// 82A71480: 817D0234  lwz r11, 0x234(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(564 as u32) ) } as u64;
	// 82A71484: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A71488: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A7148C: 419A000C  beq cr6, 0x82a71498
	if ctx.cr[6].eq {
	pc = 0x82A71498; continue 'dispatch;
	}
	// 82A71490: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A71494: 4BFFF88D  bl 0x82a70d20
	ctx.lr = 0x82A71498;
	sub_82A70D20(ctx, base);
	pc = 0x82A71498; continue 'dispatch;
            }
            0x82A71498 => {
    //   block [0x82A71498..0x82A714A4)
	// 82A71498: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A7149C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A714A0: 4082FFE0  bne 0x82a71480
	if !ctx.cr[0].eq {
	pc = 0x82A71480; continue 'dispatch;
	}
	pc = 0x82A714A4; continue 'dispatch;
            }
            0x82A714A4 => {
    //   block [0x82A714A4..0x82A714D0)
	// 82A714A4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A714A8: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A714AC: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A714B0: 419A0024  beq cr6, 0x82a714d4
	if ctx.cr[6].eq {
	pc = 0x82A714D4; continue 'dispatch;
	}
	// 82A714B4: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82A714B8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A714BC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A714C0: 7FE61A14  add r31, r6, r3
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A714C4: 4081000C  ble 0x82a714d0
	if !ctx.cr[0].gt {
	pc = 0x82A714D0; continue 'dispatch;
	}
	// 82A714C8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A714CC: 48238B5D  bl 0x82caa028
	ctx.lr = 0x82A714D0;
	sub_82CAA028(ctx, base);
	pc = 0x82A714D0; continue 'dispatch;
            }
            0x82A714D0 => {
    //   block [0x82A714D0..0x82A714D4)
	// 82A714D0: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82A714D4; continue 'dispatch;
            }
            0x82A714D4 => {
    //   block [0x82A714D4..0x82A714DC)
	// 82A714D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A714D8: 48237F80  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A714E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A714E0 size=72
    let mut pc: u32 = 0x82A714E0;
    'dispatch: loop {
        match pc {
            0x82A714E0 => {
    //   block [0x82A714E0..0x82A71528)
	// 82A714E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A714E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A714E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A714EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A714F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A714F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A714F8: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A714FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A71500: 4E800421  bctrl
	ctx.lr = 0x82A71504;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A71504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A71508: 48031C69  bl 0x82aa3170
	ctx.lr = 0x82A7150C;
	sub_82AA3170(ctx, base);
	// 82A7150C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A71510: 48032829  bl 0x82aa3d38
	ctx.lr = 0x82A71514;
	sub_82AA3D38(ctx, base);
	// 82A71514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A71518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A7151C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A71520: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A71524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A71528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A71528 size=16
    let mut pc: u32 = 0x82A71528;
    'dispatch: loop {
        match pc {
            0x82A71528 => {
    //   block [0x82A71528..0x82A71538)
	// 82A71528: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A7152C: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A71530: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A71534: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A71538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A71538 size=172
    let mut pc: u32 = 0x82A71538;
    'dispatch: loop {
        match pc {
            0x82A71538 => {
    //   block [0x82A71538..0x82A71598)
	// 82A71538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A7153C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A71540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A71544: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A71548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A7154C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A71550: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A71554: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A71558: 7D081670  srawi r8, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82A7155C: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A71560: 40990038  ble cr6, 0x82a71598
	if !ctx.cr[6].gt {
	pc = 0x82A71598; continue 'dispatch;
	}
	// 82A71564: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A71568: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A7156C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A71570: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A71574: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A71578: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82A7157C: 7CA72050  subf r5, r7, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 82A71580: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A71584: 4800535D  bl 0x82a768e0
	ctx.lr = 0x82A71588;
	sub_82A768E0(ctx, base);
	// 82A71588: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A7158C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A71590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A71594: 4E800020  blr
	return;
            }
            0x82A71598 => {
    //   block [0x82A71598..0x82A715D4)
	// 82A71598: 4098003C  bge cr6, 0x82a715d4
	if !ctx.cr[6].lt {
	pc = 0x82A715D4; continue 'dispatch;
	}
	// 82A7159C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A715A0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A715A4: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A715A8: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 82A715AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A715B0: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A715B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A715B8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A715BC: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A715C0: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A715C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A715C8: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A715CC: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A715D0: 48000079  bl 0x82a71648
	ctx.lr = 0x82A715D4;
	sub_82A71648(ctx, base);
	pc = 0x82A715D4; continue 'dispatch;
            }
            0x82A715D4 => {
    //   block [0x82A715D4..0x82A715E4)
	// 82A715D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A715D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A715DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A715E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


