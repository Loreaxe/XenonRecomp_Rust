pub fn sub_82EB5498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5498 size=12
    let mut pc: u32 = 0x82EB5498;
    'dispatch: loop {
        match pc {
            0x82EB5498 => {
    //   block [0x82EB5498..0x82EB54A4)
	// 82EB5498: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB549C: 386BDAF4  addi r3, r11, -0x250c
	ctx.r[3].s64 = ctx.r[11].s64 + -9484;
	// 82EB54A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB54A8 size=92
    let mut pc: u32 = 0x82EB54A8;
    'dispatch: loop {
        match pc {
            0x82EB54A8 => {
    //   block [0x82EB54A8..0x82EB5504)
	// 82EB54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB54AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB54B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB54B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB54B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB54BC: 4BFFFE75  bl 0x82eb5330
	ctx.lr = 0x82EB54C0;
	sub_82EB5330(ctx, base);
	// 82EB54C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB54C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB54C8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB54CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB54D0: 396BA818  addi r11, r11, -0x57e8
	ctx.r[11].s64 = ctx.r[11].s64 + -22504;
	// 82EB54D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB54D8: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EB54DC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB54E0: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB54E4: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB54E8: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EB54EC: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EB54F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB54F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB54F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB54FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB5500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5508 size=12
    let mut pc: u32 = 0x82EB5508;
    'dispatch: loop {
        match pc {
            0x82EB5508 => {
    //   block [0x82EB5508..0x82EB5514)
	// 82EB5508: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB550C: 386BD9E0  addi r3, r11, -0x2620
	ctx.r[3].s64 = ctx.r[11].s64 + -9760;
	// 82EB5510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5518 size=12
    let mut pc: u32 = 0x82EB5518;
    'dispatch: loop {
        match pc {
            0x82EB5518 => {
    //   block [0x82EB5518..0x82EB5524)
	// 82EB5518: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB551C: 386BD6A4  addi r3, r11, -0x295c
	ctx.r[3].s64 = ctx.r[11].s64 + -10588;
	// 82EB5520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5528 size=12
    let mut pc: u32 = 0x82EB5528;
    'dispatch: loop {
        match pc {
            0x82EB5528 => {
    //   block [0x82EB5528..0x82EB5534)
	// 82EB5528: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB552C: 386BD8CC  addi r3, r11, -0x2734
	ctx.r[3].s64 = ctx.r[11].s64 + -10036;
	// 82EB5530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5538 size=88
    let mut pc: u32 = 0x82EB5538;
    'dispatch: loop {
        match pc {
            0x82EB5538 => {
    //   block [0x82EB5538..0x82EB5590)
	// 82EB5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB553C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5544: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB554C: 4BFFFDE5  bl 0x82eb5330
	ctx.lr = 0x82EB5550;
	sub_82EB5330(ctx, base);
	// 82EB5550: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5554: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB5558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB555C: 396BA86C  addi r11, r11, -0x5794
	ctx.r[11].s64 = ctx.r[11].s64 + -22420;
	// 82EB5560: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5564: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5568: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB556C: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EB5570: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EB5574: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EB5578: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EB557C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB5580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5588: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB558C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5590 size=12
    let mut pc: u32 = 0x82EB5590;
    'dispatch: loop {
        match pc {
            0x82EB5590 => {
    //   block [0x82EB5590..0x82EB559C)
	// 82EB5590: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB5594: 386BD244  addi r3, r11, -0x2dbc
	ctx.r[3].s64 = ctx.r[11].s64 + -11708;
	// 82EB5598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB55A0 size=8
    let mut pc: u32 = 0x82EB55A0;
    'dispatch: loop {
        match pc {
            0x82EB55A0 => {
    //   block [0x82EB55A0..0x82EB55A8)
	// 82EB55A0: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EB55A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB55A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB55A8 size=8
    let mut pc: u32 = 0x82EB55A8;
    'dispatch: loop {
        match pc {
            0x82EB55A8 => {
    //   block [0x82EB55A8..0x82EB55B0)
	// 82EB55A8: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB55AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB55B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB55B0 size=148
    let mut pc: u32 = 0x82EB55B0;
    'dispatch: loop {
        match pc {
            0x82EB55B0 => {
    //   block [0x82EB55B0..0x82EB55F4)
	// 82EB55B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB55B4: 4BDF3E59  bl 0x82ca940c
	ctx.lr = 0x82EB55B8;
	sub_82CA93D0(ctx, base);
	// 82EB55B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB55BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB55C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB55C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB55C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB55CC: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EB55D0: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB55D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB55D8: 4B3330A1  bl 0x821e8678
	ctx.lr = 0x82EB55DC;
	sub_821E8678(ctx, base);
	// 82EB55DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB55E0: 41820014  beq 0x82eb55f4
	if ctx.cr[0].eq {
	pc = 0x82EB55F4; continue 'dispatch;
	}
	// 82EB55E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB55E8: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB55EC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB55F0: 4800002C  b 0x82eb561c
	pc = 0x82EB561C; continue 'dispatch;
            }
            0x82EB55F4 => {
    //   block [0x82EB55F4..0x82EB560C)
	// 82EB55F4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB55F8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB55FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5600: 4182000C  beq 0x82eb560c
	if ctx.cr[0].eq {
	pc = 0x82EB560C; continue 'dispatch;
	}
	// 82EB5604: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5608: 4800000C  b 0x82eb5614
	pc = 0x82EB5614; continue 'dispatch;
            }
            0x82EB560C => {
    //   block [0x82EB560C..0x82EB5614)
	// 82EB560C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5610: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EB5614; continue 'dispatch;
            }
            0x82EB5614 => {
    //   block [0x82EB5614..0x82EB561C)
	// 82EB5614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5618: C00B0B24  lfs f0, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB561C; continue 'dispatch;
            }
            0x82EB561C => {
    //   block [0x82EB561C..0x82EB5644)
	// 82EB561C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5620: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5624: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB5628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB562C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5630: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5638: 4E800421  bctrl
	ctx.lr = 0x82EB563C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB563C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5640: 4BDF3E1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5648 size=156
    let mut pc: u32 = 0x82EB5648;
    'dispatch: loop {
        match pc {
            0x82EB5648 => {
    //   block [0x82EB5648..0x82EB5690)
	// 82EB5648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB564C: 4BDF3DBD  bl 0x82ca9408
	ctx.lr = 0x82EB5650;
	sub_82CA93D0(ctx, base);
	// 82EB5650: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5654: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB565C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5660: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5664: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82EB5668: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EB566C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB5670: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EB5674: 4B333005  bl 0x821e8678
	ctx.lr = 0x82EB5678;
	sub_821E8678(ctx, base);
	// 82EB5678: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB567C: 41820014  beq 0x82eb5690
	if ctx.cr[0].eq {
	pc = 0x82EB5690; continue 'dispatch;
	}
	// 82EB5680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5684: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5688: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB568C: 4800002C  b 0x82eb56b8
	pc = 0x82EB56B8; continue 'dispatch;
            }
            0x82EB5690 => {
    //   block [0x82EB5690..0x82EB56A8)
	// 82EB5690: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5694: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB5698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB569C: 4182000C  beq 0x82eb56a8
	if ctx.cr[0].eq {
	pc = 0x82EB56A8; continue 'dispatch;
	}
	// 82EB56A0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB56A4: 4800000C  b 0x82eb56b0
	pc = 0x82EB56B0; continue 'dispatch;
            }
            0x82EB56A8 => {
    //   block [0x82EB56A8..0x82EB56B0)
	// 82EB56A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB56AC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EB56B0; continue 'dispatch;
            }
            0x82EB56B0 => {
    //   block [0x82EB56B0..0x82EB56B8)
	// 82EB56B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB56B4: C00B0B24  lfs f0, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB56B8; continue 'dispatch;
            }
            0x82EB56B8 => {
    //   block [0x82EB56B8..0x82EB56E4)
	// 82EB56B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB56BC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB56C0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB56C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB56C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB56CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB56D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB56D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB56D8: 4E800421  bctrl
	ctx.lr = 0x82EB56DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB56DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB56E0: 4BDF3D78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB56E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB56E8 size=12
    let mut pc: u32 = 0x82EB56E8;
    'dispatch: loop {
        match pc {
            0x82EB56E8 => {
    //   block [0x82EB56E8..0x82EB56F4)
	// 82EB56E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB56EC: 386BD590  addi r3, r11, -0x2a70
	ctx.r[3].s64 = ctx.r[11].s64 + -10864;
	// 82EB56F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB56F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB56F8 size=88
    let mut pc: u32 = 0x82EB56F8;
    'dispatch: loop {
        match pc {
            0x82EB56F8 => {
    //   block [0x82EB56F8..0x82EB5734)
	// 82EB56F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB56FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB5704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB5708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB570C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5710: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5714: 4800B675  bl 0x82ec0d88
	ctx.lr = 0x82EB5718;
	sub_82EC0D88(ctx, base);
	// 82EB5718: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB571C: 41820018  beq 0x82eb5734
	if ctx.cr[0].eq {
	pc = 0x82EB5734; continue 'dispatch;
	}
	// 82EB5720: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB5724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5728: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB572C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5730: 4E800421  bctrl
	ctx.lr = 0x82EB5734;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB5734 => {
    //   block [0x82EB5734..0x82EB5750)
	// 82EB5734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB5738: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB573C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB5740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB5744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB5748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB574C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5750 size=148
    let mut pc: u32 = 0x82EB5750;
    'dispatch: loop {
        match pc {
            0x82EB5750 => {
    //   block [0x82EB5750..0x82EB578C)
	// 82EB5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB5758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB575C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5764: 4BFFFBCD  bl 0x82eb5330
	ctx.lr = 0x82EB5768;
	sub_82EB5330(ctx, base);
	// 82EB5768: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB576C: 396BA8BC  addi r11, r11, -0x5744
	ctx.r[11].s64 = ctx.r[11].s64 + -22340;
	// 82EB5770: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5774: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5778: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB577C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5780: 4182000C  beq 0x82eb578c
	if ctx.cr[0].eq {
	pc = 0x82EB578C; continue 'dispatch;
	}
	// 82EB5784: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5788: 4800000C  b 0x82eb5794
	pc = 0x82EB5794; continue 'dispatch;
            }
            0x82EB578C => {
    //   block [0x82EB578C..0x82EB5794)
	// 82EB578C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5790: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EB5794; continue 'dispatch;
            }
            0x82EB5794 => {
    //   block [0x82EB5794..0x82EB57E4)
	// 82EB5794: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB5798: C00BDF3C  lfs f0, -0x20c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB579C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB57A0: C1ABBE10  lfs f13, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB57A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB57A8: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB57AC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB57B0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB57B4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB57B8: 4B3846F9  bl 0x82239eb0
	ctx.lr = 0x82EB57BC;
	sub_82239EB0(ctx, base);
	// 82EB57BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB57C0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EB57C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB57C8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB57CC: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EB57D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB57D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB57D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB57DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB57E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB57E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB57E8 size=12
    let mut pc: u32 = 0x82EB57E8;
    'dispatch: loop {
        match pc {
            0x82EB57E8 => {
    //   block [0x82EB57E8..0x82EB57F4)
	// 82EB57E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB57EC: 386BCDF0  addi r3, r11, -0x3210
	ctx.r[3].s64 = ctx.r[11].s64 + -12816;
	// 82EB57F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB57F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB57F8 size=12
    let mut pc: u32 = 0x82EB57F8;
    'dispatch: loop {
        match pc {
            0x82EB57F8 => {
    //   block [0x82EB57F8..0x82EB5804)
	// 82EB57F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB57FC: 386BCBC8  addi r3, r11, -0x3438
	ctx.r[3].s64 = ctx.r[11].s64 + -13368;
	// 82EB5800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5808 size=16
    let mut pc: u32 = 0x82EB5808;
    'dispatch: loop {
        match pc {
            0x82EB5808 => {
    //   block [0x82EB5808..0x82EB5818)
	// 82EB5808: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB580C: 99630040  stb r11, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82EB5810: 9963019D  stb r11, 0x19d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(413 as u32), ctx.r[11].u8 ) };
	// 82EB5814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5818 size=24
    let mut pc: u32 = 0x82EB5818;
    'dispatch: loop {
        match pc {
            0x82EB5818 => {
    //   block [0x82EB5818..0x82EB5830)
	// 82EB5818: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB581C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB5820: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82EB5824: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB5828: 996500A1  stb r11, 0xa1(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(161 as u32), ctx.r[11].u8 ) };
	// 82EB582C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB5830 size=200
    let mut pc: u32 = 0x82EB5830;
    'dispatch: loop {
        match pc {
            0x82EB5830 => {
    //   block [0x82EB5830..0x82EB58A0)
	// 82EB5830: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5834: 81430398  lwz r10, 0x398(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EB5838: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82EB583C: 810B01B8  lwz r8, 0x1b8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5840: 409A00B8  bne cr6, 0x82eb58f8
	if !ctx.cr[6].eq {
		sub_82EB58F8(ctx, base);
		return;
	}
	// 82EB5844: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5848: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB584C: 419A00AC  beq cr6, 0x82eb58f8
	if ctx.cr[6].eq {
		sub_82EB58F8(ctx, base);
		return;
	}
	// 82EB5850: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5854: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB5858: 8163039C  lwz r11, 0x39c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EB585C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB5860: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB5864: C16B0004  lfs f11, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5868: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB586C: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5870: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB5874: C1AA0038  lfs f13, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5878: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB587C: C18A003C  lfs f12, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5880: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5884: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB5888: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB588C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5890: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5894: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB5898: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EB589C: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EB58A0; continue 'dispatch;
            }
            0x82EB58A0 => {
    //   block [0x82EB58A0..0x82EB58E0)
	// 82EB58A0: C16AFFF8  lfs f11, -8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB58A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB58A8: C14AFFFC  lfs f10, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB58AC: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB58B0: 419A0030  beq cr6, 0x82eb58e0
	if ctx.cr[6].eq {
	pc = 0x82EB58E0; continue 'dispatch;
	}
	// 82EB58B4: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB58B8: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EB58BC: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB58C0: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB58C4: C129000C  lfs f9, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB58C8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB58CC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB58D0: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB58D4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB58D8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB58DC: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	pc = 0x82EB58E0; continue 'dispatch;
            }
            0x82EB58E0 => {
    //   block [0x82EB58E0..0x82EB58F8)
	// 82EB58E0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB58E4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB58E8: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB58EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB58F0: 409AFFB0  bne cr6, 0x82eb58a0
	if !ctx.cr[6].eq {
	pc = 0x82EB58A0; continue 'dispatch;
	}
	// 82EB58F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB58F8 size=64
    let mut pc: u32 = 0x82EB58F8;
    'dispatch: loop {
        match pc {
            0x82EB58F8 => {
    //   block [0x82EB58F8..0x82EB5938)
	// 82EB58F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB58FC: C00302DC  lfs f0, 0x2dc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5900: C1A302E0  lfs f13, 0x2e0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(736 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5904: C18302E4  lfs f12, 0x2e4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(740 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5908: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB590C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5910: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB5914: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5918: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB591C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5920: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB5924: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5928: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB592C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5930: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB5934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB5938 size=16
    let mut pc: u32 = 0x82EB5938;
    'dispatch: loop {
        match pc {
            0x82EB5938 => {
    //   block [0x82EB5938..0x82EB5948)
	// 82EB5938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB593C: 90830038  stw r4, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[4].u32 ) };
	// 82EB5940: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EB5944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5948 size=624
    let mut pc: u32 = 0x82EB5948;
    'dispatch: loop {
        match pc {
            0x82EB5948 => {
    //   block [0x82EB5948..0x82EB59A0)
	// 82EB5948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB594C: 4BDF3AB9  bl 0x82ca9404
	ctx.lr = 0x82EB5950;
	sub_82CA93D0(ctx, base);
	// 82EB5950: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82EB5954: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB595C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EB5960: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EB5964: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5968: 9BBF0034  stb r29, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u8 ) };
	// 82EB596C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5970: 4182023C  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5974: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82EB5978: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EB597C: 409A0230  bne cr6, 0x82eb5bac
	if !ctx.cr[6].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5980: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EB5984: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5988: 40820018  bne 0x82eb59a0
	if !ctx.cr[0].eq {
	pc = 0x82EB59A0; continue 'dispatch;
	}
	// 82EB598C: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EB5990: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB5994: 388B5818  addi r4, r11, 0x5818
	ctx.r[4].s64 = ctx.r[11].s64 + 22552;
	// 82EB5998: 48017009  bl 0x82ecc9a0
	ctx.lr = 0x82EB599C;
	sub_82ECC9A0(ctx, base);
	// 82EB599C: 9BBF00A0  stb r29, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[29].u8 ) };
	pc = 0x82EB59A0; continue 'dispatch;
            }
            0x82EB59A0 => {
    //   block [0x82EB59A0..0x82EB59E0)
	// 82EB59A0: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB59A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB59A8: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59AC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB59B0: 419A003C  beq cr6, 0x82eb59ec
	if ctx.cr[6].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB59B8: 419A0034  beq cr6, 0x82eb59ec
	if ctx.cr[6].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59BC: 4801DE95  bl 0x82ed3850
	ctx.lr = 0x82EB59C0;
	sub_82ED3850(ctx, base);
	// 82EB59C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB59C4: 41820028  beq 0x82eb59ec
	if ctx.cr[0].eq {
	pc = 0x82EB59EC; continue 'dispatch;
	}
	// 82EB59C8: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59CC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB59D0: 41820010  beq 0x82eb59e0
	if ctx.cr[0].eq {
	pc = 0x82EB59E0; continue 'dispatch;
	}
	// 82EB59D4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB59D8: 4801D559  bl 0x82ed2f30
	ctx.lr = 0x82EB59DC;
	sub_82ED2F30(ctx, base);
	// 82EB59DC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	pc = 0x82EB59E0; continue 'dispatch;
            }
            0x82EB59E0 => {
    //   block [0x82EB59E0..0x82EB59EC)
	// 82EB59E0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB59E4: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB59E8: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB59EC; continue 'dispatch;
            }
            0x82EB59EC => {
    //   block [0x82EB59EC..0x82EB5A18)
	// 82EB59EC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB59F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB59F4: 41820024  beq 0x82eb5a18
	if ctx.cr[0].eq {
	pc = 0x82EB5A18; continue 'dispatch;
	}
	// 82EB59F8: 4801DEB1  bl 0x82ed38a8
	ctx.lr = 0x82EB59FC;
	sub_82ED38A8(ctx, base);
	// 82EB59FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5A00: 41820018  beq 0x82eb5a18
	if ctx.cr[0].eq {
	pc = 0x82EB5A18; continue 'dispatch;
	}
	// 82EB5A04: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB5A08: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5A0C: 4801D525  bl 0x82ed2f30
	ctx.lr = 0x82EB5A10;
	sub_82ED2F30(ctx, base);
	// 82EB5A10: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB5A14: 9BBF00A1  stb r29, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[29].u8 ) };
	pc = 0x82EB5A18; continue 'dispatch;
            }
            0x82EB5A18 => {
    //   block [0x82EB5A18..0x82EB5A60)
	// 82EB5A18: C17B0000  lfs f11, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB5A1C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB5A20: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A24: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB5A28: C15F0084  lfs f10, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5A2C: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A34: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB5A38: C19B0008  lfs f12, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB5A3C: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB5A40: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EB5A44: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5A48: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5A4C: ED8C033A  fmadds f12, f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB5A50: 409A0010  bne cr6, 0x82eb5a60
	if !ctx.cr[6].eq {
	pc = 0x82EB5A60; continue 'dispatch;
	}
	// 82EB5A54: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB5A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A5C: 419A0058  beq cr6, 0x82eb5ab4
	if ctx.cr[6].eq {
	pc = 0x82EB5AB4; continue 'dispatch;
	}
	pc = 0x82EB5A60; continue 'dispatch;
            }
            0x82EB5A60 => {
    //   block [0x82EB5A60..0x82EB5A80)
	// 82EB5A60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB5A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB5A68: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB5A6C: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A74: 4182000C  beq 0x82eb5a80
	if ctx.cr[0].eq {
	pc = 0x82EB5A80; continue 'dispatch;
	}
	// 82EB5A78: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB5A7C: 48000008  b 0x82eb5a84
	pc = 0x82EB5A84; continue 'dispatch;
            }
            0x82EB5A80 => {
    //   block [0x82EB5A80..0x82EB5A84)
	// 82EB5A80: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EB5A84; continue 'dispatch;
            }
            0x82EB5A84 => {
    //   block [0x82EB5A84..0x82EB5A90)
	// 82EB5A84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5A88: 41820008  beq 0x82eb5a90
	if ctx.cr[0].eq {
	pc = 0x82EB5A90; continue 'dispatch;
	}
	// 82EB5A8C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EB5A90; continue 'dispatch;
            }
            0x82EB5A90 => {
    //   block [0x82EB5A90..0x82EB5AB4)
	// 82EB5A90: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB5A94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5A98: C00B0B60  lfs f0, 0xb60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5A9C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB5AA0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EB5AA4: 40980010  bge cr6, 0x82eb5ab4
	if !ctx.cr[6].lt {
	pc = 0x82EB5AB4; continue 'dispatch;
	}
	// 82EB5AA8: 897F00A1  lbz r11, 0xa1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(161 as u32) ) } as u64;
	// 82EB5AAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5AB0: 418200FC  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	pc = 0x82EB5AB4; continue 'dispatch;
            }
            0x82EB5AB4 => {
    //   block [0x82EB5AB4..0x82EB5AF0)
	// 82EB5AB4: D17F0080  stfs f11, 0x80(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB5AB8: 3B9F005C  addi r28, r31, 0x5c
	ctx.r[28].s64 = ctx.r[31].s64 + 92;
	// 82EB5ABC: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5AC0: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB5AC4: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5AC8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB5ACC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5AD0: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82EB5AD4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB5AD8: 4801C3C9  bl 0x82ed1ea0
	ctx.lr = 0x82EB5ADC;
	sub_82ED1EA0(ctx, base);
	// 82EB5ADC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB5AE0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82EB5AE4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5AE8: 40990008  ble cr6, 0x82eb5af0
	if !ctx.cr[6].gt {
	pc = 0x82EB5AF0; continue 'dispatch;
	}
	// 82EB5AEC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x82EB5AF0; continue 'dispatch;
            }
            0x82EB5AF0 => {
    //   block [0x82EB5AF0..0x82EB5B38)
	// 82EB5AF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB5AF4: 80FF0060  lwz r7, 0x60(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB5AF8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EB5AFC: C03F002C  lfs f1, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB5B00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB5B04: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB5B0C: 4801C58D  bl 0x82ed2098
	ctx.lr = 0x82EB5B10;
	sub_82ED2098(ctx, base);
	// 82EB5B10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5B14: 41820098  beq 0x82eb5bac
	if ctx.cr[0].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5B18: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B20: 419A008C  beq cr6, 0x82eb5bac
	if ctx.cr[6].eq {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5B24: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB5B28: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B2C: 4182000C  beq 0x82eb5b38
	if ctx.cr[0].eq {
	pc = 0x82EB5B38; continue 'dispatch;
	}
	// 82EB5B30: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B34: 4801D3FD  bl 0x82ed2f30
	ctx.lr = 0x82EB5B38;
	sub_82ED2F30(ctx, base);
	pc = 0x82EB5B38; continue 'dispatch;
            }
            0x82EB5B38 => {
    //   block [0x82EB5B38..0x82EB5B5C)
	// 82EB5B38: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B3C: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB5B40: 4801C461  bl 0x82ed1fa0
	ctx.lr = 0x82EB5B44;
	sub_82ED1FA0(ctx, base);
	// 82EB5B44: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5B4C: 40990044  ble cr6, 0x82eb5b90
	if !ctx.cr[6].gt {
	pc = 0x82EB5B90; continue 'dispatch;
	}
	// 82EB5B50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB5B54: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB5B58: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB5B5C; continue 'dispatch;
            }
            0x82EB5B5C => {
    //   block [0x82EB5B5C..0x82EB5B90)
	// 82EB5B5C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB5B60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB5B64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB5B68: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B6C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB5B70: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB5B74: 4801D1D5  bl 0x82ed2d48
	ctx.lr = 0x82EB5B78;
	sub_82ED2D48(ctx, base);
	// 82EB5B78: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EB5B7C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB5B80: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5B84: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB5B88: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5B8C: 4198FFD0  blt cr6, 0x82eb5b5c
	if ctx.cr[6].lt {
	pc = 0x82EB5B5C; continue 'dispatch;
	}
	pc = 0x82EB5B90; continue 'dispatch;
            }
            0x82EB5B90 => {
    //   block [0x82EB5B90..0x82EB5BAC)
	// 82EB5B90: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB5B94: 4801C42D  bl 0x82ed1fc0
	ctx.lr = 0x82EB5B98;
	sub_82ED1FC0(ctx, base);
	// 82EB5B98: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB5B9C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82EB5BA0: 4098000C  bge cr6, 0x82eb5bac
	if !ctx.cr[6].lt {
	pc = 0x82EB5BAC; continue 'dispatch;
	}
	// 82EB5BA4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB5BA8: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB5BAC; continue 'dispatch;
            }
            0x82EB5BAC => {
    //   block [0x82EB5BAC..0x82EB5BB8)
	// 82EB5BAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5BB0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EB5BB4: 4BDF38A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5BB8 size=196
    let mut pc: u32 = 0x82EB5BB8;
    'dispatch: loop {
        match pc {
            0x82EB5BB8 => {
    //   block [0x82EB5BB8..0x82EB5BFC)
	// 82EB5BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5BBC: 4BDF3845  bl 0x82ca9400
	ctx.lr = 0x82EB5BC0;
	sub_82CA93D0(ctx, base);
	// 82EB5BC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5BC4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EB5BC8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EB5BCC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BD0: 419A00A4  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BD4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BD8: 419A009C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BDC: 83FA01BC  lwz r31, 0x1bc(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5BE0: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5BE4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB5BE8: 419A008C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5BEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB5BF0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB5BF4: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5BF8: 4182007C  beq 0x82eb5c74
	if ctx.cr[0].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	pc = 0x82EB5BFC; continue 'dispatch;
            }
            0x82EB5BFC => {
    //   block [0x82EB5BFC..0x82EB5C20)
	// 82EB5BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB5C00: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5C04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C08: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EB5C0C: 4801DCCD  bl 0x82ed38d8
	ctx.lr = 0x82EB5C10;
	sub_82ED38D8(ctx, base);
	// 82EB5C10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5C14: 4182000C  beq 0x82eb5c20
	if ctx.cr[0].eq {
	pc = 0x82EB5C20; continue 'dispatch;
	}
	// 82EB5C18: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5C1C: 48000008  b 0x82eb5c24
	pc = 0x82EB5C24; continue 'dispatch;
            }
            0x82EB5C20 => {
    //   block [0x82EB5C20..0x82EB5C24)
	// 82EB5C20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82EB5C24; continue 'dispatch;
            }
            0x82EB5C24 => {
    //   block [0x82EB5C24..0x82EB5C58)
	// 82EB5C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB5C28: 419A0030  beq cr6, 0x82eb5c58
	if ctx.cr[6].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C2C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EB5C30: 419A0028  beq cr6, 0x82eb5c58
	if ctx.cr[6].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB5C38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB5C3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C40: 4801FD21  bl 0x82ed5960
	ctx.lr = 0x82EB5C44;
	sub_82ED5960(ctx, base);
	// 82EB5C44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB5C48: 41820010  beq 0x82eb5c58
	if ctx.cr[0].eq {
	pc = 0x82EB5C58; continue 'dispatch;
	}
	// 82EB5C4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB5C50: 4801EB41  bl 0x82ed4790
	ctx.lr = 0x82EB5C54;
	sub_82ED4790(ctx, base);
	// 82EB5C54: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	pc = 0x82EB5C58; continue 'dispatch;
            }
            0x82EB5C58 => {
    //   block [0x82EB5C58..0x82EB5C74)
	// 82EB5C58: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5C5C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB5C60: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82EB5C64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB5C68: 419A000C  beq cr6, 0x82eb5c74
	if ctx.cr[6].eq {
	pc = 0x82EB5C74; continue 'dispatch;
	}
	// 82EB5C6C: 37FF0014  addic. r31, r31, 0x14
	ctx.xer.ca = (ctx.r[31].u32 > (!(20 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EB5C70: 4082FF8C  bne 0x82eb5bfc
	if !ctx.cr[0].eq {
	pc = 0x82EB5BFC; continue 'dispatch;
	}
	pc = 0x82EB5C74; continue 'dispatch;
            }
            0x82EB5C74 => {
    //   block [0x82EB5C74..0x82EB5C7C)
	// 82EB5C74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5C78: 4BDF37D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB5CA0 size=120
    let mut pc: u32 = 0x82EB5CA0;
    'dispatch: loop {
        match pc {
            0x82EB5CA0 => {
    //   block [0x82EB5CA0..0x82EB5CB8)
	// 82EB5CA0: 816301BC  lwz r11, 0x1bc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB5CA4: 814301B8  lwz r10, 0x1b8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5CA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB5CAC: 419A0030  beq cr6, 0x82eb5cdc
	if ctx.cr[6].eq {
	pc = 0x82EB5CDC; continue 'dispatch;
	}
	// 82EB5CB0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5CB4: 5529007E  clrlwi r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	pc = 0x82EB5CB8; continue 'dispatch;
            }
            0x82EB5CB8 => {
    //   block [0x82EB5CB8..0x82EB5CD8)
	// 82EB5CB8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5CBC: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB5CC0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB5CC4: 419A0014  beq cr6, 0x82eb5cd8
	if ctx.cr[6].eq {
	pc = 0x82EB5CD8; continue 'dispatch;
	}
	// 82EB5CC8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB5CCC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB5CD0: 409AFFE8  bne cr6, 0x82eb5cb8
	if !ctx.cr[6].eq {
	pc = 0x82EB5CB8; continue 'dispatch;
	}
	// 82EB5CD4: 48000008  b 0x82eb5cdc
	pc = 0x82EB5CDC; continue 'dispatch;
            }
            0x82EB5CD8 => {
    //   block [0x82EB5CD8..0x82EB5CDC)
	// 82EB5CD8: 916301B8  stw r11, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB5CDC; continue 'dispatch;
            }
            0x82EB5CDC => {
    //   block [0x82EB5CDC..0x82EB5D18)
	// 82EB5CDC: 816301B8  lwz r11, 0x1b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5CE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB5CE4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5CE8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB5CEC: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5CF0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5CF4: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5CF8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5CFC: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5D00: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5D04: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EB5D08: 816301B8  lwz r11, 0x1b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB5D0C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EB5D10: 916301B8  stw r11, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB5D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB5D18 size=128
    let mut pc: u32 = 0x82EB5D18;
    'dispatch: loop {
        match pc {
            0x82EB5D18 => {
    //   block [0x82EB5D18..0x82EB5D4C)
	// 82EB5D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5D1C: 4BDF36F1  bl 0x82ca940c
	ctx.lr = 0x82EB5D20;
	sub_82CA93D0(ctx, base);
	// 82EB5D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB5D28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB5D2C: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82EB5D30: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5D34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5D38: 41820014  beq 0x82eb5d4c
	if ctx.cr[0].eq {
	pc = 0x82EB5D4C; continue 'dispatch;
	}
	// 82EB5D3C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB5D40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5D44: 4E800421  bctrl
	ctx.lr = 0x82EB5D48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5D48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            0x82EB5D4C => {
    //   block [0x82EB5D4C..0x82EB5D6C)
	// 82EB5D4C: 807F019C  lwz r3, 0x19c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB5D50: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EB5D54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5D58: 41820014  beq 0x82eb5d6c
	if ctx.cr[0].eq {
	pc = 0x82EB5D6C; continue 'dispatch;
	}
	// 82EB5D5C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB5D60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5D64: 4E800421  bctrl
	ctx.lr = 0x82EB5D68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5D68: 93DF019C  stw r30, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[30].u32 ) };
            }
            0x82EB5D6C => {
    //   block [0x82EB5D6C..0x82EB5D8C)
	// 82EB5D6C: 807F01B4  lwz r3, 0x1b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB5D70: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82EB5D74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5D78: 41820014  beq 0x82eb5d8c
	if ctx.cr[0].eq {
	pc = 0x82EB5D8C; continue 'dispatch;
	}
	// 82EB5D7C: 817DDAB4  lwz r11, -0x254c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB5D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB5D84: 4E800421  bctrl
	ctx.lr = 0x82EB5D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB5D88: 93DF01B4  stw r30, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[30].u32 ) };
            }
            0x82EB5D8C => {
    //   block [0x82EB5D8C..0x82EB5D98)
	// 82EB5D8C: 93DF01C0  stw r30, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[30].u32 ) };
	// 82EB5D90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB5D94: 4BDF36C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5D98 size=312
    let mut pc: u32 = 0x82EB5D98;
    'dispatch: loop {
        match pc {
            0x82EB5D98 => {
    //   block [0x82EB5D98..0x82EB5DC4)
	// 82EB5D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5D9C: 4BDF3661  bl 0x82ca93fc
	ctx.lr = 0x82EB5DA0;
	sub_82CA93D0(ctx, base);
	// 82EB5DA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5DA4: 81450018  lwz r10, 0x18(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5DA8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EB5DAC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB5DB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5DB4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5DB8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB5DBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB5DC0: 419A0024  beq cr6, 0x82eb5de4
	if ctx.cr[6].eq {
	pc = 0x82EB5DE4; continue 'dispatch;
	}
	pc = 0x82EB5DC4; continue 'dispatch;
            }
            0x82EB5DC4 => {
    //   block [0x82EB5DC4..0x82EB5DE4)
	// 82EB5DC4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB5DC8: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5DCC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB5DD0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5DD4: 913D0018  stw r9, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB5DD8: 4182000C  beq 0x82eb5de4
	if ctx.cr[0].eq {
	pc = 0x82EB5DE4; continue 'dispatch;
	}
	// 82EB5DDC: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82EB5DE0: 4BFFFFE4  b 0x82eb5dc4
	pc = 0x82EB5DC4; continue 'dispatch;
            }
            0x82EB5DE4 => {
    //   block [0x82EB5DE4..0x82EB5DE8)
	// 82EB5DE4: 54DA043E  clrlwi r26, r6, 0x10
	ctx.r[26].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	pc = 0x82EB5DE8; continue 'dispatch;
            }
            0x82EB5DE8 => {
    //   block [0x82EB5DE8..0x82EB5E7C)
	// 82EB5DE8: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5DF0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5DF4: 83EB0198  lwz r31, 0x198(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB5DF8: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB5DFC: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82EB5E00: 4801DA31  bl 0x82ed3830
	ctx.lr = 0x82EB5E04;
	sub_82ED3830(ctx, base);
	// 82EB5E04: 546B007E  clrlwi r11, r3, 1
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB5E08: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 82EB5E0C: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 82EB5E10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB5E14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5E18: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E1C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5E20: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E24: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5E28: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5E2C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5E30: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB5E34: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5E38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5E3C: 41820040  beq 0x82eb5e7c
	if ctx.cr[0].eq {
	pc = 0x82EB5E7C; continue 'dispatch;
	}
	// 82EB5E40: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5E44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5E48: 41820034  beq 0x82eb5e7c
	if ctx.cr[0].eq {
	pc = 0x82EB5E7C; continue 'dispatch;
	}
	// 82EB5E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E50: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5E54: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5E58: 4801FB09  bl 0x82ed5960
	ctx.lr = 0x82EB5E5C;
	sub_82ED5960(ctx, base);
	// 82EB5E5C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82EB5E60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB5E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E68: 4801D8E9  bl 0x82ed3750
	ctx.lr = 0x82EB5E6C;
	sub_82ED3750(ctx, base);
	// 82EB5E6C: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E70: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB5E74: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5E78: 48000008  b 0x82eb5e80
	pc = 0x82EB5E80; continue 'dispatch;
            }
            0x82EB5E7C => {
    //   block [0x82EB5E7C..0x82EB5E80)
	// 82EB5E7C: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	pc = 0x82EB5E80; continue 'dispatch;
            }
            0x82EB5E80 => {
    //   block [0x82EB5E80..0x82EB5ED0)
	// 82EB5E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5E84: 4801F2FD  bl 0x82ed5180
	ctx.lr = 0x82EB5E88;
	sub_82ED5180(ctx, base);
	// 82EB5E88: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E8C: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB5E90: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82EB5E94: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5E98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB5E9C: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5EA0: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5EA4: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB5EA8: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5EAC: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB5EB0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB5EB4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB5EB8: 914B0198  stw r10, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[10].u32 ) };
	// 82EB5EBC: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5EC0: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5EC4: 4082FF24  bne 0x82eb5de8
	if !ctx.cr[0].eq {
	pc = 0x82EB5DE8; continue 'dispatch;
	}
	// 82EB5EC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5ECC: 4BDF3580  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB5ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB5ED0 size=300
    let mut pc: u32 = 0x82EB5ED0;
    'dispatch: loop {
        match pc {
            0x82EB5ED0 => {
    //   block [0x82EB5ED0..0x82EB5EFC)
	// 82EB5ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB5ED4: 4BDF3529  bl 0x82ca93fc
	ctx.lr = 0x82EB5ED8;
	sub_82CA93D0(ctx, base);
	// 82EB5ED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB5EDC: 81450018  lwz r10, 0x18(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5EE0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EB5EE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB5EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB5EEC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EB5EF0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EB5EF4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB5EF8: 419A0024  beq cr6, 0x82eb5f1c
	if ctx.cr[6].eq {
	pc = 0x82EB5F1C; continue 'dispatch;
	}
	pc = 0x82EB5EFC; continue 'dispatch;
            }
            0x82EB5EFC => {
    //   block [0x82EB5EFC..0x82EB5F1C)
	// 82EB5EFC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EB5F00: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5F04: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB5F08: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F0C: 913D0018  stw r9, 0x18(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB5F10: 4182000C  beq 0x82eb5f1c
	if ctx.cr[0].eq {
	pc = 0x82EB5F1C; continue 'dispatch;
	}
	// 82EB5F14: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82EB5F18: 4BFFFFE4  b 0x82eb5efc
	pc = 0x82EB5EFC; continue 'dispatch;
            }
            0x82EB5F1C => {
    //   block [0x82EB5F1C..0x82EB5F20)
	// 82EB5F1C: 54DA043E  clrlwi r26, r6, 0x10
	ctx.r[26].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	pc = 0x82EB5F20; continue 'dispatch;
            }
            0x82EB5F20 => {
    //   block [0x82EB5F20..0x82EB5FAC)
	// 82EB5F20: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5F24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F28: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F2C: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB5F30: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB5F34: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82EB5F38: 4801D8F9  bl 0x82ed3830
	ctx.lr = 0x82EB5F3C;
	sub_82ED3830(ctx, base);
	// 82EB5F3C: B35F0010  sth r26, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u16 ) };
	// 82EB5F40: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 82EB5F44: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB5F48: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB5F4C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F50: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB5F54: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F58: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB5F5C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB5F60: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB5F64: A17F0010  lhz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB5F68: B33F0012  sth r25, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[25].u16 ) };
	// 82EB5F6C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F70: 4182003C  beq 0x82eb5fac
	if ctx.cr[0].eq {
	pc = 0x82EB5FAC; continue 'dispatch;
	}
	// 82EB5F74: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5F78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5F7C: 41820030  beq 0x82eb5fac
	if ctx.cr[0].eq {
	pc = 0x82EB5FAC; continue 'dispatch;
	}
	// 82EB5F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F84: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F88: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB5F8C: 4801F9D5  bl 0x82ed5960
	ctx.lr = 0x82EB5F90;
	sub_82ED5960(ctx, base);
	// 82EB5F90: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82EB5F94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB5F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5F9C: 4801D7B5  bl 0x82ed3750
	ctx.lr = 0x82EB5FA0;
	sub_82ED3750(ctx, base);
	// 82EB5FA0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FA4: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB5FA8: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	pc = 0x82EB5FAC; continue 'dispatch;
            }
            0x82EB5FAC => {
    //   block [0x82EB5FAC..0x82EB5FFC)
	// 82EB5FAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB5FB0: 4801F1D1  bl 0x82ed5180
	ctx.lr = 0x82EB5FB4;
	sub_82ED5180(ctx, base);
	// 82EB5FB4: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FB8: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB5FBC: 7C6BE12E  stwx r3, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[3].u32) };
	// 82EB5FC0: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB5FC8: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB5FCC: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB5FD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB5FD4: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB5FD8: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB5FDC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB5FE0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB5FE4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB5FE8: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB5FEC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB5FF0: 4082FF30  bne 0x82eb5f20
	if !ctx.cr[0].eq {
	pc = 0x82EB5F20; continue 'dispatch;
	}
	// 82EB5FF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EB5FF8: 4BDF3454  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB6000 size=88
    let mut pc: u32 = 0x82EB6000;
    'dispatch: loop {
        match pc {
            0x82EB6000 => {
    //   block [0x82EB6000..0x82EB603C)
	// 82EB6000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB6008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB600C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB6010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB601C: 4BFFF3AD  bl 0x82eb53c8
	ctx.lr = 0x82EB6020;
	sub_82EB53C8(ctx, base);
	// 82EB6020: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6024: 41820018  beq 0x82eb603c
	if ctx.cr[0].eq {
	pc = 0x82EB603C; continue 'dispatch;
	}
	// 82EB6028: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB602C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6030: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB6034: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6038: 4E800421  bctrl
	ctx.lr = 0x82EB603C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB603C => {
    //   block [0x82EB603C..0x82EB6058)
	// 82EB603C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB6044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB6048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB604C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB6050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB6054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB6058 size=324
    let mut pc: u32 = 0x82EB6058;
    'dispatch: loop {
        match pc {
            0x82EB6058 => {
    //   block [0x82EB6058..0x82EB60D8)
	// 82EB6058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB605C: 4BDF33AD  bl 0x82ca9408
	ctx.lr = 0x82EB6060;
	sub_82CA93D0(ctx, base);
	// 82EB6060: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6064: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB6068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB606C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB6070: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6074: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB6078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB607C: 4E800421  bctrl
	ctx.lr = 0x82EB6080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6080: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EB6084: 4182010C  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB608C: 4801D7C5  bl 0x82ed3850
	ctx.lr = 0x82EB6090;
	sub_82ED3850(ctx, base);
	// 82EB6090: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6094: 418200FC  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6098: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB609C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60A0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB60A4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EB60A8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB60AC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60B0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB60B4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB60B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB60BC: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EB60C0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB60C4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB60C8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB60CC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82EB60D0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB60D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
            }
            0x82EB60D8 => {
    //   block [0x82EB60D8..0x82EB6188)
	// 82EB60D8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB60DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB60E0: 4200FFF8  bdnz 0x82eb60d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB60D8; continue 'dispatch;
	}
	// 82EB60E4: 817C009C  lwz r11, 0x9c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EB60E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB60EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB60F0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB60F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB60F8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB60FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB6100: 9BC100D8  stb r30, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[30].u8 ) };
	// 82EB6104: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EB6108: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB610C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB6110: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB6114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6118: 4801F419  bl 0x82ed5530
	ctx.lr = 0x82EB611C;
	sub_82ED5530(ctx, base);
	// 82EB611C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB6120: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82EB6124: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB6128: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB612C: 554BDFFF  rlwinm. r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6130: 41820060  beq 0x82eb6190
	if ctx.cr[0].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6134: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6138: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82EB613C: 419A0054  beq cr6, 0x82eb6190
	if ctx.cr[6].eq {
	pc = 0x82EB6190; continue 'dispatch;
	}
	// 82EB6140: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6144: 4801D795  bl 0x82ed38d8
	ctx.lr = 0x82EB6148;
	sub_82ED38D8(ctx, base);
	// 82EB6148: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB614C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EB6150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6154: 388A75C8  addi r4, r10, 0x75c8
	ctx.r[4].s64 = ctx.r[10].s64 + 30152;
	// 82EB6158: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB615C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB6160: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6164: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB6168: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB616C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6170: 9BDF0058  stb r30, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB6174: 4BFD356D  bl 0x82e896e0
	ctx.lr = 0x82EB6178;
	sub_82E896E0(ctx, base);
	// 82EB6178: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB617C: 4182000C  beq 0x82eb6188
	if ctx.cr[0].eq {
	pc = 0x82EB6188; continue 'dispatch;
	}
	// 82EB6180: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6184: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB6188; continue 'dispatch;
            }
            0x82EB6188 => {
    //   block [0x82EB6188..0x82EB6190)
	// 82EB6188: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB618C: 48000008  b 0x82eb6194
	pc = 0x82EB6194; continue 'dispatch;
            }
            0x82EB6190 => {
    //   block [0x82EB6190..0x82EB6194)
	// 82EB6190: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EB6194; continue 'dispatch;
            }
            0x82EB6194 => {
    //   block [0x82EB6194..0x82EB619C)
	// 82EB6194: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82EB6198: 4BDF32C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB61A0 size=216
    let mut pc: u32 = 0x82EB61A0;
    'dispatch: loop {
        match pc {
            0x82EB61A0 => {
    //   block [0x82EB61A0..0x82EB61CC)
	// 82EB61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB61A4: 4BDF3265  bl 0x82ca9408
	ctx.lr = 0x82EB61A8;
	sub_82CA93D0(ctx, base);
	// 82EB61A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB61AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EB61B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EB61B4: 809D017C  lwz r4, 0x17c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB61B8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB61BC: 41820010  beq 0x82eb61cc
	if ctx.cr[0].eq {
	pc = 0x82EB61CC; continue 'dispatch;
	}
	// 82EB61C0: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB61C4: 4801CD6D  bl 0x82ed2f30
	ctx.lr = 0x82EB61C8;
	sub_82ED2F30(ctx, base);
	// 82EB61C8: 93FD017C  stw r31, 0x17c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(380 as u32), ctx.r[31].u32 ) };
	pc = 0x82EB61CC; continue 'dispatch;
            }
            0x82EB61CC => {
    //   block [0x82EB61CC..0x82EB61E0)
	// 82EB61CC: 817D0168  lwz r11, 0x168(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB61D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82EB61D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB61D8: 40990064  ble cr6, 0x82eb623c
	if !ctx.cr[6].gt {
	pc = 0x82EB623C; continue 'dispatch;
	}
	// 82EB61DC: 3BDD00A8  addi r30, r29, 0xa8
	ctx.r[30].s64 = ctx.r[29].s64 + 168;
	pc = 0x82EB61E0; continue 'dispatch;
            }
            0x82EB61E0 => {
    //   block [0x82EB61E0..0x82EB6204)
	// 82EB61E0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB61E4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB61E8: 4182001C  beq 0x82eb6204
	if ctx.cr[0].eq {
	pc = 0x82EB6204; continue 'dispatch;
	}
	// 82EB61EC: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB61F0: 4801CD41  bl 0x82ed2f30
	ctx.lr = 0x82EB61F4;
	sub_82ED2F30(ctx, base);
	// 82EB61F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82EB61F8: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EB61FC: 93FE0048  stw r31, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 82EB6200: 93FEFFFC  stw r31, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[31].u32 ) };
	pc = 0x82EB6204; continue 'dispatch;
            }
            0x82EB6204 => {
    //   block [0x82EB6204..0x82EB6228)
	// 82EB6204: 809E0060  lwz r4, 0x60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB6208: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB620C: 4182001C  beq 0x82eb6228
	if ctx.cr[0].eq {
	pc = 0x82EB6228; continue 'dispatch;
	}
	// 82EB6210: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB6214: 4801CD1D  bl 0x82ed2f30
	ctx.lr = 0x82EB6218;
	sub_82ED2F30(ctx, base);
	// 82EB6218: 93FE0060  stw r31, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82EB621C: 9BFE0064  stb r31, 0x64(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u8 ) };
	// 82EB6220: 93FE00A8  stw r31, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 82EB6224: 93FE005C  stw r31, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	pc = 0x82EB6228; continue 'dispatch;
            }
            0x82EB6228 => {
    //   block [0x82EB6228..0x82EB623C)
	// 82EB6228: 817D0168  lwz r11, 0x168(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB622C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB6230: 3BDE0060  addi r30, r30, 0x60
	ctx.r[30].s64 = ctx.r[30].s64 + 96;
	// 82EB6234: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6238: 4198FFA8  blt cr6, 0x82eb61e0
	if ctx.cr[6].lt {
	pc = 0x82EB61E0; continue 'dispatch;
	}
	pc = 0x82EB623C; continue 'dispatch;
            }
            0x82EB623C => {
    //   block [0x82EB623C..0x82EB6278)
	// 82EB623C: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6240: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6244: 812B01B4  lwz r9, 0x1b4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB6248: 810B019C  lwz r8, 0x19c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB624C: 93EB01A4  stw r31, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[31].u32 ) };
	// 82EB6250: 93EB01A8  stw r31, 0x1a8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(424 as u32), ctx.r[31].u32 ) };
	// 82EB6254: 93EB0190  stw r31, 0x190(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(400 as u32), ctx.r[31].u32 ) };
	// 82EB6258: 93EB0194  stw r31, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[31].u32 ) };
	// 82EB625C: 910B0198  stw r8, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[8].u32 ) };
	// 82EB6260: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB6264: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB6268: 912B01B8  stw r9, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[9].u32 ) };
	// 82EB626C: 912B01BC  stw r9, 0x1bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(444 as u32), ctx.r[9].u32 ) };
	// 82EB6270: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB6274: 4BDF31E4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EB6278 size=152
    let mut pc: u32 = 0x82EB6278;
    'dispatch: loop {
        match pc {
            0x82EB6278 => {
    //   block [0x82EB6278..0x82EB62D4)
	// 82EB6278: 8163019C  lwz r11, 0x19c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB627C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB6280: 38EB0014  addi r7, r11, 0x14
	ctx.r[7].s64 = ctx.r[11].s64 + 20;
	// 82EB6284: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6288: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB628C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6290: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB6294: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82EB6298: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB629C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EB62A0: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62A4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB62A8: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB62B0: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB62B4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB62B8: A0CA0010  lhz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB62BC: B0CB0010  sth r6, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u16 ) };
	// 82EB62C0: A14A0012  lhz r10, 0x12(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62C4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB62C8: B14B0012  sth r10, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82EB62CC: 41820024  beq 0x82eb62f0
	if ctx.cr[0].eq {
	pc = 0x82EB62F0; continue 'dispatch;
	}
	// 82EB62D0: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	pc = 0x82EB62D4; continue 'dispatch;
            }
            0x82EB62D4 => {
    //   block [0x82EB62D4..0x82EB62F0)
	// 82EB62D4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB62D8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB62DC: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82EB62E0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB62E4: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62E8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB62EC: 4198FFE8  blt cr6, 0x82eb62d4
	if ctx.cr[6].lt {
	pc = 0x82EB62D4; continue 'dispatch;
	}
	pc = 0x82EB62F0; continue 'dispatch;
            }
            0x82EB62F0 => {
    //   block [0x82EB62F0..0x82EB6310)
	// 82EB62F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB62F4: 914301A8  stw r10, 0x1a8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82EB62F8: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB62FC: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB6300: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6304: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB6308: 91630198  stw r11, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB630C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB6310 size=140
    let mut pc: u32 = 0x82EB6310;
    'dispatch: loop {
        match pc {
            0x82EB6310 => {
    //   block [0x82EB6310..0x82EB6328)
	// 82EB6310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB6318: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB631C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB6320: 90A301AC  stw r5, 0x1ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), ctx.r[5].u32 ) };
	// 82EB6324: 48000050  b 0x82eb6374
	pc = 0x82EB6374; continue 'dispatch;
            }
            0x82EB6328 => {
    //   block [0x82EB6328..0x82EB6374)
	// 82EB6328: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB632C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB6330: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82EB6334: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6338: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB633C: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6340: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB6344: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB6348: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB634C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6350: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EB6354: 409A0038  bne cr6, 0x82eb638c
	if !ctx.cr[6].eq {
	pc = 0x82EB638C; continue 'dispatch;
	}
	// 82EB6358: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB635C: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB6360: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82EB6364: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EB6368: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB636C: 91630194  stw r11, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB6370: 91430198  stw r10, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[10].u32 ) };
	pc = 0x82EB6374; continue 'dispatch;
            }
            0x82EB6374 => {
    //   block [0x82EB6374..0x82EB638C)
	// 82EB6374: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB6378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB637C: 4098FFAC  bge cr6, 0x82eb6328
	if !ctx.cr[6].lt {
	pc = 0x82EB6328; continue 'dispatch;
	}
	// 82EB6380: 4BFFFEF9  bl 0x82eb6278
	ctx.lr = 0x82EB6384;
	sub_82EB6278(ctx, base);
	// 82EB6384: 90A301A4  stw r5, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[5].u32 ) };
	// 82EB6388: 90A30194  stw r5, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[5].u32 ) };
	pc = 0x82EB638C; continue 'dispatch;
            }
            0x82EB638C => {
    //   block [0x82EB638C..0x82EB639C)
	// 82EB638C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB6390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB6394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB6398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB63A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB63A0 size=344
    let mut pc: u32 = 0x82EB63A0;
    'dispatch: loop {
        match pc {
            0x82EB63A0 => {
    //   block [0x82EB63A0..0x82EB6424)
	// 82EB63A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB63A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB63A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB63AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB63B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB63B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB63B8: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB63BC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB63C0: 419A0120  beq cr6, 0x82eb64e0
	if ctx.cr[6].eq {
	pc = 0x82EB64E0; continue 'dispatch;
	}
	// 82EB63C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB63C8: 409A005C  bne cr6, 0x82eb6424
	if !ctx.cr[6].eq {
	pc = 0x82EB6424; continue 'dispatch;
	}
	// 82EB63CC: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB63D0: A1440010  lhz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB63D4: B14B0010  sth r10, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	// 82EB63D8: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB63DC: B14B0012  sth r10, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[10].u16 ) };
	// 82EB63E0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB63E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB63E8: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB63F0: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB63F8: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB63FC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6400: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6404: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6408: 418200B4  beq 0x82eb64bc
	if ctx.cr[0].eq {
	pc = 0x82EB64BC; continue 'dispatch;
	}
	// 82EB640C: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6410: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82EB6414: 38840014  addi r4, r4, 0x14
	ctx.r[4].s64 = ctx.r[4].s64 + 20;
	// 82EB6418: 5545103E  rotlwi r5, r10, 2
	ctx.r[5].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82EB641C: 4BDF3065  bl 0x82ca9480
	ctx.lr = 0x82EB6420;
	sub_82CA9480(ctx, base);
	// 82EB6420: 4800009C  b 0x82eb64bc
	pc = 0x82EB64BC; continue 'dispatch;
            }
            0x82EB6424 => {
    //   block [0x82EB6424..0x82EB6478)
	// 82EB6424: 83DF0198  lwz r30, 0x198(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB6428: A1640010  lhz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB642C: B17E0010  sth r11, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82EB6430: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6434: B17E0012  sth r11, 0x12(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82EB6438: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB643C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6440: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6444: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB6448: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB644C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB6450: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6454: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6458: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB645C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6460: 41820018  beq 0x82eb6478
	if ctx.cr[0].eq {
	pc = 0x82EB6478; continue 'dispatch;
	}
	// 82EB6464: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB6468: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82EB646C: 38840014  addi r4, r4, 0x14
	ctx.r[4].s64 = ctx.r[4].s64 + 20;
	// 82EB6470: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82EB6474: 4BDF300D  bl 0x82ca9480
	ctx.lr = 0x82EB6478;
	sub_82CA9480(ctx, base);
	pc = 0x82EB6478; continue 'dispatch;
            }
            0x82EB6478 => {
    //   block [0x82EB6478..0x82EB64BC)
	// 82EB6478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB647C: 815F019C  lwz r10, 0x19c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB6480: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB6484: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB6488: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EB648C: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB6490: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB6494: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB6498: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EB649C: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB64A0: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB64A4: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EB64A8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82EB64AC: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB64B0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB64B4: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 82EB64B8: 913F0190  stw r9, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[9].u32 ) };
	pc = 0x82EB64BC; continue 'dispatch;
            }
            0x82EB64BC => {
    //   block [0x82EB64BC..0x82EB64E0)
	// 82EB64BC: 815F01A8  lwz r10, 0x1a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB64C0: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB64C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB64C8: 915F01A8  stw r10, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82EB64CC: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB64D0: 394A0005  addi r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 + 5;
	// 82EB64D4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB64D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB64DC: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB64E0; continue 'dispatch;
            }
            0x82EB64E0 => {
    //   block [0x82EB64E0..0x82EB64F8)
	// 82EB64E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB64E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB64E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB64EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB64F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB64F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB64F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB64F8 size=172
    let mut pc: u32 = 0x82EB64F8;
    'dispatch: loop {
        match pc {
            0x82EB64F8 => {
    //   block [0x82EB64F8..0x82EB65A4)
	// 82EB64F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB64FC: 4BDF2F11  bl 0x82ca940c
	ctx.lr = 0x82EB6500;
	sub_82CA93D0(ctx, base);
	// 82EB6500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6504: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6508: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EB650C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB6510: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EB6514: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EB6518: 4B760411  bl 0x82616928
	ctx.lr = 0x82EB651C;
	sub_82616928(ctx, base);
	// 82EB651C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB6520: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6524: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB6528: 4BDF3489  bl 0x82ca99b0
	ctx.lr = 0x82EB652C;
	sub_82CA99B0(ctx, base);
	// 82EB652C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6530: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82EB6534: 4B7603F5  bl 0x82616928
	ctx.lr = 0x82EB6538;
	sub_82616928(ctx, base);
	// 82EB6538: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB653C: 80BF01A0  lwz r5, 0x1a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB6540: 907F019C  stw r3, 0x19c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[3].u32 ) };
	// 82EB6544: 4BDF346D  bl 0x82ca99b0
	ctx.lr = 0x82EB6548;
	sub_82CA99B0(ctx, base);
	// 82EB6548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB654C: 93BF01C0  stw r29, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[29].u32 ) };
	// 82EB6550: 4B7603D9  bl 0x82616928
	ctx.lr = 0x82EB6554;
	sub_82616928(ctx, base);
	// 82EB6554: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EB6558: 80BF01C0  lwz r5, 0x1c0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB655C: 907F01B4  stw r3, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[3].u32 ) };
	// 82EB6560: 4BDF3451  bl 0x82ca99b0
	ctx.lr = 0x82EB6564;
	sub_82CA99B0(ctx, base);
	// 82EB6564: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB656C: 813F01B4  lwz r9, 0x1b4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82EB6570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6574: 811F019C  lwz r8, 0x19c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB6578: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82EB657C: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82EB6580: 911F0198  stw r8, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[8].u32 ) };
	// 82EB6584: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82EB6588: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82EB658C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB6590: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB6594: 913F01B8  stw r9, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[9].u32 ) };
	// 82EB6598: 913F01BC  stw r9, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[9].u32 ) };
	// 82EB659C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB65A0: 4BDF2EBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB65A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB65A8 size=2420
    let mut pc: u32 = 0x82EB65A8;
    'dispatch: loop {
        match pc {
            0x82EB65A8 => {
    //   block [0x82EB65A8..0x82EB673C)
	// 82EB65A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB65AC: 4BDF2E25  bl 0x82ca93d0
	ctx.lr = 0x82EB65B0;
	sub_82CA93D0(ctx, base);
	// 82EB65B0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB65B4: 4BDF7725  bl 0x82cadcd8
	ctx.lr = 0x82EB65B8;
	sub_82CADCA0(ctx, base);
	// 82EB65B8: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB65BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB65C0: 90E10314  stw r7, 0x314(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(788 as u32), ctx.r[7].u32 ) };
	// 82EB65C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB65C8: 9101031C  stw r8, 0x31c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(796 as u32), ctx.r[8].u32 ) };
	// 82EB65CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB65D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EB65D4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EB65D8: 4801D2D1  bl 0x82ed38a8
	ctx.lr = 0x82EB65DC;
	sub_82ED38A8(ctx, base);
	// 82EB65DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB65E0: 40820874  bne 0x82eb6e54
	if !ctx.cr[0].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB65E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB65E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB65EC: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82EB65F0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB65F4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB65F8: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB65FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6600: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82EB6604: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB6608: 93BF0078  stw r29, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EB660C: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6610: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6614: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6618: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB661C: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6620: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6624: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6628: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB662C: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6630: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6634: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82EB6638: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB663C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6640: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6644: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6648: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB664C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6650: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6654: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6658: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB665C: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6660: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6664: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6668: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB666C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6670: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB6674: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB6678: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB667C: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB6680: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB6684: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6688: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82EB668C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6690: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB6694: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB6698: C1580008  lfs f10, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB669C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB66A0: C138000C  lfs f9, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB66A4: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB66A8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66AC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB66B0: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66B4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66B8: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB66BC: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB66C0: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB66C4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB66C8: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB66CC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66D0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB66D4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66D8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66DC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB66E0: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB66E4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB66E8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB66EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB66F0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB66F4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB66F8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB66FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB6700: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EB6704: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6708: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB670C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EB6710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB6714: 3A6B9128  addi r19, r11, -0x6ed8
	ctx.r[19].s64 = ctx.r[11].s64 + -28376;
	// 82EB6718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB671C: 3B2B9128  addi r25, r11, -0x6ed8
	ctx.r[25].s64 = ctx.r[11].s64 + -28376;
	// 82EB6720: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB6724: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EB6728: C38A0BEC  lfs f28, 0xbec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EB672C: 3A4B9F1C  addi r18, r11, -0x60e4
	ctx.r[18].s64 = ctx.r[11].s64 + -24804;
	// 82EB6730: C3A90C98  lfs f29, 0xc98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB6734: 3DC08330  lis r14, -0x7cd0
	ctx.r[14].s64 = -2094006272;
	// 82EB6738: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	pc = 0x82EB673C; continue 'dispatch;
            }
            0x82EB673C => {
    //   block [0x82EB673C..0x82EB6778)
	// 82EB673C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6740: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6744: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB6748: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82EB674C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6750: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6754: 816A9E58  lwz r11, -0x61a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25000 as u32) ) } as u64;
	// 82EB6758: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 82EB675C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6760: 916A9E58  stw r11, -0x61a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25000 as u32), ctx.r[11].u32 ) };
	// 82EB6764: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB6768: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB676C: 40990044  ble cr6, 0x82eb67b0
	if !ctx.cr[6].gt {
	pc = 0x82EB67B0; continue 'dispatch;
	}
	// 82EB6770: 5527003E  slwi r7, r9, 0
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB6774: 813A9E40  lwz r9, -0x61c0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	pc = 0x82EB6778; continue 'dispatch;
            }
            0x82EB6778 => {
    //   block [0x82EB6778..0x82EB67A0)
	// 82EB6778: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB677C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB6780: 419A0020  beq cr6, 0x82eb67a0
	if ctx.cr[6].eq {
	pc = 0x82EB67A0; continue 'dispatch;
	}
	// 82EB6784: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EB6788: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB678C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB6790: 40980010  bge cr6, 0x82eb67a0
	if !ctx.cr[6].lt {
	pc = 0x82EB67A0; continue 'dispatch;
	}
	// 82EB6794: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EB6798: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB679C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82EB67A0; continue 'dispatch;
            }
            0x82EB67A0 => {
    //   block [0x82EB67A0..0x82EB67B0)
	// 82EB67A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB67A4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB67A8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB67AC: 4198FFCC  blt cr6, 0x82eb6778
	if ctx.cr[6].lt {
	pc = 0x82EB6778; continue 'dispatch;
	}
	pc = 0x82EB67B0; continue 'dispatch;
            }
            0x82EB67B0 => {
    //   block [0x82EB67B0..0x82EB6830)
	// 82EB67B0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB67B4: 418206A0  beq 0x82eb6e54
	if ctx.cr[0].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB67B8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB67BC: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB67C0: 7EAB502E  lwzx r21, r11, r10
	ctx.r[21].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB67C4: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82EB67C8: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB67CC: 7E0B5214  add r16, r11, r10
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB67D0: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67D4: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB67D8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB67DC: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB67E0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB67E4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67E8: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB67F0: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82EB67F4: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB67F8: 41820670  beq 0x82eb6e68
	if ctx.cr[0].eq {
	pc = 0x82EB6E68; continue 'dispatch;
	}
	// 82EB67FC: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EB6800: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EB6804: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 82EB6808: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82EB680C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82EB6810: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EB6814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6818: 4801DA29  bl 0x82ed4240
	ctx.lr = 0x82EB681C;
	sub_82ED4240(ctx, base);
	// 82EB681C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6820: 7FAFEB78  mr r15, r29
	ctx.r[15].u64 = ctx.r[29].u64;
	// 82EB6824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6828: 419A05AC  beq cr6, 0x82eb6dd4
	if ctx.cr[6].eq {
	pc = 0x82EB6DD4; continue 'dispatch;
	}
	// 82EB682C: 7FB1EB78  mr r17, r29
	ctx.r[17].u64 = ctx.r[29].u64;
	pc = 0x82EB6830; continue 'dispatch;
            }
            0x82EB6830 => {
    //   block [0x82EB6830..0x82EB6908)
	// 82EB6830: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB6834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB6838: 7EF1582E  lwzx r23, r17, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB683C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB6840: 7ED1582E  lwzx r22, r17, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB6844: D3C10088  stfs f30, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB6848: 8161031C  lwz r11, 0x31c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB684C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EB6850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6854: 92DE000C  stw r22, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82EB6858: 409A0188  bne cr6, 0x82eb69e0
	if !ctx.cr[6].eq {
	pc = 0x82EB69E0; continue 'dispatch;
	}
	// 82EB685C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6860: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82EB6864: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6868: 41820178  beq 0x82eb69e0
	if ctx.cr[0].eq {
	pc = 0x82EB69E0; continue 'dispatch;
	}
	// 82EB686C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6870: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB6874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6878: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB687C: 4801E095  bl 0x82ed4910
	ctx.lr = 0x82EB6880;
	sub_82ED4910(ctx, base);
	// 82EB6880: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6884: 41820538  beq 0x82eb6dbc
	if ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB688C: 4801DF05  bl 0x82ed4790
	ctx.lr = 0x82EB6890;
	sub_82ED4790(ctx, base);
	// 82EB6890: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EB6894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6898: 4BFE39B1  bl 0x82e9a248
	ctx.lr = 0x82EB689C;
	sub_82E9A248(ctx, base);
	// 82EB689C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB68A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB68A4: 4BFE3A25  bl 0x82e9a2c8
	ctx.lr = 0x82EB68A8;
	sub_82E9A2C8(ctx, base);
	// 82EB68A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB68AC: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 82EB68B0: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EB68B4: 9281005C  stw r20, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[20].u32 ) };
	// 82EB68B8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB68BC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB68C0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB68C4: 92410080  stw r18, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[18].u32 ) };
	// 82EB68C8: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 82EB68CC: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB68D0: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB68D4: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB68D8: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82EB68DC: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB68E0: 926100A0  stw r19, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[19].u32 ) };
	// 82EB68E4: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB68E8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82EB68EC: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB68F0: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EB68F4: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB68F8: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EB68FC: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6900: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EB6904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EB6908; continue 'dispatch;
            }
            0x82EB6908 => {
    //   block [0x82EB6908..0x82EB6950)
	// 82EB6908: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB690C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6910: 4200FFF8  bdnz 0x82eb6908
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6908; continue 'dispatch;
	}
	// 82EB6914: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB6918: 9BA100F8  stb r29, 0xf8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[29].u8 ) };
	// 82EB691C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EB6920: 4B2F7D89  bl 0x821ae6a8
	ctx.lr = 0x82EB6924;
	sub_821AE6A8(ctx, base);
	// 82EB6924: 92610160  stw r19, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[19].u32 ) };
	// 82EB6928: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB692C: 39410170  addi r10, r1, 0x170
	ctx.r[10].s64 = ctx.r[1].s64 + 368;
	// 82EB6930: D0010164  stfs f0, 0x164(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82EB6934: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB6938: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB693C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB6940: D0010168  stfs f0, 0x168(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 82EB6944: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6948: D001016C  stfs f0, 0x16c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82EB694C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EB6950; continue 'dispatch;
            }
            0x82EB6950 => {
    //   block [0x82EB6950..0x82EB69C8)
	// 82EB6950: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB6954: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6958: 4200FFF8  bdnz 0x82eb6950
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6950; continue 'dispatch;
	}
	// 82EB695C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EB6960: 9BA101B8  stb r29, 0x1b8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[29].u8 ) };
	// 82EB6964: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82EB6968: 4B2F7D41  bl 0x821ae6a8
	ctx.lr = 0x82EB696C;
	sub_821AE6A8(ctx, base);
	// 82EB696C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6970: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6974: 39010088  addi r8, r1, 0x88
	ctx.r[8].s64 = ctx.r[1].s64 + 136;
	// 82EB6978: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB697C: 38C10160  addi r6, r1, 0x160
	ctx.r[6].s64 = ctx.r[1].s64 + 352;
	// 82EB6980: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82EB6984: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EB6988: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB698C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6994: 4E800421  bctrl
	ctx.lr = 0x82EB6998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6998: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB699C: 4082002C  bne 0x82eb69c8
	if !ctx.cr[0].eq {
	pc = 0x82EB69C8; continue 'dispatch;
	}
	// 82EB69A0: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82EB69A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB69A8: 41820020  beq 0x82eb69c8
	if ctx.cr[0].eq {
	pc = 0x82EB69C8; continue 'dispatch;
	}
	// 82EB69AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB69B0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82EB69B4: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82EB69B8: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB69BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB69C0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB69C4: 480003F8  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
            }
            0x82EB69C8 => {
    //   block [0x82EB69C8..0x82EB69E0)
	// 82EB69C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB69CC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82EB69D0: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82EB69D4: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EB69D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB69DC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB69E0; continue 'dispatch;
            }
            0x82EB69E0 => {
    //   block [0x82EB69E0..0x82EB69F8)
	// 82EB69E0: C3F50014  lfs f31, 0x14(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB69E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB69E8: 41820010  beq 0x82eb69f8
	if ctx.cr[0].eq {
	pc = 0x82EB69F8; continue 'dispatch;
	}
	// 82EB69EC: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB69F0: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB69F4: 48000188  b 0x82eb6b7c
	pc = 0x82EB6B7C; continue 'dispatch;
            }
            0x82EB69F8 => {
    //   block [0x82EB69F8..0x82EB6A6C)
	// 82EB69F8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB69FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6A00: 419A015C  beq cr6, 0x82eb6b5c
	if ctx.cr[6].eq {
	pc = 0x82EB6B5C; continue 'dispatch;
	}
	// 82EB6A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A08: D3C10078  stfs f30, 0x78(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EB6A0C: 4BFE383D  bl 0x82e9a248
	ctx.lr = 0x82EB6A10;
	sub_82E9A248(ctx, base);
	// 82EB6A10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB6A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A18: 4BFE38B1  bl 0x82e9a2c8
	ctx.lr = 0x82EB6A1C;
	sub_82E9A2C8(ctx, base);
	// 82EB6A1C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB6A20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A24: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB6A28: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 82EB6A2C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6A30: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 82EB6A34: 4801CDFD  bl 0x82ed3830
	ctx.lr = 0x82EB6A38;
	sub_82ED3830(ctx, base);
	// 82EB6A38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6A3C: 392101D0  addi r9, r1, 0x1d0
	ctx.r[9].s64 = ctx.r[1].s64 + 464;
	// 82EB6A40: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EB6A44: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6A48: 926101C0  stw r19, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[19].u32 ) };
	// 82EB6A4C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB6A50: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A54: D00101C4  stfs f0, 0x1c4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82EB6A58: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A5C: D00101C8  stfs f0, 0x1c8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82EB6A60: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6A64: D00101CC  stfs f0, 0x1cc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 82EB6A68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EB6A6C; continue 'dispatch;
            }
            0x82EB6A6C => {
    //   block [0x82EB6A6C..0x82EB6AD4)
	// 82EB6A6C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB6A70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6A74: 4200FFF8  bdnz 0x82eb6a6c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6A6C; continue 'dispatch;
	}
	// 82EB6A78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB6A7C: 9BA10218  stb r29, 0x218(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[29].u8 ) };
	// 82EB6A80: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82EB6A84: 4B2F7C25  bl 0x821ae6a8
	ctx.lr = 0x82EB6A88;
	sub_821AE6A8(ctx, base);
	// 82EB6A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6A8C: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 82EB6A90: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB6A94: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 82EB6A98: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6A9C: 4801CD95  bl 0x82ed3830
	ctx.lr = 0x82EB6AA0;
	sub_82ED3830(ctx, base);
	// 82EB6AA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6AA4: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 82EB6AA8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EB6AAC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6AB0: 92610100  stw r19, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[19].u32 ) };
	// 82EB6AB4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB6AB8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6ABC: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EB6AC0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6AC4: D0010108  stfs f0, 0x108(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EB6AC8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6ACC: D001010C  stfs f0, 0x10c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EB6AD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EB6AD4; continue 'dispatch;
            }
            0x82EB6AD4 => {
    //   block [0x82EB6AD4..0x82EB6B40)
	// 82EB6AD4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB6AD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6ADC: 4200FFF8  bdnz 0x82eb6ad4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB6AD4; continue 'dispatch;
	}
	// 82EB6AE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB6AE4: 9BA10158  stb r29, 0x158(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[29].u8 ) };
	// 82EB6AE8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82EB6AEC: 4B2F7BBD  bl 0x821ae6a8
	ctx.lr = 0x82EB6AF0;
	sub_821AE6A8(ctx, base);
	// 82EB6AF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6AF4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6AF8: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 82EB6AFC: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 82EB6B00: 38A101C0  addi r5, r1, 0x1c0
	ctx.r[5].s64 = ctx.r[1].s64 + 448;
	// 82EB6B04: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB6B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB6B14: 4E800421  bctrl
	ctx.lr = 0x82EB6B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB6B18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6B1C: 40820024  bne 0x82eb6b40
	if !ctx.cr[0].eq {
	pc = 0x82EB6B40; continue 'dispatch;
	}
	// 82EB6B20: 897F007F  lbz r11, 0x7f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(127 as u32) ) } as u64;
	// 82EB6B24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6B28: 41820018  beq 0x82eb6b40
	if ctx.cr[0].eq {
	pc = 0x82EB6B40; continue 'dispatch;
	}
	// 82EB6B2C: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82EB6B30: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82EB6B34: 932101C0  stw r25, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[25].u32 ) };
	// 82EB6B38: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82EB6B3C: 48000280  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
            }
            0x82EB6B40 => {
    //   block [0x82EB6B40..0x82EB6B5C)
	// 82EB6B40: C0010078  lfs f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6B44: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 82EB6B48: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB6B4C: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82EB6B50: 932101C0  stw r25, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[25].u32 ) };
	// 82EB6B54: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82EB6B58: 48000024  b 0x82eb6b7c
	pc = 0x82EB6B7C; continue 'dispatch;
            }
            0x82EB6B5C => {
    //   block [0x82EB6B5C..0x82EB6B7C)
	// 82EB6B5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B60: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EB6B64: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB6B68: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 82EB6B6C: C8010098  lfd f0, 0x98(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EB6B70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EB6B74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EB6B78: EFE0FF7A  fmadds f31, f0, f29, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64);
	pc = 0x82EB6B7C; continue 'dispatch;
            }
            0x82EB6B7C => {
    //   block [0x82EB6B7C..0x82EB6BB8)
	// 82EB6B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6B80: 4BFE37C9  bl 0x82e9a348
	ctx.lr = 0x82EB6B84;
	sub_82E9A348(ctx, base);
	// 82EB6B84: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6B88: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6B8C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB6B90: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6B94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB6B98: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6B9C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB6BA0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6BA8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BAC: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6BB0: 40990060  ble cr6, 0x82eb6c10
	if !ctx.cr[6].gt {
	pc = 0x82EB6C10; continue 'dispatch;
	}
	// 82EB6BB4: 817A9E40  lwz r11, -0x61c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	pc = 0x82EB6BB8; continue 'dispatch;
            }
            0x82EB6BB8 => {
    //   block [0x82EB6BB8..0x82EB6BFC)
	// 82EB6BB8: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB6BBC: 40820054  bne 0x82eb6c10
	if !ctx.cr[0].eq {
	pc = 0x82EB6C10; continue 'dispatch;
	}
	// 82EB6BC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6BC8: 419A0034  beq cr6, 0x82eb6bfc
	if ctx.cr[6].eq {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BCC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6BD0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BD4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BD8: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6BDC: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB6BE0: 409A001C  bne cr6, 0x82eb6bfc
	if !ctx.cr[6].eq {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6BE8: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EB6BEC: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6BF0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB6BF4: 41990008  bgt cr6, 0x82eb6bfc
	if ctx.cr[6].gt {
	pc = 0x82EB6BFC; continue 'dispatch;
	}
	// 82EB6BF8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x82EB6BFC; continue 'dispatch;
            }
            0x82EB6BFC => {
    //   block [0x82EB6BFC..0x82EB6C10)
	// 82EB6BFC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6C00: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB6C04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB6C08: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6C0C: 4198FFAC  blt cr6, 0x82eb6bb8
	if ctx.cr[6].lt {
	pc = 0x82EB6BB8; continue 'dispatch;
	}
	pc = 0x82EB6C10; continue 'dispatch;
            }
            0x82EB6C10 => {
    //   block [0x82EB6C10..0x82EB6C34)
	// 82EB6C10: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6C14: 408201A8  bne 0x82eb6dbc
	if !ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6C18: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6C1C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB6C20: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB6C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6C28: 40990060  ble cr6, 0x82eb6c88
	if !ctx.cr[6].gt {
	pc = 0x82EB6C88; continue 'dispatch;
	}
	// 82EB6C2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6C30: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	pc = 0x82EB6C34; continue 'dispatch;
            }
            0x82EB6C34 => {
    //   block [0x82EB6C34..0x82EB6C74)
	// 82EB6C34: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB6C38: 40820050  bne 0x82eb6c88
	if !ctx.cr[0].eq {
	pc = 0x82EB6C88; continue 'dispatch;
	}
	// 82EB6C3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6C44: 419A0030  beq cr6, 0x82eb6c74
	if ctx.cr[6].eq {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C48: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6C4C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C50: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6C54: 5463007E  clrlwi r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB6C58: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB6C5C: 409A0018  bne cr6, 0x82eb6c74
	if !ctx.cr[6].eq {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C60: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6C64: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EB6C68: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB6C6C: 41990008  bgt cr6, 0x82eb6c74
	if ctx.cr[6].gt {
	pc = 0x82EB6C74; continue 'dispatch;
	}
	// 82EB6C70: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x82EB6C74; continue 'dispatch;
            }
            0x82EB6C74 => {
    //   block [0x82EB6C74..0x82EB6C88)
	// 82EB6C74: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6C78: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB6C7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB6C80: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6C84: 4198FFB0  blt cr6, 0x82eb6c34
	if ctx.cr[6].lt {
	pc = 0x82EB6C34; continue 'dispatch;
	}
	pc = 0x82EB6C88; continue 'dispatch;
            }
            0x82EB6C88 => {
    //   block [0x82EB6C88..0x82EB6D2C)
	// 82EB6C88: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6C8C: 40820130  bne 0x82eb6dbc
	if !ctx.cr[0].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6C90: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB6C94: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB6C98: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82EB6C9C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6CA0: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6CA4: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB6CA8: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EB6CAC: 810EDF34  lwz r8, -0x20cc(r14)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6CB0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6CB4: 419A01A0  beq cr6, 0x82eb6e54
	if ctx.cr[6].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	// 82EB6CB8: D3EB0014  stfs f31, 0x14(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB6CBC: 92AB0018  stw r21, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[21].u32 ) };
	// 82EB6CC0: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EB6CC4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EB6CC8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EB6CCC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6CD0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB6CD4: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB6CD8: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB6CDC: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82EB6CE0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB6CE4: C1780004  lfs f11, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB6CE8: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB6CEC: C1580008  lfs f10, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB6CF0: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB6CF4: C138000C  lfs f9, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB6CF8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB6CFC: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB6D00: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB6D04: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EB6D08: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB6D0C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB6D10: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB6D14: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB6D18: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB6D1C: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB6D20: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB6D24: 419A0008  beq cr6, 0x82eb6d2c
	if ctx.cr[6].eq {
	pc = 0x82EB6D2C; continue 'dispatch;
	}
	// 82EB6D28: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82EB6D2C; continue 'dispatch;
            }
            0x82EB6D2C => {
    //   block [0x82EB6D2C..0x82EB6D48)
	// 82EB6D2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D30: 409A008C  bne cr6, 0x82eb6dbc
	if !ctx.cr[6].eq {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6D34: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D38: 419A0010  beq cr6, 0x82eb6d48
	if ctx.cr[6].eq {
	pc = 0x82EB6D48; continue 'dispatch;
	}
	// 82EB6D3C: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6D40: 7FB0EB78  mr r16, r29
	ctx.r[16].u64 = ctx.r[29].u64;
	// 82EB6D44: 48000078  b 0x82eb6dbc
	pc = 0x82EB6DBC; continue 'dispatch;
            }
            0x82EB6D48 => {
    //   block [0x82EB6D48..0x82EB6D5C)
	// 82EB6D48: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D4C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB6D50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D54: 40990038  ble cr6, 0x82eb6d8c
	if !ctx.cr[6].gt {
	pc = 0x82EB6D8C; continue 'dispatch;
	}
	// 82EB6D58: 813A9E40  lwz r9, -0x61c0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	pc = 0x82EB6D5C; continue 'dispatch;
            }
            0x82EB6D5C => {
    //   block [0x82EB6D5C..0x82EB6D80)
	// 82EB6D5C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6D60: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EB6D64: 419A001C  beq cr6, 0x82eb6d80
	if ctx.cr[6].eq {
	pc = 0x82EB6D80; continue 'dispatch;
	}
	// 82EB6D68: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB6D70: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB6D74: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB6D78: 4198FFE4  blt cr6, 0x82eb6d5c
	if ctx.cr[6].lt {
	pc = 0x82EB6D5C; continue 'dispatch;
	}
	// 82EB6D7C: 48000010  b 0x82eb6d8c
	pc = 0x82EB6D8C; continue 'dispatch;
            }
            0x82EB6D80 => {
    //   block [0x82EB6D80..0x82EB6D8C)
	// 82EB6D80: 811A9E40  lwz r8, -0x61c0(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6D84: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB6D88: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	pc = 0x82EB6D8C; continue 'dispatch;
            }
            0x82EB6D8C => {
    //   block [0x82EB6D8C..0x82EB6DBC)
	// 82EB6D8C: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6D90: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6D94: 41980028  blt cr6, 0x82eb6dbc
	if ctx.cr[6].lt {
	pc = 0x82EB6DBC; continue 'dispatch;
	}
	// 82EB6D98: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB6D9C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EB6DA0: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82EB6DA4: 815A9E40  lwz r10, -0x61c0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB6DA8: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EB6DAC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB6DB0: 816EDF34  lwz r11, -0x20cc(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6DB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6DB8: 419A009C  beq cr6, 0x82eb6e54
	if ctx.cr[6].eq {
	pc = 0x82EB6E54; continue 'dispatch;
	}
	pc = 0x82EB6DBC; continue 'dispatch;
            }
            0x82EB6DBC => {
    //   block [0x82EB6DBC..0x82EB6DD4)
	// 82EB6DBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6DC0: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EB6DC4: 3A310004  addi r17, r17, 4
	ctx.r[17].s64 = ctx.r[17].s64 + 4;
	// 82EB6DC8: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6DCC: 4198FA64  blt cr6, 0x82eb6830
	if ctx.cr[6].lt {
	pc = 0x82EB6830; continue 'dispatch;
	}
	// 82EB6DD0: 83610090  lwz r27, 0x90(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	pc = 0x82EB6DD4; continue 'dispatch;
            }
            0x82EB6DD4 => {
    //   block [0x82EB6DD4..0x82EB6DEC)
	// 82EB6DD4: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6DD8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB6DDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB6DE0: 40990040  ble cr6, 0x82eb6e20
	if !ctx.cr[6].gt {
	pc = 0x82EB6E20; continue 'dispatch;
	}
	// 82EB6DE4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6DE8: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	pc = 0x82EB6DEC; continue 'dispatch;
            }
            0x82EB6DEC => {
    //   block [0x82EB6DEC..0x82EB6E10)
	// 82EB6DEC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB6DF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB6DF4: 419A001C  beq cr6, 0x82eb6e10
	if ctx.cr[6].eq {
	pc = 0x82EB6E10; continue 'dispatch;
	}
	// 82EB6DF8: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6DFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6E00: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB6E04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6E08: 4198FFE4  blt cr6, 0x82eb6dec
	if ctx.cr[6].lt {
	pc = 0x82EB6DEC; continue 'dispatch;
	}
	// 82EB6E0C: 48000014  b 0x82eb6e20
	pc = 0x82EB6E20; continue 'dispatch;
            }
            0x82EB6E10 => {
    //   block [0x82EB6E10..0x82EB6E20)
	// 82EB6E10: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6E14: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB6E18: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6E1C: 7EA9512E  stwx r21, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[21].u32) };
	pc = 0x82EB6E20; continue 'dispatch;
            }
            0x82EB6E20 => {
    //   block [0x82EB6E20..0x82EB6E54)
	// 82EB6E20: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6E24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6E28: 4198F914  blt cr6, 0x82eb673c
	if ctx.cr[6].lt {
	pc = 0x82EB673C; continue 'dispatch;
	}
	// 82EB6E2C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB6E30: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6E34: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB6E38: 7EAA592E  stwx r21, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[21].u32) };
	// 82EB6E3C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB6E40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB6E44: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB6E48: 814EDF34  lwz r10, -0x20cc(r14)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB6E4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6E50: 409AF8EC  bne cr6, 0x82eb673c
	if !ctx.cr[6].eq {
	pc = 0x82EB673C; continue 'dispatch;
	}
	pc = 0x82EB6E54; continue 'dispatch;
            }
            0x82EB6E54 => {
    //   block [0x82EB6E54..0x82EB6E58)
	// 82EB6E54: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EB6E58; continue 'dispatch;
            }
            0x82EB6E58 => {
    //   block [0x82EB6E58..0x82EB6E68)
	// 82EB6E58: 382102E0  addi r1, r1, 0x2e0
	ctx.r[1].s64 = ctx.r[1].s64 + 736;
	// 82EB6E5C: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB6E60: 4BDF6EC5  bl 0x82cadd24
	ctx.lr = 0x82EB6E64;
	sub_82CADCEC(ctx, base);
	// 82EB6E64: 4BDF25BC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EB6E68 => {
    //   block [0x82EB6E68..0x82EB6E70)
	// 82EB6E68: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB6E6C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	pc = 0x82EB6E70; continue 'dispatch;
            }
            0x82EB6E70 => {
    //   block [0x82EB6E70..0x82EB6E98)
	// 82EB6E70: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB6E78: 419A0020  beq cr6, 0x82eb6e98
	if ctx.cr[6].eq {
	pc = 0x82EB6E98; continue 'dispatch;
	}
	// 82EB6E7C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB6E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6E84: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EB6E88: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB6E8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6E90: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6E94: 4801D9B5  bl 0x82ed4848
	ctx.lr = 0x82EB6E98;
	sub_82ED4848(ctx, base);
	pc = 0x82EB6E98; continue 'dispatch;
            }
            0x82EB6E98 => {
    //   block [0x82EB6E98..0x82EB6EC8)
	// 82EB6E98: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB6E9C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB6EA0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB6EA4: 4082FFCC  bne 0x82eb6e70
	if !ctx.cr[0].eq {
	pc = 0x82EB6E70; continue 'dispatch;
	}
	// 82EB6EA8: 83A10314  lwz r29, 0x314(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(788 as u32) ) } as u64;
	// 82EB6EAC: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82EB6EB0: 409A0018  bne cr6, 0x82eb6ec8
	if !ctx.cr[6].eq {
	pc = 0x82EB6EC8; continue 'dispatch;
	}
	// 82EB6EB4: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82EB6EB8: 80C1031C  lwz r6, 0x31c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB6EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB6EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6EC4: 4BFFF00D  bl 0x82eb5ed0
	ctx.lr = 0x82EB6EC8;
	sub_82EB5ED0(ctx, base);
	pc = 0x82EB6EC8; continue 'dispatch;
            }
            0x82EB6EC8 => {
    //   block [0x82EB6EC8..0x82EB6EEC)
	// 82EB6EC8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82EB6ECC: 409A0048  bne cr6, 0x82eb6f14
	if !ctx.cr[6].eq {
	pc = 0x82EB6F14; continue 'dispatch;
	}
	// 82EB6ED0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB6ED4: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82EB6ED8: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB6EDC: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB6EE0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB6EE4: 4198001C  blt cr6, 0x82eb6f00
	if ctx.cr[6].lt {
	pc = 0x82EB6F00; continue 'dispatch;
	}
	// 82EB6EE8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	pc = 0x82EB6EEC; continue 'dispatch;
            }
            0x82EB6EEC => {
    //   block [0x82EB6EEC..0x82EB6F00)
	// 82EB6EEC: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB6EF0: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB6EF4: 4BFD4DE5  bl 0x82e8bcd8
	ctx.lr = 0x82EB6EF8;
	sub_82E8BCD8(ctx, base);
	// 82EB6EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6EFC: 4BFFFF5C  b 0x82eb6e58
	pc = 0x82EB6E58; continue 'dispatch;
            }
            0x82EB6F00 => {
    //   block [0x82EB6F00..0x82EB6F14)
	// 82EB6F00: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 82EB6F04: 80C1031C  lwz r6, 0x31c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(796 as u32) ) } as u64;
	// 82EB6F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB6F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB6F10: 4BFFEE89  bl 0x82eb5d98
	ctx.lr = 0x82EB6F14;
	sub_82EB5D98(ctx, base);
	pc = 0x82EB6F14; continue 'dispatch;
            }
            0x82EB6F14 => {
    //   block [0x82EB6F14..0x82EB6F1C)
	// 82EB6F14: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82EB6F18: 4BFFFFD4  b 0x82eb6eec
	pc = 0x82EB6EEC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB6F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB6F20 size=3164
    let mut pc: u32 = 0x82EB6F20;
    'dispatch: loop {
        match pc {
            0x82EB6F20 => {
    //   block [0x82EB6F20..0x82EB6F90)
	// 82EB6F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB6F24: 4BDF24AD  bl 0x82ca93d0
	ctx.lr = 0x82EB6F28;
	sub_82CA93D0(ctx, base);
	// 82EB6F28: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB6F2C: 4BDF6D9D  bl 0x82cadcc8
	ctx.lr = 0x82EB6F30;
	sub_82CADCA0(ctx, base);
	// 82EB6F30: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB6F34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB6F38: 90E10354  stw r7, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[7].u32 ) };
	// 82EB6F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB6F40: 9101035C  stw r8, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[8].u32 ) };
	// 82EB6F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB6F48: 91210364  stw r9, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[9].u32 ) };
	// 82EB6F4C: 7CAE2B78  mr r14, r5
	ctx.r[14].u64 = ctx.r[5].u64;
	// 82EB6F50: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82EB6F54: 4801C955  bl 0x82ed38a8
	ctx.lr = 0x82EB6F58;
	sub_82ED38A8(ctx, base);
	// 82EB6F58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB6F5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB6F60: 41820030  beq 0x82eb6f90
	if ctx.cr[0].eq {
	pc = 0x82EB6F90; continue 'dispatch;
	}
	// 82EB6F64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB6F68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB6F70: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB6F74: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F78: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB6F7C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6F80: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB6F84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6F88: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB6F8C: 48000A58  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
            }
            0x82EB6F90 => {
    //   block [0x82EB6F90..0x82EB6FEC)
	// 82EB6F90: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB6F94: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 82EB6F98: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EB6F9C: 3CE08335  lis r7, -0x7ccb
	ctx.r[7].s64 = -2093678592;
	// 82EB6FA0: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 82EB6FA4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB6FA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB6FAC: 816B9E48  lwz r11, -0x61b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25016 as u32) ) } as u64;
	// 82EB6FB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB6FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB6FB8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB6FBC: C3CB0C18  lfs f30, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EB6FC0: 409A002C  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FC4: 81699E4C  lwz r11, -0x61b4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25012 as u32) ) } as u64;
	// 82EB6FC8: 7F0B7040  cmplw cr6, r11, r14
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[14].u32, &mut ctx.xer);
	// 82EB6FCC: 409A0020  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FD0: 81689E50  lwz r11, -0x61b0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25008 as u32) ) } as u64;
	// 82EB6FD4: 7F0BA040  cmplw cr6, r11, r20
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82EB6FD8: 409A0014  bne cr6, 0x82eb6fec
	if !ctx.cr[6].eq {
	pc = 0x82EB6FEC; continue 'dispatch;
	}
	// 82EB6FDC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB6FE0: 81679E54  lwz r11, -0x61ac(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25004 as u32) ) } as u64;
	// 82EB6FE4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB6FE8: 419A0110  beq cr6, 0x82eb70f8
	if ctx.cr[6].eq {
	pc = 0x82EB70F8; continue 'dispatch;
	}
	pc = 0x82EB6FEC; continue 'dispatch;
            }
            0x82EB6FEC => {
    //   block [0x82EB6FEC..0x82EB70F8)
	// 82EB6FEC: 93BF0074  stw r29, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82EB6FF0: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB6FF4: 93BF0078  stw r29, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EB6FF8: 816A9E3C  lwz r11, -0x61c4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB6FFC: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7000: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7004: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB7008: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB700C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7010: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7014: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB7018: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB701C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7020: 91CB0000  stw r14, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[14].u32 ) };
	// 82EB7024: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7028: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB702C: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7030: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7034: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EB7038: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB703C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7040: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7044: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7048: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB704C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7050: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7054: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB7058: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB705C: D3CB0014  stfs f30, 0x14(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB7060: 91DE0004  stw r14, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[14].u32 ) };
	// 82EB7064: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7068: C1AE0004  lfs f13, 4(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB706C: C18E0008  lfs f12, 8(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB7070: C00E000C  lfs f0, 0xc(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7074: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82EB7078: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB707C: C1740004  lfs f11, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB7080: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7084: C1540008  lfs f10, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB7088: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB708C: C134000C  lfs f9, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB7090: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7094: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7098: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB709C: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70A0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70A4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB70A8: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB70AC: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB70B0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB70B4: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB70B8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70BC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB70C0: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70C4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70C8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB70CC: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB70D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB70D4: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB70D8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70DC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB70E0: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB70E4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB70E8: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EB70EC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB70F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB70F4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB70F8; continue 'dispatch;
            }
            0x82EB70F8 => {
    //   block [0x82EB70F8..0x82EB713C)
	// 82EB70F8: 839F0194  lwz r28, 0x194(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB70FC: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82EB7100: 4B3A98B9  bl 0x822609b8
	ctx.lr = 0x82EB7104;
	sub_822609B8(ctx, base);
	// 82EB7104: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB7108: 4BFCA411  bl 0x82e81518
	ctx.lr = 0x82EB710C;
	sub_82E81518(ctx, base);
	// 82EB710C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB7110: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82EB7114: 3AEBDAC0  addi r23, r11, -0x2540
	ctx.r[23].s64 = ctx.r[11].s64 + -9536;
	// 82EB7118: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB711C: 92E100A0  stw r23, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[23].u32 ) };
	// 82EB7120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7124: 419A0018  beq cr6, 0x82eb713c
	if ctx.cr[6].eq {
	pc = 0x82EB713C; continue 'dispatch;
	}
	// 82EB7128: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB712C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7130: 4E800421  bctrl
	ctx.lr = 0x82EB7134;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7134: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82EB7138: 48000008  b 0x82eb7140
	pc = 0x82EB7140; continue 'dispatch;
            }
            0x82EB713C => {
    //   block [0x82EB713C..0x82EB7140)
	// 82EB713C: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	pc = 0x82EB7140; continue 'dispatch;
            }
            0x82EB7140 => {
    //   block [0x82EB7140..0x82EB71BC)
	// 82EB7140: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7144: 815F0444  lwz r10, 0x444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82EB7148: C1BF044C  lfs f13, 0x44c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB714C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82EB7150: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB7154: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB7158: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB715C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7160: F9410098  std r10, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 82EB7164: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7168: C9A10098  lfd f13, 0x98(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EB716C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB7170: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EB7174: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB7178: C3490BFC  lfs f26, 0xbfc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3068 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EB717C: C3080BEC  lfs f24, 0xbec(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3052 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EB7180: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 82EB7184: C3270C98  lfs f25, 0xc98(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3224 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EB7188: C36A0C14  lfs f27, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EB718C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB7190: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7194: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EB7198: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82EB719C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB71A0: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB71A4: 3A4B9128  addi r18, r11, -0x6ed8
	ctx.r[18].s64 = ctx.r[11].s64 + -28376;
	// 82EB71A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB71AC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB71B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB71B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB71B8: 3A2B9F1C  addi r17, r11, -0x60e4
	ctx.r[17].s64 = ctx.r[11].s64 + -24804;
	pc = 0x82EB71BC; continue 'dispatch;
            }
            0x82EB71BC => {
    //   block [0x82EB71BC..0x82EB720C)
	// 82EB71BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB71C0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82EB71C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB71C8: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82EB71CC: 816A9E58  lwz r11, -0x61a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25000 as u32) ) } as u64;
	// 82EB71D0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EB71D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB71D8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EB71DC: 916A9E58  stw r11, -0x61a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25000 as u32), ctx.r[11].u32 ) };
	// 82EB71E0: 409900B4  ble cr6, 0x82eb7294
	if !ctx.cr[6].gt {
	pc = 0x82EB7294; continue 'dispatch;
	}
	// 82EB71E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB71E8: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB71EC: 4BFD4AED  bl 0x82e8bcd8
	ctx.lr = 0x82EB71F0;
	sub_82E8BCD8(ctx, base);
	// 82EB71F0: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB71F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB71F8: 419A0014  beq cr6, 0x82eb720c
	if ctx.cr[6].eq {
	pc = 0x82EB720C; continue 'dispatch;
	}
	// 82EB71FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB7200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7204: 4E800421  bctrl
	ctx.lr = 0x82EB7208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7208: 48000008  b 0x82eb7210
	pc = 0x82EB7210; continue 'dispatch;
            }
            0x82EB720C => {
    //   block [0x82EB720C..0x82EB7210)
	// 82EB720C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	pc = 0x82EB7210; continue 'dispatch;
            }
            0x82EB7210 => {
    //   block [0x82EB7210..0x82EB7278)
	// 82EB7210: EC01E028  fsubs f0, f1, f28
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EB7214: EFBD0028  fsubs f29, f29, f0
	ctx.f[29].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7218: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 82EB721C: 409907D8  ble cr6, 0x82eb79f4
	if !ctx.cr[6].gt {
	pc = 0x82EB79F4; continue 'dispatch;
	}
	// 82EB7220: 7B6A0020  clrldi r10, r27, 0x20
	ctx.r[10].u64 = ctx.r[27].u64 & 0x00000000FFFFFFFFu64;
	// 82EB7224: C1BF044C  lfs f13, 0x44c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7228: EDBB6828  fsubs f13, f27, f13
	ctx.f[13].f64 = (((ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB722C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB7230: 817F0448  lwz r11, 0x448(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1096 as u32) ) } as u64;
	// 82EB7234: F94100A8  std r10, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u64 ) };
	// 82EB7238: EDADD82A  fadds f13, f13, f27
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EB723C: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 82EB7240: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EB7244: C9A100A8  lfd f13, 0xa8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82EB7248: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB724C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB7250: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7254: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EB7258: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82EB725C: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82EB7260: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB7264: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7268: 41990010  bgt cr6, 0x82eb7278
	if ctx.cr[6].gt {
	pc = 0x82EB7278; continue 'dispatch;
	}
	// 82EB726C: 817F0444  lwz r11, 0x444(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82EB7270: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7274: 4098000C  bge cr6, 0x82eb7280
	if !ctx.cr[6].lt {
	pc = 0x82EB7280; continue 'dispatch;
	}
	pc = 0x82EB7278; continue 'dispatch;
            }
            0x82EB7278 => {
    //   block [0x82EB7278..0x82EB7280)
	// 82EB7278: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82EB727C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	pc = 0x82EB7280; continue 'dispatch;
            }
            0x82EB7280 => {
    //   block [0x82EB7280..0x82EB7294)
	// 82EB7280: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EB7284: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82EB7288: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82EB728C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82EB7290: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB7294; continue 'dispatch;
            }
            0x82EB7294 => {
    //   block [0x82EB7294..0x82EB72B8)
	// 82EB7294: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7298: FC00C090  fmr f0, f24
	ctx.f[0].f64 = ctx.f[24].f64;
	// 82EB729C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB72A0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB72A4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB72A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB72AC: 40990044  ble cr6, 0x82eb72f0
	if !ctx.cr[6].gt {
	pc = 0x82EB72F0; continue 'dispatch;
	}
	// 82EB72B0: 5547003E  slwi r7, r10, 0
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB72B4: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	pc = 0x82EB72B8; continue 'dispatch;
            }
            0x82EB72B8 => {
    //   block [0x82EB72B8..0x82EB72E0)
	// 82EB72B8: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB72BC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB72C0: 419A0020  beq cr6, 0x82eb72e0
	if ctx.cr[6].eq {
	pc = 0x82EB72E0; continue 'dispatch;
	}
	// 82EB72C4: 54C6003E  slwi r6, r6, 0
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82EB72C8: C1A6000C  lfs f13, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB72CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB72D0: 40980010  bge cr6, 0x82eb72e0
	if !ctx.cr[6].lt {
	pc = 0x82EB72E0; continue 'dispatch;
	}
	// 82EB72D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82EB72D8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB72DC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82EB72E0; continue 'dispatch;
            }
            0x82EB72E0 => {
    //   block [0x82EB72E0..0x82EB72F0)
	// 82EB72E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB72E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB72E8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EB72EC: 4198FFCC  blt cr6, 0x82eb72b8
	if ctx.cr[6].lt {
	pc = 0x82EB72B8; continue 'dispatch;
	}
	pc = 0x82EB72F0; continue 'dispatch;
            }
            0x82EB72F0 => {
    //   block [0x82EB72F0..0x82EB7370)
	// 82EB72F0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB72F4: 41820748  beq 0x82eb7a3c
	if ctx.cr[0].eq {
	pc = 0x82EB7A3C; continue 'dispatch;
	}
	// 82EB72F8: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB72FC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB7300: 7F0B502E  lwzx r24, r11, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EB7304: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 82EB7308: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB730C: 7E0B5214  add r16, r11, r10
	ctx.r[16].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EB7310: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7314: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7318: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB731C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7320: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB7324: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7328: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB732C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7330: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82EB7334: 556B007F  clrlwi. r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7338: 4182073C  beq 0x82eb7a74
	if ctx.cr[0].eq {
	pc = 0x82EB7A74; continue 'dispatch;
	}
	// 82EB733C: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 82EB7340: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82EB7344: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82EB7348: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82EB734C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82EB7350: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82EB7354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7358: 4801CEE9  bl 0x82ed4240
	ctx.lr = 0x82EB735C;
	sub_82ED4240(ctx, base);
	// 82EB735C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB7360: 7FAFEB78  mr r15, r29
	ctx.r[15].u64 = ctx.r[29].u64;
	// 82EB7364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7368: 419A05C4  beq cr6, 0x82eb792c
	if ctx.cr[6].eq {
	pc = 0x82EB792C; continue 'dispatch;
	}
	// 82EB736C: 7FB3EB78  mr r19, r29
	ctx.r[19].u64 = ctx.r[29].u64;
	pc = 0x82EB7370; continue 'dispatch;
            }
            0x82EB7370 => {
    //   block [0x82EB7370..0x82EB7448)
	// 82EB7370: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB7374: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EB7378: 7EF3582E  lwzx r23, r19, r11
	ctx.r[23].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB737C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB7380: 7ED3582E  lwzx r22, r19, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB7384: D3C10080  stfs f30, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB7388: 8161035C  lwz r11, 0x35c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB738C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82EB7390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7394: 92DE000C  stw r22, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[22].u32 ) };
	// 82EB7398: 409A0188  bne cr6, 0x82eb7520
	if !ctx.cr[6].eq {
	pc = 0x82EB7520; continue 'dispatch;
	}
	// 82EB739C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB73A0: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 82EB73A4: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB73A8: 41820178  beq 0x82eb7520
	if ctx.cr[0].eq {
	pc = 0x82EB7520; continue 'dispatch;
	}
	// 82EB73AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB73B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EB73B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73B8: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB73BC: 4801D555  bl 0x82ed4910
	ctx.lr = 0x82EB73C0;
	sub_82ED4910(ctx, base);
	// 82EB73C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB73C4: 41820548  beq 0x82eb790c
	if ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB73C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73CC: 4801D3C5  bl 0x82ed4790
	ctx.lr = 0x82EB73D0;
	sub_82ED4790(ctx, base);
	// 82EB73D0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EB73D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73D8: 4BFE2E71  bl 0x82e9a248
	ctx.lr = 0x82EB73DC;
	sub_82E9A248(ctx, base);
	// 82EB73DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB73E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB73E4: 4BFE2EE5  bl 0x82e9a2c8
	ctx.lr = 0x82EB73E8;
	sub_82E9A2C8(ctx, base);
	// 82EB73E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB73EC: 92A10094  stw r21, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[21].u32 ) };
	// 82EB73F0: 39410190  addi r10, r1, 0x190
	ctx.r[10].s64 = ctx.r[1].s64 + 400;
	// 82EB73F4: 92A1007C  stw r21, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[21].u32 ) };
	// 82EB73F8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB73FC: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7400: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7404: 92210090  stw r17, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[17].u32 ) };
	// 82EB7408: 92210078  stw r17, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[17].u32 ) };
	// 82EB740C: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB7410: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7414: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7418: 91010094  stw r8, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 82EB741C: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7420: 92410180  stw r18, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[18].u32 ) };
	// 82EB7424: 5508007E  clrlwi r8, r8, 1
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7428: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82EB742C: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7430: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB7434: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7438: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB743C: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7440: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EB7444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EB7448; continue 'dispatch;
            }
            0x82EB7448 => {
    //   block [0x82EB7448..0x82EB7490)
	// 82EB7448: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB744C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7450: 4200FFF8  bdnz 0x82eb7448
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7448; continue 'dispatch;
	}
	// 82EB7454: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EB7458: 9BA101D8  stb r29, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[29].u8 ) };
	// 82EB745C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EB7460: 4B2F7249  bl 0x821ae6a8
	ctx.lr = 0x82EB7464;
	sub_821AE6A8(ctx, base);
	// 82EB7464: 924100C0  stw r18, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[18].u32 ) };
	// 82EB7468: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB746C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82EB7470: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EB7474: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EB7478: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB747C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7480: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EB7484: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7488: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EB748C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EB7490; continue 'dispatch;
            }
            0x82EB7490 => {
    //   block [0x82EB7490..0x82EB7508)
	// 82EB7490: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7494: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7498: 4200FFF8  bdnz 0x82eb7490
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7490; continue 'dispatch;
	}
	// 82EB749C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EB74A0: 9BA10118  stb r29, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[29].u8 ) };
	// 82EB74A4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EB74A8: 4B2F7201  bl 0x821ae6a8
	ctx.lr = 0x82EB74AC;
	sub_821AE6A8(ctx, base);
	// 82EB74AC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB74B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB74B4: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82EB74B8: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB74BC: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82EB74C0: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 82EB74C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EB74C8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EB74CC: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB74D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB74D4: 4E800421  bctrl
	ctx.lr = 0x82EB74D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB74D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB74DC: 4082002C  bne 0x82eb7508
	if !ctx.cr[0].eq {
	pc = 0x82EB7508; continue 'dispatch;
	}
	// 82EB74E0: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82EB74E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB74E8: 41820020  beq 0x82eb7508
	if ctx.cr[0].eq {
	pc = 0x82EB7508; continue 'dispatch;
	}
	// 82EB74EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB74F0: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB74F4: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EB74F8: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EB74FC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB7500: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB7504: 48000408  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
            }
            0x82EB7508 => {
    //   block [0x82EB7508..0x82EB7520)
	// 82EB7508: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB750C: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB7510: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EB7514: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EB7518: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB751C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB7520; continue 'dispatch;
            }
            0x82EB7520 => {
    //   block [0x82EB7520..0x82EB7538)
	// 82EB7520: C3F80014  lfs f31, 0x14(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB7524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7528: 41820010  beq 0x82eb7538
	if ctx.cr[0].eq {
	pc = 0x82EB7538; continue 'dispatch;
	}
	// 82EB752C: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7530: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EB7534: 48000190  b 0x82eb76c4
	pc = 0x82EB76C4; continue 'dispatch;
            }
            0x82EB7538 => {
    //   block [0x82EB7538..0x82EB75AC)
	// 82EB7538: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB753C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7540: 419A0164  beq cr6, 0x82eb76a4
	if ctx.cr[6].eq {
	pc = 0x82EB76A4; continue 'dispatch;
	}
	// 82EB7544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7548: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EB754C: 4BFE2CFD  bl 0x82e9a248
	ctx.lr = 0x82EB7550;
	sub_82E9A248(ctx, base);
	// 82EB7550: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EB7554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7558: 4BFE2D71  bl 0x82e9a2c8
	ctx.lr = 0x82EB755C;
	sub_82E9A2C8(ctx, base);
	// 82EB755C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB7560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7564: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82EB7568: 92210070  stw r17, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[17].u32 ) };
	// 82EB756C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7570: 92A10074  stw r21, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[21].u32 ) };
	// 82EB7574: 4801C2BD  bl 0x82ed3830
	ctx.lr = 0x82EB7578;
	sub_82ED3830(ctx, base);
	// 82EB7578: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB757C: 392101F0  addi r9, r1, 0x1f0
	ctx.r[9].s64 = ctx.r[1].s64 + 496;
	// 82EB7580: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EB7584: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB7588: 924101E0  stw r18, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[18].u32 ) };
	// 82EB758C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB7590: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7594: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EB7598: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB759C: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EB75A0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB75A4: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EB75A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EB75AC; continue 'dispatch;
            }
            0x82EB75AC => {
    //   block [0x82EB75AC..0x82EB7614)
	// 82EB75AC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB75B0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB75B4: 4200FFF8  bdnz 0x82eb75ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB75AC; continue 'dispatch;
	}
	// 82EB75B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EB75BC: 9BA10238  stb r29, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[29].u8 ) };
	// 82EB75C0: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82EB75C4: 4B2F70E5  bl 0x821ae6a8
	ctx.lr = 0x82EB75C8;
	sub_821AE6A8(ctx, base);
	// 82EB75C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB75CC: 92210088  stw r17, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[17].u32 ) };
	// 82EB75D0: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82EB75D4: 92A1008C  stw r21, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[21].u32 ) };
	// 82EB75D8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB75DC: 4801C255  bl 0x82ed3830
	ctx.lr = 0x82EB75E0;
	sub_82ED3830(ctx, base);
	// 82EB75E0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB75E4: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EB75E8: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82EB75EC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB75F0: 92410120  stw r18, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[18].u32 ) };
	// 82EB75F4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB75F8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB75FC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EB7600: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7604: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EB7608: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB760C: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EB7610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EB7614; continue 'dispatch;
            }
            0x82EB7614 => {
    //   block [0x82EB7614..0x82EB7684)
	// 82EB7614: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB7618: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB761C: 4200FFF8  bdnz 0x82eb7614
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7614; continue 'dispatch;
	}
	// 82EB7620: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EB7624: 9BA10178  stb r29, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[29].u8 ) };
	// 82EB7628: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82EB762C: 4B2F707D  bl 0x821ae6a8
	ctx.lr = 0x82EB7630;
	sub_821AE6A8(ctx, base);
	// 82EB7630: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7634: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB7638: 38E10098  addi r7, r1, 0x98
	ctx.r[7].s64 = ctx.r[1].s64 + 152;
	// 82EB763C: 38C10120  addi r6, r1, 0x120
	ctx.r[6].s64 = ctx.r[1].s64 + 288;
	// 82EB7640: 38A101E0  addi r5, r1, 0x1e0
	ctx.r[5].s64 = ctx.r[1].s64 + 480;
	// 82EB7644: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB764C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB7654: 4E800421  bctrl
	ctx.lr = 0x82EB7658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB7658: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB765C: 40820028  bne 0x82eb7684
	if !ctx.cr[0].eq {
	pc = 0x82EB7684; continue 'dispatch;
	}
	// 82EB7660: 897F007F  lbz r11, 0x7f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(127 as u32) ) } as u64;
	// 82EB7664: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7668: 4182001C  beq 0x82eb7684
	if ctx.cr[0].eq {
	pc = 0x82EB7684; continue 'dispatch;
	}
	// 82EB766C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7670: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EB7674: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EB7678: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB767C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB7680: 4800028C  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
            }
            0x82EB7684 => {
    //   block [0x82EB7684..0x82EB76A4)
	// 82EB7684: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7688: C0010098  lfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB768C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EB7690: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82EB7694: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EB7698: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB769C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EB76A0: 48000024  b 0x82eb76c4
	pc = 0x82EB76C4; continue 'dispatch;
            }
            0x82EB76A4 => {
    //   block [0x82EB76A4..0x82EB76C4)
	// 82EB76A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76A8: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82EB76AC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB76B0: F96100B0  std r11, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u64 ) };
	// 82EB76B4: C80100B0  lfd f0, 0xb0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82EB76B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82EB76BC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82EB76C0: EFE0FE7A  fmadds f31, f0, f25, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[31].f64) as f32) as f64);
	pc = 0x82EB76C4; continue 'dispatch;
            }
            0x82EB76C4 => {
    //   block [0x82EB76C4..0x82EB7700)
	// 82EB76C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB76C8: 4BFE2C81  bl 0x82e9a348
	ctx.lr = 0x82EB76CC;
	sub_82E9A348(ctx, base);
	// 82EB76CC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76D0: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB76D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB76D8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB76DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB76E0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB76E4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB76E8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB76EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB76F0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB76F4: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB76F8: 40990060  ble cr6, 0x82eb7758
	if !ctx.cr[6].gt {
	pc = 0x82EB7758; continue 'dispatch;
	}
	// 82EB76FC: 81799E40  lwz r11, -0x61c0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	pc = 0x82EB7700; continue 'dispatch;
            }
            0x82EB7700 => {
    //   block [0x82EB7700..0x82EB7744)
	// 82EB7700: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7704: 40820054  bne 0x82eb7758
	if !ctx.cr[0].eq {
	pc = 0x82EB7758; continue 'dispatch;
	}
	// 82EB7708: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB770C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7710: 419A0034  beq cr6, 0x82eb7744
	if ctx.cr[6].eq {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB7714: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7718: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB771C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7720: 554A007E  clrlwi r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB7724: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB7728: 409A001C  bne cr6, 0x82eb7744
	if !ctx.cr[6].eq {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB772C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7730: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EB7734: C00A0014  lfs f0, 0x14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7738: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB773C: 41990008  bgt cr6, 0x82eb7744
	if ctx.cr[6].gt {
	pc = 0x82EB7744; continue 'dispatch;
	}
	// 82EB7740: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x82EB7744; continue 'dispatch;
            }
            0x82EB7744 => {
    //   block [0x82EB7744..0x82EB7758)
	// 82EB7744: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7748: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB774C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB7750: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB7754: 4198FFAC  blt cr6, 0x82eb7700
	if ctx.cr[6].lt {
	pc = 0x82EB7700; continue 'dispatch;
	}
	pc = 0x82EB7758; continue 'dispatch;
            }
            0x82EB7758 => {
    //   block [0x82EB7758..0x82EB777C)
	// 82EB7758: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB775C: 408201B0  bne 0x82eb790c
	if !ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB7760: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7764: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB7768: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EB776C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7770: 40990060  ble cr6, 0x82eb77d0
	if !ctx.cr[6].gt {
	pc = 0x82EB77D0; continue 'dispatch;
	}
	// 82EB7774: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7778: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	pc = 0x82EB777C; continue 'dispatch;
            }
            0x82EB777C => {
    //   block [0x82EB777C..0x82EB77BC)
	// 82EB777C: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7780: 40820050  bne 0x82eb77d0
	if !ctx.cr[0].eq {
	pc = 0x82EB77D0; continue 'dispatch;
	}
	// 82EB7784: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7788: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB778C: 419A0030  beq cr6, 0x82eb77bc
	if ctx.cr[6].eq {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB7790: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7794: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7798: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB779C: 5463007E  clrlwi r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x7FFFFFFFu64;
	// 82EB77A0: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB77A4: 409A0018  bne cr6, 0x82eb77bc
	if !ctx.cr[6].eq {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB77A8: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB77AC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 82EB77B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EB77B4: 41990008  bgt cr6, 0x82eb77bc
	if ctx.cr[6].gt {
	pc = 0x82EB77BC; continue 'dispatch;
	}
	// 82EB77B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x82EB77BC; continue 'dispatch;
            }
            0x82EB77BC => {
    //   block [0x82EB77BC..0x82EB77D0)
	// 82EB77BC: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB77C0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB77C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB77C8: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB77CC: 4198FFB0  blt cr6, 0x82eb777c
	if ctx.cr[6].lt {
	pc = 0x82EB777C; continue 'dispatch;
	}
	pc = 0x82EB77D0; continue 'dispatch;
            }
            0x82EB77D0 => {
    //   block [0x82EB77D0..0x82EB7878)
	// 82EB77D0: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB77D4: 40820138  bne 0x82eb790c
	if !ctx.cr[0].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB77D8: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB77DC: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82EB77E0: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82EB77E4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB77E8: 816B9E3C  lwz r11, -0x61c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EB77EC: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EB77F0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82EB77F4: 3D008330  lis r8, -0x7cd0
	ctx.r[8].s64 = -2094006272;
	// 82EB77F8: 8108DF34  lwz r8, -0x20cc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB77FC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB7800: 419A0354  beq cr6, 0x82eb7b54
	if ctx.cr[6].eq {
	pc = 0x82EB7B54; continue 'dispatch;
	}
	// 82EB7804: D3EB0014  stfs f31, 0x14(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EB7808: 930B0018  stw r24, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 82EB780C: 92CB0004  stw r22, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 82EB7810: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EB7814: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EB7818: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB781C: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7820: C1890008  lfs f12, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB7824: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7828: 929E0004  stw r20, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 82EB782C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EB7830: C1740004  lfs f11, 4(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB7834: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB7838: C1540008  lfs f10, 8(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB783C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB7840: C134000C  lfs f9, 0xc(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EB7844: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB7848: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EB784C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7850: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82EB7854: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB7858: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB785C: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB7860: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB7864: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EB7868: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EB786C: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7870: 419A0008  beq cr6, 0x82eb7878
	if ctx.cr[6].eq {
	pc = 0x82EB7878; continue 'dispatch;
	}
	// 82EB7874: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82EB7878; continue 'dispatch;
            }
            0x82EB7878 => {
    //   block [0x82EB7878..0x82EB7894)
	// 82EB7878: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EB787C: 409A0090  bne cr6, 0x82eb790c
	if !ctx.cr[6].eq {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB7880: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82EB7884: 419A0010  beq cr6, 0x82eb7894
	if ctx.cr[6].eq {
	pc = 0x82EB7894; continue 'dispatch;
	}
	// 82EB7888: 91700000  stw r11, 0(r16)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB788C: 7FB0EB78  mr r16, r29
	ctx.r[16].u64 = ctx.r[29].u64;
	// 82EB7890: 4800007C  b 0x82eb790c
	pc = 0x82EB790C; continue 'dispatch;
            }
            0x82EB7894 => {
    //   block [0x82EB7894..0x82EB78A8)
	// 82EB7894: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7898: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82EB789C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB78A0: 40990038  ble cr6, 0x82eb78d8
	if !ctx.cr[6].gt {
	pc = 0x82EB78D8; continue 'dispatch;
	}
	// 82EB78A4: 81399E40  lwz r9, -0x61c0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	pc = 0x82EB78A8; continue 'dispatch;
            }
            0x82EB78A8 => {
    //   block [0x82EB78A8..0x82EB78CC)
	// 82EB78A8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB78AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EB78B0: 419A001C  beq cr6, 0x82eb78cc
	if ctx.cr[6].eq {
	pc = 0x82EB78CC; continue 'dispatch;
	}
	// 82EB78B4: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB78B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB78BC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB78C0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82EB78C4: 4198FFE4  blt cr6, 0x82eb78a8
	if ctx.cr[6].lt {
	pc = 0x82EB78A8; continue 'dispatch;
	}
	// 82EB78C8: 48000010  b 0x82eb78d8
	pc = 0x82EB78D8; continue 'dispatch;
            }
            0x82EB78CC => {
    //   block [0x82EB78CC..0x82EB78D8)
	// 82EB78CC: 81199E40  lwz r8, -0x61c0(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78D0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB78D4: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	pc = 0x82EB78D8; continue 'dispatch;
            }
            0x82EB78D8 => {
    //   block [0x82EB78D8..0x82EB790C)
	// 82EB78D8: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB78DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB78E0: 4198002C  blt cr6, 0x82eb790c
	if ctx.cr[6].lt {
	pc = 0x82EB790C; continue 'dispatch;
	}
	// 82EB78E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB78E8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EB78EC: 913F0074  stw r9, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82EB78F0: 81599E40  lwz r10, -0x61c0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EB78F4: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 82EB78F8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB78FC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EB7900: 816BDF34  lwz r11, -0x20cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB7904: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7908: 419A024C  beq cr6, 0x82eb7b54
	if ctx.cr[6].eq {
	pc = 0x82EB7B54; continue 'dispatch;
	}
	pc = 0x82EB790C; continue 'dispatch;
            }
            0x82EB790C => {
    //   block [0x82EB790C..0x82EB792C)
	// 82EB790C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB7910: 39EF0001  addi r15, r15, 1
	ctx.r[15].s64 = ctx.r[15].s64 + 1;
	// 82EB7914: 3A730004  addi r19, r19, 4
	ctx.r[19].s64 = ctx.r[19].s64 + 4;
	// 82EB7918: 7F0F5840  cmplw cr6, r15, r11
	ctx.cr[6].compare_u32(ctx.r[15].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB791C: 4198FA54  blt cr6, 0x82eb7370
	if ctx.cr[6].lt {
	pc = 0x82EB7370; continue 'dispatch;
	}
	// 82EB7920: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB7924: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB7928: 82E100A0  lwz r23, 0xa0(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	pc = 0x82EB792C; continue 'dispatch;
            }
            0x82EB792C => {
    //   block [0x82EB792C..0x82EB7944)
	// 82EB792C: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7930: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7934: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7938: 40990040  ble cr6, 0x82eb7978
	if !ctx.cr[6].gt {
	pc = 0x82EB7978; continue 'dispatch;
	}
	// 82EB793C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7940: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	pc = 0x82EB7944; continue 'dispatch;
            }
            0x82EB7944 => {
    //   block [0x82EB7944..0x82EB7968)
	// 82EB7944: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7948: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB794C: 419A001C  beq cr6, 0x82eb7968
	if ctx.cr[6].eq {
	pc = 0x82EB7968; continue 'dispatch;
	}
	// 82EB7950: 813F0078  lwz r9, 0x78(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB7954: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7958: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB795C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB7960: 4198FFE4  blt cr6, 0x82eb7944
	if ctx.cr[6].lt {
	pc = 0x82EB7944; continue 'dispatch;
	}
	// 82EB7964: 48000014  b 0x82eb7978
	pc = 0x82EB7978; continue 'dispatch;
            }
            0x82EB7968 => {
    //   block [0x82EB7968..0x82EB7978)
	// 82EB7968: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB796C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB7970: 814A9E44  lwz r10, -0x61bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7974: 7F09512E  stwx r24, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[24].u32) };
	pc = 0x82EB7978; continue 'dispatch;
            }
            0x82EB7978 => {
    //   block [0x82EB7978..0x82EB79E4)
	// 82EB7978: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB797C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB7980: 4198F83C  blt cr6, 0x82eb71bc
	if ctx.cr[6].lt {
	pc = 0x82EB71BC; continue 'dispatch;
	}
	// 82EB7984: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EB7988: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB798C: 816B9E44  lwz r11, -0x61bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EB7990: 7F0A592E  stwx r24, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u32) };
	// 82EB7994: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EB7998: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EB799C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB79A0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EB79A4: 814ADF34  lwz r10, -0x20cc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EB79A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB79AC: 409AF810  bne cr6, 0x82eb71bc
	if !ctx.cr[6].eq {
	pc = 0x82EB71BC; continue 'dispatch;
	}
	// 82EB79B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB79B4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB79BC: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB79C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79C4: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB79C8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB79CC: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB79D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB79D4: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB79D8: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB79DC: 4BFD42FD  bl 0x82e8bcd8
	ctx.lr = 0x82EB79E0;
	sub_82E8BCD8(ctx, base);
	// 82EB79E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB79E4; continue 'dispatch;
            }
            0x82EB79E4 => {
    //   block [0x82EB79E4..0x82EB79F4)
	// 82EB79E4: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 82EB79E8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82EB79EC: 4BDF6329  bl 0x82cadd14
	ctx.lr = 0x82EB79F0;
	sub_82CADCEC(ctx, base);
	// 82EB79F0: 4BDF1A30  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EB79F4 => {
    //   block [0x82EB79F4..0x82EB7A3C)
	// 82EB79F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB79F8: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB79FC: 4B3A8FBD  bl 0x822609b8
	ctx.lr = 0x82EB7A00;
	sub_822609B8(ctx, base);
	// 82EB7A00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7A04: 4BFC9C05  bl 0x82e81608
	ctx.lr = 0x82EB7A08;
	sub_82E81608(ctx, base);
	// 82EB7A08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7A0C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A10: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82EB7A14: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7A18: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A1C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A20: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A24: 91CB9E4C  stw r14, -0x61b4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25012 as u32), ctx.r[14].u32 ) };
	// 82EB7A28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A2C: 928B9E50  stw r20, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[20].u32 ) };
	// 82EB7A30: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB7A34: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A38: 4BFFFFAC  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
            }
            0x82EB7A3C => {
    //   block [0x82EB7A3C..0x82EB7A74)
	// 82EB7A3C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7A40: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB7A48: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A4C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A50: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A54: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A58: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7A5C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7A60: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB7A64: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB7A68: 4BFD4271  bl 0x82e8bcd8
	ctx.lr = 0x82EB7A6C;
	sub_82E8BCD8(ctx, base);
	// 82EB7A6C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82EB7A70: 4BFFFF74  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
            }
            0x82EB7A74 => {
    //   block [0x82EB7A74..0x82EB7AA0)
	// 82EB7A74: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7A78: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A7C: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB7A80: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 82EB7A84: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7A88: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A8C: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7A90: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A94: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7A98: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7A9C: 916A9E50  stw r11, -0x61b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25008 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB7AA0; continue 'dispatch;
            }
            0x82EB7AA0 => {
    //   block [0x82EB7AA0..0x82EB7AC8)
	// 82EB7AA0: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB7AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7AA8: 419A0020  beq cr6, 0x82eb7ac8
	if ctx.cr[6].eq {
	pc = 0x82EB7AC8; continue 'dispatch;
	}
	// 82EB7AAC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7AB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7AB4: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EB7AB8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7ABC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7AC0: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB7AC4: 4801CD85  bl 0x82ed4848
	ctx.lr = 0x82EB7AC8;
	sub_82ED4848(ctx, base);
	pc = 0x82EB7AC8; continue 'dispatch;
            }
            0x82EB7AC8 => {
    //   block [0x82EB7AC8..0x82EB7AF8)
	// 82EB7AC8: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EB7ACC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82EB7AD0: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7AD4: 4082FFCC  bne 0x82eb7aa0
	if !ctx.cr[0].eq {
	pc = 0x82EB7AA0; continue 'dispatch;
	}
	// 82EB7AD8: 83A10354  lwz r29, 0x354(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(852 as u32) ) } as u64;
	// 82EB7ADC: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82EB7AE0: 409A0018  bne cr6, 0x82eb7af8
	if !ctx.cr[6].eq {
	pc = 0x82EB7AF8; continue 'dispatch;
	}
	// 82EB7AE4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EB7AE8: 80C1035C  lwz r6, 0x35c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB7AEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB7AF4: 4BFFE3DD  bl 0x82eb5ed0
	ctx.lr = 0x82EB7AF8;
	sub_82EB5ED0(ctx, base);
	pc = 0x82EB7AF8; continue 'dispatch;
            }
            0x82EB7AF8 => {
    //   block [0x82EB7AF8..0x82EB7B18)
	// 82EB7AF8: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82EB7AFC: 409A0048  bne cr6, 0x82eb7b44
	if !ctx.cr[6].eq {
	pc = 0x82EB7B44; continue 'dispatch;
	}
	// 82EB7B00: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7B04: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82EB7B08: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB7B0C: 816B01A0  lwz r11, 0x1a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(416 as u32) ) } as u64;
	// 82EB7B10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7B14: 4198001C  blt cr6, 0x82eb7b30
	if ctx.cr[6].lt {
	pc = 0x82EB7B30; continue 'dispatch;
	}
	pc = 0x82EB7B18; continue 'dispatch;
            }
            0x82EB7B18 => {
    //   block [0x82EB7B18..0x82EB7B1C)
	// 82EB7B18: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82EB7B1C; continue 'dispatch;
            }
            0x82EB7B1C => {
    //   block [0x82EB7B1C..0x82EB7B30)
	// 82EB7B1C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB7B20: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EB7B24: 4BFD41B5  bl 0x82e8bcd8
	ctx.lr = 0x82EB7B28;
	sub_82E8BCD8(ctx, base);
	// 82EB7B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EB7B2C: 4BFFFEB8  b 0x82eb79e4
	pc = 0x82EB79E4; continue 'dispatch;
            }
            0x82EB7B30 => {
    //   block [0x82EB7B30..0x82EB7B44)
	// 82EB7B30: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EB7B34: 80C1035C  lwz r6, 0x35c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EB7B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB7B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB7B40: 4BFFE259  bl 0x82eb5d98
	ctx.lr = 0x82EB7B44;
	sub_82EB5D98(ctx, base);
	pc = 0x82EB7B44; continue 'dispatch;
            }
            0x82EB7B44 => {
    //   block [0x82EB7B44..0x82EB7B54)
	// 82EB7B44: 81610364  lwz r11, 0x364(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EB7B48: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82EB7B4C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82EB7B50: 4BFFFFCC  b 0x82eb7b1c
	pc = 0x82EB7B1C; continue 'dispatch;
            }
            0x82EB7B54 => {
    //   block [0x82EB7B54..0x82EB7B7C)
	// 82EB7B54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB7B58: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B5C: 916A9E54  stw r11, -0x61ac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25004 as u32), ctx.r[11].u32 ) };
	// 82EB7B60: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B64: 916A9E48  stw r11, -0x61b8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25016 as u32), ctx.r[11].u32 ) };
	// 82EB7B68: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EB7B6C: 916A9E4C  stw r11, -0x61b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25012 as u32), ctx.r[11].u32 ) };
	// 82EB7B70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB7B74: 93AB9E50  stw r29, -0x61b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25008 as u32), ctx.r[29].u32 ) };
	// 82EB7B78: 4BFFFFA0  b 0x82eb7b18
	pc = 0x82EB7B18; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB7B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB7B80 size=1024
    let mut pc: u32 = 0x82EB7B80;
    'dispatch: loop {
        match pc {
            0x82EB7B80 => {
    //   block [0x82EB7B80..0x82EB7C1C)
	// 82EB7B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB7B84: 4BDF1875  bl 0x82ca93f8
	ctx.lr = 0x82EB7B88;
	sub_82CA93D0(ctx, base);
	// 82EB7B88: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82EB7B8C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB7B90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EB7B94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB7B98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EB7B9C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82EB7BA0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EB7BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7BA8: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82EB7BAC: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7BB0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7BB4: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7BB8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7BBC: 408202A0  bne 0x82eb7e5c
	if !ctx.cr[0].eq {
	pc = 0x82EB7E5C; continue 'dispatch;
	}
	// 82EB7BC0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7BC4: 4801BC8D  bl 0x82ed3850
	ctx.lr = 0x82EB7BC8;
	sub_82ED3850(ctx, base);
	// 82EB7BC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7BCC: 41820290  beq 0x82eb7e5c
	if ctx.cr[0].eq {
	pc = 0x82EB7E5C; continue 'dispatch;
	}
	// 82EB7BD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7BD4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB7BD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7BDC: 408200B8  bne 0x82eb7c94
	if !ctx.cr[0].eq {
	pc = 0x82EB7C94; continue 'dispatch;
	}
	// 82EB7BE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB7BE4: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7BE8: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82EB7BEC: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB7BF0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB7BF4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7BF8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB7BFC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82EB7C00: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7C04: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82EB7C08: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EB7C0C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EB7C10: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB7C14: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EB7C18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EB7C1C; continue 'dispatch;
            }
            0x82EB7C1C => {
    //   block [0x82EB7C1C..0x82EB7C94)
	// 82EB7C1C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7C20: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7C24: 4200FFF8  bdnz 0x82eb7c1c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB7C1C; continue 'dispatch;
	}
	// 82EB7C28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB7C2C: 9B4100D8  stb r26, 0xd8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[26].u8 ) };
	// 82EB7C30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB7C34: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7C38: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB7C3C: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82EB7C40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EB7C44: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82EB7C48: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EB7C4C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82EB7C50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB7C54: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EB7C58: 4801D8D9  bl 0x82ed5530
	ctx.lr = 0x82EB7C5C;
	sub_82ED5530(ctx, base);
	// 82EB7C5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7C60: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EB7C64: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7C68: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7C6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB7C70: 7D44E850  subf r10, r4, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[4].s64;
	// 82EB7C74: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB7C78: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82EB7C7C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82EB7C80: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EB7C84: 695D0001  xori r29, r10, 1
	ctx.r[29].u64 = ctx.r[10].u64 ^ 1;
	// 82EB7C88: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7C8C: 4801BC4D  bl 0x82ed38d8
	ctx.lr = 0x82EB7C90;
	sub_82ED38D8(ctx, base);
	// 82EB7C90: 4800001C  b 0x82eb7cac
	pc = 0x82EB7CAC; continue 'dispatch;
            }
            0x82EB7C94 => {
    //   block [0x82EB7C94..0x82EB7CAC)
	// 82EB7C94: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7C98: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7C9C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7CA0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7CA4: 4801BC35  bl 0x82ed38d8
	ctx.lr = 0x82EB7CA8;
	sub_82ED38D8(ctx, base);
	// 82EB7CA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x82EB7CAC; continue 'dispatch;
            }
            0x82EB7CAC => {
    //   block [0x82EB7CAC..0x82EB7D30)
	// 82EB7CAC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7CB0: 418202C4  beq 0x82eb7f74
	if ctx.cr[0].eq {
	pc = 0x82EB7F74; continue 'dispatch;
	}
	// 82EB7CB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7CB8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7CBC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7CC0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7CC4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7CC8: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7CCC: D00B0050  stfs f0, 0x50(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB7CD0: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7CD4: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB7CD8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7CDC: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB7CE0: 4801BB51  bl 0x82ed3830
	ctx.lr = 0x82EB7CE4;
	sub_82ED3830(ctx, base);
	// 82EB7CE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7CE8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7CEC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7CF0: 572A063F  clrlwi. r10, r25, 0x18
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB7CF4: 906B005C  stw r3, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82EB7CF8: 418200F4  beq 0x82eb7dec
	if ctx.cr[0].eq {
	pc = 0x82EB7DEC; continue 'dispatch;
	}
	// 82EB7CFC: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7D00: 815B016C  lwz r10, 0x16c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB7D04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EB7D08: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7D0C: 419A0090  beq cr6, 0x82eb7d9c
	if ctx.cr[6].eq {
	pc = 0x82EB7D9C; continue 'dispatch;
	}
	// 82EB7D10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7D14: 395D0014  addi r10, r29, 0x14
	ctx.r[10].s64 = ctx.r[29].s64 + 20;
	// 82EB7D18: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7D1C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7D20: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82EB7D24: 8129004C  lwz r9, 0x4c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB7D28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EB7D2C: 4099004C  ble cr6, 0x82eb7d78
	if !ctx.cr[6].gt {
	pc = 0x82EB7D78; continue 'dispatch;
	}
	pc = 0x82EB7D30; continue 'dispatch;
            }
            0x82EB7D30 => {
    //   block [0x82EB7D30..0x82EB7D78)
	// 82EB7D30: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7D34: 1D290018  mulli r9, r9, 0x18
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 24 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB7D38: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB7D3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7D40: 39290003  addi r9, r9, 3
	ctx.r[9].s64 = ctx.r[9].s64 + 3;
	// 82EB7D44: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB7D48: 7D29F02E  lwzx r9, r9, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EB7D4C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB7D50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB7D54: A13D0012  lhz r9, 0x12(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB7D58: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EB7D5C: B13D0012  sth r9, 0x12(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(18 as u32), ctx.r[9].u16 ) };
	// 82EB7D60: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7D64: 1D290060  mulli r9, r9, 0x60
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 96 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB7D68: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82EB7D6C: 8129004C  lwz r9, 0x4c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB7D70: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB7D74: 4198FFBC  blt cr6, 0x82eb7d30
	if ctx.cr[6].lt {
	pc = 0x82EB7D30; continue 'dispatch;
	}
	pc = 0x82EB7D78; continue 'dispatch;
            }
            0x82EB7D78 => {
    //   block [0x82EB7D78..0x82EB7D9C)
	// 82EB7D78: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7D7C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7D80: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB7D84: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB7D88: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB7D8C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB7D90: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB7D94: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB7D98: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82EB7D9C; continue 'dispatch;
            }
            0x82EB7D9C => {
    //   block [0x82EB7D9C..0x82EB7DEC)
	// 82EB7D9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DA0: B17D0010  sth r11, 0x10(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82EB7DA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DA8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7DAC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7DB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7DB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7DB8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7DBC: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7DC0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7DC4: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7DC8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7DCC: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7DD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DD4: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7DD8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7DDC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7DE0: 4801BA51  bl 0x82ed3830
	ctx.lr = 0x82EB7DE4;
	sub_82ED3830(ctx, base);
	// 82EB7DE4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB7DE8: B35D0012  sth r26, 0x12(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(18 as u32), ctx.r[26].u16 ) };
	pc = 0x82EB7DEC; continue 'dispatch;
            }
            0x82EB7DEC => {
    //   block [0x82EB7DEC..0x82EB7E24)
	// 82EB7DEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7DF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB7DF4: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7DF8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7DFC: 994B0008  stb r10, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82EB7E00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E04: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7E08: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E0C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E10: 4801B9F1  bl 0x82ed3800
	ctx.lr = 0x82EB7E14;
	sub_82ED3800(ctx, base);
	// 82EB7E14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7E18: 90780000  stw r3, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EB7E1C: 40820008  bne 0x82eb7e24
	if !ctx.cr[0].eq {
	pc = 0x82EB7E24; continue 'dispatch;
	}
	// 82EB7E20: 93580000  stw r26, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82EB7E24; continue 'dispatch;
            }
            0x82EB7E24 => {
    //   block [0x82EB7E24..0x82EB7E5C)
	// 82EB7E24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E28: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7E2C: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7E30: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E34: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E38: 4801B0F9  bl 0x82ed2f30
	ctx.lr = 0x82EB7E3C;
	sub_82ED2F30(ctx, base);
	// 82EB7E3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E40: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7E44: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E48: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82EB7E4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB7E54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB7E58: 4800011C  b 0x82eb7f74
	pc = 0x82EB7F74; continue 'dispatch;
            }
            0x82EB7E5C => {
    //   block [0x82EB7E5C..0x82EB7EEC)
	// 82EB7E5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E60: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7E64: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E68: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB7E6C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB7E70: 40820104  bne 0x82eb7f74
	if !ctx.cr[0].eq {
	pc = 0x82EB7F74; continue 'dispatch;
	}
	// 82EB7E74: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E78: 4801BA31  bl 0x82ed38a8
	ctx.lr = 0x82EB7E7C;
	sub_82ED38A8(ctx, base);
	// 82EB7E7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB7E80: 418200F4  beq 0x82eb7f74
	if ctx.cr[0].eq {
	pc = 0x82EB7F74; continue 'dispatch;
	}
	// 82EB7E84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7E88: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7E8C: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7E90: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7E94: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB7E98: 4801B099  bl 0x82ed2f30
	ctx.lr = 0x82EB7E9C;
	sub_82ED2F30(ctx, base);
	// 82EB7E9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EA0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EB7EA4: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7EA8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7EAC: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82EB7EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EB4: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7EBC: 409A0030  bne cr6, 0x82eb7eec
	if !ctx.cr[6].eq {
	pc = 0x82EB7EEC; continue 'dispatch;
	}
	// 82EB7EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7EC4: 809B00A4  lwz r4, 0xa4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EB7EC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB7ECC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB7ED0: C02B0C4C  lfs f1, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB7ED4: 4801AE75  bl 0x82ed2d48
	ctx.lr = 0x82EB7ED8;
	sub_82ED2D48(ctx, base);
	// 82EB7ED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EDC: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7EE0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7EE4: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EB7EE8: 4800008C  b 0x82eb7f74
	pc = 0x82EB7F74; continue 'dispatch;
            }
            0x82EB7EEC => {
    //   block [0x82EB7EEC..0x82EB7F14)
	// 82EB7EEC: 4801A0B5  bl 0x82ed1fa0
	ctx.lr = 0x82EB7EF0;
	sub_82ED1FA0(ctx, base);
	// 82EB7EF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7EF4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82EB7EF8: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7EFC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB7F00: 816B00F0  lwz r11, 0xf0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB7F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB7F08: 40990064  ble cr6, 0x82eb7f6c
	if !ctx.cr[6].gt {
	pc = 0x82EB7F6C; continue 'dispatch;
	}
	// 82EB7F0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB7F10: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB7F14; continue 'dispatch;
            }
            0x82EB7F14 => {
    //   block [0x82EB7F14..0x82EB7F6C)
	// 82EB7F14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7F18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB7F1C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB7F20: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7F24: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7F28: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB7F2C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82EB7F30: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 82EB7F34: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB7F38: 7C8BD82E  lwzx r4, r11, r27
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82EB7F3C: 4801AE0D  bl 0x82ed2d48
	ctx.lr = 0x82EB7F40;
	sub_82ED2D48(ctx, base);
	// 82EB7F40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7F44: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB7F48: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7F4C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB7F50: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EB7F54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB7F58: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB7F5C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82EB7F60: 816B00F0  lwz r11, 0xf0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB7F64: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB7F68: 4198FFAC  blt cr6, 0x82eb7f14
	if ctx.cr[6].lt {
	pc = 0x82EB7F14; continue 'dispatch;
	}
	pc = 0x82EB7F6C; continue 'dispatch;
            }
            0x82EB7F6C => {
    //   block [0x82EB7F6C..0x82EB7F74)
	// 82EB7F6C: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB7F70: 4801A051  bl 0x82ed1fc0
	ctx.lr = 0x82EB7F74;
	sub_82ED1FC0(ctx, base);
	pc = 0x82EB7F74; continue 'dispatch;
            }
            0x82EB7F74 => {
    //   block [0x82EB7F74..0x82EB7F80)
	// 82EB7F74: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82EB7F78: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82EB7F7C: 4BDF14CC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB7F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB7F80 size=964
    let mut pc: u32 = 0x82EB7F80;
    'dispatch: loop {
        match pc {
            0x82EB7F80 => {
    //   block [0x82EB7F80..0x82EB8028)
	// 82EB7F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB7F84: 4BDF1485  bl 0x82ca9408
	ctx.lr = 0x82EB7F88;
	sub_82CA93D0(ctx, base);
	// 82EB7F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB7F8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EB7F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB7F94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB7F98: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82EB7F9C: 397F0334  addi r11, r31, 0x334
	ctx.r[11].s64 = ctx.r[31].s64 + 820;
	// 82EB7FA0: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB7FA4: 395F027C  addi r10, r31, 0x27c
	ctx.r[10].s64 = ctx.r[31].s64 + 636;
	// 82EB7FA8: 393F03A4  addi r9, r31, 0x3a4
	ctx.r[9].s64 = ctx.r[31].s64 + 932;
	// 82EB7FAC: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 82EB7FB0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82EB7FB4: 911F03A0  stw r8, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[8].u32 ) };
	// 82EB7FB8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EB7FBC: 9BDF0396  stb r30, 0x396(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(918 as u32), ctx.r[30].u8 ) };
	// 82EB7FC0: 9BDF0397  stb r30, 0x397(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(919 as u32), ctx.r[30].u8 ) };
	// 82EB7FC4: 9BDF0395  stb r30, 0x395(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(917 as u32), ctx.r[30].u8 ) };
	// 82EB7FC8: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 82EB7FCC: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 82EB7FD0: C1A80C1C  lfs f13, 0xc1c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB7FD4: 9BDF0435  stb r30, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[30].u8 ) };
	// 82EB7FD8: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FDC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7FE0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7FE4: 9BCB0058  stb r30, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB7FE8: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FEC: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB7FF0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB7FF4: 9BCA0058  stb r30, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB7FF8: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB7FFC: D0090008  stfs f0, 8(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB8000: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB8004: 9BC90058  stb r30, 0x58(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EB8008: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB800C: D1BF0424  stfs f13, 0x424(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82EB8010: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82EB8014: 9BDF0394  stb r30, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u8 ) };
	// 82EB8018: 9BDF019D  stb r30, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[30].u8 ) };
	// 82EB801C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8020: 40990034  ble cr6, 0x82eb8054
	if !ctx.cr[6].gt {
	pc = 0x82EB8054; continue 'dispatch;
	}
	// 82EB8024: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x82EB8028; continue 'dispatch;
            }
            0x82EB8028 => {
    //   block [0x82EB8028..0x82EB8054)
	// 82EB8028: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EB802C: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8030: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8034: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB803C: 4E800421  bctrl
	ctx.lr = 0x82EB8040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8040: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB8044: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8048: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EB804C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8050: 4198FFD8  blt cr6, 0x82eb8028
	if ctx.cr[6].lt {
	pc = 0x82EB8028; continue 'dispatch;
	}
            }
            0x82EB8054 => {
    //   block [0x82EB8054..0x82EB8068)
	// 82EB8054: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB8058: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB805C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8060: 40990034  ble cr6, 0x82eb8094
	if !ctx.cr[6].gt {
	pc = 0x82EB8094; continue 'dispatch;
	}
	// 82EB8064: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB8068; continue 'dispatch;
            }
            0x82EB8068 => {
    //   block [0x82EB8068..0x82EB8094)
	// 82EB8068: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB806C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8074: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB807C: 4E800421  bctrl
	ctx.lr = 0x82EB8080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8080: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EB8084: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8088: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB808C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8090: 4198FFD8  blt cr6, 0x82eb8068
	if ctx.cr[6].lt {
	pc = 0x82EB8068; continue 'dispatch;
	}
            }
            0x82EB8094 => {
    //   block [0x82EB8094..0x82EB80A8)
	// 82EB8094: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EB8098: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB809C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB80A0: 40990034  ble cr6, 0x82eb80d4
	if !ctx.cr[6].gt {
	pc = 0x82EB80D4; continue 'dispatch;
	}
	// 82EB80A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB80A8; continue 'dispatch;
            }
            0x82EB80A8 => {
    //   block [0x82EB80A8..0x82EB80D4)
	// 82EB80A8: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EB80AC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB80B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB80B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB80B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB80BC: 4E800421  bctrl
	ctx.lr = 0x82EB80C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB80C0: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EB80C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB80C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB80CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB80D0: 4198FFD8  blt cr6, 0x82eb80a8
	if ctx.cr[6].lt {
	pc = 0x82EB80A8; continue 'dispatch;
	}
            }
            0x82EB80D4 => {
    //   block [0x82EB80D4..0x82EB80E8)
	// 82EB80D4: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EB80D8: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB80DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB80E0: 40990034  ble cr6, 0x82eb8114
	if !ctx.cr[6].gt {
	pc = 0x82EB8114; continue 'dispatch;
	}
	// 82EB80E4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB80E8; continue 'dispatch;
            }
            0x82EB80E8 => {
    //   block [0x82EB80E8..0x82EB8114)
	// 82EB80E8: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EB80EC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB80F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB80F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB80F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB80FC: 4E800421  bctrl
	ctx.lr = 0x82EB8100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8100: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EB8104: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8108: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB810C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8110: 4198FFD8  blt cr6, 0x82eb80e8
	if ctx.cr[6].lt {
	pc = 0x82EB80E8; continue 'dispatch;
	}
            }
            0x82EB8114 => {
    //   block [0x82EB8114..0x82EB8128)
	// 82EB8114: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EB8118: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB811C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8120: 40990034  ble cr6, 0x82eb8154
	if !ctx.cr[6].gt {
	pc = 0x82EB8154; continue 'dispatch;
	}
	// 82EB8124: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB8128; continue 'dispatch;
            }
            0x82EB8128 => {
    //   block [0x82EB8128..0x82EB8154)
	// 82EB8128: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EB812C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8134: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB813C: 4E800421  bctrl
	ctx.lr = 0x82EB8140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8140: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EB8144: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8148: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB814C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8150: 4198FFD8  blt cr6, 0x82eb8128
	if ctx.cr[6].lt {
	pc = 0x82EB8128; continue 'dispatch;
	}
            }
            0x82EB8154 => {
    //   block [0x82EB8154..0x82EB8168)
	// 82EB8154: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EB8158: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8160: 40990034  ble cr6, 0x82eb8194
	if !ctx.cr[6].gt {
	pc = 0x82EB8194; continue 'dispatch;
	}
	// 82EB8164: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB8168; continue 'dispatch;
            }
            0x82EB8168 => {
    //   block [0x82EB8168..0x82EB8194)
	// 82EB8168: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EB816C: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8174: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB817C: 4E800421  bctrl
	ctx.lr = 0x82EB8180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8180: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EB8184: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8188: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB818C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8190: 4198FFD8  blt cr6, 0x82eb8168
	if ctx.cr[6].lt {
	pc = 0x82EB8168; continue 'dispatch;
	}
            }
            0x82EB8194 => {
    //   block [0x82EB8194..0x82EB81A8)
	// 82EB8194: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EB8198: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB819C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB81A0: 40990034  ble cr6, 0x82eb81d4
	if !ctx.cr[6].gt {
	pc = 0x82EB81D4; continue 'dispatch;
	}
	// 82EB81A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB81A8; continue 'dispatch;
            }
            0x82EB81A8 => {
    //   block [0x82EB81A8..0x82EB81D4)
	// 82EB81A8: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EB81AC: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB81B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB81B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB81B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB81BC: 4E800421  bctrl
	ctx.lr = 0x82EB81C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB81C0: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EB81C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB81C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB81CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB81D0: 4198FFD8  blt cr6, 0x82eb81a8
	if ctx.cr[6].lt {
	pc = 0x82EB81A8; continue 'dispatch;
	}
            }
            0x82EB81D4 => {
    //   block [0x82EB81D4..0x82EB81E8)
	// 82EB81D4: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EB81D8: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB81DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB81E0: 40990034  ble cr6, 0x82eb8214
	if !ctx.cr[6].gt {
	pc = 0x82EB8214; continue 'dispatch;
	}
	// 82EB81E4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB81E8; continue 'dispatch;
            }
            0x82EB81E8 => {
    //   block [0x82EB81E8..0x82EB8214)
	// 82EB81E8: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EB81EC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB81F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB81F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB81F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB81FC: 4E800421  bctrl
	ctx.lr = 0x82EB8200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8200: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EB8204: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8208: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB820C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8210: 4198FFD8  blt cr6, 0x82eb81e8
	if ctx.cr[6].lt {
	pc = 0x82EB81E8; continue 'dispatch;
	}
            }
            0x82EB8214 => {
    //   block [0x82EB8214..0x82EB8228)
	// 82EB8214: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EB8218: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB821C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8220: 40990034  ble cr6, 0x82eb8254
	if !ctx.cr[6].gt {
	pc = 0x82EB8254; continue 'dispatch;
	}
	// 82EB8224: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB8228; continue 'dispatch;
            }
            0x82EB8228 => {
    //   block [0x82EB8228..0x82EB8254)
	// 82EB8228: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EB822C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB8230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8234: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB823C: 4E800421  bctrl
	ctx.lr = 0x82EB8240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8240: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EB8244: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8248: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB824C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8250: 4198FFD8  blt cr6, 0x82eb8228
	if ctx.cr[6].lt {
	pc = 0x82EB8228; continue 'dispatch;
	}
            }
            0x82EB8254 => {
    //   block [0x82EB8254..0x82EB8268)
	// 82EB8254: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EB8258: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB825C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8260: 40990034  ble cr6, 0x82eb8294
	if !ctx.cr[6].gt {
	pc = 0x82EB8294; continue 'dispatch;
	}
	// 82EB8264: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB8268; continue 'dispatch;
            }
            0x82EB8268 => {
    //   block [0x82EB8268..0x82EB8294)
	// 82EB8268: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EB826C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB8270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8274: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB8278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB827C: 4E800421  bctrl
	ctx.lr = 0x82EB8280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB8280: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EB8284: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8288: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB828C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8290: 4198FFD8  blt cr6, 0x82eb8268
	if ctx.cr[6].lt {
	pc = 0x82EB8268; continue 'dispatch;
	}
            }
            0x82EB8294 => {
    //   block [0x82EB8294..0x82EB82A8)
	// 82EB8294: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EB8298: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82EB829C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB82A0: 40990034  ble cr6, 0x82eb82d4
	if !ctx.cr[6].gt {
	pc = 0x82EB82D4; continue 'dispatch;
	}
	// 82EB82A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82EB82A8; continue 'dispatch;
            }
            0x82EB82A8 => {
    //   block [0x82EB82A8..0x82EB82D4)
	// 82EB82A8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EB82AC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB82B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB82B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB82B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB82BC: 4E800421  bctrl
	ctx.lr = 0x82EB82C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB82C0: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EB82C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB82C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB82CC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB82D0: 4198FFD8  blt cr6, 0x82eb82a8
	if ctx.cr[6].lt {
	pc = 0x82EB82A8; continue 'dispatch;
	}
            }
            0x82EB82D4 => {
    //   block [0x82EB82D4..0x82EB8310)
	// 82EB82D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB82D8: 4BFFDEC9  bl 0x82eb61a0
	ctx.lr = 0x82EB82DC;
	sub_82EB61A0(ctx, base);
	// 82EB82DC: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB82E0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EB82E4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EB82E8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB82EC: 41820024  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB82F0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB82F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB82F8: 41820018  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB82FC: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB8300: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8304: 4182000C  beq 0x82eb8310
	if ctx.cr[0].eq {
	pc = 0x82EB8310; continue 'dispatch;
	}
	// 82EB8308: 4801AC29  bl 0x82ed2f30
	ctx.lr = 0x82EB830C;
	sub_82ED2F30(ctx, base);
	// 82EB830C: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	pc = 0x82EB8310; continue 'dispatch;
            }
            0x82EB8310 => {
    //   block [0x82EB8310..0x82EB833C)
	// 82EB8310: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB8314: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8318: 41820024  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB831C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8320: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8324: 41820018  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB8328: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB832C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8330: 4182000C  beq 0x82eb833c
	if ctx.cr[0].eq {
	pc = 0x82EB833C; continue 'dispatch;
	}
	// 82EB8334: 4801ABFD  bl 0x82ed2f30
	ctx.lr = 0x82EB8338;
	sub_82ED2F30(ctx, base);
	// 82EB8338: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	pc = 0x82EB833C; continue 'dispatch;
            }
            0x82EB833C => {
    //   block [0x82EB833C..0x82EB8344)
	// 82EB833C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB8340: 4BDF1118  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB8348 size=2008
    let mut pc: u32 = 0x82EB8348;
    'dispatch: loop {
        match pc {
            0x82EB8348 => {
    //   block [0x82EB8348..0x82EB837C)
	// 82EB8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB834C: 4BDF10A9  bl 0x82ca93f4
	ctx.lr = 0x82EB8350;
	sub_82CA93D0(ctx, base);
	// 82EB8350: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EB8354: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB8358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB835C: 839F0054  lwz r28, 0x54(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8360: 817C01A4  lwz r11, 0x1a4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EB8364: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB8368: 408200F4  bne 0x82eb845c
	if !ctx.cr[0].eq {
	pc = 0x82EB845C; continue 'dispatch;
	}
	// 82EB836C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8370: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB8374: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB8378: 419A006C  beq cr6, 0x82eb83e4
	if ctx.cr[6].eq {
	pc = 0x82EB83E4; continue 'dispatch;
	}
	pc = 0x82EB837C; continue 'dispatch;
            }
            0x82EB837C => {
    //   block [0x82EB837C..0x82EB83C8)
	// 82EB837C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8380: 816301A8  lwz r11, 0x1a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(424 as u32) ) } as u64;
	// 82EB8384: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82EB8388: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EB838C: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8390: 40820038  bne 0x82eb83c8
	if !ctx.cr[0].eq {
	pc = 0x82EB83C8; continue 'dispatch;
	}
	// 82EB8394: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8398: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB839C: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EB83A0: 419A0770  beq cr6, 0x82eb8b10
	if ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB83A4: 4BFFDFFD  bl 0x82eb63a0
	ctx.lr = 0x82EB83A8;
	sub_82EB63A0(ctx, base);
	// 82EB83A8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB83B0: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB83B4: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB83B8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB83BC: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB83C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB83C4: 4BFFFFB8  b 0x82eb837c
	pc = 0x82EB837C; continue 'dispatch;
            }
            0x82EB83C8 => {
    //   block [0x82EB83C8..0x82EB83E4)
	// 82EB83C8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EB83D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EB83D4: 914B01A4  stw r10, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[10].u32 ) };
	// 82EB83D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB83DC: 912B01AC  stw r9, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[9].u32 ) };
	// 82EB83E0: 48000730  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB83E4 => {
    //   block [0x82EB83E4..0x82EB8420)
	// 82EB83E4: 817C01B8  lwz r11, 0x1b8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB83E8: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB83EC: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB83F0: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB83F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB83F8: 409A0028  bne cr6, 0x82eb8420
	if !ctx.cr[6].eq {
	pc = 0x82EB8420; continue 'dispatch;
	}
	// 82EB83FC: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8400: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8404: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8408: 409A0018  bne cr6, 0x82eb8420
	if !ctx.cr[6].eq {
	pc = 0x82EB8420; continue 'dispatch;
	}
	// 82EB840C: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8410: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8414: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8418: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB841C: 419A0008  beq cr6, 0x82eb8424
	if ctx.cr[6].eq {
	pc = 0x82EB8424; continue 'dispatch;
	}
	pc = 0x82EB8420; continue 'dispatch;
            }
            0x82EB8420 => {
    //   block [0x82EB8420..0x82EB8424)
	// 82EB8420: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82EB8424; continue 'dispatch;
            }
            0x82EB8424 => {
    //   block [0x82EB8424..0x82EB845C)
	// 82EB8424: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB8428: 418206E8  beq 0x82eb8b10
	if ctx.cr[0].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB842C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB8430: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8434: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB8438: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB843C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB8440: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8444: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB8448: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB844C: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB8450: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB8454: 914B01B8  stw r10, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[10].u32 ) };
	// 82EB8458: 480006B8  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB845C => {
    //   block [0x82EB845C..0x82EB84A4)
	// 82EB845C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB8460: 409A06B0  bne cr6, 0x82eb8b10
	if !ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8464: 817C01BC  lwz r11, 0x1bc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EB8468: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82EB846C: 815C01B8  lwz r10, 0x1b8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB8470: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB8474: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 82EB8478: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EB847C: 419A0030  beq cr6, 0x82eb84ac
	if ctx.cr[6].eq {
	pc = 0x82EB84AC; continue 'dispatch;
	}
	// 82EB8480: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82EB8484: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82EB8488: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82EB848C: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 82EB8490: 41990680  bgt cr6, 0x82eb8b10
	if ctx.cr[6].gt {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8494: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82EB8498: 4098000C  bge cr6, 0x82eb84a4
	if !ctx.cr[6].lt {
	pc = 0x82EB84A4; continue 'dispatch;
	}
	// 82EB849C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82EB84A0: 48000010  b 0x82eb84b0
	pc = 0x82EB84B0; continue 'dispatch;
            }
            0x82EB84A4 => {
    //   block [0x82EB84A4..0x82EB84AC)
	// 82EB84A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EB84A8: 40980008  bge cr6, 0x82eb84b0
	if !ctx.cr[6].lt {
	pc = 0x82EB84B0; continue 'dispatch;
	}
	pc = 0x82EB84AC; continue 'dispatch;
            }
            0x82EB84AC => {
    //   block [0x82EB84AC..0x82EB84B0)
	// 82EB84AC: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	pc = 0x82EB84B0; continue 'dispatch;
            }
            0x82EB84B0 => {
    //   block [0x82EB84B0..0x82EB8514)
	// 82EB84B0: 817C01AC  lwz r11, 0x1ac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EB84B4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB84B8: 40820324  bne 0x82eb87dc
	if !ctx.cr[0].eq {
	pc = 0x82EB87DC; continue 'dispatch;
	}
	// 82EB84BC: 817C0194  lwz r11, 0x194(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB84C0: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB84C4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82EB84C8: 38CB0010  addi r6, r11, 0x10
	ctx.r[6].s64 = ctx.r[11].s64 + 16;
	// 82EB84CC: 83C60008  lwz r30, 8(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB84D0: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB84D4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB84D8: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 82EB84DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB84E0: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82EB84E4: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB84E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB84EC: 409A0028  bne cr6, 0x82eb8514
	if !ctx.cr[6].eq {
	pc = 0x82EB8514; continue 'dispatch;
	}
	// 82EB84F0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB84F4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB84F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB84FC: 409A0018  bne cr6, 0x82eb8514
	if !ctx.cr[6].eq {
	pc = 0x82EB8514; continue 'dispatch;
	}
	// 82EB8500: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8504: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB8508: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB850C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8510: 419A0008  beq cr6, 0x82eb8518
	if ctx.cr[6].eq {
	pc = 0x82EB8518; continue 'dispatch;
	}
	pc = 0x82EB8514; continue 'dispatch;
            }
            0x82EB8514 => {
    //   block [0x82EB8514..0x82EB8518)
	// 82EB8514: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82EB8518; continue 'dispatch;
            }
            0x82EB8518 => {
    //   block [0x82EB8518..0x82EB8538)
	// 82EB8518: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB851C: 4182001C  beq 0x82eb8538
	if ctx.cr[0].eq {
	pc = 0x82EB8538; continue 'dispatch;
	}
	// 82EB8520: 92FC01A4  stw r23, 0x1a4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(420 as u32), ctx.r[23].u32 ) };
	// 82EB8524: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8528: 4BFFDDE9  bl 0x82eb6310
	ctx.lr = 0x82EB852C;
	sub_82EB6310(ctx, base);
	// 82EB852C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8530: 4BFFFE19  bl 0x82eb8348
	ctx.lr = 0x82EB8534;
	sub_82EB8348(ctx, base);
	// 82EB8534: 480005DC  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB8538 => {
    //   block [0x82EB8538..0x82EB856C)
	// 82EB8538: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB853C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8540: 40820080  bne 0x82eb85c0
	if !ctx.cr[0].eq {
	pc = 0x82EB85C0; continue 'dispatch;
	}
	// 82EB8544: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8548: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB854C: 40820074  bne 0x82eb85c0
	if !ctx.cr[0].eq {
	pc = 0x82EB85C0; continue 'dispatch;
	}
	// 82EB8550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EB8558: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EB855C: 4BFFD745  bl 0x82eb5ca0
	ctx.lr = 0x82EB8560;
	sub_82EB5CA0(ctx, base);
	// 82EB8560: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8564: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8568: 419A002C  beq cr6, 0x82eb8594
	if ctx.cr[6].eq {
	pc = 0x82EB8594; continue 'dispatch;
	}
	pc = 0x82EB856C; continue 'dispatch;
            }
            0x82EB856C => {
    //   block [0x82EB856C..0x82EB8594)
	// 82EB856C: A1670012  lhz r11, 0x12(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8570: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8574: 396B0005  addi r11, r11, 5
	ctx.r[11].s64 = ctx.r[11].s64 + 5;
	// 82EB8578: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB857C: 7CEB3A14  add r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82EB8580: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82EB8584: 4BFFD71D  bl 0x82eb5ca0
	ctx.lr = 0x82EB8588;
	sub_82EB5CA0(ctx, base);
	// 82EB8588: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB858C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8590: 409AFFDC  bne cr6, 0x82eb856c
	if !ctx.cr[6].eq {
	pc = 0x82EB856C; continue 'dispatch;
	}
	pc = 0x82EB8594; continue 'dispatch;
            }
            0x82EB8594 => {
    //   block [0x82EB8594..0x82EB85C0)
	// 82EB8594: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8598: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB859C: 1D2A000C  mulli r9, r10, 0xc
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB85A0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB85A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82EB85A8: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB85AC: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB85B0: 912B0198  stw r9, 0x198(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(408 as u32), ctx.r[9].u32 ) };
	// 82EB85B4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB85B8: 4BFFDD59  bl 0x82eb6310
	ctx.lr = 0x82EB85BC;
	sub_82EB6310(ctx, base);
	// 82EB85BC: 48000554  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB85C0 => {
    //   block [0x82EB85C0..0x82EB85F8)
	// 82EB85C0: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB85C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB85C8: 419800A8  blt cr6, 0x82eb8670
	if ctx.cr[6].lt {
	pc = 0x82EB8670; continue 'dispatch;
	}
	// 82EB85CC: 419A00A4  beq cr6, 0x82eb8670
	if ctx.cr[6].eq {
	pc = 0x82EB8670; continue 'dispatch;
	}
	// 82EB85D0: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB85D4: 480199CD  bl 0x82ed1fa0
	ctx.lr = 0x82EB85D8;
	sub_82ED1FA0(ctx, base);
	// 82EB85D8: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB85DC: 3B7E0014  addi r27, r30, 0x14
	ctx.r[27].s64 = ctx.r[30].s64 + 20;
	// 82EB85E0: 835F0054  lwz r26, 0x54(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB85E4: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EB85E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB85EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB85F0: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB85F4: 41820034  beq 0x82eb8628
	if ctx.cr[0].eq {
	pc = 0x82EB8628; continue 'dispatch;
	}
	pc = 0x82EB85F8; continue 'dispatch;
            }
            0x82EB85F8 => {
    //   block [0x82EB85F8..0x82EB8628)
	// 82EB85F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB85FC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8600: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8604: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8608: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB860C: 4801A73D  bl 0x82ed2d48
	ctx.lr = 0x82EB8610;
	sub_82ED2D48(ctx, base);
	// 82EB8610: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB8614: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8618: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB861C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EB8620: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8624: 4198FFD4  blt cr6, 0x82eb85f8
	if ctx.cr[6].lt {
	pc = 0x82EB85F8; continue 'dispatch;
	}
	pc = 0x82EB8628; continue 'dispatch;
            }
            0x82EB8628 => {
    //   block [0x82EB8628..0x82EB863C)
	// 82EB8628: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB862C: 3B9D0014  addi r28, r29, 0x14
	ctx.r[28].s64 = ctx.r[29].s64 + 20;
	// 82EB8630: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EB8634: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8638: 41820190  beq 0x82eb87c8
	if ctx.cr[0].eq {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	pc = 0x82EB863C; continue 'dispatch;
            }
            0x82EB863C => {
    //   block [0x82EB863C..0x82EB8670)
	// 82EB863C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8640: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8644: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8648: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB864C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8650: 4801A6F9  bl 0x82ed2d48
	ctx.lr = 0x82EB8654;
	sub_82ED2D48(ctx, base);
	// 82EB8654: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB8658: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB865C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB8660: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82EB8664: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8668: 4198FFD4  blt cr6, 0x82eb863c
	if ctx.cr[6].lt {
	pc = 0x82EB863C; continue 'dispatch;
	}
	// 82EB866C: 4800015C  b 0x82eb87c8
	pc = 0x82EB87C8; continue 'dispatch;
            }
            0x82EB8670 => {
    //   block [0x82EB8670..0x82EB8698)
	// 82EB8670: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8674: 4801992D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8678;
	sub_82ED1FA0(ctx, base);
	// 82EB8678: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB867C: 3B7E0014  addi r27, r30, 0x14
	ctx.r[27].s64 = ctx.r[30].s64 + 20;
	// 82EB8680: 835F0054  lwz r26, 0x54(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8684: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82EB8688: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB868C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8690: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB8694: 41820034  beq 0x82eb86c8
	if ctx.cr[0].eq {
	pc = 0x82EB86C8; continue 'dispatch;
	}
	pc = 0x82EB8698; continue 'dispatch;
            }
            0x82EB8698 => {
    //   block [0x82EB8698..0x82EB86C8)
	// 82EB8698: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB869C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB86A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB86A4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB86A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB86AC: 4801A69D  bl 0x82ed2d48
	ctx.lr = 0x82EB86B0;
	sub_82ED2D48(ctx, base);
	// 82EB86B0: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB86B4: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB86B8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB86BC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EB86C0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB86C4: 4198FFD4  blt cr6, 0x82eb8698
	if ctx.cr[6].lt {
	pc = 0x82EB8698; continue 'dispatch;
	}
	pc = 0x82EB86C8; continue 'dispatch;
            }
            0x82EB86C8 => {
    //   block [0x82EB86C8..0x82EB8798)
	// 82EB86C8: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB86CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB86D0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB86D4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB86D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB86DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB86E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB86E4: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82EB86E8: 4801A661  bl 0x82ed2d48
	ctx.lr = 0x82EB86EC;
	sub_82ED2D48(ctx, base);
	// 82EB86EC: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB86F0: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB86F4: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB86F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB86FC: 409800CC  bge cr6, 0x82eb87c8
	if !ctx.cr[6].lt {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB8700: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8704: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB870C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82EB8710: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB8714: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82EB8718: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82EB871C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8720: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EB8724: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB8728: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EB872C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB8730: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB8734: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8738: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB873C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EB8740: C02B4DDC  lfs f1, 0x4ddc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19932 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EB8744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8748: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB874C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8750: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB8754: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8758: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB875C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB8760: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8764: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EB8768: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB876C: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8770: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EB8774: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8778: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EB877C: A0DE0010  lhz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8780: 48019919  bl 0x82ed2098
	ctx.lr = 0x82EB8784;
	sub_82ED2098(ctx, base);
	// 82EB8784: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8788: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82EB878C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8790: 419A0038  beq cr6, 0x82eb87c8
	if ctx.cr[6].eq {
	pc = 0x82EB87C8; continue 'dispatch;
	}
	// 82EB8794: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	pc = 0x82EB8798; continue 'dispatch;
            }
            0x82EB8798 => {
    //   block [0x82EB8798..0x82EB87C8)
	// 82EB8798: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB879C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB87A0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB87A4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB87A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB87AC: 4801A59D  bl 0x82ed2d48
	ctx.lr = 0x82EB87B0;
	sub_82ED2D48(ctx, base);
	// 82EB87B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB87B4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EB87B8: 907A01B0  stw r3, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[3].u32 ) };
	// 82EB87BC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82EB87C0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB87C4: 4198FFD4  blt cr6, 0x82eb8798
	if ctx.cr[6].lt {
	pc = 0x82EB8798; continue 'dispatch;
	}
	pc = 0x82EB87C8; continue 'dispatch;
            }
            0x82EB87C8 => {
    //   block [0x82EB87C8..0x82EB87D4)
	// 82EB87C8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB87CC: 480197F5  bl 0x82ed1fc0
	ctx.lr = 0x82EB87D0;
	sub_82ED1FC0(ctx, base);
	// 82EB87D0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82EB87D4; continue 'dispatch;
            }
            0x82EB87D4 => {
    //   block [0x82EB87D4..0x82EB87DC)
	// 82EB87D4: 930B01AC  stw r24, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[24].u32 ) };
	// 82EB87D8: 48000338  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB87DC => {
    //   block [0x82EB87DC..0x82EB8804)
	// 82EB87DC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB87E0: 409A0050  bne cr6, 0x82eb8830
	if !ctx.cr[6].eq {
	pc = 0x82EB8830; continue 'dispatch;
	}
	// 82EB87E4: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB87E8: 4801B069  bl 0x82ed3850
	ctx.lr = 0x82EB87EC;
	sub_82ED3850(ctx, base);
	// 82EB87EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB87F0: 41820014  beq 0x82eb8804
	if ctx.cr[0].eq {
	pc = 0x82EB8804; continue 'dispatch;
	}
	// 82EB87F4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB87F8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EB87FC: 914B01AC  stw r10, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[10].u32 ) };
	// 82EB8800: 48000310  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB8804 => {
    //   block [0x82EB8804..0x82EB8830)
	// 82EB8804: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8808: 4801B0A1  bl 0x82ed38a8
	ctx.lr = 0x82EB880C;
	sub_82ED38A8(ctx, base);
	// 82EB880C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8810: 41820300  beq 0x82eb8b10
	if ctx.cr[0].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8814: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8818: 92EB01AC  stw r23, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[23].u32 ) };
	// 82EB881C: 809C01B0  lwz r4, 0x1b0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8820: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8824: 4801A70D  bl 0x82ed2f30
	ctx.lr = 0x82EB8828;
	sub_82ED2F30(ctx, base);
	// 82EB8828: 92FC01B0  stw r23, 0x1b0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(432 as u32), ctx.r[23].u32 ) };
	// 82EB882C: 480002E4  b 0x82eb8b10
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB8830 => {
    //   block [0x82EB8830..0x82EB88A0)
	// 82EB8830: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB8834: 409A02DC  bne cr6, 0x82eb8b10
	if !ctx.cr[6].eq {
	pc = 0x82EB8B10; continue 'dispatch;
	}
	// 82EB8838: 807C01B0  lwz r3, 0x1b0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB883C: 4801B015  bl 0x82ed3850
	ctx.lr = 0x82EB8840;
	sub_82ED3850(ctx, base);
	// 82EB8840: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8844: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8848: 4182FF8C  beq 0x82eb87d4
	if ctx.cr[0].eq {
	pc = 0x82EB87D4; continue 'dispatch;
	}
	// 82EB884C: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8850: 836B01B0  lwz r27, 0x1b0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EB8854: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82EB8858: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB885C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB8860: 7FAA582E  lwzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8864: A13D0012  lhz r9, 0x12(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8868: A15D0010  lhz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB886C: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8870: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB8874: 7F89EA14  add r28, r9, r29
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 82EB8878: A13C0010  lhz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB887C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB8880: 409800DC  bge cr6, 0x82eb895c
	if !ctx.cr[6].lt {
	pc = 0x82EB895C; continue 'dispatch;
	}
	// 82EB8884: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8888: 4801B051  bl 0x82ed38d8
	ctx.lr = 0x82EB888C;
	sub_82ED38D8(ctx, base);
	// 82EB888C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8890: 4801D009  bl 0x82ed5898
	ctx.lr = 0x82EB8894;
	sub_82ED5898(ctx, base);
	// 82EB8894: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB8898: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB889C: 409A0014  bne cr6, 0x82eb88b0
	if !ctx.cr[6].eq {
	pc = 0x82EB88B0; continue 'dispatch;
	}
	pc = 0x82EB88A0; continue 'dispatch;
            }
            0x82EB88A0 => {
    //   block [0x82EB88A0..0x82EB88B0)
	// 82EB88A0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB88A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB88A8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB88AC: 48000268  b 0x82eb8b14
	pc = 0x82EB8B14; continue 'dispatch;
            }
            0x82EB88B0 => {
    //   block [0x82EB88B0..0x82EB88C4)
	// 82EB88B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB88B4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB88B8: 4801B021  bl 0x82ed38d8
	ctx.lr = 0x82EB88BC;
	sub_82ED38D8(ctx, base);
	// 82EB88BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB88C0: 4082000C  bne 0x82eb88cc
	if !ctx.cr[0].eq {
	pc = 0x82EB88CC; continue 'dispatch;
	}
	pc = 0x82EB88C4; continue 'dispatch;
            }
            0x82EB88C4 => {
    //   block [0x82EB88C4..0x82EB88CC)
	// 82EB88C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB88C8: 4800024C  b 0x82eb8b14
	pc = 0x82EB8B14; continue 'dispatch;
            }
            0x82EB88CC => {
    //   block [0x82EB88CC..0x82EB8938)
	// 82EB88CC: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB88D0: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82EB88D4: 419AFFF0  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB88D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB88DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB88E0: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB88E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB88E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB88EC: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB88F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB88F4: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB88F8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB88FC: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8900: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB8904: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB8908: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB890C: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB8910: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB8914: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB8918: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB891C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB8920: A11D0010  lhz r8, 0x10(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8924: 4BFFDC85  bl 0x82eb65a8
	ctx.lr = 0x82EB8928;
	sub_82EB65A8(ctx, base);
	// 82EB8928: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB892C: 419AFF98  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8930: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8934: 408101C0  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	pc = 0x82EB8938; continue 'dispatch;
            }
            0x82EB8938 => {
    //   block [0x82EB8938..0x82EB895C)
	// 82EB8938: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB893C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8940: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8944: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8948: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB894C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8950: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8954: 4082FFE4  bne 0x82eb8938
	if !ctx.cr[0].eq {
	pc = 0x82EB8938; continue 'dispatch;
	}
	// 82EB8958: 4800019C  b 0x82eb8af4
	pc = 0x82EB8AF4; continue 'dispatch;
            }
            0x82EB895C => {
    //   block [0x82EB895C..0x82EB8A18)
	// 82EB895C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8960: 409A00DC  bne cr6, 0x82eb8a3c
	if !ctx.cr[6].eq {
	pc = 0x82EB8A3C; continue 'dispatch;
	}
	// 82EB8964: 4801AF75  bl 0x82ed38d8
	ctx.lr = 0x82EB8968;
	sub_82ED38D8(ctx, base);
	// 82EB8968: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB896C: 4182FF34  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8970: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8974: 4801CF25  bl 0x82ed5898
	ctx.lr = 0x82EB8978;
	sub_82ED5898(ctx, base);
	// 82EB8978: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB897C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB8980: 419AFF20  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8984: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8988: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB898C: 4801AF4D  bl 0x82ed38d8
	ctx.lr = 0x82EB8990;
	sub_82ED38D8(ctx, base);
	// 82EB8990: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8994: 4182FF0C  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB899C: 4801CEFD  bl 0x82ed5898
	ctx.lr = 0x82EB89A0;
	sub_82ED5898(ctx, base);
	// 82EB89A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EB89A4: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 82EB89A8: 419AFEF8  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB89AC: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EB89B0: 419AFEF0  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB89B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB89B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB89BC: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB89C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB89C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB89C8: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB89CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB89D0: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB89D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB89D8: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB89DC: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB89E0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB89E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB89E8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB89EC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB89F0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB89F4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB89F8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB89FC: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8A00: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 82EB8A04: 4BFFDBA5  bl 0x82eb65a8
	ctx.lr = 0x82EB8A08;
	sub_82EB65A8(ctx, base);
	// 82EB8A08: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB8A0C: 419AFE94  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A10: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A14: 408100E0  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	pc = 0x82EB8A18; continue 'dispatch;
            }
            0x82EB8A18 => {
    //   block [0x82EB8A18..0x82EB8A3C)
	// 82EB8A18: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8A1C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A20: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8A24: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8A28: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB8A2C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8A30: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8A34: 4082FFE4  bne 0x82eb8a18
	if !ctx.cr[0].eq {
	pc = 0x82EB8A18; continue 'dispatch;
	}
	// 82EB8A38: 480000BC  b 0x82eb8af4
	pc = 0x82EB8AF4; continue 'dispatch;
            }
            0x82EB8A3C => {
    //   block [0x82EB8A3C..0x82EB8AD4)
	// 82EB8A3C: 4801AE9D  bl 0x82ed38d8
	ctx.lr = 0x82EB8A40;
	sub_82ED38D8(ctx, base);
	// 82EB8A40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8A44: 4182FE5C  beq 0x82eb88a0
	if ctx.cr[0].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8A4C: 4801CE4D  bl 0x82ed5898
	ctx.lr = 0x82EB8A50;
	sub_82ED5898(ctx, base);
	// 82EB8A50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB8A54: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB8A58: 419AFE48  beq cr6, 0x82eb88a0
	if ctx.cr[6].eq {
	pc = 0x82EB88A0; continue 'dispatch;
	}
	// 82EB8A5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EB8A60: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8A64: 4801AE75  bl 0x82ed38d8
	ctx.lr = 0x82EB8A68;
	sub_82ED38D8(ctx, base);
	// 82EB8A68: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8A6C: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EB8A70: 419AFE54  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8A74: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8A78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB8A7C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB8A80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB8A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8A88: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8A8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB8A90: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB8A94: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8A98: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB8A9C: 814B0198  lwz r10, 0x198(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB8AA0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB8AA4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB8AA8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 82EB8AAC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB8AB0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EB8AB4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EB8AB8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EB8ABC: A11C0010  lhz r8, 0x10(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB8AC0: 4BFFDAE9  bl 0x82eb65a8
	ctx.lr = 0x82EB8AC4;
	sub_82EB65A8(ctx, base);
	// 82EB8AC4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82EB8AC8: 419AFDFC  beq cr6, 0x82eb88c4
	if ctx.cr[6].eq {
	pc = 0x82EB88C4; continue 'dispatch;
	}
	// 82EB8ACC: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8AD0: 40810024  ble 0x82eb8af4
	if !ctx.cr[0].gt {
	pc = 0x82EB8AF4; continue 'dispatch;
	}
	pc = 0x82EB8AD4; continue 'dispatch;
            }
            0x82EB8AD4 => {
    //   block [0x82EB8AD4..0x82EB8AF4)
	// 82EB8AD4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB8AD8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8ADC: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB8AE0: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB8AE4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB8AE8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB8AEC: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EB8AF0: 4082FFE4  bne 0x82eb8ad4
	if !ctx.cr[0].eq {
	pc = 0x82EB8AD4; continue 'dispatch;
	}
	pc = 0x82EB8AF4; continue 'dispatch;
            }
            0x82EB8AF4 => {
    //   block [0x82EB8AF4..0x82EB8B10)
	// 82EB8AF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EB8AF8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8AFC: 4801A435  bl 0x82ed2f30
	ctx.lr = 0x82EB8B00;
	sub_82ED2F30(ctx, base);
	// 82EB8B00: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8B04: 92EB01B0  stw r23, 0x1b0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(432 as u32), ctx.r[23].u32 ) };
	// 82EB8B08: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB8B0C: 92EB01AC  stw r23, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[23].u32 ) };
	pc = 0x82EB8B10; continue 'dispatch;
            }
            0x82EB8B10 => {
    //   block [0x82EB8B10..0x82EB8B14)
	// 82EB8B10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB8B14; continue 'dispatch;
            }
            0x82EB8B14 => {
    //   block [0x82EB8B14..0x82EB8B20)
	// 82EB8B14: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82EB8B18: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EB8B1C: 4BDF0928  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB8B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB8B20 size=1716
    let mut pc: u32 = 0x82EB8B20;
    'dispatch: loop {
        match pc {
            0x82EB8B20 => {
    //   block [0x82EB8B20..0x82EB8B90)
	// 82EB8B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB8B24: 4BDF08BD  bl 0x82ca93e0
	ctx.lr = 0x82EB8B28;
	sub_82CA93D0(ctx, base);
	// 82EB8B28: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 82EB8B2C: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82EB8B30: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82EB8B34: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB8B38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB8B3C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EB8B40: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82EB8B44: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 82EB8B48: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EB8B4C: 827F0058  lwz r19, 0x58(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB8B50: 2C130000  cmpwi r19, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB8B54: 40820114  bne 0x82eb8c68
	if !ctx.cr[0].eq {
	pc = 0x82EB8C68; continue 'dispatch;
	}
	// 82EB8B58: 3BB20004  addi r29, r18, 4
	ctx.r[29].s64 = ctx.r[18].s64 + 4;
	// 82EB8B5C: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B60: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B68: 409A0028  bne cr6, 0x82eb8b90
	if !ctx.cr[6].eq {
	pc = 0x82EB8B90; continue 'dispatch;
	}
	// 82EB8B6C: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B70: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B78: 409A0018  bne cr6, 0x82eb8b90
	if !ctx.cr[6].eq {
	pc = 0x82EB8B90; continue 'dispatch;
	}
	// 82EB8B7C: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8B80: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 82EB8B84: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8B88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB8B8C: 419A0008  beq cr6, 0x82eb8b94
	if ctx.cr[6].eq {
	pc = 0x82EB8B94; continue 'dispatch;
	}
	pc = 0x82EB8B90; continue 'dispatch;
            }
            0x82EB8B90 => {
    //   block [0x82EB8B90..0x82EB8B94)
	// 82EB8B90: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82EB8B94; continue 'dispatch;
            }
            0x82EB8B94 => {
    //   block [0x82EB8B94..0x82EB8BA4)
	// 82EB8B94: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8B98: 4182000C  beq 0x82eb8ba4
	if ctx.cr[0].eq {
	pc = 0x82EB8BA4; continue 'dispatch;
	}
	// 82EB8B9C: 92DF0058  stw r22, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82EB8BA0: 4800061C  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
            }
            0x82EB8BA4 => {
    //   block [0x82EB8BA4..0x82EB8BD8)
	// 82EB8BA4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8BA8: 81630294  lwz r11, 0x294(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82EB8BAC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EB8BB0: 409A060C  bne cr6, 0x82eb91bc
	if !ctx.cr[6].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8BB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB8BB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB8BBC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8BC0: 48019C71  bl 0x82ed2830
	ctx.lr = 0x82EB8BC4;
	sub_82ED2830(ctx, base);
	// 82EB8BC4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB8BC8: 40820010  bne 0x82eb8bd8
	if !ctx.cr[0].eq {
	pc = 0x82EB8BD8; continue 'dispatch;
	}
	// 82EB8BCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB8BD0: 929F0198  stw r20, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[20].u32 ) };
	// 82EB8BD4: 480005EC  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
            }
            0x82EB8BD8 => {
    //   block [0x82EB8BD8..0x82EB8C2C)
	// 82EB8BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB8BDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8BE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8BE4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8BE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8BEC: C3EBBE10  lfs f31, -0x41f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EB8BF0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8BF4: 4801A155  bl 0x82ed2d48
	ctx.lr = 0x82EB8BF8;
	sub_82ED2D48(ctx, base);
	// 82EB8BF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EB8BFC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8C00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EB8C04: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 82EB8C08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EB8C0C: 92DF00F0  stw r22, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[22].u32 ) };
	// 82EB8C10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB8C14: 9ADF00AC  stb r22, 0xac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[22].u8 ) };
	// 82EB8C18: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82EB8C1C: 48019C15  bl 0x82ed2830
	ctx.lr = 0x82EB8C20;
	sub_82ED2830(ctx, base);
	// 82EB8C20: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EB8C24: 40820014  bne 0x82eb8c38
	if !ctx.cr[0].eq {
	pc = 0x82EB8C38; continue 'dispatch;
	}
	// 82EB8C28: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82EB8C2C; continue 'dispatch;
            }
            0x82EB8C2C => {
    //   block [0x82EB8C2C..0x82EB8C38)
	// 82EB8C2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB8C30: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB8C34: 4800058C  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
            }
            0x82EB8C38 => {
    //   block [0x82EB8C38..0x82EB8C68)
	// 82EB8C38: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8C3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8C40: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8C44: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB8C4C: 4801A0FD  bl 0x82ed2d48
	ctx.lr = 0x82EB8C50;
	sub_82ED2D48(ctx, base);
	// 82EB8C50: 907F0108  stw r3, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82EB8C54: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 82EB8C58: 92DF0150  stw r22, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[22].u32 ) };
	// 82EB8C5C: 9ADF010C  stb r22, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[22].u8 ) };
	// 82EB8C60: 92DF0050  stw r22, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82EB8C64: 929F0058  stw r20, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	pc = 0x82EB8C68; continue 'dispatch;
            }
            0x82EB8C68 => {
    //   block [0x82EB8C68..0x82EB8CC8)
	// 82EB8C68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8C6C: 3AA00003  li r21, 3
	ctx.r[21].s64 = 3;
	// 82EB8C70: 2F130001  cmpwi cr6, r19, 1
	ctx.cr[6].compare_i32(ctx.r[19].s32, 1, &mut ctx.xer);
	// 82EB8C74: C3AB0C4C  lfs f29, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EB8C78: 409A0210  bne cr6, 0x82eb8e88
	if !ctx.cr[6].eq {
	pc = 0x82EB8E88; continue 'dispatch;
	}
	// 82EB8C7C: 3B320004  addi r25, r18, 4
	ctx.r[25].s64 = ctx.r[18].s64 + 4;
	// 82EB8C80: C1B80008  lfs f13, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8C84: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8C88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB8C8C: C1980000  lfs f12, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EB8C90: 83BF0050  lwz r29, 0x50(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8C94: 3AFF005C  addi r23, r31, 0x5c
	ctx.r[23].s64 = ctx.r[31].s64 + 92;
	// 82EB8C98: C1590008  lfs f10, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EB8C9C: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EB8CA0: C1790004  lfs f11, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB8CA4: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EB8CA8: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EB8CAC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EB8CB0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EB8CB4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EB8CB8: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB8CBC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EB8CC0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EB8CC4: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82EB8CC8; continue 'dispatch;
            }
            0x82EB8CC8 => {
    //   block [0x82EB8CC8..0x82EB8D68)
	// 82EB8CC8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 82EB8CCC: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EB8CD0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EB8CD4: 811F0060  lwz r8, 0x60(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB8CD8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EB8CDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8CE0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8CE4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB8CE8: 92D70000  stw r22, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 82EB8CEC: 9AC10057  stb r22, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[22].u8 ) };
	// 82EB8CF0: 4801A499  bl 0x82ed3188
	ctx.lr = 0x82EB8CF4;
	sub_82ED3188(ctx, base);
	// 82EB8CF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EB8CF8: 419A016C  beq cr6, 0x82eb8e64
	if ctx.cr[6].eq {
	pc = 0x82EB8E64; continue 'dispatch;
	}
	// 82EB8CFC: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 82EB8D00: 1D7D0060  mulli r11, r29, 0x60
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB8D04: 79490020  clrldi r9, r10, 0x20
	ctx.r[9].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82EB8D08: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB8D0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8D10: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB8D14: 3B7E00F0  addi r27, r30, 0xf0
	ctx.r[27].s64 = ctx.r[30].s64 + 240;
	// 82EB8D18: 3B5E00B0  addi r26, r30, 0xb0
	ctx.r[26].s64 = ctx.r[30].s64 + 176;
	// 82EB8D1C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 82EB8D20: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB8D24: 92DE00F0  stw r22, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[22].u32 ) };
	// 82EB8D28: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8D2C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EB8D30: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D34: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EB8D38: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EB8D3C: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EB8D40: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82EB8D44: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82EB8D48: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8D4C: 4801934D  bl 0x82ed2098
	ctx.lr = 0x82EB8D50;
	sub_82ED2098(ctx, base);
	// 82EB8D50: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D54: 4801924D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8D58;
	sub_82ED1FA0(ctx, base);
	// 82EB8D58: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 82EB8D5C: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB8D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8D64: 40990034  ble cr6, 0x82eb8d98
	if !ctx.cr[6].gt {
	pc = 0x82EB8D98; continue 'dispatch;
	}
	pc = 0x82EB8D68; continue 'dispatch;
            }
            0x82EB8D68 => {
    //   block [0x82EB8D68..0x82EB8D98)
	// 82EB8D68: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8D6C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8D70: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8D74: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D78: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8D7C: 48019FCD  bl 0x82ed2d48
	ctx.lr = 0x82EB8D80;
	sub_82ED2D48(ctx, base);
	// 82EB8D80: 907E00A8  stw r3, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[3].u32 ) };
	// 82EB8D84: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8D88: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8D8C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EB8D90: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8D94: 4198FFD4  blt cr6, 0x82eb8d68
	if ctx.cr[6].lt {
	pc = 0x82EB8D68; continue 'dispatch;
	}
	pc = 0x82EB8D98; continue 'dispatch;
            }
            0x82EB8D98 => {
    //   block [0x82EB8D98..0x82EB8DF4)
	// 82EB8D98: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8D9C: 48019225  bl 0x82ed1fc0
	ctx.lr = 0x82EB8DA0;
	sub_82ED1FC0(ctx, base);
	// 82EB8DA0: 3B7E0150  addi r27, r30, 0x150
	ctx.r[27].s64 = ctx.r[30].s64 + 336;
	// 82EB8DA4: 92DE00A4  stw r22, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[22].u32 ) };
	// 82EB8DA8: 3B5E0110  addi r26, r30, 0x110
	ctx.r[26].s64 = ctx.r[30].s64 + 272;
	// 82EB8DAC: 9ADE00AC  stb r22, 0xac(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[22].u8 ) };
	// 82EB8DB0: 92DE0150  stw r22, 0x150(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(336 as u32), ctx.r[22].u32 ) };
	// 82EB8DB4: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB8DB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB8DBC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8DC0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB8DC4: EC3E0032  fmuls f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EB8DC8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EB8DCC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EB8DD0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EB8DD4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EB8DD8: 480192C1  bl 0x82ed2098
	ctx.lr = 0x82EB8DDC;
	sub_82ED2098(ctx, base);
	// 82EB8DDC: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8DE0: 480191C1  bl 0x82ed1fa0
	ctx.lr = 0x82EB8DE4;
	sub_82ED1FA0(ctx, base);
	// 82EB8DE4: 817E0150  lwz r11, 0x150(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82EB8DE8: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 82EB8DEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8DF0: 40990034  ble cr6, 0x82eb8e24
	if !ctx.cr[6].gt {
	pc = 0x82EB8E24; continue 'dispatch;
	}
	pc = 0x82EB8DF4; continue 'dispatch;
            }
            0x82EB8DF4 => {
    //   block [0x82EB8DF4..0x82EB8E24)
	// 82EB8DF4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8DF8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8DFC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8E00: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E04: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8E08: 48019F41  bl 0x82ed2d48
	ctx.lr = 0x82EB8E0C;
	sub_82ED2D48(ctx, base);
	// 82EB8E0C: 907E0108  stw r3, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 82EB8E10: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E14: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82EB8E18: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82EB8E1C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8E20: 4198FFD4  blt cr6, 0x82eb8df4
	if ctx.cr[6].lt {
	pc = 0x82EB8DF4; continue 'dispatch;
	}
	pc = 0x82EB8E24; continue 'dispatch;
            }
            0x82EB8E24 => {
    //   block [0x82EB8E24..0x82EB8E3C)
	// 82EB8E24: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E28: 48019199  bl 0x82ed1fc0
	ctx.lr = 0x82EB8E2C;
	sub_82ED1FC0(ctx, base);
	// 82EB8E2C: 92DE0104  stw r22, 0x104(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(260 as u32), ctx.r[22].u32 ) };
	// 82EB8E30: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EB8E34: 9ADE010C  stb r22, 0x10c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(268 as u32), ctx.r[22].u8 ) };
	// 82EB8E38: 80B70000  lwz r5, 0(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82EB8E3C; continue 'dispatch;
            }
            0x82EB8E3C => {
    //   block [0x82EB8E3C..0x82EB8E54)
	// 82EB8E3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8E40: 480190C9  bl 0x82ed1f08
	ctx.lr = 0x82EB8E44;
	sub_82ED1F08(ctx, base);
	// 82EB8E44: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E48: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82EB8E4C: 40990008  ble cr6, 0x82eb8e54
	if !ctx.cr[6].gt {
	pc = 0x82EB8E54; continue 'dispatch;
	}
	// 82EB8E50: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x82EB8E54; continue 'dispatch;
            }
            0x82EB8E54 => {
    //   block [0x82EB8E54..0x82EB8E64)
	// 82EB8E54: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82EB8E58: 40990018  ble cr6, 0x82eb8e70
	if !ctx.cr[6].gt {
	pc = 0x82EB8E70; continue 'dispatch;
	}
	// 82EB8E5C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8E60: 4BFFFE68  b 0x82eb8cc8
	pc = 0x82EB8CC8; continue 'dispatch;
            }
            0x82EB8E64 => {
    //   block [0x82EB8E64..0x82EB8E70)
	// 82EB8E64: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8E68: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82EB8E6C: 4BFFFFD0  b 0x82eb8e3c
	pc = 0x82EB8E3C; continue 'dispatch;
            }
            0x82EB8E70 => {
    //   block [0x82EB8E70..0x82EB8E88)
	// 82EB8E70: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB8E74: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EB8E78: 93BF0168  stw r29, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[29].u32 ) };
	// 82EB8E7C: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB8E80: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82EB8E84: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB8E88; continue 'dispatch;
            }
            0x82EB8E88 => {
    //   block [0x82EB8E88..0x82EB8EC0)
	// 82EB8E88: 2F130002  cmpwi cr6, r19, 2
	ctx.cr[6].compare_i32(ctx.r[19].s32, 2, &mut ctx.xer);
	// 82EB8E8C: 409A0084  bne cr6, 0x82eb8f10
	if !ctx.cr[6].eq {
	pc = 0x82EB8F10; continue 'dispatch;
	}
	// 82EB8E90: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82EB8E94: 3BBF016C  addi r29, r31, 0x16c
	ctx.r[29].s64 = ctx.r[31].s64 + 364;
	// 82EB8E98: 815F0168  lwz r10, 0x168(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8E9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB8EA0: 41990020  bgt cr6, 0x82eb8ec0
	if ctx.cr[6].gt {
	pc = 0x82EB8EC0; continue 'dispatch;
	}
	// 82EB8EA4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EB8EA8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82EB8EAC: 38DF0170  addi r6, r31, 0x170
	ctx.r[6].s64 = ctx.r[31].s64 + 368;
	// 82EB8EB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB8EB4: 389F00A4  addi r4, r31, 0xa4
	ctx.r[4].s64 = ctx.r[31].s64 + 164;
	// 82EB8EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8EBC: 4BFFECC5  bl 0x82eb7b80
	ctx.lr = 0x82EB8EC0;
	sub_82EB7B80(ctx, base);
	pc = 0x82EB8EC0; continue 'dispatch;
            }
            0x82EB8EC0 => {
    //   block [0x82EB8EC0..0x82EB8EF0)
	// 82EB8EC0: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82EB8EC4: 3BDF0174  addi r30, r31, 0x174
	ctx.r[30].s64 = ctx.r[31].s64 + 372;
	// 82EB8EC8: 815F0168  lwz r10, 0x168(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8ECC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB8ED0: 41990020  bgt cr6, 0x82eb8ef0
	if ctx.cr[6].gt {
	pc = 0x82EB8EF0; continue 'dispatch;
	}
	// 82EB8ED4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB8ED8: 38F20004  addi r7, r18, 4
	ctx.r[7].s64 = ctx.r[18].s64 + 4;
	// 82EB8EDC: 38DF0178  addi r6, r31, 0x178
	ctx.r[6].s64 = ctx.r[31].s64 + 376;
	// 82EB8EE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB8EE4: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82EB8EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB8EEC: 4BFFEC95  bl 0x82eb7b80
	ctx.lr = 0x82EB8EF0;
	sub_82EB7B80(ctx, base);
	pc = 0x82EB8EF0; continue 'dispatch;
            }
            0x82EB8EF0 => {
    //   block [0x82EB8EF0..0x82EB8F10)
	// 82EB8EF0: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB8EF4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8EF8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8EFC: 409902C0  ble cr6, 0x82eb91bc
	if !ctx.cr[6].gt {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8F00: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB8F04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8F08: 409902B4  ble cr6, 0x82eb91bc
	if !ctx.cr[6].gt {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8F0C: 92BF0058  stw r21, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	pc = 0x82EB8F10; continue 'dispatch;
            }
            0x82EB8F10 => {
    //   block [0x82EB8F10..0x82EB8F3C)
	// 82EB8F10: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 82EB8F14: 2F130003  cmpwi cr6, r19, 3
	ctx.cr[6].compare_i32(ctx.r[19].s32, 3, &mut ctx.xer);
	// 82EB8F18: 409A006C  bne cr6, 0x82eb8f84
	if !ctx.cr[6].eq {
	pc = 0x82EB8F84; continue 'dispatch;
	}
	// 82EB8F1C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F20: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB8F24: 4801907D  bl 0x82ed1fa0
	ctx.lr = 0x82EB8F28;
	sub_82ED1FA0(ctx, base);
	// 82EB8F28: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB8F2C: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 82EB8F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB8F34: 40990044  ble cr6, 0x82eb8f78
	if !ctx.cr[6].gt {
	pc = 0x82EB8F78; continue 'dispatch;
	}
	// 82EB8F38: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x82EB8F3C; continue 'dispatch;
            }
            0x82EB8F3C => {
    //   block [0x82EB8F3C..0x82EB8F78)
	// 82EB8F3C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB8F40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB8F44: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB8F48: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F4C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82EB8F50: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB8F54: 48019DF5  bl 0x82ed2d48
	ctx.lr = 0x82EB8F58;
	sub_82ED2D48(ctx, base);
	// 82EB8F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8F5C: 907F017C  stw r3, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[3].u32 ) };
	// 82EB8F60: 41820048  beq 0x82eb8fa8
	if ctx.cr[0].eq {
	pc = 0x82EB8FA8; continue 'dispatch;
	}
	// 82EB8F64: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB8F68: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB8F6C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EB8F70: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB8F74: 4198FFC8  blt cr6, 0x82eb8f3c
	if ctx.cr[6].lt {
	pc = 0x82EB8F3C; continue 'dispatch;
	}
	pc = 0x82EB8F78; continue 'dispatch;
            }
            0x82EB8F78 => {
    //   block [0x82EB8F78..0x82EB8F84)
	// 82EB8F78: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8F7C: 48019045  bl 0x82ed1fc0
	ctx.lr = 0x82EB8F80;
	sub_82ED1FC0(ctx, base);
	// 82EB8F80: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB8F84; continue 'dispatch;
            }
            0x82EB8F84 => {
    //   block [0x82EB8F84..0x82EB8FA8)
	// 82EB8F84: 2F130004  cmpwi cr6, r19, 4
	ctx.cr[6].compare_i32(ctx.r[19].s32, 4, &mut ctx.xer);
	// 82EB8F88: 409A0050  bne cr6, 0x82eb8fd8
	if !ctx.cr[6].eq {
	pc = 0x82EB8FD8; continue 'dispatch;
	}
	// 82EB8F8C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8F90: 4801A8C1  bl 0x82ed3850
	ctx.lr = 0x82EB8F94;
	sub_82ED3850(ctx, base);
	// 82EB8F94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8F98: 41820018  beq 0x82eb8fb0
	if ctx.cr[0].eq {
	pc = 0x82EB8FB0; continue 'dispatch;
	}
	// 82EB8F9C: 3A600007  li r19, 7
	ctx.r[19].s64 = 7;
	// 82EB8FA0: 927F0058  stw r19, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 82EB8FA4: 4800003C  b 0x82eb8fe0
	pc = 0x82EB8FE0; continue 'dispatch;
            }
            0x82EB8FA8 => {
    //   block [0x82EB8FA8..0x82EB8FB0)
	// 82EB8FA8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB8FAC: 4BFFFC80  b 0x82eb8c2c
	pc = 0x82EB8C2C; continue 'dispatch;
            }
            0x82EB8FB0 => {
    //   block [0x82EB8FB0..0x82EB8FD8)
	// 82EB8FB0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FB4: 4801A8F5  bl 0x82ed38a8
	ctx.lr = 0x82EB8FB8;
	sub_82ED38A8(ctx, base);
	// 82EB8FB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8FBC: 41820200  beq 0x82eb91bc
	if ctx.cr[0].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB8FC0: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FC4: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB8FC8: 48019F69  bl 0x82ed2f30
	ctx.lr = 0x82EB8FCC;
	sub_82ED2F30(ctx, base);
	// 82EB8FCC: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB8FD0: 92BF0058  stw r21, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 82EB8FD4: 480001E8  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
            }
            0x82EB8FD8 => {
    //   block [0x82EB8FD8..0x82EB8FE0)
	// 82EB8FD8: 2F130007  cmpwi cr6, r19, 7
	ctx.cr[6].compare_i32(ctx.r[19].s32, 7, &mut ctx.xer);
	// 82EB8FDC: 409A01CC  bne cr6, 0x82eb91a8
	if !ctx.cr[6].eq {
	pc = 0x82EB91A8; continue 'dispatch;
	}
	pc = 0x82EB8FE0; continue 'dispatch;
            }
            0x82EB8FE0 => {
    //   block [0x82EB8FE0..0x82EB9000)
	// 82EB8FE0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB8FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB8FE8: 418201D8  beq 0x82eb91c0
	if ctx.cr[0].eq {
	pc = 0x82EB91C0; continue 'dispatch;
	}
	// 82EB8FEC: 4801A865  bl 0x82ed3850
	ctx.lr = 0x82EB8FF0;
	sub_82ED3850(ctx, base);
	// 82EB8FF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB8FF4: 4082000C  bne 0x82eb9000
	if !ctx.cr[0].eq {
	pc = 0x82EB9000; continue 'dispatch;
	}
	// 82EB8FF8: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB8FFC: 480001C0  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
            }
            0x82EB9000 => {
    //   block [0x82EB9000..0x82EB9020)
	// 82EB9000: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9004: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9008: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB900C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB9010: 808B0100  lwz r4, 0x100(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) } as u64;
	// 82EB9014: 4801A8C5  bl 0x82ed38d8
	ctx.lr = 0x82EB9018;
	sub_82ED38D8(ctx, base);
	// 82EB9018: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB901C: 40820010  bne 0x82eb902c
	if !ctx.cr[0].eq {
	pc = 0x82EB902C; continue 'dispatch;
	}
	pc = 0x82EB9020; continue 'dispatch;
            }
            0x82EB9020 => {
    //   block [0x82EB9020..0x82EB902C)
	// 82EB9020: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9024: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB9028: 48000198  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
            }
            0x82EB902C => {
    //   block [0x82EB902C..0x82EB90B4)
	// 82EB902C: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9030: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9034: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB9038: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB903C: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9040: 808B0160  lwz r4, 0x160(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB9044: 4801A895  bl 0x82ed38d8
	ctx.lr = 0x82EB9048;
	sub_82ED38D8(ctx, base);
	// 82EB9048: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB904C: 4182FFD4  beq 0x82eb9020
	if ctx.cr[0].eq {
	pc = 0x82EB9020; continue 'dispatch;
	}
	// 82EB9050: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9054: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EB9058: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB905C: 811F0168  lwz r8, 0x168(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB9060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9064: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9068: 4BFFD541  bl 0x82eb65a8
	ctx.lr = 0x82EB906C;
	sub_82EB65A8(ctx, base);
	// 82EB906C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9070: 809F017C  lwz r4, 0x17c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82EB9074: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9078: 48019EB9  bl 0x82ed2f30
	ctx.lr = 0x82EB907C;
	sub_82ED2F30(ctx, base);
	// 82EB907C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB9080: 92DF017C  stw r22, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[22].u32 ) };
	// 82EB9084: 409A0038  bne cr6, 0x82eb90bc
	if !ctx.cr[6].eq {
	pc = 0x82EB90BC; continue 'dispatch;
	}
	// 82EB9088: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB908C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9090: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB9094: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EB9098: 48018E21  bl 0x82ed1eb8
	ctx.lr = 0x82EB909C;
	sub_82ED1EB8(ctx, base);
	// 82EB909C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB90A0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB90A4: 40990010  ble cr6, 0x82eb90b4
	if !ctx.cr[6].gt {
	pc = 0x82EB90B4; continue 'dispatch;
	}
	// 82EB90A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB90AC: 92BF0198  stw r21, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[21].u32 ) };
	// 82EB90B0: 48000110  b 0x82eb91c0
	pc = 0x82EB91C0; continue 'dispatch;
            }
            0x82EB90B4 => {
    //   block [0x82EB90B4..0x82EB90BC)
	// 82EB90B4: 929F0058  stw r20, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[20].u32 ) };
	// 82EB90B8: 48000104  b 0x82eb91bc
	pc = 0x82EB91BC; continue 'dispatch;
            }
            0x82EB90BC => {
    //   block [0x82EB90BC..0x82EB90D4)
	// 82EB90BC: 813F0168  lwz r9, 0x168(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82EB90C0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EB90C4: 408100AC  ble 0x82eb9170
	if !ctx.cr[0].gt {
	pc = 0x82EB9170; continue 'dispatch;
	}
	// 82EB90C8: 1D690060  mulli r11, r9, 0x60
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EB90CC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82EB90D0: 394B015C  addi r10, r11, 0x15c
	ctx.r[10].s64 = ctx.r[11].s64 + 348;
	pc = 0x82EB90D4; continue 'dispatch;
            }
            0x82EB90D4 => {
    //   block [0x82EB90D4..0x82EB911C)
	// 82EB90D4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB90D8: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 82EB90DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB90E0: 38EB0014  addi r7, r11, 0x14
	ctx.r[7].s64 = ctx.r[11].s64 + 20;
	// 82EB90E4: B12B0010  sth r9, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u16 ) };
	// 82EB90E8: C00AFFF8  lfs f0, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90EC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB90F0: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB90F8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB90FC: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9100: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9104: B2CB0012  sth r22, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[22].u16 ) };
	// 82EB9108: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EB910C: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EB9110: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82EB9114: 40990034  ble cr6, 0x82eb9148
	if !ctx.cr[6].gt {
	pc = 0x82EB9148; continue 'dispatch;
	}
	// 82EB9118: 38CAFFB4  addi r6, r10, -0x4c
	ctx.r[6].s64 = ctx.r[10].s64 + -76;
	pc = 0x82EB911C; continue 'dispatch;
            }
            0x82EB911C => {
    //   block [0x82EB911C..0x82EB9148)
	// 82EB911C: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9120: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EB9124: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EB9128: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82EB912C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB9130: A0AB0012  lhz r5, 0x12(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB9134: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EB9138: B0AB0012  sth r5, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[5].u16 ) };
	// 82EB913C: 80AAFFF4  lwz r5, -0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EB9140: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82EB9144: 4198FFD8  blt cr6, 0x82eb911c
	if ctx.cr[6].lt {
	pc = 0x82EB911C; continue 'dispatch;
	}
	pc = 0x82EB9148; continue 'dispatch;
            }
            0x82EB9148 => {
    //   block [0x82EB9148..0x82EB9170)
	// 82EB9148: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB914C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EB9150: 394AFFA0  addi r10, r10, -0x60
	ctx.r[10].s64 = ctx.r[10].s64 + -96;
	// 82EB9154: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB9158: A0E80012  lhz r7, 0x12(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB915C: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 82EB9160: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB9164: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82EB9168: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EB916C: 4181FF68  bgt 0x82eb90d4
	if ctx.cr[0].gt {
	pc = 0x82EB90D4; continue 'dispatch;
	}
	pc = 0x82EB9170; continue 'dispatch;
            }
            0x82EB9170 => {
    //   block [0x82EB9170..0x82EB91A8)
	// 82EB9170: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9174: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82EB9178: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB917C: B2CB0010  sth r22, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[22].u16 ) };
	// 82EB9180: C01F0154  lfs f0, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9184: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9188: C01F0158  lfs f0, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB918C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9190: C01F015C  lfs f0, 0x15c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9194: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9198: 813F0160  lwz r9, 0x160(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82EB919C: B2CB0012  sth r22, 0x12(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[22].u16 ) };
	// 82EB91A0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB91A4: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	pc = 0x82EB91A8; continue 'dispatch;
            }
            0x82EB91A8 => {
    //   block [0x82EB91A8..0x82EB91BC)
	// 82EB91A8: 2F130008  cmpwi cr6, r19, 8
	ctx.cr[6].compare_i32(ctx.r[19].s32, 8, &mut ctx.xer);
	// 82EB91AC: 409A0010  bne cr6, 0x82eb91bc
	if !ctx.cr[6].eq {
	pc = 0x82EB91BC; continue 'dispatch;
	}
	// 82EB91B0: 38920004  addi r4, r18, 4
	ctx.r[4].s64 = ctx.r[18].s64 + 4;
	// 82EB91B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB91B8: 4BFFF191  bl 0x82eb8348
	ctx.lr = 0x82EB91BC;
	sub_82EB8348(ctx, base);
	pc = 0x82EB91BC; continue 'dispatch;
            }
            0x82EB91BC => {
    //   block [0x82EB91BC..0x82EB91C0)
	// 82EB91BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB91C0; continue 'dispatch;
            }
            0x82EB91C0 => {
    //   block [0x82EB91C0..0x82EB91D4)
	// 82EB91C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82EB91C4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 82EB91C8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82EB91CC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82EB91D0: 4BDF0260  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB91D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB91D8 size=180
    let mut pc: u32 = 0x82EB91D8;
    'dispatch: loop {
        match pc {
            0x82EB91D8 => {
    //   block [0x82EB91D8..0x82EB9218)
	// 82EB91D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB91DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB91E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB91E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB91E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB91EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB91F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB91F4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB91F8: 4099007C  ble cr6, 0x82eb9274
	if !ctx.cr[6].gt {
	pc = 0x82EB9274; continue 'dispatch;
	}
	// 82EB91FC: 3D603FFF  lis r11, 0x3fff
	ctx.r[11].s64 = 1073676288;
	// 82EB9200: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82EB9204: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EB9208: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EB920C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB9210: 40990008  ble cr6, 0x82eb9218
	if !ctx.cr[6].gt {
	pc = 0x82EB9218; continue 'dispatch;
	}
	// 82EB9214: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EB9218; continue 'dispatch;
            }
            0x82EB9218 => {
    //   block [0x82EB9218..0x82EB9234)
	// 82EB9218: 4B75D711  bl 0x82616928
	ctx.lr = 0x82EB921C;
	sub_82616928(ctx, base);
	// 82EB921C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9220: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9224: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB9228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB922C: 40990028  ble cr6, 0x82eb9254
	if !ctx.cr[6].gt {
	pc = 0x82EB9254; continue 'dispatch;
	}
	// 82EB9230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB9234; continue 'dispatch;
            }
            0x82EB9234 => {
    //   block [0x82EB9234..0x82EB9254)
	// 82EB9234: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB923C: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9240: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82EB9244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB9248: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB924C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9250: 4198FFE4  blt cr6, 0x82eb9234
	if ctx.cr[6].lt {
	pc = 0x82EB9234; continue 'dispatch;
	}
	pc = 0x82EB9254; continue 'dispatch;
            }
            0x82EB9254 => {
    //   block [0x82EB9254..0x82EB9270)
	// 82EB9254: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9258: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB925C: 41820014  beq 0x82eb9270
	if ctx.cr[0].eq {
	pc = 0x82EB9270; continue 'dispatch;
	}
	// 82EB9260: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB9264: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB9268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB926C: 4E800421  bctrl
	ctx.lr = 0x82EB9270;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB9270 => {
    //   block [0x82EB9270..0x82EB9274)
	// 82EB9270: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82EB9274; continue 'dispatch;
            }
            0x82EB9274 => {
    //   block [0x82EB9274..0x82EB928C)
	// 82EB9274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB9278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB927C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB9280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB9284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB9288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB9290 size=240
    let mut pc: u32 = 0x82EB9290;
    'dispatch: loop {
        match pc {
            0x82EB9290 => {
    //   block [0x82EB9290..0x82EB92C4)
	// 82EB9290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9294: 4BDF0179  bl 0x82ca940c
	ctx.lr = 0x82EB9298;
	sub_82CA93D0(ctx, base);
	// 82EB9298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB929C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB92A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EB92A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB92A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB92AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB92B0: 409A00A8  bne cr6, 0x82eb9358
	if !ctx.cr[6].eq {
	pc = 0x82EB9358; continue 'dispatch;
	}
	// 82EB92B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB92B8: 409A000C  bne cr6, 0x82eb92c4
	if !ctx.cr[6].eq {
	pc = 0x82EB92C4; continue 'dispatch;
	}
	// 82EB92BC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EB92C0: 48000008  b 0x82eb92c8
	pc = 0x82EB92C8; continue 'dispatch;
            }
            0x82EB92C4 => {
    //   block [0x82EB92C4..0x82EB92C8)
	// 82EB92C4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82EB92C8; continue 'dispatch;
            }
            0x82EB92C8 => {
    //   block [0x82EB92C8..0x82EB92E8)
	// 82EB92C8: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EB92CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EB92D0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB92D4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82EB92D8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EB92DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EB92E0: 40990008  ble cr6, 0x82eb92e8
	if !ctx.cr[6].gt {
	pc = 0x82EB92E8; continue 'dispatch;
	}
	// 82EB92E4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82EB92E8; continue 'dispatch;
            }
            0x82EB92E8 => {
    //   block [0x82EB92E8..0x82EB9304)
	// 82EB92E8: 4B75D641  bl 0x82616928
	ctx.lr = 0x82EB92EC;
	sub_82616928(ctx, base);
	// 82EB92EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EB92F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB92F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB92F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB92FC: 40990008  ble cr6, 0x82eb9304
	if !ctx.cr[6].gt {
	pc = 0x82EB9304; continue 'dispatch;
	}
	// 82EB9300: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB9304; continue 'dispatch;
            }
            0x82EB9304 => {
    //   block [0x82EB9304..0x82EB9318)
	// 82EB9304: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9308: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EB930C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB9310: 40990028  ble cr6, 0x82eb9338
	if !ctx.cr[6].gt {
	pc = 0x82EB9338; continue 'dispatch;
	}
	// 82EB9314: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EB9318; continue 'dispatch;
            }
            0x82EB9318 => {
    //   block [0x82EB9318..0x82EB9338)
	// 82EB9318: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB931C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB9320: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9324: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82EB9328: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EB932C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9330: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9334: 4198FFE4  blt cr6, 0x82eb9318
	if ctx.cr[6].lt {
	pc = 0x82EB9318; continue 'dispatch;
	}
	pc = 0x82EB9338; continue 'dispatch;
            }
            0x82EB9338 => {
    //   block [0x82EB9338..0x82EB9354)
	// 82EB9338: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB933C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9340: 41820014  beq 0x82eb9354
	if ctx.cr[0].eq {
	pc = 0x82EB9354; continue 'dispatch;
	}
	// 82EB9344: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB9348: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB934C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9350: 4E800421  bctrl
	ctx.lr = 0x82EB9354;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB9354 => {
    //   block [0x82EB9354..0x82EB9358)
	// 82EB9354: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82EB9358; continue 'dispatch;
            }
            0x82EB9358 => {
    //   block [0x82EB9358..0x82EB9380)
	// 82EB9358: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB935C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9360: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9364: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EB9368: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82EB936C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EB9370: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EB9374: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EB9378: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB937C: 4BDF00E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB9380 size=92
    let mut pc: u32 = 0x82EB9380;
    'dispatch: loop {
        match pc {
            0x82EB9380 => {
    //   block [0x82EB9380..0x82EB93BC)
	// 82EB9380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB9388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB938C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9394: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB9398: 396BA8F0  addi r11, r11, -0x5710
	ctx.r[11].s64 = ctx.r[11].s64 + -22288;
	// 82EB939C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB93A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB93A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB93A8: 41820014  beq 0x82eb93bc
	if ctx.cr[0].eq {
	pc = 0x82EB93BC; continue 'dispatch;
	}
	// 82EB93AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB93B0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB93B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB93B8: 4E800421  bctrl
	ctx.lr = 0x82EB93BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB93BC => {
    //   block [0x82EB93BC..0x82EB93DC)
	// 82EB93BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB93C0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB93C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB93C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EB93CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB93D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB93D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB93D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB93E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EB93E0 size=88
    let mut pc: u32 = 0x82EB93E0;
    'dispatch: loop {
        match pc {
            0x82EB93E0 => {
    //   block [0x82EB93E0..0x82EB941C)
	// 82EB93E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB93E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EB93E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EB93EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EB93F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB93F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB93F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EB93FC: 4BFFFF85  bl 0x82eb9380
	ctx.lr = 0x82EB9400;
	sub_82EB9380(ctx, base);
	// 82EB9400: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9404: 41820018  beq 0x82eb941c
	if ctx.cr[0].eq {
	pc = 0x82EB941C; continue 'dispatch;
	}
	// 82EB9408: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EB940C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9410: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EB9414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9418: 4E800421  bctrl
	ctx.lr = 0x82EB941C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EB941C => {
    //   block [0x82EB941C..0x82EB9438)
	// 82EB941C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EB9424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EB9428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EB942C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EB9430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EB9434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9438 size=1716
    let mut pc: u32 = 0x82EB9438;
    'dispatch: loop {
        match pc {
            0x82EB9438 => {
    //   block [0x82EB9438..0x82EB94A4)
	// 82EB9438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB943C: 4BDEFFB9  bl 0x82ca93f4
	ctx.lr = 0x82EB9440;
	sub_82CA93D0(ctx, base);
	// 82EB9440: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EB9444: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB944C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82EB9450: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB9454: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EB9458: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB945C: 837F0058  lwz r27, 0x58(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB9460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB9464: 409A004C  bne cr6, 0x82eb94b0
	if !ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9468: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB946C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9470: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EB9474: 419A003C  beq cr6, 0x82eb94b0
	if ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EB947C: 419A0034  beq cr6, 0x82eb94b0
	if ctx.cr[6].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB9480: 4801A3D1  bl 0x82ed3850
	ctx.lr = 0x82EB9484;
	sub_82ED3850(ctx, base);
	// 82EB9484: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9488: 41820028  beq 0x82eb94b0
	if ctx.cr[0].eq {
	pc = 0x82EB94B0; continue 'dispatch;
	}
	// 82EB948C: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9490: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9494: 41820010  beq 0x82eb94a4
	if ctx.cr[0].eq {
	pc = 0x82EB94A4; continue 'dispatch;
	}
	// 82EB9498: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB949C: 48019A95  bl 0x82ed2f30
	ctx.lr = 0x82EB94A0;
	sub_82ED2F30(ctx, base);
	// 82EB94A0: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB94A4; continue 'dispatch;
            }
            0x82EB94A4 => {
    //   block [0x82EB94A4..0x82EB94B0)
	// 82EB94A4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EB94A8: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82EB94AC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB94B0; continue 'dispatch;
            }
            0x82EB94B0 => {
    //   block [0x82EB94B0..0x82EB94EC)
	// 82EB94B0: 3B5E0004  addi r26, r30, 4
	ctx.r[26].s64 = ctx.r[30].s64 + 4;
	// 82EB94B4: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94B8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82EB94BC: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94C4: 409A0028  bne cr6, 0x82eb94ec
	if !ctx.cr[6].eq {
	pc = 0x82EB94EC; continue 'dispatch;
	}
	// 82EB94C8: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94CC: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94D4: 409A0018  bne cr6, 0x82eb94ec
	if !ctx.cr[6].eq {
	pc = 0x82EB94EC; continue 'dispatch;
	}
	// 82EB94D8: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB94DC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82EB94E0: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB94E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB94E8: 419A0008  beq cr6, 0x82eb94f0
	if ctx.cr[6].eq {
	pc = 0x82EB94F0; continue 'dispatch;
	}
	pc = 0x82EB94EC; continue 'dispatch;
            }
            0x82EB94EC => {
    //   block [0x82EB94EC..0x82EB94F0)
	// 82EB94EC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EB94F0; continue 'dispatch;
            }
            0x82EB94F0 => {
    //   block [0x82EB94F0..0x82EB9500)
	// 82EB94F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB94F4: 4182000C  beq 0x82eb9500
	if ctx.cr[0].eq {
	pc = 0x82EB9500; continue 'dispatch;
	}
	// 82EB94F8: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB94FC: 480005E0  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
            }
            0x82EB9500 => {
    //   block [0x82EB9500..0x82EB9514)
	// 82EB9500: 3AE00004  li r23, 4
	ctx.r[23].s64 = 4;
	// 82EB9504: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EB9508: 409A000C  bne cr6, 0x82eb9514
	if !ctx.cr[6].eq {
	pc = 0x82EB9514; continue 'dispatch;
	}
	// 82EB950C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82EB9510: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	pc = 0x82EB9514; continue 'dispatch;
            }
            0x82EB9514 => {
    //   block [0x82EB9514..0x82EB9540)
	// 82EB9514: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 82EB9518: 409A0080  bne cr6, 0x82eb9598
	if !ctx.cr[6].eq {
	pc = 0x82EB9598; continue 'dispatch;
	}
	// 82EB951C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9520: 48018A81  bl 0x82ed1fa0
	ctx.lr = 0x82EB9524;
	sub_82ED1FA0(ctx, base);
	// 82EB9524: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB9528: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EB952C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EB9530: 4099005C  ble cr6, 0x82eb958c
	if !ctx.cr[6].gt {
	pc = 0x82EB958C; continue 'dispatch;
	}
	// 82EB9534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9538: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EB953C: C3EB0C4C  lfs f31, 0xc4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EB9540; continue 'dispatch;
            }
            0x82EB9540 => {
    //   block [0x82EB9540..0x82EB9578)
	// 82EB9540: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EB9544: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EB9548: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EB954C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9550: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EB9554: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EB9558: 480197F1  bl 0x82ed2d48
	ctx.lr = 0x82EB955C;
	sub_82ED2D48(ctx, base);
	// 82EB955C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9560: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EB9564: 40820014  bne 0x82eb9578
	if !ctx.cr[0].eq {
	pc = 0x82EB9578; continue 'dispatch;
	}
	// 82EB9568: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB956C: 48018A55  bl 0x82ed1fc0
	ctx.lr = 0x82EB9570;
	sub_82ED1FC0(ctx, base);
	// 82EB9570: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EB9574: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB9578; continue 'dispatch;
            }
            0x82EB9578 => {
    //   block [0x82EB9578..0x82EB958C)
	// 82EB9578: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB957C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EB9580: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EB9584: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EB9588: 4198FFB8  blt cr6, 0x82eb9540
	if ctx.cr[6].lt {
	pc = 0x82EB9540; continue 'dispatch;
	}
	pc = 0x82EB958C; continue 'dispatch;
            }
            0x82EB958C => {
    //   block [0x82EB958C..0x82EB9598)
	// 82EB958C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9590: 48018A31  bl 0x82ed1fc0
	ctx.lr = 0x82EB9594;
	sub_82ED1FC0(ctx, base);
	// 82EB9594: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	pc = 0x82EB9598; continue 'dispatch;
            }
            0x82EB9598 => {
    //   block [0x82EB9598..0x82EB95DC)
	// 82EB9598: 3BA00007  li r29, 7
	ctx.r[29].s64 = 7;
	// 82EB959C: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82EB95A0: 409A00A8  bne cr6, 0x82eb9648
	if !ctx.cr[6].eq {
	pc = 0x82EB9648; continue 'dispatch;
	}
	// 82EB95A4: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB95AC: 41820530  beq 0x82eb9adc
	if ctx.cr[0].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB95B0: 4801A2A1  bl 0x82ed3850
	ctx.lr = 0x82EB95B4;
	sub_82ED3850(ctx, base);
	// 82EB95B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB95B8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95BC: 41820020  beq 0x82eb95dc
	if ctx.cr[0].eq {
	pc = 0x82EB95DC; continue 'dispatch;
	}
	// 82EB95C0: 3B600005  li r27, 5
	ctx.r[27].s64 = 5;
	// 82EB95C4: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB95C8: 937F0058  stw r27, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82EB95CC: 4801A175  bl 0x82ed3740
	ctx.lr = 0x82EB95D0;
	sub_82ED3740(ctx, base);
	// 82EB95D0: 9B9F007D  stb r28, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[28].u8 ) };
	// 82EB95D4: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	// 82EB95D8: 48000080  b 0x82eb9658
	pc = 0x82EB9658; continue 'dispatch;
            }
            0x82EB95DC => {
    //   block [0x82EB95DC..0x82EB9600)
	// 82EB95DC: 4801A2CD  bl 0x82ed38a8
	ctx.lr = 0x82EB95E0;
	sub_82ED38A8(ctx, base);
	// 82EB95E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB95E4: 4182002C  beq 0x82eb9610
	if ctx.cr[0].eq {
	pc = 0x82EB9610; continue 'dispatch;
	}
	// 82EB95E8: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB95EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB95F0: 409A0010  bne cr6, 0x82eb9600
	if !ctx.cr[6].eq {
	pc = 0x82EB9600; continue 'dispatch;
	}
	// 82EB95F4: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB95F8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB95FC: 48019935  bl 0x82ed2f30
	ctx.lr = 0x82EB9600;
	sub_82ED2F30(ctx, base);
	pc = 0x82EB9600; continue 'dispatch;
            }
            0x82EB9600 => {
    //   block [0x82EB9600..0x82EB9608)
	// 82EB9600: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82EB9604: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB9608; continue 'dispatch;
            }
            0x82EB9608 => {
    //   block [0x82EB9608..0x82EB9610)
	// 82EB9608: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EB960C: 480004D0  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
            }
            0x82EB9610 => {
    //   block [0x82EB9610..0x82EB963C)
	// 82EB9610: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9614: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EB9618: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82EB961C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EB9620: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB9624: 409A04B8  bne cr6, 0x82eb9adc
	if !ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB9628: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EB962C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9630: 4182000C  beq 0x82eb963c
	if ctx.cr[0].eq {
	pc = 0x82EB963C; continue 'dispatch;
	}
	// 82EB9634: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9638: 480198F9  bl 0x82ed2f30
	ctx.lr = 0x82EB963C;
	sub_82ED2F30(ctx, base);
	pc = 0x82EB963C; continue 'dispatch;
            }
            0x82EB963C => {
    //   block [0x82EB963C..0x82EB9648)
	// 82EB963C: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EB9640: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82EB9644: 939F0058  stw r28, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB9648; continue 'dispatch;
            }
            0x82EB9648 => {
    //   block [0x82EB9648..0x82EB9658)
	// 82EB9648: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82EB964C: 419A000C  beq cr6, 0x82eb9658
	if ctx.cr[6].eq {
	pc = 0x82EB9658; continue 'dispatch;
	}
	// 82EB9650: 2F1B0006  cmpwi cr6, r27, 6
	ctx.cr[6].compare_i32(ctx.r[27].s32, 6, &mut ctx.xer);
	// 82EB9654: 409A0180  bne cr6, 0x82eb97d4
	if !ctx.cr[6].eq {
	pc = 0x82EB97D4; continue 'dispatch;
	}
	pc = 0x82EB9658; continue 'dispatch;
            }
            0x82EB9658 => {
    //   block [0x82EB9658..0x82EB9664)
	// 82EB9658: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB965C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9660: 4082000C  bne 0x82eb966c
	if !ctx.cr[0].eq {
	pc = 0x82EB966C; continue 'dispatch;
	}
	pc = 0x82EB9664; continue 'dispatch;
            }
            0x82EB9664 => {
    //   block [0x82EB9664..0x82EB966C)
	// 82EB9664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9668: 48000478  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
            }
            0x82EB966C => {
    //   block [0x82EB966C..0x82EB9698)
	// 82EB966C: 4801A1E5  bl 0x82ed3850
	ctx.lr = 0x82EB9670;
	sub_82ED3850(ctx, base);
	// 82EB9670: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9674: 41820464  beq 0x82eb9ad8
	if ctx.cr[0].eq {
	pc = 0x82EB9AD8; continue 'dispatch;
	}
	// 82EB9678: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 82EB967C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB9680: 409A0018  bne cr6, 0x82eb9698
	if !ctx.cr[6].eq {
	pc = 0x82EB9698; continue 'dispatch;
	}
	// 82EB9684: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB9688: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB968C: 419AFFD8  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	// 82EB9690: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9694: 419AFFD0  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	pc = 0x82EB9698; continue 'dispatch;
            }
            0x82EB9698 => {
    //   block [0x82EB9698..0x82EB96B4)
	// 82EB9698: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EB969C: 9B1F007D  stb r24, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[24].u8 ) };
	// 82EB96A0: 3BDF0090  addi r30, r31, 0x90
	ctx.r[30].s64 = ctx.r[31].s64 + 144;
	// 82EB96A4: 2F1B0005  cmpwi cr6, r27, 5
	ctx.cr[6].compare_i32(ctx.r[27].s32, 5, &mut ctx.xer);
	// 82EB96A8: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EB96AC: 409A0008  bne cr6, 0x82eb96b4
	if !ctx.cr[6].eq {
	pc = 0x82EB96B4; continue 'dispatch;
	}
	// 82EB96B0: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	pc = 0x82EB96B4; continue 'dispatch;
            }
            0x82EB96B4 => {
    //   block [0x82EB96B4..0x82EB96F0)
	// 82EB96B4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB96B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB96BC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82EB96C0: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EB96C4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EB96C8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EB96CC: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB96D0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EB96D4: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96D8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EB96DC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96E0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EB96E4: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB96E8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EB96EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82EB96F0; continue 'dispatch;
            }
            0x82EB96F0 => {
    //   block [0x82EB96F0..0x82EB974C)
	// 82EB96F0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EB96F4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EB96F8: 4200FFF8  bdnz 0x82eb96f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB96F0; continue 'dispatch;
	}
	// 82EB96FC: 807F0278  lwz r3, 0x278(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EB9700: 391F008C  addi r8, r31, 0x8c
	ctx.r[8].s64 = ctx.r[31].s64 + 140;
	// 82EB9704: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EB9708: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EB970C: 80FF0094  lwz r7, 0x94(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB9710: 38BF02D8  addi r5, r31, 0x2d8
	ctx.r[5].s64 = ctx.r[31].s64 + 728;
	// 82EB9714: 80DF0068  lwz r6, 0x68(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9718: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EB971C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB9720: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9724: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EB9728: 4E800421  bctrl
	ctx.lr = 0x82EB972C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EB972C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EB9730: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB9734: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EB9738: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB973C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB9740: 419A000C  beq cr6, 0x82eb974c
	if ctx.cr[6].eq {
	pc = 0x82EB974C; continue 'dispatch;
	}
	// 82EB9744: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82EB9748: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
            }
            0x82EB974C => {
    //   block [0x82EB974C..0x82EB9774)
	// 82EB974C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9750: 40820024  bne 0x82eb9774
	if !ctx.cr[0].eq {
	pc = 0x82EB9774; continue 'dispatch;
	}
	// 82EB9754: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9758: 83FF0194  lwz r31, 0x194(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB975C: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9760: 4B3A7259  bl 0x822609b8
	ctx.lr = 0x82EB9764;
	sub_822609B8(ctx, base);
	// 82EB9764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EB9768: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB976C: 4BFC84CD  bl 0x82e81c38
	ctx.lr = 0x82EB9770;
	sub_82E81C38(ctx, base);
	// 82EB9770: 4800036C  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
            }
            0x82EB9774 => {
    //   block [0x82EB9774..0x82EB978C)
	// 82EB9774: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82EB9778: 409A0028  bne cr6, 0x82eb97a0
	if !ctx.cr[6].eq {
	pc = 0x82EB97A0; continue 'dispatch;
	}
	// 82EB977C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9780: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9784: 931F0198  stw r24, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[24].u32 ) };
	// 82EB9788: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82EB978C; continue 'dispatch;
            }
            0x82EB978C => {
    //   block [0x82EB978C..0x82EB97A0)
	// 82EB978C: 4B3A722D  bl 0x822609b8
	ctx.lr = 0x82EB9790;
	sub_822609B8(ctx, base);
	// 82EB9790: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB9794: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EB9798: 4BFC82D9  bl 0x82e81a70
	ctx.lr = 0x82EB979C;
	sub_82E81A70(ctx, base);
	// 82EB979C: 4BFFFEC8  b 0x82eb9664
	pc = 0x82EB9664; continue 'dispatch;
            }
            0x82EB97A0 => {
    //   block [0x82EB97A0..0x82EB97C4)
	// 82EB97A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EB97A4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EB97A8: 409A001C  bne cr6, 0x82eb97c4
	if !ctx.cr[6].eq {
	pc = 0x82EB97C4; continue 'dispatch;
	}
	// 82EB97AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EB97B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB97B4: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB97B8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB97BC: 83EA0014  lwz r31, 0x14(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB97C0: 4BFFFFCC  b 0x82eb978c
	pc = 0x82EB978C; continue 'dispatch;
            }
            0x82EB97C4 => {
    //   block [0x82EB97C4..0x82EB97D4)
	// 82EB97C4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82EB97C8: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB97CC: 9B9F007C  stb r28, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[28].u8 ) };
	// 82EB97D0: 939F0198  stw r28, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[28].u32 ) };
	pc = 0x82EB97D4; continue 'dispatch;
            }
            0x82EB97D4 => {
    //   block [0x82EB97D4..0x82EB9804)
	// 82EB97D4: 2F1B0007  cmpwi cr6, r27, 7
	ctx.cr[6].compare_i32(ctx.r[27].s32, 7, &mut ctx.xer);
	// 82EB97D8: 409A0304  bne cr6, 0x82eb9adc
	if !ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB97DC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB97E0: 4801A071  bl 0x82ed3850
	ctx.lr = 0x82EB97E4;
	sub_82ED3850(ctx, base);
	// 82EB97E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB97E8: 418202F0  beq 0x82eb9ad8
	if ctx.cr[0].eq {
	pc = 0x82EB9AD8; continue 'dispatch;
	}
	// 82EB97EC: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EB97F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EB97F4: 409A0010  bne cr6, 0x82eb9804
	if !ctx.cr[6].eq {
	pc = 0x82EB9804; continue 'dispatch;
	}
	// 82EB97F8: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB97FC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EB9800: 419AFE64  beq cr6, 0x82eb9664
	if ctx.cr[6].eq {
	pc = 0x82EB9664; continue 'dispatch;
	}
	pc = 0x82EB9804; continue 'dispatch;
            }
            0x82EB9804 => {
    //   block [0x82EB9804..0x82EB983C)
	// 82EB9804: 83DF0194  lwz r30, 0x194(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9808: 9B1F007C  stb r24, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[24].u8 ) };
	// 82EB980C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB9810: 419A002C  beq cr6, 0x82eb983c
	if ctx.cr[6].eq {
	pc = 0x82EB983C; continue 'dispatch;
	}
	// 82EB9814: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9818: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB981C: 4B3A719D  bl 0x822609b8
	ctx.lr = 0x82EB9820;
	sub_822609B8(ctx, base);
	// 82EB9820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EB9824: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB9828: 4BFB68A9  bl 0x82e700d0
	ctx.lr = 0x82EB982C;
	sub_82E700D0(ctx, base);
	// 82EB982C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9830: 4082000C  bne 0x82eb983c
	if !ctx.cr[0].eq {
	pc = 0x82EB983C; continue 'dispatch;
	}
	// 82EB9834: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB9838: 480002A4  b 0x82eb9adc
	pc = 0x82EB9ADC; continue 'dispatch;
            }
            0x82EB983C => {
    //   block [0x82EB983C..0x82EB9868)
	// 82EB983C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9840: 4BFFC961  bl 0x82eb61a0
	ctx.lr = 0x82EB9844;
	sub_82EB61A0(ctx, base);
	// 82EB9844: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EB9848: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB984C: 9B1F006C  stb r24, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[24].u8 ) };
	// 82EB9850: 4801A089  bl 0x82ed38d8
	ctx.lr = 0x82EB9854;
	sub_82ED38D8(ctx, base);
	// 82EB9854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9858: 40820010  bne 0x82eb9868
	if !ctx.cr[0].eq {
	pc = 0x82EB9868; continue 'dispatch;
	}
	// 82EB985C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9860: 931F0198  stw r24, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[24].u32 ) };
	// 82EB9864: 4800027C  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
            }
            0x82EB9868 => {
    //   block [0x82EB9868..0x82EB9884)
	// 82EB9868: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB986C: 809F0090  lwz r4, 0x90(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EB9870: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9874: 4801A065  bl 0x82ed38d8
	ctx.lr = 0x82EB9878;
	sub_82ED38D8(ctx, base);
	// 82EB9878: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB987C: 40820014  bne 0x82eb9890
	if !ctx.cr[0].eq {
	pc = 0x82EB9890; continue 'dispatch;
	}
	// 82EB9880: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82EB9884; continue 'dispatch;
            }
            0x82EB9884 => {
    //   block [0x82EB9884..0x82EB9890)
	// 82EB9884: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EB9888: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82EB988C: 48000254  b 0x82eb9ae0
	pc = 0x82EB9AE0; continue 'dispatch;
            }
            0x82EB9890 => {
    //   block [0x82EB9890..0x82EB9938)
	// 82EB9890: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9894: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9898: 812B0194  lwz r9, 0x194(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB989C: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB98A0: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82EB98A4: 814B019C  lwz r10, 0x19c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB98A8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EB98AC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EB98B0: B38A0012  sth r28, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	// 82EB98B4: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98B8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB98BC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB98C0: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB98C4: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98C8: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB98CC: C0190008  lfs f0, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB98D0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB98D4: 93090000  stw r24, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB98D8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB98DC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82EB98E0: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB98E4: A12A0012  lhz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB98E8: 39290005  addi r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 + 5;
	// 82EB98EC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EB98F0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82EB98F4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EB98F8: B38A0012  sth r28, 0x12(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	// 82EB98FC: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9900: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9904: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82EB9908: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB990C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9910: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9914: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9918: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB991C: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB9920: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EB9924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9928: 41820010  beq 0x82eb9938
	if ctx.cr[0].eq {
	pc = 0x82EB9938; continue 'dispatch;
	}
	// 82EB992C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB9930: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9934: 4BFE3335  bl 0x82e9cc68
	ctx.lr = 0x82EB9938;
	sub_82E9CC68(ctx, base);
	pc = 0x82EB9938; continue 'dispatch;
            }
            0x82EB9938 => {
    //   block [0x82EB9938..0x82EB9998)
	// 82EB9938: 897F0440  lbz r11, 0x440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1088 as u32) ) } as u64;
	// 82EB993C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EB9940: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9944: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EB9948: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB994C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EB9950: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EB9954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9958: 41820048  beq 0x82eb99a0
	if ctx.cr[0].eq {
	pc = 0x82EB99A0; continue 'dispatch;
	}
	// 82EB995C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EB9960: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EB9964: 4BFFD5BD  bl 0x82eb6f20
	ctx.lr = 0x82EB9968;
	sub_82EB6F20(ctx, base);
	// 82EB9968: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB996C: 83BF0194  lwz r29, 0x194(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB9970: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB9974: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB9978: 4B3A7041  bl 0x822609b8
	ctx.lr = 0x82EB997C;
	sub_822609B8(ctx, base);
	// 82EB997C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB9980: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB9984: 4BFC8365  bl 0x82e81ce8
	ctx.lr = 0x82EB9988;
	sub_82E81CE8(ctx, base);
	// 82EB9988: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82EB998C: 419A0150  beq cr6, 0x82eb9adc
	if ctx.cr[6].eq {
	pc = 0x82EB9ADC; continue 'dispatch;
	}
	// 82EB9990: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 82EB9994: 419A0038  beq cr6, 0x82eb99cc
	if ctx.cr[6].eq {
	pc = 0x82EB99CC; continue 'dispatch;
	}
	pc = 0x82EB9998; continue 'dispatch;
            }
            0x82EB9998 => {
    //   block [0x82EB9998..0x82EB99A0)
	// 82EB9998: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82EB999C: 4BFFFEE8  b 0x82eb9884
	pc = 0x82EB9884; continue 'dispatch;
            }
            0x82EB99A0 => {
    //   block [0x82EB99A0..0x82EB99CC)
	// 82EB99A0: 4BFFCC09  bl 0x82eb65a8
	ctx.lr = 0x82EB99A4;
	sub_82EB65A8(ctx, base);
	// 82EB99A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EB99A8: 83BF0194  lwz r29, 0x194(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EB99B0: 836B0014  lwz r27, 0x14(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EB99B4: 4B3A7005  bl 0x822609b8
	ctx.lr = 0x82EB99B8;
	sub_822609B8(ctx, base);
	// 82EB99B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EB99BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EB99C0: 4BFC8329  bl 0x82e81ce8
	ctx.lr = 0x82EB99C4;
	sub_82E81CE8(ctx, base);
	// 82EB99C4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82EB99C8: 419AFFD0  beq cr6, 0x82eb9998
	if ctx.cr[6].eq {
	pc = 0x82EB9998; continue 'dispatch;
	}
	pc = 0x82EB99CC; continue 'dispatch;
            }
            0x82EB99CC => {
    //   block [0x82EB99CC..0x82EB9A1C)
	// 82EB99CC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99D0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82EB99D4: 930B01A4  stw r24, 0x1a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(420 as u32), ctx.r[24].u32 ) };
	// 82EB99D8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99DC: 938B01AC  stw r28, 0x1ac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(428 as u32), ctx.r[28].u32 ) };
	// 82EB99E0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99E4: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB99EC: 914B0194  stw r10, 0x194(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 82EB99F0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB99F4: 814B0194  lwz r10, 0x194(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(404 as u32) ) } as u64;
	// 82EB99F8: 812B019C  lwz r9, 0x19c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EB99FC: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EB9A00: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EB9A04: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EB9A08: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82EB9A0C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9A10: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EB9A14: 81290198  lwz r9, 0x198(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(408 as u32) ) } as u64;
	// 82EB9A18: 48000018  b 0x82eb9a30
	pc = 0x82EB9A30; continue 'dispatch;
            }
            0x82EB9A1C => {
    //   block [0x82EB9A1C..0x82EB9A30)
	// 82EB9A1C: A0EB0012  lhz r7, 0x12(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82EB9A20: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EB9A24: 38E70005  addi r7, r7, 5
	ctx.r[7].s64 = ctx.r[7].s64 + 5;
	// 82EB9A28: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82EB9A2C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	pc = 0x82EB9A30; continue 'dispatch;
            }
            0x82EB9A30 => {
    //   block [0x82EB9A30..0x82EB9A84)
	// 82EB9A30: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EB9A34: 409AFFE8  bne cr6, 0x82eb9a1c
	if !ctx.cr[6].eq {
	pc = 0x82EB9A1C; continue 'dispatch;
	}
	// 82EB9A38: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EB9A3C: 910A0014  stw r8, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EB9A40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9A44: 4BFFE905  bl 0x82eb8348
	ctx.lr = 0x82EB9A48;
	sub_82EB8348(ctx, base);
	// 82EB9A48: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9A4C: C01A0000  lfs f0, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A50: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB9A54: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EB9A5C: 409A0028  bne cr6, 0x82eb9a84
	if !ctx.cr[6].eq {
	pc = 0x82EB9A84; continue 'dispatch;
	}
	// 82EB9A60: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A64: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A68: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9A6C: 409A0018  bne cr6, 0x82eb9a84
	if !ctx.cr[6].eq {
	pc = 0x82EB9A84; continue 'dispatch;
	}
	// 82EB9A70: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A74: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EB9A78: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9A7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9A80: 419A0008  beq cr6, 0x82eb9a88
	if ctx.cr[6].eq {
	pc = 0x82EB9A88; continue 'dispatch;
	}
	pc = 0x82EB9A84; continue 'dispatch;
            }
            0x82EB9A84 => {
    //   block [0x82EB9A84..0x82EB9A88)
	// 82EB9A84: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82EB9A88; continue 'dispatch;
            }
            0x82EB9A88 => {
    //   block [0x82EB9A88..0x82EB9ABC)
	// 82EB9A88: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EB9A8C: 41820030  beq 0x82eb9abc
	if ctx.cr[0].eq {
	pc = 0x82EB9ABC; continue 'dispatch;
	}
	// 82EB9A90: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82EB9A94: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9A98: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9A9C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9AA0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9AA4: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9AA8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9AAC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9AB0: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EB9AB4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EB9AB8: 914B01B8  stw r10, 0x1b8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(440 as u32), ctx.r[10].u32 ) };
	pc = 0x82EB9ABC; continue 'dispatch;
            }
            0x82EB9ABC => {
    //   block [0x82EB9ABC..0x82EB9AD8)
	// 82EB9ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9AC0: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EB9AC4: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9AC8: 9B1F006C  stb r24, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[24].u8 ) };
	// 82EB9ACC: 4BFFC0ED  bl 0x82eb5bb8
	ctx.lr = 0x82EB9AD0;
	sub_82EB5BB8(ctx, base);
	// 82EB9AD0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82EB9AD4: 4BFFFB34  b 0x82eb9608
	pc = 0x82EB9608; continue 'dispatch;
            }
            0x82EB9AD8 => {
    //   block [0x82EB9AD8..0x82EB9ADC)
	// 82EB9AD8: 92FF0058  stw r23, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	pc = 0x82EB9ADC; continue 'dispatch;
            }
            0x82EB9ADC => {
    //   block [0x82EB9ADC..0x82EB9AE0)
	// 82EB9ADC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EB9AE0; continue 'dispatch;
            }
            0x82EB9AE0 => {
    //   block [0x82EB9AE0..0x82EB9AEC)
	// 82EB9AE0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EB9AE4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EB9AE8: 4BDEF95C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9AF0 size=268
    let mut pc: u32 = 0x82EB9AF0;
    'dispatch: loop {
        match pc {
            0x82EB9AF0 => {
    //   block [0x82EB9AF0..0x82EB9B50)
	// 82EB9AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9AF4: 4BDEF915  bl 0x82ca9408
	ctx.lr = 0x82EB9AF8;
	sub_82CA93D0(ctx, base);
	// 82EB9AF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9B00: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EB9B04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EB9B08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EB9B0C: 897F018C  lbz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82EB9B10: 9BBF006C  stb r29, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u8 ) };
	// 82EB9B14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9B18: 4182007C  beq 0x82eb9b94
	if ctx.cr[0].eq {
	pc = 0x82EB9B94; continue 'dispatch;
	}
	// 82EB9B1C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B20: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B28: 409A0028  bne cr6, 0x82eb9b50
	if !ctx.cr[6].eq {
	pc = 0x82EB9B50; continue 'dispatch;
	}
	// 82EB9B2C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B30: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B38: 409A0018  bne cr6, 0x82eb9b50
	if !ctx.cr[6].eq {
	pc = 0x82EB9B50; continue 'dispatch;
	}
	// 82EB9B3C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9B40: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EB9B44: C1BF0188  lfs f13, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9B48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EB9B4C: 419A0008  beq cr6, 0x82eb9b54
	if ctx.cr[6].eq {
	pc = 0x82EB9B54; continue 'dispatch;
	}
	pc = 0x82EB9B50; continue 'dispatch;
            }
            0x82EB9B50 => {
    //   block [0x82EB9B50..0x82EB9B54)
	// 82EB9B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EB9B54; continue 'dispatch;
            }
            0x82EB9B54 => {
    //   block [0x82EB9B54..0x82EB9B70)
	// 82EB9B54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9B58: 40820018  bne 0x82eb9b70
	if !ctx.cr[0].eq {
	pc = 0x82EB9B70; continue 'dispatch;
	}
	// 82EB9B5C: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EB9B60: 40820010  bne 0x82eb9b70
	if !ctx.cr[0].eq {
	pc = 0x82EB9B70; continue 'dispatch;
	}
	// 82EB9B64: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EB9B68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EB9B6C: 4182004C  beq 0x82eb9bb8
	if ctx.cr[0].eq {
	pc = 0x82EB9BB8; continue 'dispatch;
	}
	pc = 0x82EB9B70; continue 'dispatch;
            }
            0x82EB9B70 => {
    //   block [0x82EB9B70..0x82EB9B94)
	// 82EB9B70: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB9B74: 9BBF0040  stb r29, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 82EB9B78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9B7C: 409A0020  bne cr6, 0x82eb9b9c
	if !ctx.cr[6].eq {
	pc = 0x82EB9B9C; continue 'dispatch;
	}
	// 82EB9B80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9B88: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82EB9B8C: 4BFFC615  bl 0x82eb61a0
	ctx.lr = 0x82EB9B90;
	sub_82EB61A0(ctx, base);
	// 82EB9B90: 4800000C  b 0x82eb9b9c
	pc = 0x82EB9B9C; continue 'dispatch;
            }
            0x82EB9B94 => {
    //   block [0x82EB9B94..0x82EB9B9C)
	// 82EB9B94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EB9B98: 997F018C  stb r11, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u8 ) };
	pc = 0x82EB9B9C; continue 'dispatch;
            }
            0x82EB9B9C => {
    //   block [0x82EB9B9C..0x82EB9BB8)
	// 82EB9B9C: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EB9BA0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BA4: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9BA8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BAC: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9BB0: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9BB4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	pc = 0x82EB9BB8; continue 'dispatch;
            }
            0x82EB9BB8 => {
    //   block [0x82EB9BB8..0x82EB9BDC)
	// 82EB9BB8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EB9BBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EB9BC0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82EB9BC4: 409A0018  bne cr6, 0x82eb9bdc
	if !ctx.cr[6].eq {
	pc = 0x82EB9BDC; continue 'dispatch;
	}
	// 82EB9BC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB9BCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB9BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9BD4: 4BFFF865  bl 0x82eb9438
	ctx.lr = 0x82EB9BD8;
	sub_82EB9438(ctx, base);
	// 82EB9BD8: 4800001C  b 0x82eb9bf4
	pc = 0x82EB9BF4; continue 'dispatch;
            }
            0x82EB9BDC => {
    //   block [0x82EB9BDC..0x82EB9BF4)
	// 82EB9BDC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EB9BE0: 409A0014  bne cr6, 0x82eb9bf4
	if !ctx.cr[6].eq {
	pc = 0x82EB9BF4; continue 'dispatch;
	}
	// 82EB9BE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EB9BE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EB9BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9BF0: 4BFFEF31  bl 0x82eb8b20
	ctx.lr = 0x82EB9BF4;
	sub_82EB8B20(ctx, base);
	pc = 0x82EB9BF4; continue 'dispatch;
            }
            0x82EB9BF4 => {
    //   block [0x82EB9BF4..0x82EB9BFC)
	// 82EB9BF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB9BF8: 4BDEF860  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EB9C00 size=1004
    let mut pc: u32 = 0x82EB9C00;
    'dispatch: loop {
        match pc {
            0x82EB9C00 => {
    //   block [0x82EB9C00..0x82EB9DA8)
	// 82EB9C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EB9C04: 4BDEF809  bl 0x82ca940c
	ctx.lr = 0x82EB9C08;
	sub_82CA93D0(ctx, base);
	// 82EB9C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EB9C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EB9C10: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82EB9C14: 4BFCBCED  bl 0x82e85900
	ctx.lr = 0x82EB9C18;
	sub_82E85900(ctx, base);
	// 82EB9C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9C1C: 395F00A4  addi r10, r31, 0xa4
	ctx.r[10].s64 = ctx.r[31].s64 + 164;
	// 82EB9C20: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EB9C24: 393F0104  addi r9, r31, 0x104
	ctx.r[9].s64 = ctx.r[31].s64 + 260;
	// 82EB9C28: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 82EB9C2C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9C30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EB9C34: 3CA08204  lis r5, -0x7dfc
	ctx.r[5].s64 = -2113667072;
	// 82EB9C38: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EB9C3C: 390BA8F8  addi r8, r11, -0x5708
	ctx.r[8].s64 = ctx.r[11].s64 + -22280;
	// 82EB9C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9C44: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EB9C48: 38E7A8F0  addi r7, r7, -0x5710
	ctx.r[7].s64 = ctx.r[7].s64 + -22288;
	// 82EB9C4C: 38C6A8F0  addi r6, r6, -0x5710
	ctx.r[6].s64 = ctx.r[6].s64 + -22288;
	// 82EB9C50: 38A5A8F0  addi r5, r5, -0x5710
	ctx.r[5].s64 = ctx.r[5].s64 + -22288;
	// 82EB9C54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EB9C58: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EB9C5C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EB9C60: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EB9C64: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB9C68: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB9C6C: 3908A8F0  addi r8, r8, -0x5710
	ctx.r[8].s64 = ctx.r[8].s64 + -22288;
	// 82EB9C70: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB9C74: D00A0050  stfs f0, 0x50(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB9C78: D00A0054  stfs f0, 0x54(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB9C7C: D00A0058  stfs f0, 0x58(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB9C80: 395F027C  addi r10, r31, 0x27c
	ctx.r[10].s64 = ctx.r[31].s64 + 636;
	// 82EB9C84: D0090050  stfs f0, 0x50(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EB9C88: D0090054  stfs f0, 0x54(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EB9C8C: D0090058  stfs f0, 0x58(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EB9C90: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9C94: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9C98: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9C9C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9CA0: 90FF01A0  stw r7, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[7].u32 ) };
	// 82EB9CA4: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82EB9CA8: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82EB9CAC: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82EB9CB0: 90DF01B4  stw r6, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[6].u32 ) };
	// 82EB9CB4: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82EB9CB8: 917F01BC  stw r11, 0x1bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82EB9CBC: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82EB9CC0: 90BF01C8  stw r5, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[5].u32 ) };
	// 82EB9CC4: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82EB9CC8: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82EB9CCC: 917F01D4  stw r11, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EB9CD0: 911F01DC  stw r8, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[8].u32 ) };
	// 82EB9CD4: 3909A8F0  addi r8, r9, -0x5710
	ctx.r[8].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CD8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9CDC: 917F01E0  stw r11, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EB9CE0: 917F01E4  stw r11, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82EB9CE4: 38E9A8F0  addi r7, r9, -0x5710
	ctx.r[7].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CE8: 917F01E8  stw r11, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[11].u32 ) };
	// 82EB9CEC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9CF0: 917F01F4  stw r11, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 82EB9CF4: 911F01F0  stw r8, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[8].u32 ) };
	// 82EB9CF8: 38C9A8F0  addi r6, r9, -0x5710
	ctx.r[6].s64 = ctx.r[9].s64 + -22288;
	// 82EB9CFC: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82EB9D00: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D04: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 82EB9D08: 90FF0204  stw r7, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[7].u32 ) };
	// 82EB9D0C: 38A9A8F0  addi r5, r9, -0x5710
	ctx.r[5].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D10: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82EB9D14: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D18: 917F020C  stw r11, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 82EB9D1C: 917F0210  stw r11, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 82EB9D20: 3889A8F0  addi r4, r9, -0x5710
	ctx.r[4].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D24: 90DF0218  stw r6, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[6].u32 ) };
	// 82EB9D28: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D2C: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82EB9D30: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 82EB9D34: 3869A8F0  addi r3, r9, -0x5710
	ctx.r[3].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D38: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 82EB9D3C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9D40: 90BF022C  stw r5, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[5].u32 ) };
	// 82EB9D44: 3BC9A8F0  addi r30, r9, -0x5710
	ctx.r[30].s64 = ctx.r[9].s64 + -22288;
	// 82EB9D48: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EB9D4C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EB9D50: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 82EB9D54: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 82EB9D58: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82EB9D5C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EB9D60: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82EB9D64: 909F0240  stw r4, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[4].u32 ) };
	// 82EB9D68: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 82EB9D6C: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 82EB9D70: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 82EB9D74: 907F0254  stw r3, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[3].u32 ) };
	// 82EB9D78: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 82EB9D7C: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 82EB9D80: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 82EB9D84: 93DF0268  stw r30, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[30].u32 ) };
	// 82EB9D88: 917F026C  stw r11, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[11].u32 ) };
	// 82EB9D8C: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 82EB9D90: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 82EB9D94: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9D98: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9D9C: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9DA0: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9DA4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82EB9DA8; continue 'dispatch;
            }
            0x82EB9DA8 => {
    //   block [0x82EB9DA8..0x82EB9DD8)
	// 82EB9DA8: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9DAC: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EB9DB0: 4200FFF8  bdnz 0x82eb9da8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9DA8; continue 'dispatch;
	}
	// 82EB9DB4: 38FF02D8  addi r7, r31, 0x2d8
	ctx.r[7].s64 = ctx.r[31].s64 + 728;
	// 82EB9DB8: 996A0058  stb r11, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9DBC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EB9DC0: 39470010  addi r10, r7, 0x10
	ctx.r[10].s64 = ctx.r[7].s64 + 16;
	// 82EB9DC4: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9DC8: D0070004  stfs f0, 4(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9DCC: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9DD0: D007000C  stfs f0, 0xc(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9DD4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82EB9DD8; continue 'dispatch;
            }
            0x82EB9DD8 => {
    //   block [0x82EB9DD8..0x82EB9E08)
	// 82EB9DD8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9DDC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EB9DE0: 4200FFF8  bdnz 0x82eb9dd8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9DD8; continue 'dispatch;
	}
	// 82EB9DE4: 391F0334  addi r8, r31, 0x334
	ctx.r[8].s64 = ctx.r[31].s64 + 820;
	// 82EB9DE8: 99670058  stb r11, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9DEC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EB9DF0: 38E80010  addi r7, r8, 0x10
	ctx.r[7].s64 = ctx.r[8].s64 + 16;
	// 82EB9DF4: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9DF8: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9DFC: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9E00: D008000C  stfs f0, 0xc(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9E04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EB9E08; continue 'dispatch;
            }
            0x82EB9E08 => {
    //   block [0x82EB9E08..0x82EB9E38)
	// 82EB9E08: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9E0C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EB9E10: 4200FFF8  bdnz 0x82eb9e08
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9E08; continue 'dispatch;
	}
	// 82EB9E14: 395F03A4  addi r10, r31, 0x3a4
	ctx.r[10].s64 = ctx.r[31].s64 + 932;
	// 82EB9E18: 99680058  stb r11, 0x58(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9E1C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EB9E20: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EB9E24: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EB9E28: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EB9E2C: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 82EB9E30: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EB9E34: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82EB9E38; continue 'dispatch;
            }
            0x82EB9E38 => {
    //   block [0x82EB9E38..0x82EB9FEC)
	// 82EB9E38: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EB9E3C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EB9E40: 4200FFF8  bdnz 0x82eb9e38
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EB9E38; continue 'dispatch;
	}
	// 82EB9E44: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EB9E48: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82EB9E4C: 996A0058  stb r11, 0x58(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82EB9E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EB9E54: 39298704  addi r9, r9, -0x78fc
	ctx.r[9].s64 = ctx.r[9].s64 + -30972;
	// 82EB9E58: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EB9E5C: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EB9E60: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82EB9E64: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EB9E68: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EB9E6C: D01F0428  stfs f0, 0x428(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82EB9E70: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 82EB9E74: 917F041C  stw r11, 0x41c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1052 as u32), ctx.r[11].u32 ) };
	// 82EB9E78: D01F042C  stfs f0, 0x42c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 82EB9E7C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82EB9E80: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82EB9E84: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EB9E88: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82EB9E8C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82EB9E90: 38A00400  li r5, 0x400
	ctx.r[5].s64 = 1024;
	// 82EB9E94: 386001F4  li r3, 0x1f4
	ctx.r[3].s64 = 500;
	// 82EB9E98: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EB9E9C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EB9EA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EB9EA4: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82EB9EA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9EAC: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EB9EB0: 814B9E38  lwz r10, -0x61c8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25032 as u32) ) } as u64;
	// 82EB9EB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EB9EB8: 914B9E38  stw r10, -0x61c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25032 as u32), ctx.r[10].u32 ) };
	// 82EB9EBC: D1BF044C  stfs f13, 0x44c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 82EB9EC0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EB9EC4: 909F0444  stw r4, 0x444(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1092 as u32), ctx.r[4].u32 ) };
	// 82EB9EC8: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82EB9ECC: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EB9ED0: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82EB9ED4: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EB9ED8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EB9EDC: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82EB9EE0: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82EB9EE4: 93DF0198  stw r30, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[30].u32 ) };
	// 82EB9EE8: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 82EB9EEC: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EB9EF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9EF4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EB9EF8: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 82EB9EFC: 388BF090  addi r4, r11, -0xf70
	ctx.r[4].s64 = ctx.r[11].s64 + -3952;
	// 82EB9F00: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EB9F04: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EB9F08: 9BDF0040  stb r30, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u8 ) };
	// 82EB9F0C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EB9F10: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82EB9F14: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82EB9F18: 90FF0030  stw r7, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[7].u32 ) };
	// 82EB9F1C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EB9F20: 993F019C  stb r9, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[9].u8 ) };
	// 82EB9F24: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EB9F28: 9BDF019D  stb r30, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[30].u8 ) };
	// 82EB9F2C: 90DF0194  stw r6, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[6].u32 ) };
	// 82EB9F30: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82EB9F34: 90BF0098  stw r5, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 82EB9F38: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82EB9F3C: 9BDF007E  stb r30, 0x7e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(126 as u32), ctx.r[30].u8 ) };
	// 82EB9F40: 993F007F  stb r9, 0x7f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(127 as u32), ctx.r[9].u8 ) };
	// 82EB9F44: 9BDF00A0  stb r30, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u8 ) };
	// 82EB9F48: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 82EB9F4C: 9BDF0440  stb r30, 0x440(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1088 as u32), ctx.r[30].u8 ) };
	// 82EB9F50: 907F0448  stw r3, 0x448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1096 as u32), ctx.r[3].u32 ) };
	// 82EB9F54: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EB9F58: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EB9F5C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB9F60: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EB9F64: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82EB9F68: 9BDF00AC  stb r30, 0xac(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u8 ) };
	// 82EB9F6C: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82EB9F70: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 82EB9F74: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 82EB9F78: 9BDF010C  stb r30, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u8 ) };
	// 82EB9F7C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EB9F80: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82EB9F84: 93DF0160  stw r30, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u32 ) };
	// 82EB9F88: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EB9F8C: 93DF0168  stw r30, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 82EB9F90: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB9F94: 4B3ADC8D  bl 0x82267c20
	ctx.lr = 0x82EB9F98;
	sub_82267C20(ctx, base);
	// 82EB9F98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EB9F9C: 907F0044  stw r3, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[3].u32 ) };
	// 82EB9FA0: 807D0718  lwz r3, 0x718(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EB9FA4: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EB9FA8: 4B3ADC79  bl 0x82267c20
	ctx.lr = 0x82EB9FAC;
	sub_82267C20(ctx, base);
	// 82EB9FAC: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EB9FB0: 9BDF018C  stb r30, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u8 ) };
	// 82EB9FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EB9FB8: 93DF01B0  stw r30, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[30].u32 ) };
	// 82EB9FBC: 93DF01C4  stw r30, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[30].u32 ) };
	// 82EB9FC0: 93DF01D8  stw r30, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[30].u32 ) };
	// 82EB9FC4: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 82EB9FC8: 93DF0200  stw r30, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[30].u32 ) };
	// 82EB9FCC: 93DF0214  stw r30, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[30].u32 ) };
	// 82EB9FD0: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 82EB9FD4: 93DF0264  stw r30, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
	// 82EB9FD8: 93DF0250  stw r30, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
	// 82EB9FDC: 93DF023C  stw r30, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[30].u32 ) };
	// 82EB9FE0: 93DF0278  stw r30, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[30].u32 ) };
	// 82EB9FE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EB9FE8: 4BDEF474  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EB9FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EB9FF0 size=12
    let mut pc: u32 = 0x82EB9FF0;
    'dispatch: loop {
        match pc {
            0x82EB9FF0 => {
    //   block [0x82EB9FF0..0x82EB9FFC)
	// 82EB9FF0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EB9FF4: 386B9E5C  addi r3, r11, -0x61a4
	ctx.r[3].s64 = ctx.r[11].s64 + -24996;
	// 82EB9FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA000 size=8
    let mut pc: u32 = 0x82EBA000;
    'dispatch: loop {
        match pc {
            0x82EBA000 => {
    //   block [0x82EBA000..0x82EBA008)
	// 82EBA000: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 82EBA004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA008 size=60
    let mut pc: u32 = 0x82EBA008;
    'dispatch: loop {
        match pc {
            0x82EBA008 => {
    //   block [0x82EBA008..0x82EBA044)
	// 82EBA008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBA00C: 806B0068  lwz r3, 0x68(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EBA010: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA014: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82EBA018: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EBA01C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA020: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82EBA024: 894B0034  lbz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA028: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA02C: 40820018  bne 0x82eba044
	if !ctx.cr[0].eq {
		sub_82EBA044(ctx, base);
		return;
	}
	// 82EBA030: 806B0048  lwz r3, 0x48(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA034: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA038: 4182000C  beq 0x82eba044
	if ctx.cr[0].eq {
		sub_82EBA044(ctx, base);
		return;
	}
	// 82EBA03C: 808B0038  lwz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBA040: 4801B9F0  b 0x82ed5a30
	sub_82ED5A30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA044(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA044 size=8
    let mut pc: u32 = 0x82EBA044;
    'dispatch: loop {
        match pc {
            0x82EBA044 => {
    //   block [0x82EBA044..0x82EBA04C)
	// 82EBA044: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBA048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA050 size=8
    let mut pc: u32 = 0x82EBA050;
    'dispatch: loop {
        match pc {
            0x82EBA050 => {
    //   block [0x82EBA050..0x82EBA058)
	// 82EBA050: 80630398  lwz r3, 0x398(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EBA054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBA058 size=8
    let mut pc: u32 = 0x82EBA058;
    'dispatch: loop {
        match pc {
            0x82EBA058 => {
    //   block [0x82EBA058..0x82EBA060)
	// 82EBA058: 88630396  lbz r3, 0x396(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(918 as u32) ) } as u64;
	// 82EBA05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBA060 size=1496
    let mut pc: u32 = 0x82EBA060;
    'dispatch: loop {
        match pc {
            0x82EBA060 => {
    //   block [0x82EBA060..0x82EBA0BC)
	// 82EBA060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBA064: 4BDEF3A5  bl 0x82ca9408
	ctx.lr = 0x82EBA068;
	sub_82CA93D0(ctx, base);
	// 82EBA068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBA06C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBA074: 396BA8F8  addi r11, r11, -0x5708
	ctx.r[11].s64 = ctx.r[11].s64 + -22280;
	// 82EBA078: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBA07C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EBA080: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82EBA084: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA088: 816A9E38  lwz r11, -0x61c8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25032 as u32) ) } as u64;
	// 82EBA08C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA090: 916A9E38  stw r11, -0x61c8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25032 as u32), ctx.r[11].u32 ) };
	// 82EBA094: 40820070  bne 0x82eba104
	if !ctx.cr[0].eq {
	pc = 0x82EBA104; continue 'dispatch;
	}
	// 82EBA098: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA09C: 807D9E3C  lwz r3, -0x61c4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EBA0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0A4: 419A0018  beq cr6, 0x82eba0bc
	if ctx.cr[6].eq {
	pc = 0x82EBA0BC; continue 'dispatch;
	}
	// 82EBA0A8: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0B0: 4E800421  bctrl
	ctx.lr = 0x82EBA0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA0B8: 917D9E3C  stw r11, -0x61c4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25028 as u32), ctx.r[11].u32 ) };
            }
            0x82EBA0BC => {
    //   block [0x82EBA0BC..0x82EBA0E0)
	// 82EBA0BC: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA0C0: 807D9E40  lwz r3, -0x61c0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25024 as u32) ) } as u64;
	// 82EBA0C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0C8: 419A0018  beq cr6, 0x82eba0e0
	if ctx.cr[6].eq {
	pc = 0x82EBA0E0; continue 'dispatch;
	}
	// 82EBA0CC: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0D4: 4E800421  bctrl
	ctx.lr = 0x82EBA0D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA0DC: 917D9E40  stw r11, -0x61c0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25024 as u32), ctx.r[11].u32 ) };
            }
            0x82EBA0E0 => {
    //   block [0x82EBA0E0..0x82EBA104)
	// 82EBA0E0: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 82EBA0E4: 807D9E44  lwz r3, -0x61bc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25020 as u32) ) } as u64;
	// 82EBA0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBA0EC: 419A0018  beq cr6, 0x82eba104
	if ctx.cr[6].eq {
	pc = 0x82EBA104; continue 'dispatch;
	}
	// 82EBA0F0: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA0F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA0F8: 4E800421  bctrl
	ctx.lr = 0x82EBA0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA0FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EBA100: 917D9E44  stw r11, -0x61bc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-25020 as u32), ctx.r[11].u32 ) };
            }
            0x82EBA104 => {
    //   block [0x82EBA104..0x82EBA12C)
	// 82EBA104: 83BF0054  lwz r29, 0x54(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBA108: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA10C: 41820020  beq 0x82eba12c
	if ctx.cr[0].eq {
	pc = 0x82EBA12C; continue 'dispatch;
	}
	// 82EBA110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBA114: 4BFFBC05  bl 0x82eb5d18
	ctx.lr = 0x82EBA118;
	sub_82EB5D18(ctx, base);
	// 82EBA118: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA11C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBA120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA124: 4E800421  bctrl
	ctx.lr = 0x82EBA128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA128: 939F0054  stw r28, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
            }
            0x82EBA12C => {
    //   block [0x82EBA12C..0x82EBA148)
	// 82EBA12C: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EBA130: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA134: 41820014  beq 0x82eba148
	if ctx.cr[0].eq {
	pc = 0x82EBA148; continue 'dispatch;
	}
	// 82EBA138: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA13C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA140: 4E800421  bctrl
	ctx.lr = 0x82EBA144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA144: 939F0094  stw r28, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[28].u32 ) };
            }
            0x82EBA148 => {
    //   block [0x82EBA148..0x82EBA164)
	// 82EBA148: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EBA14C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA150: 41820014  beq 0x82eba164
	if ctx.cr[0].eq {
	pc = 0x82EBA164; continue 'dispatch;
	}
	// 82EBA154: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBA158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA15C: 4E800421  bctrl
	ctx.lr = 0x82EBA160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA160: 939F0060  stw r28, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
            }
            0x82EBA164 => {
    //   block [0x82EBA164..0x82EBA178)
	// 82EBA164: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA168: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA16C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA170: 4099004C  ble cr6, 0x82eba1bc
	if !ctx.cr[6].gt {
	pc = 0x82EBA1BC; continue 'dispatch;
	}
	// 82EBA174: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA178; continue 'dispatch;
            }
            0x82EBA178 => {
    //   block [0x82EBA178..0x82EBA1A8)
	// 82EBA178: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA17C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBA180: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA184: 419A0024  beq cr6, 0x82eba1a8
	if ctx.cr[6].eq {
	pc = 0x82EBA1A8; continue 'dispatch;
	}
	// 82EBA188: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA190: 41820018  beq 0x82eba1a8
	if ctx.cr[0].eq {
	pc = 0x82EBA1A8; continue 'dispatch;
	}
	// 82EBA194: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA198: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA19C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA1A4: 4E800421  bctrl
	ctx.lr = 0x82EBA1A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA1A8 => {
    //   block [0x82EBA1A8..0x82EBA1BC)
	// 82EBA1A8: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA1AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA1B0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA1B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA1B8: 4198FFC0  blt cr6, 0x82eba178
	if ctx.cr[6].lt {
	pc = 0x82EBA178; continue 'dispatch;
	}
	pc = 0x82EBA1BC; continue 'dispatch;
            }
            0x82EBA1BC => {
    //   block [0x82EBA1BC..0x82EBA1D0)
	// 82EBA1BC: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA1C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1C8: 4099004C  ble cr6, 0x82eba214
	if !ctx.cr[6].gt {
	pc = 0x82EBA214; continue 'dispatch;
	}
	// 82EBA1CC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA1D0; continue 'dispatch;
            }
            0x82EBA1D0 => {
    //   block [0x82EBA1D0..0x82EBA200)
	// 82EBA1D0: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBA1D4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA1D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1DC: 419A0024  beq cr6, 0x82eba200
	if ctx.cr[6].eq {
	pc = 0x82EBA200; continue 'dispatch;
	}
	// 82EBA1E0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA1E8: 41820018  beq 0x82eba200
	if ctx.cr[0].eq {
	pc = 0x82EBA200; continue 'dispatch;
	}
	// 82EBA1EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA1F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA1F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA1FC: 4E800421  bctrl
	ctx.lr = 0x82EBA200;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA200 => {
    //   block [0x82EBA200..0x82EBA214)
	// 82EBA200: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA204: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA208: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA20C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA210: 4198FFC0  blt cr6, 0x82eba1d0
	if ctx.cr[6].lt {
	pc = 0x82EBA1D0; continue 'dispatch;
	}
	pc = 0x82EBA214; continue 'dispatch;
            }
            0x82EBA214 => {
    //   block [0x82EBA214..0x82EBA228)
	// 82EBA214: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBA218: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA220: 4099004C  ble cr6, 0x82eba26c
	if !ctx.cr[6].gt {
	pc = 0x82EBA26C; continue 'dispatch;
	}
	// 82EBA224: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA228; continue 'dispatch;
            }
            0x82EBA228 => {
    //   block [0x82EBA228..0x82EBA258)
	// 82EBA228: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBA22C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA230: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA234: 419A0024  beq cr6, 0x82eba258
	if ctx.cr[6].eq {
	pc = 0x82EBA258; continue 'dispatch;
	}
	// 82EBA238: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA23C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA240: 41820018  beq 0x82eba258
	if ctx.cr[0].eq {
	pc = 0x82EBA258; continue 'dispatch;
	}
	// 82EBA244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA248: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA24C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA254: 4E800421  bctrl
	ctx.lr = 0x82EBA258;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA258 => {
    //   block [0x82EBA258..0x82EBA26C)
	// 82EBA258: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBA25C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA260: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA264: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA268: 4198FFC0  blt cr6, 0x82eba228
	if ctx.cr[6].lt {
	pc = 0x82EBA228; continue 'dispatch;
	}
	pc = 0x82EBA26C; continue 'dispatch;
            }
            0x82EBA26C => {
    //   block [0x82EBA26C..0x82EBA280)
	// 82EBA26C: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBA270: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA278: 4099004C  ble cr6, 0x82eba2c4
	if !ctx.cr[6].gt {
	pc = 0x82EBA2C4; continue 'dispatch;
	}
	// 82EBA27C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA280; continue 'dispatch;
            }
            0x82EBA280 => {
    //   block [0x82EBA280..0x82EBA2B0)
	// 82EBA280: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBA284: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA288: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA28C: 419A0024  beq cr6, 0x82eba2b0
	if ctx.cr[6].eq {
	pc = 0x82EBA2B0; continue 'dispatch;
	}
	// 82EBA290: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA298: 41820018  beq 0x82eba2b0
	if ctx.cr[0].eq {
	pc = 0x82EBA2B0; continue 'dispatch;
	}
	// 82EBA29C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA2A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA2AC: 4E800421  bctrl
	ctx.lr = 0x82EBA2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA2B0 => {
    //   block [0x82EBA2B0..0x82EBA2C4)
	// 82EBA2B0: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBA2B4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA2B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA2BC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA2C0: 4198FFC0  blt cr6, 0x82eba280
	if ctx.cr[6].lt {
	pc = 0x82EBA280; continue 'dispatch;
	}
	pc = 0x82EBA2C4; continue 'dispatch;
            }
            0x82EBA2C4 => {
    //   block [0x82EBA2C4..0x82EBA2D8)
	// 82EBA2C4: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBA2C8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2D0: 4099004C  ble cr6, 0x82eba31c
	if !ctx.cr[6].gt {
	pc = 0x82EBA31C; continue 'dispatch;
	}
	// 82EBA2D4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA2D8; continue 'dispatch;
            }
            0x82EBA2D8 => {
    //   block [0x82EBA2D8..0x82EBA308)
	// 82EBA2D8: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBA2DC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA2E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2E4: 419A0024  beq cr6, 0x82eba308
	if ctx.cr[6].eq {
	pc = 0x82EBA308; continue 'dispatch;
	}
	// 82EBA2E8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA2EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA2F0: 41820018  beq 0x82eba308
	if ctx.cr[0].eq {
	pc = 0x82EBA308; continue 'dispatch;
	}
	// 82EBA2F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA2F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA2FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA304: 4E800421  bctrl
	ctx.lr = 0x82EBA308;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA308 => {
    //   block [0x82EBA308..0x82EBA31C)
	// 82EBA308: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBA30C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA310: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA314: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA318: 4198FFC0  blt cr6, 0x82eba2d8
	if ctx.cr[6].lt {
	pc = 0x82EBA2D8; continue 'dispatch;
	}
	pc = 0x82EBA31C; continue 'dispatch;
            }
            0x82EBA31C => {
    //   block [0x82EBA31C..0x82EBA330)
	// 82EBA31C: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBA320: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA328: 4099004C  ble cr6, 0x82eba374
	if !ctx.cr[6].gt {
	pc = 0x82EBA374; continue 'dispatch;
	}
	// 82EBA32C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA330; continue 'dispatch;
            }
            0x82EBA330 => {
    //   block [0x82EBA330..0x82EBA360)
	// 82EBA330: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBA334: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA33C: 419A0024  beq cr6, 0x82eba360
	if ctx.cr[6].eq {
	pc = 0x82EBA360; continue 'dispatch;
	}
	// 82EBA340: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA348: 41820018  beq 0x82eba360
	if ctx.cr[0].eq {
	pc = 0x82EBA360; continue 'dispatch;
	}
	// 82EBA34C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA350: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA354: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA35C: 4E800421  bctrl
	ctx.lr = 0x82EBA360;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA360 => {
    //   block [0x82EBA360..0x82EBA374)
	// 82EBA360: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBA364: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA368: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA36C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA370: 4198FFC0  blt cr6, 0x82eba330
	if ctx.cr[6].lt {
	pc = 0x82EBA330; continue 'dispatch;
	}
	pc = 0x82EBA374; continue 'dispatch;
            }
            0x82EBA374 => {
    //   block [0x82EBA374..0x82EBA388)
	// 82EBA374: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBA378: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA380: 4099004C  ble cr6, 0x82eba3cc
	if !ctx.cr[6].gt {
	pc = 0x82EBA3CC; continue 'dispatch;
	}
	// 82EBA384: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA388; continue 'dispatch;
            }
            0x82EBA388 => {
    //   block [0x82EBA388..0x82EBA3B8)
	// 82EBA388: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBA38C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA394: 419A0024  beq cr6, 0x82eba3b8
	if ctx.cr[6].eq {
	pc = 0x82EBA3B8; continue 'dispatch;
	}
	// 82EBA398: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA39C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3A0: 41820018  beq 0x82eba3b8
	if ctx.cr[0].eq {
	pc = 0x82EBA3B8; continue 'dispatch;
	}
	// 82EBA3A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA3A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA3AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA3B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA3B4: 4E800421  bctrl
	ctx.lr = 0x82EBA3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA3B8 => {
    //   block [0x82EBA3B8..0x82EBA3CC)
	// 82EBA3B8: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBA3BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA3C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA3C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA3C8: 4198FFC0  blt cr6, 0x82eba388
	if ctx.cr[6].lt {
	pc = 0x82EBA388; continue 'dispatch;
	}
	pc = 0x82EBA3CC; continue 'dispatch;
            }
            0x82EBA3CC => {
    //   block [0x82EBA3CC..0x82EBA3E0)
	// 82EBA3CC: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBA3D0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA3D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3D8: 4099004C  ble cr6, 0x82eba424
	if !ctx.cr[6].gt {
	pc = 0x82EBA424; continue 'dispatch;
	}
	// 82EBA3DC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA3E0; continue 'dispatch;
            }
            0x82EBA3E0 => {
    //   block [0x82EBA3E0..0x82EBA410)
	// 82EBA3E0: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBA3E4: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA3E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3EC: 419A0024  beq cr6, 0x82eba410
	if ctx.cr[6].eq {
	pc = 0x82EBA410; continue 'dispatch;
	}
	// 82EBA3F0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA3F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA3F8: 41820018  beq 0x82eba410
	if ctx.cr[0].eq {
	pc = 0x82EBA410; continue 'dispatch;
	}
	// 82EBA3FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA400: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA404: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA40C: 4E800421  bctrl
	ctx.lr = 0x82EBA410;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA410 => {
    //   block [0x82EBA410..0x82EBA424)
	// 82EBA410: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBA414: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA418: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA41C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA420: 4198FFC0  blt cr6, 0x82eba3e0
	if ctx.cr[6].lt {
	pc = 0x82EBA3E0; continue 'dispatch;
	}
	pc = 0x82EBA424; continue 'dispatch;
            }
            0x82EBA424 => {
    //   block [0x82EBA424..0x82EBA438)
	// 82EBA424: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBA428: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA42C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA430: 4099004C  ble cr6, 0x82eba47c
	if !ctx.cr[6].gt {
	pc = 0x82EBA47C; continue 'dispatch;
	}
	// 82EBA434: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA438; continue 'dispatch;
            }
            0x82EBA438 => {
    //   block [0x82EBA438..0x82EBA468)
	// 82EBA438: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBA43C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA440: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA444: 419A0024  beq cr6, 0x82eba468
	if ctx.cr[6].eq {
	pc = 0x82EBA468; continue 'dispatch;
	}
	// 82EBA448: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA44C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA450: 41820018  beq 0x82eba468
	if ctx.cr[0].eq {
	pc = 0x82EBA468; continue 'dispatch;
	}
	// 82EBA454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA458: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA464: 4E800421  bctrl
	ctx.lr = 0x82EBA468;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA468 => {
    //   block [0x82EBA468..0x82EBA47C)
	// 82EBA468: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBA46C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA470: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA474: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA478: 4198FFC0  blt cr6, 0x82eba438
	if ctx.cr[6].lt {
	pc = 0x82EBA438; continue 'dispatch;
	}
	pc = 0x82EBA47C; continue 'dispatch;
            }
            0x82EBA47C => {
    //   block [0x82EBA47C..0x82EBA490)
	// 82EBA47C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBA480: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA488: 4099004C  ble cr6, 0x82eba4d4
	if !ctx.cr[6].gt {
	pc = 0x82EBA4D4; continue 'dispatch;
	}
	// 82EBA48C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA490; continue 'dispatch;
            }
            0x82EBA490 => {
    //   block [0x82EBA490..0x82EBA4C0)
	// 82EBA490: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBA494: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA49C: 419A0024  beq cr6, 0x82eba4c0
	if ctx.cr[6].eq {
	pc = 0x82EBA4C0; continue 'dispatch;
	}
	// 82EBA4A0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA4A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4A8: 41820018  beq 0x82eba4c0
	if ctx.cr[0].eq {
	pc = 0x82EBA4C0; continue 'dispatch;
	}
	// 82EBA4AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA4B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA4B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA4B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA4BC: 4E800421  bctrl
	ctx.lr = 0x82EBA4C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA4C0 => {
    //   block [0x82EBA4C0..0x82EBA4D4)
	// 82EBA4C0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBA4C4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA4C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA4CC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA4D0: 4198FFC0  blt cr6, 0x82eba490
	if ctx.cr[6].lt {
	pc = 0x82EBA490; continue 'dispatch;
	}
	pc = 0x82EBA4D4; continue 'dispatch;
            }
            0x82EBA4D4 => {
    //   block [0x82EBA4D4..0x82EBA4E8)
	// 82EBA4D4: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBA4D8: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EBA4DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4E0: 4099004C  ble cr6, 0x82eba52c
	if !ctx.cr[6].gt {
	pc = 0x82EBA52C; continue 'dispatch;
	}
	// 82EBA4E4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82EBA4E8; continue 'dispatch;
            }
            0x82EBA4E8 => {
    //   block [0x82EBA4E8..0x82EBA518)
	// 82EBA4E8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBA4EC: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA4F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA4F4: 419A0024  beq cr6, 0x82eba518
	if ctx.cr[6].eq {
	pc = 0x82EBA518; continue 'dispatch;
	}
	// 82EBA4F8: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA4FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA500: 41820018  beq 0x82eba518
	if ctx.cr[0].eq {
	pc = 0x82EBA518; continue 'dispatch;
	}
	// 82EBA504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA508: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EBA50C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA514: 4E800421  bctrl
	ctx.lr = 0x82EBA518;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA518 => {
    //   block [0x82EBA518..0x82EBA52C)
	// 82EBA518: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBA51C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA520: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA524: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA528: 4198FFC0  blt cr6, 0x82eba4e8
	if ctx.cr[6].lt {
	pc = 0x82EBA4E8; continue 'dispatch;
	}
	pc = 0x82EBA52C; continue 'dispatch;
            }
            0x82EBA52C => {
    //   block [0x82EBA52C..0x82EBA558)
	// 82EBA52C: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EBA530: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA534: 41820024  beq 0x82eba558
	if ctx.cr[0].eq {
	pc = 0x82EBA558; continue 'dispatch;
	}
	// 82EBA538: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA53C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA540: 41820018  beq 0x82eba558
	if ctx.cr[0].eq {
	pc = 0x82EBA558; continue 'dispatch;
	}
	// 82EBA544: 3D6082EB  lis r11, -0x7d15
	ctx.r[11].s64 = -2098528256;
	// 82EBA548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EBA54C: 388B5818  addi r4, r11, 0x5818
	ctx.r[4].s64 = ctx.r[11].s64 + 22552;
	// 82EBA550: 480125B1  bl 0x82eccb00
	ctx.lr = 0x82EBA554;
	sub_82ECCB00(ctx, base);
	// 82EBA554: 9B9F00A0  stb r28, 0xa0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[28].u8 ) };
	pc = 0x82EBA558; continue 'dispatch;
            }
            0x82EBA558 => {
    //   block [0x82EBA558..0x82EBA580)
	// 82EBA558: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EBA55C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA560: 41820020  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA564: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA568: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA56C: 41820014  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA570: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA578: 41820008  beq 0x82eba580
	if ctx.cr[0].eq {
	pc = 0x82EBA580; continue 'dispatch;
	}
	// 82EBA57C: 480189B5  bl 0x82ed2f30
	ctx.lr = 0x82EBA580;
	sub_82ED2F30(ctx, base);
	pc = 0x82EBA580; continue 'dispatch;
            }
            0x82EBA580 => {
    //   block [0x82EBA580..0x82EBA5AC)
	// 82EBA580: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EBA584: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82EBA588: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA58C: 41820020  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA590: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EBA594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA598: 41820014  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA59C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EBA5A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA5A4: 41820008  beq 0x82eba5ac
	if ctx.cr[0].eq {
	pc = 0x82EBA5AC; continue 'dispatch;
	}
	// 82EBA5A8: 48018989  bl 0x82ed2f30
	ctx.lr = 0x82EBA5AC;
	sub_82ED2F30(ctx, base);
	pc = 0x82EBA5AC; continue 'dispatch;
            }
            0x82EBA5AC => {
    //   block [0x82EBA5AC..0x82EBA638)
	// 82EBA5AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBA5B0: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82EBA5B4: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 82EBA5B8: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 82EBA5BC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBA5C0: 917F0418  stw r11, 0x418(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1048 as u32), ctx.r[11].u32 ) };
	// 82EBA5C4: 917F03A4  stw r11, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	// 82EBA5C8: 917F0334  stw r11, 0x334(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 82EBA5CC: 917F02D8  stw r11, 0x2d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), ctx.r[11].u32 ) };
	// 82EBA5D0: 917F027C  stw r11, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[11].u32 ) };
	// 82EBA5D4: 4BFFEDAD  bl 0x82eb9380
	ctx.lr = 0x82EBA5D8;
	sub_82EB9380(ctx, base);
	// 82EBA5D8: 387F0254  addi r3, r31, 0x254
	ctx.r[3].s64 = ctx.r[31].s64 + 596;
	// 82EBA5DC: 4BFFEDA5  bl 0x82eb9380
	ctx.lr = 0x82EBA5E0;
	sub_82EB9380(ctx, base);
	// 82EBA5E0: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82EBA5E4: 4BFFED9D  bl 0x82eb9380
	ctx.lr = 0x82EBA5E8;
	sub_82EB9380(ctx, base);
	// 82EBA5E8: 387F022C  addi r3, r31, 0x22c
	ctx.r[3].s64 = ctx.r[31].s64 + 556;
	// 82EBA5EC: 4BFFED95  bl 0x82eb9380
	ctx.lr = 0x82EBA5F0;
	sub_82EB9380(ctx, base);
	// 82EBA5F0: 387F0218  addi r3, r31, 0x218
	ctx.r[3].s64 = ctx.r[31].s64 + 536;
	// 82EBA5F4: 4BFFED8D  bl 0x82eb9380
	ctx.lr = 0x82EBA5F8;
	sub_82EB9380(ctx, base);
	// 82EBA5F8: 387F0204  addi r3, r31, 0x204
	ctx.r[3].s64 = ctx.r[31].s64 + 516;
	// 82EBA5FC: 4BFFED85  bl 0x82eb9380
	ctx.lr = 0x82EBA600;
	sub_82EB9380(ctx, base);
	// 82EBA600: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82EBA604: 4BFFED7D  bl 0x82eb9380
	ctx.lr = 0x82EBA608;
	sub_82EB9380(ctx, base);
	// 82EBA608: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82EBA60C: 4BFFED75  bl 0x82eb9380
	ctx.lr = 0x82EBA610;
	sub_82EB9380(ctx, base);
	// 82EBA610: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82EBA614: 4BFFED6D  bl 0x82eb9380
	ctx.lr = 0x82EBA618;
	sub_82EB9380(ctx, base);
	// 82EBA618: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82EBA61C: 4BFFED65  bl 0x82eb9380
	ctx.lr = 0x82EBA620;
	sub_82EB9380(ctx, base);
	// 82EBA620: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EBA624: 4BFFED5D  bl 0x82eb9380
	ctx.lr = 0x82EBA628;
	sub_82EB9380(ctx, base);
	// 82EBA628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBA62C: 4BFCB24D  bl 0x82e85878
	ctx.lr = 0x82EBA630;
	sub_82E85878(ctx, base);
	// 82EBA630: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBA634: 4BDEEE24  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBA638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBA638 size=3388
    let mut pc: u32 = 0x82EBA638;
    'dispatch: loop {
        match pc {
            0x82EBA638 => {
    //   block [0x82EBA638..0x82EBA670)
	// 82EBA638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBA63C: 4BDEEDC1  bl 0x82ca93fc
	ctx.lr = 0x82EBA640;
	sub_82CA93D0(ctx, base);
	// 82EBA640: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBA644: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EBA648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBA64C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EBA650: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBA654: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBA658: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBA65C: C14A0C14  lfs f10, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBA660: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA664: 4182000C  beq 0x82eba670
	if ctx.cr[0].eq {
	pc = 0x82EBA670; continue 'dispatch;
	}
	// 82EBA668: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA66C: 48000008  b 0x82eba674
	pc = 0x82EBA674; continue 'dispatch;
            }
            0x82EBA670 => {
    //   block [0x82EBA670..0x82EBA674)
	// 82EBA670: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	pc = 0x82EBA674; continue 'dispatch;
            }
            0x82EBA674 => {
    //   block [0x82EBA674..0x82EBA68C)
	// 82EBA674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA678: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBA67C: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBA680: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA684: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBA688: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82EBA68C; continue 'dispatch;
            }
            0x82EBA68C => {
    //   block [0x82EBA68C..0x82EBA698)
	// 82EBA68C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBA690: 41980008  blt cr6, 0x82eba698
	if ctx.cr[6].lt {
	pc = 0x82EBA698; continue 'dispatch;
	}
	// 82EBA694: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x82EBA698; continue 'dispatch;
            }
            0x82EBA698 => {
    //   block [0x82EBA698..0x82EBA6B8)
	// 82EBA698: FF0C6000  fcmpu cr6, f12, f12
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[12].f64);
	// 82EBA69C: 409AFFF0  bne cr6, 0x82eba68c
	if !ctx.cr[6].eq {
	pc = 0x82EBA68C; continue 'dispatch;
	}
	// 82EBA6A0: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBA6A4: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBA6A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA6AC: 4182000C  beq 0x82eba6b8
	if ctx.cr[0].eq {
	pc = 0x82EBA6B8; continue 'dispatch;
	}
	// 82EBA6B0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBA6B4: 48000008  b 0x82eba6bc
	pc = 0x82EBA6BC; continue 'dispatch;
            }
            0x82EBA6B8 => {
    //   block [0x82EBA6B8..0x82EBA6BC)
	// 82EBA6B8: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	pc = 0x82EBA6BC; continue 'dispatch;
            }
            0x82EBA6BC => {
    //   block [0x82EBA6BC..0x82EBA6CC)
	// 82EBA6BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA6C0: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBA6C4: C1AB0AEC  lfs f13, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA6C8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82EBA6CC; continue 'dispatch;
            }
            0x82EBA6CC => {
    //   block [0x82EBA6CC..0x82EBA6D8)
	// 82EBA6CC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EBA6D0: 41980008  blt cr6, 0x82eba6d8
	if ctx.cr[6].lt {
	pc = 0x82EBA6D8; continue 'dispatch;
	}
	// 82EBA6D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBA6D8; continue 'dispatch;
            }
            0x82EBA6D8 => {
    //   block [0x82EBA6D8..0x82EBA71C)
	// 82EBA6D8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBA6DC: 409AFFF0  bne cr6, 0x82eba6cc
	if !ctx.cr[6].eq {
	pc = 0x82EBA6CC; continue 'dispatch;
	}
	// 82EBA6E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBA6E4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBA6E8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EBA6EC: D15F043C  stfs f10, 0x43c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1084 as u32), tmp.u32 ) };
	// 82EBA6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBA6F4: C1AB0BF8  lfs f13, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBA6F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBA6FC: D1BF0420  stfs f13, 0x420(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), tmp.u32 ) };
	// 82EBA700: 9B3F019D  stb r25, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[25].u8 ) };
	// 82EBA704: 997F019C  stb r11, 0x19c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), ctx.r[11].u8 ) };
	// 82EBA708: 4BFCACA1  bl 0x82e853a8
	ctx.lr = 0x82EBA70C;
	sub_82E853A8(ctx, base);
	// 82EBA70C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA710: 4082000C  bne 0x82eba71c
	if !ctx.cr[0].eq {
	pc = 0x82EBA71C; continue 'dispatch;
	}
	// 82EBA714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBA718: 48000C54  b 0x82ebb36c
	pc = 0x82EBB36C; continue 'dispatch;
            }
            0x82EBA71C => {
    //   block [0x82EBA71C..0x82EBA73C)
	// 82EBA71C: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82EBA720: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA724: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 82EBA728: 615CFFFF  ori r28, r10, 0xffff
	ctx.r[28].u64 = ctx.r[10].u64 | 65535;
	// 82EBA72C: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA730: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA734: 40990008  ble cr6, 0x82eba73c
	if !ctx.cr[6].gt {
	pc = 0x82EBA73C; continue 'dispatch;
	}
	// 82EBA738: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82EBA73C; continue 'dispatch;
            }
            0x82EBA73C => {
    //   block [0x82EBA73C..0x82EBA758)
	// 82EBA73C: 4B75C1ED  bl 0x82616928
	ctx.lr = 0x82EBA740;
	sub_82616928(ctx, base);
	// 82EBA740: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA744: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBA748: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EBA74C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBA750: 40990024  ble cr6, 0x82eba774
	if !ctx.cr[6].gt {
	pc = 0x82EBA774; continue 'dispatch;
	}
	// 82EBA754: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x82EBA758; continue 'dispatch;
            }
            0x82EBA758 => {
    //   block [0x82EBA758..0x82EBA774)
	// 82EBA758: 813F0060  lwz r9, 0x60(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EBA75C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBA760: 7F29512E  stwx r25, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[25].u32) };
	// 82EBA764: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EBA768: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EBA76C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EBA770: 4198FFE8  blt cr6, 0x82eba758
	if ctx.cr[6].lt {
	pc = 0x82EBA758; continue 'dispatch;
	}
	pc = 0x82EBA774; continue 'dispatch;
            }
            0x82EBA774 => {
    //   block [0x82EBA774..0x82EBA7B8)
	// 82EBA774: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EBA778: 4B75C1B1  bl 0x82616928
	ctx.lr = 0x82EBA77C;
	sub_82616928(ctx, base);
	// 82EBA77C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EBA780: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82EBA784: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82EBA788: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA78C: 817E9E3C  lwz r11, -0x61c4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 82EBA790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA794: 409A006C  bne cr6, 0x82eba800
	if !ctx.cr[6].eq {
	pc = 0x82EBA800; continue 'dispatch;
	}
	// 82EBA798: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82EBA79C: 3D400924  lis r10, 0x924
	ctx.r[10].s64 = 153354240;
	// 82EBA7A0: 614A9249  ori r10, r10, 0x9249
	ctx.r[10].u64 = ctx.r[10].u64 | 37449;
	// 82EBA7A4: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EBA7AC: 1C6B001C  mulli r3, r11, 0x1c
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82EBA7B0: 40990008  ble cr6, 0x82eba7b8
	if !ctx.cr[6].gt {
	pc = 0x82EBA7B8; continue 'dispatch;
	}
	// 82EBA7B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82EBA7B8; continue 'dispatch;
            }
            0x82EBA7B8 => {
    //   block [0x82EBA7B8..0x82EBA7D4)
	// 82EBA7B8: 4B75C171  bl 0x82616928
	ctx.lr = 0x82EBA7BC;
	sub_82616928(ctx, base);
	// 82EBA7BC: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7C0: 907E9E3C  stw r3, -0x61c4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-25028 as u32), ctx.r[3].u32 ) };
	// 82EBA7C4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA7C8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA7CC: 40990008  ble cr6, 0x82eba7d4
	if !ctx.cr[6].gt {
	pc = 0x82EBA7D4; continue 'dispatch;
	}
	// 82EBA7D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82EBA7D4; continue 'dispatch;
            }
            0x82EBA7D4 => {
    //   block [0x82EBA7D4..0x82EBA7F4)
	// 82EBA7D4: 4B75C155  bl 0x82616928
	ctx.lr = 0x82EBA7D8;
	sub_82616928(ctx, base);
	// 82EBA7D8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBA7DC: 817DDF34  lwz r11, -0x20cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8396 as u32) ) } as u64;
	// 82EBA7E0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82EBA7E4: 906A9E40  stw r3, -0x61c0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-25024 as u32), ctx.r[3].u32 ) };
	// 82EBA7E8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBA7EC: 40990008  ble cr6, 0x82eba7f4
	if !ctx.cr[6].gt {
	pc = 0x82EBA7F4; continue 'dispatch;
	}
	// 82EBA7F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	pc = 0x82EBA7F4; continue 'dispatch;
            }
            0x82EBA7F4 => {
    //   block [0x82EBA7F4..0x82EBA800)
	// 82EBA7F4: 4B75C135  bl 0x82616928
	ctx.lr = 0x82EBA7F8;
	sub_82616928(ctx, base);
	// 82EBA7F8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA7FC: 906B9E44  stw r3, -0x61bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25020 as u32), ctx.r[3].u32 ) };
	pc = 0x82EBA800; continue 'dispatch;
            }
            0x82EBA800 => {
    //   block [0x82EBA800..0x82EBA82C)
	// 82EBA800: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBA804: 386001C4  li r3, 0x1c4
	ctx.r[3].s64 = 452;
	// 82EBA808: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EBA80C: 409A0020  bne cr6, 0x82eba82c
	if !ctx.cr[6].eq {
	pc = 0x82EBA82C; continue 'dispatch;
	}
	// 82EBA810: 4B75C119  bl 0x82616928
	ctx.lr = 0x82EBA814;
	sub_82616928(ctx, base);
	// 82EBA814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA818: 41820040  beq 0x82eba858
	if ctx.cr[0].eq {
	pc = 0x82EBA858; continue 'dispatch;
	}
	// 82EBA81C: 3CC00005  lis r6, 5
	ctx.r[6].s64 = 327680;
	// 82EBA820: 38A02800  li r5, 0x2800
	ctx.r[5].s64 = 10240;
	// 82EBA824: 38803800  li r4, 0x3800
	ctx.r[4].s64 = 14336;
	// 82EBA828: 48000028  b 0x82eba850
	pc = 0x82EBA850; continue 'dispatch;
            }
            0x82EBA82C => {
    //   block [0x82EBA82C..0x82EBA850)
	// 82EBA82C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EBA830: 1FCB0018  mulli r30, r11, 0x18
	ctx.r[30].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82EBA834: 1FAB0014  mulli r29, r11, 0x14
	ctx.r[29].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 82EBA838: 4B75C0F1  bl 0x82616928
	ctx.lr = 0x82EBA83C;
	sub_82616928(ctx, base);
	// 82EBA83C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA840: 41820018  beq 0x82eba858
	if ctx.cr[0].eq {
	pc = 0x82EBA858; continue 'dispatch;
	}
	// 82EBA844: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82EBA848: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBA84C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x82EBA850; continue 'dispatch;
            }
            0x82EBA850 => {
    //   block [0x82EBA850..0x82EBA858)
	// 82EBA850: 4BFFBCA9  bl 0x82eb64f8
	ctx.lr = 0x82EBA854;
	sub_82EB64F8(ctx, base);
	// 82EBA854: 48000008  b 0x82eba85c
	pc = 0x82EBA85C; continue 'dispatch;
            }
            0x82EBA858 => {
    //   block [0x82EBA858..0x82EBA85C)
	// 82EBA858: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBA85C; continue 'dispatch;
            }
            0x82EBA85C => {
    //   block [0x82EBA85C..0x82EBA8C4)
	// 82EBA85C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA860: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EBA864: 3BCBA9B8  addi r30, r11, -0x5648
	ctx.r[30].s64 = ctx.r[11].s64 + -22088;
	// 82EBA868: 4B3A6151  bl 0x822609b8
	ctx.lr = 0x82EBA86C;
	sub_822609B8(ctx, base);
	// 82EBA86C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBA870: 4BFC68F9  bl 0x82e81168
	ctx.lr = 0x82EBA874;
	sub_82E81168(ctx, base);
	// 82EBA874: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA878: 907F0194  stw r3, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[3].u32 ) };
	// 82EBA87C: 3BCBA994  addi r30, r11, -0x566c
	ctx.r[30].s64 = ctx.r[11].s64 + -22124;
	// 82EBA880: 4B3A6139  bl 0x822609b8
	ctx.lr = 0x82EBA884;
	sub_822609B8(ctx, base);
	// 82EBA884: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBA888: 4BFC68E1  bl 0x82e81168
	ctx.lr = 0x82EBA88C;
	sub_82E81168(ctx, base);
	// 82EBA88C: 817F01B0  lwz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EBA890: 3B7F01B0  addi r27, r31, 0x1b0
	ctx.r[27].s64 = ctx.r[31].s64 + 432;
	// 82EBA894: 907F0414  stw r3, 0x414(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1044 as u32), ctx.r[3].u32 ) };
	// 82EBA898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA89C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA8A0: 3B4BA98C  addi r26, r11, -0x5674
	ctx.r[26].s64 = ctx.r[11].s64 + -22132;
	// 82EBA8A4: 409A00F0  bne cr6, 0x82eba994
	if !ctx.cr[6].eq {
	pc = 0x82EBA994; continue 'dispatch;
	}
	// 82EBA8A8: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA8AC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBA8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA8B4: 40990078  ble cr6, 0x82eba92c
	if !ctx.cr[6].gt {
	pc = 0x82EBA92C; continue 'dispatch;
	}
	// 82EBA8B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA8BC: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBA8C0: 3B8BE058  addi r28, r11, -0x1fa8
	ctx.r[28].s64 = ctx.r[11].s64 + -8104;
	pc = 0x82EBA8C4; continue 'dispatch;
            }
            0x82EBA8C4 => {
    //   block [0x82EBA8C4..0x82EBA8DC)
	// 82EBA8C4: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA8C8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA8CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA8D0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBA8D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA8D8: 4E800421  bctrl
	ctx.lr = 0x82EBA8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA8DC => {
    //   block [0x82EBA8DC..0x82EBA8F4)
	// 82EBA8DC: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBA8E0: 419A0034  beq cr6, 0x82eba914
	if ctx.cr[6].eq {
	pc = 0x82EBA914; continue 'dispatch;
	}
	// 82EBA8E4: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBA8E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA8EC: 4082FFF0  bne 0x82eba8dc
	if !ctx.cr[0].eq {
	pc = 0x82EBA8DC; continue 'dispatch;
	}
	// 82EBA8F0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBA8F4; continue 'dispatch;
            }
            0x82EBA8F4 => {
    //   block [0x82EBA8F4..0x82EBA914)
	// 82EBA8F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA8F8: 40820024  bne 0x82eba91c
	if !ctx.cr[0].eq {
	pc = 0x82EBA91C; continue 'dispatch;
	}
	// 82EBA8FC: 817F01AC  lwz r11, 0x1ac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBA900: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBA904: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBA908: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBA90C: 4198FFB8  blt cr6, 0x82eba8c4
	if ctx.cr[6].lt {
	pc = 0x82EBA8C4; continue 'dispatch;
	}
	// 82EBA910: 4800001C  b 0x82eba92c
	pc = 0x82EBA92C; continue 'dispatch;
            }
            0x82EBA914 => {
    //   block [0x82EBA914..0x82EBA91C)
	// 82EBA914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBA918: 4BFFFFDC  b 0x82eba8f4
	pc = 0x82EBA8F4; continue 'dispatch;
            }
            0x82EBA91C => {
    //   block [0x82EBA91C..0x82EBA92C)
	// 82EBA91C: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBA920: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBA924: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBA928: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBA92C; continue 'dispatch;
            }
            0x82EBA92C => {
    //   block [0x82EBA92C..0x82EBA96C)
	// 82EBA92C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA934: 409A0060  bne cr6, 0x82eba994
	if !ctx.cr[6].eq {
	pc = 0x82EBA994; continue 'dispatch;
	}
	// 82EBA938: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBA93C: 4B75BFED  bl 0x82616928
	ctx.lr = 0x82EBA940;
	sub_82616928(ctx, base);
	// 82EBA940: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBA944: 41820028  beq 0x82eba96c
	if ctx.cr[0].eq {
	pc = 0x82EBA96C; continue 'dispatch;
	}
	// 82EBA948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBA94C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBA950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBA954: 4BFFA9DD  bl 0x82eb5330
	ctx.lr = 0x82EBA958;
	sub_82EB5330(ctx, base);
	// 82EBA958: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBA95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBA960: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82EBA964: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBA968: 48000008  b 0x82eba970
	pc = 0x82EBA970; continue 'dispatch;
            }
            0x82EBA96C => {
    //   block [0x82EBA96C..0x82EBA970)
	// 82EBA96C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBA970; continue 'dispatch;
            }
            0x82EBA970 => {
    //   block [0x82EBA970..0x82EBA994)
	// 82EBA970: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBA974: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBA978: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA97C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBA980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA984: 4E800421  bctrl
	ctx.lr = 0x82EBA988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBA988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBA98C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82EBA990: 4BFFE901  bl 0x82eb9290
	ctx.lr = 0x82EBA994;
	sub_82EB9290(ctx, base);
            }
            0x82EBA994 => {
    //   block [0x82EBA994..0x82EBA9C0)
	// 82EBA994: 817F01C4  lwz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EBA998: 3B7F01C4  addi r27, r31, 0x1c4
	ctx.r[27].s64 = ctx.r[31].s64 + 452;
	// 82EBA99C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9A0: 409A00F0  bne cr6, 0x82ebaa90
	if !ctx.cr[6].eq {
	pc = 0x82EBAA90; continue 'dispatch;
	}
	// 82EBA9A4: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA9A8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBA9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9B0: 40990078  ble cr6, 0x82ebaa28
	if !ctx.cr[6].gt {
	pc = 0x82EBAA28; continue 'dispatch;
	}
	// 82EBA9B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBA9B8: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBA9BC: 3B8BDD1C  addi r28, r11, -0x22e4
	ctx.r[28].s64 = ctx.r[11].s64 + -8932;
	pc = 0x82EBA9C0; continue 'dispatch;
            }
            0x82EBA9C0 => {
    //   block [0x82EBA9C0..0x82EBA9D8)
	// 82EBA9C0: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBA9C4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBA9C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBA9CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBA9D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBA9D4: 4E800421  bctrl
	ctx.lr = 0x82EBA9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBA9D8 => {
    //   block [0x82EBA9D8..0x82EBA9F0)
	// 82EBA9D8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBA9DC: 419A0034  beq cr6, 0x82ebaa10
	if ctx.cr[6].eq {
	pc = 0x82EBAA10; continue 'dispatch;
	}
	// 82EBA9E0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBA9E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBA9E8: 4082FFF0  bne 0x82eba9d8
	if !ctx.cr[0].eq {
	pc = 0x82EBA9D8; continue 'dispatch;
	}
	// 82EBA9EC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBA9F0; continue 'dispatch;
            }
            0x82EBA9F0 => {
    //   block [0x82EBA9F0..0x82EBAA10)
	// 82EBA9F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBA9F4: 40820024  bne 0x82ebaa18
	if !ctx.cr[0].eq {
	pc = 0x82EBAA18; continue 'dispatch;
	}
	// 82EBA9F8: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBA9FC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAA00: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAA04: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAA08: 4198FFB8  blt cr6, 0x82eba9c0
	if ctx.cr[6].lt {
	pc = 0x82EBA9C0; continue 'dispatch;
	}
	// 82EBAA0C: 4800001C  b 0x82ebaa28
	pc = 0x82EBAA28; continue 'dispatch;
            }
            0x82EBAA10 => {
    //   block [0x82EBAA10..0x82EBAA18)
	// 82EBAA10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAA14: 4BFFFFDC  b 0x82eba9f0
	pc = 0x82EBA9F0; continue 'dispatch;
            }
            0x82EBAA18 => {
    //   block [0x82EBAA18..0x82EBAA28)
	// 82EBAA18: 817F01B8  lwz r11, 0x1b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBAA1C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAA20: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAA24: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBAA28; continue 'dispatch;
            }
            0x82EBAA28 => {
    //   block [0x82EBAA28..0x82EBAA68)
	// 82EBAA28: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAA30: 409A0060  bne cr6, 0x82ebaa90
	if !ctx.cr[6].eq {
	pc = 0x82EBAA90; continue 'dispatch;
	}
	// 82EBAA34: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EBAA38: 4B75BEF1  bl 0x82616928
	ctx.lr = 0x82EBAA3C;
	sub_82616928(ctx, base);
	// 82EBAA3C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAA40: 41820028  beq 0x82ebaa68
	if ctx.cr[0].eq {
	pc = 0x82EBAA68; continue 'dispatch;
	}
	// 82EBAA44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAA48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAA4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAA50: 4BFFA8E1  bl 0x82eb5330
	ctx.lr = 0x82EBAA54;
	sub_82EB5330(ctx, base);
	// 82EBAA54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAA5C: 396BA7E8  addi r11, r11, -0x5818
	ctx.r[11].s64 = ctx.r[11].s64 + -22552;
	// 82EBAA60: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAA64: 48000008  b 0x82ebaa6c
	pc = 0x82EBAA6C; continue 'dispatch;
            }
            0x82EBAA68 => {
    //   block [0x82EBAA68..0x82EBAA6C)
	// 82EBAA68: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBAA6C; continue 'dispatch;
            }
            0x82EBAA6C => {
    //   block [0x82EBAA6C..0x82EBAA90)
	// 82EBAA6C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAA70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAA74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAA80: 4E800421  bctrl
	ctx.lr = 0x82EBAA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAA84: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAA88: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82EBAA8C: 4BFFE805  bl 0x82eb9290
	ctx.lr = 0x82EBAA90;
	sub_82EB9290(ctx, base);
            }
            0x82EBAA90 => {
    //   block [0x82EBAA90..0x82EBAABC)
	// 82EBAA90: 817F01D8  lwz r11, 0x1d8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EBAA94: 3B7F01D8  addi r27, r31, 0x1d8
	ctx.r[27].s64 = ctx.r[31].s64 + 472;
	// 82EBAA98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAA9C: 409A00F0  bne cr6, 0x82ebab8c
	if !ctx.cr[6].eq {
	pc = 0x82EBAB8C; continue 'dispatch;
	}
	// 82EBAAA0: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBAAA4: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAAA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAAAC: 40990078  ble cr6, 0x82ebab24
	if !ctx.cr[6].gt {
	pc = 0x82EBAB24; continue 'dispatch;
	}
	// 82EBAAB0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAAB4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAAB8: 3B8BDAF4  addi r28, r11, -0x250c
	ctx.r[28].s64 = ctx.r[11].s64 + -9484;
	pc = 0x82EBAABC; continue 'dispatch;
            }
            0x82EBAABC => {
    //   block [0x82EBAABC..0x82EBAAD4)
	// 82EBAABC: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBAAC0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBAAC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAAC8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAAD0: 4E800421  bctrl
	ctx.lr = 0x82EBAAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBAAD4 => {
    //   block [0x82EBAAD4..0x82EBAAEC)
	// 82EBAAD4: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAAD8: 419A0034  beq cr6, 0x82ebab0c
	if ctx.cr[6].eq {
	pc = 0x82EBAB0C; continue 'dispatch;
	}
	// 82EBAADC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAAE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAAE4: 4082FFF0  bne 0x82ebaad4
	if !ctx.cr[0].eq {
	pc = 0x82EBAAD4; continue 'dispatch;
	}
	// 82EBAAE8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBAAEC; continue 'dispatch;
            }
            0x82EBAAEC => {
    //   block [0x82EBAAEC..0x82EBAB0C)
	// 82EBAAEC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAAF0: 40820024  bne 0x82ebab14
	if !ctx.cr[0].eq {
	pc = 0x82EBAB14; continue 'dispatch;
	}
	// 82EBAAF4: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBAAF8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAAFC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAB00: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAB04: 4198FFB8  blt cr6, 0x82ebaabc
	if ctx.cr[6].lt {
	pc = 0x82EBAABC; continue 'dispatch;
	}
	// 82EBAB08: 4800001C  b 0x82ebab24
	pc = 0x82EBAB24; continue 'dispatch;
            }
            0x82EBAB0C => {
    //   block [0x82EBAB0C..0x82EBAB14)
	// 82EBAB0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAB10: 4BFFFFDC  b 0x82ebaaec
	pc = 0x82EBAAEC; continue 'dispatch;
            }
            0x82EBAB14 => {
    //   block [0x82EBAB14..0x82EBAB24)
	// 82EBAB14: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBAB18: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAB1C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAB20: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBAB24; continue 'dispatch;
            }
            0x82EBAB24 => {
    //   block [0x82EBAB24..0x82EBAB64)
	// 82EBAB24: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAB28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAB2C: 409A0060  bne cr6, 0x82ebab8c
	if !ctx.cr[6].eq {
	pc = 0x82EBAB8C; continue 'dispatch;
	}
	// 82EBAB30: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EBAB34: 4B75BDF5  bl 0x82616928
	ctx.lr = 0x82EBAB38;
	sub_82616928(ctx, base);
	// 82EBAB38: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAB3C: 41820028  beq 0x82ebab64
	if ctx.cr[0].eq {
	pc = 0x82EBAB64; continue 'dispatch;
	}
	// 82EBAB40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAB44: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAB48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAB4C: 4BFFA7E5  bl 0x82eb5330
	ctx.lr = 0x82EBAB50;
	sub_82EB5330(ctx, base);
	// 82EBAB50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAB58: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 82EBAB5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAB60: 48000008  b 0x82ebab68
	pc = 0x82EBAB68; continue 'dispatch;
            }
            0x82EBAB64 => {
    //   block [0x82EBAB64..0x82EBAB68)
	// 82EBAB64: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBAB68; continue 'dispatch;
            }
            0x82EBAB68 => {
    //   block [0x82EBAB68..0x82EBAB8C)
	// 82EBAB68: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAB6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAB74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAB78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAB7C: 4E800421  bctrl
	ctx.lr = 0x82EBAB80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAB80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAB84: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82EBAB88: 4BFFE709  bl 0x82eb9290
	ctx.lr = 0x82EBAB8C;
	sub_82EB9290(ctx, base);
            }
            0x82EBAB8C => {
    //   block [0x82EBAB8C..0x82EBABB8)
	// 82EBAB8C: 817F01EC  lwz r11, 0x1ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EBAB90: 3B7F01EC  addi r27, r31, 0x1ec
	ctx.r[27].s64 = ctx.r[31].s64 + 492;
	// 82EBAB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAB98: 409A00DC  bne cr6, 0x82ebac74
	if !ctx.cr[6].eq {
	pc = 0x82EBAC74; continue 'dispatch;
	}
	// 82EBAB9C: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBABA0: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBABA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBABA8: 40990078  ble cr6, 0x82ebac20
	if !ctx.cr[6].gt {
	pc = 0x82EBAC20; continue 'dispatch;
	}
	// 82EBABAC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBABB0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBABB4: 3B8BD9E0  addi r28, r11, -0x2620
	ctx.r[28].s64 = ctx.r[11].s64 + -9760;
	pc = 0x82EBABB8; continue 'dispatch;
            }
            0x82EBABB8 => {
    //   block [0x82EBABB8..0x82EBABD0)
	// 82EBABB8: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBABBC: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBABC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBABC4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBABC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBABCC: 4E800421  bctrl
	ctx.lr = 0x82EBABD0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBABD0 => {
    //   block [0x82EBABD0..0x82EBABE8)
	// 82EBABD0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBABD4: 419A0034  beq cr6, 0x82ebac08
	if ctx.cr[6].eq {
	pc = 0x82EBAC08; continue 'dispatch;
	}
	// 82EBABD8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBABDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBABE0: 4082FFF0  bne 0x82ebabd0
	if !ctx.cr[0].eq {
	pc = 0x82EBABD0; continue 'dispatch;
	}
	// 82EBABE4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBABE8; continue 'dispatch;
            }
            0x82EBABE8 => {
    //   block [0x82EBABE8..0x82EBAC08)
	// 82EBABE8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBABEC: 40820024  bne 0x82ebac10
	if !ctx.cr[0].eq {
	pc = 0x82EBAC10; continue 'dispatch;
	}
	// 82EBABF0: 817F01E8  lwz r11, 0x1e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBABF4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBABF8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBABFC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAC00: 4198FFB8  blt cr6, 0x82ebabb8
	if ctx.cr[6].lt {
	pc = 0x82EBABB8; continue 'dispatch;
	}
	// 82EBAC04: 4800001C  b 0x82ebac20
	pc = 0x82EBAC20; continue 'dispatch;
            }
            0x82EBAC08 => {
    //   block [0x82EBAC08..0x82EBAC10)
	// 82EBAC08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAC0C: 4BFFFFDC  b 0x82ebabe8
	pc = 0x82EBABE8; continue 'dispatch;
            }
            0x82EBAC10 => {
    //   block [0x82EBAC10..0x82EBAC20)
	// 82EBAC10: 817F01E0  lwz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBAC14: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAC18: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAC1C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBAC20; continue 'dispatch;
            }
            0x82EBAC20 => {
    //   block [0x82EBAC20..0x82EBAC4C)
	// 82EBAC20: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAC24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC28: 409A004C  bne cr6, 0x82ebac74
	if !ctx.cr[6].eq {
	pc = 0x82EBAC74; continue 'dispatch;
	}
	// 82EBAC2C: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EBAC30: 4B75BCF9  bl 0x82616928
	ctx.lr = 0x82EBAC34;
	sub_82616928(ctx, base);
	// 82EBAC34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC38: 41820014  beq 0x82ebac4c
	if ctx.cr[0].eq {
	pc = 0x82EBAC4C; continue 'dispatch;
	}
	// 82EBAC3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAC40: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAC44: 4BFFA865  bl 0x82eb54a8
	ctx.lr = 0x82EBAC48;
	sub_82EB54A8(ctx, base);
	// 82EBAC48: 48000008  b 0x82ebac50
	pc = 0x82EBAC50; continue 'dispatch;
            }
            0x82EBAC4C => {
    //   block [0x82EBAC4C..0x82EBAC50)
	// 82EBAC4C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBAC50; continue 'dispatch;
            }
            0x82EBAC50 => {
    //   block [0x82EBAC50..0x82EBAC74)
	// 82EBAC50: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAC54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAC58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAC5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAC64: 4E800421  bctrl
	ctx.lr = 0x82EBAC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAC68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAC6C: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82EBAC70: 4BFFE621  bl 0x82eb9290
	ctx.lr = 0x82EBAC74;
	sub_82EB9290(ctx, base);
            }
            0x82EBAC74 => {
    //   block [0x82EBAC74..0x82EBACA0)
	// 82EBAC74: 817F0200  lwz r11, 0x200(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EBAC78: 3B7F0200  addi r27, r31, 0x200
	ctx.r[27].s64 = ctx.r[31].s64 + 512;
	// 82EBAC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC80: 409A00F0  bne cr6, 0x82ebad70
	if !ctx.cr[6].eq {
	pc = 0x82EBAD70; continue 'dispatch;
	}
	// 82EBAC84: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBAC88: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAC90: 40990078  ble cr6, 0x82ebad08
	if !ctx.cr[6].gt {
	pc = 0x82EBAD08; continue 'dispatch;
	}
	// 82EBAC94: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAC98: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAC9C: 3B8BD8CC  addi r28, r11, -0x2734
	ctx.r[28].s64 = ctx.r[11].s64 + -10036;
	pc = 0x82EBACA0; continue 'dispatch;
            }
            0x82EBACA0 => {
    //   block [0x82EBACA0..0x82EBACB8)
	// 82EBACA0: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBACA4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBACA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBACAC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBACB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBACB4: 4E800421  bctrl
	ctx.lr = 0x82EBACB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBACB8 => {
    //   block [0x82EBACB8..0x82EBACD0)
	// 82EBACB8: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBACBC: 419A0034  beq cr6, 0x82ebacf0
	if ctx.cr[6].eq {
	pc = 0x82EBACF0; continue 'dispatch;
	}
	// 82EBACC0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBACC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBACC8: 4082FFF0  bne 0x82ebacb8
	if !ctx.cr[0].eq {
	pc = 0x82EBACB8; continue 'dispatch;
	}
	// 82EBACCC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBACD0; continue 'dispatch;
            }
            0x82EBACD0 => {
    //   block [0x82EBACD0..0x82EBACF0)
	// 82EBACD0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBACD4: 40820024  bne 0x82ebacf8
	if !ctx.cr[0].eq {
	pc = 0x82EBACF8; continue 'dispatch;
	}
	// 82EBACD8: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBACDC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBACE0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBACE4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBACE8: 4198FFB8  blt cr6, 0x82ebaca0
	if ctx.cr[6].lt {
	pc = 0x82EBACA0; continue 'dispatch;
	}
	// 82EBACEC: 4800001C  b 0x82ebad08
	pc = 0x82EBAD08; continue 'dispatch;
            }
            0x82EBACF0 => {
    //   block [0x82EBACF0..0x82EBACF8)
	// 82EBACF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBACF4: 4BFFFFDC  b 0x82ebacd0
	pc = 0x82EBACD0; continue 'dispatch;
            }
            0x82EBACF8 => {
    //   block [0x82EBACF8..0x82EBAD08)
	// 82EBACF8: 817F01F4  lwz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBACFC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAD00: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAD04: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBAD08; continue 'dispatch;
            }
            0x82EBAD08 => {
    //   block [0x82EBAD08..0x82EBAD48)
	// 82EBAD08: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD10: 409A0060  bne cr6, 0x82ebad70
	if !ctx.cr[6].eq {
	pc = 0x82EBAD70; continue 'dispatch;
	}
	// 82EBAD14: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EBAD18: 4B75BC11  bl 0x82616928
	ctx.lr = 0x82EBAD1C;
	sub_82616928(ctx, base);
	// 82EBAD1C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAD20: 41820028  beq 0x82ebad48
	if ctx.cr[0].eq {
	pc = 0x82EBAD48; continue 'dispatch;
	}
	// 82EBAD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAD28: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAD2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAD30: 4BFFA601  bl 0x82eb5330
	ctx.lr = 0x82EBAD34;
	sub_82EB5330(ctx, base);
	// 82EBAD34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAD38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAD3C: 396BA84C  addi r11, r11, -0x57b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22452;
	// 82EBAD40: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAD44: 48000008  b 0x82ebad4c
	pc = 0x82EBAD4C; continue 'dispatch;
            }
            0x82EBAD48 => {
    //   block [0x82EBAD48..0x82EBAD4C)
	// 82EBAD48: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBAD4C; continue 'dispatch;
            }
            0x82EBAD4C => {
    //   block [0x82EBAD4C..0x82EBAD70)
	// 82EBAD4C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAD50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAD54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAD58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAD5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAD60: 4E800421  bctrl
	ctx.lr = 0x82EBAD64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAD64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAD68: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82EBAD6C: 4BFFE525  bl 0x82eb9290
	ctx.lr = 0x82EBAD70;
	sub_82EB9290(ctx, base);
            }
            0x82EBAD70 => {
    //   block [0x82EBAD70..0x82EBAD9C)
	// 82EBAD70: 817F0214  lwz r11, 0x214(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EBAD74: 3B7F0214  addi r27, r31, 0x214
	ctx.r[27].s64 = ctx.r[31].s64 + 532;
	// 82EBAD78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD7C: 409A00F0  bne cr6, 0x82ebae6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAE6C; continue 'dispatch;
	}
	// 82EBAD80: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBAD84: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAD8C: 40990078  ble cr6, 0x82ebae04
	if !ctx.cr[6].gt {
	pc = 0x82EBAE04; continue 'dispatch;
	}
	// 82EBAD90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAD94: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAD98: 3B8BD6A4  addi r28, r11, -0x295c
	ctx.r[28].s64 = ctx.r[11].s64 + -10588;
	pc = 0x82EBAD9C; continue 'dispatch;
            }
            0x82EBAD9C => {
    //   block [0x82EBAD9C..0x82EBADB4)
	// 82EBAD9C: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBADA0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBADA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBADA8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBADAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBADB0: 4E800421  bctrl
	ctx.lr = 0x82EBADB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBADB4 => {
    //   block [0x82EBADB4..0x82EBADCC)
	// 82EBADB4: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBADB8: 419A0034  beq cr6, 0x82ebadec
	if ctx.cr[6].eq {
	pc = 0x82EBADEC; continue 'dispatch;
	}
	// 82EBADBC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBADC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBADC4: 4082FFF0  bne 0x82ebadb4
	if !ctx.cr[0].eq {
	pc = 0x82EBADB4; continue 'dispatch;
	}
	// 82EBADC8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBADCC; continue 'dispatch;
            }
            0x82EBADCC => {
    //   block [0x82EBADCC..0x82EBADEC)
	// 82EBADCC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBADD0: 40820024  bne 0x82ebadf4
	if !ctx.cr[0].eq {
	pc = 0x82EBADF4; continue 'dispatch;
	}
	// 82EBADD4: 817F0210  lwz r11, 0x210(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBADD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBADDC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBADE0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBADE4: 4198FFB8  blt cr6, 0x82ebad9c
	if ctx.cr[6].lt {
	pc = 0x82EBAD9C; continue 'dispatch;
	}
	// 82EBADE8: 4800001C  b 0x82ebae04
	pc = 0x82EBAE04; continue 'dispatch;
            }
            0x82EBADEC => {
    //   block [0x82EBADEC..0x82EBADF4)
	// 82EBADEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBADF0: 4BFFFFDC  b 0x82ebadcc
	pc = 0x82EBADCC; continue 'dispatch;
            }
            0x82EBADF4 => {
    //   block [0x82EBADF4..0x82EBAE04)
	// 82EBADF4: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBADF8: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBADFC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAE00: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBAE04; continue 'dispatch;
            }
            0x82EBAE04 => {
    //   block [0x82EBAE04..0x82EBAE44)
	// 82EBAE04: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAE08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE0C: 409A0060  bne cr6, 0x82ebae6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAE6C; continue 'dispatch;
	}
	// 82EBAE10: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EBAE14: 4B75BB15  bl 0x82616928
	ctx.lr = 0x82EBAE18;
	sub_82616928(ctx, base);
	// 82EBAE18: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAE1C: 41820028  beq 0x82ebae44
	if ctx.cr[0].eq {
	pc = 0x82EBAE44; continue 'dispatch;
	}
	// 82EBAE20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAE24: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAE28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAE2C: 4BFFA505  bl 0x82eb5330
	ctx.lr = 0x82EBAE30;
	sub_82EB5330(ctx, base);
	// 82EBAE30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAE38: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 82EBAE3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAE40: 48000008  b 0x82ebae48
	pc = 0x82EBAE48; continue 'dispatch;
            }
            0x82EBAE44 => {
    //   block [0x82EBAE44..0x82EBAE48)
	// 82EBAE44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBAE48; continue 'dispatch;
            }
            0x82EBAE48 => {
    //   block [0x82EBAE48..0x82EBAE6C)
	// 82EBAE48: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAE4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAE50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAE54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAE58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAE5C: 4E800421  bctrl
	ctx.lr = 0x82EBAE60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAE60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAE64: 387F0204  addi r3, r31, 0x204
	ctx.r[3].s64 = ctx.r[31].s64 + 516;
	// 82EBAE68: 4BFFE429  bl 0x82eb9290
	ctx.lr = 0x82EBAE6C;
	sub_82EB9290(ctx, base);
            }
            0x82EBAE6C => {
    //   block [0x82EBAE6C..0x82EBAE98)
	// 82EBAE6C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EBAE70: 3B7F0228  addi r27, r31, 0x228
	ctx.r[27].s64 = ctx.r[31].s64 + 552;
	// 82EBAE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE78: 409A00F4  bne cr6, 0x82ebaf6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAF6C; continue 'dispatch;
	}
	// 82EBAE7C: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBAE80: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAE88: 40990078  ble cr6, 0x82ebaf00
	if !ctx.cr[6].gt {
	pc = 0x82EBAF00; continue 'dispatch;
	}
	// 82EBAE8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAE90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAE94: 3B8BD590  addi r28, r11, -0x2a70
	ctx.r[28].s64 = ctx.r[11].s64 + -10864;
	pc = 0x82EBAE98; continue 'dispatch;
            }
            0x82EBAE98 => {
    //   block [0x82EBAE98..0x82EBAEB0)
	// 82EBAE98: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBAE9C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAEA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAEA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAEA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAEAC: 4E800421  bctrl
	ctx.lr = 0x82EBAEB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBAEB0 => {
    //   block [0x82EBAEB0..0x82EBAEC8)
	// 82EBAEB0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAEB4: 419A0034  beq cr6, 0x82ebaee8
	if ctx.cr[6].eq {
	pc = 0x82EBAEE8; continue 'dispatch;
	}
	// 82EBAEB8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAEBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAEC0: 4082FFF0  bne 0x82ebaeb0
	if !ctx.cr[0].eq {
	pc = 0x82EBAEB0; continue 'dispatch;
	}
	// 82EBAEC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBAEC8; continue 'dispatch;
            }
            0x82EBAEC8 => {
    //   block [0x82EBAEC8..0x82EBAEE8)
	// 82EBAEC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAECC: 40820024  bne 0x82ebaef0
	if !ctx.cr[0].eq {
	pc = 0x82EBAEF0; continue 'dispatch;
	}
	// 82EBAED0: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBAED4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAED8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAEDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAEE0: 4198FFB8  blt cr6, 0x82ebae98
	if ctx.cr[6].lt {
	pc = 0x82EBAE98; continue 'dispatch;
	}
	// 82EBAEE4: 4800001C  b 0x82ebaf00
	pc = 0x82EBAF00; continue 'dispatch;
            }
            0x82EBAEE8 => {
    //   block [0x82EBAEE8..0x82EBAEF0)
	// 82EBAEE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAEEC: 4BFFFFDC  b 0x82ebaec8
	pc = 0x82EBAEC8; continue 'dispatch;
            }
            0x82EBAEF0 => {
    //   block [0x82EBAEF0..0x82EBAF00)
	// 82EBAEF0: 817F021C  lwz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBAEF4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAEF8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAEFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBAF00; continue 'dispatch;
            }
            0x82EBAF00 => {
    //   block [0x82EBAF00..0x82EBAF44)
	// 82EBAF00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF08: 409A0064  bne cr6, 0x82ebaf6c
	if !ctx.cr[6].eq {
	pc = 0x82EBAF6C; continue 'dispatch;
	}
	// 82EBAF0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EBAF10: 4B75BA19  bl 0x82616928
	ctx.lr = 0x82EBAF14;
	sub_82616928(ctx, base);
	// 82EBAF14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBAF18: 4182002C  beq 0x82ebaf44
	if ctx.cr[0].eq {
	pc = 0x82EBAF44; continue 'dispatch;
	}
	// 82EBAF1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBAF20: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBAF24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAF28: 4BFFA409  bl 0x82eb5330
	ctx.lr = 0x82EBAF2C;
	sub_82EB5330(ctx, base);
	// 82EBAF2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBAF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBAF34: 933E000C  stw r25, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 82EBAF38: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EBAF3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBAF40: 48000008  b 0x82ebaf48
	pc = 0x82EBAF48; continue 'dispatch;
            }
            0x82EBAF44 => {
    //   block [0x82EBAF44..0x82EBAF48)
	// 82EBAF44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBAF48; continue 'dispatch;
            }
            0x82EBAF48 => {
    //   block [0x82EBAF48..0x82EBAF6C)
	// 82EBAF48: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBAF4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBAF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAF54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBAF58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAF5C: 4E800421  bctrl
	ctx.lr = 0x82EBAF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBAF60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBAF64: 387F0218  addi r3, r31, 0x218
	ctx.r[3].s64 = ctx.r[31].s64 + 536;
	// 82EBAF68: 4BFFE329  bl 0x82eb9290
	ctx.lr = 0x82EBAF6C;
	sub_82EB9290(ctx, base);
            }
            0x82EBAF6C => {
    //   block [0x82EBAF6C..0x82EBAF98)
	// 82EBAF6C: 817F0264  lwz r11, 0x264(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBAF70: 3B7F0264  addi r27, r31, 0x264
	ctx.r[27].s64 = ctx.r[31].s64 + 612;
	// 82EBAF74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF78: 409A00DC  bne cr6, 0x82ebb054
	if !ctx.cr[6].eq {
	pc = 0x82EBB054; continue 'dispatch;
	}
	// 82EBAF7C: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBAF80: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBAF84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBAF88: 40990078  ble cr6, 0x82ebb000
	if !ctx.cr[6].gt {
	pc = 0x82EBB000; continue 'dispatch;
	}
	// 82EBAF8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBAF90: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBAF94: 3B8BCDF0  addi r28, r11, -0x3210
	ctx.r[28].s64 = ctx.r[11].s64 + -12816;
	pc = 0x82EBAF98; continue 'dispatch;
            }
            0x82EBAF98 => {
    //   block [0x82EBAF98..0x82EBAFB0)
	// 82EBAF98: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBAF9C: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAFA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBAFA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBAFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBAFAC: 4E800421  bctrl
	ctx.lr = 0x82EBAFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBAFB0 => {
    //   block [0x82EBAFB0..0x82EBAFC8)
	// 82EBAFB0: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBAFB4: 419A0034  beq cr6, 0x82ebafe8
	if ctx.cr[6].eq {
	pc = 0x82EBAFE8; continue 'dispatch;
	}
	// 82EBAFB8: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBAFBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBAFC0: 4082FFF0  bne 0x82ebafb0
	if !ctx.cr[0].eq {
	pc = 0x82EBAFB0; continue 'dispatch;
	}
	// 82EBAFC4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBAFC8; continue 'dispatch;
            }
            0x82EBAFC8 => {
    //   block [0x82EBAFC8..0x82EBAFE8)
	// 82EBAFC8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBAFCC: 40820024  bne 0x82ebaff0
	if !ctx.cr[0].eq {
	pc = 0x82EBAFF0; continue 'dispatch;
	}
	// 82EBAFD0: 817F0260  lwz r11, 0x260(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBAFD4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBAFD8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBAFDC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBAFE0: 4198FFB8  blt cr6, 0x82ebaf98
	if ctx.cr[6].lt {
	pc = 0x82EBAF98; continue 'dispatch;
	}
	// 82EBAFE4: 4800001C  b 0x82ebb000
	pc = 0x82EBB000; continue 'dispatch;
            }
            0x82EBAFE8 => {
    //   block [0x82EBAFE8..0x82EBAFF0)
	// 82EBAFE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBAFEC: 4BFFFFDC  b 0x82ebafc8
	pc = 0x82EBAFC8; continue 'dispatch;
            }
            0x82EBAFF0 => {
    //   block [0x82EBAFF0..0x82EBB000)
	// 82EBAFF0: 817F0258  lwz r11, 0x258(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBAFF4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBAFF8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBAFFC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB000; continue 'dispatch;
            }
            0x82EBB000 => {
    //   block [0x82EBB000..0x82EBB02C)
	// 82EBB000: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB008: 409A004C  bne cr6, 0x82ebb054
	if !ctx.cr[6].eq {
	pc = 0x82EBB054; continue 'dispatch;
	}
	// 82EBB00C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EBB010: 4B75B919  bl 0x82616928
	ctx.lr = 0x82EBB014;
	sub_82616928(ctx, base);
	// 82EBB014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB018: 41820014  beq 0x82ebb02c
	if ctx.cr[0].eq {
	pc = 0x82EBB02C; continue 'dispatch;
	}
	// 82EBB01C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB020: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB024: 4BFFA72D  bl 0x82eb5750
	ctx.lr = 0x82EBB028;
	sub_82EB5750(ctx, base);
	// 82EBB028: 48000008  b 0x82ebb030
	pc = 0x82EBB030; continue 'dispatch;
            }
            0x82EBB02C => {
    //   block [0x82EBB02C..0x82EBB030)
	// 82EBB02C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBB030; continue 'dispatch;
            }
            0x82EBB030 => {
    //   block [0x82EBB030..0x82EBB054)
	// 82EBB030: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB038: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB03C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB044: 4E800421  bctrl
	ctx.lr = 0x82EBB048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB048: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB04C: 387F0254  addi r3, r31, 0x254
	ctx.r[3].s64 = ctx.r[31].s64 + 596;
	// 82EBB050: 4BFFE241  bl 0x82eb9290
	ctx.lr = 0x82EBB054;
	sub_82EB9290(ctx, base);
            }
            0x82EBB054 => {
    //   block [0x82EBB054..0x82EBB080)
	// 82EBB054: 817F0250  lwz r11, 0x250(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBB058: 3B7F0250  addi r27, r31, 0x250
	ctx.r[27].s64 = ctx.r[31].s64 + 592;
	// 82EBB05C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB060: 409A00DC  bne cr6, 0x82ebb13c
	if !ctx.cr[6].eq {
	pc = 0x82EBB13C; continue 'dispatch;
	}
	// 82EBB064: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBB068: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB06C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB070: 40990078  ble cr6, 0x82ebb0e8
	if !ctx.cr[6].gt {
	pc = 0x82EBB0E8; continue 'dispatch;
	}
	// 82EBB074: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EBB078: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB07C: 3B8B89BC  addi r28, r11, -0x7644
	ctx.r[28].s64 = ctx.r[11].s64 + -30276;
	pc = 0x82EBB080; continue 'dispatch;
            }
            0x82EBB080 => {
    //   block [0x82EBB080..0x82EBB098)
	// 82EBB080: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBB084: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBB088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB08C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB094: 4E800421  bctrl
	ctx.lr = 0x82EBB098;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBB098 => {
    //   block [0x82EBB098..0x82EBB0B0)
	// 82EBB098: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB09C: 419A0034  beq cr6, 0x82ebb0d0
	if ctx.cr[6].eq {
	pc = 0x82EBB0D0; continue 'dispatch;
	}
	// 82EBB0A0: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB0A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB0A8: 4082FFF0  bne 0x82ebb098
	if !ctx.cr[0].eq {
	pc = 0x82EBB098; continue 'dispatch;
	}
	// 82EBB0AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBB0B0; continue 'dispatch;
            }
            0x82EBB0B0 => {
    //   block [0x82EBB0B0..0x82EBB0D0)
	// 82EBB0B0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB0B4: 40820024  bne 0x82ebb0d8
	if !ctx.cr[0].eq {
	pc = 0x82EBB0D8; continue 'dispatch;
	}
	// 82EBB0B8: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBB0BC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB0C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB0C4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB0C8: 4198FFB8  blt cr6, 0x82ebb080
	if ctx.cr[6].lt {
	pc = 0x82EBB080; continue 'dispatch;
	}
	// 82EBB0CC: 4800001C  b 0x82ebb0e8
	pc = 0x82EBB0E8; continue 'dispatch;
            }
            0x82EBB0D0 => {
    //   block [0x82EBB0D0..0x82EBB0D8)
	// 82EBB0D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB0D4: 4BFFFFDC  b 0x82ebb0b0
	pc = 0x82EBB0B0; continue 'dispatch;
            }
            0x82EBB0D8 => {
    //   block [0x82EBB0D8..0x82EBB0E8)
	// 82EBB0D8: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBB0DC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBB0E0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB0E4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB0E8; continue 'dispatch;
            }
            0x82EBB0E8 => {
    //   block [0x82EBB0E8..0x82EBB114)
	// 82EBB0E8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB0F0: 409A004C  bne cr6, 0x82ebb13c
	if !ctx.cr[6].eq {
	pc = 0x82EBB13C; continue 'dispatch;
	}
	// 82EBB0F4: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 82EBB0F8: 4B75B831  bl 0x82616928
	ctx.lr = 0x82EBB0FC;
	sub_82616928(ctx, base);
	// 82EBB0FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB100: 41820014  beq 0x82ebb114
	if ctx.cr[0].eq {
	pc = 0x82EBB114; continue 'dispatch;
	}
	// 82EBB104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB108: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB10C: 4801FD75  bl 0x82edae80
	ctx.lr = 0x82EBB110;
	sub_82EDAE80(ctx, base);
	// 82EBB110: 48000008  b 0x82ebb118
	pc = 0x82EBB118; continue 'dispatch;
            }
            0x82EBB114 => {
    //   block [0x82EBB114..0x82EBB118)
	// 82EBB114: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBB118; continue 'dispatch;
            }
            0x82EBB118 => {
    //   block [0x82EBB118..0x82EBB13C)
	// 82EBB118: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB11C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB124: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB12C: 4E800421  bctrl
	ctx.lr = 0x82EBB130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB130: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB134: 387F0240  addi r3, r31, 0x240
	ctx.r[3].s64 = ctx.r[31].s64 + 576;
	// 82EBB138: 4BFFE159  bl 0x82eb9290
	ctx.lr = 0x82EBB13C;
	sub_82EB9290(ctx, base);
            }
            0x82EBB13C => {
    //   block [0x82EBB13C..0x82EBB168)
	// 82EBB13C: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EBB140: 3B7F023C  addi r27, r31, 0x23c
	ctx.r[27].s64 = ctx.r[31].s64 + 572;
	// 82EBB144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB148: 409A00DC  bne cr6, 0x82ebb224
	if !ctx.cr[6].eq {
	pc = 0x82EBB224; continue 'dispatch;
	}
	// 82EBB14C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBB150: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB158: 40990078  ble cr6, 0x82ebb1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBB1D0; continue 'dispatch;
	}
	// 82EBB15C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBB160: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB164: 3B8BD244  addi r28, r11, -0x2dbc
	ctx.r[28].s64 = ctx.r[11].s64 + -11708;
	pc = 0x82EBB168; continue 'dispatch;
            }
            0x82EBB168 => {
    //   block [0x82EBB168..0x82EBB180)
	// 82EBB168: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBB16C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82EBB170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB174: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB17C: 4E800421  bctrl
	ctx.lr = 0x82EBB180;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBB180 => {
    //   block [0x82EBB180..0x82EBB198)
	// 82EBB180: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB184: 419A0034  beq cr6, 0x82ebb1b8
	if ctx.cr[6].eq {
	pc = 0x82EBB1B8; continue 'dispatch;
	}
	// 82EBB188: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB190: 4082FFF0  bne 0x82ebb180
	if !ctx.cr[0].eq {
	pc = 0x82EBB180; continue 'dispatch;
	}
	// 82EBB194: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBB198; continue 'dispatch;
            }
            0x82EBB198 => {
    //   block [0x82EBB198..0x82EBB1B8)
	// 82EBB198: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB19C: 40820024  bne 0x82ebb1c0
	if !ctx.cr[0].eq {
	pc = 0x82EBB1C0; continue 'dispatch;
	}
	// 82EBB1A0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBB1A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB1A8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB1AC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB1B0: 4198FFB8  blt cr6, 0x82ebb168
	if ctx.cr[6].lt {
	pc = 0x82EBB168; continue 'dispatch;
	}
	// 82EBB1B4: 4800001C  b 0x82ebb1d0
	pc = 0x82EBB1D0; continue 'dispatch;
            }
            0x82EBB1B8 => {
    //   block [0x82EBB1B8..0x82EBB1C0)
	// 82EBB1B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB1BC: 4BFFFFDC  b 0x82ebb198
	pc = 0x82EBB198; continue 'dispatch;
            }
            0x82EBB1C0 => {
    //   block [0x82EBB1C0..0x82EBB1D0)
	// 82EBB1C0: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBB1C4: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBB1C8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB1CC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB1D0; continue 'dispatch;
            }
            0x82EBB1D0 => {
    //   block [0x82EBB1D0..0x82EBB1FC)
	// 82EBB1D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB1D8: 409A004C  bne cr6, 0x82ebb224
	if !ctx.cr[6].eq {
	pc = 0x82EBB224; continue 'dispatch;
	}
	// 82EBB1DC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EBB1E0: 4B75B749  bl 0x82616928
	ctx.lr = 0x82EBB1E4;
	sub_82616928(ctx, base);
	// 82EBB1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB1E8: 41820014  beq 0x82ebb1fc
	if ctx.cr[0].eq {
	pc = 0x82EBB1FC; continue 'dispatch;
	}
	// 82EBB1EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB1F0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB1F4: 4BFFA345  bl 0x82eb5538
	ctx.lr = 0x82EBB1F8;
	sub_82EB5538(ctx, base);
	// 82EBB1F8: 48000008  b 0x82ebb200
	pc = 0x82EBB200; continue 'dispatch;
            }
            0x82EBB1FC => {
    //   block [0x82EBB1FC..0x82EBB200)
	// 82EBB1FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBB200; continue 'dispatch;
            }
            0x82EBB200 => {
    //   block [0x82EBB200..0x82EBB224)
	// 82EBB200: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB204: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB20C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB214: 4E800421  bctrl
	ctx.lr = 0x82EBB218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB218: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB21C: 387F022C  addi r3, r31, 0x22c
	ctx.r[3].s64 = ctx.r[31].s64 + 556;
	// 82EBB220: 4BFFE071  bl 0x82eb9290
	ctx.lr = 0x82EBB224;
	sub_82EB9290(ctx, base);
            }
            0x82EBB224 => {
    //   block [0x82EBB224..0x82EBB250)
	// 82EBB224: 817F0278  lwz r11, 0x278(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EBB228: 3B7F0278  addi r27, r31, 0x278
	ctx.r[27].s64 = ctx.r[31].s64 + 632;
	// 82EBB22C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB230: 409A00F0  bne cr6, 0x82ebb320
	if !ctx.cr[6].eq {
	pc = 0x82EBB320; continue 'dispatch;
	}
	// 82EBB234: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBB238: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82EBB23C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB240: 40990078  ble cr6, 0x82ebb2b8
	if !ctx.cr[6].gt {
	pc = 0x82EBB2B8; continue 'dispatch;
	}
	// 82EBB244: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBB248: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82EBB24C: 3B8BCBC8  addi r28, r11, -0x3438
	ctx.r[28].s64 = ctx.r[11].s64 + -13368;
	pc = 0x82EBB250; continue 'dispatch;
            }
            0x82EBB250 => {
    //   block [0x82EBB250..0x82EBB268)
	// 82EBB250: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBB254: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB25C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBB260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB264: 4E800421  bctrl
	ctx.lr = 0x82EBB268;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBB268 => {
    //   block [0x82EBB268..0x82EBB280)
	// 82EBB268: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBB26C: 419A0034  beq cr6, 0x82ebb2a0
	if ctx.cr[6].eq {
	pc = 0x82EBB2A0; continue 'dispatch;
	}
	// 82EBB270: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EBB274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB278: 4082FFF0  bne 0x82ebb268
	if !ctx.cr[0].eq {
	pc = 0x82EBB268; continue 'dispatch;
	}
	// 82EBB27C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBB280; continue 'dispatch;
            }
            0x82EBB280 => {
    //   block [0x82EBB280..0x82EBB2A0)
	// 82EBB280: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBB284: 40820024  bne 0x82ebb2a8
	if !ctx.cr[0].eq {
	pc = 0x82EBB2A8; continue 'dispatch;
	}
	// 82EBB288: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBB28C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBB290: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82EBB294: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBB298: 4198FFB8  blt cr6, 0x82ebb250
	if ctx.cr[6].lt {
	pc = 0x82EBB250; continue 'dispatch;
	}
	// 82EBB29C: 4800001C  b 0x82ebb2b8
	pc = 0x82EBB2B8; continue 'dispatch;
            }
            0x82EBB2A0 => {
    //   block [0x82EBB2A0..0x82EBB2A8)
	// 82EBB2A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBB2A4: 4BFFFFDC  b 0x82ebb280
	pc = 0x82EBB280; continue 'dispatch;
            }
            0x82EBB2A8 => {
    //   block [0x82EBB2A8..0x82EBB2B8)
	// 82EBB2A8: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBB2AC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBB2B0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBB2B4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB2B8; continue 'dispatch;
            }
            0x82EBB2B8 => {
    //   block [0x82EBB2B8..0x82EBB2F8)
	// 82EBB2B8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBB2C0: 409A0060  bne cr6, 0x82ebb320
	if !ctx.cr[6].eq {
	pc = 0x82EBB320; continue 'dispatch;
	}
	// 82EBB2C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBB2C8: 4B75B661  bl 0x82616928
	ctx.lr = 0x82EBB2CC;
	sub_82616928(ctx, base);
	// 82EBB2CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBB2D0: 41820028  beq 0x82ebb2f8
	if ctx.cr[0].eq {
	pc = 0x82EBB2F8; continue 'dispatch;
	}
	// 82EBB2D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBB2D8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBB2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBB2E0: 4BFFA051  bl 0x82eb5330
	ctx.lr = 0x82EBB2E4;
	sub_82EB5330(ctx, base);
	// 82EBB2E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBB2E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBB2EC: 396BA8D8  addi r11, r11, -0x5728
	ctx.r[11].s64 = ctx.r[11].s64 + -22312;
	// 82EBB2F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBB2F4: 48000008  b 0x82ebb2fc
	pc = 0x82EBB2FC; continue 'dispatch;
            }
            0x82EBB2F8 => {
    //   block [0x82EBB2F8..0x82EBB2FC)
	// 82EBB2F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82EBB2FC; continue 'dispatch;
            }
            0x82EBB2FC => {
    //   block [0x82EBB2FC..0x82EBB320)
	// 82EBB2FC: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82EBB300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBB304: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB308: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBB30C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB310: 4E800421  bctrl
	ctx.lr = 0x82EBB314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB314: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBB318: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 82EBB31C: 4BFFDF75  bl 0x82eb9290
	ctx.lr = 0x82EBB320;
	sub_82EB9290(ctx, base);
            }
            0x82EBB320 => {
    //   block [0x82EBB320..0x82EBB36C)
	// 82EBB320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB324: 389F0418  addi r4, r31, 0x418
	ctx.r[4].s64 = ctx.r[31].s64 + 1048;
	// 82EBB328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB32C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EBB330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB334: 4E800421  bctrl
	ctx.lr = 0x82EBB338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB33C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB340: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBB344: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBB348: 4E800421  bctrl
	ctx.lr = 0x82EBB34C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBB34C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBB350: 3BCBA974  addi r30, r11, -0x568c
	ctx.r[30].s64 = ctx.r[11].s64 + -22156;
	// 82EBB354: 4B3A5665  bl 0x822609b8
	ctx.lr = 0x82EBB358;
	sub_822609B8(ctx, base);
	// 82EBB358: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBB35C: 4BFC5EDD  bl 0x82e81238
	ctx.lr = 0x82EBB360;
	sub_82E81238(ctx, base);
	// 82EBB360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBB364: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBB368: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
            }
            0x82EBB36C => {
    //   block [0x82EBB36C..0x82EBB374)
	// 82EBB36C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EBB370: 4BDEE0DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB378 size=116
    let mut pc: u32 = 0x82EBB378;
    'dispatch: loop {
        match pc {
            0x82EBB378 => {
    //   block [0x82EBB378..0x82EBB3C0)
	// 82EBB378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB388: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB38C: 816AA374  lwz r11, -0x5c8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23692 as u32) ) } as u64;
	// 82EBB390: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB394: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB398: 3BE99F70  addi r31, r9, -0x6090
	ctx.r[31].s64 = ctx.r[9].s64 + -24720;
	// 82EBB39C: 40820038  bne 0x82ebb3d4
	if !ctx.cr[0].eq {
	pc = 0x82EBB3D4; continue 'dispatch;
	}
	// 82EBB3A0: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB3A4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB3A8: 8909DF40  lbz r8, -0x20c0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8384 as u32) ) } as u64;
	// 82EBB3AC: 916AA374  stw r11, -0x5c8c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-23692 as u32), ctx.r[11].u32 ) };
	// 82EBB3B0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB3B4: 4182000C  beq 0x82ebb3c0
	if ctx.cr[0].eq {
	pc = 0x82EBB3C0; continue 'dispatch;
	}
	// 82EBB3B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB3BC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB3C0; continue 'dispatch;
            }
            0x82EBB3C0 => {
    //   block [0x82EBB3C0..0x82EBB3D4)
	// 82EBB3C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB3C4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB3C8: 386A8BA8  addi r3, r10, -0x7458
	ctx.r[3].s64 = ctx.r[10].s64 + -29784;
	// 82EBB3CC: 9969DF40  stb r11, -0x20c0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8384 as u32), ctx.r[11].u8 ) };
	// 82EBB3D0: 4BDEEB51  bl 0x82ca9f20
	ctx.lr = 0x82EBB3D4;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB3D4; continue 'dispatch;
            }
            0x82EBB3D4 => {
    //   block [0x82EBB3D4..0x82EBB3EC)
	// 82EBB3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB3D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB3DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB3E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB3E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB3E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB3F0 size=116
    let mut pc: u32 = 0x82EBB3F0;
    'dispatch: loop {
        match pc {
            0x82EBB3F0 => {
    //   block [0x82EBB3F0..0x82EBB438)
	// 82EBB3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB3F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB3FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB400: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB404: 816AA77C  lwz r11, -0x5884(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22660 as u32) ) } as u64;
	// 82EBB408: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB40C: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB410: 3BE9A378  addi r31, r9, -0x5c88
	ctx.r[31].s64 = ctx.r[9].s64 + -23688;
	// 82EBB414: 40820038  bne 0x82ebb44c
	if !ctx.cr[0].eq {
	pc = 0x82EBB44C; continue 'dispatch;
	}
	// 82EBB418: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB41C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB420: 8909DF41  lbz r8, -0x20bf(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8383 as u32) ) } as u64;
	// 82EBB424: 916AA77C  stw r11, -0x5884(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-22660 as u32), ctx.r[11].u32 ) };
	// 82EBB428: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB42C: 4182000C  beq 0x82ebb438
	if ctx.cr[0].eq {
	pc = 0x82EBB438; continue 'dispatch;
	}
	// 82EBB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB434: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB438; continue 'dispatch;
            }
            0x82EBB438 => {
    //   block [0x82EBB438..0x82EBB44C)
	// 82EBB438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB43C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB440: 386A8B90  addi r3, r10, -0x7470
	ctx.r[3].s64 = ctx.r[10].s64 + -29808;
	// 82EBB444: 9969DF41  stb r11, -0x20bf(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8383 as u32), ctx.r[11].u8 ) };
	// 82EBB448: 4BDEEAD9  bl 0x82ca9f20
	ctx.lr = 0x82EBB44C;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB44C; continue 'dispatch;
            }
            0x82EBB44C => {
    //   block [0x82EBB44C..0x82EBB464)
	// 82EBB44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB45C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB468 size=116
    let mut pc: u32 = 0x82EBB468;
    'dispatch: loop {
        match pc {
            0x82EBB468 => {
    //   block [0x82EBB468..0x82EBB4B0)
	// 82EBB468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB474: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB478: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB47C: 816AAB84  lwz r11, -0x547c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21628 as u32) ) } as u64;
	// 82EBB480: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB484: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB488: 3BE9A780  addi r31, r9, -0x5880
	ctx.r[31].s64 = ctx.r[9].s64 + -22656;
	// 82EBB48C: 40820038  bne 0x82ebb4c4
	if !ctx.cr[0].eq {
	pc = 0x82EBB4C4; continue 'dispatch;
	}
	// 82EBB490: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB494: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB498: 8909DF42  lbz r8, -0x20be(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8382 as u32) ) } as u64;
	// 82EBB49C: 916AAB84  stw r11, -0x547c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21628 as u32), ctx.r[11].u32 ) };
	// 82EBB4A0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB4A4: 4182000C  beq 0x82ebb4b0
	if ctx.cr[0].eq {
	pc = 0x82EBB4B0; continue 'dispatch;
	}
	// 82EBB4A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB4AC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB4B0; continue 'dispatch;
            }
            0x82EBB4B0 => {
    //   block [0x82EBB4B0..0x82EBB4C4)
	// 82EBB4B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB4B4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB4B8: 386A8B78  addi r3, r10, -0x7488
	ctx.r[3].s64 = ctx.r[10].s64 + -29832;
	// 82EBB4BC: 9969DF42  stb r11, -0x20be(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8382 as u32), ctx.r[11].u8 ) };
	// 82EBB4C0: 4BDEEA61  bl 0x82ca9f20
	ctx.lr = 0x82EBB4C4;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB4C4; continue 'dispatch;
            }
            0x82EBB4C4 => {
    //   block [0x82EBB4C4..0x82EBB4DC)
	// 82EBB4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB4C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB4D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB4D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB4E0 size=116
    let mut pc: u32 = 0x82EBB4E0;
    'dispatch: loop {
        match pc {
            0x82EBB4E0 => {
    //   block [0x82EBB4E0..0x82EBB528)
	// 82EBB4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB4EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB4F0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB4F4: 816AAF8C  lwz r11, -0x5074(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20596 as u32) ) } as u64;
	// 82EBB4F8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB4FC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB500: 3BE9AB88  addi r31, r9, -0x5478
	ctx.r[31].s64 = ctx.r[9].s64 + -21624;
	// 82EBB504: 40820038  bne 0x82ebb53c
	if !ctx.cr[0].eq {
	pc = 0x82EBB53C; continue 'dispatch;
	}
	// 82EBB508: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB50C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB510: 8909DF44  lbz r8, -0x20bc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8380 as u32) ) } as u64;
	// 82EBB514: 916AAF8C  stw r11, -0x5074(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-20596 as u32), ctx.r[11].u32 ) };
	// 82EBB518: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB51C: 4182000C  beq 0x82ebb528
	if ctx.cr[0].eq {
	pc = 0x82EBB528; continue 'dispatch;
	}
	// 82EBB520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB524: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB528; continue 'dispatch;
            }
            0x82EBB528 => {
    //   block [0x82EBB528..0x82EBB53C)
	// 82EBB528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB52C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB530: 386A8B60  addi r3, r10, -0x74a0
	ctx.r[3].s64 = ctx.r[10].s64 + -29856;
	// 82EBB534: 9969DF44  stb r11, -0x20bc(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8380 as u32), ctx.r[11].u8 ) };
	// 82EBB538: 4BDEE9E9  bl 0x82ca9f20
	ctx.lr = 0x82EBB53C;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB53C; continue 'dispatch;
            }
            0x82EBB53C => {
    //   block [0x82EBB53C..0x82EBB554)
	// 82EBB53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB540: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB54C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB558 size=116
    let mut pc: u32 = 0x82EBB558;
    'dispatch: loop {
        match pc {
            0x82EBB558 => {
    //   block [0x82EBB558..0x82EBB5A0)
	// 82EBB558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB568: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB56C: 816AB394  lwz r11, -0x4c6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19564 as u32) ) } as u64;
	// 82EBB570: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB574: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB578: 3BE9AF90  addi r31, r9, -0x5070
	ctx.r[31].s64 = ctx.r[9].s64 + -20592;
	// 82EBB57C: 40820038  bne 0x82ebb5b4
	if !ctx.cr[0].eq {
	pc = 0x82EBB5B4; continue 'dispatch;
	}
	// 82EBB580: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB584: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB588: 8909DF46  lbz r8, -0x20ba(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8378 as u32) ) } as u64;
	// 82EBB58C: 916AB394  stw r11, -0x4c6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19564 as u32), ctx.r[11].u32 ) };
	// 82EBB590: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB594: 4182000C  beq 0x82ebb5a0
	if ctx.cr[0].eq {
	pc = 0x82EBB5A0; continue 'dispatch;
	}
	// 82EBB598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB59C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB5A0; continue 'dispatch;
            }
            0x82EBB5A0 => {
    //   block [0x82EBB5A0..0x82EBB5B4)
	// 82EBB5A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB5A4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB5A8: 386A8B48  addi r3, r10, -0x74b8
	ctx.r[3].s64 = ctx.r[10].s64 + -29880;
	// 82EBB5AC: 9969DF46  stb r11, -0x20ba(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8378 as u32), ctx.r[11].u8 ) };
	// 82EBB5B0: 4BDEE971  bl 0x82ca9f20
	ctx.lr = 0x82EBB5B4;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB5B4; continue 'dispatch;
            }
            0x82EBB5B4 => {
    //   block [0x82EBB5B4..0x82EBB5CC)
	// 82EBB5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB5B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB5BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB5C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB5C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB5C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB5D0 size=116
    let mut pc: u32 = 0x82EBB5D0;
    'dispatch: loop {
        match pc {
            0x82EBB5D0 => {
    //   block [0x82EBB5D0..0x82EBB618)
	// 82EBB5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB5D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB5DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB5E0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB5E4: 816AB79C  lwz r11, -0x4864(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18532 as u32) ) } as u64;
	// 82EBB5E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB5EC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB5F0: 3BE9B398  addi r31, r9, -0x4c68
	ctx.r[31].s64 = ctx.r[9].s64 + -19560;
	// 82EBB5F4: 40820038  bne 0x82ebb62c
	if !ctx.cr[0].eq {
	pc = 0x82EBB62C; continue 'dispatch;
	}
	// 82EBB5F8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB5FC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB600: 8909DF45  lbz r8, -0x20bb(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8379 as u32) ) } as u64;
	// 82EBB604: 916AB79C  stw r11, -0x4864(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18532 as u32), ctx.r[11].u32 ) };
	// 82EBB608: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB60C: 4182000C  beq 0x82ebb618
	if ctx.cr[0].eq {
	pc = 0x82EBB618; continue 'dispatch;
	}
	// 82EBB610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB614: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB618; continue 'dispatch;
            }
            0x82EBB618 => {
    //   block [0x82EBB618..0x82EBB62C)
	// 82EBB618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB61C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB620: 386A8B30  addi r3, r10, -0x74d0
	ctx.r[3].s64 = ctx.r[10].s64 + -29904;
	// 82EBB624: 9969DF45  stb r11, -0x20bb(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8379 as u32), ctx.r[11].u8 ) };
	// 82EBB628: 4BDEE8F9  bl 0x82ca9f20
	ctx.lr = 0x82EBB62C;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB62C; continue 'dispatch;
            }
            0x82EBB62C => {
    //   block [0x82EBB62C..0x82EBB644)
	// 82EBB62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB63C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB648 size=116
    let mut pc: u32 = 0x82EBB648;
    'dispatch: loop {
        match pc {
            0x82EBB648 => {
    //   block [0x82EBB648..0x82EBB690)
	// 82EBB648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB658: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB65C: 816ABBA4  lwz r11, -0x445c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17500 as u32) ) } as u64;
	// 82EBB660: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB664: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB668: 3BE9B7A0  addi r31, r9, -0x4860
	ctx.r[31].s64 = ctx.r[9].s64 + -18528;
	// 82EBB66C: 40820038  bne 0x82ebb6a4
	if !ctx.cr[0].eq {
	pc = 0x82EBB6A4; continue 'dispatch;
	}
	// 82EBB670: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB674: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB678: 8909DF47  lbz r8, -0x20b9(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8377 as u32) ) } as u64;
	// 82EBB67C: 916ABBA4  stw r11, -0x445c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17500 as u32), ctx.r[11].u32 ) };
	// 82EBB680: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB684: 4182000C  beq 0x82ebb690
	if ctx.cr[0].eq {
	pc = 0x82EBB690; continue 'dispatch;
	}
	// 82EBB688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB68C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB690; continue 'dispatch;
            }
            0x82EBB690 => {
    //   block [0x82EBB690..0x82EBB6A4)
	// 82EBB690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB694: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB698: 386A8B18  addi r3, r10, -0x74e8
	ctx.r[3].s64 = ctx.r[10].s64 + -29928;
	// 82EBB69C: 9969DF47  stb r11, -0x20b9(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8377 as u32), ctx.r[11].u8 ) };
	// 82EBB6A0: 4BDEE881  bl 0x82ca9f20
	ctx.lr = 0x82EBB6A4;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB6A4; continue 'dispatch;
            }
            0x82EBB6A4 => {
    //   block [0x82EBB6A4..0x82EBB6BC)
	// 82EBB6A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB6A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB6AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB6B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB6B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB6C0 size=116
    let mut pc: u32 = 0x82EBB6C0;
    'dispatch: loop {
        match pc {
            0x82EBB6C0 => {
    //   block [0x82EBB6C0..0x82EBB708)
	// 82EBB6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB6CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB6D0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB6D4: 816ABFAC  lwz r11, -0x4054(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16468 as u32) ) } as u64;
	// 82EBB6D8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB6DC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB6E0: 3BE9BBA8  addi r31, r9, -0x4458
	ctx.r[31].s64 = ctx.r[9].s64 + -17496;
	// 82EBB6E4: 40820038  bne 0x82ebb71c
	if !ctx.cr[0].eq {
	pc = 0x82EBB71C; continue 'dispatch;
	}
	// 82EBB6E8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB6EC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB6F0: 8909DF43  lbz r8, -0x20bd(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8381 as u32) ) } as u64;
	// 82EBB6F4: 916ABFAC  stw r11, -0x4054(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-16468 as u32), ctx.r[11].u32 ) };
	// 82EBB6F8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB6FC: 4182000C  beq 0x82ebb708
	if ctx.cr[0].eq {
	pc = 0x82EBB708; continue 'dispatch;
	}
	// 82EBB700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB704: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB708; continue 'dispatch;
            }
            0x82EBB708 => {
    //   block [0x82EBB708..0x82EBB71C)
	// 82EBB708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB70C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB710: 386A8B00  addi r3, r10, -0x7500
	ctx.r[3].s64 = ctx.r[10].s64 + -29952;
	// 82EBB714: 9969DF43  stb r11, -0x20bd(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8381 as u32), ctx.r[11].u8 ) };
	// 82EBB718: 4BDEE809  bl 0x82ca9f20
	ctx.lr = 0x82EBB71C;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB71C; continue 'dispatch;
            }
            0x82EBB71C => {
    //   block [0x82EBB71C..0x82EBB734)
	// 82EBB71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB738 size=116
    let mut pc: u32 = 0x82EBB738;
    'dispatch: loop {
        match pc {
            0x82EBB738 => {
    //   block [0x82EBB738..0x82EBB780)
	// 82EBB738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB744: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB748: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB74C: 816AC3B4  lwz r11, -0x3c4c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15436 as u32) ) } as u64;
	// 82EBB750: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB754: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB758: 3BE9BFB0  addi r31, r9, -0x4050
	ctx.r[31].s64 = ctx.r[9].s64 + -16464;
	// 82EBB75C: 40820038  bne 0x82ebb794
	if !ctx.cr[0].eq {
	pc = 0x82EBB794; continue 'dispatch;
	}
	// 82EBB760: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB764: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB768: 8909DF49  lbz r8, -0x20b7(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8375 as u32) ) } as u64;
	// 82EBB76C: 916AC3B4  stw r11, -0x3c4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15436 as u32), ctx.r[11].u32 ) };
	// 82EBB770: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB774: 4182000C  beq 0x82ebb780
	if ctx.cr[0].eq {
	pc = 0x82EBB780; continue 'dispatch;
	}
	// 82EBB778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB77C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB780; continue 'dispatch;
            }
            0x82EBB780 => {
    //   block [0x82EBB780..0x82EBB794)
	// 82EBB780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB784: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB788: 386A8AE8  addi r3, r10, -0x7518
	ctx.r[3].s64 = ctx.r[10].s64 + -29976;
	// 82EBB78C: 9969DF49  stb r11, -0x20b7(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8375 as u32), ctx.r[11].u8 ) };
	// 82EBB790: 4BDEE791  bl 0x82ca9f20
	ctx.lr = 0x82EBB794;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB794; continue 'dispatch;
            }
            0x82EBB794 => {
    //   block [0x82EBB794..0x82EBB7AC)
	// 82EBB794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB798: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB79C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB7A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB7B0 size=116
    let mut pc: u32 = 0x82EBB7B0;
    'dispatch: loop {
        match pc {
            0x82EBB7B0 => {
    //   block [0x82EBB7B0..0x82EBB7F8)
	// 82EBB7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB7BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB7C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB7C4: 816AC7BC  lwz r11, -0x3844(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14404 as u32) ) } as u64;
	// 82EBB7C8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB7CC: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB7D0: 3BE9C3B8  addi r31, r9, -0x3c48
	ctx.r[31].s64 = ctx.r[9].s64 + -15432;
	// 82EBB7D4: 40820038  bne 0x82ebb80c
	if !ctx.cr[0].eq {
	pc = 0x82EBB80C; continue 'dispatch;
	}
	// 82EBB7D8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB7DC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB7E0: 8909DF48  lbz r8, -0x20b8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8376 as u32) ) } as u64;
	// 82EBB7E4: 916AC7BC  stw r11, -0x3844(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-14404 as u32), ctx.r[11].u32 ) };
	// 82EBB7E8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB7EC: 4182000C  beq 0x82ebb7f8
	if ctx.cr[0].eq {
	pc = 0x82EBB7F8; continue 'dispatch;
	}
	// 82EBB7F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB7F4: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB7F8; continue 'dispatch;
            }
            0x82EBB7F8 => {
    //   block [0x82EBB7F8..0x82EBB80C)
	// 82EBB7F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB7FC: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB800: 386A8AD0  addi r3, r10, -0x7530
	ctx.r[3].s64 = ctx.r[10].s64 + -30000;
	// 82EBB804: 9969DF48  stb r11, -0x20b8(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8376 as u32), ctx.r[11].u8 ) };
	// 82EBB808: 4BDEE719  bl 0x82ca9f20
	ctx.lr = 0x82EBB80C;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB80C; continue 'dispatch;
            }
            0x82EBB80C => {
    //   block [0x82EBB80C..0x82EBB824)
	// 82EBB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB81C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB828 size=116
    let mut pc: u32 = 0x82EBB828;
    'dispatch: loop {
        match pc {
            0x82EBB828 => {
    //   block [0x82EBB828..0x82EBB870)
	// 82EBB828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB838: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EBB83C: 816ACBC4  lwz r11, -0x343c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13372 as u32) ) } as u64;
	// 82EBB840: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EBB844: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EBB848: 3BE9C7C0  addi r31, r9, -0x3840
	ctx.r[31].s64 = ctx.r[9].s64 + -14400;
	// 82EBB84C: 40820038  bne 0x82ebb884
	if !ctx.cr[0].eq {
	pc = 0x82EBB884; continue 'dispatch;
	}
	// 82EBB850: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82EBB854: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EBB858: 8909DF4A  lbz r8, -0x20b6(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8374 as u32) ) } as u64;
	// 82EBB85C: 916ACBC4  stw r11, -0x343c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-13372 as u32), ctx.r[11].u32 ) };
	// 82EBB860: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBB864: 4182000C  beq 0x82ebb870
	if ctx.cr[0].eq {
	pc = 0x82EBB870; continue 'dispatch;
	}
	// 82EBB868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB86C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBB870; continue 'dispatch;
            }
            0x82EBB870 => {
    //   block [0x82EBB870..0x82EBB884)
	// 82EBB870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBB874: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82EBB878: 386A8AB8  addi r3, r10, -0x7548
	ctx.r[3].s64 = ctx.r[10].s64 + -30024;
	// 82EBB87C: 9969DF4A  stb r11, -0x20b6(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8374 as u32), ctx.r[11].u8 ) };
	// 82EBB880: 4BDEE6A1  bl 0x82ca9f20
	ctx.lr = 0x82EBB884;
	sub_82CA9F20(ctx, base);
	pc = 0x82EBB884; continue 'dispatch;
            }
            0x82EBB884 => {
    //   block [0x82EBB884..0x82EBB89C)
	// 82EBB884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBB888: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB8A0 size=160
    let mut pc: u32 = 0x82EBB8A0;
    'dispatch: loop {
        match pc {
            0x82EBB8A0 => {
    //   block [0x82EBB8A0..0x82EBB8D4)
	// 82EBB8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB8A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB8AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB8B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBB8B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBB8B8: 419A0064  beq cr6, 0x82ebb91c
	if ctx.cr[6].eq {
	pc = 0x82EBB91C; continue 'dispatch;
	}
	// 82EBB8BC: 4BFFFABD  bl 0x82ebb378
	ctx.lr = 0x82EBB8C0;
	sub_82EBB378(ctx, base);
	// 82EBB8C0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBB8C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBB8C8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB8CC: 40810050  ble 0x82ebb91c
	if !ctx.cr[0].gt {
	pc = 0x82EBB91C; continue 'dispatch;
	}
	// 82EBB8D0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBB8D4; continue 'dispatch;
            }
            0x82EBB8D4 => {
    //   block [0x82EBB8D4..0x82EBB8E0)
	// 82EBB8D4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB8D8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBB8DC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBB8E0; continue 'dispatch;
            }
            0x82EBB8E0 => {
    //   block [0x82EBB8E0..0x82EBB904)
	// 82EBB8E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB8E4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB8E8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB8EC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBB8F0: 41820014  beq 0x82ebb904
	if ctx.cr[0].eq {
	pc = 0x82EBB904; continue 'dispatch;
	}
	// 82EBB8F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBB8F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBB8FC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBB900: 419AFFE0  beq cr6, 0x82ebb8e0
	if ctx.cr[6].eq {
	pc = 0x82EBB8E0; continue 'dispatch;
	}
	pc = 0x82EBB904; continue 'dispatch;
            }
            0x82EBB904 => {
    //   block [0x82EBB904..0x82EBB91C)
	// 82EBB904: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB908: 4182002C  beq 0x82ebb934
	if ctx.cr[0].eq {
	pc = 0x82EBB934; continue 'dispatch;
	}
	// 82EBB90C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBB910: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBB914: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBB918: 4198FFBC  blt cr6, 0x82ebb8d4
	if ctx.cr[6].lt {
	pc = 0x82EBB8D4; continue 'dispatch;
	}
	pc = 0x82EBB91C; continue 'dispatch;
            }
            0x82EBB91C => {
    //   block [0x82EBB91C..0x82EBB920)
	// 82EBB91C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBB920; continue 'dispatch;
            }
            0x82EBB920 => {
    //   block [0x82EBB920..0x82EBB934)
	// 82EBB920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB930: 4E800020  blr
	return;
            }
            0x82EBB934 => {
    //   block [0x82EBB934..0x82EBB940)
	// 82EBB934: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBB938: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBB93C: 4BFFFFE4  b 0x82ebb920
	pc = 0x82EBB920; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB940 size=160
    let mut pc: u32 = 0x82EBB940;
    'dispatch: loop {
        match pc {
            0x82EBB940 => {
    //   block [0x82EBB940..0x82EBB974)
	// 82EBB940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB94C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBB954: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBB958: 419A0064  beq cr6, 0x82ebb9bc
	if ctx.cr[6].eq {
	pc = 0x82EBB9BC; continue 'dispatch;
	}
	// 82EBB95C: 4BFFFA95  bl 0x82ebb3f0
	ctx.lr = 0x82EBB960;
	sub_82EBB3F0(ctx, base);
	// 82EBB960: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBB964: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBB968: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB96C: 40810050  ble 0x82ebb9bc
	if !ctx.cr[0].gt {
	pc = 0x82EBB9BC; continue 'dispatch;
	}
	// 82EBB970: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBB974; continue 'dispatch;
            }
            0x82EBB974 => {
    //   block [0x82EBB974..0x82EBB980)
	// 82EBB974: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB978: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBB97C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBB980; continue 'dispatch;
            }
            0x82EBB980 => {
    //   block [0x82EBB980..0x82EBB9A4)
	// 82EBB980: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB984: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBB988: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB98C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBB990: 41820014  beq 0x82ebb9a4
	if ctx.cr[0].eq {
	pc = 0x82EBB9A4; continue 'dispatch;
	}
	// 82EBB994: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBB998: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBB99C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBB9A0: 419AFFE0  beq cr6, 0x82ebb980
	if ctx.cr[6].eq {
	pc = 0x82EBB980; continue 'dispatch;
	}
	pc = 0x82EBB9A4; continue 'dispatch;
            }
            0x82EBB9A4 => {
    //   block [0x82EBB9A4..0x82EBB9BC)
	// 82EBB9A4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBB9A8: 4182002C  beq 0x82ebb9d4
	if ctx.cr[0].eq {
	pc = 0x82EBB9D4; continue 'dispatch;
	}
	// 82EBB9AC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBB9B0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBB9B4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBB9B8: 4198FFBC  blt cr6, 0x82ebb974
	if ctx.cr[6].lt {
	pc = 0x82EBB974; continue 'dispatch;
	}
	pc = 0x82EBB9BC; continue 'dispatch;
            }
            0x82EBB9BC => {
    //   block [0x82EBB9BC..0x82EBB9C0)
	// 82EBB9BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBB9C0; continue 'dispatch;
            }
            0x82EBB9C0 => {
    //   block [0x82EBB9C0..0x82EBB9D4)
	// 82EBB9C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBB9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBB9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBB9CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBB9D0: 4E800020  blr
	return;
            }
            0x82EBB9D4 => {
    //   block [0x82EBB9D4..0x82EBB9E0)
	// 82EBB9D4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBB9D8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBB9DC: 4BFFFFE4  b 0x82ebb9c0
	pc = 0x82EBB9C0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBB9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBB9E0 size=160
    let mut pc: u32 = 0x82EBB9E0;
    'dispatch: loop {
        match pc {
            0x82EBB9E0 => {
    //   block [0x82EBB9E0..0x82EBBA14)
	// 82EBB9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBB9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBB9E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBB9EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBB9F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBB9F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBB9F8: 419A0064  beq cr6, 0x82ebba5c
	if ctx.cr[6].eq {
	pc = 0x82EBBA5C; continue 'dispatch;
	}
	// 82EBB9FC: 4BFFFA6D  bl 0x82ebb468
	ctx.lr = 0x82EBBA00;
	sub_82EBB468(ctx, base);
	// 82EBBA00: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBA04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBA08: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBA0C: 40810050  ble 0x82ebba5c
	if !ctx.cr[0].gt {
	pc = 0x82EBBA5C; continue 'dispatch;
	}
	// 82EBBA10: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBA14; continue 'dispatch;
            }
            0x82EBBA14 => {
    //   block [0x82EBBA14..0x82EBBA20)
	// 82EBBA14: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBA18: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBA1C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBA20; continue 'dispatch;
            }
            0x82EBBA20 => {
    //   block [0x82EBBA20..0x82EBBA44)
	// 82EBBA20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBA24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBA28: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBA2C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBA30: 41820014  beq 0x82ebba44
	if ctx.cr[0].eq {
	pc = 0x82EBBA44; continue 'dispatch;
	}
	// 82EBBA34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBA38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBA3C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBA40: 419AFFE0  beq cr6, 0x82ebba20
	if ctx.cr[6].eq {
	pc = 0x82EBBA20; continue 'dispatch;
	}
	pc = 0x82EBBA44; continue 'dispatch;
            }
            0x82EBBA44 => {
    //   block [0x82EBBA44..0x82EBBA5C)
	// 82EBBA44: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBA48: 4182002C  beq 0x82ebba74
	if ctx.cr[0].eq {
	pc = 0x82EBBA74; continue 'dispatch;
	}
	// 82EBBA4C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBA50: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBA54: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBA58: 4198FFBC  blt cr6, 0x82ebba14
	if ctx.cr[6].lt {
	pc = 0x82EBBA14; continue 'dispatch;
	}
	pc = 0x82EBBA5C; continue 'dispatch;
            }
            0x82EBBA5C => {
    //   block [0x82EBBA5C..0x82EBBA60)
	// 82EBBA5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBA60; continue 'dispatch;
            }
            0x82EBBA60 => {
    //   block [0x82EBBA60..0x82EBBA74)
	// 82EBBA60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBA64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBA68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBA6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBA70: 4E800020  blr
	return;
            }
            0x82EBBA74 => {
    //   block [0x82EBBA74..0x82EBBA80)
	// 82EBBA74: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBA78: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBA7C: 4BFFFFE4  b 0x82ebba60
	pc = 0x82EBBA60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBA80 size=160
    let mut pc: u32 = 0x82EBBA80;
    'dispatch: loop {
        match pc {
            0x82EBBA80 => {
    //   block [0x82EBBA80..0x82EBBAB4)
	// 82EBBA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBA8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBA94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBA98: 419A0064  beq cr6, 0x82ebbafc
	if ctx.cr[6].eq {
	pc = 0x82EBBAFC; continue 'dispatch;
	}
	// 82EBBA9C: 4BFFFA45  bl 0x82ebb4e0
	ctx.lr = 0x82EBBAA0;
	sub_82EBB4E0(ctx, base);
	// 82EBBAA0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBAA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBAA8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBAAC: 40810050  ble 0x82ebbafc
	if !ctx.cr[0].gt {
	pc = 0x82EBBAFC; continue 'dispatch;
	}
	// 82EBBAB0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBAB4; continue 'dispatch;
            }
            0x82EBBAB4 => {
    //   block [0x82EBBAB4..0x82EBBAC0)
	// 82EBBAB4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBAB8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBABC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBAC0; continue 'dispatch;
            }
            0x82EBBAC0 => {
    //   block [0x82EBBAC0..0x82EBBAE4)
	// 82EBBAC0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBAC4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBAC8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBACC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBAD0: 41820014  beq 0x82ebbae4
	if ctx.cr[0].eq {
	pc = 0x82EBBAE4; continue 'dispatch;
	}
	// 82EBBAD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBAD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBADC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBAE0: 419AFFE0  beq cr6, 0x82ebbac0
	if ctx.cr[6].eq {
	pc = 0x82EBBAC0; continue 'dispatch;
	}
	pc = 0x82EBBAE4; continue 'dispatch;
            }
            0x82EBBAE4 => {
    //   block [0x82EBBAE4..0x82EBBAFC)
	// 82EBBAE4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBAE8: 4182002C  beq 0x82ebbb14
	if ctx.cr[0].eq {
	pc = 0x82EBBB14; continue 'dispatch;
	}
	// 82EBBAEC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBAF0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBAF4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBAF8: 4198FFBC  blt cr6, 0x82ebbab4
	if ctx.cr[6].lt {
	pc = 0x82EBBAB4; continue 'dispatch;
	}
	pc = 0x82EBBAFC; continue 'dispatch;
            }
            0x82EBBAFC => {
    //   block [0x82EBBAFC..0x82EBBB00)
	// 82EBBAFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBB00; continue 'dispatch;
            }
            0x82EBBB00 => {
    //   block [0x82EBBB00..0x82EBBB14)
	// 82EBBB00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBB04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBB08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBB0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBB10: 4E800020  blr
	return;
            }
            0x82EBBB14 => {
    //   block [0x82EBBB14..0x82EBBB20)
	// 82EBBB14: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBB18: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBB1C: 4BFFFFE4  b 0x82ebbb00
	pc = 0x82EBBB00; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBB20 size=160
    let mut pc: u32 = 0x82EBBB20;
    'dispatch: loop {
        match pc {
            0x82EBBB20 => {
    //   block [0x82EBBB20..0x82EBBB54)
	// 82EBBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBB2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBB34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBB38: 419A0064  beq cr6, 0x82ebbb9c
	if ctx.cr[6].eq {
	pc = 0x82EBBB9C; continue 'dispatch;
	}
	// 82EBBB3C: 4BFFFA1D  bl 0x82ebb558
	ctx.lr = 0x82EBBB40;
	sub_82EBB558(ctx, base);
	// 82EBBB40: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBB48: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBB4C: 40810050  ble 0x82ebbb9c
	if !ctx.cr[0].gt {
	pc = 0x82EBBB9C; continue 'dispatch;
	}
	// 82EBBB50: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBB54; continue 'dispatch;
            }
            0x82EBBB54 => {
    //   block [0x82EBBB54..0x82EBBB60)
	// 82EBBB54: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBB58: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBB5C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBB60; continue 'dispatch;
            }
            0x82EBBB60 => {
    //   block [0x82EBBB60..0x82EBBB84)
	// 82EBBB60: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBB64: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBB68: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBB6C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBB70: 41820014  beq 0x82ebbb84
	if ctx.cr[0].eq {
	pc = 0x82EBBB84; continue 'dispatch;
	}
	// 82EBBB74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBB78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBB7C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBB80: 419AFFE0  beq cr6, 0x82ebbb60
	if ctx.cr[6].eq {
	pc = 0x82EBBB60; continue 'dispatch;
	}
	pc = 0x82EBBB84; continue 'dispatch;
            }
            0x82EBBB84 => {
    //   block [0x82EBBB84..0x82EBBB9C)
	// 82EBBB84: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBB88: 4182002C  beq 0x82ebbbb4
	if ctx.cr[0].eq {
	pc = 0x82EBBBB4; continue 'dispatch;
	}
	// 82EBBB8C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBB90: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBB94: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBB98: 4198FFBC  blt cr6, 0x82ebbb54
	if ctx.cr[6].lt {
	pc = 0x82EBBB54; continue 'dispatch;
	}
	pc = 0x82EBBB9C; continue 'dispatch;
            }
            0x82EBBB9C => {
    //   block [0x82EBBB9C..0x82EBBBA0)
	// 82EBBB9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBBA0; continue 'dispatch;
            }
            0x82EBBBA0 => {
    //   block [0x82EBBBA0..0x82EBBBB4)
	// 82EBBBA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBBA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBBA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBBAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBBB0: 4E800020  blr
	return;
            }
            0x82EBBBB4 => {
    //   block [0x82EBBBB4..0x82EBBBC0)
	// 82EBBBB4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBBB8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBBBC: 4BFFFFE4  b 0x82ebbba0
	pc = 0x82EBBBA0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBBC0 size=160
    let mut pc: u32 = 0x82EBBBC0;
    'dispatch: loop {
        match pc {
            0x82EBBBC0 => {
    //   block [0x82EBBBC0..0x82EBBBF4)
	// 82EBBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBBD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBBD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBBD8: 419A0064  beq cr6, 0x82ebbc3c
	if ctx.cr[6].eq {
	pc = 0x82EBBC3C; continue 'dispatch;
	}
	// 82EBBBDC: 4BFFF9F5  bl 0x82ebb5d0
	ctx.lr = 0x82EBBBE0;
	sub_82EBB5D0(ctx, base);
	// 82EBBBE0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBBE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBBE8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBBEC: 40810050  ble 0x82ebbc3c
	if !ctx.cr[0].gt {
	pc = 0x82EBBC3C; continue 'dispatch;
	}
	// 82EBBBF0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBBF4; continue 'dispatch;
            }
            0x82EBBBF4 => {
    //   block [0x82EBBBF4..0x82EBBC00)
	// 82EBBBF4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBBF8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBBFC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBC00; continue 'dispatch;
            }
            0x82EBBC00 => {
    //   block [0x82EBBC00..0x82EBBC24)
	// 82EBBC00: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBC04: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBC08: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBC0C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBC10: 41820014  beq 0x82ebbc24
	if ctx.cr[0].eq {
	pc = 0x82EBBC24; continue 'dispatch;
	}
	// 82EBBC14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBC18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBC1C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBC20: 419AFFE0  beq cr6, 0x82ebbc00
	if ctx.cr[6].eq {
	pc = 0x82EBBC00; continue 'dispatch;
	}
	pc = 0x82EBBC24; continue 'dispatch;
            }
            0x82EBBC24 => {
    //   block [0x82EBBC24..0x82EBBC3C)
	// 82EBBC24: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBC28: 4182002C  beq 0x82ebbc54
	if ctx.cr[0].eq {
	pc = 0x82EBBC54; continue 'dispatch;
	}
	// 82EBBC2C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBC30: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBC34: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBC38: 4198FFBC  blt cr6, 0x82ebbbf4
	if ctx.cr[6].lt {
	pc = 0x82EBBBF4; continue 'dispatch;
	}
	pc = 0x82EBBC3C; continue 'dispatch;
            }
            0x82EBBC3C => {
    //   block [0x82EBBC3C..0x82EBBC40)
	// 82EBBC3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBC40; continue 'dispatch;
            }
            0x82EBBC40 => {
    //   block [0x82EBBC40..0x82EBBC54)
	// 82EBBC40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBC44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBC48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBC50: 4E800020  blr
	return;
            }
            0x82EBBC54 => {
    //   block [0x82EBBC54..0x82EBBC60)
	// 82EBBC54: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBC58: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBC5C: 4BFFFFE4  b 0x82ebbc40
	pc = 0x82EBBC40; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBC60 size=160
    let mut pc: u32 = 0x82EBBC60;
    'dispatch: loop {
        match pc {
            0x82EBBC60 => {
    //   block [0x82EBBC60..0x82EBBC94)
	// 82EBBC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBC68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBC6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBC70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBC74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBC78: 419A0064  beq cr6, 0x82ebbcdc
	if ctx.cr[6].eq {
	pc = 0x82EBBCDC; continue 'dispatch;
	}
	// 82EBBC7C: 4BFFF9CD  bl 0x82ebb648
	ctx.lr = 0x82EBBC80;
	sub_82EBB648(ctx, base);
	// 82EBBC80: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBC84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBC88: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBC8C: 40810050  ble 0x82ebbcdc
	if !ctx.cr[0].gt {
	pc = 0x82EBBCDC; continue 'dispatch;
	}
	// 82EBBC90: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBC94; continue 'dispatch;
            }
            0x82EBBC94 => {
    //   block [0x82EBBC94..0x82EBBCA0)
	// 82EBBC94: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBC98: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBC9C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBCA0; continue 'dispatch;
            }
            0x82EBBCA0 => {
    //   block [0x82EBBCA0..0x82EBBCC4)
	// 82EBBCA0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBCA4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBCA8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBCAC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBCB0: 41820014  beq 0x82ebbcc4
	if ctx.cr[0].eq {
	pc = 0x82EBBCC4; continue 'dispatch;
	}
	// 82EBBCB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBCB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBCBC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBCC0: 419AFFE0  beq cr6, 0x82ebbca0
	if ctx.cr[6].eq {
	pc = 0x82EBBCA0; continue 'dispatch;
	}
	pc = 0x82EBBCC4; continue 'dispatch;
            }
            0x82EBBCC4 => {
    //   block [0x82EBBCC4..0x82EBBCDC)
	// 82EBBCC4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBCC8: 4182002C  beq 0x82ebbcf4
	if ctx.cr[0].eq {
	pc = 0x82EBBCF4; continue 'dispatch;
	}
	// 82EBBCCC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBCD0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBCD4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBCD8: 4198FFBC  blt cr6, 0x82ebbc94
	if ctx.cr[6].lt {
	pc = 0x82EBBC94; continue 'dispatch;
	}
	pc = 0x82EBBCDC; continue 'dispatch;
            }
            0x82EBBCDC => {
    //   block [0x82EBBCDC..0x82EBBCE0)
	// 82EBBCDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBCE0; continue 'dispatch;
            }
            0x82EBBCE0 => {
    //   block [0x82EBBCE0..0x82EBBCF4)
	// 82EBBCE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBCE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBCE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBCEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBCF0: 4E800020  blr
	return;
            }
            0x82EBBCF4 => {
    //   block [0x82EBBCF4..0x82EBBD00)
	// 82EBBCF4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBCF8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBCFC: 4BFFFFE4  b 0x82ebbce0
	pc = 0x82EBBCE0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBD00 size=160
    let mut pc: u32 = 0x82EBBD00;
    'dispatch: loop {
        match pc {
            0x82EBBD00 => {
    //   block [0x82EBBD00..0x82EBBD34)
	// 82EBBD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBD08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBD0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBD10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBD14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBD18: 419A0064  beq cr6, 0x82ebbd7c
	if ctx.cr[6].eq {
	pc = 0x82EBBD7C; continue 'dispatch;
	}
	// 82EBBD1C: 4BFFF9A5  bl 0x82ebb6c0
	ctx.lr = 0x82EBBD20;
	sub_82EBB6C0(ctx, base);
	// 82EBBD20: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBD24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBD28: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBD2C: 40810050  ble 0x82ebbd7c
	if !ctx.cr[0].gt {
	pc = 0x82EBBD7C; continue 'dispatch;
	}
	// 82EBBD30: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBD34; continue 'dispatch;
            }
            0x82EBBD34 => {
    //   block [0x82EBBD34..0x82EBBD40)
	// 82EBBD34: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBD38: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBD3C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBD40; continue 'dispatch;
            }
            0x82EBBD40 => {
    //   block [0x82EBBD40..0x82EBBD64)
	// 82EBBD40: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBD44: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBD48: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBD4C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBD50: 41820014  beq 0x82ebbd64
	if ctx.cr[0].eq {
	pc = 0x82EBBD64; continue 'dispatch;
	}
	// 82EBBD54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBD58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBD5C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBD60: 419AFFE0  beq cr6, 0x82ebbd40
	if ctx.cr[6].eq {
	pc = 0x82EBBD40; continue 'dispatch;
	}
	pc = 0x82EBBD64; continue 'dispatch;
            }
            0x82EBBD64 => {
    //   block [0x82EBBD64..0x82EBBD7C)
	// 82EBBD64: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBD68: 4182002C  beq 0x82ebbd94
	if ctx.cr[0].eq {
	pc = 0x82EBBD94; continue 'dispatch;
	}
	// 82EBBD6C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBD70: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBD74: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBD78: 4198FFBC  blt cr6, 0x82ebbd34
	if ctx.cr[6].lt {
	pc = 0x82EBBD34; continue 'dispatch;
	}
	pc = 0x82EBBD7C; continue 'dispatch;
            }
            0x82EBBD7C => {
    //   block [0x82EBBD7C..0x82EBBD80)
	// 82EBBD7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBD80; continue 'dispatch;
            }
            0x82EBBD80 => {
    //   block [0x82EBBD80..0x82EBBD94)
	// 82EBBD80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBD84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBD88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBD8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBD90: 4E800020  blr
	return;
            }
            0x82EBBD94 => {
    //   block [0x82EBBD94..0x82EBBDA0)
	// 82EBBD94: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBD98: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBD9C: 4BFFFFE4  b 0x82ebbd80
	pc = 0x82EBBD80; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBDA0 size=160
    let mut pc: u32 = 0x82EBBDA0;
    'dispatch: loop {
        match pc {
            0x82EBBDA0 => {
    //   block [0x82EBBDA0..0x82EBBDD4)
	// 82EBBDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBDA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBDA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBDAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBDB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBDB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBDB8: 419A0064  beq cr6, 0x82ebbe1c
	if ctx.cr[6].eq {
	pc = 0x82EBBE1C; continue 'dispatch;
	}
	// 82EBBDBC: 4BFFF97D  bl 0x82ebb738
	ctx.lr = 0x82EBBDC0;
	sub_82EBB738(ctx, base);
	// 82EBBDC0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBDC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBDC8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBDCC: 40810050  ble 0x82ebbe1c
	if !ctx.cr[0].gt {
	pc = 0x82EBBE1C; continue 'dispatch;
	}
	// 82EBBDD0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBDD4; continue 'dispatch;
            }
            0x82EBBDD4 => {
    //   block [0x82EBBDD4..0x82EBBDE0)
	// 82EBBDD4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBDD8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBDDC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBDE0; continue 'dispatch;
            }
            0x82EBBDE0 => {
    //   block [0x82EBBDE0..0x82EBBE04)
	// 82EBBDE0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBDE4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBDE8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBDEC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBDF0: 41820014  beq 0x82ebbe04
	if ctx.cr[0].eq {
	pc = 0x82EBBE04; continue 'dispatch;
	}
	// 82EBBDF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBDF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBDFC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBE00: 419AFFE0  beq cr6, 0x82ebbde0
	if ctx.cr[6].eq {
	pc = 0x82EBBDE0; continue 'dispatch;
	}
	pc = 0x82EBBE04; continue 'dispatch;
            }
            0x82EBBE04 => {
    //   block [0x82EBBE04..0x82EBBE1C)
	// 82EBBE04: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBE08: 4182002C  beq 0x82ebbe34
	if ctx.cr[0].eq {
	pc = 0x82EBBE34; continue 'dispatch;
	}
	// 82EBBE0C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBE10: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBE14: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBE18: 4198FFBC  blt cr6, 0x82ebbdd4
	if ctx.cr[6].lt {
	pc = 0x82EBBDD4; continue 'dispatch;
	}
	pc = 0x82EBBE1C; continue 'dispatch;
            }
            0x82EBBE1C => {
    //   block [0x82EBBE1C..0x82EBBE20)
	// 82EBBE1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBE20; continue 'dispatch;
            }
            0x82EBBE20 => {
    //   block [0x82EBBE20..0x82EBBE34)
	// 82EBBE20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBE24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBE28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBE2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBE30: 4E800020  blr
	return;
            }
            0x82EBBE34 => {
    //   block [0x82EBBE34..0x82EBBE40)
	// 82EBBE34: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBE38: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBE3C: 4BFFFFE4  b 0x82ebbe20
	pc = 0x82EBBE20; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBE40 size=160
    let mut pc: u32 = 0x82EBBE40;
    'dispatch: loop {
        match pc {
            0x82EBBE40 => {
    //   block [0x82EBBE40..0x82EBBE74)
	// 82EBBE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBE48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBE4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBE50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBE54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBE58: 419A0064  beq cr6, 0x82ebbebc
	if ctx.cr[6].eq {
	pc = 0x82EBBEBC; continue 'dispatch;
	}
	// 82EBBE5C: 4BFFF955  bl 0x82ebb7b0
	ctx.lr = 0x82EBBE60;
	sub_82EBB7B0(ctx, base);
	// 82EBBE60: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBE64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBE68: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBE6C: 40810050  ble 0x82ebbebc
	if !ctx.cr[0].gt {
	pc = 0x82EBBEBC; continue 'dispatch;
	}
	// 82EBBE70: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBE74; continue 'dispatch;
            }
            0x82EBBE74 => {
    //   block [0x82EBBE74..0x82EBBE80)
	// 82EBBE74: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBE78: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBE7C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBE80; continue 'dispatch;
            }
            0x82EBBE80 => {
    //   block [0x82EBBE80..0x82EBBEA4)
	// 82EBBE80: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBE84: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBE88: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBE8C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBE90: 41820014  beq 0x82ebbea4
	if ctx.cr[0].eq {
	pc = 0x82EBBEA4; continue 'dispatch;
	}
	// 82EBBE94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBE98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBE9C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBEA0: 419AFFE0  beq cr6, 0x82ebbe80
	if ctx.cr[6].eq {
	pc = 0x82EBBE80; continue 'dispatch;
	}
	pc = 0x82EBBEA4; continue 'dispatch;
            }
            0x82EBBEA4 => {
    //   block [0x82EBBEA4..0x82EBBEBC)
	// 82EBBEA4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBEA8: 4182002C  beq 0x82ebbed4
	if ctx.cr[0].eq {
	pc = 0x82EBBED4; continue 'dispatch;
	}
	// 82EBBEAC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBEB0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBEB4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBEB8: 4198FFBC  blt cr6, 0x82ebbe74
	if ctx.cr[6].lt {
	pc = 0x82EBBE74; continue 'dispatch;
	}
	pc = 0x82EBBEBC; continue 'dispatch;
            }
            0x82EBBEBC => {
    //   block [0x82EBBEBC..0x82EBBEC0)
	// 82EBBEBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBEC0; continue 'dispatch;
            }
            0x82EBBEC0 => {
    //   block [0x82EBBEC0..0x82EBBED4)
	// 82EBBEC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBEC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBEC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBED0: 4E800020  blr
	return;
            }
            0x82EBBED4 => {
    //   block [0x82EBBED4..0x82EBBEE0)
	// 82EBBED4: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBED8: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBEDC: 4BFFFFE4  b 0x82ebbec0
	pc = 0x82EBBEC0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBEE0 size=160
    let mut pc: u32 = 0x82EBBEE0;
    'dispatch: loop {
        match pc {
            0x82EBBEE0 => {
    //   block [0x82EBBEE0..0x82EBBF14)
	// 82EBBEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBEEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBEF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBEF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EBBEF8: 419A0064  beq cr6, 0x82ebbf5c
	if ctx.cr[6].eq {
	pc = 0x82EBBF5C; continue 'dispatch;
	}
	// 82EBBEFC: 4BFFF92D  bl 0x82ebb828
	ctx.lr = 0x82EBBF00;
	sub_82EBB828(ctx, base);
	// 82EBBF00: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBBF04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBBF08: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBF0C: 40810050  ble 0x82ebbf5c
	if !ctx.cr[0].gt {
	pc = 0x82EBBF5C; continue 'dispatch;
	}
	// 82EBBF10: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82EBBF14; continue 'dispatch;
            }
            0x82EBBF14 => {
    //   block [0x82EBBF14..0x82EBBF20)
	// 82EBBF14: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBF18: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EBBF1C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82EBBF20; continue 'dispatch;
            }
            0x82EBBF20 => {
    //   block [0x82EBBF20..0x82EBBF44)
	// 82EBBF20: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBF24: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBBF28: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBF2C: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82EBBF30: 41820014  beq 0x82ebbf44
	if ctx.cr[0].eq {
	pc = 0x82EBBF44; continue 'dispatch;
	}
	// 82EBBF34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBBF38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EBBF3C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82EBBF40: 419AFFE0  beq cr6, 0x82ebbf20
	if ctx.cr[6].eq {
	pc = 0x82EBBF20; continue 'dispatch;
	}
	pc = 0x82EBBF44; continue 'dispatch;
            }
            0x82EBBF44 => {
    //   block [0x82EBBF44..0x82EBBF5C)
	// 82EBBF44: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBBF48: 4182002C  beq 0x82ebbf74
	if ctx.cr[0].eq {
	pc = 0x82EBBF74; continue 'dispatch;
	}
	// 82EBBF4C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82EBBF50: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBBF54: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82EBBF58: 4198FFBC  blt cr6, 0x82ebbf14
	if ctx.cr[6].lt {
	pc = 0x82EBBF14; continue 'dispatch;
	}
	pc = 0x82EBBF5C; continue 'dispatch;
            }
            0x82EBBF5C => {
    //   block [0x82EBBF5C..0x82EBBF60)
	// 82EBBF5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBF60; continue 'dispatch;
            }
            0x82EBBF60 => {
    //   block [0x82EBBF60..0x82EBBF74)
	// 82EBBF60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBF64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBF68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBF6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBF70: 4E800020  blr
	return;
            }
            0x82EBBF74 => {
    //   block [0x82EBBF74..0x82EBBF80)
	// 82EBBF74: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBBF78: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82EBBF7C: 4BFFFFE4  b 0x82ebbf60
	pc = 0x82EBBF60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBF80 size=72
    let mut pc: u32 = 0x82EBBF80;
    'dispatch: loop {
        match pc {
            0x82EBBF80 => {
    //   block [0x82EBBF80..0x82EBBFB0)
	// 82EBBF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBF88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBF8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBF90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBF94: 38600450  li r3, 0x450
	ctx.r[3].s64 = 1104;
	// 82EBBF98: 4B75A991  bl 0x82616928
	ctx.lr = 0x82EBBF9C;
	sub_82616928(ctx, base);
	// 82EBBF9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBBFA0: 41820010  beq 0x82ebbfb0
	if ctx.cr[0].eq {
	pc = 0x82EBBFB0; continue 'dispatch;
	}
	// 82EBBFA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBBFA8: 4BFFDC59  bl 0x82eb9c00
	ctx.lr = 0x82EBBFAC;
	sub_82EB9C00(ctx, base);
	// 82EBBFAC: 48000008  b 0x82ebbfb4
	pc = 0x82EBBFB4; continue 'dispatch;
            }
            0x82EBBFB0 => {
    //   block [0x82EBBFB0..0x82EBBFB4)
	// 82EBBFB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBBFB4; continue 'dispatch;
            }
            0x82EBBFB4 => {
    //   block [0x82EBBFB4..0x82EBBFC8)
	// 82EBBFB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBBFB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBBFBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBBFC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBBFC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBBFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBBFC8 size=88
    let mut pc: u32 = 0x82EBBFC8;
    'dispatch: loop {
        match pc {
            0x82EBBFC8 => {
    //   block [0x82EBBFC8..0x82EBC004)
	// 82EBBFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBBFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBBFD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBBFD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBBFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBBFDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBBFE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBBFE4: 4BFFE07D  bl 0x82eba060
	ctx.lr = 0x82EBBFE8;
	sub_82EBA060(ctx, base);
	// 82EBBFE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBBFEC: 41820018  beq 0x82ebc004
	if ctx.cr[0].eq {
	pc = 0x82EBC004; continue 'dispatch;
	}
	// 82EBBFF0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBBFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBBFF8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBBFFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC000: 4E800421  bctrl
	ctx.lr = 0x82EBC004;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBC004 => {
    //   block [0x82EBC004..0x82EBC020)
	// 82EBC004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBC00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBC010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBC014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBC018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBC01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBC020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBC020 size=7308
    let mut pc: u32 = 0x82EBC020;
    'dispatch: loop {
        match pc {
            0x82EBC020 => {
    //   block [0x82EBC020..0x82EBC04C)
	// 82EBC020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBC024: 4BDED3DD  bl 0x82ca9400
	ctx.lr = 0x82EBC028;
	sub_82CA93D0(ctx, base);
	// 82EBC028: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EBC02C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBC030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBC034: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EBC038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC03C: 48300025  bl 0x831bc060
	ctx.lr = 0x82EBC040;
	sub_831BC060(ctx, base);
	// 82EBC040: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC044: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82EBC048: 409A000C  bne cr6, 0x82ebc054
	if !ctx.cr[6].eq {
	pc = 0x82EBC054; continue 'dispatch;
	}
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC04C => {
    //   block [0x82EBC04C..0x82EBC054)
	// 82EBC04C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC050: 48000184  b 0x82ebc1d4
	pc = 0x82EBC1D4; continue 'dispatch;
            }
            0x82EBC054 => {
    //   block [0x82EBC054..0x82EBC094)
	// 82EBC054: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC05C: 3BCBACD0  addi r30, r11, -0x5330
	ctx.r[30].s64 = ctx.r[11].s64 + -21296;
	// 82EBC060: 48300001  bl 0x831bc060
	ctx.lr = 0x82EBC064;
	sub_831BC060(ctx, base);
	// 82EBC064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC068: 4BDF0AE9  bl 0x82cacb50
	ctx.lr = 0x82EBC06C;
	sub_82CACB50(ctx, base);
	// 82EBC06C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC074: 40820034  bne 0x82ebc0a8
	if !ctx.cr[0].eq {
	pc = 0x82EBC0A8; continue 'dispatch;
	}
	// 82EBC078: 4BA51C91  bl 0x8290dd08
	ctx.lr = 0x82EBC07C;
	sub_8290DD08(ctx, base);
	// 82EBC07C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC080: 4182FFCC  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC084: 4BDEE33D  bl 0x82caa3c0
	ctx.lr = 0x82EBC088;
	sub_82CAA3C0(ctx, base);
	// 82EBC088: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82EBC08C: 40980008  bge cr6, 0x82ebc094
	if !ctx.cr[6].lt {
	pc = 0x82EBC094; continue 'dispatch;
	}
	// 82EBC090: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EBC094; continue 'dispatch;
            }
            0x82EBC094 => {
    //   block [0x82EBC094..0x82EBC0A0)
	// 82EBC094: 2B031000  cmplwi cr6, r3, 0x1000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4096 as u32, &mut ctx.xer);
	// 82EBC098: 40990008  ble cr6, 0x82ebc0a0
	if !ctx.cr[6].gt {
	pc = 0x82EBC0A0; continue 'dispatch;
	}
	// 82EBC09C: 38601000  li r3, 0x1000
	ctx.r[3].s64 = 4096;
	pc = 0x82EBC0A0; continue 'dispatch;
            }
            0x82EBC0A0 => {
    //   block [0x82EBC0A0..0x82EBC0A8)
	// 82EBC0A0: 907A0030  stw r3, 0x30(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82EBC0A4: 4BFFFFA8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC0A8 => {
    //   block [0x82EBC0A8..0x82EBC0E4)
	// 82EBC0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC0AC: 3BCBACBC  addi r30, r11, -0x5344
	ctx.r[30].s64 = ctx.r[11].s64 + -21316;
	// 82EBC0B0: 482FFFB1  bl 0x831bc060
	ctx.lr = 0x82EBC0B4;
	sub_831BC060(ctx, base);
	// 82EBC0B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC0B8: 4BDF0A99  bl 0x82cacb50
	ctx.lr = 0x82EBC0BC;
	sub_82CACB50(ctx, base);
	// 82EBC0BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC0C4: 40820034  bne 0x82ebc0f8
	if !ctx.cr[0].eq {
	pc = 0x82EBC0F8; continue 'dispatch;
	}
	// 82EBC0C8: 4BA51C41  bl 0x8290dd08
	ctx.lr = 0x82EBC0CC;
	sub_8290DD08(ctx, base);
	// 82EBC0CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC0D0: 4182FF7C  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC0D4: 4BDEE2ED  bl 0x82caa3c0
	ctx.lr = 0x82EBC0D8;
	sub_82CAA3C0(ctx, base);
	// 82EBC0D8: 2B030008  cmplwi cr6, r3, 8
	ctx.cr[6].compare_u32(ctx.r[3].u32, 8 as u32, &mut ctx.xer);
	// 82EBC0DC: 40980008  bge cr6, 0x82ebc0e4
	if !ctx.cr[6].lt {
	pc = 0x82EBC0E4; continue 'dispatch;
	}
	// 82EBC0E0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	pc = 0x82EBC0E4; continue 'dispatch;
            }
            0x82EBC0E4 => {
    //   block [0x82EBC0E4..0x82EBC0F0)
	// 82EBC0E4: 2B030800  cmplwi cr6, r3, 0x800
	ctx.cr[6].compare_u32(ctx.r[3].u32, 2048 as u32, &mut ctx.xer);
	// 82EBC0E8: 40990008  ble cr6, 0x82ebc0f0
	if !ctx.cr[6].gt {
	pc = 0x82EBC0F0; continue 'dispatch;
	}
	// 82EBC0EC: 38600800  li r3, 0x800
	ctx.r[3].s64 = 2048;
	pc = 0x82EBC0F0; continue 'dispatch;
            }
            0x82EBC0F0 => {
    //   block [0x82EBC0F0..0x82EBC0F8)
	// 82EBC0F0: 907A0028  stw r3, 0x28(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82EBC0F4: 4BFFFF58  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC0F8 => {
    //   block [0x82EBC0F8..0x82EBC134)
	// 82EBC0F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC0FC: 3BCBAC94  addi r30, r11, -0x536c
	ctx.r[30].s64 = ctx.r[11].s64 + -21356;
	// 82EBC100: 482FFF61  bl 0x831bc060
	ctx.lr = 0x82EBC104;
	sub_831BC060(ctx, base);
	// 82EBC104: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC108: 4BDF0A49  bl 0x82cacb50
	ctx.lr = 0x82EBC10C;
	sub_82CACB50(ctx, base);
	// 82EBC10C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC114: 40820038  bne 0x82ebc14c
	if !ctx.cr[0].eq {
	pc = 0x82EBC14C; continue 'dispatch;
	}
	// 82EBC118: 4BA51BF1  bl 0x8290dd08
	ctx.lr = 0x82EBC11C;
	sub_8290DD08(ctx, base);
	// 82EBC11C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC120: 4182FF2C  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC124: 4BDEE29D  bl 0x82caa3c0
	ctx.lr = 0x82EBC128;
	sub_82CAA3C0(ctx, base);
	// 82EBC128: 2B030400  cmplwi cr6, r3, 0x400
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1024 as u32, &mut ctx.xer);
	// 82EBC12C: 40980008  bge cr6, 0x82ebc134
	if !ctx.cr[6].lt {
	pc = 0x82EBC134; continue 'dispatch;
	}
	// 82EBC130: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	pc = 0x82EBC134; continue 'dispatch;
            }
            0x82EBC134 => {
    //   block [0x82EBC134..0x82EBC144)
	// 82EBC134: 3D600004  lis r11, 4
	ctx.r[11].s64 = 262144;
	// 82EBC138: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC13C: 40990008  ble cr6, 0x82ebc144
	if !ctx.cr[6].gt {
	pc = 0x82EBC144; continue 'dispatch;
	}
	// 82EBC140: 3C600004  lis r3, 4
	ctx.r[3].s64 = 262144;
	pc = 0x82EBC144; continue 'dispatch;
            }
            0x82EBC144 => {
    //   block [0x82EBC144..0x82EBC14C)
	// 82EBC144: 907A0098  stw r3, 0x98(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 82EBC148: 4BFFFF04  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC14C => {
    //   block [0x82EBC14C..0x82EBC184)
	// 82EBC14C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC150: 3BCBAC60  addi r30, r11, -0x53a0
	ctx.r[30].s64 = ctx.r[11].s64 + -21408;
	// 82EBC154: 482FFF0D  bl 0x831bc060
	ctx.lr = 0x82EBC158;
	sub_831BC060(ctx, base);
	// 82EBC158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC15C: 4BDF09F5  bl 0x82cacb50
	ctx.lr = 0x82EBC160;
	sub_82CACB50(ctx, base);
	// 82EBC160: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC168: 4082001C  bne 0x82ebc184
	if !ctx.cr[0].eq {
	pc = 0x82EBC184; continue 'dispatch;
	}
	// 82EBC16C: 4BA51B9D  bl 0x8290dd08
	ctx.lr = 0x82EBC170;
	sub_8290DD08(ctx, base);
	// 82EBC170: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC174: 4182FED8  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC178: 4BDEE249  bl 0x82caa3c0
	ctx.lr = 0x82EBC17C;
	sub_82CAA3C0(ctx, base);
	// 82EBC17C: 907A009C  stw r3, 0x9c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 82EBC180: 4BFFFECC  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC184 => {
    //   block [0x82EBC184..0x82EBC1D0)
	// 82EBC184: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC188: 3BCB9C80  addi r30, r11, -0x6380
	ctx.r[30].s64 = ctx.r[11].s64 + -25472;
	// 82EBC18C: 482FFED5  bl 0x831bc060
	ctx.lr = 0x82EBC190;
	sub_831BC060(ctx, base);
	// 82EBC190: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC194: 4BDF09BD  bl 0x82cacb50
	ctx.lr = 0x82EBC198;
	sub_82CACB50(ctx, base);
	// 82EBC198: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC1A0: 40820040  bne 0x82ebc1e0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1E0; continue 'dispatch;
	}
	// 82EBC1A4: 4BA51B65  bl 0x8290dd08
	ctx.lr = 0x82EBC1A8;
	sub_8290DD08(ctx, base);
	// 82EBC1A8: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82EBC1AC: 4182FEA0  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC1B0: 817A0044  lwz r11, 0x44(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EBC1B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC1B8: 41820018  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC1BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EBC1C0: 48012321  bl 0x82ece4e0
	ctx.lr = 0x82EBC1C4;
	sub_82ECE4E0(ctx, base);
	// 82EBC1C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC1C8: 907A0048  stw r3, 0x48(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82EBC1CC: 4082FE80  bne 0x82ebc04c
	if !ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBC1D0 => {
    //   block [0x82EBC1D0..0x82EBC1D4)
	// 82EBC1D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBC1D4; continue 'dispatch;
            }
            0x82EBC1D4 => {
    //   block [0x82EBC1D4..0x82EBC1E0)
	// 82EBC1D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EBC1D8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EBC1DC: 4BDED274  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EBC1E0 => {
    //   block [0x82EBC1E0..0x82EBC234)
	// 82EBC1E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC1E4: 3BCBAC54  addi r30, r11, -0x53ac
	ctx.r[30].s64 = ctx.r[11].s64 + -21420;
	// 82EBC1E8: 482FFE79  bl 0x831bc060
	ctx.lr = 0x82EBC1EC;
	sub_831BC060(ctx, base);
	// 82EBC1EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC1F0: 4BDF0961  bl 0x82cacb50
	ctx.lr = 0x82EBC1F4;
	sub_82CACB50(ctx, base);
	// 82EBC1F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC1F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC1FC: 4082005C  bne 0x82ebc258
	if !ctx.cr[0].eq {
	pc = 0x82EBC258; continue 'dispatch;
	}
	// 82EBC200: 4BA51B09  bl 0x8290dd08
	ctx.lr = 0x82EBC204;
	sub_8290DD08(ctx, base);
	// 82EBC204: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBC208: 4182FFC8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC20C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82EBC210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC214: 388BD7D0  addi r4, r11, -0x2830
	ctx.r[4].s64 = ctx.r[11].s64 + -10288;
	// 82EBC218: 4BDF0939  bl 0x82cacb50
	ctx.lr = 0x82EBC21C;
	sub_82CACB50(ctx, base);
	// 82EBC21C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC220: 40820014  bne 0x82ebc234
	if !ctx.cr[0].eq {
	pc = 0x82EBC234; continue 'dispatch;
	}
	// 82EBC224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC228: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBC22C: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBC230: 4BFFFFA4  b 0x82ebc1d4
	pc = 0x82EBC1D4; continue 'dispatch;
            }
            0x82EBC234 => {
    //   block [0x82EBC234..0x82EBC258)
	// 82EBC234: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC23C: 388BAC44  addi r4, r11, -0x53bc
	ctx.r[4].s64 = ctx.r[11].s64 + -21436;
	// 82EBC240: 4BDF0911  bl 0x82cacb50
	ctx.lr = 0x82EBC244;
	sub_82CACB50(ctx, base);
	// 82EBC244: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC248: 4082FF88  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC24C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EBC250: 917A0020  stw r11, 0x20(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EBC254: 4BFFFDF8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC258 => {
    //   block [0x82EBC258..0x82EBC30C)
	// 82EBC258: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC25C: 3BCBAC28  addi r30, r11, -0x53d8
	ctx.r[30].s64 = ctx.r[11].s64 + -21464;
	// 82EBC260: 482FFE01  bl 0x831bc060
	ctx.lr = 0x82EBC264;
	sub_831BC060(ctx, base);
	// 82EBC264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC268: 4BDF08E9  bl 0x82cacb50
	ctx.lr = 0x82EBC26C;
	sub_82CACB50(ctx, base);
	// 82EBC26C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC274: 408200AC  bne 0x82ebc320
	if !ctx.cr[0].eq {
	pc = 0x82EBC320; continue 'dispatch;
	}
	// 82EBC278: 4BA51A91  bl 0x8290dd08
	ctx.lr = 0x82EBC27C;
	sub_8290DD08(ctx, base);
	// 82EBC27C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBC284: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EBC288: 4BDF08C9  bl 0x82cacb50
	ctx.lr = 0x82EBC28C;
	sub_82CACB50(ctx, base);
	// 82EBC28C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC290: 41820084  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC29C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EBC2A0: 4BDF08B1  bl 0x82cacb50
	ctx.lr = 0x82EBC2A4;
	sub_82CACB50(ctx, base);
	// 82EBC2A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2A8: 4182006C  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC2AC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2B4: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EBC2B8: 4BDF0899  bl 0x82cacb50
	ctx.lr = 0x82EBC2BC;
	sub_82CACB50(ctx, base);
	// 82EBC2BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2C0: 41820054  beq 0x82ebc314
	if ctx.cr[0].eq {
	pc = 0x82EBC314; continue 'dispatch;
	}
	// 82EBC2C4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2CC: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EBC2D0: 4BDF0881  bl 0x82cacb50
	ctx.lr = 0x82EBC2D4;
	sub_82CACB50(ctx, base);
	// 82EBC2D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2D8: 41820034  beq 0x82ebc30c
	if ctx.cr[0].eq {
	pc = 0x82EBC30C; continue 'dispatch;
	}
	// 82EBC2DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2E4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EBC2E8: 4BDF0869  bl 0x82cacb50
	ctx.lr = 0x82EBC2EC;
	sub_82CACB50(ctx, base);
	// 82EBC2EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC2F0: 4182001C  beq 0x82ebc30c
	if ctx.cr[0].eq {
	pc = 0x82EBC30C; continue 'dispatch;
	}
	// 82EBC2F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC2F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC2FC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EBC300: 4BDF0851  bl 0x82cacb50
	ctx.lr = 0x82EBC304;
	sub_82CACB50(ctx, base);
	// 82EBC304: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC308: 4082FEC8  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBC30C; continue 'dispatch;
            }
            0x82EBC30C => {
    //   block [0x82EBC30C..0x82EBC314)
	// 82EBC30C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC310: 48000008  b 0x82ebc318
	pc = 0x82EBC318; continue 'dispatch;
            }
            0x82EBC314 => {
    //   block [0x82EBC314..0x82EBC318)
	// 82EBC314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EBC318; continue 'dispatch;
            }
            0x82EBC318 => {
    //   block [0x82EBC318..0x82EBC320)
	// 82EBC318: 997A007E  stb r11, 0x7e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(126 as u32), ctx.r[11].u8 ) };
	// 82EBC31C: 4BFFFD30  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC320 => {
    //   block [0x82EBC320..0x82EBC3DC)
	// 82EBC320: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC324: 3BCBAC0C  addi r30, r11, -0x53f4
	ctx.r[30].s64 = ctx.r[11].s64 + -21492;
	// 82EBC328: 482FFD39  bl 0x831bc060
	ctx.lr = 0x82EBC32C;
	sub_831BC060(ctx, base);
	// 82EBC32C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC330: 4BDF0821  bl 0x82cacb50
	ctx.lr = 0x82EBC334;
	sub_82CACB50(ctx, base);
	// 82EBC334: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC33C: 408200B4  bne 0x82ebc3f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC3F0; continue 'dispatch;
	}
	// 82EBC340: 4BA519C9  bl 0x8290dd08
	ctx.lr = 0x82EBC344;
	sub_8290DD08(ctx, base);
	// 82EBC344: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBC348: 4182FD04  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC34C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC354: 388B1694  addi r4, r11, 0x1694
	ctx.r[4].s64 = ctx.r[11].s64 + 5780;
	// 82EBC358: 4BDF07F9  bl 0x82cacb50
	ctx.lr = 0x82EBC35C;
	sub_82CACB50(ctx, base);
	// 82EBC35C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC360: 41820084  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC36C: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 82EBC370: 4BDF07E1  bl 0x82cacb50
	ctx.lr = 0x82EBC374;
	sub_82CACB50(ctx, base);
	// 82EBC374: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC378: 4182006C  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC37C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC384: 388BD56C  addi r4, r11, -0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + -10900;
	// 82EBC388: 4BDF07C9  bl 0x82cacb50
	ctx.lr = 0x82EBC38C;
	sub_82CACB50(ctx, base);
	// 82EBC38C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC390: 41820054  beq 0x82ebc3e4
	if ctx.cr[0].eq {
	pc = 0x82EBC3E4; continue 'dispatch;
	}
	// 82EBC394: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC39C: 388B1698  addi r4, r11, 0x1698
	ctx.r[4].s64 = ctx.r[11].s64 + 5784;
	// 82EBC3A0: 4BDF07B1  bl 0x82cacb50
	ctx.lr = 0x82EBC3A4;
	sub_82CACB50(ctx, base);
	// 82EBC3A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3A8: 41820034  beq 0x82ebc3dc
	if ctx.cr[0].eq {
	pc = 0x82EBC3DC; continue 'dispatch;
	}
	// 82EBC3AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC3B4: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 82EBC3B8: 4BDF0799  bl 0x82cacb50
	ctx.lr = 0x82EBC3BC;
	sub_82CACB50(ctx, base);
	// 82EBC3BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3C0: 4182001C  beq 0x82ebc3dc
	if ctx.cr[0].eq {
	pc = 0x82EBC3DC; continue 'dispatch;
	}
	// 82EBC3C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC3CC: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 82EBC3D0: 4BDF0781  bl 0x82cacb50
	ctx.lr = 0x82EBC3D4;
	sub_82CACB50(ctx, base);
	// 82EBC3D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC3D8: 4082FDF8  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBC3DC; continue 'dispatch;
            }
            0x82EBC3DC => {
    //   block [0x82EBC3DC..0x82EBC3E4)
	// 82EBC3DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC3E0: 48000008  b 0x82ebc3e8
	pc = 0x82EBC3E8; continue 'dispatch;
            }
            0x82EBC3E4 => {
    //   block [0x82EBC3E4..0x82EBC3E8)
	// 82EBC3E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EBC3E8; continue 'dispatch;
            }
            0x82EBC3E8 => {
    //   block [0x82EBC3E8..0x82EBC3F0)
	// 82EBC3E8: 997A007F  stb r11, 0x7f(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(127 as u32), ctx.r[11].u8 ) };
	// 82EBC3EC: 4BFFFC60  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC3F0 => {
    //   block [0x82EBC3F0..0x82EBC434)
	// 82EBC3F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC3F4: 3BCBABFC  addi r30, r11, -0x5404
	ctx.r[30].s64 = ctx.r[11].s64 + -21508;
	// 82EBC3F8: 482FFC69  bl 0x831bc060
	ctx.lr = 0x82EBC3FC;
	sub_831BC060(ctx, base);
	// 82EBC3FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC400: 4BDF0751  bl 0x82cacb50
	ctx.lr = 0x82EBC404;
	sub_82CACB50(ctx, base);
	// 82EBC404: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC40C: 40820064  bne 0x82ebc470
	if !ctx.cr[0].eq {
	pc = 0x82EBC470; continue 'dispatch;
	}
	// 82EBC410: 4BA518F9  bl 0x8290dd08
	ctx.lr = 0x82EBC414;
	sub_8290DD08(ctx, base);
	// 82EBC414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC418: 4182FDB8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC41C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBC420: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBC424: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC428: 4182000C  beq 0x82ebc434
	if ctx.cr[0].eq {
	pc = 0x82EBC434; continue 'dispatch;
	}
	// 82EBC42C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC430: 4800000C  b 0x82ebc43c
	pc = 0x82EBC43C; continue 'dispatch;
            }
            0x82EBC434 => {
    //   block [0x82EBC434..0x82EBC43C)
	// 82EBC434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC438: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBC43C; continue 'dispatch;
            }
            0x82EBC43C => {
    //   block [0x82EBC43C..0x82EBC454)
	// 82EBC43C: 4BDEF775  bl 0x82cabbb0
	ctx.lr = 0x82EBC440;
	sub_82CABBB0(ctx, base);
	// 82EBC440: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC448: C01A0024  lfs f0, 0x24(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBC44C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC450: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EBC454; continue 'dispatch;
            }
            0x82EBC454 => {
    //   block [0x82EBC454..0x82EBC460)
	// 82EBC454: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBC458: 41980008  blt cr6, 0x82ebc460
	if ctx.cr[6].lt {
	pc = 0x82EBC460; continue 'dispatch;
	}
	// 82EBC45C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBC460; continue 'dispatch;
            }
            0x82EBC460 => {
    //   block [0x82EBC460..0x82EBC470)
	// 82EBC460: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBC464: 409AFFF0  bne cr6, 0x82ebc454
	if !ctx.cr[6].eq {
	pc = 0x82EBC454; continue 'dispatch;
	}
	// 82EBC468: D01A0024  stfs f0, 0x24(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBC46C: 4BFFFBE0  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC470 => {
    //   block [0x82EBC470..0x82EBC4B4)
	// 82EBC470: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC474: 3BCBABE0  addi r30, r11, -0x5420
	ctx.r[30].s64 = ctx.r[11].s64 + -21536;
	// 82EBC478: 482FFBE9  bl 0x831bc060
	ctx.lr = 0x82EBC47C;
	sub_831BC060(ctx, base);
	// 82EBC47C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC480: 4BDF06D1  bl 0x82cacb50
	ctx.lr = 0x82EBC484;
	sub_82CACB50(ctx, base);
	// 82EBC484: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC48C: 40820064  bne 0x82ebc4f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC4F0; continue 'dispatch;
	}
	// 82EBC490: 4BA51879  bl 0x8290dd08
	ctx.lr = 0x82EBC494;
	sub_8290DD08(ctx, base);
	// 82EBC494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC498: 4182FD38  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC49C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBC4A0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBC4A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC4A8: 4182000C  beq 0x82ebc4b4
	if ctx.cr[0].eq {
	pc = 0x82EBC4B4; continue 'dispatch;
	}
	// 82EBC4AC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBC4B0: 4800000C  b 0x82ebc4bc
	pc = 0x82EBC4BC; continue 'dispatch;
            }
            0x82EBC4B4 => {
    //   block [0x82EBC4B4..0x82EBC4BC)
	// 82EBC4B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC4B8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBC4BC; continue 'dispatch;
            }
            0x82EBC4BC => {
    //   block [0x82EBC4BC..0x82EBC4D4)
	// 82EBC4BC: 4BDEF6F5  bl 0x82cabbb0
	ctx.lr = 0x82EBC4C0;
	sub_82CABBB0(ctx, base);
	// 82EBC4C0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC4C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC4C8: C01A002C  lfs f0, 0x2c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBC4CC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBC4D0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EBC4D4; continue 'dispatch;
            }
            0x82EBC4D4 => {
    //   block [0x82EBC4D4..0x82EBC4E0)
	// 82EBC4D4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBC4D8: 41980008  blt cr6, 0x82ebc4e0
	if ctx.cr[6].lt {
	pc = 0x82EBC4E0; continue 'dispatch;
	}
	// 82EBC4DC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBC4E0; continue 'dispatch;
            }
            0x82EBC4E0 => {
    //   block [0x82EBC4E0..0x82EBC4F0)
	// 82EBC4E0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBC4E4: 409AFFF0  bne cr6, 0x82ebc4d4
	if !ctx.cr[6].eq {
	pc = 0x82EBC4D4; continue 'dispatch;
	}
	// 82EBC4E8: D01A002C  stfs f0, 0x2c(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBC4EC: 4BFFFB60  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC4F0 => {
    //   block [0x82EBC4F0..0x82EBC5CC)
	// 82EBC4F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC4F4: 3BCBABD0  addi r30, r11, -0x5430
	ctx.r[30].s64 = ctx.r[11].s64 + -21552;
	// 82EBC4F8: 482FFB69  bl 0x831bc060
	ctx.lr = 0x82EBC4FC;
	sub_831BC060(ctx, base);
	// 82EBC4FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC500: 4BDF0651  bl 0x82cacb50
	ctx.lr = 0x82EBC504;
	sub_82CACB50(ctx, base);
	// 82EBC504: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC50C: 408200E0  bne 0x82ebc5ec
	if !ctx.cr[0].eq {
	pc = 0x82EBC5EC; continue 'dispatch;
	}
	// 82EBC510: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC514: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82EBC518: 4BA517F1  bl 0x8290dd08
	ctx.lr = 0x82EBC51C;
	sub_8290DD08(ctx, base);
	// 82EBC51C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC520: 4BDF0631  bl 0x82cacb50
	ctx.lr = 0x82EBC524;
	sub_82CACB50(ctx, base);
	// 82EBC524: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC528: 418200AC  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC52C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC534: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82EBC538: 4BA517D1  bl 0x8290dd08
	ctx.lr = 0x82EBC53C;
	sub_8290DD08(ctx, base);
	// 82EBC53C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC540: 4BDF0611  bl 0x82cacb50
	ctx.lr = 0x82EBC544;
	sub_82CACB50(ctx, base);
	// 82EBC544: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC548: 4182008C  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC54C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EBC550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC554: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82EBC558: 4BA517B1  bl 0x8290dd08
	ctx.lr = 0x82EBC55C;
	sub_8290DD08(ctx, base);
	// 82EBC55C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC560: 4BDF05F1  bl 0x82cacb50
	ctx.lr = 0x82EBC564;
	sub_82CACB50(ctx, base);
	// 82EBC564: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC568: 4182006C  beq 0x82ebc5d4
	if ctx.cr[0].eq {
	pc = 0x82EBC5D4; continue 'dispatch;
	}
	// 82EBC56C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EBC570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC574: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82EBC578: 4BA51791  bl 0x8290dd08
	ctx.lr = 0x82EBC57C;
	sub_8290DD08(ctx, base);
	// 82EBC57C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC580: 4BDF05D1  bl 0x82cacb50
	ctx.lr = 0x82EBC584;
	sub_82CACB50(ctx, base);
	// 82EBC584: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC588: 41820044  beq 0x82ebc5cc
	if ctx.cr[0].eq {
	pc = 0x82EBC5CC; continue 'dispatch;
	}
	// 82EBC58C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC594: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82EBC598: 4BA51771  bl 0x8290dd08
	ctx.lr = 0x82EBC59C;
	sub_8290DD08(ctx, base);
	// 82EBC59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5A0: 4BDF05B1  bl 0x82cacb50
	ctx.lr = 0x82EBC5A4;
	sub_82CACB50(ctx, base);
	// 82EBC5A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC5A8: 41820024  beq 0x82ebc5cc
	if ctx.cr[0].eq {
	pc = 0x82EBC5CC; continue 'dispatch;
	}
	// 82EBC5AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EBC5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC5B4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82EBC5B8: 4BA51751  bl 0x8290dd08
	ctx.lr = 0x82EBC5BC;
	sub_8290DD08(ctx, base);
	// 82EBC5BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5C0: 4BDF0591  bl 0x82cacb50
	ctx.lr = 0x82EBC5C4;
	sub_82CACB50(ctx, base);
	// 82EBC5C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC5C8: 4082FC08  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBC5CC; continue 'dispatch;
            }
            0x82EBC5CC => {
    //   block [0x82EBC5CC..0x82EBC5D4)
	// 82EBC5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBC5D0: 48000008  b 0x82ebc5d8
	pc = 0x82EBC5D8; continue 'dispatch;
            }
            0x82EBC5D4 => {
    //   block [0x82EBC5D4..0x82EBC5D8)
	// 82EBC5D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EBC5D8; continue 'dispatch;
            }
            0x82EBC5D8 => {
    //   block [0x82EBC5D8..0x82EBC5EC)
	// 82EBC5D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC5DC: 4182FA70  beq 0x82ebc04c
	if ctx.cr[0].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBC5E4: 997A0440  stb r11, 0x440(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(1088 as u32), ctx.r[11].u8 ) };
	// 82EBC5E8: 4BFFFA64  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC5EC => {
    //   block [0x82EBC5EC..0x82EBC634)
	// 82EBC5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC5F0: 3BCBA5B4  addi r30, r11, -0x5a4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23116;
	// 82EBC5F4: 482FFA6D  bl 0x831bc060
	ctx.lr = 0x82EBC5F8;
	sub_831BC060(ctx, base);
	// 82EBC5F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC5FC: 4BDF0555  bl 0x82cacb50
	ctx.lr = 0x82EBC600;
	sub_82CACB50(ctx, base);
	// 82EBC600: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC608: 40820050  bne 0x82ebc658
	if !ctx.cr[0].eq {
	pc = 0x82EBC658; continue 'dispatch;
	}
	// 82EBC60C: 4BA516FD  bl 0x8290dd08
	ctx.lr = 0x82EBC610;
	sub_8290DD08(ctx, base);
	// 82EBC610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBC614: 4182FBBC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBC618: 4BDEF599  bl 0x82cabbb0
	ctx.lr = 0x82EBC61C;
	sub_82CABBB0(ctx, base);
	// 82EBC61C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBC620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBC624: C1BA044C  lfs f13, 0x44c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBC628: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBC62C: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBC630: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EBC634; continue 'dispatch;
            }
            0x82EBC634 => {
    //   block [0x82EBC634..0x82EBC648)
	// 82EBC634: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBC638: 41980010  blt cr6, 0x82ebc648
	if ctx.cr[6].lt {
	pc = 0x82EBC648; continue 'dispatch;
	}
	// 82EBC63C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EBC640: 41990008  bgt cr6, 0x82ebc648
	if ctx.cr[6].gt {
	pc = 0x82EBC648; continue 'dispatch;
	}
	// 82EBC644: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EBC648; continue 'dispatch;
            }
            0x82EBC648 => {
    //   block [0x82EBC648..0x82EBC658)
	// 82EBC648: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EBC64C: 409AFFE8  bne cr6, 0x82ebc634
	if !ctx.cr[6].eq {
	pc = 0x82EBC634; continue 'dispatch;
	}
	// 82EBC650: D1BA044C  stfs f13, 0x44c(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(1100 as u32), tmp.u32 ) };
	// 82EBC654: 4BFFF9F8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC658 => {
    //   block [0x82EBC658..0x82EBC69C)
	// 82EBC658: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC65C: 3BCBABB8  addi r30, r11, -0x5448
	ctx.r[30].s64 = ctx.r[11].s64 + -21576;
	// 82EBC660: 482FFA01  bl 0x831bc060
	ctx.lr = 0x82EBC664;
	sub_831BC060(ctx, base);
	// 82EBC664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC668: 4BDF04E9  bl 0x82cacb50
	ctx.lr = 0x82EBC66C;
	sub_82CACB50(ctx, base);
	// 82EBC66C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC670: 40820118  bne 0x82ebc788
	if !ctx.cr[0].eq {
	pc = 0x82EBC788; continue 'dispatch;
	}
	// 82EBC674: 387A01A0  addi r3, r26, 0x1a0
	ctx.r[3].s64 = ctx.r[26].s64 + 416;
	// 82EBC678: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC67C: 4BFFCB5D  bl 0x82eb91d8
	ctx.lr = 0x82EBC680;
	sub_82EB91D8(ctx, base);
	// 82EBC680: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC684: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC688: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC690: 409900D0  ble cr6, 0x82ebc760
	if !ctx.cr[6].gt {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC694: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC698: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBC69C; continue 'dispatch;
            }
            0x82EBC69C => {
    //   block [0x82EBC69C..0x82EBC6D0)
	// 82EBC69C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC6A4: 4BFC7985  bl 0x82e84028
	ctx.lr = 0x82EBC6A8;
	sub_82E84028(ctx, base);
	// 82EBC6A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC6AC: 482FF9B5  bl 0x831bc060
	ctx.lr = 0x82EBC6B0;
	sub_831BC060(ctx, base);
	// 82EBC6B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC6B4: 4BDF049D  bl 0x82cacb50
	ctx.lr = 0x82EBC6B8;
	sub_82CACB50(ctx, base);
	// 82EBC6B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC6BC: 40820014  bne 0x82ebc6d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC6D0; continue 'dispatch;
	}
	// 82EBC6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC6C4: 4BA51645  bl 0x8290dd08
	ctx.lr = 0x82EBC6C8;
	sub_8290DD08(ctx, base);
	// 82EBC6C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC6CC: 48000024  b 0x82ebc6f0
	pc = 0x82EBC6F0; continue 'dispatch;
            }
            0x82EBC6D0 => {
    //   block [0x82EBC6D0..0x82EBC6F0)
	// 82EBC6D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC6D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC6D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC6DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC6E4: 4E800421  bctrl
	ctx.lr = 0x82EBC6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC6E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC6EC: 4182FAE4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBC6F0 => {
    //   block [0x82EBC6F0..0x82EBC71C)
	// 82EBC6F0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC6F4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC6F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC6FC: 4198FFA0  blt cr6, 0x82ebc69c
	if ctx.cr[6].lt {
	pc = 0x82EBC69C; continue 'dispatch;
	}
	// 82EBC700: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC704: 419A005C  beq cr6, 0x82ebc760
	if ctx.cr[6].eq {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC708: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC70C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC714: 4099004C  ble cr6, 0x82ebc760
	if !ctx.cr[6].gt {
	pc = 0x82EBC760; continue 'dispatch;
	}
	// 82EBC718: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBC71C; continue 'dispatch;
            }
            0x82EBC71C => {
    //   block [0x82EBC71C..0x82EBC750)
	// 82EBC71C: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC720: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC724: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC728: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC72C: 4BDF0425  bl 0x82cacb50
	ctx.lr = 0x82EBC730;
	sub_82CACB50(ctx, base);
	// 82EBC730: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC734: 4182001C  beq 0x82ebc750
	if ctx.cr[0].eq {
	pc = 0x82EBC750; continue 'dispatch;
	}
	// 82EBC738: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC73C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC740: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC744: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC748: 4198FFD4  blt cr6, 0x82ebc71c
	if ctx.cr[6].lt {
	pc = 0x82EBC71C; continue 'dispatch;
	}
	// 82EBC74C: 48000014  b 0x82ebc760
	pc = 0x82EBC760; continue 'dispatch;
            }
            0x82EBC750 => {
    //   block [0x82EBC750..0x82EBC760)
	// 82EBC750: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC754: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBC758: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC75C: 917A01B0  stw r11, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBC760; continue 'dispatch;
            }
            0x82EBC760 => {
    //   block [0x82EBC760..0x82EBC788)
	// 82EBC760: 817A01B0  lwz r11, 0x1b0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EBC764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC768: 409AF8E4  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC76C: 817A01AC  lwz r11, 0x1ac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(428 as u32) ) } as u64;
	// 82EBC770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC774: 419AF8D8  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC778: 817A01A4  lwz r11, 0x1a4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(420 as u32) ) } as u64;
	// 82EBC77C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC780: 917A01B0  stw r11, 0x1b0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82EBC784: 4BFFF8C8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC788 => {
    //   block [0x82EBC788..0x82EBC7D0)
	// 82EBC788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC790: 3BCBAB98  addi r30, r11, -0x5468
	ctx.r[30].s64 = ctx.r[11].s64 + -21608;
	// 82EBC794: 482FF8CD  bl 0x831bc060
	ctx.lr = 0x82EBC798;
	sub_831BC060(ctx, base);
	// 82EBC798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC79C: 4BDF03B5  bl 0x82cacb50
	ctx.lr = 0x82EBC7A0;
	sub_82CACB50(ctx, base);
	// 82EBC7A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC7A4: 40820118  bne 0x82ebc8bc
	if !ctx.cr[0].eq {
	pc = 0x82EBC8BC; continue 'dispatch;
	}
	// 82EBC7A8: 387A01B4  addi r3, r26, 0x1b4
	ctx.r[3].s64 = ctx.r[26].s64 + 436;
	// 82EBC7AC: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC7B0: 4BFFCA29  bl 0x82eb91d8
	ctx.lr = 0x82EBC7B4;
	sub_82EB91D8(ctx, base);
	// 82EBC7B4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC7B8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC7BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC7C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC7C4: 409900D0  ble cr6, 0x82ebc894
	if !ctx.cr[6].gt {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC7CC: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBC7D0; continue 'dispatch;
            }
            0x82EBC7D0 => {
    //   block [0x82EBC7D0..0x82EBC804)
	// 82EBC7D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC7D8: 4BFC7851  bl 0x82e84028
	ctx.lr = 0x82EBC7DC;
	sub_82E84028(ctx, base);
	// 82EBC7DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC7E0: 482FF881  bl 0x831bc060
	ctx.lr = 0x82EBC7E4;
	sub_831BC060(ctx, base);
	// 82EBC7E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC7E8: 4BDF0369  bl 0x82cacb50
	ctx.lr = 0x82EBC7EC;
	sub_82CACB50(ctx, base);
	// 82EBC7EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC7F0: 40820014  bne 0x82ebc804
	if !ctx.cr[0].eq {
	pc = 0x82EBC804; continue 'dispatch;
	}
	// 82EBC7F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC7F8: 4BA51511  bl 0x8290dd08
	ctx.lr = 0x82EBC7FC;
	sub_8290DD08(ctx, base);
	// 82EBC7FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC800: 48000024  b 0x82ebc824
	pc = 0x82EBC824; continue 'dispatch;
            }
            0x82EBC804 => {
    //   block [0x82EBC804..0x82EBC824)
	// 82EBC804: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC80C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC810: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC818: 4E800421  bctrl
	ctx.lr = 0x82EBC81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC81C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC820: 4182F9B0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBC824 => {
    //   block [0x82EBC824..0x82EBC850)
	// 82EBC824: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC828: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC82C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC830: 4198FFA0  blt cr6, 0x82ebc7d0
	if ctx.cr[6].lt {
	pc = 0x82EBC7D0; continue 'dispatch;
	}
	// 82EBC834: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC838: 419A005C  beq cr6, 0x82ebc894
	if ctx.cr[6].eq {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC83C: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC840: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC848: 4099004C  ble cr6, 0x82ebc894
	if !ctx.cr[6].gt {
	pc = 0x82EBC894; continue 'dispatch;
	}
	// 82EBC84C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBC850; continue 'dispatch;
            }
            0x82EBC850 => {
    //   block [0x82EBC850..0x82EBC884)
	// 82EBC850: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC854: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC858: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBC85C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC860: 4BDF02F1  bl 0x82cacb50
	ctx.lr = 0x82EBC864;
	sub_82CACB50(ctx, base);
	// 82EBC864: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC868: 4182001C  beq 0x82ebc884
	if ctx.cr[0].eq {
	pc = 0x82EBC884; continue 'dispatch;
	}
	// 82EBC86C: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC870: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC874: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC878: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC87C: 4198FFD4  blt cr6, 0x82ebc850
	if ctx.cr[6].lt {
	pc = 0x82EBC850; continue 'dispatch;
	}
	// 82EBC880: 48000014  b 0x82ebc894
	pc = 0x82EBC894; continue 'dispatch;
            }
            0x82EBC884 => {
    //   block [0x82EBC884..0x82EBC894)
	// 82EBC884: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC888: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBC88C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC890: 917A01C4  stw r11, 0x1c4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBC894; continue 'dispatch;
            }
            0x82EBC894 => {
    //   block [0x82EBC894..0x82EBC8BC)
	// 82EBC894: 817A01C4  lwz r11, 0x1c4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EBC898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC89C: 409AF7B0  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC8A0: 817A01C0  lwz r11, 0x1c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(448 as u32) ) } as u64;
	// 82EBC8A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC8A8: 419AF7A4  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC8AC: 817A01B8  lwz r11, 0x1b8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBC8B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC8B4: 917A01C4  stw r11, 0x1c4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(452 as u32), ctx.r[11].u32 ) };
	// 82EBC8B8: 4BFFF794  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC8BC => {
    //   block [0x82EBC8BC..0x82EBC904)
	// 82EBC8BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC8C4: 3BCBAB78  addi r30, r11, -0x5488
	ctx.r[30].s64 = ctx.r[11].s64 + -21640;
	// 82EBC8C8: 482FF799  bl 0x831bc060
	ctx.lr = 0x82EBC8CC;
	sub_831BC060(ctx, base);
	// 82EBC8CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC8D0: 4BDF0281  bl 0x82cacb50
	ctx.lr = 0x82EBC8D4;
	sub_82CACB50(ctx, base);
	// 82EBC8D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC8D8: 40820118  bne 0x82ebc9f0
	if !ctx.cr[0].eq {
	pc = 0x82EBC9F0; continue 'dispatch;
	}
	// 82EBC8DC: 387A01C8  addi r3, r26, 0x1c8
	ctx.r[3].s64 = ctx.r[26].s64 + 456;
	// 82EBC8E0: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC8E4: 4BFFC8F5  bl 0x82eb91d8
	ctx.lr = 0x82EBC8E8;
	sub_82EB91D8(ctx, base);
	// 82EBC8E8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC8EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBC8F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBC8F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC8F8: 409900D0  ble cr6, 0x82ebc9c8
	if !ctx.cr[6].gt {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC8FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC900: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBC904; continue 'dispatch;
            }
            0x82EBC904 => {
    //   block [0x82EBC904..0x82EBC938)
	// 82EBC904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBC908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC90C: 4BFC771D  bl 0x82e84028
	ctx.lr = 0x82EBC910;
	sub_82E84028(ctx, base);
	// 82EBC910: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBC914: 482FF74D  bl 0x831bc060
	ctx.lr = 0x82EBC918;
	sub_831BC060(ctx, base);
	// 82EBC918: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBC91C: 4BDF0235  bl 0x82cacb50
	ctx.lr = 0x82EBC920;
	sub_82CACB50(ctx, base);
	// 82EBC920: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC924: 40820014  bne 0x82ebc938
	if !ctx.cr[0].eq {
	pc = 0x82EBC938; continue 'dispatch;
	}
	// 82EBC928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBC92C: 4BA513DD  bl 0x8290dd08
	ctx.lr = 0x82EBC930;
	sub_8290DD08(ctx, base);
	// 82EBC930: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBC934: 48000024  b 0x82ebc958
	pc = 0x82EBC958; continue 'dispatch;
            }
            0x82EBC938 => {
    //   block [0x82EBC938..0x82EBC958)
	// 82EBC938: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC93C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBC940: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBC944: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBC94C: 4E800421  bctrl
	ctx.lr = 0x82EBC950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBC950: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBC954: 4182F87C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBC958 => {
    //   block [0x82EBC958..0x82EBC984)
	// 82EBC958: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBC95C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBC960: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC964: 4198FFA0  blt cr6, 0x82ebc904
	if ctx.cr[6].lt {
	pc = 0x82EBC904; continue 'dispatch;
	}
	// 82EBC968: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBC96C: 419A005C  beq cr6, 0x82ebc9c8
	if ctx.cr[6].eq {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC970: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC974: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBC978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC97C: 4099004C  ble cr6, 0x82ebc9c8
	if !ctx.cr[6].gt {
	pc = 0x82EBC9C8; continue 'dispatch;
	}
	// 82EBC980: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBC984; continue 'dispatch;
            }
            0x82EBC984 => {
    //   block [0x82EBC984..0x82EBC9B8)
	// 82EBC984: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC988: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBC98C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC990: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBC994: 4BDF01BD  bl 0x82cacb50
	ctx.lr = 0x82EBC998;
	sub_82CACB50(ctx, base);
	// 82EBC998: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBC99C: 4182001C  beq 0x82ebc9b8
	if ctx.cr[0].eq {
	pc = 0x82EBC9B8; continue 'dispatch;
	}
	// 82EBC9A0: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC9A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBC9A8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBC9AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBC9B0: 4198FFD4  blt cr6, 0x82ebc984
	if ctx.cr[6].lt {
	pc = 0x82EBC984; continue 'dispatch;
	}
	// 82EBC9B4: 48000014  b 0x82ebc9c8
	pc = 0x82EBC9C8; continue 'dispatch;
            }
            0x82EBC9B8 => {
    //   block [0x82EBC9B8..0x82EBC9C8)
	// 82EBC9B8: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC9BC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBC9C0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBC9C4: 917A01D8  stw r11, 0x1d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBC9C8; continue 'dispatch;
            }
            0x82EBC9C8 => {
    //   block [0x82EBC9C8..0x82EBC9F0)
	// 82EBC9C8: 817A01D8  lwz r11, 0x1d8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EBC9CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC9D0: 409AF67C  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC9D4: 817A01D4  lwz r11, 0x1d4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EBC9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBC9DC: 419AF670  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBC9E0: 817A01CC  lwz r11, 0x1cc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(460 as u32) ) } as u64;
	// 82EBC9E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBC9E8: 917A01D8  stw r11, 0x1d8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EBC9EC: 4BFFF660  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBC9F0 => {
    //   block [0x82EBC9F0..0x82EBCA38)
	// 82EBC9F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBC9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBC9F8: 3BCBAB64  addi r30, r11, -0x549c
	ctx.r[30].s64 = ctx.r[11].s64 + -21660;
	// 82EBC9FC: 482FF665  bl 0x831bc060
	ctx.lr = 0x82EBCA00;
	sub_831BC060(ctx, base);
	// 82EBCA00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCA04: 4BDF014D  bl 0x82cacb50
	ctx.lr = 0x82EBCA08;
	sub_82CACB50(ctx, base);
	// 82EBCA08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCA0C: 40820118  bne 0x82ebcb24
	if !ctx.cr[0].eq {
	pc = 0x82EBCB24; continue 'dispatch;
	}
	// 82EBCA10: 387A0218  addi r3, r26, 0x218
	ctx.r[3].s64 = ctx.r[26].s64 + 536;
	// 82EBCA14: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA18: 4BFFC7C1  bl 0x82eb91d8
	ctx.lr = 0x82EBCA1C;
	sub_82EB91D8(ctx, base);
	// 82EBCA1C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA20: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCA24: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCA2C: 409900D0  ble cr6, 0x82ebcafc
	if !ctx.cr[6].gt {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCA30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCA34: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBCA38; continue 'dispatch;
            }
            0x82EBCA38 => {
    //   block [0x82EBCA38..0x82EBCA6C)
	// 82EBCA38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCA40: 4BFC75E9  bl 0x82e84028
	ctx.lr = 0x82EBCA44;
	sub_82E84028(ctx, base);
	// 82EBCA44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCA48: 482FF619  bl 0x831bc060
	ctx.lr = 0x82EBCA4C;
	sub_831BC060(ctx, base);
	// 82EBCA4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCA50: 4BDF0101  bl 0x82cacb50
	ctx.lr = 0x82EBCA54;
	sub_82CACB50(ctx, base);
	// 82EBCA54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCA58: 40820014  bne 0x82ebca6c
	if !ctx.cr[0].eq {
	pc = 0x82EBCA6C; continue 'dispatch;
	}
	// 82EBCA5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCA60: 4BA512A9  bl 0x8290dd08
	ctx.lr = 0x82EBCA64;
	sub_8290DD08(ctx, base);
	// 82EBCA64: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCA68: 48000024  b 0x82ebca8c
	pc = 0x82EBCA8C; continue 'dispatch;
            }
            0x82EBCA6C => {
    //   block [0x82EBCA6C..0x82EBCA8C)
	// 82EBCA6C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCA70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCA74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCA7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCA80: 4E800421  bctrl
	ctx.lr = 0x82EBCA84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCA84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCA88: 4182F748  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBCA8C => {
    //   block [0x82EBCA8C..0x82EBCAB8)
	// 82EBCA8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCA90: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCA94: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCA98: 4198FFA0  blt cr6, 0x82ebca38
	if ctx.cr[6].lt {
	pc = 0x82EBCA38; continue 'dispatch;
	}
	// 82EBCA9C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCAA0: 419A005C  beq cr6, 0x82ebcafc
	if ctx.cr[6].eq {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCAA4: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCAA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCAB0: 4099004C  ble cr6, 0x82ebcafc
	if !ctx.cr[6].gt {
	pc = 0x82EBCAFC; continue 'dispatch;
	}
	// 82EBCAB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBCAB8; continue 'dispatch;
            }
            0x82EBCAB8 => {
    //   block [0x82EBCAB8..0x82EBCAEC)
	// 82EBCAB8: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCABC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCAC0: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCAC4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCAC8: 4BDF0089  bl 0x82cacb50
	ctx.lr = 0x82EBCACC;
	sub_82CACB50(ctx, base);
	// 82EBCACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCAD0: 4182001C  beq 0x82ebcaec
	if ctx.cr[0].eq {
	pc = 0x82EBCAEC; continue 'dispatch;
	}
	// 82EBCAD4: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCAD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCADC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCAE0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCAE4: 4198FFD4  blt cr6, 0x82ebcab8
	if ctx.cr[6].lt {
	pc = 0x82EBCAB8; continue 'dispatch;
	}
	// 82EBCAE8: 48000014  b 0x82ebcafc
	pc = 0x82EBCAFC; continue 'dispatch;
            }
            0x82EBCAEC => {
    //   block [0x82EBCAEC..0x82EBCAFC)
	// 82EBCAEC: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCAF0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCAF4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCAF8: 917A0228  stw r11, 0x228(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBCAFC; continue 'dispatch;
            }
            0x82EBCAFC => {
    //   block [0x82EBCAFC..0x82EBCB24)
	// 82EBCAFC: 817A0228  lwz r11, 0x228(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EBCB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB04: 409AF548  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCB08: 817A0224  lwz r11, 0x224(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EBCB0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB10: 419AF53C  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCB14: 817A021C  lwz r11, 0x21c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EBCB18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCB1C: 917A0228  stw r11, 0x228(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82EBCB20: 4BFFF52C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBCB24 => {
    //   block [0x82EBCB24..0x82EBCB6C)
	// 82EBCB24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCB2C: 3BCBAB48  addi r30, r11, -0x54b8
	ctx.r[30].s64 = ctx.r[11].s64 + -21688;
	// 82EBCB30: 482FF531  bl 0x831bc060
	ctx.lr = 0x82EBCB34;
	sub_831BC060(ctx, base);
	// 82EBCB34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCB38: 4BDF0019  bl 0x82cacb50
	ctx.lr = 0x82EBCB3C;
	sub_82CACB50(ctx, base);
	// 82EBCB3C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCB40: 40820118  bne 0x82ebcc58
	if !ctx.cr[0].eq {
	pc = 0x82EBCC58; continue 'dispatch;
	}
	// 82EBCB44: 387A01DC  addi r3, r26, 0x1dc
	ctx.r[3].s64 = ctx.r[26].s64 + 476;
	// 82EBCB48: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCB4C: 4BFFC68D  bl 0x82eb91d8
	ctx.lr = 0x82EBCB50;
	sub_82EB91D8(ctx, base);
	// 82EBCB50: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCB54: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCB58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCB5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCB60: 409900D0  ble cr6, 0x82ebcc30
	if !ctx.cr[6].gt {
	pc = 0x82EBCC30; continue 'dispatch;
	}
	// 82EBCB64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCB68: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBCB6C; continue 'dispatch;
            }
            0x82EBCB6C => {
    //   block [0x82EBCB6C..0x82EBCBA0)
	// 82EBCB6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCB74: 4BFC74B5  bl 0x82e84028
	ctx.lr = 0x82EBCB78;
	sub_82E84028(ctx, base);
	// 82EBCB78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCB7C: 482FF4E5  bl 0x831bc060
	ctx.lr = 0x82EBCB80;
	sub_831BC060(ctx, base);
	// 82EBCB80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCB84: 4BDEFFCD  bl 0x82cacb50
	ctx.lr = 0x82EBCB88;
	sub_82CACB50(ctx, base);
	// 82EBCB88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCB8C: 40820014  bne 0x82ebcba0
	if !ctx.cr[0].eq {
	pc = 0x82EBCBA0; continue 'dispatch;
	}
	// 82EBCB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCB94: 4BA51175  bl 0x8290dd08
	ctx.lr = 0x82EBCB98;
	sub_8290DD08(ctx, base);
	// 82EBCB98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCB9C: 48000024  b 0x82ebcbc0
	pc = 0x82EBCBC0; continue 'dispatch;
            }
            0x82EBCBA0 => {
    //   block [0x82EBCBA0..0x82EBCBC0)
	// 82EBCBA0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCBA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCBA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCBAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCBB4: 4E800421  bctrl
	ctx.lr = 0x82EBCBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCBB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCBBC: 4182F614  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBCBC0 => {
    //   block [0x82EBCBC0..0x82EBCBEC)
	// 82EBCBC0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCBC4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCBC8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCBCC: 4198FFA0  blt cr6, 0x82ebcb6c
	if ctx.cr[6].lt {
	pc = 0x82EBCB6C; continue 'dispatch;
	}
	// 82EBCBD0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCBD4: 419A005C  beq cr6, 0x82ebcc30
	if ctx.cr[6].eq {
	pc = 0x82EBCC30; continue 'dispatch;
	}
	// 82EBCBD8: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCBDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCBE4: 4099004C  ble cr6, 0x82ebcc30
	if !ctx.cr[6].gt {
	pc = 0x82EBCC30; continue 'dispatch;
	}
	// 82EBCBE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBCBEC; continue 'dispatch;
            }
            0x82EBCBEC => {
    //   block [0x82EBCBEC..0x82EBCC20)
	// 82EBCBEC: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCBF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCBF4: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCBF8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCBFC: 4BDEFF55  bl 0x82cacb50
	ctx.lr = 0x82EBCC00;
	sub_82CACB50(ctx, base);
	// 82EBCC00: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCC04: 4182001C  beq 0x82ebcc20
	if ctx.cr[0].eq {
	pc = 0x82EBCC20; continue 'dispatch;
	}
	// 82EBCC08: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCC0C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCC10: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCC14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCC18: 4198FFD4  blt cr6, 0x82ebcbec
	if ctx.cr[6].lt {
	pc = 0x82EBCBEC; continue 'dispatch;
	}
	// 82EBCC1C: 48000014  b 0x82ebcc30
	pc = 0x82EBCC30; continue 'dispatch;
            }
            0x82EBCC20 => {
    //   block [0x82EBCC20..0x82EBCC30)
	// 82EBCC20: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCC24: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCC28: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCC2C: 917A01EC  stw r11, 0x1ec(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBCC30; continue 'dispatch;
            }
            0x82EBCC30 => {
    //   block [0x82EBCC30..0x82EBCC58)
	// 82EBCC30: 817A01EC  lwz r11, 0x1ec(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EBCC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCC38: 409AF414  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCC3C: 817A01E8  lwz r11, 0x1e8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EBCC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCC44: 419AF408  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCC48: 817A01E0  lwz r11, 0x1e0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EBCC4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCC50: 917A01EC  stw r11, 0x1ec(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82EBCC54: 4BFFF3F8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBCC58 => {
    //   block [0x82EBCC58..0x82EBCCA0)
	// 82EBCC58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCC60: 3BCBAB24  addi r30, r11, -0x54dc
	ctx.r[30].s64 = ctx.r[11].s64 + -21724;
	// 82EBCC64: 482FF3FD  bl 0x831bc060
	ctx.lr = 0x82EBCC68;
	sub_831BC060(ctx, base);
	// 82EBCC68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCC6C: 4BDEFEE5  bl 0x82cacb50
	ctx.lr = 0x82EBCC70;
	sub_82CACB50(ctx, base);
	// 82EBCC70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCC74: 40820118  bne 0x82ebcd8c
	if !ctx.cr[0].eq {
	pc = 0x82EBCD8C; continue 'dispatch;
	}
	// 82EBCC78: 387A01F0  addi r3, r26, 0x1f0
	ctx.r[3].s64 = ctx.r[26].s64 + 496;
	// 82EBCC7C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCC80: 4BFFC559  bl 0x82eb91d8
	ctx.lr = 0x82EBCC84;
	sub_82EB91D8(ctx, base);
	// 82EBCC84: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCC88: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCC8C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCC94: 409900D0  ble cr6, 0x82ebcd64
	if !ctx.cr[6].gt {
	pc = 0x82EBCD64; continue 'dispatch;
	}
	// 82EBCC98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCC9C: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBCCA0; continue 'dispatch;
            }
            0x82EBCCA0 => {
    //   block [0x82EBCCA0..0x82EBCCD4)
	// 82EBCCA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCCA8: 4BFC7381  bl 0x82e84028
	ctx.lr = 0x82EBCCAC;
	sub_82E84028(ctx, base);
	// 82EBCCAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCCB0: 482FF3B1  bl 0x831bc060
	ctx.lr = 0x82EBCCB4;
	sub_831BC060(ctx, base);
	// 82EBCCB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCCB8: 4BDEFE99  bl 0x82cacb50
	ctx.lr = 0x82EBCCBC;
	sub_82CACB50(ctx, base);
	// 82EBCCBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCCC0: 40820014  bne 0x82ebccd4
	if !ctx.cr[0].eq {
	pc = 0x82EBCCD4; continue 'dispatch;
	}
	// 82EBCCC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCCC8: 4BA51041  bl 0x8290dd08
	ctx.lr = 0x82EBCCCC;
	sub_8290DD08(ctx, base);
	// 82EBCCCC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCCD0: 48000024  b 0x82ebccf4
	pc = 0x82EBCCF4; continue 'dispatch;
            }
            0x82EBCCD4 => {
    //   block [0x82EBCCD4..0x82EBCCF4)
	// 82EBCCD4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCCD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCCDC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCCE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCCE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCCE8: 4E800421  bctrl
	ctx.lr = 0x82EBCCEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCCEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCCF0: 4182F4E0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBCCF4 => {
    //   block [0x82EBCCF4..0x82EBCD20)
	// 82EBCCF4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCCF8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCCFC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCD00: 4198FFA0  blt cr6, 0x82ebcca0
	if ctx.cr[6].lt {
	pc = 0x82EBCCA0; continue 'dispatch;
	}
	// 82EBCD04: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD08: 419A005C  beq cr6, 0x82ebcd64
	if ctx.cr[6].eq {
	pc = 0x82EBCD64; continue 'dispatch;
	}
	// 82EBCD0C: 817A01FC  lwz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBCD10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD18: 4099004C  ble cr6, 0x82ebcd64
	if !ctx.cr[6].gt {
	pc = 0x82EBCD64; continue 'dispatch;
	}
	// 82EBCD1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBCD20; continue 'dispatch;
            }
            0x82EBCD20 => {
    //   block [0x82EBCD20..0x82EBCD54)
	// 82EBCD20: 817A01F4  lwz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBCD24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCD28: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCD2C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCD30: 4BDEFE21  bl 0x82cacb50
	ctx.lr = 0x82EBCD34;
	sub_82CACB50(ctx, base);
	// 82EBCD34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCD38: 4182001C  beq 0x82ebcd54
	if ctx.cr[0].eq {
	pc = 0x82EBCD54; continue 'dispatch;
	}
	// 82EBCD3C: 817A01FC  lwz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBCD40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCD44: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCD48: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCD4C: 4198FFD4  blt cr6, 0x82ebcd20
	if ctx.cr[6].lt {
	pc = 0x82EBCD20; continue 'dispatch;
	}
	// 82EBCD50: 48000014  b 0x82ebcd64
	pc = 0x82EBCD64; continue 'dispatch;
            }
            0x82EBCD54 => {
    //   block [0x82EBCD54..0x82EBCD64)
	// 82EBCD54: 817A01F4  lwz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBCD58: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCD5C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCD60: 917A0200  stw r11, 0x200(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBCD64; continue 'dispatch;
            }
            0x82EBCD64 => {
    //   block [0x82EBCD64..0x82EBCD8C)
	// 82EBCD64: 817A0200  lwz r11, 0x200(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EBCD68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD6C: 409AF2E0  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCD70: 817A01FC  lwz r11, 0x1fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(508 as u32) ) } as u64;
	// 82EBCD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCD78: 419AF2D4  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCD7C: 817A01F4  lwz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 82EBCD80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCD84: 917A0200  stw r11, 0x200(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82EBCD88: 4BFFF2C4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBCD8C => {
    //   block [0x82EBCD8C..0x82EBCDD4)
	// 82EBCD8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCD94: 3BCBAB00  addi r30, r11, -0x5500
	ctx.r[30].s64 = ctx.r[11].s64 + -21760;
	// 82EBCD98: 482FF2C9  bl 0x831bc060
	ctx.lr = 0x82EBCD9C;
	sub_831BC060(ctx, base);
	// 82EBCD9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCDA0: 4BDEFDB1  bl 0x82cacb50
	ctx.lr = 0x82EBCDA4;
	sub_82CACB50(ctx, base);
	// 82EBCDA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCDA8: 40820118  bne 0x82ebcec0
	if !ctx.cr[0].eq {
	pc = 0x82EBCEC0; continue 'dispatch;
	}
	// 82EBCDAC: 387A0204  addi r3, r26, 0x204
	ctx.r[3].s64 = ctx.r[26].s64 + 516;
	// 82EBCDB0: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCDB4: 4BFFC425  bl 0x82eb91d8
	ctx.lr = 0x82EBCDB8;
	sub_82EB91D8(ctx, base);
	// 82EBCDB8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCDBC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCDC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCDC8: 409900D0  ble cr6, 0x82ebce98
	if !ctx.cr[6].gt {
	pc = 0x82EBCE98; continue 'dispatch;
	}
	// 82EBCDCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCDD0: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBCDD4; continue 'dispatch;
            }
            0x82EBCDD4 => {
    //   block [0x82EBCDD4..0x82EBCE08)
	// 82EBCDD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCDDC: 4BFC724D  bl 0x82e84028
	ctx.lr = 0x82EBCDE0;
	sub_82E84028(ctx, base);
	// 82EBCDE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCDE4: 482FF27D  bl 0x831bc060
	ctx.lr = 0x82EBCDE8;
	sub_831BC060(ctx, base);
	// 82EBCDE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCDEC: 4BDEFD65  bl 0x82cacb50
	ctx.lr = 0x82EBCDF0;
	sub_82CACB50(ctx, base);
	// 82EBCDF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCDF4: 40820014  bne 0x82ebce08
	if !ctx.cr[0].eq {
	pc = 0x82EBCE08; continue 'dispatch;
	}
	// 82EBCDF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCDFC: 4BA50F0D  bl 0x8290dd08
	ctx.lr = 0x82EBCE00;
	sub_8290DD08(ctx, base);
	// 82EBCE00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCE04: 48000024  b 0x82ebce28
	pc = 0x82EBCE28; continue 'dispatch;
            }
            0x82EBCE08 => {
    //   block [0x82EBCE08..0x82EBCE28)
	// 82EBCE08: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCE0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCE10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCE14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCE18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCE1C: 4E800421  bctrl
	ctx.lr = 0x82EBCE20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCE20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCE24: 4182F3AC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBCE28 => {
    //   block [0x82EBCE28..0x82EBCE54)
	// 82EBCE28: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCE2C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCE30: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCE34: 4198FFA0  blt cr6, 0x82ebcdd4
	if ctx.cr[6].lt {
	pc = 0x82EBCDD4; continue 'dispatch;
	}
	// 82EBCE38: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCE3C: 419A005C  beq cr6, 0x82ebce98
	if ctx.cr[6].eq {
	pc = 0x82EBCE98; continue 'dispatch;
	}
	// 82EBCE40: 817A0210  lwz r11, 0x210(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBCE44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCE4C: 4099004C  ble cr6, 0x82ebce98
	if !ctx.cr[6].gt {
	pc = 0x82EBCE98; continue 'dispatch;
	}
	// 82EBCE50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBCE54; continue 'dispatch;
            }
            0x82EBCE54 => {
    //   block [0x82EBCE54..0x82EBCE88)
	// 82EBCE54: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBCE58: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCE5C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCE60: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCE64: 4BDEFCED  bl 0x82cacb50
	ctx.lr = 0x82EBCE68;
	sub_82CACB50(ctx, base);
	// 82EBCE68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCE6C: 4182001C  beq 0x82ebce88
	if ctx.cr[0].eq {
	pc = 0x82EBCE88; continue 'dispatch;
	}
	// 82EBCE70: 817A0210  lwz r11, 0x210(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBCE74: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCE78: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCE7C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCE80: 4198FFD4  blt cr6, 0x82ebce54
	if ctx.cr[6].lt {
	pc = 0x82EBCE54; continue 'dispatch;
	}
	// 82EBCE84: 48000014  b 0x82ebce98
	pc = 0x82EBCE98; continue 'dispatch;
            }
            0x82EBCE88 => {
    //   block [0x82EBCE88..0x82EBCE98)
	// 82EBCE88: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBCE8C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCE90: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCE94: 917A0214  stw r11, 0x214(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBCE98; continue 'dispatch;
            }
            0x82EBCE98 => {
    //   block [0x82EBCE98..0x82EBCEC0)
	// 82EBCE98: 817A0214  lwz r11, 0x214(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EBCE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCEA0: 409AF1AC  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCEA4: 817A0210  lwz r11, 0x210(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(528 as u32) ) } as u64;
	// 82EBCEA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCEAC: 419AF1A0  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCEB0: 817A0208  lwz r11, 0x208(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(520 as u32) ) } as u64;
	// 82EBCEB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCEB8: 917A0214  stw r11, 0x214(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 82EBCEBC: 4BFFF190  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBCEC0 => {
    //   block [0x82EBCEC0..0x82EBCF08)
	// 82EBCEC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCEC8: 3BCBAAE0  addi r30, r11, -0x5520
	ctx.r[30].s64 = ctx.r[11].s64 + -21792;
	// 82EBCECC: 482FF195  bl 0x831bc060
	ctx.lr = 0x82EBCED0;
	sub_831BC060(ctx, base);
	// 82EBCED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCED4: 4BDEFC7D  bl 0x82cacb50
	ctx.lr = 0x82EBCED8;
	sub_82CACB50(ctx, base);
	// 82EBCED8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCEDC: 40820118  bne 0x82ebcff4
	if !ctx.cr[0].eq {
	pc = 0x82EBCFF4; continue 'dispatch;
	}
	// 82EBCEE0: 387A022C  addi r3, r26, 0x22c
	ctx.r[3].s64 = ctx.r[26].s64 + 556;
	// 82EBCEE4: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCEE8: 4BFFC2F1  bl 0x82eb91d8
	ctx.lr = 0x82EBCEEC;
	sub_82EB91D8(ctx, base);
	// 82EBCEEC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCEF0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBCEF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBCEF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCEFC: 409900D0  ble cr6, 0x82ebcfcc
	if !ctx.cr[6].gt {
	pc = 0x82EBCFCC; continue 'dispatch;
	}
	// 82EBCF00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCF04: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBCF08; continue 'dispatch;
            }
            0x82EBCF08 => {
    //   block [0x82EBCF08..0x82EBCF3C)
	// 82EBCF08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBCF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCF10: 4BFC7119  bl 0x82e84028
	ctx.lr = 0x82EBCF14;
	sub_82E84028(ctx, base);
	// 82EBCF14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBCF18: 482FF149  bl 0x831bc060
	ctx.lr = 0x82EBCF1C;
	sub_831BC060(ctx, base);
	// 82EBCF1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBCF20: 4BDEFC31  bl 0x82cacb50
	ctx.lr = 0x82EBCF24;
	sub_82CACB50(ctx, base);
	// 82EBCF24: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCF28: 40820014  bne 0x82ebcf3c
	if !ctx.cr[0].eq {
	pc = 0x82EBCF3C; continue 'dispatch;
	}
	// 82EBCF2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBCF30: 4BA50DD9  bl 0x8290dd08
	ctx.lr = 0x82EBCF34;
	sub_8290DD08(ctx, base);
	// 82EBCF34: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBCF38: 48000024  b 0x82ebcf5c
	pc = 0x82EBCF5C; continue 'dispatch;
            }
            0x82EBCF3C => {
    //   block [0x82EBCF3C..0x82EBCF5C)
	// 82EBCF3C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCF40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBCF44: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBCF48: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCF4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBCF50: 4E800421  bctrl
	ctx.lr = 0x82EBCF54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBCF54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBCF58: 4182F278  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBCF5C => {
    //   block [0x82EBCF5C..0x82EBCF88)
	// 82EBCF5C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBCF60: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBCF64: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCF68: 4198FFA0  blt cr6, 0x82ebcf08
	if ctx.cr[6].lt {
	pc = 0x82EBCF08; continue 'dispatch;
	}
	// 82EBCF6C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBCF70: 419A005C  beq cr6, 0x82ebcfcc
	if ctx.cr[6].eq {
	pc = 0x82EBCFCC; continue 'dispatch;
	}
	// 82EBCF74: 817A0238  lwz r11, 0x238(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBCF78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBCF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCF80: 4099004C  ble cr6, 0x82ebcfcc
	if !ctx.cr[6].gt {
	pc = 0x82EBCFCC; continue 'dispatch;
	}
	// 82EBCF84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBCF88; continue 'dispatch;
            }
            0x82EBCF88 => {
    //   block [0x82EBCF88..0x82EBCFBC)
	// 82EBCF88: 817A0230  lwz r11, 0x230(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBCF8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBCF90: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82EBCF94: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBCF98: 4BDEFBB9  bl 0x82cacb50
	ctx.lr = 0x82EBCF9C;
	sub_82CACB50(ctx, base);
	// 82EBCF9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBCFA0: 4182001C  beq 0x82ebcfbc
	if ctx.cr[0].eq {
	pc = 0x82EBCFBC; continue 'dispatch;
	}
	// 82EBCFA4: 817A0238  lwz r11, 0x238(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBCFA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBCFAC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBCFB0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBCFB4: 4198FFD4  blt cr6, 0x82ebcf88
	if ctx.cr[6].lt {
	pc = 0x82EBCF88; continue 'dispatch;
	}
	// 82EBCFB8: 48000014  b 0x82ebcfcc
	pc = 0x82EBCFCC; continue 'dispatch;
            }
            0x82EBCFBC => {
    //   block [0x82EBCFBC..0x82EBCFCC)
	// 82EBCFBC: 817A0230  lwz r11, 0x230(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBCFC0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBCFC4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBCFC8: 917A023C  stw r11, 0x23c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBCFCC; continue 'dispatch;
            }
            0x82EBCFCC => {
    //   block [0x82EBCFCC..0x82EBCFF4)
	// 82EBCFCC: 817A023C  lwz r11, 0x23c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EBCFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCFD4: 409AF078  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCFD8: 817A0238  lwz r11, 0x238(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(568 as u32) ) } as u64;
	// 82EBCFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBCFE0: 419AF06C  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBCFE4: 817A0230  lwz r11, 0x230(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(560 as u32) ) } as u64;
	// 82EBCFE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBCFEC: 917A023C  stw r11, 0x23c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 82EBCFF0: 4BFFF05C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBCFF4 => {
    //   block [0x82EBCFF4..0x82EBD03C)
	// 82EBCFF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBCFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBCFFC: 3BCBAAD0  addi r30, r11, -0x5530
	ctx.r[30].s64 = ctx.r[11].s64 + -21808;
	// 82EBD000: 482FF061  bl 0x831bc060
	ctx.lr = 0x82EBD004;
	sub_831BC060(ctx, base);
	// 82EBD004: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD008: 4BDEFB49  bl 0x82cacb50
	ctx.lr = 0x82EBD00C;
	sub_82CACB50(ctx, base);
	// 82EBD00C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD010: 40820118  bne 0x82ebd128
	if !ctx.cr[0].eq {
	pc = 0x82EBD128; continue 'dispatch;
	}
	// 82EBD014: 387A0240  addi r3, r26, 0x240
	ctx.r[3].s64 = ctx.r[26].s64 + 576;
	// 82EBD018: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD01C: 4BFFC1BD  bl 0x82eb91d8
	ctx.lr = 0x82EBD020;
	sub_82EB91D8(ctx, base);
	// 82EBD020: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD024: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBD028: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBD02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD030: 409900D0  ble cr6, 0x82ebd100
	if !ctx.cr[6].gt {
	pc = 0x82EBD100; continue 'dispatch;
	}
	// 82EBD034: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD038: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBD03C; continue 'dispatch;
            }
            0x82EBD03C => {
    //   block [0x82EBD03C..0x82EBD070)
	// 82EBD03C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBD040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD044: 4BFC6FE5  bl 0x82e84028
	ctx.lr = 0x82EBD048;
	sub_82E84028(ctx, base);
	// 82EBD048: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBD04C: 482FF015  bl 0x831bc060
	ctx.lr = 0x82EBD050;
	sub_831BC060(ctx, base);
	// 82EBD050: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBD054: 4BDEFAFD  bl 0x82cacb50
	ctx.lr = 0x82EBD058;
	sub_82CACB50(ctx, base);
	// 82EBD058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD05C: 40820014  bne 0x82ebd070
	if !ctx.cr[0].eq {
	pc = 0x82EBD070; continue 'dispatch;
	}
	// 82EBD060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBD064: 4BA50CA5  bl 0x8290dd08
	ctx.lr = 0x82EBD068;
	sub_8290DD08(ctx, base);
	// 82EBD068: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBD06C: 48000024  b 0x82ebd090
	pc = 0x82EBD090; continue 'dispatch;
            }
            0x82EBD070 => {
    //   block [0x82EBD070..0x82EBD090)
	// 82EBD070: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD078: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD07C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD084: 4E800421  bctrl
	ctx.lr = 0x82EBD088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD088: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD08C: 4182F144  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBD090 => {
    //   block [0x82EBD090..0x82EBD0BC)
	// 82EBD090: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD094: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBD098: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD09C: 4198FFA0  blt cr6, 0x82ebd03c
	if ctx.cr[6].lt {
	pc = 0x82EBD03C; continue 'dispatch;
	}
	// 82EBD0A0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBD0A4: 419A005C  beq cr6, 0x82ebd100
	if ctx.cr[6].eq {
	pc = 0x82EBD100; continue 'dispatch;
	}
	// 82EBD0A8: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBD0AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBD0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD0B4: 4099004C  ble cr6, 0x82ebd100
	if !ctx.cr[6].gt {
	pc = 0x82EBD100; continue 'dispatch;
	}
	// 82EBD0B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBD0BC; continue 'dispatch;
            }
            0x82EBD0BC => {
    //   block [0x82EBD0BC..0x82EBD0F0)
	// 82EBD0BC: 817A0244  lwz r11, 0x244(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBD0C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBD0C4: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD0C8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD0CC: 4BDEFA85  bl 0x82cacb50
	ctx.lr = 0x82EBD0D0;
	sub_82CACB50(ctx, base);
	// 82EBD0D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD0D4: 4182001C  beq 0x82ebd0f0
	if ctx.cr[0].eq {
	pc = 0x82EBD0F0; continue 'dispatch;
	}
	// 82EBD0D8: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBD0DC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBD0E0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBD0E4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD0E8: 4198FFD4  blt cr6, 0x82ebd0bc
	if ctx.cr[6].lt {
	pc = 0x82EBD0BC; continue 'dispatch;
	}
	// 82EBD0EC: 48000014  b 0x82ebd100
	pc = 0x82EBD100; continue 'dispatch;
            }
            0x82EBD0F0 => {
    //   block [0x82EBD0F0..0x82EBD100)
	// 82EBD0F0: 817A0244  lwz r11, 0x244(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBD0F4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBD0F8: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD0FC: 917A0250  stw r11, 0x250(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBD100; continue 'dispatch;
            }
            0x82EBD100 => {
    //   block [0x82EBD100..0x82EBD128)
	// 82EBD100: 817A0250  lwz r11, 0x250(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBD104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD108: 409AEF44  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD10C: 817A024C  lwz r11, 0x24c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(588 as u32) ) } as u64;
	// 82EBD110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD114: 419AEF38  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD118: 817A0244  lwz r11, 0x244(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(580 as u32) ) } as u64;
	// 82EBD11C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD120: 917A0250  stw r11, 0x250(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 82EBD124: 4BFFEF28  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD128 => {
    //   block [0x82EBD128..0x82EBD170)
	// 82EBD128: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD12C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD130: 3BCBAABC  addi r30, r11, -0x5544
	ctx.r[30].s64 = ctx.r[11].s64 + -21828;
	// 82EBD134: 482FEF2D  bl 0x831bc060
	ctx.lr = 0x82EBD138;
	sub_831BC060(ctx, base);
	// 82EBD138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD13C: 4BDEFA15  bl 0x82cacb50
	ctx.lr = 0x82EBD140;
	sub_82CACB50(ctx, base);
	// 82EBD140: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD144: 40820118  bne 0x82ebd25c
	if !ctx.cr[0].eq {
	pc = 0x82EBD25C; continue 'dispatch;
	}
	// 82EBD148: 387A0254  addi r3, r26, 0x254
	ctx.r[3].s64 = ctx.r[26].s64 + 596;
	// 82EBD14C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD150: 4BFFC089  bl 0x82eb91d8
	ctx.lr = 0x82EBD154;
	sub_82EB91D8(ctx, base);
	// 82EBD154: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD158: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBD15C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBD160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD164: 409900D0  ble cr6, 0x82ebd234
	if !ctx.cr[6].gt {
	pc = 0x82EBD234; continue 'dispatch;
	}
	// 82EBD168: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD16C: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBD170; continue 'dispatch;
            }
            0x82EBD170 => {
    //   block [0x82EBD170..0x82EBD1A4)
	// 82EBD170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBD174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD178: 4BFC6EB1  bl 0x82e84028
	ctx.lr = 0x82EBD17C;
	sub_82E84028(ctx, base);
	// 82EBD17C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBD180: 482FEEE1  bl 0x831bc060
	ctx.lr = 0x82EBD184;
	sub_831BC060(ctx, base);
	// 82EBD184: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBD188: 4BDEF9C9  bl 0x82cacb50
	ctx.lr = 0x82EBD18C;
	sub_82CACB50(ctx, base);
	// 82EBD18C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD190: 40820014  bne 0x82ebd1a4
	if !ctx.cr[0].eq {
	pc = 0x82EBD1A4; continue 'dispatch;
	}
	// 82EBD194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBD198: 4BA50B71  bl 0x8290dd08
	ctx.lr = 0x82EBD19C;
	sub_8290DD08(ctx, base);
	// 82EBD19C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBD1A0: 48000024  b 0x82ebd1c4
	pc = 0x82EBD1C4; continue 'dispatch;
            }
            0x82EBD1A4 => {
    //   block [0x82EBD1A4..0x82EBD1C4)
	// 82EBD1A4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD1A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD1AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD1B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD1B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD1B8: 4E800421  bctrl
	ctx.lr = 0x82EBD1BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD1BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD1C0: 4182F010  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBD1C4 => {
    //   block [0x82EBD1C4..0x82EBD1F0)
	// 82EBD1C4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD1C8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBD1CC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD1D0: 4198FFA0  blt cr6, 0x82ebd170
	if ctx.cr[6].lt {
	pc = 0x82EBD170; continue 'dispatch;
	}
	// 82EBD1D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBD1D8: 419A005C  beq cr6, 0x82ebd234
	if ctx.cr[6].eq {
	pc = 0x82EBD234; continue 'dispatch;
	}
	// 82EBD1DC: 817A0260  lwz r11, 0x260(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBD1E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBD1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD1E8: 4099004C  ble cr6, 0x82ebd234
	if !ctx.cr[6].gt {
	pc = 0x82EBD234; continue 'dispatch;
	}
	// 82EBD1EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBD1F0; continue 'dispatch;
            }
            0x82EBD1F0 => {
    //   block [0x82EBD1F0..0x82EBD224)
	// 82EBD1F0: 817A0258  lwz r11, 0x258(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBD1F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBD1F8: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD1FC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD200: 4BDEF951  bl 0x82cacb50
	ctx.lr = 0x82EBD204;
	sub_82CACB50(ctx, base);
	// 82EBD204: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD208: 4182001C  beq 0x82ebd224
	if ctx.cr[0].eq {
	pc = 0x82EBD224; continue 'dispatch;
	}
	// 82EBD20C: 817A0260  lwz r11, 0x260(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBD210: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBD214: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBD218: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD21C: 4198FFD4  blt cr6, 0x82ebd1f0
	if ctx.cr[6].lt {
	pc = 0x82EBD1F0; continue 'dispatch;
	}
	// 82EBD220: 48000014  b 0x82ebd234
	pc = 0x82EBD234; continue 'dispatch;
            }
            0x82EBD224 => {
    //   block [0x82EBD224..0x82EBD234)
	// 82EBD224: 817A0258  lwz r11, 0x258(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBD228: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBD22C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD230: 917A0264  stw r11, 0x264(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBD234; continue 'dispatch;
            }
            0x82EBD234 => {
    //   block [0x82EBD234..0x82EBD25C)
	// 82EBD234: 817A0264  lwz r11, 0x264(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBD238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD23C: 409AEE10  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD240: 817A0260  lwz r11, 0x260(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EBD244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD248: 419AEE04  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD24C: 817A0258  lwz r11, 0x258(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EBD250: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD254: 917A0264  stw r11, 0x264(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 82EBD258: 4BFFEDF4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD25C => {
    //   block [0x82EBD25C..0x82EBD2A4)
	// 82EBD25C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD264: 3BCBAA98  addi r30, r11, -0x5568
	ctx.r[30].s64 = ctx.r[11].s64 + -21864;
	// 82EBD268: 482FEDF9  bl 0x831bc060
	ctx.lr = 0x82EBD26C;
	sub_831BC060(ctx, base);
	// 82EBD26C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD270: 4BDEF8E1  bl 0x82cacb50
	ctx.lr = 0x82EBD274;
	sub_82CACB50(ctx, base);
	// 82EBD274: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD278: 40820118  bne 0x82ebd390
	if !ctx.cr[0].eq {
	pc = 0x82EBD390; continue 'dispatch;
	}
	// 82EBD27C: 387A0268  addi r3, r26, 0x268
	ctx.r[3].s64 = ctx.r[26].s64 + 616;
	// 82EBD280: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD284: 4BFFBF55  bl 0x82eb91d8
	ctx.lr = 0x82EBD288;
	sub_82EB91D8(ctx, base);
	// 82EBD288: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD28C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EBD290: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EBD294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD298: 409900D0  ble cr6, 0x82ebd368
	if !ctx.cr[6].gt {
	pc = 0x82EBD368; continue 'dispatch;
	}
	// 82EBD29C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD2A0: 3B8BA98C  addi r28, r11, -0x5674
	ctx.r[28].s64 = ctx.r[11].s64 + -22132;
	pc = 0x82EBD2A4; continue 'dispatch;
            }
            0x82EBD2A4 => {
    //   block [0x82EBD2A4..0x82EBD2D8)
	// 82EBD2A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBD2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD2AC: 4BFC6D7D  bl 0x82e84028
	ctx.lr = 0x82EBD2B0;
	sub_82E84028(ctx, base);
	// 82EBD2B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBD2B4: 482FEDAD  bl 0x831bc060
	ctx.lr = 0x82EBD2B8;
	sub_831BC060(ctx, base);
	// 82EBD2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBD2BC: 4BDEF895  bl 0x82cacb50
	ctx.lr = 0x82EBD2C0;
	sub_82CACB50(ctx, base);
	// 82EBD2C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD2C4: 40820014  bne 0x82ebd2d8
	if !ctx.cr[0].eq {
	pc = 0x82EBD2D8; continue 'dispatch;
	}
	// 82EBD2C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBD2CC: 4BA50A3D  bl 0x8290dd08
	ctx.lr = 0x82EBD2D0;
	sub_8290DD08(ctx, base);
	// 82EBD2D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBD2D4: 48000024  b 0x82ebd2f8
	pc = 0x82EBD2F8; continue 'dispatch;
            }
            0x82EBD2D8 => {
    //   block [0x82EBD2D8..0x82EBD2F8)
	// 82EBD2D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD2DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD2E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD2E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD2E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD2EC: 4E800421  bctrl
	ctx.lr = 0x82EBD2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD2F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD2F4: 4182EEDC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
            }
            0x82EBD2F8 => {
    //   block [0x82EBD2F8..0x82EBD324)
	// 82EBD2F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EBD2FC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82EBD300: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD304: 4198FFA0  blt cr6, 0x82ebd2a4
	if ctx.cr[6].lt {
	pc = 0x82EBD2A4; continue 'dispatch;
	}
	// 82EBD308: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EBD30C: 419A005C  beq cr6, 0x82ebd368
	if ctx.cr[6].eq {
	pc = 0x82EBD368; continue 'dispatch;
	}
	// 82EBD310: 817A0274  lwz r11, 0x274(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBD314: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBD318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD31C: 4099004C  ble cr6, 0x82ebd368
	if !ctx.cr[6].gt {
	pc = 0x82EBD368; continue 'dispatch;
	}
	// 82EBD320: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82EBD324; continue 'dispatch;
            }
            0x82EBD324 => {
    //   block [0x82EBD324..0x82EBD358)
	// 82EBD324: 817A026C  lwz r11, 0x26c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBD328: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EBD32C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD330: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD334: 4BDEF81D  bl 0x82cacb50
	ctx.lr = 0x82EBD338;
	sub_82CACB50(ctx, base);
	// 82EBD338: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD33C: 4182001C  beq 0x82ebd358
	if ctx.cr[0].eq {
	pc = 0x82EBD358; continue 'dispatch;
	}
	// 82EBD340: 817A0274  lwz r11, 0x274(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBD344: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBD348: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82EBD34C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBD350: 4198FFD4  blt cr6, 0x82ebd324
	if ctx.cr[6].lt {
	pc = 0x82EBD324; continue 'dispatch;
	}
	// 82EBD354: 48000014  b 0x82ebd368
	pc = 0x82EBD368; continue 'dispatch;
            }
            0x82EBD358 => {
    //   block [0x82EBD358..0x82EBD368)
	// 82EBD358: 817A026C  lwz r11, 0x26c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBD35C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EBD360: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EBD364: 917A0278  stw r11, 0x278(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBD368; continue 'dispatch;
            }
            0x82EBD368 => {
    //   block [0x82EBD368..0x82EBD390)
	// 82EBD368: 817A0278  lwz r11, 0x278(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EBD36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD370: 409AECDC  bne cr6, 0x82ebc04c
	if !ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD374: 817A0274  lwz r11, 0x274(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(628 as u32) ) } as u64;
	// 82EBD378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EBD37C: 419AECD0  beq cr6, 0x82ebc04c
	if ctx.cr[6].eq {
	pc = 0x82EBC04C; continue 'dispatch;
	}
	// 82EBD380: 817A026C  lwz r11, 0x26c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EBD384: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD388: 917A0278  stw r11, 0x278(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 82EBD38C: 4BFFECC0  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD390 => {
    //   block [0x82EBD390..0x82EBD3DC)
	// 82EBD390: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD398: 3BCBAA8C  addi r30, r11, -0x5574
	ctx.r[30].s64 = ctx.r[11].s64 + -21876;
	// 82EBD39C: 482FECC5  bl 0x831bc060
	ctx.lr = 0x82EBD3A0;
	sub_831BC060(ctx, base);
	// 82EBD3A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD3A4: 4BDEF7AD  bl 0x82cacb50
	ctx.lr = 0x82EBD3A8;
	sub_82CACB50(ctx, base);
	// 82EBD3A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD3AC: 408200B8  bne 0x82ebd464
	if !ctx.cr[0].eq {
	pc = 0x82EBD464; continue 'dispatch;
	}
	// 82EBD3B0: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD3B4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3B8: 4182EE18  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD3BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD3C4: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD3C8: 4BFC6B51  bl 0x82e83f18
	ctx.lr = 0x82EBD3CC;
	sub_82E83F18(ctx, base);
	// 82EBD3CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3D0: 4182000C  beq 0x82ebd3dc
	if ctx.cr[0].eq {
	pc = 0x82EBD3DC; continue 'dispatch;
	}
	// 82EBD3D4: 4BA50935  bl 0x8290dd08
	ctx.lr = 0x82EBD3D8;
	sub_8290DD08(ctx, base);
	// 82EBD3D8: 48000008  b 0x82ebd3e0
	pc = 0x82EBD3E0; continue 'dispatch;
            }
            0x82EBD3DC => {
    //   block [0x82EBD3DC..0x82EBD3E0)
	// 82EBD3DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD3E0; continue 'dispatch;
            }
            0x82EBD3E0 => {
    //   block [0x82EBD3E0..0x82EBD408)
	// 82EBD3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3E4: 419AEDEC  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD3E8: 4BFFE4B9  bl 0x82ebb8a0
	ctx.lr = 0x82EBD3EC;
	sub_82EBB8A0(ctx, base);
	// 82EBD3EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD3F0: 40820030  bne 0x82ebd420
	if !ctx.cr[0].eq {
	pc = 0x82EBD420; continue 'dispatch;
	}
	// 82EBD3F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD3F8: 4BFFDF81  bl 0x82ebb378
	ctx.lr = 0x82EBD3FC;
	sub_82EBB378(ctx, base);
	// 82EBD3FC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD400: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD404: 4099EDCC  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD408; continue 'dispatch;
            }
            0x82EBD408 => {
    //   block [0x82EBD408..0x82EBD420)
	// 82EBD408: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD40C: 4BFFDF6D  bl 0x82ebb378
	ctx.lr = 0x82EBD410;
	sub_82EBB378(ctx, base);
	// 82EBD410: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD414: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD418: 4198FFF0  blt cr6, 0x82ebd408
	if ctx.cr[6].lt {
	pc = 0x82EBD408; continue 'dispatch;
	}
	// 82EBD41C: 4BFFEDB4  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD420 => {
    //   block [0x82EBD420..0x82EBD464)
	// 82EBD420: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD428: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD42C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD430: 4E800421  bctrl
	ctx.lr = 0x82EBD434;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD434: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD438: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD43C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD440: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD448: 4E800421  bctrl
	ctx.lr = 0x82EBD44C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD44C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD450: 4182ED80  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD454: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD458: 387A01A0  addi r3, r26, 0x1a0
	ctx.r[3].s64 = ctx.r[26].s64 + 416;
	// 82EBD45C: 4BFFBE35  bl 0x82eb9290
	ctx.lr = 0x82EBD460;
	sub_82EB9290(ctx, base);
	// 82EBD460: 4BFFEBEC  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD464 => {
    //   block [0x82EBD464..0x82EBD4B0)
	// 82EBD464: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD46C: 3BCBAA78  addi r30, r11, -0x5588
	ctx.r[30].s64 = ctx.r[11].s64 + -21896;
	// 82EBD470: 482FEBF1  bl 0x831bc060
	ctx.lr = 0x82EBD474;
	sub_831BC060(ctx, base);
	// 82EBD474: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD478: 4BDEF6D9  bl 0x82cacb50
	ctx.lr = 0x82EBD47C;
	sub_82CACB50(ctx, base);
	// 82EBD47C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD480: 408200B8  bne 0x82ebd538
	if !ctx.cr[0].eq {
	pc = 0x82EBD538; continue 'dispatch;
	}
	// 82EBD484: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD488: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD48C: 4182ED44  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD490: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD498: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD49C: 4BFC6A7D  bl 0x82e83f18
	ctx.lr = 0x82EBD4A0;
	sub_82E83F18(ctx, base);
	// 82EBD4A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD4A4: 4182000C  beq 0x82ebd4b0
	if ctx.cr[0].eq {
	pc = 0x82EBD4B0; continue 'dispatch;
	}
	// 82EBD4A8: 4BA50861  bl 0x8290dd08
	ctx.lr = 0x82EBD4AC;
	sub_8290DD08(ctx, base);
	// 82EBD4AC: 48000008  b 0x82ebd4b4
	pc = 0x82EBD4B4; continue 'dispatch;
            }
            0x82EBD4B0 => {
    //   block [0x82EBD4B0..0x82EBD4B4)
	// 82EBD4B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD4B4; continue 'dispatch;
            }
            0x82EBD4B4 => {
    //   block [0x82EBD4B4..0x82EBD4DC)
	// 82EBD4B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD4B8: 419AED18  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD4BC: 4BFFE485  bl 0x82ebb940
	ctx.lr = 0x82EBD4C0;
	sub_82EBB940(ctx, base);
	// 82EBD4C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD4C4: 40820030  bne 0x82ebd4f4
	if !ctx.cr[0].eq {
	pc = 0x82EBD4F4; continue 'dispatch;
	}
	// 82EBD4C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD4CC: 4BFFDF25  bl 0x82ebb3f0
	ctx.lr = 0x82EBD4D0;
	sub_82EBB3F0(ctx, base);
	// 82EBD4D0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD4D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD4D8: 4099ECF8  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD4DC; continue 'dispatch;
            }
            0x82EBD4DC => {
    //   block [0x82EBD4DC..0x82EBD4F4)
	// 82EBD4DC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD4E0: 4BFFDF11  bl 0x82ebb3f0
	ctx.lr = 0x82EBD4E4;
	sub_82EBB3F0(ctx, base);
	// 82EBD4E4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD4E8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD4EC: 4198FFF0  blt cr6, 0x82ebd4dc
	if ctx.cr[6].lt {
	pc = 0x82EBD4DC; continue 'dispatch;
	}
	// 82EBD4F0: 4BFFECE0  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD4F4 => {
    //   block [0x82EBD4F4..0x82EBD538)
	// 82EBD4F4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD4F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD4FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD504: 4E800421  bctrl
	ctx.lr = 0x82EBD508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD50C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD514: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD518: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD51C: 4E800421  bctrl
	ctx.lr = 0x82EBD520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD520: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD524: 4182ECAC  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD52C: 387A01B4  addi r3, r26, 0x1b4
	ctx.r[3].s64 = ctx.r[26].s64 + 436;
	// 82EBD530: 4BFFBD61  bl 0x82eb9290
	ctx.lr = 0x82EBD534;
	sub_82EB9290(ctx, base);
	// 82EBD534: 4BFFEB18  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD538 => {
    //   block [0x82EBD538..0x82EBD584)
	// 82EBD538: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD540: 3BCBAA64  addi r30, r11, -0x559c
	ctx.r[30].s64 = ctx.r[11].s64 + -21916;
	// 82EBD544: 482FEB1D  bl 0x831bc060
	ctx.lr = 0x82EBD548;
	sub_831BC060(ctx, base);
	// 82EBD548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD54C: 4BDEF605  bl 0x82cacb50
	ctx.lr = 0x82EBD550;
	sub_82CACB50(ctx, base);
	// 82EBD550: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD554: 408200B8  bne 0x82ebd60c
	if !ctx.cr[0].eq {
	pc = 0x82EBD60C; continue 'dispatch;
	}
	// 82EBD558: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD55C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD560: 4182EC70  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD56C: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD570: 4BFC69A9  bl 0x82e83f18
	ctx.lr = 0x82EBD574;
	sub_82E83F18(ctx, base);
	// 82EBD574: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD578: 4182000C  beq 0x82ebd584
	if ctx.cr[0].eq {
	pc = 0x82EBD584; continue 'dispatch;
	}
	// 82EBD57C: 4BA5078D  bl 0x8290dd08
	ctx.lr = 0x82EBD580;
	sub_8290DD08(ctx, base);
	// 82EBD580: 48000008  b 0x82ebd588
	pc = 0x82EBD588; continue 'dispatch;
            }
            0x82EBD584 => {
    //   block [0x82EBD584..0x82EBD588)
	// 82EBD584: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD588; continue 'dispatch;
            }
            0x82EBD588 => {
    //   block [0x82EBD588..0x82EBD5B0)
	// 82EBD588: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD58C: 419AEC44  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD590: 4BFFE451  bl 0x82ebb9e0
	ctx.lr = 0x82EBD594;
	sub_82EBB9E0(ctx, base);
	// 82EBD594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD598: 40820030  bne 0x82ebd5c8
	if !ctx.cr[0].eq {
	pc = 0x82EBD5C8; continue 'dispatch;
	}
	// 82EBD59C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD5A0: 4BFFDEC9  bl 0x82ebb468
	ctx.lr = 0x82EBD5A4;
	sub_82EBB468(ctx, base);
	// 82EBD5A4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD5A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD5AC: 4099EC24  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD5B0; continue 'dispatch;
            }
            0x82EBD5B0 => {
    //   block [0x82EBD5B0..0x82EBD5C8)
	// 82EBD5B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD5B4: 4BFFDEB5  bl 0x82ebb468
	ctx.lr = 0x82EBD5B8;
	sub_82EBB468(ctx, base);
	// 82EBD5B8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD5BC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD5C0: 4198FFF0  blt cr6, 0x82ebd5b0
	if ctx.cr[6].lt {
	pc = 0x82EBD5B0; continue 'dispatch;
	}
	// 82EBD5C4: 4BFFEC0C  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD5C8 => {
    //   block [0x82EBD5C8..0x82EBD60C)
	// 82EBD5C8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD5CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD5D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD5D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD5D8: 4E800421  bctrl
	ctx.lr = 0x82EBD5DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD5DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD5E0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD5E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD5E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD5EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD5F0: 4E800421  bctrl
	ctx.lr = 0x82EBD5F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD5F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD5F8: 4182EBD8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD5FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD600: 387A01C8  addi r3, r26, 0x1c8
	ctx.r[3].s64 = ctx.r[26].s64 + 456;
	// 82EBD604: 4BFFBC8D  bl 0x82eb9290
	ctx.lr = 0x82EBD608;
	sub_82EB9290(ctx, base);
	// 82EBD608: 4BFFEA44  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD60C => {
    //   block [0x82EBD60C..0x82EBD658)
	// 82EBD60C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD614: 3BCBAA5C  addi r30, r11, -0x55a4
	ctx.r[30].s64 = ctx.r[11].s64 + -21924;
	// 82EBD618: 482FEA49  bl 0x831bc060
	ctx.lr = 0x82EBD61C;
	sub_831BC060(ctx, base);
	// 82EBD61C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD620: 4BDEF531  bl 0x82cacb50
	ctx.lr = 0x82EBD624;
	sub_82CACB50(ctx, base);
	// 82EBD624: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD628: 408200B8  bne 0x82ebd6e0
	if !ctx.cr[0].eq {
	pc = 0x82EBD6E0; continue 'dispatch;
	}
	// 82EBD62C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD630: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD634: 4182EB9C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD63C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD640: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD644: 4BFC68D5  bl 0x82e83f18
	ctx.lr = 0x82EBD648;
	sub_82E83F18(ctx, base);
	// 82EBD648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD64C: 4182000C  beq 0x82ebd658
	if ctx.cr[0].eq {
	pc = 0x82EBD658; continue 'dispatch;
	}
	// 82EBD650: 4BA506B9  bl 0x8290dd08
	ctx.lr = 0x82EBD654;
	sub_8290DD08(ctx, base);
	// 82EBD654: 48000008  b 0x82ebd65c
	pc = 0x82EBD65C; continue 'dispatch;
            }
            0x82EBD658 => {
    //   block [0x82EBD658..0x82EBD65C)
	// 82EBD658: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD65C; continue 'dispatch;
            }
            0x82EBD65C => {
    //   block [0x82EBD65C..0x82EBD684)
	// 82EBD65C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD660: 419AEB70  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD664: 4BFFE69D  bl 0x82ebbd00
	ctx.lr = 0x82EBD668;
	sub_82EBBD00(ctx, base);
	// 82EBD668: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD66C: 40820030  bne 0x82ebd69c
	if !ctx.cr[0].eq {
	pc = 0x82EBD69C; continue 'dispatch;
	}
	// 82EBD670: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD674: 4BFFE04D  bl 0x82ebb6c0
	ctx.lr = 0x82EBD678;
	sub_82EBB6C0(ctx, base);
	// 82EBD678: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD67C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD680: 4099EB50  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD684; continue 'dispatch;
            }
            0x82EBD684 => {
    //   block [0x82EBD684..0x82EBD69C)
	// 82EBD684: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD688: 4BFFE039  bl 0x82ebb6c0
	ctx.lr = 0x82EBD68C;
	sub_82EBB6C0(ctx, base);
	// 82EBD68C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD690: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD694: 4198FFF0  blt cr6, 0x82ebd684
	if ctx.cr[6].lt {
	pc = 0x82EBD684; continue 'dispatch;
	}
	// 82EBD698: 4BFFEB38  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD69C => {
    //   block [0x82EBD69C..0x82EBD6E0)
	// 82EBD69C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD6A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD6A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD6A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD6AC: 4E800421  bctrl
	ctx.lr = 0x82EBD6B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD6B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD6B4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD6B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD6BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD6C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD6C4: 4E800421  bctrl
	ctx.lr = 0x82EBD6C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD6C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD6CC: 4182EB04  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD6D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD6D4: 387A0218  addi r3, r26, 0x218
	ctx.r[3].s64 = ctx.r[26].s64 + 536;
	// 82EBD6D8: 4BFFBBB9  bl 0x82eb9290
	ctx.lr = 0x82EBD6DC;
	sub_82EB9290(ctx, base);
	// 82EBD6DC: 4BFFE970  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD6E0 => {
    //   block [0x82EBD6E0..0x82EBD72C)
	// 82EBD6E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD6E8: 3BCBAA4C  addi r30, r11, -0x55b4
	ctx.r[30].s64 = ctx.r[11].s64 + -21940;
	// 82EBD6EC: 482FE975  bl 0x831bc060
	ctx.lr = 0x82EBD6F0;
	sub_831BC060(ctx, base);
	// 82EBD6F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD6F4: 4BDEF45D  bl 0x82cacb50
	ctx.lr = 0x82EBD6F8;
	sub_82CACB50(ctx, base);
	// 82EBD6F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD6FC: 408200B8  bne 0x82ebd7b4
	if !ctx.cr[0].eq {
	pc = 0x82EBD7B4; continue 'dispatch;
	}
	// 82EBD700: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD704: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD708: 4182EAC8  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD70C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD714: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD718: 4BFC6801  bl 0x82e83f18
	ctx.lr = 0x82EBD71C;
	sub_82E83F18(ctx, base);
	// 82EBD71C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD720: 4182000C  beq 0x82ebd72c
	if ctx.cr[0].eq {
	pc = 0x82EBD72C; continue 'dispatch;
	}
	// 82EBD724: 4BA505E5  bl 0x8290dd08
	ctx.lr = 0x82EBD728;
	sub_8290DD08(ctx, base);
	// 82EBD728: 48000008  b 0x82ebd730
	pc = 0x82EBD730; continue 'dispatch;
            }
            0x82EBD72C => {
    //   block [0x82EBD72C..0x82EBD730)
	// 82EBD72C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD730; continue 'dispatch;
            }
            0x82EBD730 => {
    //   block [0x82EBD730..0x82EBD758)
	// 82EBD730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD734: 419AEA9C  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD738: 4BFFE349  bl 0x82ebba80
	ctx.lr = 0x82EBD73C;
	sub_82EBBA80(ctx, base);
	// 82EBD73C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD740: 40820030  bne 0x82ebd770
	if !ctx.cr[0].eq {
	pc = 0x82EBD770; continue 'dispatch;
	}
	// 82EBD744: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD748: 4BFFDD99  bl 0x82ebb4e0
	ctx.lr = 0x82EBD74C;
	sub_82EBB4E0(ctx, base);
	// 82EBD74C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD750: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD754: 4099EA7C  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD758; continue 'dispatch;
            }
            0x82EBD758 => {
    //   block [0x82EBD758..0x82EBD770)
	// 82EBD758: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD75C: 4BFFDD85  bl 0x82ebb4e0
	ctx.lr = 0x82EBD760;
	sub_82EBB4E0(ctx, base);
	// 82EBD760: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD764: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD768: 4198FFF0  blt cr6, 0x82ebd758
	if ctx.cr[6].lt {
	pc = 0x82EBD758; continue 'dispatch;
	}
	// 82EBD76C: 4BFFEA64  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD770 => {
    //   block [0x82EBD770..0x82EBD7B4)
	// 82EBD770: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD77C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD780: 4E800421  bctrl
	ctx.lr = 0x82EBD784;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD788: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD78C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD790: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD798: 4E800421  bctrl
	ctx.lr = 0x82EBD79C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD79C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD7A0: 4182EA30  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD7A8: 387A01DC  addi r3, r26, 0x1dc
	ctx.r[3].s64 = ctx.r[26].s64 + 476;
	// 82EBD7AC: 4BFFBAE5  bl 0x82eb9290
	ctx.lr = 0x82EBD7B0;
	sub_82EB9290(ctx, base);
	// 82EBD7B0: 4BFFE89C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD7B4 => {
    //   block [0x82EBD7B4..0x82EBD800)
	// 82EBD7B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD7BC: 3BCBAA30  addi r30, r11, -0x55d0
	ctx.r[30].s64 = ctx.r[11].s64 + -21968;
	// 82EBD7C0: 482FE8A1  bl 0x831bc060
	ctx.lr = 0x82EBD7C4;
	sub_831BC060(ctx, base);
	// 82EBD7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD7C8: 4BDEF389  bl 0x82cacb50
	ctx.lr = 0x82EBD7CC;
	sub_82CACB50(ctx, base);
	// 82EBD7CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD7D0: 408200B8  bne 0x82ebd888
	if !ctx.cr[0].eq {
	pc = 0x82EBD888; continue 'dispatch;
	}
	// 82EBD7D4: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD7D8: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD7DC: 4182E9F4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD7E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD7E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD7E8: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD7EC: 4BFC672D  bl 0x82e83f18
	ctx.lr = 0x82EBD7F0;
	sub_82E83F18(ctx, base);
	// 82EBD7F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD7F4: 4182000C  beq 0x82ebd800
	if ctx.cr[0].eq {
	pc = 0x82EBD800; continue 'dispatch;
	}
	// 82EBD7F8: 4BA50511  bl 0x8290dd08
	ctx.lr = 0x82EBD7FC;
	sub_8290DD08(ctx, base);
	// 82EBD7FC: 48000008  b 0x82ebd804
	pc = 0x82EBD804; continue 'dispatch;
            }
            0x82EBD800 => {
    //   block [0x82EBD800..0x82EBD804)
	// 82EBD800: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD804; continue 'dispatch;
            }
            0x82EBD804 => {
    //   block [0x82EBD804..0x82EBD82C)
	// 82EBD804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD808: 419AE9C8  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD80C: 4BFFE3B5  bl 0x82ebbbc0
	ctx.lr = 0x82EBD810;
	sub_82EBBBC0(ctx, base);
	// 82EBD810: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD814: 40820030  bne 0x82ebd844
	if !ctx.cr[0].eq {
	pc = 0x82EBD844; continue 'dispatch;
	}
	// 82EBD818: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD81C: 4BFFDDB5  bl 0x82ebb5d0
	ctx.lr = 0x82EBD820;
	sub_82EBB5D0(ctx, base);
	// 82EBD820: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD824: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD828: 4099E9A8  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD82C; continue 'dispatch;
            }
            0x82EBD82C => {
    //   block [0x82EBD82C..0x82EBD844)
	// 82EBD82C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD830: 4BFFDDA1  bl 0x82ebb5d0
	ctx.lr = 0x82EBD834;
	sub_82EBB5D0(ctx, base);
	// 82EBD834: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD838: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD83C: 4198FFF0  blt cr6, 0x82ebd82c
	if ctx.cr[6].lt {
	pc = 0x82EBD82C; continue 'dispatch;
	}
	// 82EBD840: 4BFFE990  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD844 => {
    //   block [0x82EBD844..0x82EBD888)
	// 82EBD844: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD84C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD854: 4E800421  bctrl
	ctx.lr = 0x82EBD858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD858: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD85C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD864: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD86C: 4E800421  bctrl
	ctx.lr = 0x82EBD870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD870: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD874: 4182E95C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD87C: 387A01F0  addi r3, r26, 0x1f0
	ctx.r[3].s64 = ctx.r[26].s64 + 496;
	// 82EBD880: 4BFFBA11  bl 0x82eb9290
	ctx.lr = 0x82EBD884;
	sub_82EB9290(ctx, base);
	// 82EBD884: 4BFFE7C8  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD888 => {
    //   block [0x82EBD888..0x82EBD8D4)
	// 82EBD888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD890: 3BCBAA18  addi r30, r11, -0x55e8
	ctx.r[30].s64 = ctx.r[11].s64 + -21992;
	// 82EBD894: 482FE7CD  bl 0x831bc060
	ctx.lr = 0x82EBD898;
	sub_831BC060(ctx, base);
	// 82EBD898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD89C: 4BDEF2B5  bl 0x82cacb50
	ctx.lr = 0x82EBD8A0;
	sub_82CACB50(ctx, base);
	// 82EBD8A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD8A4: 408200B8  bne 0x82ebd95c
	if !ctx.cr[0].eq {
	pc = 0x82EBD95C; continue 'dispatch;
	}
	// 82EBD8A8: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD8AC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8B0: 4182E920  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD8B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD8BC: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD8C0: 4BFC6659  bl 0x82e83f18
	ctx.lr = 0x82EBD8C4;
	sub_82E83F18(ctx, base);
	// 82EBD8C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8C8: 4182000C  beq 0x82ebd8d4
	if ctx.cr[0].eq {
	pc = 0x82EBD8D4; continue 'dispatch;
	}
	// 82EBD8CC: 4BA5043D  bl 0x8290dd08
	ctx.lr = 0x82EBD8D0;
	sub_8290DD08(ctx, base);
	// 82EBD8D0: 48000008  b 0x82ebd8d8
	pc = 0x82EBD8D8; continue 'dispatch;
            }
            0x82EBD8D4 => {
    //   block [0x82EBD8D4..0x82EBD8D8)
	// 82EBD8D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD8D8; continue 'dispatch;
            }
            0x82EBD8D8 => {
    //   block [0x82EBD8D8..0x82EBD900)
	// 82EBD8D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8DC: 419AE8F4  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD8E0: 4BFFE241  bl 0x82ebbb20
	ctx.lr = 0x82EBD8E4;
	sub_82EBBB20(ctx, base);
	// 82EBD8E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD8E8: 40820030  bne 0x82ebd918
	if !ctx.cr[0].eq {
	pc = 0x82EBD918; continue 'dispatch;
	}
	// 82EBD8EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD8F0: 4BFFDC69  bl 0x82ebb558
	ctx.lr = 0x82EBD8F4;
	sub_82EBB558(ctx, base);
	// 82EBD8F4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD8F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD8FC: 4099E8D4  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD900; continue 'dispatch;
            }
            0x82EBD900 => {
    //   block [0x82EBD900..0x82EBD918)
	// 82EBD900: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD904: 4BFFDC55  bl 0x82ebb558
	ctx.lr = 0x82EBD908;
	sub_82EBB558(ctx, base);
	// 82EBD908: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD90C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD910: 4198FFF0  blt cr6, 0x82ebd900
	if ctx.cr[6].lt {
	pc = 0x82EBD900; continue 'dispatch;
	}
	// 82EBD914: 4BFFE8BC  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD918 => {
    //   block [0x82EBD918..0x82EBD95C)
	// 82EBD918: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD91C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD920: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD924: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD928: 4E800421  bctrl
	ctx.lr = 0x82EBD92C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD92C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBD930: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBD934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBD938: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD93C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD940: 4E800421  bctrl
	ctx.lr = 0x82EBD944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBD944: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD948: 4182E888  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD94C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBD950: 387A0204  addi r3, r26, 0x204
	ctx.r[3].s64 = ctx.r[26].s64 + 516;
	// 82EBD954: 4BFFB93D  bl 0x82eb9290
	ctx.lr = 0x82EBD958;
	sub_82EB9290(ctx, base);
	// 82EBD958: 4BFFE6F4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBD95C => {
    //   block [0x82EBD95C..0x82EBD9A8)
	// 82EBD95C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD964: 3BCBAA04  addi r30, r11, -0x55fc
	ctx.r[30].s64 = ctx.r[11].s64 + -22012;
	// 82EBD968: 482FE6F9  bl 0x831bc060
	ctx.lr = 0x82EBD96C;
	sub_831BC060(ctx, base);
	// 82EBD96C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD970: 4BDEF1E1  bl 0x82cacb50
	ctx.lr = 0x82EBD974;
	sub_82CACB50(ctx, base);
	// 82EBD974: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBD978: 408200B8  bne 0x82ebda30
	if !ctx.cr[0].eq {
	pc = 0x82EBDA30; continue 'dispatch;
	}
	// 82EBD97C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBD980: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD984: 4182E84C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD988: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBD98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBD990: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBD994: 4BFC6585  bl 0x82e83f18
	ctx.lr = 0x82EBD998;
	sub_82E83F18(ctx, base);
	// 82EBD998: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD99C: 4182000C  beq 0x82ebd9a8
	if ctx.cr[0].eq {
	pc = 0x82EBD9A8; continue 'dispatch;
	}
	// 82EBD9A0: 4BA50369  bl 0x8290dd08
	ctx.lr = 0x82EBD9A4;
	sub_8290DD08(ctx, base);
	// 82EBD9A4: 48000008  b 0x82ebd9ac
	pc = 0x82EBD9AC; continue 'dispatch;
            }
            0x82EBD9A8 => {
    //   block [0x82EBD9A8..0x82EBD9AC)
	// 82EBD9A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBD9AC; continue 'dispatch;
            }
            0x82EBD9AC => {
    //   block [0x82EBD9AC..0x82EBD9D4)
	// 82EBD9AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBD9B0: 419AE820  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBD9B4: 4BFFE2AD  bl 0x82ebbc60
	ctx.lr = 0x82EBD9B8;
	sub_82EBBC60(ctx, base);
	// 82EBD9B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBD9BC: 40820030  bne 0x82ebd9ec
	if !ctx.cr[0].eq {
	pc = 0x82EBD9EC; continue 'dispatch;
	}
	// 82EBD9C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBD9C4: 4BFFDC85  bl 0x82ebb648
	ctx.lr = 0x82EBD9C8;
	sub_82EBB648(ctx, base);
	// 82EBD9C8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD9CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBD9D0: 4099E800  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBD9D4; continue 'dispatch;
            }
            0x82EBD9D4 => {
    //   block [0x82EBD9D4..0x82EBD9EC)
	// 82EBD9D4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBD9D8: 4BFFDC71  bl 0x82ebb648
	ctx.lr = 0x82EBD9DC;
	sub_82EBB648(ctx, base);
	// 82EBD9DC: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBD9E0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBD9E4: 4198FFF0  blt cr6, 0x82ebd9d4
	if ctx.cr[6].lt {
	pc = 0x82EBD9D4; continue 'dispatch;
	}
	// 82EBD9E8: 4BFFE7E8  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBD9EC => {
    //   block [0x82EBD9EC..0x82EBDA30)
	// 82EBD9EC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBD9F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBD9F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBD9F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBD9FC: 4E800421  bctrl
	ctx.lr = 0x82EBDA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDA00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDA04: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDA08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDA0C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDA10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDA14: 4E800421  bctrl
	ctx.lr = 0x82EBDA18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDA18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDA1C: 4182E7B4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDA20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDA24: 387A022C  addi r3, r26, 0x22c
	ctx.r[3].s64 = ctx.r[26].s64 + 556;
	// 82EBDA28: 4BFFB869  bl 0x82eb9290
	ctx.lr = 0x82EBDA2C;
	sub_82EB9290(ctx, base);
	// 82EBDA2C: 4BFFE620  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBDA30 => {
    //   block [0x82EBDA30..0x82EBDA7C)
	// 82EBDA30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDA38: 3BCBA9FC  addi r30, r11, -0x5604
	ctx.r[30].s64 = ctx.r[11].s64 + -22020;
	// 82EBDA3C: 482FE625  bl 0x831bc060
	ctx.lr = 0x82EBDA40;
	sub_831BC060(ctx, base);
	// 82EBDA40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDA44: 4BDEF10D  bl 0x82cacb50
	ctx.lr = 0x82EBDA48;
	sub_82CACB50(ctx, base);
	// 82EBDA48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDA4C: 408200B8  bne 0x82ebdb04
	if !ctx.cr[0].eq {
	pc = 0x82EBDB04; continue 'dispatch;
	}
	// 82EBDA50: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDA54: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA58: 4182E778  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDA5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDA64: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBDA68: 4BFC64B1  bl 0x82e83f18
	ctx.lr = 0x82EBDA6C;
	sub_82E83F18(ctx, base);
	// 82EBDA6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA70: 4182000C  beq 0x82ebda7c
	if ctx.cr[0].eq {
	pc = 0x82EBDA7C; continue 'dispatch;
	}
	// 82EBDA74: 4BA50295  bl 0x8290dd08
	ctx.lr = 0x82EBDA78;
	sub_8290DD08(ctx, base);
	// 82EBDA78: 48000008  b 0x82ebda80
	pc = 0x82EBDA80; continue 'dispatch;
            }
            0x82EBDA7C => {
    //   block [0x82EBDA7C..0x82EBDA80)
	// 82EBDA7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBDA80; continue 'dispatch;
            }
            0x82EBDA80 => {
    //   block [0x82EBDA80..0x82EBDAA8)
	// 82EBDA80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA84: 419AE74C  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDA88: 4BFFE3B9  bl 0x82ebbe40
	ctx.lr = 0x82EBDA8C;
	sub_82EBBE40(ctx, base);
	// 82EBDA8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDA90: 40820030  bne 0x82ebdac0
	if !ctx.cr[0].eq {
	pc = 0x82EBDAC0; continue 'dispatch;
	}
	// 82EBDA94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDA98: 4BFFDD19  bl 0x82ebb7b0
	ctx.lr = 0x82EBDA9C;
	sub_82EBB7B0(ctx, base);
	// 82EBDA9C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDAA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDAA4: 4099E72C  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBDAA8; continue 'dispatch;
            }
            0x82EBDAA8 => {
    //   block [0x82EBDAA8..0x82EBDAC0)
	// 82EBDAA8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBDAAC: 4BFFDD05  bl 0x82ebb7b0
	ctx.lr = 0x82EBDAB0;
	sub_82EBB7B0(ctx, base);
	// 82EBDAB0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDAB4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBDAB8: 4198FFF0  blt cr6, 0x82ebdaa8
	if ctx.cr[6].lt {
	pc = 0x82EBDAA8; continue 'dispatch;
	}
	// 82EBDABC: 4BFFE714  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBDAC0 => {
    //   block [0x82EBDAC0..0x82EBDB04)
	// 82EBDAC0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDAC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDAC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBDACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDAD0: 4E800421  bctrl
	ctx.lr = 0x82EBDAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDAD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDAD8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDAE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDAE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDAE8: 4E800421  bctrl
	ctx.lr = 0x82EBDAEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDAEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDAF0: 4182E6E0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDAF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDAF8: 387A0240  addi r3, r26, 0x240
	ctx.r[3].s64 = ctx.r[26].s64 + 576;
	// 82EBDAFC: 4BFFB795  bl 0x82eb9290
	ctx.lr = 0x82EBDB00;
	sub_82EB9290(ctx, base);
	// 82EBDB00: 4BFFE54C  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBDB04 => {
    //   block [0x82EBDB04..0x82EBDB50)
	// 82EBDB04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDB0C: 3BCBA9F0  addi r30, r11, -0x5610
	ctx.r[30].s64 = ctx.r[11].s64 + -22032;
	// 82EBDB10: 482FE551  bl 0x831bc060
	ctx.lr = 0x82EBDB14;
	sub_831BC060(ctx, base);
	// 82EBDB14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDB18: 4BDEF039  bl 0x82cacb50
	ctx.lr = 0x82EBDB1C;
	sub_82CACB50(ctx, base);
	// 82EBDB1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDB20: 408200B8  bne 0x82ebdbd8
	if !ctx.cr[0].eq {
	pc = 0x82EBDBD8; continue 'dispatch;
	}
	// 82EBDB24: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDB28: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB2C: 4182E6A4  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDB30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDB38: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBDB3C: 4BFC63DD  bl 0x82e83f18
	ctx.lr = 0x82EBDB40;
	sub_82E83F18(ctx, base);
	// 82EBDB40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB44: 4182000C  beq 0x82ebdb50
	if ctx.cr[0].eq {
	pc = 0x82EBDB50; continue 'dispatch;
	}
	// 82EBDB48: 4BA501C1  bl 0x8290dd08
	ctx.lr = 0x82EBDB4C;
	sub_8290DD08(ctx, base);
	// 82EBDB4C: 48000008  b 0x82ebdb54
	pc = 0x82EBDB54; continue 'dispatch;
            }
            0x82EBDB50 => {
    //   block [0x82EBDB50..0x82EBDB54)
	// 82EBDB50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBDB54; continue 'dispatch;
            }
            0x82EBDB54 => {
    //   block [0x82EBDB54..0x82EBDB7C)
	// 82EBDB54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB58: 419AE678  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDB5C: 4BFFE245  bl 0x82ebbda0
	ctx.lr = 0x82EBDB60;
	sub_82EBBDA0(ctx, base);
	// 82EBDB60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDB64: 40820030  bne 0x82ebdb94
	if !ctx.cr[0].eq {
	pc = 0x82EBDB94; continue 'dispatch;
	}
	// 82EBDB68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDB6C: 4BFFDBCD  bl 0x82ebb738
	ctx.lr = 0x82EBDB70;
	sub_82EBB738(ctx, base);
	// 82EBDB70: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDB74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDB78: 4099E658  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBDB7C; continue 'dispatch;
            }
            0x82EBDB7C => {
    //   block [0x82EBDB7C..0x82EBDB94)
	// 82EBDB7C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBDB80: 4BFFDBB9  bl 0x82ebb738
	ctx.lr = 0x82EBDB84;
	sub_82EBB738(ctx, base);
	// 82EBDB84: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDB88: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBDB8C: 4198FFF0  blt cr6, 0x82ebdb7c
	if ctx.cr[6].lt {
	pc = 0x82EBDB7C; continue 'dispatch;
	}
	// 82EBDB90: 4BFFE640  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBDB94 => {
    //   block [0x82EBDB94..0x82EBDBD8)
	// 82EBDB94: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDB98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDB9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBDBA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDBA4: 4E800421  bctrl
	ctx.lr = 0x82EBDBA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDBA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDBAC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDBB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDBB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDBB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDBBC: 4E800421  bctrl
	ctx.lr = 0x82EBDBC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDBC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDBC4: 4182E60C  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDBC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDBCC: 387A0254  addi r3, r26, 0x254
	ctx.r[3].s64 = ctx.r[26].s64 + 596;
	// 82EBDBD0: 4BFFB6C1  bl 0x82eb9290
	ctx.lr = 0x82EBDBD4;
	sub_82EB9290(ctx, base);
	// 82EBDBD4: 4BFFE478  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            0x82EBDBD8 => {
    //   block [0x82EBDBD8..0x82EBDC24)
	// 82EBDBD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDBE0: 3BCBA9D8  addi r30, r11, -0x5628
	ctx.r[30].s64 = ctx.r[11].s64 + -22056;
	// 82EBDBE4: 482FE47D  bl 0x831bc060
	ctx.lr = 0x82EBDBE8;
	sub_831BC060(ctx, base);
	// 82EBDBE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDBEC: 4BDEEF65  bl 0x82cacb50
	ctx.lr = 0x82EBDBF0;
	sub_82CACB50(ctx, base);
	// 82EBDBF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDBF4: 4082E5DC  bne 0x82ebc1d0
	if !ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDBF8: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDBFC: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC00: 4182E5D0  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDC0C: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82EBDC10: 4BFC6309  bl 0x82e83f18
	ctx.lr = 0x82EBDC14;
	sub_82E83F18(ctx, base);
	// 82EBDC14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC18: 4182000C  beq 0x82ebdc24
	if ctx.cr[0].eq {
	pc = 0x82EBDC24; continue 'dispatch;
	}
	// 82EBDC1C: 4BA500ED  bl 0x8290dd08
	ctx.lr = 0x82EBDC20;
	sub_8290DD08(ctx, base);
	// 82EBDC20: 48000008  b 0x82ebdc28
	pc = 0x82EBDC28; continue 'dispatch;
            }
            0x82EBDC24 => {
    //   block [0x82EBDC24..0x82EBDC28)
	// 82EBDC24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBDC28; continue 'dispatch;
            }
            0x82EBDC28 => {
    //   block [0x82EBDC28..0x82EBDC50)
	// 82EBDC28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC2C: 419AE5A4  beq cr6, 0x82ebc1d0
	if ctx.cr[6].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC30: 4BFFE2B1  bl 0x82ebbee0
	ctx.lr = 0x82EBDC34;
	sub_82EBBEE0(ctx, base);
	// 82EBDC34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDC38: 40820030  bne 0x82ebdc68
	if !ctx.cr[0].eq {
	pc = 0x82EBDC68; continue 'dispatch;
	}
	// 82EBDC3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDC40: 4BFFDBE9  bl 0x82ebb828
	ctx.lr = 0x82EBDC44;
	sub_82EBB828(ctx, base);
	// 82EBDC44: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDC48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDC4C: 4099E584  ble cr6, 0x82ebc1d0
	if !ctx.cr[6].gt {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	pc = 0x82EBDC50; continue 'dispatch;
            }
            0x82EBDC50 => {
    //   block [0x82EBDC50..0x82EBDC68)
	// 82EBDC50: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EBDC54: 4BFFDBD5  bl 0x82ebb828
	ctx.lr = 0x82EBDC58;
	sub_82EBB828(ctx, base);
	// 82EBDC58: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EBDC5C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EBDC60: 4198FFF0  blt cr6, 0x82ebdc50
	if ctx.cr[6].lt {
	pc = 0x82EBDC50; continue 'dispatch;
	}
	// 82EBDC64: 4BFFE56C  b 0x82ebc1d0
	pc = 0x82EBC1D0; continue 'dispatch;
            }
            0x82EBDC68 => {
    //   block [0x82EBDC68..0x82EBDCAC)
	// 82EBDC68: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDC6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDC70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EBDC74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDC78: 4E800421  bctrl
	ctx.lr = 0x82EBDC7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDC7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDC80: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EBDC84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBDC88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDC8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDC90: 4E800421  bctrl
	ctx.lr = 0x82EBDC94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDC94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDC98: 4182E538  beq 0x82ebc1d0
	if ctx.cr[0].eq {
	pc = 0x82EBC1D0; continue 'dispatch;
	}
	// 82EBDC9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBDCA0: 387A0268  addi r3, r26, 0x268
	ctx.r[3].s64 = ctx.r[26].s64 + 616;
	// 82EBDCA4: 4BFFB5ED  bl 0x82eb9290
	ctx.lr = 0x82EBDCA8;
	sub_82EB9290(ctx, base);
	// 82EBDCA8: 4BFFE3A4  b 0x82ebc04c
	pc = 0x82EBC04C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDCB0 size=84
    let mut pc: u32 = 0x82EBDCB0;
    'dispatch: loop {
        match pc {
            0x82EBDCB0 => {
    //   block [0x82EBDCB0..0x82EBDCF8)
	// 82EBDCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDCB4: 4BDEB759  bl 0x82ca940c
	ctx.lr = 0x82EBDCB8;
	sub_82CA93D0(ctx, base);
	// 82EBDCB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDCBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBDCC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBDCC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBDCC8: 4B758C61  bl 0x82616928
	ctx.lr = 0x82EBDCCC;
	sub_82616928(ctx, base);
	// 82EBDCCC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBDCD0: 41820028  beq 0x82ebdcf8
	if ctx.cr[0].eq {
	pc = 0x82EBDCF8; continue 'dispatch;
	}
	// 82EBDCD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBDCD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDCE0: 4BFF7651  bl 0x82eb5330
	ctx.lr = 0x82EBDCE4;
	sub_82EB5330(ctx, base);
	// 82EBDCE4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDCEC: 396BA8D8  addi r11, r11, -0x5728
	ctx.r[11].s64 = ctx.r[11].s64 + -22312;
	// 82EBDCF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDCF4: 48000008  b 0x82ebdcfc
	pc = 0x82EBDCFC; continue 'dispatch;
            }
            0x82EBDCF8 => {
    //   block [0x82EBDCF8..0x82EBDCFC)
	// 82EBDCF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBDCFC; continue 'dispatch;
            }
            0x82EBDCFC => {
    //   block [0x82EBDCFC..0x82EBDD04)
	// 82EBDCFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBDD00: 4BDEB75C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDD08 size=276
    let mut pc: u32 = 0x82EBDD08;
    'dispatch: loop {
        match pc {
            0x82EBDD08 => {
    //   block [0x82EBDD08..0x82EBDD60)
	// 82EBDD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDD0C: 4BDEB6F1  bl 0x82ca93fc
	ctx.lr = 0x82EBDD10;
	sub_82CA93D0(ctx, base);
	// 82EBDD10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDD14: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EBDD18: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD1C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EBDD20: 388B75C8  addi r4, r11, 0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + 30152;
	// 82EBDD24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBDD28: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EBDD2C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82EBDD30: 4BFCB9B1  bl 0x82e896e0
	ctx.lr = 0x82EBDD34;
	sub_82E896E0(ctx, base);
	// 82EBDD34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD38: 418200B4  beq 0x82ebddec
	if ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDD3C: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDD40: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDD44: 48015B95  bl 0x82ed38d8
	ctx.lr = 0x82EBDD48;
	sub_82ED38D8(ctx, base);
	// 82EBDD48: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBDD4C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDD50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD54: 4182000C  beq 0x82ebdd60
	if ctx.cr[0].eq {
	pc = 0x82EBDD60; continue 'dispatch;
	}
	// 82EBDD58: 48017CB9  bl 0x82ed5a10
	ctx.lr = 0x82EBDD5C;
	sub_82ED5A10(ctx, base);
	// 82EBDD5C: 48000008  b 0x82ebdd64
	pc = 0x82EBDD64; continue 'dispatch;
            }
            0x82EBDD60 => {
    //   block [0x82EBDD60..0x82EBDD64)
	// 82EBDD60: 48017CC1  bl 0x82ed5a20
	ctx.lr = 0x82EBDD64;
	sub_82ED5A20(ctx, base);
	pc = 0x82EBDD64; continue 'dispatch;
            }
            0x82EBDD64 => {
    //   block [0x82EBDD64..0x82EBDDA4)
	// 82EBDD64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBDD68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD6C: 419A0078  beq cr6, 0x82ebdde4
	if ctx.cr[6].eq {
	pc = 0x82EBDDE4; continue 'dispatch;
	}
	// 82EBDD70: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82EBDD74: 419A0070  beq cr6, 0x82ebdde4
	if ctx.cr[6].eq {
	pc = 0x82EBDDE4; continue 'dispatch;
	}
	// 82EBDD78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD7C: 388B6D70  addi r4, r11, 0x6d70
	ctx.r[4].s64 = ctx.r[11].s64 + 28016;
	// 82EBDD80: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDD84: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBDD88: 4B3A9E99  bl 0x82267c20
	ctx.lr = 0x82EBDD8C;
	sub_82267C20(ctx, base);
	// 82EBDD8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDD90: 4182005C  beq 0x82ebddec
	if ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	// 82EBDD94: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EBDD98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EBDD9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBDDA0: 419A003C  beq cr6, 0x82ebdddc
	if ctx.cr[6].eq {
	pc = 0x82EBDDDC; continue 'dispatch;
	}
	pc = 0x82EBDDA4; continue 'dispatch;
            }
            0x82EBDDA4 => {
    //   block [0x82EBDDA4..0x82EBDDD8)
	// 82EBDDA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDDA8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDDAC: 48017C0D  bl 0x82ed59b8
	ctx.lr = 0x82EBDDB0;
	sub_82ED59B8(ctx, base);
	// 82EBDDB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EBDDB4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDDB8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBDDBC: 48016B55  bl 0x82ed4910
	ctx.lr = 0x82EBDDC0;
	sub_82ED4910(ctx, base);
	// 82EBDDC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDDC4: 40820014  bne 0x82ebddd8
	if !ctx.cr[0].eq {
	pc = 0x82EBDDD8; continue 'dispatch;
	}
	// 82EBDDC8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EBDDCC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EBDDD0: 4198FFD4  blt cr6, 0x82ebdda4
	if ctx.cr[6].lt {
	pc = 0x82EBDDA4; continue 'dispatch;
	}
	// 82EBDDD4: 48000008  b 0x82ebdddc
	pc = 0x82EBDDDC; continue 'dispatch;
            }
            0x82EBDDD8 => {
    //   block [0x82EBDDD8..0x82EBDDDC)
	// 82EBDDD8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82EBDDDC; continue 'dispatch;
            }
            0x82EBDDDC => {
    //   block [0x82EBDDDC..0x82EBDDE4)
	// 82EBDDDC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBDDE0: 4082000C  bne 0x82ebddec
	if !ctx.cr[0].eq {
	pc = 0x82EBDDEC; continue 'dispatch;
	}
	pc = 0x82EBDDE4; continue 'dispatch;
            }
            0x82EBDDE4 => {
    //   block [0x82EBDDE4..0x82EBDDEC)
	// 82EBDDE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDDE8: 4800002C  b 0x82ebde14
	pc = 0x82EBDE14; continue 'dispatch;
            }
            0x82EBDDEC => {
    //   block [0x82EBDDEC..0x82EBDE14)
	// 82EBDDEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDDF0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EBDDF4: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDDF8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EBDDFC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBDE00: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EBDE04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE08: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBDE0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDE10: 4E800421  bctrl
	ctx.lr = 0x82EBDE14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBDE14 => {
    //   block [0x82EBDE14..0x82EBDE1C)
	// 82EBDE14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EBDE18: 4BDEB634  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDE20 size=392
    let mut pc: u32 = 0x82EBDE20;
    'dispatch: loop {
        match pc {
            0x82EBDE20 => {
    //   block [0x82EBDE20..0x82EBDEE8)
	// 82EBDE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDE24: 4BDEB5D5  bl 0x82ca93f8
	ctx.lr = 0x82EBDE28;
	sub_82CA93D0(ctx, base);
	// 82EBDE28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDE2C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82EBDE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBDE34: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EBDE38: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EBDE3C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EBDE40: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE44: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82EBDE48: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE4C: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82EBDE50: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EBDE54: 409A0094  bne cr6, 0x82ebdee8
	if !ctx.cr[6].eq {
	pc = 0x82EBDEE8; continue 'dispatch;
	}
	// 82EBDE58: 57A3003E  slwi r3, r29, 0
	ctx.r[3].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82EBDE5C: 81630250  lwz r11, 0x250(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBDE60: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EBDE64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDE68: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBDE6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDE70: 4E800421  bctrl
	ctx.lr = 0x82EBDE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDE74: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE78: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EBDE7C: 3D4082EC  lis r10, -0x7d14
	ctx.r[10].s64 = -2098462720;
	// 82EBDE80: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EBDE84: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EBDE88: 38AADD08  addi r5, r10, -0x22f8
	ctx.r[5].s64 = ctx.r[10].s64 + -8952;
	// 82EBDE8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EBDE90: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDE94: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EBDE98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EBDE9C: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82EBDEA0: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EBDEA4: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82EBDEA8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EBDEAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EBDEB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBDEB4: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBDEB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EBDEBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBDEC0: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EBDEC4: 9B410080  stb r26, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u8 ) };
	// 82EBDEC8: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82EBDECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBDED0: 48017661  bl 0x82ed5530
	ctx.lr = 0x82EBDED4;
	sub_82ED5530(ctx, base);
	// 82EBDED4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDED8: 40820034  bne 0x82ebdf0c
	if !ctx.cr[0].eq {
	pc = 0x82EBDF0C; continue 'dispatch;
	}
	// 82EBDEDC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDEE0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EBDEE4: 419A00B8  beq cr6, 0x82ebdf9c
	if ctx.cr[6].eq {
	pc = 0x82EBDF9C; continue 'dispatch;
	}
            }
            0x82EBDEE8 => {
    //   block [0x82EBDEE8..0x82EBDF0C)
	// 82EBDEE8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBDEEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EBDEF0: 388B75C8  addi r4, r11, 0x75c8
	ctx.r[4].s64 = ctx.r[11].s64 + 30152;
	// 82EBDEF4: 4BFCB7ED  bl 0x82e896e0
	ctx.lr = 0x82EBDEF8;
	sub_82E896E0(ctx, base);
	// 82EBDEF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBDEFC: 41820018  beq 0x82ebdf14
	if ctx.cr[0].eq {
	pc = 0x82EBDF14; continue 'dispatch;
	}
	// 82EBDF00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF04: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDF08: 48000094  b 0x82ebdf9c
	pc = 0x82EBDF9C; continue 'dispatch;
            }
            0x82EBDF0C => {
    //   block [0x82EBDF0C..0x82EBDF14)
	// 82EBDF0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDF10: 48000090  b 0x82ebdfa0
	pc = 0x82EBDFA0; continue 'dispatch;
            }
            0x82EBDF14 => {
    //   block [0x82EBDF14..0x82EBDF9C)
	// 82EBDF14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF18: 81630250  lwz r11, 0x250(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBDF1C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EBDF20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBDF24: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBDF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBDF2C: 4E800421  bctrl
	ctx.lr = 0x82EBDF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBDF30: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF34: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EBDF38: 3D4082EC  lis r10, -0x7d14
	ctx.r[10].s64 = -2098462720;
	// 82EBDF3C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EBDF40: 817D009C  lwz r11, 0x9c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EBDF44: 38AADD08  addi r5, r10, -0x22f8
	ctx.r[5].s64 = ctx.r[10].s64 + -8952;
	// 82EBDF48: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EBDF4C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBDF50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EBDF54: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EBDF58: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82EBDF5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBDF60: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82EBDF64: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82EBDF68: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EBDF6C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBDF70: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBDF74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBDF78: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EBDF7C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EBDF80: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82EBDF84: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82EBDF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBDF8C: 480175A5  bl 0x82ed5530
	ctx.lr = 0x82EBDF90;
	sub_82ED5530(ctx, base);
	// 82EBDF90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBDF94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBDF98: 40820008  bne 0x82ebdfa0
	if !ctx.cr[0].eq {
	pc = 0x82EBDFA0; continue 'dispatch;
	}
            }
            0x82EBDF9C => {
    //   block [0x82EBDF9C..0x82EBDFA0)
	// 82EBDF9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EBDFA0; continue 'dispatch;
            }
            0x82EBDFA0 => {
    //   block [0x82EBDFA0..0x82EBDFA8)
	// 82EBDFA0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EBDFA4: 4BDEB4A4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBDFA8 size=12
    let mut pc: u32 = 0x82EBDFA8;
    'dispatch: loop {
        match pc {
            0x82EBDFA8 => {
    //   block [0x82EBDFA8..0x82EBDFB4)
	// 82EBDFA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBDFAC: 386BCCDC  addi r3, r11, -0x3324
	ctx.r[3].s64 = ctx.r[11].s64 + -13092;
	// 82EBDFB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBDFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBDFB8 size=84
    let mut pc: u32 = 0x82EBDFB8;
    'dispatch: loop {
        match pc {
            0x82EBDFB8 => {
    //   block [0x82EBDFB8..0x82EBE000)
	// 82EBDFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBDFBC: 4BDEB451  bl 0x82ca940c
	ctx.lr = 0x82EBDFC0;
	sub_82CA93D0(ctx, base);
	// 82EBDFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBDFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBDFC8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBDFCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBDFD0: 4B758959  bl 0x82616928
	ctx.lr = 0x82EBDFD4;
	sub_82616928(ctx, base);
	// 82EBDFD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBDFD8: 41820028  beq 0x82ebe000
	if ctx.cr[0].eq {
	pc = 0x82EBE000; continue 'dispatch;
	}
	// 82EBDFDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBDFE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBDFE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDFE8: 4BFF7349  bl 0x82eb5330
	ctx.lr = 0x82EBDFEC;
	sub_82EB5330(ctx, base);
	// 82EBDFEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBDFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBDFF4: 396BAD3C  addi r11, r11, -0x52c4
	ctx.r[11].s64 = ctx.r[11].s64 + -21188;
	// 82EBDFF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBDFFC: 48000008  b 0x82ebe004
	pc = 0x82EBE004; continue 'dispatch;
            }
            0x82EBE000 => {
    //   block [0x82EBE000..0x82EBE004)
	// 82EBE000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBE004; continue 'dispatch;
            }
            0x82EBE004 => {
    //   block [0x82EBE004..0x82EBE00C)
	// 82EBE004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE008: 4BDEB454  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE010 size=4
    let mut pc: u32 = 0x82EBE010;
    'dispatch: loop {
        match pc {
            0x82EBE010 => {
    //   block [0x82EBE010..0x82EBE014)
	// 82EBE010: 4BFF7410  b 0x82eb5420
	sub_82EB5420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE018 size=424
    let mut pc: u32 = 0x82EBE018;
    'dispatch: loop {
        match pc {
            0x82EBE018 => {
    //   block [0x82EBE018..0x82EBE10C)
	// 82EBE018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE01C: 4BDEB3E5  bl 0x82ca9400
	ctx.lr = 0x82EBE020;
	sub_82CA93D0(ctx, base);
	// 82EBE020: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EBE024: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE028: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EBE02C: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82EBE030: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE034: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE038: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EBE03C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EBE040: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82EBE044: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82EBE048: 4B32A631  bl 0x821e8678
	ctx.lr = 0x82EBE04C;
	sub_821E8678(ctx, base);
	// 82EBE04C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE050: 41820160  beq 0x82ebe1b0
	if ctx.cr[0].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE054: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE058: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE05C: 41820154  beq 0x82ebe1b0
	if ctx.cr[0].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE060: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE064: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE068: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EBE06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE070: 4BFBF651  bl 0x82e7d6c0
	ctx.lr = 0x82EBE074;
	sub_82E7D6C0(ctx, base);
	// 82EBE074: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE07C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 82EBE080: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE088: 4BFBF639  bl 0x82e7d6c0
	ctx.lr = 0x82EBE08C;
	sub_82E7D6C0(ctx, base);
	// 82EBE08C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE090: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBE094: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EBE098: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE0A0: 4BFBF621  bl 0x82e7d6c0
	ctx.lr = 0x82EBE0A4;
	sub_82E7D6C0(ctx, base);
	// 82EBE0A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EBE0A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0AC: 419A0104  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0B4: 419A00FC  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EBE0BC: 419A00F4  beq cr6, 0x82ebe1b0
	if ctx.cr[6].eq {
	pc = 0x82EBE1B0; continue 'dispatch;
	}
	// 82EBE0C0: C01B0038  lfs f0, 0x38(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE0C8: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE0CC: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE0D0: C01B003C  lfs f0, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0D4: C19A000C  lfs f12, 0xc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE0D8: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE0DC: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0E0: C17B0034  lfs f11, 0x34(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE0E4: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBE0E8: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE0EC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE0F0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE0F4: ED40002C  fsqrts f10, f0
	ctx.f[10].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBE0F8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE0FC: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EBE100: 409A000C  bne cr6, 0x82ebe10c
	if !ctx.cr[6].eq {
	pc = 0x82EBE10C; continue 'dispatch;
	}
	// 82EBE104: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE108: 480000AC  b 0x82ebe1b4
	pc = 0x82EBE1B4; continue 'dispatch;
            }
            0x82EBE10C => {
    //   block [0x82EBE10C..0x82EBE1B0)
	// 82EBE10C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE110: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBE114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBE118: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE11C: EC005024  fdivs f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82EBE120: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBE124: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE128: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE12C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBE130: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBE134: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBE138: 4BFC7C31  bl 0x82e85d68
	ctx.lr = 0x82EBE13C;
	sub_82E85D68(ctx, base);
	// 82EBE13C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82EBE140: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EBE144: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE148: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE14C: 9BFC0004  stb r31, 4(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE150: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE154: C00B0ED4  lfs f0, 0xed4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE158: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE15C: 4B37BD55  bl 0x82239eb0
	ctx.lr = 0x82EBE160;
	sub_82239EB0(ctx, base);
	// 82EBE160: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE164: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE168: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE16C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE170: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBE174: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE178: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE17C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE180: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE184: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBE188: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE18C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE190: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE194: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBE198: 9BFD0004  stb r31, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82EBE19C: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBE1A0: EC0D02BA  fmadds f0, f13, f10, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE1A4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE1A8: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE1AC: 48000008  b 0x82ebe1b4
	pc = 0x82EBE1B4; continue 'dispatch;
            }
            0x82EBE1B0 => {
    //   block [0x82EBE1B0..0x82EBE1B4)
	// 82EBE1B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBE1B4; continue 'dispatch;
            }
            0x82EBE1B4 => {
    //   block [0x82EBE1B4..0x82EBE1C0)
	// 82EBE1B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EBE1B8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EBE1BC: 4BDEB294  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE1C0 size=88
    let mut pc: u32 = 0x82EBE1C0;
    'dispatch: loop {
        match pc {
            0x82EBE1C0 => {
    //   block [0x82EBE1C0..0x82EBE1FC)
	// 82EBE1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE1C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBE1C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBE1CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBE1D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE1D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBE1D8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EBE1DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE1E0: 4B758749  bl 0x82616928
	ctx.lr = 0x82EBE1E4;
	sub_82616928(ctx, base);
	// 82EBE1E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE1E8: 41820014  beq 0x82ebe1fc
	if ctx.cr[0].eq {
	pc = 0x82EBE1FC; continue 'dispatch;
	}
	// 82EBE1EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBE1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBE1F4: 4BFF755D  bl 0x82eb5750
	ctx.lr = 0x82EBE1F8;
	sub_82EB5750(ctx, base);
	// 82EBE1F8: 48000008  b 0x82ebe200
	pc = 0x82EBE200; continue 'dispatch;
            }
            0x82EBE1FC => {
    //   block [0x82EBE1FC..0x82EBE200)
	// 82EBE1FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBE200; continue 'dispatch;
            }
            0x82EBE200 => {
    //   block [0x82EBE200..0x82EBE218)
	// 82EBE200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBE208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBE20C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBE210: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBE214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE218 size=360
    let mut pc: u32 = 0x82EBE218;
    'dispatch: loop {
        match pc {
            0x82EBE218 => {
    //   block [0x82EBE218..0x82EBE270)
	// 82EBE218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE21C: 4BDEB1F1  bl 0x82ca940c
	ctx.lr = 0x82EBE220;
	sub_82CA93D0(ctx, base);
	// 82EBE220: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBE224: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE228: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBE22C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE230: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE234: 482FDE2D  bl 0x831bc060
	ctx.lr = 0x82EBE238;
	sub_831BC060(ctx, base);
	// 82EBE238: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE23C: 4182012C  beq 0x82ebe368
	if ctx.cr[0].eq {
	pc = 0x82EBE368; continue 'dispatch;
	}
	// 82EBE240: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE248: 388BAD78  addi r4, r11, -0x5288
	ctx.r[4].s64 = ctx.r[11].s64 + -21128;
	// 82EBE24C: 4BDEE905  bl 0x82cacb50
	ctx.lr = 0x82EBE250;
	sub_82CACB50(ctx, base);
	// 82EBE250: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE254: 40820064  bne 0x82ebe2b8
	if !ctx.cr[0].eq {
	pc = 0x82EBE2B8; continue 'dispatch;
	}
	// 82EBE258: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE25C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBE260: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE264: 4182000C  beq 0x82ebe270
	if ctx.cr[0].eq {
	pc = 0x82EBE270; continue 'dispatch;
	}
	// 82EBE268: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE26C: 4800000C  b 0x82ebe278
	pc = 0x82EBE278; continue 'dispatch;
            }
            0x82EBE270 => {
    //   block [0x82EBE270..0x82EBE278)
	// 82EBE270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE274: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBE278; continue 'dispatch;
            }
            0x82EBE278 => {
    //   block [0x82EBE278..0x82EBE298)
	// 82EBE278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE27C: 4BA4FA8D  bl 0x8290dd08
	ctx.lr = 0x82EBE280;
	sub_8290DD08(ctx, base);
	// 82EBE280: 4BDED931  bl 0x82cabbb0
	ctx.lr = 0x82EBE284;
	sub_82CABBB0(ctx, base);
	// 82EBE284: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE28C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE290: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE294: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EBE298; continue 'dispatch;
            }
            0x82EBE298 => {
    //   block [0x82EBE298..0x82EBE2A4)
	// 82EBE298: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBE29C: 41980008  blt cr6, 0x82ebe2a4
	if ctx.cr[6].lt {
	pc = 0x82EBE2A4; continue 'dispatch;
	}
	// 82EBE2A0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBE2A4; continue 'dispatch;
            }
            0x82EBE2A4 => {
    //   block [0x82EBE2A4..0x82EBE2B0)
	// 82EBE2A4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBE2A8: 409AFFF0  bne cr6, 0x82ebe298
	if !ctx.cr[6].eq {
	pc = 0x82EBE298; continue 'dispatch;
	}
	// 82EBE2AC: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82EBE2B0; continue 'dispatch;
            }
            0x82EBE2B0 => {
    //   block [0x82EBE2B0..0x82EBE2B8)
	// 82EBE2B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE2B4: 480000C0  b 0x82ebe374
	pc = 0x82EBE374; continue 'dispatch;
            }
            0x82EBE2B8 => {
    //   block [0x82EBE2B8..0x82EBE310)
	// 82EBE2B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE2C0: 388BAD6C  addi r4, r11, -0x5294
	ctx.r[4].s64 = ctx.r[11].s64 + -21140;
	// 82EBE2C4: 4BDEE88D  bl 0x82cacb50
	ctx.lr = 0x82EBE2C8;
	sub_82CACB50(ctx, base);
	// 82EBE2C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE2CC: 4082009C  bne 0x82ebe368
	if !ctx.cr[0].eq {
	pc = 0x82EBE368; continue 'dispatch;
	}
	// 82EBE2D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBE2D4: 4BA4FA35  bl 0x8290dd08
	ctx.lr = 0x82EBE2D8;
	sub_8290DD08(ctx, base);
	// 82EBE2D8: 4BDED8D9  bl 0x82cabbb0
	ctx.lr = 0x82EBE2DC;
	sub_82CABBB0(ctx, base);
	// 82EBE2DC: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE2E0: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE2E4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82EBE2E8: 4B3A2659  bl 0x82260940
	ctx.lr = 0x82EBE2EC;
	sub_82260940(ctx, base);
	// 82EBE2EC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE2F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE2F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE2F8: C1ABDF6C  lfs f13, -0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE2FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE300: C16A0A44  lfs f11, 0xa44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2628 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE304: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EBE308: C18B89C8  lfs f12, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE30C: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EBE310; continue 'dispatch;
            }
            0x82EBE310 => {
    //   block [0x82EBE310..0x82EBE324)
	// 82EBE310: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82EBE314: 41980010  blt cr6, 0x82ebe324
	if ctx.cr[6].lt {
	pc = 0x82EBE324; continue 'dispatch;
	}
	// 82EBE318: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EBE31C: 41990008  bgt cr6, 0x82ebe324
	if ctx.cr[6].gt {
	pc = 0x82EBE324; continue 'dispatch;
	}
	// 82EBE320: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EBE324; continue 'dispatch;
            }
            0x82EBE324 => {
    //   block [0x82EBE324..0x82EBE360)
	// 82EBE324: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBE328: 409AFFE8  bne cr6, 0x82ebe310
	if !ctx.cr[6].eq {
	pc = 0x82EBE310; continue 'dispatch;
	}
	// 82EBE32C: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE330: EC2D07F2  fmuls f1, f13, f31
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE334: 4B37BB7D  bl 0x82239eb0
	ctx.lr = 0x82EBE338;
	sub_82239EB0(ctx, base);
	// 82EBE338: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE33C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE340: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE344: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE348: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE34C: 41990014  bgt cr6, 0x82ebe360
	if ctx.cr[6].gt {
	pc = 0x82EBE360; continue 'dispatch;
	}
	// 82EBE350: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE354: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE358: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE35C: 4098FF54  bge cr6, 0x82ebe2b0
	if !ctx.cr[6].lt {
	pc = 0x82EBE2B0; continue 'dispatch;
	}
	pc = 0x82EBE360; continue 'dispatch;
            }
            0x82EBE360 => {
    //   block [0x82EBE360..0x82EBE368)
	// 82EBE360: D1BE0010  stfs f13, 0x10(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBE364: 4BFFFF4C  b 0x82ebe2b0
	pc = 0x82EBE2B0; continue 'dispatch;
            }
            0x82EBE368 => {
    //   block [0x82EBE368..0x82EBE374)
	// 82EBE368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE370: 4BFF70B1  bl 0x82eb5420
	ctx.lr = 0x82EBE374;
	sub_82EB5420(ctx, base);
	pc = 0x82EBE374; continue 'dispatch;
            }
            0x82EBE374 => {
    //   block [0x82EBE374..0x82EBE380)
	// 82EBE374: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBE378: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBE37C: 4BDEB0E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE380 size=12
    let mut pc: u32 = 0x82EBE380;
    'dispatch: loop {
        match pc {
            0x82EBE380 => {
    //   block [0x82EBE380..0x82EBE38C)
	// 82EBE380: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE384: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EBE388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE390 size=808
    let mut pc: u32 = 0x82EBE390;
    'dispatch: loop {
        match pc {
            0x82EBE390 => {
    //   block [0x82EBE390..0x82EBE3EC)
	// 82EBE390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE394: 4BDEB071  bl 0x82ca9404
	ctx.lr = 0x82EBE398;
	sub_82CA93D0(ctx, base);
	// 82EBE398: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EBE39C: 4BDEF935  bl 0x82cadcd0
	ctx.lr = 0x82EBE3A0;
	sub_82CADCA0(ctx, base);
	// 82EBE3A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE3A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE3A8: C1A60004  lfs f13, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBE3B0: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82EBE3B4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82EBE3B8: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EBE3BC: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBE3C4: 409A0028  bne cr6, 0x82ebe3ec
	if !ctx.cr[6].eq {
	pc = 0x82EBE3EC; continue 'dispatch;
	}
	// 82EBE3C8: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3CC: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE3D4: 409A0018  bne cr6, 0x82ebe3ec
	if !ctx.cr[6].eq {
	pc = 0x82EBE3EC; continue 'dispatch;
	}
	// 82EBE3D8: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE3DC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EBE3E0: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE3E8: 419A0008  beq cr6, 0x82ebe3f0
	if ctx.cr[6].eq {
	pc = 0x82EBE3F0; continue 'dispatch;
	}
	pc = 0x82EBE3EC; continue 'dispatch;
            }
            0x82EBE3EC => {
    //   block [0x82EBE3EC..0x82EBE3F0)
	// 82EBE3EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EBE3F0; continue 'dispatch;
            }
            0x82EBE3F0 => {
    //   block [0x82EBE3F0..0x82EBE47C)
	// 82EBE3F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBE3F4: 408202B0  bne 0x82ebe6a4
	if !ctx.cr[0].eq {
	pc = 0x82EBE6A4; continue 'dispatch;
	}
	// 82EBE3F8: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE3FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE400: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBE408: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE40C: C186000C  lfs f12, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE410: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE414: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EBE418: C38B0C18  lfs f28, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EBE41C: D3810054  stfs f28, 0x54(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBE420: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE424: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE428: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE42C: C19E0034  lfs f12, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE430: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBE434: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBE438: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE43C: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBE440: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE444: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBE448: 4BFC7921  bl 0x82e85d68
	ctx.lr = 0x82EBE44C;
	sub_82E85D68(ctx, base);
	// 82EBE44C: C1A10084  lfs f13, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE450: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE454: C01E0044  lfs f0, 0x44(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE458: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE45C: FF406890  fmr f26, f13
	ctx.f[26].f64 = ctx.f[13].f64;
	// 82EBE460: C1AB0A44  lfs f13, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE464: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE468: 40990014  ble cr6, 0x82ebe47c
	if !ctx.cr[6].gt {
	pc = 0x82EBE47C; continue 'dispatch;
	}
	// 82EBE46C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE470: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE474: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE478: 48000028  b 0x82ebe4a0
	pc = 0x82EBE4A0; continue 'dispatch;
            }
            0x82EBE47C => {
    //   block [0x82EBE47C..0x82EBE49C)
	// 82EBE47C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE480: C1AB89C8  lfs f13, -0x7638(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE484: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBE488: 40980014  bge cr6, 0x82ebe49c
	if !ctx.cr[6].lt {
	pc = 0x82EBE49C; continue 'dispatch;
	}
	// 82EBE48C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE490: C1AB89CC  lfs f13, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE494: EFA0682A  fadds f29, f0, f13
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBE498: 48000008  b 0x82ebe4a0
	pc = 0x82EBE4A0; continue 'dispatch;
            }
            0x82EBE49C => {
    //   block [0x82EBE49C..0x82EBE4A0)
	// 82EBE49C: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	pc = 0x82EBE4A0; continue 'dispatch;
            }
            0x82EBE4A0 => {
    //   block [0x82EBE4A0..0x82EBE4FC)
	// 82EBE4A0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBE4A4: C00BDF6C  lfs f0, -0x2094(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE4AC: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EBE4B0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4B4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE4B8: 4B37B9F9  bl 0x82239eb0
	ctx.lr = 0x82EBE4BC;
	sub_82239EB0(ctx, base);
	// 82EBE4BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE4C0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE4C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE4C8: 388BC904  addi r4, r11, -0x36fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14076;
	// 82EBE4CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE4D0: EF6007F2  fmuls f27, f0, f31
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBE4D4: 4BFBF1ED  bl 0x82e7d6c0
	ctx.lr = 0x82EBE4D8;
	sub_82E7D6C0(ctx, base);
	// 82EBE4D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE4DC: 418200F4  beq 0x82ebe5d0
	if ctx.cr[0].eq {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE4E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE4E4: 895D0014  lbz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE4E8: C1BD000C  lfs f13, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE4EC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE4F0: C00B0C80  lfs f0, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE4F4: 41820008  beq 0x82ebe4fc
	if ctx.cr[0].eq {
	pc = 0x82EBE4FC; continue 'dispatch;
	}
	// 82EBE4F8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EBE4FC; continue 'dispatch;
            }
            0x82EBE4FC => {
    //   block [0x82EBE4FC..0x82EBE510)
	// 82EBE4FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EBE500: 419A0010  beq cr6, 0x82ebe510
	if ctx.cr[6].eq {
	pc = 0x82EBE510; continue 'dispatch;
	}
	// 82EBE504: C19D0010  lfs f12, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE508: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE50C: 48000008  b 0x82ebe514
	pc = 0x82EBE514; continue 'dispatch;
            }
            0x82EBE510 => {
    //   block [0x82EBE510..0x82EBE514)
	// 82EBE510: C3FD0010  lfs f31, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBE514; continue 'dispatch;
            }
            0x82EBE514 => {
    //   block [0x82EBE514..0x82EBE550)
	// 82EBE514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE518: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 82EBE51C: 997D0014  stb r11, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EBE520: 409900B0  ble cr6, 0x82ebe5d0
	if !ctx.cr[6].gt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE524: FF1E6800  fcmpu cr6, f30, f13
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[13].f64);
	// 82EBE528: 409800A8  bge cr6, 0x82ebe5d0
	if !ctx.cr[6].lt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE52C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE530: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE534: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EBE538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE53C: 4B32A13D  bl 0x821e8678
	ctx.lr = 0x82EBE540;
	sub_821E8678(ctx, base);
	// 82EBE540: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE544: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EBE548: 40820008  bne 0x82ebe550
	if !ctx.cr[0].eq {
	pc = 0x82EBE550; continue 'dispatch;
	}
	// 82EBE54C: 397E004C  addi r11, r30, 0x4c
	ctx.r[11].s64 = ctx.r[30].s64 + 76;
	pc = 0x82EBE550; continue 'dispatch;
            }
            0x82EBE550 => {
    //   block [0x82EBE550..0x82EBE5D0)
	// 82EBE550: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE554: ED7F07B2  fmuls f11, f31, f30
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EBE558: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBE55C: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBE560: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE564: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE568: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBE56C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBE570: 40980060  bge cr6, 0x82ebe5d0
	if !ctx.cr[6].lt {
	pc = 0x82EBE5D0; continue 'dispatch;
	}
	// 82EBE574: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE578: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EBE57C: 9B7D0014  stb r27, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82EBE580: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE584: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBE588: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EBE58C: C1AB03B0  lfs f13, 0x3b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(944 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE590: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBE594: C18B03AC  lfs f12, 0x3ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE598: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE59C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBE5A0: C18B03A8  lfs f12, 0x3a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBE5A4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBE5A8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBE5AC: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EBE5B0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBE5B4: 4BFC77B5  bl 0x82e85d68
	ctx.lr = 0x82EBE5B8;
	sub_82E85D68(ctx, base);
	// 82EBE5B8: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE5BC: 9B7F0004  stb r27, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE5C0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBE5C4: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE5C8: 9B7F0004  stb r27, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE5CC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EBE5D0; continue 'dispatch;
            }
            0x82EBE5D0 => {
    //   block [0x82EBE5D0..0x82EBE618)
	// 82EBE5D0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE5D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE5D8: 388BC6DC  addi r4, r11, -0x3924
	ctx.r[4].s64 = ctx.r[11].s64 + -14628;
	// 82EBE5DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE5E0: 4BFBF0E1  bl 0x82e7d6c0
	ctx.lr = 0x82EBE5E4;
	sub_82E7D6C0(ctx, base);
	// 82EBE5E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE5E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE5EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE5F0: C3CA0EE0  lfs f30, 0xee0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3808 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBE5F4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE5F8: 40820044  bne 0x82ebe63c
	if !ctx.cr[0].eq {
	pc = 0x82EBE63C; continue 'dispatch;
	}
	// 82EBE5FC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE600: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE604: 388BCB2C  addi r4, r11, -0x34d4
	ctx.r[4].s64 = ctx.r[11].s64 + -13524;
	// 82EBE608: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE60C: 4BFBF0B5  bl 0x82e7d6c0
	ctx.lr = 0x82EBE610;
	sub_82E7D6C0(ctx, base);
	// 82EBE610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE614: 4082000C  bne 0x82ebe620
	if !ctx.cr[0].eq {
	pc = 0x82EBE620; continue 'dispatch;
	}
	pc = 0x82EBE618; continue 'dispatch;
            }
            0x82EBE618 => {
    //   block [0x82EBE618..0x82EBE620)
	// 82EBE618: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBE61C: 4800008C  b 0x82ebe6a8
	pc = 0x82EBE6A8; continue 'dispatch;
            }
            0x82EBE620 => {
    //   block [0x82EBE620..0x82EBE634)
	// 82EBE620: FF1DE000  fcmpu cr6, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[28].f64);
	// 82EBE624: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE628: 4099000C  ble cr6, 0x82ebe634
	if !ctx.cr[6].gt {
	pc = 0x82EBE634; continue 'dispatch;
	}
	// 82EBE62C: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE630: 48000014  b 0x82ebe644
	pc = 0x82EBE644; continue 'dispatch;
            }
            0x82EBE634 => {
    //   block [0x82EBE634..0x82EBE63C)
	// 82EBE634: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE638: 4800000C  b 0x82ebe644
	pc = 0x82EBE644; continue 'dispatch;
            }
            0x82EBE63C => {
    //   block [0x82EBE63C..0x82EBE644)
	// 82EBE63C: D3430008  stfs f26, 8(r3)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE640: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EBE644; continue 'dispatch;
            }
            0x82EBE644 => {
    //   block [0x82EBE644..0x82EBE694)
	// 82EBE644: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE648: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE64C: 388BC7F0  addi r4, r11, -0x3810
	ctx.r[4].s64 = ctx.r[11].s64 + -14352;
	// 82EBE650: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE654: 4BFBF06D  bl 0x82e7d6c0
	ctx.lr = 0x82EBE658;
	sub_82E7D6C0(ctx, base);
	// 82EBE658: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE65C: 40820040  bne 0x82ebe69c
	if !ctx.cr[0].eq {
	pc = 0x82EBE69C; continue 'dispatch;
	}
	// 82EBE660: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBE664: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBE668: 388BCF7C  addi r4, r11, -0x3084
	ctx.r[4].s64 = ctx.r[11].s64 + -12420;
	// 82EBE66C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EBE670: 4BFBF051  bl 0x82e7d6c0
	ctx.lr = 0x82EBE674;
	sub_82E7D6C0(ctx, base);
	// 82EBE674: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBE678: 4182FFA0  beq 0x82ebe618
	if ctx.cr[0].eq {
	pc = 0x82EBE618; continue 'dispatch;
	}
	// 82EBE67C: C01E0058  lfs f0, 0x58(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBE680: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 82EBE684: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EBE688: 4099000C  ble cr6, 0x82ebe694
	if !ctx.cr[6].gt {
	pc = 0x82EBE694; continue 'dispatch;
	}
	// 82EBE68C: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE690: 48000014  b 0x82ebe6a4
	pc = 0x82EBE6A4; continue 'dispatch;
            }
            0x82EBE694 => {
    //   block [0x82EBE694..0x82EBE69C)
	// 82EBE694: D3C30008  stfs f30, 8(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE698: 4800000C  b 0x82ebe6a4
	pc = 0x82EBE6A4; continue 'dispatch;
            }
            0x82EBE69C => {
    //   block [0x82EBE69C..0x82EBE6A4)
	// 82EBE69C: D3630008  stfs f27, 8(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBE6A0: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	pc = 0x82EBE6A4; continue 'dispatch;
            }
            0x82EBE6A4 => {
    //   block [0x82EBE6A4..0x82EBE6A8)
	// 82EBE6A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EBE6A8; continue 'dispatch;
            }
            0x82EBE6A8 => {
    //   block [0x82EBE6A8..0x82EBE6B8)
	// 82EBE6A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EBE6AC: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EBE6B0: 4BDEF66D  bl 0x82cadd1c
	ctx.lr = 0x82EBE6B4;
	sub_82CADCEC(ctx, base);
	// 82EBE6B4: 4BDEADA0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE6B8 size=24
    let mut pc: u32 = 0x82EBE6B8;
    'dispatch: loop {
        match pc {
            0x82EBE6B8 => {
    //   block [0x82EBE6B8..0x82EBE6D0)
	// 82EBE6B8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EBE6BC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82EBE6C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBE6C4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBE6C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBE6CC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE6D0 size=12
    let mut pc: u32 = 0x82EBE6D0;
    'dispatch: loop {
        match pc {
            0x82EBE6D0 => {
    //   block [0x82EBE6D0..0x82EBE6DC)
	// 82EBE6D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBE6D4: 386BCF04  addi r3, r11, -0x30fc
	ctx.r[3].s64 = ctx.r[11].s64 + -12540;
	// 82EBE6D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBE6E0 size=84
    let mut pc: u32 = 0x82EBE6E0;
    'dispatch: loop {
        match pc {
            0x82EBE6E0 => {
    //   block [0x82EBE6E0..0x82EBE728)
	// 82EBE6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE6E4: 4BDEAD29  bl 0x82ca940c
	ctx.lr = 0x82EBE6E8;
	sub_82CA93D0(ctx, base);
	// 82EBE6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE6EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE6F0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EBE6F4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EBE6F8: 4B758231  bl 0x82616928
	ctx.lr = 0x82EBE6FC;
	sub_82616928(ctx, base);
	// 82EBE6FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EBE700: 41820028  beq 0x82ebe728
	if ctx.cr[0].eq {
	pc = 0x82EBE728; continue 'dispatch;
	}
	// 82EBE704: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBE708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBE70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE710: 4BFF6C21  bl 0x82eb5330
	ctx.lr = 0x82EBE714;
	sub_82EB5330(ctx, base);
	// 82EBE714: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE71C: 396BADA4  addi r11, r11, -0x525c
	ctx.r[11].s64 = ctx.r[11].s64 + -21084;
	// 82EBE720: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EBE724: 48000008  b 0x82ebe72c
	pc = 0x82EBE72C; continue 'dispatch;
            }
            0x82EBE728 => {
    //   block [0x82EBE728..0x82EBE72C)
	// 82EBE728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBE72C; continue 'dispatch;
            }
            0x82EBE72C => {
    //   block [0x82EBE72C..0x82EBE734)
	// 82EBE72C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE730: 4BDEAD2C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBE740 size=52
    let mut pc: u32 = 0x82EBE740;
    'dispatch: loop {
        match pc {
            0x82EBE740 => {
    //   block [0x82EBE740..0x82EBE774)
	// 82EBE740: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE744: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82EBE748: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82EBE74C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBE750: C02B0010  lfs f1, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBE754: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBE758: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE75C: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82EBE760: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE764: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBE768: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE76C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBE770: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE778 size=448
    let mut pc: u32 = 0x82EBE778;
    'dispatch: loop {
        match pc {
            0x82EBE778 => {
    //   block [0x82EBE778..0x82EBE7C8)
	// 82EBE778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE77C: 4BDEAC91  bl 0x82ca940c
	ctx.lr = 0x82EBE780;
	sub_82CA93D0(ctx, base);
	// 82EBE780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE784: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBE788: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EBE78C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE794: 3BABAE40  addi r29, r11, -0x51c0
	ctx.r[29].s64 = ctx.r[11].s64 + -20928;
	// 82EBE798: 482FD8C9  bl 0x831bc060
	ctx.lr = 0x82EBE79C;
	sub_831BC060(ctx, base);
	// 82EBE79C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE7A0: 4BDEE3B1  bl 0x82cacb50
	ctx.lr = 0x82EBE7A4;
	sub_82CACB50(ctx, base);
	// 82EBE7A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE7AC: 4082001C  bne 0x82ebe7c8
	if !ctx.cr[0].eq {
	pc = 0x82EBE7C8; continue 'dispatch;
	}
	// 82EBE7B0: 4BA4F559  bl 0x8290dd08
	ctx.lr = 0x82EBE7B4;
	sub_8290DD08(ctx, base);
	// 82EBE7B4: 4BDED3FD  bl 0x82cabbb0
	ctx.lr = 0x82EBE7B8;
	sub_82CABBB0(ctx, base);
	// 82EBE7B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE7BC: D01E00D8  stfs f0, 0xd8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EBE7C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE7C4: 4800016C  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE7C8 => {
    //   block [0x82EBE7C8..0x82EBE800)
	// 82EBE7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE7CC: 3BABAE30  addi r29, r11, -0x51d0
	ctx.r[29].s64 = ctx.r[11].s64 + -20944;
	// 82EBE7D0: 482FD891  bl 0x831bc060
	ctx.lr = 0x82EBE7D4;
	sub_831BC060(ctx, base);
	// 82EBE7D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE7D8: 4BDEE379  bl 0x82cacb50
	ctx.lr = 0x82EBE7DC;
	sub_82CACB50(ctx, base);
	// 82EBE7DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE7E4: 4082001C  bne 0x82ebe800
	if !ctx.cr[0].eq {
	pc = 0x82EBE800; continue 'dispatch;
	}
	// 82EBE7E8: 4BA4F521  bl 0x8290dd08
	ctx.lr = 0x82EBE7EC;
	sub_8290DD08(ctx, base);
	// 82EBE7EC: 4BDED3C5  bl 0x82cabbb0
	ctx.lr = 0x82EBE7F0;
	sub_82CABBB0(ctx, base);
	// 82EBE7F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE7F4: D01E00D4  stfs f0, 0xd4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EBE7F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE7FC: 48000134  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE800 => {
    //   block [0x82EBE800..0x82EBE838)
	// 82EBE800: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE804: 3BABAE20  addi r29, r11, -0x51e0
	ctx.r[29].s64 = ctx.r[11].s64 + -20960;
	// 82EBE808: 482FD859  bl 0x831bc060
	ctx.lr = 0x82EBE80C;
	sub_831BC060(ctx, base);
	// 82EBE80C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE810: 4BDEE341  bl 0x82cacb50
	ctx.lr = 0x82EBE814;
	sub_82CACB50(ctx, base);
	// 82EBE814: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE81C: 4082001C  bne 0x82ebe838
	if !ctx.cr[0].eq {
	pc = 0x82EBE838; continue 'dispatch;
	}
	// 82EBE820: 4BA4F4E9  bl 0x8290dd08
	ctx.lr = 0x82EBE824;
	sub_8290DD08(ctx, base);
	// 82EBE824: 4BDED38D  bl 0x82cabbb0
	ctx.lr = 0x82EBE828;
	sub_82CABBB0(ctx, base);
	// 82EBE828: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE82C: D01E00DC  stfs f0, 0xdc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EBE830: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE834: 480000FC  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE838 => {
    //   block [0x82EBE838..0x82EBE870)
	// 82EBE838: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE83C: 3BABAE10  addi r29, r11, -0x51f0
	ctx.r[29].s64 = ctx.r[11].s64 + -20976;
	// 82EBE840: 482FD821  bl 0x831bc060
	ctx.lr = 0x82EBE844;
	sub_831BC060(ctx, base);
	// 82EBE844: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE848: 4BDEE309  bl 0x82cacb50
	ctx.lr = 0x82EBE84C;
	sub_82CACB50(ctx, base);
	// 82EBE84C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE854: 4082001C  bne 0x82ebe870
	if !ctx.cr[0].eq {
	pc = 0x82EBE870; continue 'dispatch;
	}
	// 82EBE858: 4BA4F4B1  bl 0x8290dd08
	ctx.lr = 0x82EBE85C;
	sub_8290DD08(ctx, base);
	// 82EBE85C: 4BDED355  bl 0x82cabbb0
	ctx.lr = 0x82EBE860;
	sub_82CABBB0(ctx, base);
	// 82EBE860: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE864: D01E00E0  stfs f0, 0xe0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EBE868: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE86C: 480000C4  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE870 => {
    //   block [0x82EBE870..0x82EBE8A8)
	// 82EBE870: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE874: 3BABAE00  addi r29, r11, -0x5200
	ctx.r[29].s64 = ctx.r[11].s64 + -20992;
	// 82EBE878: 482FD7E9  bl 0x831bc060
	ctx.lr = 0x82EBE87C;
	sub_831BC060(ctx, base);
	// 82EBE87C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE880: 4BDEE2D1  bl 0x82cacb50
	ctx.lr = 0x82EBE884;
	sub_82CACB50(ctx, base);
	// 82EBE884: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE88C: 4082001C  bne 0x82ebe8a8
	if !ctx.cr[0].eq {
	pc = 0x82EBE8A8; continue 'dispatch;
	}
	// 82EBE890: 4BA4F479  bl 0x8290dd08
	ctx.lr = 0x82EBE894;
	sub_8290DD08(ctx, base);
	// 82EBE894: 4BDED31D  bl 0x82cabbb0
	ctx.lr = 0x82EBE898;
	sub_82CABBB0(ctx, base);
	// 82EBE898: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE89C: D01E00E4  stfs f0, 0xe4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EBE8A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE8A4: 4800008C  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE8A8 => {
    //   block [0x82EBE8A8..0x82EBE8E0)
	// 82EBE8A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE8AC: 3BABADEC  addi r29, r11, -0x5214
	ctx.r[29].s64 = ctx.r[11].s64 + -21012;
	// 82EBE8B0: 482FD7B1  bl 0x831bc060
	ctx.lr = 0x82EBE8B4;
	sub_831BC060(ctx, base);
	// 82EBE8B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE8B8: 4BDEE299  bl 0x82cacb50
	ctx.lr = 0x82EBE8BC;
	sub_82CACB50(ctx, base);
	// 82EBE8BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE8C4: 4082001C  bne 0x82ebe8e0
	if !ctx.cr[0].eq {
	pc = 0x82EBE8E0; continue 'dispatch;
	}
	// 82EBE8C8: 4BA4F441  bl 0x8290dd08
	ctx.lr = 0x82EBE8CC;
	sub_8290DD08(ctx, base);
	// 82EBE8CC: 4BDED2E5  bl 0x82cabbb0
	ctx.lr = 0x82EBE8D0;
	sub_82CABBB0(ctx, base);
	// 82EBE8D0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE8D4: D01E00E8  stfs f0, 0xe8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EBE8D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE8DC: 48000054  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE8E0 => {
    //   block [0x82EBE8E0..0x82EBE924)
	// 82EBE8E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE8E4: 3BABADD4  addi r29, r11, -0x522c
	ctx.r[29].s64 = ctx.r[11].s64 + -21036;
	// 82EBE8E8: 482FD779  bl 0x831bc060
	ctx.lr = 0x82EBE8EC;
	sub_831BC060(ctx, base);
	// 82EBE8EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBE8F0: 4BDEE261  bl 0x82cacb50
	ctx.lr = 0x82EBE8F4;
	sub_82CACB50(ctx, base);
	// 82EBE8F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBE8F8: 4082002C  bne 0x82ebe924
	if !ctx.cr[0].eq {
	pc = 0x82EBE924; continue 'dispatch;
	}
	// 82EBE8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBE900: 4BA4F409  bl 0x8290dd08
	ctx.lr = 0x82EBE904;
	sub_8290DD08(ctx, base);
	// 82EBE904: 4BDED2AD  bl 0x82cabbb0
	ctx.lr = 0x82EBE908;
	sub_82CABBB0(ctx, base);
	// 82EBE908: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBE90C: C1BE0018  lfs f13, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBE910: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBE914: D01E00EC  stfs f0, 0xec(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EBE918: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBE91C: D01E00D0  stfs f0, 0xd0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EBE920: 48000010  b 0x82ebe930
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE924 => {
    //   block [0x82EBE924..0x82EBE930)
	// 82EBE924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBE928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBE92C: 4BFFF6E5  bl 0x82ebe010
	ctx.lr = 0x82EBE930;
	sub_82EBE010(ctx, base);
	pc = 0x82EBE930; continue 'dispatch;
            }
            0x82EBE930 => {
    //   block [0x82EBE930..0x82EBE938)
	// 82EBE930: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBE934: 4BDEAB28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE938 size=4
    let mut pc: u32 = 0x82EBE938;
    'dispatch: loop {
        match pc {
            0x82EBE938 => {
    //   block [0x82EBE938..0x82EBE93C)
	// 82EBE938: 4BFFFE00  b 0x82ebe738
	crate::recompiler::externs::call(ctx, base, 0x82EBE738);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBE940 size=16
    let mut pc: u32 = 0x82EBE940;
    'dispatch: loop {
        match pc {
            0x82EBE940 => {
    //   block [0x82EBE940..0x82EBE950)
	// 82EBE940: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE944: 996300C8  stb r11, 0xc8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBE948: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBE94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBE950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBE950 size=544
    let mut pc: u32 = 0x82EBE950;
    'dispatch: loop {
        match pc {
            0x82EBE950 => {
    //   block [0x82EBE950..0x82EBEA14)
	// 82EBE950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBE954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBE958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBE95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBE960: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EBE964: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EBE968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBE96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBE970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBE974: 4BFF69BD  bl 0x82eb5330
	ctx.lr = 0x82EBE978;
	sub_82EB5330(ctx, base);
	// 82EBE978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBE97C: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBE980: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBE984: 394BAE50  addi r10, r11, -0x51b0
	ctx.r[10].s64 = ctx.r[11].s64 + -20912;
	// 82EBE988: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBE98C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EBE990: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EBE994: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBE998: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EBE99C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBE9A0: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBE9A4: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBE9A8: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBE9AC: D3FF0024  stfs f31, 0x24(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBE9B0: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82EBE9B4: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EBE9B8: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EBE9BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBE9C0: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EBE9C4: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82EBE9C8: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EBE9CC: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EBE9D0: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EBE9D4: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EBE9D8: D3FF0048  stfs f31, 0x48(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EBE9DC: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EBE9E0: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBE9E4: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBE9E8: D3FF00BC  stfs f31, 0xbc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EBE9EC: D3FF00C0  stfs f31, 0xc0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EBE9F0: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBE9F4: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82EBE9F8: D3FF00CC  stfs f31, 0xcc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBE9FC: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBEA00: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBEA04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEA08: 4182000C  beq 0x82ebea14
	if ctx.cr[0].eq {
	pc = 0x82EBEA14; continue 'dispatch;
	}
	// 82EBEA0C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEA10: 48000008  b 0x82ebea18
	pc = 0x82EBEA18; continue 'dispatch;
            }
            0x82EBEA14 => {
    //   block [0x82EBEA14..0x82EBEA18)
	// 82EBEA14: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	pc = 0x82EBEA18; continue 'dispatch;
            }
            0x82EBEA18 => {
    //   block [0x82EBEA18..0x82EBEAC0)
	// 82EBEA18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA1C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EBEA20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EBEA24: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82EBEA28: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEA2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA30: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEA34: D15F00D0  stfs f10, 0xd0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EBEA38: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EBEA3C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEA40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA44: D1BF00D4  stfs f13, 0xd4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EBEA48: D1BF00E4  stfs f13, 0xe4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EBEA4C: C18B0BF8  lfs f12, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEA50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA54: D19F00D8  stfs f12, 0xd8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EBEA58: C16B0EE0  lfs f11, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEA5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA60: D17F00DC  stfs f11, 0xdc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EBEA64: C14B0A7C  lfs f10, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEA68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBEA6C: D15F00E8  stfs f10, 0xe8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EBEA70: C18BBE10  lfs f12, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEA74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEA78: D19F00EC  stfs f12, 0xec(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EBEA7C: D19F00F4  stfs f12, 0xf4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EBEA80: C00B0B64  lfs f0, 0xb64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEA84: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EBEA88: 4BDEAF29  bl 0x82ca99b0
	ctx.lr = 0x82EBEA8C;
	sub_82CA99B0(ctx, base);
	// 82EBEA8C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEA90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEA94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEA98: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EBEA9C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEAA0: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBEAA4: 4B329BD5  bl 0x821e8678
	ctx.lr = 0x82EBEAA8;
	sub_821E8678(ctx, base);
	// 82EBEAA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEAAC: 41820014  beq 0x82ebeac0
	if ctx.cr[0].eq {
	pc = 0x82EBEAC0; continue 'dispatch;
	}
	// 82EBEAB0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEAB4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBEAB8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EBEABC: 409A0020  bne cr6, 0x82ebeadc
	if !ctx.cr[6].eq {
	pc = 0x82EBEADC; continue 'dispatch;
	}
	pc = 0x82EBEAC0; continue 'dispatch;
            }
            0x82EBEAC0 => {
    //   block [0x82EBEAC0..0x82EBEAD4)
	// 82EBEAC0: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBEAC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEAC8: 4182000C  beq 0x82ebead4
	if ctx.cr[0].eq {
	pc = 0x82EBEAD4; continue 'dispatch;
	}
	// 82EBEACC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEAD0: 48000008  b 0x82ebead8
	pc = 0x82EBEAD8; continue 'dispatch;
            }
            0x82EBEAD4 => {
    //   block [0x82EBEAD4..0x82EBEAD8)
	// 82EBEAD4: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x82EBEAD8; continue 'dispatch;
            }
            0x82EBEAD8 => {
    //   block [0x82EBEAD8..0x82EBEADC)
	// 82EBEAD8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82EBEADC; continue 'dispatch;
            }
            0x82EBEADC => {
    //   block [0x82EBEADC..0x82EBEB08)
	// 82EBEADC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEAE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEAE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEAE8: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EBEAEC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEAF0: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBEAF4: 4B329B85  bl 0x821e8678
	ctx.lr = 0x82EBEAF8;
	sub_821E8678(ctx, base);
	// 82EBEAF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEAFC: 4182000C  beq 0x82ebeb08
	if ctx.cr[0].eq {
	pc = 0x82EBEB08; continue 'dispatch;
	}
	// 82EBEB00: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEB04: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x82EBEB08; continue 'dispatch;
            }
            0x82EBEB08 => {
    //   block [0x82EBEB08..0x82EBEB34)
	// 82EBEB08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEB0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEB10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEB14: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EBEB18: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEB1C: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBEB20: 4B329B59  bl 0x821e8678
	ctx.lr = 0x82EBEB24;
	sub_821E8678(ctx, base);
	// 82EBEB24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEB28: 4182000C  beq 0x82ebeb34
	if ctx.cr[0].eq {
	pc = 0x82EBEB34; continue 'dispatch;
	}
	// 82EBEB2C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEB30: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	pc = 0x82EBEB34; continue 'dispatch;
            }
            0x82EBEB34 => {
    //   block [0x82EBEB34..0x82EBEB70)
	// 82EBEB34: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEB38: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBEB3C: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EBEB40: 4B3A90E1  bl 0x82267c20
	ctx.lr = 0x82EBEB44;
	sub_82267C20(ctx, base);
	// 82EBEB44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBEB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBEB4C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EBEB50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBEB54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBEB58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBEB5C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBEB60: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EBEB64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBEB68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBEB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBEB70 size=12
    let mut pc: u32 = 0x82EBEB70;
    'dispatch: loop {
        match pc {
            0x82EBEB70 => {
    //   block [0x82EBEB70..0x82EBEB7C)
	// 82EBEB70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBEB74: 386BD018  addi r3, r11, -0x2fe8
	ctx.r[3].s64 = ctx.r[11].s64 + -12264;
	// 82EBEB78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEB80 size=32
    let mut pc: u32 = 0x82EBEB80;
    'dispatch: loop {
        match pc {
            0x82EBEB80 => {
    //   block [0x82EBEB80..0x82EBEBA0)
	// 82EBEB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEB84: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEB88: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EBEB8C: 409A0024  bne cr6, 0x82ebebb0
	if !ctx.cr[6].eq {
		sub_82EBEBA0(ctx, base);
		return;
	}
	// 82EBEB90: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EBEB94: 409A000C  bne cr6, 0x82ebeba0
	if !ctx.cr[6].eq {
		sub_82EBEBA0(ctx, base);
		return;
	}
	// 82EBEB98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EBEB9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEBA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEBA0 size=96
    let mut pc: u32 = 0x82EBEBA0;
    'dispatch: loop {
        match pc {
            0x82EBEBA0 => {
    //   block [0x82EBEBA0..0x82EBEBF4)
	// 82EBEBA0: EC031024  fdivs f0, f3, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[3].f64 / ctx.f[2].f64) as f32) as f64;
	// 82EBEBA4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EBEBA8: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EBEBAC: 48000048  b 0x82ebebf4
	pc = 0x82EBEBF4; continue 'dispatch;
	// 82EBEBB0: ED8100F2  fmuls f12, f1, f3
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[3].f64) as f32) as f64);
	// 82EBEBB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEBB8: C1AB0A4C  lfs f13, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEBBC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEBC0: EDA268B8  fmsubs f13, f2, f2, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEBC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBEBC8: 4198FFD0  blt cr6, 0x82ebeb98
	if ctx.cr[6].lt {
		sub_82EBEB80(ctx, base);
		return;
	}
	// 82EBEBCC: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82EBEBD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEBD4: FD801050  fneg f12, f2
	ctx.f[12].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EBEBD8: ED6D1028  fsubs f11, f13, f2
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 82EBEBDC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEBE0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEBE4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEBE8: ED8B0024  fdivs f12, f11, f0
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEBEC: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EBEBF0: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
            }
            0x82EBEBF4 => {
    //   block [0x82EBEBF4..0x82EBEC00)
	// 82EBEBF4: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EBEBF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBEBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBEC00 size=96
    let mut pc: u32 = 0x82EBEC00;
    'dispatch: loop {
        match pc {
            0x82EBEC00 => {
    //   block [0x82EBEC00..0x82EBEC60)
	// 82EBEC00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEC04: C0E50000  lfs f7, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBEC08: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEC0C: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEC10: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEC14: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEC18: C10B0A98  lfs f8, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBEC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEC20: ED070232  fmuls f8, f7, f8
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EBEC24: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEC28: ECEB02F2  fmuls f7, f11, f11
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEC2C: C1240008  lfs f9, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBEC30: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEC34: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEC38: ECED3B7A  fmadds f7, f13, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EBEC3C: EDAD583A  fmadds f13, f13, f0, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EBEC40: EC00603A  fmadds f0, f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EBEC44: ED893A7A  fmadds f12, f9, f9, f7
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EBEC48: EDA96ABA  fmadds f13, f9, f10, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBEC4C: EC2A02BA  fmadds f1, f10, f10, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEC50: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEC54: EC68623C  fnmsubs f3, f8, f8, f12
	ctx.f[3].f64 = -(((ctx.f[8].f64 * ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBEC58: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEC5C: 4BFFFF24  b 0x82ebeb80
	sub_82EBEB80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBEC60 size=88
    let mut pc: u32 = 0x82EBEC60;
    'dispatch: loop {
        match pc {
            0x82EBEC60 => {
    //   block [0x82EBEC60..0x82EBEC9C)
	// 82EBEC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBEC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBEC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBEC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBEC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBEC74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBEC78: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 82EBEC7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBEC80: 4B757CA9  bl 0x82616928
	ctx.lr = 0x82EBEC84;
	sub_82616928(ctx, base);
	// 82EBEC84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEC88: 41820014  beq 0x82ebec9c
	if ctx.cr[0].eq {
	pc = 0x82EBEC9C; continue 'dispatch;
	}
	// 82EBEC8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBEC90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBEC94: 4BFFFCBD  bl 0x82ebe950
	ctx.lr = 0x82EBEC98;
	sub_82EBE950(ctx, base);
	// 82EBEC98: 48000008  b 0x82ebeca0
	pc = 0x82EBECA0; continue 'dispatch;
            }
            0x82EBEC9C => {
    //   block [0x82EBEC9C..0x82EBECA0)
	// 82EBEC9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBECA0; continue 'dispatch;
            }
            0x82EBECA0 => {
    //   block [0x82EBECA0..0x82EBECB8)
	// 82EBECA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBECA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBECA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBECAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBECB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBECB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBECB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBECB8 size=820
    let mut pc: u32 = 0x82EBECB8;
    'dispatch: loop {
        match pc {
            0x82EBECB8 => {
    //   block [0x82EBECB8..0x82EBED10)
	// 82EBECB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBECBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBECC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBECC4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EBECC8: 4BDEEFFD  bl 0x82cadcc4
	ctx.lr = 0x82EBECCC;
	sub_82CADCA0(ctx, base);
	// 82EBECCC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBECD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBECD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBECD8: C36B0C18  lfs f27, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EBECDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBECE0: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBECE4: FDA0D890  fmr f13, f27
	ctx.f[13].f64 = ctx.f[27].f64;
	// 82EBECE8: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 82EBECEC: FD60D890  fmr f11, f27
	ctx.f[11].f64 = ctx.f[27].f64;
	// 82EBECF0: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBECF4: C34B0C14  lfs f26, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EBECF8: 40810070  ble 0x82ebed68
	if !ctx.cr[0].gt {
	pc = 0x82EBED68; continue 'dispatch;
	}
	// 82EBECFC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBED00: 393F0058  addi r9, r31, 0x58
	ctx.r[9].s64 = ctx.r[31].s64 + 88;
	// 82EBED04: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBED08: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBED0C: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	pc = 0x82EBED10; continue 'dispatch;
            }
            0x82EBED10 => {
    //   block [0x82EBED10..0x82EBED5C)
	// 82EBED10: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBED14: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBED18: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBED1C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBED20: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBED24: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBED28: ED060028  fsubs f8, f6, f0
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBED2C: EC090272  fmuls f0, f9, f9
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EBED30: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED34: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED38: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBED3C: 40990020  ble cr6, 0x82ebed5c
	if !ctx.cr[6].gt {
	pc = 0x82EBED5C; continue 'dispatch;
	}
	// 82EBED40: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBED44: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBED48: ED000232  fmuls f8, f0, f8
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EBED4C: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EBED50: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBED54: ED88602A  fadds f12, f8, f12
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBED58: ED60582A  fadds f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82EBED5C; continue 'dispatch;
            }
            0x82EBED5C => {
    //   block [0x82EBED5C..0x82EBED68)
	// 82EBED5C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EBED60: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EBED64: 4082FFAC  bne 0x82ebed10
	if !ctx.cr[0].eq {
	pc = 0x82EBED10; continue 'dispatch;
	}
	pc = 0x82EBED68; continue 'dispatch;
            }
            0x82EBED68 => {
    //   block [0x82EBED68..0x82EBED94)
	// 82EBED68: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBED6C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED70: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBED74: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBED78: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBED7C: 40990018  ble cr6, 0x82ebed94
	if !ctx.cr[6].gt {
	pc = 0x82EBED94; continue 'dispatch;
	}
	// 82EBED80: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBED84: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBED88: EEE00332  fmuls f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBED8C: EF0002F2  fmuls f24, f0, f11
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBED90: 48000010  b 0x82ebeda0
	pc = 0x82EBEDA0; continue 'dispatch;
            }
            0x82EBED94 => {
    //   block [0x82EBED94..0x82EBEDA0)
	// 82EBED94: FF20D890  fmr f25, f27
	ctx.f[25].f64 = ctx.f[27].f64;
	// 82EBED98: FEE0D890  fmr f23, f27
	ctx.f[23].f64 = ctx.f[27].f64;
	// 82EBED9C: FF00D890  fmr f24, f27
	ctx.f[24].f64 = ctx.f[27].f64;
	pc = 0x82EBEDA0; continue 'dispatch;
            }
            0x82EBEDA0 => {
    //   block [0x82EBEDA0..0x82EBEDF4)
	// 82EBEDA0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBEDA4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEDA8: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEDAC: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEDB0: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEDB4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEDB8: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEDBC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBEDC0: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEDC4: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEDC8: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEDCC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEDD0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEDD4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBEDD8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEDDC: 40990018  ble cr6, 0x82ebedf4
	if !ctx.cr[6].gt {
	pc = 0x82EBEDF4; continue 'dispatch;
	}
	// 82EBEDE0: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEDE4: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEDE8: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEDEC: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEDF0: 48000010  b 0x82ebee00
	pc = 0x82EBEE00; continue 'dispatch;
            }
            0x82EBEDF4 => {
    //   block [0x82EBEDF4..0x82EBEE00)
	// 82EBEDF4: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82EBEDF8: FFA0D890  fmr f29, f27
	ctx.f[29].f64 = ctx.f[27].f64;
	// 82EBEDFC: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	pc = 0x82EBEE00; continue 'dispatch;
            }
            0x82EBEE00 => {
    //   block [0x82EBEE00..0x82EBEE74)
	// 82EBEE00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBEE04: C39F00D4  lfs f28, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EBEE08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBEE0C: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EBEE10: 4B329869  bl 0x821e8678
	ctx.lr = 0x82EBEE14;
	sub_821E8678(ctx, base);
	// 82EBEE14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEE18: 4182010C  beq 0x82ebef24
	if ctx.cr[0].eq {
	pc = 0x82EBEF24; continue 'dispatch;
	}
	// 82EBEE1C: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBEE20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBEE24: 41820100  beq 0x82ebef24
	if ctx.cr[0].eq {
	pc = 0x82EBEF24; continue 'dispatch;
	}
	// 82EBEE28: ED9D0672  fmuls f12, f29, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EBEE2C: EC1E05F2  fmuls f0, f30, f23
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[23].f64) as f32) as f64);
	// 82EBEE30: ED5807F2  fmuls f10, f24, f31
	ctx.f[10].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEE34: ED7767F8  fmsubs f11, f23, f31, f12
	ctx.f[11].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBEE38: EDBD0638  fmsubs f13, f29, f24, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEE3C: ED9E5678  fmsubs f12, f30, f25, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEE40: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEE44: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEE48: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBEE4C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBEE50: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEE54: 409A0074  bne cr6, 0x82ebeec8
	if !ctx.cr[6].eq {
	pc = 0x82EBEEC8; continue 'dispatch;
	}
	// 82EBEE58: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82EBEE5C: 409A0018  bne cr6, 0x82ebee74
	if !ctx.cr[6].eq {
	pc = 0x82EBEE74; continue 'dispatch;
	}
	// 82EBEE60: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EBEE64: 409A0010  bne cr6, 0x82ebee74
	if !ctx.cr[6].eq {
	pc = 0x82EBEE74; continue 'dispatch;
	}
	// 82EBEE68: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEE6C: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82EBEE70: 4800000C  b 0x82ebee7c
	pc = 0x82EBEE7C; continue 'dispatch;
            }
            0x82EBEE74 => {
    //   block [0x82EBEE74..0x82EBEE7C)
	// 82EBEE74: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEE78: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	pc = 0x82EBEE7C; continue 'dispatch;
            }
            0x82EBEE7C => {
    //   block [0x82EBEE7C..0x82EBEEC8)
	// 82EBEE7C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEE80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBEE84: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEE88: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEE8C: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEE90: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEE94: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEE98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBEE9C: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBEEA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEEA4: EC1E5338  fmsubs f0, f30, f12, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEEA8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBEEAC: EC1F4B78  fmsubs f0, f31, f13, f9
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBEEB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBEEB4: 4B3C03B5  bl 0x8227f268
	ctx.lr = 0x82EBEEB8;
	sub_8227F268(ctx, base);
	// 82EBEEB8: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBEEBC: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEEC0: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEEC4: 48000030  b 0x82ebeef4
	pc = 0x82EBEEF4; continue 'dispatch;
            }
            0x82EBEEC8 => {
    //   block [0x82EBEEC8..0x82EBEEF4)
	// 82EBEEC8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EBEECC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEED0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEED4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEED8: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEEDC: ED2C07F2  fmuls f9, f12, f31
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEEE0: ED400772  fmuls f10, f0, f29
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EBEEE4: ED4C57B8  fmsubs f10, f12, f30, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBEEE8: ED805FF8  fmsubs f12, f0, f31, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBEEEC: ED7D4B78  fmsubs f11, f29, f13, f9
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBEEF0: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	pc = 0x82EBEEF4; continue 'dispatch;
            }
            0x82EBEEF4 => {
    //   block [0x82EBEEF4..0x82EBEF24)
	// 82EBEEF4: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EBEEF8: ED5F0732  fmuls f10, f31, f28
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEEFC: ED3D0732  fmuls f9, f29, f28
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF00: ED1E0732  fmuls f8, f30, f28
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF04: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF08: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF0C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF10: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBEF14: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEF18: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBEF1C: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBEF20: 48000084  b 0x82ebefa4
	pc = 0x82EBEFA4; continue 'dispatch;
            }
            0x82EBEF24 => {
    //   block [0x82EBEF24..0x82EBEF40)
	// 82EBEF24: EC1807F2  fmuls f0, f24, f31
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBEF28: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	// 82EBEF2C: EC1E0678  fmsubs f0, f30, f25, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBEF30: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EBEF34: 4098000C  bge cr6, 0x82ebef40
	if !ctx.cr[6].lt {
	pc = 0x82EBEF40; continue 'dispatch;
	}
	// 82EBEF38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBEF3C: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EBEF40; continue 'dispatch;
            }
            0x82EBEF40 => {
    //   block [0x82EBEF40..0x82EBEFA4)
	// 82EBEF40: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBEF44: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EBEF48: ED3F0732  fmuls f9, f31, f28
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF4C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EBEF50: ECFE0732  fmuls f7, f30, f28
	ctx.f[7].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF54: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBEF58: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBEF5C: ED1D02F2  fmuls f8, f29, f11
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBEF60: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBEF64: ECDE02B2  fmuls f6, f30, f10
	ctx.f[6].f64 = (((ctx.f[30].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBEF68: ECBF0332  fmuls f5, f31, f12
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBEF6C: ED9E4338  fmsubs f12, f30, f12, f8
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EBEF70: ED7F32F8  fmsubs f11, f31, f11, f6
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBEF74: ED5D2AB8  fmsubs f10, f29, f10, f5
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[10].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EBEF78: ED1D0732  fmuls f8, f29, f28
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EBEF7C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF80: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF84: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBEF88: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF8C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF90: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBEF94: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBEF98: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBEF9C: EDA8582A  fadds f13, f8, f11
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBEFA0: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82EBEFA4; continue 'dispatch;
            }
            0x82EBEFA4 => {
    //   block [0x82EBEFA4..0x82EBEFEC)
	// 82EBEFA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBEFA8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBEFAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EBEFB0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBEFB4: 4B3C02B5  bl 0x8227f268
	ctx.lr = 0x82EBEFB8;
	sub_8227F268(ctx, base);
	// 82EBEFB8: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFBC: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EBEFC0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFC4: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EBEFC8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBEFCC: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBEFD0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EBEFD4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EBEFD8: 4BDEED39  bl 0x82cadd10
	ctx.lr = 0x82EBEFDC;
	sub_82CADCEC(ctx, base);
	// 82EBEFDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBEFE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBEFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBEFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBEFF0 size=708
    let mut pc: u32 = 0x82EBEFF0;
    'dispatch: loop {
        match pc {
            0x82EBEFF0 => {
    //   block [0x82EBEFF0..0x82EBF030)
	// 82EBEFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBEFF4: 4BDEA419  bl 0x82ca940c
	ctx.lr = 0x82EBEFF8;
	sub_82CA93D0(ctx, base);
	// 82EBEFF8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EBEFFC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBF000: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF004: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF008: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF00C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF010: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF014: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EBF018: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF01C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF020: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF024: 4182000C  beq 0x82ebf030
	if ctx.cr[0].eq {
	pc = 0x82EBF030; continue 'dispatch;
	}
	// 82EBF028: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBF02C: 48000008  b 0x82ebf034
	pc = 0x82EBF034; continue 'dispatch;
            }
            0x82EBF030 => {
    //   block [0x82EBF030..0x82EBF034)
	// 82EBF030: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x82EBF034; continue 'dispatch;
            }
            0x82EBF034 => {
    //   block [0x82EBF034..0x82EBF054)
	// 82EBF034: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF038: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EBF03C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EBF040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EBF044: 4B329635  bl 0x821e8678
	ctx.lr = 0x82EBF048;
	sub_821E8678(ctx, base);
	// 82EBF048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF04C: 41820008  beq 0x82ebf054
	if ctx.cr[0].eq {
	pc = 0x82EBF054; continue 'dispatch;
	}
	// 82EBF050: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82EBF054; continue 'dispatch;
            }
            0x82EBF054 => {
    //   block [0x82EBF054..0x82EBF0B0)
	// 82EBF054: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF058: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF05C: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF060: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF064: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF068: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF06C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF070: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF074: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF078: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF07C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF080: C14A0C18  lfs f10, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF084: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF088: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF08C: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF090: ED20002C  fsqrts f9, f0
	ctx.f[9].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBF094: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EBF098: 40990018  ble cr6, 0x82ebf0b0
	if !ctx.cr[6].gt {
	pc = 0x82EBF0B0; continue 'dispatch;
	}
	// 82EBF09C: EC1F4824  fdivs f0, f31, f9
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EBF0A0: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBF0A4: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF0A8: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBF0AC: 48000010  b 0x82ebf0bc
	pc = 0x82EBF0BC; continue 'dispatch;
            }
            0x82EBF0B0 => {
    //   block [0x82EBF0B0..0x82EBF0BC)
	// 82EBF0B0: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EBF0B4: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EBF0B8: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x82EBF0BC; continue 'dispatch;
            }
            0x82EBF0BC => {
    //   block [0x82EBF0BC..0x82EBF0E8)
	// 82EBF0BC: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF0C0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF0C4: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF0C8: C10B004C  lfs f8, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF0CC: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF0D0: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF0D4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EBF0D8: 41990010  bgt cr6, 0x82ebf0e8
	if ctx.cr[6].gt {
	pc = 0x82EBF0E8; continue 'dispatch;
	}
	// 82EBF0DC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF0E0: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EBF0E4: 409801C0  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	pc = 0x82EBF0E8; continue 'dispatch;
            }
            0x82EBF0E8 => {
    //   block [0x82EBF0E8..0x82EBF1AC)
	// 82EBF0E8: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF0EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF0F0: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF0F4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EBF0F8: C12B004C  lfs f9, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF0FC: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF100: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF104: C10B0050  lfs f8, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF108: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF10C: C15E0050  lfs f10, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF110: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF114: C0FE0054  lfs f7, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBF118: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF11C: C08B0054  lfs f4, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EBF120: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF124: EC040032  fmuls f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF128: C0CB0034  lfs f6, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBF12C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EBF130: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBF134: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBF138: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EBF13C: ECC53028  fsubs f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EBF140: C18A0A40  lfs f12, 0xa40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF144: C07E003C  lfs f3, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EBF148: FFE06090  fmr f31, f12
	ctx.f[31].f64 = ctx.f[12].f64;
	// 82EBF14C: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EBF150: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EBF154: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EBF158: ECA32828  fsubs f5, f3, f5
	ctx.f[5].f64 = (((ctx.f[3].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EBF15C: ED6A4028  fsubs f11, f10, f8
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EBF160: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBF164: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF168: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBF16C: 419A0040  beq cr6, 0x82ebf1ac
	if ctx.cr[6].eq {
	pc = 0x82EBF1AC; continue 'dispatch;
	}
	// 82EBF170: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF174: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF178: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EBF17C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF180: C10B003C  lfs f8, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EBF184: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF188: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF18C: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF190: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF194: C14B0058  lfs f10, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF198: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF19C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF1A0: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF1A4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBF1A8: EFE05024  fdivs f31, f0, f10
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	pc = 0x82EBF1AC; continue 'dispatch;
            }
            0x82EBF1AC => {
    //   block [0x82EBF1AC..0x82EBF204)
	// 82EBF1AC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF1B4: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EBF1B8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 82EBF1BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EBF1C0: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF1C4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82EBF1C8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBF1CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EBF1D0: D0E10070  stfs f7, 0x70(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EBF1D4: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EBF1DC: D0C10074  stfs f6, 0x74(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EBF1E0: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EBF1E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF1E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBF1EC: 4BFFFA15  bl 0x82ebec00
	ctx.lr = 0x82EBF1F0;
	sub_82EBEC00(ctx, base);
	// 82EBF1F0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF1F4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF1F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF1FC: 41980008  blt cr6, 0x82ebf204
	if ctx.cr[6].lt {
	pc = 0x82EBF204; continue 'dispatch;
	}
	// 82EBF200: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBF204; continue 'dispatch;
            }
            0x82EBF204 => {
    //   block [0x82EBF204..0x82EBF250)
	// 82EBF204: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBF208: 4182009C  beq 0x82ebf2a4
	if ctx.cr[0].eq {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF20C: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF210: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF214: 40980090  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF218: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EBF21C: 40980088  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF220: C1BF00DC  lfs f13, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF224: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF228: 4099007C  ble cr6, 0x82ebf2a4
	if !ctx.cr[6].gt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF22C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF230: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82EBF234: 4098001C  bge cr6, 0x82ebf250
	if !ctx.cr[6].lt {
	pc = 0x82EBF250; continue 'dispatch;
	}
	// 82EBF238: 396B0016  addi r11, r11, 0x16
	ctx.r[11].s64 = ctx.r[11].s64 + 22;
	// 82EBF23C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EBF240: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 82EBF244: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF248: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EBF24C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82EBF250; continue 'dispatch;
            }
            0x82EBF250 => {
    //   block [0x82EBF250..0x82EBF2A4)
	// 82EBF250: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF254: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF258: 4098004C  bge cr6, 0x82ebf2a4
	if !ctx.cr[6].lt {
	pc = 0x82EBF2A4; continue 'dispatch;
	}
	// 82EBF25C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EBF260: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF264: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF268: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82EBF26C: 995F003C  stb r10, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	// 82EBF270: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF274: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF278: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF27C: C14B0054  lfs f10, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF280: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF284: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF288: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF28C: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF290: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EBF294: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF298: D17F0048  stfs f11, 0x48(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EBF29C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF2A0: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x82EBF2A4; continue 'dispatch;
            }
            0x82EBF2A4 => {
    //   block [0x82EBF2A4..0x82EBF2B4)
	// 82EBF2A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EBF2A8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EBF2AC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBF2B0: 4BDEA1AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF2B8 size=344
    let mut pc: u32 = 0x82EBF2B8;
    'dispatch: loop {
        match pc {
            0x82EBF2B8 => {
    //   block [0x82EBF2B8..0x82EBF330)
	// 82EBF2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF2C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF2C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF2C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EBF2CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EBF2D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF2D4: C1AB00C0  lfs f13, 0xc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF2D8: C16B00C4  lfs f11, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF2DC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF2E0: C12B00BC  lfs f9, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EBF2E4: C00B00F0  lfs f0, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF2E8: C18A0050  lfs f12, 0x50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF2EC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF2F0: C18A0054  lfs f12, 0x54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF2F4: C14A004C  lfs f10, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF2F8: 807F0264  lwz r3, 0x264(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EBF2FC: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF300: EDAA6A7A  fmadds f13, f10, f9, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EBF304: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBF308: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF30C: C1AB00F4  lfs f13, 0xf4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF310: 40990054  ble cr6, 0x82ebf364
	if !ctx.cr[6].gt {
	pc = 0x82EBF364; continue 'dispatch;
	}
	// 82EBF314: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF318: 40980018  bge cr6, 0x82ebf330
	if !ctx.cr[6].lt {
	pc = 0x82EBF330; continue 'dispatch;
	}
	// 82EBF31C: C04B0024  lfs f2, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EBF320: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EBF324: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF328: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82EBF32C: 48000060  b 0x82ebf38c
	pc = 0x82EBF38C; continue 'dispatch;
            }
            0x82EBF330 => {
    //   block [0x82EBF330..0x82EBF364)
	// 82EBF330: C16B00E4  lfs f11, 0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF334: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF338: EC4B02B2  fmuls f2, f11, f10
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBF33C: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF340: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF344: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF348: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF34C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF350: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF354: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF358: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF35C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF360: 4800002C  b 0x82ebf38c
	pc = 0x82EBF38C; continue 'dispatch;
            }
            0x82EBF364 => {
    //   block [0x82EBF364..0x82EBF384)
	// 82EBF364: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF368: C18B00C4  lfs f12, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF36C: C00B00BC  lfs f0, 0xbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF370: C1AB00C0  lfs f13, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF374: C14B0024  lfs f10, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF378: 4098000C  bge cr6, 0x82ebf384
	if !ctx.cr[6].lt {
	pc = 0x82EBF384; continue 'dispatch;
	}
	// 82EBF37C: C16B00E8  lfs f11, 0xe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF380: 48000008  b 0x82ebf388
	pc = 0x82EBF388; continue 'dispatch;
            }
            0x82EBF384 => {
    //   block [0x82EBF384..0x82EBF388)
	// 82EBF384: C16B00E4  lfs f11, 0xe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82EBF388; continue 'dispatch;
            }
            0x82EBF388 => {
    //   block [0x82EBF388..0x82EBF38C)
	// 82EBF388: EC4B02B2  fmuls f2, f11, f10
	ctx.f[2].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	pc = 0x82EBF38C; continue 'dispatch;
            }
            0x82EBF38C => {
    //   block [0x82EBF38C..0x82EBF3CC)
	// 82EBF38C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBF390: C16A0034  lfs f11, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF394: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBF398: C14A0038  lfs f10, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF39C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBF3A0: C16A003C  lfs f11, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF3A4: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBF3A8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBF3AC: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBF3B0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBF3B4: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EBF3B8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EBF3BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EBF3C0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EBF3C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EBF3C8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82EBF3CC; continue 'dispatch;
            }
            0x82EBF3CC => {
    //   block [0x82EBF3CC..0x82EBF410)
	// 82EBF3CC: 90C70000  stw r6, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82EBF3D0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82EBF3D4: 4200FFF8  bdnz 0x82ebf3cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBF3CC; continue 'dispatch;
	}
	// 82EBF3D8: 98C100A8  stb r6, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[6].u8 ) };
	// 82EBF3DC: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBF3E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBF3E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EBF3E8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EBF3EC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82EBF3F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF3F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF3F8: 4E800421  bctrl
	ctx.lr = 0x82EBF3FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF3FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EBF400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF40C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF410 size=340
    let mut pc: u32 = 0x82EBF410;
    'dispatch: loop {
        match pc {
            0x82EBF410 => {
    //   block [0x82EBF410..0x82EBF460)
	// 82EBF410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF414: 4BDE9FF5  bl 0x82ca9408
	ctx.lr = 0x82EBF418;
	sub_82CA93D0(ctx, base);
	// 82EBF418: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF420: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBF428: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EBF42C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF430: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF434: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBF438: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EBF43C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82EBF440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF444: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EBF448: 4182006C  beq 0x82ebf4b4
	if ctx.cr[0].eq {
	pc = 0x82EBF4B4; continue 'dispatch;
	}
	// 82EBF44C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF450: C03F00D0  lfs f1, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EBF454: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EBF458: 4BFC8851  bl 0x82e87ca8
	ctx.lr = 0x82EBF45C;
	sub_82E87CA8(ctx, base);
	// 82EBF45C: 4800004C  b 0x82ebf4a8
	pc = 0x82EBF4A8; continue 'dispatch;
            }
            0x82EBF460 => {
    //   block [0x82EBF460..0x82EBF490)
	// 82EBF460: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF464: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBF468: 419A0038  beq cr6, 0x82ebf4a0
	if ctx.cr[6].eq {
	pc = 0x82EBF4A0; continue 'dispatch;
	}
	// 82EBF46C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF470: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF474: 4182001C  beq 0x82ebf490
	if ctx.cr[0].eq {
	pc = 0x82EBF490; continue 'dispatch;
	}
	// 82EBF478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF47C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF480: 4E800421  bctrl
	ctx.lr = 0x82EBF484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF484: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EBF488: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EBF48C: 409A0014  bne cr6, 0x82ebf4a0
	if !ctx.cr[6].eq {
	pc = 0x82EBF4A0; continue 'dispatch;
	}
            }
            0x82EBF490 => {
    //   block [0x82EBF490..0x82EBF4A0)
	// 82EBF490: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EBF494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF49C: 4BFFFB55  bl 0x82ebeff0
	ctx.lr = 0x82EBF4A0;
	sub_82EBEFF0(ctx, base);
	pc = 0x82EBF4A0; continue 'dispatch;
            }
            0x82EBF4A0 => {
    //   block [0x82EBF4A0..0x82EBF4A8)
	// 82EBF4A0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF4A4: 4BFC82CD  bl 0x82e87770
	ctx.lr = 0x82EBF4A8;
	sub_82E87770(ctx, base);
	pc = 0x82EBF4A8; continue 'dispatch;
            }
            0x82EBF4A8 => {
    //   block [0x82EBF4A8..0x82EBF4B4)
	// 82EBF4A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EBF4AC: 4082FFB4  bne 0x82ebf460
	if !ctx.cr[0].eq {
	pc = 0x82EBF460; continue 'dispatch;
	}
	// 82EBF4B0: 480000AC  b 0x82ebf55c
	pc = 0x82EBF55C; continue 'dispatch;
            }
            0x82EBF4B4 => {
    //   block [0x82EBF4B4..0x82EBF4C8)
	// 82EBF4B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF4B8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF4BC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBF4C0: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EBF4C4: 48000090  b 0x82ebf554
	pc = 0x82EBF554; continue 'dispatch;
            }
            0x82EBF4C8 => {
    //   block [0x82EBF4C8..0x82EBF4FC)
	// 82EBF4C8: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF4CC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF4D0: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EBF4D4: 419A007C  beq cr6, 0x82ebf550
	if ctx.cr[6].eq {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF4D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF4DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF4E0: 4182001C  beq 0x82ebf4fc
	if ctx.cr[0].eq {
	pc = 0x82EBF4FC; continue 'dispatch;
	}
	// 82EBF4E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF4E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF4EC: 4E800421  bctrl
	ctx.lr = 0x82EBF4F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF4F0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EBF4F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EBF4F8: 409A0058  bne cr6, 0x82ebf550
	if !ctx.cr[6].eq {
	pc = 0x82EBF550; continue 'dispatch;
	}
            }
            0x82EBF4FC => {
    //   block [0x82EBF4FC..0x82EBF550)
	// 82EBF4FC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EBF500: C01F00D0  lfs f0, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF504: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF508: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF50C: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF510: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF514: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBF518: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF51C: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBF520: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF524: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBF528: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBF52C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF530: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF534: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBF538: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EBF53C: 40980014  bge cr6, 0x82ebf550
	if !ctx.cr[6].lt {
	pc = 0x82EBF550; continue 'dispatch;
	}
	// 82EBF540: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EBF544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF54C: 4BFFFAA5  bl 0x82ebeff0
	ctx.lr = 0x82EBF550;
	sub_82EBEFF0(ctx, base);
	pc = 0x82EBF550; continue 'dispatch;
            }
            0x82EBF550 => {
    //   block [0x82EBF550..0x82EBF554)
	// 82EBF550: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EBF554; continue 'dispatch;
            }
            0x82EBF554 => {
    //   block [0x82EBF554..0x82EBF55C)
	// 82EBF554: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF558: 4082FF70  bne 0x82ebf4c8
	if !ctx.cr[0].eq {
	pc = 0x82EBF4C8; continue 'dispatch;
	}
	pc = 0x82EBF55C; continue 'dispatch;
            }
            0x82EBF55C => {
    //   block [0x82EBF55C..0x82EBF564)
	// 82EBF55C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF560: 4BDE9EF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF568 size=200
    let mut pc: u32 = 0x82EBF568;
    'dispatch: loop {
        match pc {
            0x82EBF568 => {
    //   block [0x82EBF568..0x82EBF5DC)
	// 82EBF568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF56C: 4BDE9E9D  bl 0x82ca9408
	ctx.lr = 0x82EBF570;
	sub_82CA93D0(ctx, base);
	// 82EBF570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF578: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EBF57C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EBF580: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82EBF584: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF58C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF590: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBF594: 4BFFFE7D  bl 0x82ebf410
	ctx.lr = 0x82EBF598;
	sub_82EBF410(ctx, base);
	// 82EBF598: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EBF59C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF5A0: 4182003C  beq 0x82ebf5dc
	if ctx.cr[0].eq {
	pc = 0x82EBF5DC; continue 'dispatch;
	}
	// 82EBF5A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5AC: 4BFFF70D  bl 0x82ebecb8
	ctx.lr = 0x82EBF5B0;
	sub_82EBECB8(ctx, base);
	// 82EBF5B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF5B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBF5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5BC: 4BFFFCFD  bl 0x82ebf2b8
	ctx.lr = 0x82EBF5C0;
	sub_82EBF2B8(ctx, base);
	// 82EBF5C0: 4B3A13F9  bl 0x822609b8
	ctx.lr = 0x82EBF5C4;
	sub_822609B8(ctx, base);
	// 82EBF5C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBF5C8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF5CC: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF5D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBF5D4: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBF5D8: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	pc = 0x82EBF5DC; continue 'dispatch;
            }
            0x82EBF5DC => {
    //   block [0x82EBF5DC..0x82EBF5FC)
	// 82EBF5DC: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EBF5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF5E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF5E8: 40820014  bne 0x82ebf5fc
	if !ctx.cr[0].eq {
	pc = 0x82EBF5FC; continue 'dispatch;
	}
	// 82EBF5EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EBF5F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EBF5F4: 4BFFF14D  bl 0x82ebe740
	ctx.lr = 0x82EBF5F8;
	sub_82EBE740(ctx, base);
	// 82EBF5F8: 48000030  b 0x82ebf628
	pc = 0x82EBF628; continue 'dispatch;
            }
            0x82EBF5FC => {
    //   block [0x82EBF5FC..0x82EBF624)
	// 82EBF5FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF600: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EBF604: 4BFFFCB5  bl 0x82ebf2b8
	ctx.lr = 0x82EBF608;
	sub_82EBF2B8(ctx, base);
	// 82EBF608: 4B3A13B1  bl 0x822609b8
	ctx.lr = 0x82EBF60C;
	sub_822609B8(ctx, base);
	// 82EBF60C: C01F00CC  lfs f0, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF610: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF614: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBF618: 4098000C  bge cr6, 0x82ebf624
	if !ctx.cr[6].lt {
	pc = 0x82EBF624; continue 'dispatch;
	}
	// 82EBF61C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EBF620: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	pc = 0x82EBF624; continue 'dispatch;
            }
            0x82EBF624 => {
    //   block [0x82EBF624..0x82EBF628)
	// 82EBF624: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EBF628; continue 'dispatch;
            }
            0x82EBF628 => {
    //   block [0x82EBF628..0x82EBF630)
	// 82EBF628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF62C: 4BDE9E2C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF630 size=296
    let mut pc: u32 = 0x82EBF630;
    'dispatch: loop {
        match pc {
            0x82EBF630 => {
    //   block [0x82EBF630..0x82EBF690)
	// 82EBF630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF634: 4BDE9DD9  bl 0x82ca940c
	ctx.lr = 0x82EBF638;
	sub_82CA93D0(ctx, base);
	// 82EBF638: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBF63C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBF644: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBF648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF64C: 482FCA15  bl 0x831bc060
	ctx.lr = 0x82EBF650;
	sub_831BC060(ctx, base);
	// 82EBF650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF654: 41820084  beq 0x82ebf6d8
	if ctx.cr[0].eq {
	pc = 0x82EBF6D8; continue 'dispatch;
	}
	// 82EBF658: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBF65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF660: 3BCBAEA0  addi r30, r11, -0x5160
	ctx.r[30].s64 = ctx.r[11].s64 + -20832;
	// 82EBF664: 482FC9FD  bl 0x831bc060
	ctx.lr = 0x82EBF668;
	sub_831BC060(ctx, base);
	// 82EBF668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF66C: 4BDED4E5  bl 0x82cacb50
	ctx.lr = 0x82EBF670;
	sub_82CACB50(ctx, base);
	// 82EBF670: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBF674: 40820064  bne 0x82ebf6d8
	if !ctx.cr[0].eq {
	pc = 0x82EBF6D8; continue 'dispatch;
	}
	// 82EBF678: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF67C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF680: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF684: 4182000C  beq 0x82ebf690
	if ctx.cr[0].eq {
	pc = 0x82EBF690; continue 'dispatch;
	}
	// 82EBF688: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBF68C: 4800000C  b 0x82ebf698
	pc = 0x82EBF698; continue 'dispatch;
            }
            0x82EBF690 => {
    //   block [0x82EBF690..0x82EBF698)
	// 82EBF690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF694: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBF698; continue 'dispatch;
            }
            0x82EBF698 => {
    //   block [0x82EBF698..0x82EBF6B8)
	// 82EBF698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF69C: 4BA4E66D  bl 0x8290dd08
	ctx.lr = 0x82EBF6A0;
	sub_8290DD08(ctx, base);
	// 82EBF6A0: 4BDEC511  bl 0x82cabbb0
	ctx.lr = 0x82EBF6A4;
	sub_82CABBB0(ctx, base);
	// 82EBF6A4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBF6A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF6AC: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF6B0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF6B4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EBF6B8; continue 'dispatch;
            }
            0x82EBF6B8 => {
    //   block [0x82EBF6B8..0x82EBF6C4)
	// 82EBF6B8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBF6BC: 40990008  ble cr6, 0x82ebf6c4
	if !ctx.cr[6].gt {
	pc = 0x82EBF6C4; continue 'dispatch;
	}
	// 82EBF6C0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBF6C4; continue 'dispatch;
            }
            0x82EBF6C4 => {
    //   block [0x82EBF6C4..0x82EBF6D0)
	// 82EBF6C4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBF6C8: 409AFFF0  bne cr6, 0x82ebf6b8
	if !ctx.cr[6].eq {
	pc = 0x82EBF6B8; continue 'dispatch;
	}
	// 82EBF6CC: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82EBF6D0; continue 'dispatch;
            }
            0x82EBF6D0 => {
    //   block [0x82EBF6D0..0x82EBF6D8)
	// 82EBF6D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBF6D4: 48000078  b 0x82ebf74c
	pc = 0x82EBF74C; continue 'dispatch;
            }
            0x82EBF6D8 => {
    //   block [0x82EBF6D8..0x82EBF724)
	// 82EBF6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF6DC: 482FC985  bl 0x831bc060
	ctx.lr = 0x82EBF6E0;
	sub_831BC060(ctx, base);
	// 82EBF6E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF6E4: 4182005C  beq 0x82ebf740
	if ctx.cr[0].eq {
	pc = 0x82EBF740; continue 'dispatch;
	}
	// 82EBF6E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBF6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF6F0: 3BCBAE90  addi r30, r11, -0x5170
	ctx.r[30].s64 = ctx.r[11].s64 + -20848;
	// 82EBF6F4: 482FC96D  bl 0x831bc060
	ctx.lr = 0x82EBF6F8;
	sub_831BC060(ctx, base);
	// 82EBF6F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF6FC: 4BDED455  bl 0x82cacb50
	ctx.lr = 0x82EBF700;
	sub_82CACB50(ctx, base);
	// 82EBF700: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBF704: 4082003C  bne 0x82ebf740
	if !ctx.cr[0].eq {
	pc = 0x82EBF740; continue 'dispatch;
	}
	// 82EBF708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF70C: 4BA4E5FD  bl 0x8290dd08
	ctx.lr = 0x82EBF710;
	sub_8290DD08(ctx, base);
	// 82EBF710: 4BDEC4A1  bl 0x82cabbb0
	ctx.lr = 0x82EBF714;
	sub_82CABBB0(ctx, base);
	// 82EBF714: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF718: C01D0088  lfs f0, 0x88(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF71C: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBF720: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EBF724; continue 'dispatch;
            }
            0x82EBF724 => {
    //   block [0x82EBF724..0x82EBF730)
	// 82EBF724: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBF728: 41980008  blt cr6, 0x82ebf730
	if ctx.cr[6].lt {
	pc = 0x82EBF730; continue 'dispatch;
	}
	// 82EBF72C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBF730; continue 'dispatch;
            }
            0x82EBF730 => {
    //   block [0x82EBF730..0x82EBF740)
	// 82EBF730: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBF734: 409AFFF0  bne cr6, 0x82ebf724
	if !ctx.cr[6].eq {
	pc = 0x82EBF724; continue 'dispatch;
	}
	// 82EBF738: D01D0088  stfs f0, 0x88(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EBF73C: 4BFFFF94  b 0x82ebf6d0
	pc = 0x82EBF6D0; continue 'dispatch;
            }
            0x82EBF740 => {
    //   block [0x82EBF740..0x82EBF74C)
	// 82EBF740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBF744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBF748: 4BFF5CD9  bl 0x82eb5420
	ctx.lr = 0x82EBF74C;
	sub_82EB5420(ctx, base);
	pc = 0x82EBF74C; continue 'dispatch;
            }
            0x82EBF74C => {
    //   block [0x82EBF74C..0x82EBF758)
	// 82EBF74C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EBF750: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EBF754: 4BDE9D08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF758 size=144
    let mut pc: u32 = 0x82EBF758;
    'dispatch: loop {
        match pc {
            0x82EBF758 => {
    //   block [0x82EBF758..0x82EBF78C)
	// 82EBF758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF76C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBF770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF778: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBF77C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF780: 4182000C  beq 0x82ebf78c
	if ctx.cr[0].eq {
	pc = 0x82EBF78C; continue 'dispatch;
	}
	// 82EBF784: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF788: 4800000C  b 0x82ebf794
	pc = 0x82EBF794; continue 'dispatch;
            }
            0x82EBF78C => {
    //   block [0x82EBF78C..0x82EBF794)
	// 82EBF78C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF790: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EBF794; continue 'dispatch;
            }
            0x82EBF794 => {
    //   block [0x82EBF794..0x82EBF7E8)
	// 82EBF794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF798: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBF79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF7A0: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7A8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBF7AC: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF7B0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7B4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EBF7B8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EBF7BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF7C0: 4E800421  bctrl
	ctx.lr = 0x82EBF7C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBF7C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBF7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF7CC: 480048AD  bl 0x82ec4078
	ctx.lr = 0x82EBF7D0;
	sub_82EC4078(ctx, base);
	// 82EBF7D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF7DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF7E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF7E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EBF7E8 size=44
    let mut pc: u32 = 0x82EBF7E8;
    'dispatch: loop {
        match pc {
            0x82EBF7E8 => {
    //   block [0x82EBF7E8..0x82EBF814)
	// 82EBF7E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7EC: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF7F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF7F4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBF7F8: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBF7FC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF800: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF804: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBF808: C00B0C1C  lfs f0, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF80C: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EBF810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF818 size=152
    let mut pc: u32 = 0x82EBF818;
    'dispatch: loop {
        match pc {
            0x82EBF818 => {
    //   block [0x82EBF818..0x82EBF888)
	// 82EBF818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF824: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF82C: 4BFF5B05  bl 0x82eb5330
	ctx.lr = 0x82EBF830;
	sub_82EB5330(ctx, base);
	// 82EBF830: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EBF834: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EBF838: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82EBF83C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EBF840: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EBF844: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF848: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EBF84C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82EBF850: 394AAEB0  addi r10, r10, -0x5150
	ctx.r[10].s64 = ctx.r[10].s64 + -20816;
	// 82EBF854: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EBF858: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBF85C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBF860: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 82EBF864: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBF868: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBF86C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBF870: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBF874: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EBF878: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EBF87C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBF880: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBF884: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82EBF888; continue 'dispatch;
            }
            0x82EBF888 => {
    //   block [0x82EBF888..0x82EBF8B0)
	// 82EBF888: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EBF88C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EBF890: 4200FFF8  bdnz 0x82ebf888
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBF888; continue 'dispatch;
	}
	// 82EBF894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF898: 98EB0058  stb r7, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[7].u8 ) };
	// 82EBF89C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EBF8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF8A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF8AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EBF8B0 size=12
    let mut pc: u32 = 0x82EBF8B0;
    'dispatch: loop {
        match pc {
            0x82EBF8B0 => {
    //   block [0x82EBF8B0..0x82EBF8BC)
	// 82EBF8B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EBF8B4: 386BD12C  addi r3, r11, -0x2ed4
	ctx.r[3].s64 = ctx.r[11].s64 + -11988;
	// 82EBF8B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBF8C0 size=100
    let mut pc: u32 = 0x82EBF8C0;
    'dispatch: loop {
        match pc {
            0x82EBF8C0 => {
    //   block [0x82EBF8C0..0x82EBF908)
	// 82EBF8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF8C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF8CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF8D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBF8D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF8DC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EBF8E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF8E4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EBF8E8: 4BFF5AE1  bl 0x82eb53c8
	ctx.lr = 0x82EBF8EC;
	sub_82EB53C8(ctx, base);
	// 82EBF8EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBF8F0: 41820018  beq 0x82ebf908
	if ctx.cr[0].eq {
	pc = 0x82EBF908; continue 'dispatch;
	}
	// 82EBF8F4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EBF8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF8FC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EBF900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBF904: 4E800421  bctrl
	ctx.lr = 0x82EBF908;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EBF908 => {
    //   block [0x82EBF908..0x82EBF924)
	// 82EBF908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBF90C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF91C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBF928 size=88
    let mut pc: u32 = 0x82EBF928;
    'dispatch: loop {
        match pc {
            0x82EBF928 => {
    //   block [0x82EBF928..0x82EBF964)
	// 82EBF928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBF930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBF934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBF938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF940: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 82EBF944: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBF948: 4B756FE1  bl 0x82616928
	ctx.lr = 0x82EBF94C;
	sub_82616928(ctx, base);
	// 82EBF94C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBF950: 41820014  beq 0x82ebf964
	if ctx.cr[0].eq {
	pc = 0x82EBF964; continue 'dispatch;
	}
	// 82EBF954: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBF958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBF95C: 4BFFFEBD  bl 0x82ebf818
	ctx.lr = 0x82EBF960;
	sub_82EBF818(ctx, base);
	// 82EBF960: 48000008  b 0x82ebf968
	pc = 0x82EBF968; continue 'dispatch;
            }
            0x82EBF964 => {
    //   block [0x82EBF964..0x82EBF968)
	// 82EBF964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBF968; continue 'dispatch;
            }
            0x82EBF968 => {
    //   block [0x82EBF968..0x82EBF980)
	// 82EBF968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBF96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBF970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBF974: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBF978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBF97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBF980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBF980 size=1144
    let mut pc: u32 = 0x82EBF980;
    'dispatch: loop {
        match pc {
            0x82EBF980 => {
    //   block [0x82EBF980..0x82EBF9BC)
	// 82EBF980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBF984: 4BDE9A71  bl 0x82ca93f4
	ctx.lr = 0x82EBF988;
	sub_82CA93D0(ctx, base);
	// 82EBF988: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82EBF98C: 4BDEE349  bl 0x82cadcd4
	ctx.lr = 0x82EBF990;
	sub_82CADCA0(ctx, base);
	// 82EBF990: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBF994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBF998: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EBF99C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82EBF9A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBF9A4: 83CB039C  lwz r30, 0x39c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EBF9A8: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EBF9AC: 3BBE0014  addi r29, r30, 0x14
	ctx.r[29].s64 = ctx.r[30].s64 + 20;
	// 82EBF9B0: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EBF9B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EBF9B8: 409A000C  bne cr6, 0x82ebf9c4
	if !ctx.cr[6].eq {
	pc = 0x82EBF9C4; continue 'dispatch;
	}
	pc = 0x82EBF9BC; continue 'dispatch;
            }
            0x82EBF9BC => {
    //   block [0x82EBF9BC..0x82EBF9C4)
	// 82EBF9BC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBF9C0: 4800041C  b 0x82ebfddc
	pc = 0x82EBFDDC; continue 'dispatch;
            }
            0x82EBF9C4 => {
    //   block [0x82EBF9C4..0x82EBF9F8)
	// 82EBF9C4: 4B3A0FF5  bl 0x822609b8
	ctx.lr = 0x82EBF9C8;
	sub_822609B8(ctx, base);
	// 82EBF9C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBF9CC: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBF9D0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82EBF9D4: C17F008C  lfs f11, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBF9D8: C183004C  lfs f12, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBF9DC: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBF9E0: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EBF9E4: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBF9E8: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EBF9EC: 4099000C  ble cr6, 0x82ebf9f8
	if !ctx.cr[6].gt {
	pc = 0x82EBF9F8; continue 'dispatch;
	}
	// 82EBF9F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBF9F4: 48000024  b 0x82ebfa18
	pc = 0x82EBFA18; continue 'dispatch;
            }
            0x82EBF9F8 => {
    //   block [0x82EBF9F8..0x82EBFA14)
	// 82EBF9F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBF9FC: 40990018  ble cr6, 0x82ebfa14
	if !ctx.cr[6].gt {
	pc = 0x82EBFA14; continue 'dispatch;
	}
	// 82EBFA00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFA04: 896B0410  lbz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EBFA08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFA0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA10: 40820008  bne 0x82ebfa18
	if !ctx.cr[0].eq {
	pc = 0x82EBFA18; continue 'dispatch;
	}
	pc = 0x82EBFA14; continue 'dispatch;
            }
            0x82EBFA14 => {
    //   block [0x82EBFA14..0x82EBFA18)
	// 82EBFA14: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBFA18; continue 'dispatch;
            }
            0x82EBFA18 => {
    //   block [0x82EBFA18..0x82EBFA54)
	// 82EBFA18: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA1C: 4082008C  bne 0x82ebfaa8
	if !ctx.cr[0].eq {
	pc = 0x82EBFAA8; continue 'dispatch;
	}
	// 82EBFA20: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA24: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFA2C: 409A0028  bne cr6, 0x82ebfa54
	if !ctx.cr[6].eq {
	pc = 0x82EBFA54; continue 'dispatch;
	}
	// 82EBFA30: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA34: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA3C: 409A0018  bne cr6, 0x82ebfa54
	if !ctx.cr[6].eq {
	pc = 0x82EBFA54; continue 'dispatch;
	}
	// 82EBFA40: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA48: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA50: 419A0008  beq cr6, 0x82ebfa58
	if ctx.cr[6].eq {
	pc = 0x82EBFA58; continue 'dispatch;
	}
	pc = 0x82EBFA54; continue 'dispatch;
            }
            0x82EBFA54 => {
    //   block [0x82EBFA54..0x82EBFA58)
	// 82EBFA54: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBFA58; continue 'dispatch;
            }
            0x82EBFA58 => {
    //   block [0x82EBFA58..0x82EBFA94)
	// 82EBFA58: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA5C: 4182FF60  beq 0x82ebf9bc
	if ctx.cr[0].eq {
	pc = 0x82EBF9BC; continue 'dispatch;
	}
	// 82EBFA60: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA64: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFA6C: 409A0028  bne cr6, 0x82ebfa94
	if !ctx.cr[6].eq {
	pc = 0x82EBFA94; continue 'dispatch;
	}
	// 82EBFA70: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA74: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA7C: 409A0018  bne cr6, 0x82ebfa94
	if !ctx.cr[6].eq {
	pc = 0x82EBFA94; continue 'dispatch;
	}
	// 82EBFA80: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFA84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EBFA88: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFA8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFA90: 419A0008  beq cr6, 0x82ebfa98
	if ctx.cr[6].eq {
	pc = 0x82EBFA98; continue 'dispatch;
	}
	pc = 0x82EBFA94; continue 'dispatch;
            }
            0x82EBFA94 => {
    //   block [0x82EBFA94..0x82EBFA98)
	// 82EBFA94: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82EBFA98; continue 'dispatch;
            }
            0x82EBFA98 => {
    //   block [0x82EBFA98..0x82EBFAA8)
	// 82EBFA98: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFA9C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82EBFAA0: 4082033C  bne 0x82ebfddc
	if !ctx.cr[0].eq {
	pc = 0x82EBFDDC; continue 'dispatch;
	}
	// 82EBFAA4: 4BFFFF18  b 0x82ebf9bc
	pc = 0x82EBF9BC; continue 'dispatch;
            }
            0x82EBFAA8 => {
    //   block [0x82EBFAA8..0x82EBFAE0)
	// 82EBFAA8: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EBFAAC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAB0: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFAB8: 409A0028  bne cr6, 0x82ebfae0
	if !ctx.cr[6].eq {
	pc = 0x82EBFAE0; continue 'dispatch;
	}
	// 82EBFABC: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAC0: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFAC8: 409A0018  bne cr6, 0x82ebfae0
	if !ctx.cr[6].eq {
	pc = 0x82EBFAE0; continue 'dispatch;
	}
	// 82EBFACC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAD0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFAD4: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFADC: 419A0008  beq cr6, 0x82ebfae4
	if ctx.cr[6].eq {
	pc = 0x82EBFAE4; continue 'dispatch;
	}
	pc = 0x82EBFAE0; continue 'dispatch;
            }
            0x82EBFAE0 => {
    //   block [0x82EBFAE0..0x82EBFAE4)
	// 82EBFAE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EBFAE4; continue 'dispatch;
            }
            0x82EBFAE4 => {
    //   block [0x82EBFAE4..0x82EBFB28)
	// 82EBFAE4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFAE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFAEC: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EBFAF0: 40820044  bne 0x82ebfb34
	if !ctx.cr[0].eq {
	pc = 0x82EBFB34; continue 'dispatch;
	}
	// 82EBFAF4: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFAF8: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFAFC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB00: 409A0028  bne cr6, 0x82ebfb28
	if !ctx.cr[6].eq {
	pc = 0x82EBFB28; continue 'dispatch;
	}
	// 82EBFB04: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB08: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB0C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB10: 409A0018  bne cr6, 0x82ebfb28
	if !ctx.cr[6].eq {
	pc = 0x82EBFB28; continue 'dispatch;
	}
	// 82EBFB14: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB18: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EBFB1C: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EBFB24: 419A0008  beq cr6, 0x82ebfb2c
	if ctx.cr[6].eq {
	pc = 0x82EBFB2C; continue 'dispatch;
	}
	pc = 0x82EBFB28; continue 'dispatch;
            }
            0x82EBFB28 => {
    //   block [0x82EBFB28..0x82EBFB2C)
	// 82EBFB28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EBFB2C; continue 'dispatch;
            }
            0x82EBFB2C => {
    //   block [0x82EBFB2C..0x82EBFB34)
	// 82EBFB2C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFB30: 41820044  beq 0x82ebfb74
	if ctx.cr[0].eq {
	pc = 0x82EBFB74; continue 'dispatch;
	}
	pc = 0x82EBFB34; continue 'dispatch;
            }
            0x82EBFB34 => {
    //   block [0x82EBFB34..0x82EBFB74)
	// 82EBFB34: C0180004  lfs f0, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB38: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBFB3C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EBFB40: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82EBFB44: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB48: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EBFB4C: C018000C  lfs f0, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB50: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EBFB54: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB58: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBFB5C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB60: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBFB64: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB68: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EBFB6C: D3DF0084  stfs f30, 0x84(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EBFB70: 4BFB0389  bl 0x82e6fef8
	ctx.lr = 0x82EBFB74;
	sub_82E6FEF8(ctx, base);
	pc = 0x82EBFB74; continue 'dispatch;
            }
            0x82EBFB74 => {
    //   block [0x82EBFB74..0x82EBFBC8)
	// 82EBFB74: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB78: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFB7C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBFB80: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFB84: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFB88: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EBFB8C: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFB90: C19D000C  lfs f12, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFB94: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBFB98: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EBFB9C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBFBA0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EBFBA4: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EBFBA8: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82EBFBAC: 409A001C  bne cr6, 0x82ebfbc8
	if !ctx.cr[6].eq {
	pc = 0x82EBFBC8; continue 'dispatch;
	}
	// 82EBFBB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EBFBB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82EBFBB8: 4BFB0341  bl 0x82e6fef8
	ctx.lr = 0x82EBFBBC;
	sub_82E6FEF8(ctx, base);
	// 82EBFBBC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EBFBC0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82EBFBC4: 4800021C  b 0x82ebfde0
	pc = 0x82EBFDE0; continue 'dispatch;
            }
            0x82EBFBC8 => {
    //   block [0x82EBFBC8..0x82EBFCA4)
	// 82EBFBC8: C19F000C  lfs f12, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFBCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFBD0: C17F0084  lfs f11, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBD4: EFEC582A  fadds f31, f12, f11
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EBFBD8: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBDC: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFBE0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EBFBE4: C15D0008  lfs f10, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFBE8: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFBEC: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFBF0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EBFBF4: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EBFBF8: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFBFC: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EBFC00: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFC04: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EBFC08: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EBFC0C: ED8002F2  fmuls f12, f0, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EBFC10: ED6002B2  fmuls f11, f0, f10
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EBFC14: 419901C4  bgt cr6, 0x82ebfdd8
	if ctx.cr[6].gt {
	pc = 0x82EBFDD8; continue 'dispatch;
	}
	// 82EBFC18: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC20: EDAC07F2  fmuls f13, f12, f31
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC24: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EBFC28: ED8B07F2  fmuls f12, f11, f31
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EBFC2C: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EBFC30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFC34: EFAB002A  fadds f29, f11, f0
	ctx.f[29].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBFC38: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC3C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EBFC40: EF8A682A  fadds f28, f10, f13
	ctx.f[28].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EBFC44: EF60602A  fadds f27, f0, f12
	ctx.f[27].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EBFC48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFC4C: 4E800421  bctrl
	ctx.lr = 0x82EBFC50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFC50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EBFC58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EBFC5C: 3B8A9128  addi r28, r10, -0x6ed8
	ctx.r[28].s64 = ctx.r[10].s64 + -28376;
	// 82EBFC60: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82EBFC64: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFC68: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EBFC6C: 83AB0250  lwz r29, 0x250(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EBFC70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EBFC74: 83C70014  lwz r30, 0x14(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EBFC78: D3C10054  stfs f30, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EBFC7C: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EBFC80: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EBFC84: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EBFC88: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC8C: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EBFC90: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC94: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EBFC98: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFC9C: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EBFCA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
            }
            0x82EBFCA4 => {
    //   block [0x82EBFCA4..0x82EBFD0C)
	// 82EBFCA4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EBFCA8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EBFCAC: 4200FFF8  bdnz 0x82ebfca4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBFCA4; continue 'dispatch;
	}
	// 82EBFCB0: 9B210118  stb r25, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[25].u8 ) };
	// 82EBFCB4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EBFCB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFCBC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFCC0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EBFCC4: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EBFCC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFCCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFCD0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFCD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFCD8: 4E800421  bctrl
	ctx.lr = 0x82EBFCDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFCDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFCE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EBFCE4: 3B4B9128  addi r26, r11, -0x6ed8
	ctx.r[26].s64 = ctx.r[11].s64 + -28376;
	// 82EBFCE8: 418200EC  beq 0x82ebfdd4
	if ctx.cr[0].eq {
	pc = 0x82EBFDD4; continue 'dispatch;
	}
	// 82EBFCEC: D3A10064  stfs f29, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EBFCF0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82EBFCF4: D3810068  stfs f28, 0x68(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EBFCF8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EBFCFC: D361006C  stfs f27, 0x6c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EBFD00: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EBFD04: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EBFD08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
            }
            0x82EBFD0C => {
    //   block [0x82EBFD0C..0x82EBFDD0)
	// 82EBFD0C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EBFD10: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EBFD14: 4200FFF8  bdnz 0x82ebfd0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EBFD0C; continue 'dispatch;
	}
	// 82EBFD18: 9B2100B8  stb r25, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u8 ) };
	// 82EBFD1C: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EBFD20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFD24: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFD28: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EBFD2C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EBFD30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFD34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFD38: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFD3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFD40: 4E800421  bctrl
	ctx.lr = 0x82EBFD44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFD44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFD48: 41820088  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD4C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFD50: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EBFD54: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EBFD58: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EBFD5C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EBFD60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFD64: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EBFD68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EBFD6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFD70: 4E800421  bctrl
	ctx.lr = 0x82EBFD74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFD74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFD78: 41820058  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD7C: C1A10058  lfs f13, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFD80: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFD84: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EBFD88: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EBFD8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EBFD90: 41990040  bgt cr6, 0x82ebfdd0
	if ctx.cr[6].gt {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFD94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EBFD98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EBFD9C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EBFDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EBFDA4: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EBFDA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EBFDAC: 4E800421  bctrl
	ctx.lr = 0x82EBFDB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EBFDB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EBFDB4: 4182001C  beq 0x82ebfdd0
	if ctx.cr[0].eq {
	pc = 0x82EBFDD0; continue 'dispatch;
	}
	// 82EBFDB8: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82EBFDBC: D3AB0004  stfs f29, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EBFDC0: D38B0008  stfs f28, 8(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EBFDC4: D36B000C  stfs f27, 0xc(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EBFDC8: 9B2B0058  stb r25, 0x58(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[25].u8 ) };
	// 82EBFDCC: D3FF0084  stfs f31, 0x84(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
            }
            0x82EBFDD0 => {
    //   block [0x82EBFDD0..0x82EBFDD4)
	// 82EBFDD0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	pc = 0x82EBFDD4; continue 'dispatch;
            }
            0x82EBFDD4 => {
    //   block [0x82EBFDD4..0x82EBFDD8)
	// 82EBFDD4: 934100C0  stw r26, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u32 ) };
	pc = 0x82EBFDD8; continue 'dispatch;
            }
            0x82EBFDD8 => {
    //   block [0x82EBFDD8..0x82EBFDDC)
	// 82EBFDD8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	pc = 0x82EBFDDC; continue 'dispatch;
            }
            0x82EBFDDC => {
    //   block [0x82EBFDDC..0x82EBFDE0)
	// 82EBFDDC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	pc = 0x82EBFDE0; continue 'dispatch;
            }
            0x82EBFDE0 => {
    //   block [0x82EBFDE0..0x82EBFDF8)
	// 82EBFDE0: 4BFB0119  bl 0x82e6fef8
	ctx.lr = 0x82EBFDE4;
	sub_82E6FEF8(ctx, base);
	// 82EBFDE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBFDE8: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82EBFDEC: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82EBFDF0: 4BDEDF31  bl 0x82cadd20
	ctx.lr = 0x82EBFDF4;
	sub_82CADCEC(ctx, base);
	// 82EBFDF4: 4BDE9650  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBFDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EBFDF8 size=88
    let mut pc: u32 = 0x82EBFDF8;
    'dispatch: loop {
        match pc {
            0x82EBFDF8 => {
    //   block [0x82EBFDF8..0x82EBFE34)
	// 82EBFDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBFDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EBFE00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EBFE04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EBFE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBFE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EBFE10: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82EBFE14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EBFE18: 4B756B11  bl 0x82616928
	ctx.lr = 0x82EBFE1C;
	sub_82616928(ctx, base);
	// 82EBFE1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFE20: 41820014  beq 0x82ebfe34
	if ctx.cr[0].eq {
	pc = 0x82EBFE34; continue 'dispatch;
	}
	// 82EBFE24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EBFE28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EBFE2C: 4BFF570D  bl 0x82eb5538
	ctx.lr = 0x82EBFE30;
	sub_82EB5538(ctx, base);
	// 82EBFE30: 48000008  b 0x82ebfe38
	pc = 0x82EBFE38; continue 'dispatch;
            }
            0x82EBFE34 => {
    //   block [0x82EBFE34..0x82EBFE38)
	// 82EBFE34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EBFE38; continue 'dispatch;
            }
            0x82EBFE38 => {
    //   block [0x82EBFE38..0x82EBFE50)
	// 82EBFE38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EBFE3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EBFE40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EBFE44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EBFE48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EBFE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EBFE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EBFE50 size=576
    let mut pc: u32 = 0x82EBFE50;
    'dispatch: loop {
        match pc {
            0x82EBFE50 => {
    //   block [0x82EBFE50..0x82EBFEB0)
	// 82EBFE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EBFE54: 4BDE95B9  bl 0x82ca940c
	ctx.lr = 0x82EBFE58;
	sub_82CA93D0(ctx, base);
	// 82EBFE58: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EBFE5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EBFE60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EBFE64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EBFE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFE6C: 482FC1F5  bl 0x831bc060
	ctx.lr = 0x82EBFE70;
	sub_831BC060(ctx, base);
	// 82EBFE70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFE74: 41820084  beq 0x82ebfef8
	if ctx.cr[0].eq {
	pc = 0x82EBFEF8; continue 'dispatch;
	}
	// 82EBFE78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBFE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFE80: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EBFE84: 482FC1DD  bl 0x831bc060
	ctx.lr = 0x82EBFE88;
	sub_831BC060(ctx, base);
	// 82EBFE88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFE8C: 4BDECCC5  bl 0x82cacb50
	ctx.lr = 0x82EBFE90;
	sub_82CACB50(ctx, base);
	// 82EBFE90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBFE94: 40820064  bne 0x82ebfef8
	if !ctx.cr[0].eq {
	pc = 0x82EBFEF8; continue 'dispatch;
	}
	// 82EBFE98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBFE9C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBFEA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFEA4: 4182000C  beq 0x82ebfeb0
	if ctx.cr[0].eq {
	pc = 0x82EBFEB0; continue 'dispatch;
	}
	// 82EBFEA8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBFEAC: 4800000C  b 0x82ebfeb8
	pc = 0x82EBFEB8; continue 'dispatch;
            }
            0x82EBFEB0 => {
    //   block [0x82EBFEB0..0x82EBFEB8)
	// 82EBFEB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFEB4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBFEB8; continue 'dispatch;
            }
            0x82EBFEB8 => {
    //   block [0x82EBFEB8..0x82EBFED8)
	// 82EBFEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFEBC: 4BA4DE4D  bl 0x8290dd08
	ctx.lr = 0x82EBFEC0;
	sub_8290DD08(ctx, base);
	// 82EBFEC0: 4BDEBCF1  bl 0x82cabbb0
	ctx.lr = 0x82EBFEC4;
	sub_82CABBB0(ctx, base);
	// 82EBFEC4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBFEC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFECC: C01D0014  lfs f0, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFED0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFED4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EBFED8; continue 'dispatch;
            }
            0x82EBFED8 => {
    //   block [0x82EBFED8..0x82EBFEE4)
	// 82EBFED8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBFEDC: 41980008  blt cr6, 0x82ebfee4
	if ctx.cr[6].lt {
	pc = 0x82EBFEE4; continue 'dispatch;
	}
	// 82EBFEE0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBFEE4; continue 'dispatch;
            }
            0x82EBFEE4 => {
    //   block [0x82EBFEE4..0x82EBFEF0)
	// 82EBFEE4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBFEE8: 409AFFF0  bne cr6, 0x82ebfed8
	if !ctx.cr[6].eq {
	pc = 0x82EBFED8; continue 'dispatch;
	}
	// 82EBFEEC: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82EBFEF0; continue 'dispatch;
            }
            0x82EBFEF0 => {
    //   block [0x82EBFEF0..0x82EBFEF8)
	// 82EBFEF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EBFEF4: 48000190  b 0x82ec0084
	pc = 0x82EC0084; continue 'dispatch;
            }
            0x82EBFEF8 => {
    //   block [0x82EBFEF8..0x82EBFF40)
	// 82EBFEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFEFC: 482FC165  bl 0x831bc060
	ctx.lr = 0x82EBFF00;
	sub_831BC060(ctx, base);
	// 82EBFF00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFF04: 41820080  beq 0x82ebff84
	if ctx.cr[0].eq {
	pc = 0x82EBFF84; continue 'dispatch;
	}
	// 82EBFF08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBFF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF10: 3BCBAF10  addi r30, r11, -0x50f0
	ctx.r[30].s64 = ctx.r[11].s64 + -20720;
	// 82EBFF14: 482FC14D  bl 0x831bc060
	ctx.lr = 0x82EBFF18;
	sub_831BC060(ctx, base);
	// 82EBFF18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFF1C: 4BDECC35  bl 0x82cacb50
	ctx.lr = 0x82EBFF20;
	sub_82CACB50(ctx, base);
	// 82EBFF20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBFF24: 40820060  bne 0x82ebff84
	if !ctx.cr[0].eq {
	pc = 0x82EBFF84; continue 'dispatch;
	}
	// 82EBFF28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EBFF2C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EBFF30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFF34: 4182000C  beq 0x82ebff40
	if ctx.cr[0].eq {
	pc = 0x82EBFF40; continue 'dispatch;
	}
	// 82EBFF38: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EBFF3C: 4800000C  b 0x82ebff48
	pc = 0x82EBFF48; continue 'dispatch;
            }
            0x82EBFF40 => {
    //   block [0x82EBFF40..0x82EBFF48)
	// 82EBFF40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFF44: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EBFF48; continue 'dispatch;
            }
            0x82EBFF48 => {
    //   block [0x82EBFF48..0x82EBFF68)
	// 82EBFF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF4C: 4BA4DDBD  bl 0x8290dd08
	ctx.lr = 0x82EBFF50;
	sub_8290DD08(ctx, base);
	// 82EBFF50: 4BDEBC61  bl 0x82cabbb0
	ctx.lr = 0x82EBFF54;
	sub_82CABBB0(ctx, base);
	// 82EBFF54: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBFF58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFF5C: C01D001C  lfs f0, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFF60: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EBFF64: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EBFF68; continue 'dispatch;
            }
            0x82EBFF68 => {
    //   block [0x82EBFF68..0x82EBFF74)
	// 82EBFF68: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBFF6C: 41980008  blt cr6, 0x82ebff74
	if ctx.cr[6].lt {
	pc = 0x82EBFF74; continue 'dispatch;
	}
	// 82EBFF70: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBFF74; continue 'dispatch;
            }
            0x82EBFF74 => {
    //   block [0x82EBFF74..0x82EBFF84)
	// 82EBFF74: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBFF78: 409AFFF0  bne cr6, 0x82ebff68
	if !ctx.cr[6].eq {
	pc = 0x82EBFF68; continue 'dispatch;
	}
	// 82EBFF7C: D01D001C  stfs f0, 0x1c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EBFF80: 4BFFFF70  b 0x82ebfef0
	pc = 0x82EBFEF0; continue 'dispatch;
            }
            0x82EBFF84 => {
    //   block [0x82EBFF84..0x82EBFFD0)
	// 82EBFF84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF88: 482FC0D9  bl 0x831bc060
	ctx.lr = 0x82EBFF8C;
	sub_831BC060(ctx, base);
	// 82EBFF8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFF90: 4182005C  beq 0x82ebffec
	if ctx.cr[0].eq {
	pc = 0x82EBFFEC; continue 'dispatch;
	}
	// 82EBFF94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EBFF98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFF9C: 3BCBAEFC  addi r30, r11, -0x5104
	ctx.r[30].s64 = ctx.r[11].s64 + -20740;
	// 82EBFFA0: 482FC0C1  bl 0x831bc060
	ctx.lr = 0x82EBFFA4;
	sub_831BC060(ctx, base);
	// 82EBFFA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EBFFA8: 4BDECBA9  bl 0x82cacb50
	ctx.lr = 0x82EBFFAC;
	sub_82CACB50(ctx, base);
	// 82EBFFAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EBFFB0: 4082003C  bne 0x82ebffec
	if !ctx.cr[0].eq {
	pc = 0x82EBFFEC; continue 'dispatch;
	}
	// 82EBFFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFFB8: 4BA4DD51  bl 0x8290dd08
	ctx.lr = 0x82EBFFBC;
	sub_8290DD08(ctx, base);
	// 82EBFFBC: 4BDEBBF5  bl 0x82cabbb0
	ctx.lr = 0x82EBFFC0;
	sub_82CABBB0(ctx, base);
	// 82EBFFC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EBFFC4: C01D0020  lfs f0, 0x20(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EBFFC8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EBFFCC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EBFFD0; continue 'dispatch;
            }
            0x82EBFFD0 => {
    //   block [0x82EBFFD0..0x82EBFFDC)
	// 82EBFFD0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EBFFD4: 41980008  blt cr6, 0x82ebffdc
	if ctx.cr[6].lt {
	pc = 0x82EBFFDC; continue 'dispatch;
	}
	// 82EBFFD8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EBFFDC; continue 'dispatch;
            }
            0x82EBFFDC => {
    //   block [0x82EBFFDC..0x82EBFFEC)
	// 82EBFFDC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EBFFE0: 409AFFF0  bne cr6, 0x82ebffd0
	if !ctx.cr[6].eq {
	pc = 0x82EBFFD0; continue 'dispatch;
	}
	// 82EBFFE4: D01D0020  stfs f0, 0x20(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EBFFE8: 4BFFFF08  b 0x82ebfef0
	pc = 0x82EBFEF0; continue 'dispatch;
            }
            0x82EBFFEC => {
    //   block [0x82EBFFEC..0x82EC0034)
	// 82EBFFEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EBFFF0: 482FC071  bl 0x831bc060
	ctx.lr = 0x82EBFFF4;
	sub_831BC060(ctx, base);
	// 82EBFFF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EBFFF8: 41820080  beq 0x82ec0078
	if ctx.cr[0].eq {
	pc = 0x82EC0078; continue 'dispatch;
	}
	// 82EBFFFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0004: 3BCBAEEC  addi r30, r11, -0x5114
	ctx.r[30].s64 = ctx.r[11].s64 + -20756;
	// 82EC0008: 482FC059  bl 0x831bc060
	ctx.lr = 0x82EC000C;
	sub_831BC060(ctx, base);
	// 82EC000C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0010: 4BDECB41  bl 0x82cacb50
	ctx.lr = 0x82EC0014;
	sub_82CACB50(ctx, base);
	// 82EC0014: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC0018: 40820060  bne 0x82ec0078
	if !ctx.cr[0].eq {
	pc = 0x82EC0078; continue 'dispatch;
	}
	// 82EC001C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0020: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0024: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0028: 4182000C  beq 0x82ec0034
	if ctx.cr[0].eq {
	pc = 0x82EC0034; continue 'dispatch;
	}
	// 82EC002C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC0030: 4800000C  b 0x82ec003c
	pc = 0x82EC003C; continue 'dispatch;
            }
            0x82EC0034 => {
    //   block [0x82EC0034..0x82EC003C)
	// 82EC0034: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0038: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC003C; continue 'dispatch;
            }
            0x82EC003C => {
    //   block [0x82EC003C..0x82EC005C)
	// 82EC003C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0040: 4BA4DCC9  bl 0x8290dd08
	ctx.lr = 0x82EC0044;
	sub_8290DD08(ctx, base);
	// 82EC0044: 4BDEBB6D  bl 0x82cabbb0
	ctx.lr = 0x82EC0048;
	sub_82CABBB0(ctx, base);
	// 82EC0048: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC004C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0050: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0054: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0058: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC005C; continue 'dispatch;
            }
            0x82EC005C => {
    //   block [0x82EC005C..0x82EC0068)
	// 82EC005C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC0060: 41980008  blt cr6, 0x82ec0068
	if ctx.cr[6].lt {
	pc = 0x82EC0068; continue 'dispatch;
	}
	// 82EC0064: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC0068; continue 'dispatch;
            }
            0x82EC0068 => {
    //   block [0x82EC0068..0x82EC0078)
	// 82EC0068: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC006C: 409AFFF0  bne cr6, 0x82ec005c
	if !ctx.cr[6].eq {
	pc = 0x82EC005C; continue 'dispatch;
	}
	// 82EC0070: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC0074: 4BFFFE7C  b 0x82ebfef0
	pc = 0x82EBFEF0; continue 'dispatch;
            }
            0x82EC0078 => {
    //   block [0x82EC0078..0x82EC0084)
	// 82EC0078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC007C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0080: 4BFF53A1  bl 0x82eb5420
	ctx.lr = 0x82EC0084;
	sub_82EB5420(ctx, base);
	pc = 0x82EC0084; continue 'dispatch;
            }
            0x82EC0084 => {
    //   block [0x82EC0084..0x82EC0090)
	// 82EC0084: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC0088: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC008C: 4BDE93D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0090 size=216
    let mut pc: u32 = 0x82EC0090;
    'dispatch: loop {
        match pc {
            0x82EC0090 => {
    //   block [0x82EC0090..0x82EC00CC)
	// 82EC0090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0098: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC009C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC00A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC00A4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC00A8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC00AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC00B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC00B4: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC00B8: C1890C14  lfs f12, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC00BC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC00C0: 4182000C  beq 0x82ec00cc
	if ctx.cr[0].eq {
	pc = 0x82EC00CC; continue 'dispatch;
	}
	// 82EC00C4: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC00C8: 48000008  b 0x82ec00d0
	pc = 0x82EC00D0; continue 'dispatch;
            }
            0x82EC00CC => {
    //   block [0x82EC00CC..0x82EC00D0)
	// 82EC00CC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EC00D0; continue 'dispatch;
            }
            0x82EC00D0 => {
    //   block [0x82EC00D0..0x82EC00F4)
	// 82EC00D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC00D4: C1AA0A54  lfs f13, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC00D8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC00DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC00E0: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC00E4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC00E8: 4182000C  beq 0x82ec00f4
	if ctx.cr[0].eq {
	pc = 0x82EC00F4; continue 'dispatch;
	}
	// 82EC00EC: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC00F0: 48000008  b 0x82ec00f8
	pc = 0x82EC00F8; continue 'dispatch;
            }
            0x82EC00F4 => {
    //   block [0x82EC00F4..0x82EC00F8)
	// 82EC00F4: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EC00F8; continue 'dispatch;
            }
            0x82EC00F8 => {
    //   block [0x82EC00F8..0x82EC011C)
	// 82EC00F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC00FC: D19F0020  stfs f12, 0x20(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC0100: C00A0A7C  lfs f0, 0xa7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0104: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0108: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC010C: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0110: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0114: 41820008  beq 0x82ec011c
	if ctx.cr[0].eq {
	pc = 0x82EC011C; continue 'dispatch;
	}
	// 82EC0118: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC011C; continue 'dispatch;
            }
            0x82EC011C => {
    //   block [0x82EC011C..0x82EC0168)
	// 82EC011C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC0120: 388A1BA0  addi r4, r10, 0x1ba0
	ctx.r[4].s64 = ctx.r[10].s64 + 7072;
	// 82EC0124: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0128: C00A0A9C  lfs f0, 0xa9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2716 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC012C: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0130: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC0134: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0138: 4B3A7AE9  bl 0x82267c20
	ctx.lr = 0x82EC013C;
	sub_82267C20(ctx, base);
	// 82EC013C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC0140: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0148: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC014C: 48003F2D  bl 0x82ec4078
	ctx.lr = 0x82EC0150;
	sub_82EC4078(ctx, base);
	// 82EC0150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC015C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC0160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC0164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC0168 size=76
    let mut pc: u32 = 0x82EC0168;
    'dispatch: loop {
        match pc {
            0x82EC0168 => {
    //   block [0x82EC0168..0x82EC01A0)
	// 82EC0168: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC016C: C1A40004  lfs f13, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0170: C00B02DC  lfs f0, 0x2dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0174: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC0178: 409A0028  bne cr6, 0x82ec01a0
	if !ctx.cr[6].eq {
	pc = 0x82EC01A0; continue 'dispatch;
	}
	// 82EC017C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0180: C1AB02E0  lfs f13, 0x2e0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(736 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0184: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC0188: 409A0018  bne cr6, 0x82ec01a0
	if !ctx.cr[6].eq {
	pc = 0x82EC01A0; continue 'dispatch;
	}
	// 82EC018C: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0190: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0194: C1AB02E4  lfs f13, 0x2e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(740 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0198: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC019C: 419A0008  beq cr6, 0x82ec01a4
	if ctx.cr[6].eq {
	pc = 0x82EC01A4; continue 'dispatch;
	}
	pc = 0x82EC01A0; continue 'dispatch;
            }
            0x82EC01A0 => {
    //   block [0x82EC01A0..0x82EC01A4)
	// 82EC01A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82EC01A4; continue 'dispatch;
            }
            0x82EC01A4 => {
    //   block [0x82EC01A4..0x82EC01B4)
	// 82EC01A4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC01A8: 4182000C  beq 0x82ec01b4
	if ctx.cr[0].eq {
		sub_82EC01B4(ctx, base);
		return;
	}
	// 82EC01AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC01B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC01B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC01B4 size=84
    let mut pc: u32 = 0x82EC01B4;
    'dispatch: loop {
        match pc {
            0x82EC01B4 => {
    //   block [0x82EC01B4..0x82EC0208)
	// 82EC01B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC01B8: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC01BC: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC01C0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC01C4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC01C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC01CC: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC01D0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC01D4: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC01D8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC01DC: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC01E0: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC01E4: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC01E8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC01EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC01F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC01F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC01F8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC01FC: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82EC0200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0208 size=1088
    let mut pc: u32 = 0x82EC0208;
    'dispatch: loop {
        match pc {
            0x82EC0208 => {
    //   block [0x82EC0208..0x82EC0268)
	// 82EC0208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC020C: 4BDE91F5  bl 0x82ca9400
	ctx.lr = 0x82EC0210;
	sub_82CA93D0(ctx, base);
	// 82EC0210: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EC0214: 4BDEDAB5  bl 0x82cadcc8
	ctx.lr = 0x82EC0218;
	sub_82CADCA0(ctx, base);
	// 82EC0218: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC021C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC0220: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0224: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC0228: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EC022C: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC0230: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC0234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0238: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82EC023C: 4B32843D  bl 0x821e8678
	ctx.lr = 0x82EC0240;
	sub_821E8678(ctx, base);
	// 82EC0240: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0244: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0248: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC024C: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82EC0250: C3AA0C14  lfs f29, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC0254: C3CB0BFC  lfs f30, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC0258: 41820010  beq 0x82ec0268
	if ctx.cr[0].eq {
	pc = 0x82EC0268; continue 'dispatch;
	}
	// 82EC025C: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0260: EFE007B2  fmuls f31, f0, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC0264: 4800001C  b 0x82ec0280
	pc = 0x82EC0280; continue 'dispatch;
            }
            0x82EC0268 => {
    //   block [0x82EC0268..0x82EC027C)
	// 82EC0268: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC026C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0270: 4182000C  beq 0x82ec027c
	if ctx.cr[0].eq {
	pc = 0x82EC027C; continue 'dispatch;
	}
	// 82EC0274: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC0278: 48000008  b 0x82ec0280
	pc = 0x82EC0280; continue 'dispatch;
            }
            0x82EC027C => {
    //   block [0x82EC027C..0x82EC0280)
	// 82EC027C: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	pc = 0x82EC0280; continue 'dispatch;
            }
            0x82EC0280 => {
    //   block [0x82EC0280..0x82EC0310)
	// 82EC0280: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0284: 807C0024  lwz r3, 0x24(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0288: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EC028C: C1BC0020  lfs f13, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0290: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0294: C15C0030  lfs f10, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC0298: C13C002C  lfs f9, 0x2c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC029C: C0E30034  lfs f7, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC02A0: C11C0028  lfs f8, 0x28(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC02A4: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC02A8: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC02AC: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC02B0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC02B4: C1A3003C  lfs f13, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC02B8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC02BC: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC02C0: ED8C3828  fsubs f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EC02C4: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC02C8: EC09683A  fmadds f0, f9, f0, f13
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC02CC: EC08033A  fmadds f0, f8, f12, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC02D0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EC02D4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC02D8: 4199035C  bgt cr6, 0x82ec0634
	if ctx.cr[6].gt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC02DC: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC02E0: 419A0354  beq cr6, 0x82ec0634
	if ctx.cr[6].eq {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC02E4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC02E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC02EC: 419A0348  beq cr6, 0x82ec0634
	if ctx.cr[6].eq {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC02F0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC02F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC02F8: 41820018  beq 0x82ec0310
	if ctx.cr[0].eq {
	pc = 0x82EC0310; continue 'dispatch;
	}
	// 82EC02FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0300: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0304: 4E800421  bctrl
	ctx.lr = 0x82EC0308;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0308: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC030C: 41820328  beq 0x82ec0634
	if ctx.cr[0].eq {
	pc = 0x82EC0634; continue 'dispatch;
	}
            }
            0x82EC0310 => {
    //   block [0x82EC0310..0x82EC0364)
	// 82EC0310: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0314: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0318: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC031C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC0320: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC0324: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC0328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC032C: C35F0034  lfs f26, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EC0330: C33F003C  lfs f25, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EC0334: EF00F828  fsubs f24, f0, f31
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EC0338: 4B328341  bl 0x821e8678
	ctx.lr = 0x82EC033C;
	sub_821E8678(ctx, base);
	// 82EC033C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0340: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC0344: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EC0348: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC034C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0350: 4B328329  bl 0x821e8678
	ctx.lr = 0x82EC0354;
	sub_821E8678(ctx, base);
	// 82EC0354: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC0358: 419A000C  beq cr6, 0x82ec0364
	if ctx.cr[6].eq {
	pc = 0x82EC0364; continue 'dispatch;
	}
	// 82EC035C: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0360: 4800001C  b 0x82ec037c
	pc = 0x82EC037C; continue 'dispatch;
            }
            0x82EC0364 => {
    //   block [0x82EC0364..0x82EC0378)
	// 82EC0364: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0368: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC036C: 4182000C  beq 0x82ec0378
	if ctx.cr[0].eq {
	pc = 0x82EC0378; continue 'dispatch;
	}
	// 82EC0370: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0374: 48000008  b 0x82ec037c
	pc = 0x82EC037C; continue 'dispatch;
            }
            0x82EC0378 => {
    //   block [0x82EC0378..0x82EC037C)
	// 82EC0378: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EC037C; continue 'dispatch;
            }
            0x82EC037C => {
    //   block [0x82EC037C..0x82EC03C8)
	// 82EC037C: C1BC001C  lfs f13, 0x1c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0380: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC0384: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC038C: 419A0204  beq cr6, 0x82ec0590
	if ctx.cr[6].eq {
	pc = 0x82EC0590; continue 'dispatch;
	}
	// 82EC0390: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0394: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0398: ED6B67BA  fmadds f11, f11, f30, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EC039C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC03A0: ED8C682A  fadds f12, f12, f13
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC03A4: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EC03A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC03AC: EFEB682A  fadds f31, f11, f13
	ctx.f[31].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC03B0: EFCC002A  fadds f30, f12, f0
	ctx.f[30].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC03B4: 4B3282C5  bl 0x821e8678
	ctx.lr = 0x82EC03B8;
	sub_821E8678(ctx, base);
	// 82EC03B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC03BC: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 82EC03C0: 40820008  bne 0x82ec03c8
	if !ctx.cr[0].eq {
	pc = 0x82EC03C8; continue 'dispatch;
	}
	// 82EC03C4: 395F004C  addi r10, r31, 0x4c
	ctx.r[10].s64 = ctx.r[31].s64 + 76;
	pc = 0x82EC03C8; continue 'dispatch;
            }
            0x82EC03C8 => {
    //   block [0x82EC03C8..0x82EC0524)
	// 82EC03C8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC03CC: C38A0004  lfs f28, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EC03D0: C36A0008  lfs f27, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC03D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC03D8: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC03DC: C3AA0000  lfs f29, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC03E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC03E4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC03E8: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC03EC: ED7C0372  fmuls f11, f28, f13
	ctx.f[11].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC03F0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC03F4: ED5B0332  fmuls f10, f27, f12
	ctx.f[10].f64 = (((ctx.f[27].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC03F8: ED3D0032  fmuls f9, f29, f0
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC03FC: EC1B5838  fmsubs f0, f27, f0, f11
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC0400: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0404: EC1D5378  fmsubs f0, f29, f13, f10
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC0408: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC040C: EC1C4B38  fmsubs f0, f28, f12, f9
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC0410: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0414: 4B3BEE55  bl 0x8227f268
	ctx.lr = 0x82EC0418;
	sub_8227F268(ctx, base);
	// 82EC0418: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC041C: C1BF0038  lfs f13, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0420: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0424: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0428: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC042C: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0430: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0434: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0438: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC043C: ED4D6028  fsubs f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0440: EDA00732  fmuls f13, f0, f28
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC0444: EDAB6EFA  fmadds f13, f11, f27, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC0448: EDAA6F7A  fmadds f13, f10, f29, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC044C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82EC0450: 419901E4  bgt cr6, 0x82ec0634
	if ctx.cr[6].gt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0454: FD80F850  fneg f12, f31
	ctx.f[12].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC0458: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC045C: 419801D8  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0460: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0464: ED2D0032  fmuls f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0468: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC046C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0470: ED6C4AFA  fmadds f11, f12, f11, f9
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EC0474: ED605ABA  fmadds f11, f0, f10, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EC0478: FF0BF000  fcmpu cr6, f11, f30
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[30].f64);
	// 82EC047C: 419901B8  bgt cr6, 0x82ec0634
	if ctx.cr[6].gt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC0480: FD40F050  fneg f10, f30
	ctx.f[10].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC0484: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 82EC0488: 419801AC  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC048C: ED7D07F2  fmuls f11, f29, f31
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC0490: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC0494: ED5C07F2  fmuls f10, f28, f31
	ctx.f[10].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC0498: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82EC049C: ED3B07F2  fmuls f9, f27, f31
	ctx.f[9].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC04A0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC04A4: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC04A8: ED8C07B2  fmuls f12, f12, f30
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC04AC: ED0BD02A  fadds f8, f11, f26
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EC04B0: ECEAC02A  fadds f7, f10, f24
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EC04B4: ECC9C82A  fadds f6, f9, f25
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EC04B8: ED7A5828  fsubs f11, f26, f11
	ctx.f[11].f64 = (((ctx.f[26].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC04BC: ED585028  fsubs f10, f24, f10
	ctx.f[10].f64 = (((ctx.f[24].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC04C0: ED394828  fsubs f9, f25, f9
	ctx.f[9].f64 = (((ctx.f[25].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC04C4: ECA8002A  fadds f5, f8, f0
	ctx.f[5].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC04C8: D0A10070  stfs f5, 0x70(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC04CC: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC04D0: D101007C  stfs f8, 0x7c(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EC04D4: ED076828  fsubs f8, f7, f13
	ctx.f[8].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC04D8: D1010080  stfs f8, 0x80(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EC04DC: ED066028  fsubs f8, f6, f12
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC04E0: D1010084  stfs f8, 0x84(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC04E4: ED0B0028  fsubs f8, f11, f0
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC04E8: D1010088  stfs f8, 0x88(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC04EC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC04F0: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EC04F4: ECA7682A  fadds f5, f7, f13
	ctx.f[5].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC04F8: D0A10074  stfs f5, 0x74(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC04FC: ED0A6828  fsubs f8, f10, f13
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0500: D101008C  stfs f8, 0x8c(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EC0504: EC0A682A  fadds f0, f10, f13
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC0508: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EC050C: ECA6602A  fadds f5, f6, f12
	ctx.f[5].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC0510: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC0514: ED096028  fsubs f8, f9, f12
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0518: D1010090  stfs f8, 0x90(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EC051C: EC09602A  fadds f0, f9, f12
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC0520: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x82EC0524; continue 'dispatch;
            }
            0x82EC0524 => {
    //   block [0x82EC0524..0x82EC057C)
	// 82EC0524: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0528: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82EC052C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EC0530: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0534: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 82EC0538: 57EB07BE  clrlwi r11, r31, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000003u64;
	// 82EC053C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EC0540: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EC0544: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0548: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EC054C: 4B3C8BCD  bl 0x82289118
	ctx.lr = 0x82EC0550;
	sub_82289118(ctx, base);
	// 82EC0550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0554: 40820034  bne 0x82ec0588
	if !ctx.cr[0].eq {
	pc = 0x82EC0588; continue 'dispatch;
	}
	// 82EC0558: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82EC055C: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 82EC0560: 4198FFC4  blt cr6, 0x82ec0524
	if ctx.cr[6].lt {
	pc = 0x82EC0524; continue 'dispatch;
	}
	// 82EC0564: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0568: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC056C: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0570: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0574: D01A0004  stfs f0, 4(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0578: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC057C; continue 'dispatch;
            }
            0x82EC057C => {
    //   block [0x82EC057C..0x82EC0588)
	// 82EC057C: D01A0008  stfs f0, 8(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0580: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0584: 480000B4  b 0x82ec0638
	pc = 0x82EC0638; continue 'dispatch;
            }
            0x82EC0588 => {
    //   block [0x82EC0588..0x82EC0590)
	// 82EC0588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC058C: 480000AC  b 0x82ec0638
	pc = 0x82EC0638; continue 'dispatch;
            }
            0x82EC0590 => {
    //   block [0x82EC0590..0x82EC0600)
	// 82EC0590: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC0594: C13A0000  lfs f9, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC0598: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC059C: C11A0008  lfs f8, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC05A0: ED88C828  fsubs f12, f8, f25
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[25].f64) as f32) as f64);
	// 82EC05A4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC05A8: C0EB0008  lfs f7, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC05AC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC05B0: EDA9D028  fsubs f13, f9, f26
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[26].f64) as f32) as f64);
	// 82EC05B4: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC05B8: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC05BC: ED47533A  fmadds f10, f7, f12, f10
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC05C0: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 82EC05C4: 41980070  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05C8: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82EC05CC: 40980068  bge cr6, 0x82ec0634
	if !ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05D0: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC05D4: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC05D8: EDAC69F8  fmsubs f13, f12, f7, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC05DC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EC05E0: 41980054  blt cr6, 0x82ec0634
	if ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC05E8: 4098004C  bge cr6, 0x82ec0634
	if !ctx.cr[6].lt {
	pc = 0x82EC0634; continue 'dispatch;
	}
	// 82EC05EC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC05F0: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC05F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC05F8: 40980008  bge cr6, 0x82ec0600
	if !ctx.cr[6].lt {
	pc = 0x82EC0600; continue 'dispatch;
	}
	// 82EC05FC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC0600; continue 'dispatch;
            }
            0x82EC0600 => {
    //   block [0x82EC0600..0x82EC0634)
	// 82EC0600: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0604: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0608: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC060C: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC0610: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0614: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0618: C17A0004  lfs f11, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC061C: EDA96828  fsubs f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0620: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0624: EDAB6028  fsubs f13, f11, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0628: D1BA0004  stfs f13, 4(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC062C: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC0630: 4BFFFF4C  b 0x82ec057c
	pc = 0x82EC057C; continue 'dispatch;
            }
            0x82EC0634 => {
    //   block [0x82EC0634..0x82EC0638)
	// 82EC0634: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC0638; continue 'dispatch;
            }
            0x82EC0638 => {
    //   block [0x82EC0638..0x82EC0648)
	// 82EC0638: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC063C: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82EC0640: 4BDED6D5  bl 0x82cadd14
	ctx.lr = 0x82EC0644;
	sub_82CADCEC(ctx, base);
	// 82EC0644: 4BDE8E0C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0648 size=512
    let mut pc: u32 = 0x82EC0648;
    'dispatch: loop {
        match pc {
            0x82EC0648 => {
    //   block [0x82EC0648..0x82EC073C)
	// 82EC0648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC064C: 4BDE8DB9  bl 0x82ca9404
	ctx.lr = 0x82EC0650;
	sub_82CA93D0(ctx, base);
	// 82EC0650: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82EC0654: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82EC0658: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC065C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0660: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0664: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC0668: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EC066C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC0674: 419A0174  beq cr6, 0x82ec07e8
	if ctx.cr[6].eq {
	pc = 0x82EC07E8; continue 'dispatch;
	}
	// 82EC0678: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC067C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0680: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0684: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0688: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC068C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0690: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0694: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0698: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC069C: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC06A0: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC06A4: C1A30038  lfs f13, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC06A8: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC06AC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC06B0: C143003C  lfs f10, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC06B4: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC06B8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC06BC: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC06C0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC06C4: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC06C8: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC06CC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC06D0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EC06D4: 419A0114  beq cr6, 0x82ec07e8
	if ctx.cr[6].eq {
	pc = 0x82EC07E8; continue 'dispatch;
	}
	// 82EC06D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC06DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC06E0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC06E4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC06E8: EC1FF024  fdivs f0, f31, f30
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[30].f64) as f32) as f64;
	// 82EC06EC: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC06F0: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC06F4: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC06F8: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC06FC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0700: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC0704: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0708: 4B327F71  bl 0x821e8678
	ctx.lr = 0x82EC070C;
	sub_821E8678(ctx, base);
	// 82EC070C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0710: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC0714: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC0718: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC071C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0720: 4B327F59  bl 0x821e8678
	ctx.lr = 0x82EC0724;
	sub_821E8678(ctx, base);
	// 82EC0724: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC0728: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EC072C: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0730: 419A000C  beq cr6, 0x82ec073c
	if ctx.cr[6].eq {
	pc = 0x82EC073C; continue 'dispatch;
	}
	// 82EC0734: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0738: 48000018  b 0x82ec0750
	pc = 0x82EC0750; continue 'dispatch;
            }
            0x82EC073C => {
    //   block [0x82EC073C..0x82EC074C)
	// 82EC073C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0740: 4182000C  beq 0x82ec074c
	if ctx.cr[0].eq {
	pc = 0x82EC074C; continue 'dispatch;
	}
	// 82EC0744: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0748: 48000008  b 0x82ec0750
	pc = 0x82EC0750; continue 'dispatch;
            }
            0x82EC074C => {
    //   block [0x82EC074C..0x82EC0750)
	// 82EC074C: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x82EC0750; continue 'dispatch;
            }
            0x82EC0750 => {
    //   block [0x82EC0750..0x82EC0774)
	// 82EC0750: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0758: 396B0BFC  addi r11, r11, 0xbfc
	ctx.r[11].s64 = ctx.r[11].s64 + 3068;
	// 82EC075C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0760: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0764: 419A0010  beq cr6, 0x82ec0774
	if ctx.cr[6].eq {
	pc = 0x82EC0774; continue 'dispatch;
	}
	// 82EC0768: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC076C: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0770: 48000010  b 0x82ec0780
	pc = 0x82EC0780; continue 'dispatch;
            }
            0x82EC0774 => {
    //   block [0x82EC0774..0x82EC0780)
	// 82EC0774: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0778: 41820008  beq 0x82ec0780
	if ctx.cr[0].eq {
	pc = 0x82EC0780; continue 'dispatch;
	}
	// 82EC077C: C3EA000C  lfs f31, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC0780; continue 'dispatch;
            }
            0x82EC0780 => {
    //   block [0x82EC0780..0x82EC07BC)
	// 82EC0780: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EC0784: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC0788: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC078C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82EC0790: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0794: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EC0798: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC079C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC07A0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82EC07A4: 41820060  beq 0x82ec0804
	if ctx.cr[0].eq {
	pc = 0x82EC0804; continue 'dispatch;
	}
	// 82EC07A8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC07AC: C03F0018  lfs f1, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC07B0: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC07B4: 4BFC74F5  bl 0x82e87ca8
	ctx.lr = 0x82EC07B8;
	sub_82E87CA8(ctx, base);
	// 82EC07B8: 48000028  b 0x82ec07e0
	pc = 0x82EC07E0; continue 'dispatch;
            }
            0x82EC07BC => {
    //   block [0x82EC07BC..0x82EC07E0)
	// 82EC07BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC07C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC07C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC07C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC07CC: 4BFFFA3D  bl 0x82ec0208
	ctx.lr = 0x82EC07D0;
	sub_82EC0208(ctx, base);
	// 82EC07D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC07D4: 40820028  bne 0x82ec07fc
	if !ctx.cr[0].eq {
	pc = 0x82EC07FC; continue 'dispatch;
	}
	// 82EC07D8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC07DC: 4BFC6F95  bl 0x82e87770
	ctx.lr = 0x82EC07E0;
	sub_82E87770(ctx, base);
	pc = 0x82EC07E0; continue 'dispatch;
            }
            0x82EC07E0 => {
    //   block [0x82EC07E0..0x82EC07E8)
	// 82EC07E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC07E4: 4082FFD8  bne 0x82ec07bc
	if !ctx.cr[0].eq {
	pc = 0x82EC07BC; continue 'dispatch;
	}
	pc = 0x82EC07E8; continue 'dispatch;
            }
            0x82EC07E8 => {
    //   block [0x82EC07E8..0x82EC07EC)
	// 82EC07E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC07EC; continue 'dispatch;
            }
            0x82EC07EC => {
    //   block [0x82EC07EC..0x82EC07FC)
	// 82EC07EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EC07F0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EC07F4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EC07F8: 4BDE8C5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC07FC => {
    //   block [0x82EC07FC..0x82EC0804)
	// 82EC07FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC0800: 4BFFFFEC  b 0x82ec07ec
	pc = 0x82EC07EC; continue 'dispatch;
            }
            0x82EC0804 => {
    //   block [0x82EC0804..0x82EC0810)
	// 82EC0804: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0808: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC080C: 48000028  b 0x82ec0834
	pc = 0x82EC0834; continue 'dispatch;
            }
            0x82EC0810 => {
    //   block [0x82EC0810..0x82EC0834)
	// 82EC0810: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0814: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC0818: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC081C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0820: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC0824: 4BFFF9E5  bl 0x82ec0208
	ctx.lr = 0x82EC0828;
	sub_82EC0208(ctx, base);
	// 82EC0828: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC082C: 40820014  bne 0x82ec0840
	if !ctx.cr[0].eq {
	pc = 0x82EC0840; continue 'dispatch;
	}
	// 82EC0830: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC0834; continue 'dispatch;
            }
            0x82EC0834 => {
    //   block [0x82EC0834..0x82EC0840)
	// 82EC0834: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0838: 4082FFD8  bne 0x82ec0810
	if !ctx.cr[0].eq {
	pc = 0x82EC0810; continue 'dispatch;
	}
	// 82EC083C: 4BFFFFAC  b 0x82ec07e8
	pc = 0x82EC07E8; continue 'dispatch;
            }
            0x82EC0840 => {
    //   block [0x82EC0840..0x82EC0848)
	// 82EC0840: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0844: 4BFFFFA8  b 0x82ec07ec
	pc = 0x82EC07EC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0848 size=736
    let mut pc: u32 = 0x82EC0848;
    'dispatch: loop {
        match pc {
            0x82EC0848 => {
    //   block [0x82EC0848..0x82EC0998)
	// 82EC0848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC084C: 4BDE8BB9  bl 0x82ca9404
	ctx.lr = 0x82EC0850;
	sub_82CA93D0(ctx, base);
	// 82EC0850: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EC0854: 4BDED481  bl 0x82cadcd4
	ctx.lr = 0x82EC0858;
	sub_82CADCA0(ctx, base);
	// 82EC0858: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC085C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC0860: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0868: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC086C: 4BFAF68D  bl 0x82e6fef8
	ctx.lr = 0x82EC0870;
	sub_82E6FEF8(ctx, base);
	// 82EC0870: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0874: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC087C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC0880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0884: 4E800421  bctrl
	ctx.lr = 0x82EC0888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0888: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC088C: 40820288  bne 0x82ec0b14
	if !ctx.cr[0].eq {
	pc = 0x82EC0B14; continue 'dispatch;
	}
	// 82EC0890: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0894: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0898: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC089C: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC08A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC08A4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC08A8: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC08AC: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EC08B0: ED6D5828  fsubs f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC08B4: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC08B8: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC08BC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC08C0: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC08C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC08C8: C36B0C18  lfs f27, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC08CC: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC08D0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC08D4: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC08D8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC08DC: 419A0238  beq cr6, 0x82ec0b14
	if ctx.cr[6].eq {
	pc = 0x82EC0B14; continue 'dispatch;
	}
	// 82EC08E0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC08E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC08E8: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC08EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC08F0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC08F4: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC08F8: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC08FC: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC0900: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC0904: EFC002F2  fmuls f30, f0, f11
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC0908: EFE002B2  fmuls f31, f0, f10
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC090C: EFA00332  fmuls f29, f0, f12
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC0910: FC00F050  fneg f0, f30
	ctx.f[0].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC0914: ED7F06F2  fmuls f11, f31, f27
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EC0918: EDBD07F2  fmuls f13, f29, f31
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC091C: ED9E0032  fmuls f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0920: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC0924: D01E0030  stfs f0, 0x30(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC0928: EDBE6EF8  fmsubs f13, f30, f27, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[27].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC092C: D1BE0028  stfs f13, 0x28(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC0930: ED9F67F8  fmsubs f12, f31, f31, f12
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0934: D19E002C  stfs f12, 0x2c(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC0938: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC093C: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0940: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 82EC0944: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0948: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC094C: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0950: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0954: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0958: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC095C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC0960: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0964: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC0968: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC096C: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC0970: ED2C4828  fsubs f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC0974: C10B0034  lfs f8, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC0978: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC097C: 83EA0014  lwz r31, 0x14(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0980: 2C1F0000  cmpwi r31, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC0984: ED4A0772  fmuls f10, f10, f29
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC0988: ED4957BA  fmadds f10, f9, f30, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[30].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC098C: EF8057FA  fmadds f28, f0, f31, f10
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC0990: 40810140  ble 0x82ec0ad0
	if !ctx.cr[0].gt {
	pc = 0x82EC0AD0; continue 'dispatch;
	}
	// 82EC0994: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
            }
            0x82EC0998 => {
    //   block [0x82EC0998..0x82EC0A38)
	// 82EC0998: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC099C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EC09A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC09A4: 4BFFFCA5  bl 0x82ec0648
	ctx.lr = 0x82EC09A8;
	sub_82EC0648(ctx, base);
	// 82EC09A8: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC09AC: 7C661B79  or. r6, r3, r3
	ctx.r[6].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82EC09B0: 41820118  beq 0x82ec0ac8
	if ctx.cr[0].eq {
	pc = 0x82EC0AC8; continue 'dispatch;
	}
	// 82EC09B4: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC09B8: C01BD240  lfs f0, -0x2dc0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC09BC: ED3C0028  fsubs f9, f28, f0
	ctx.f[9].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC09C0: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC09C4: ED4D6028  fsubs f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC09C8: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC09CC: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC09D0: ED0C5828  fsubs f8, f12, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC09D4: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC09D8: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC09DC: ECEB3828  fsubs f7, f11, f7
	ctx.f[7].f64 = (((ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EC09E0: ED4A0772  fmuls f10, f10, f29
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC09E4: ED4857BA  fmadds f10, f8, f30, f10
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[30].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC09E8: ED4757FA  fmadds f10, f7, f31, f10
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC09EC: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EC09F0: 40990064  ble cr6, 0x82ec0a54
	if !ctx.cr[6].gt {
	pc = 0x82EC0A54; continue 'dispatch;
	}
	// 82EC09F4: FF0AD800  fcmpu cr6, f10, f27
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[27].f64);
	// 82EC09F8: 41980040  blt cr6, 0x82ec0a38
	if ctx.cr[6].lt {
	pc = 0x82EC0A38; continue 'dispatch;
	}
	// 82EC09FC: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82EC0A00: 40990038  ble cr6, 0x82ec0a38
	if !ctx.cr[6].gt {
	pc = 0x82EC0A38; continue 'dispatch;
	}
	// 82EC0A04: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0A08: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0A0C: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0A10: EC1E0032  fmuls f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0A14: FD404890  fmr f10, f9
	ctx.f[10].f64 = ctx.f[9].f64;
	// 82EC0A18: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC0A1C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0A20: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC0A24: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0A28: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0A2C: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC0A30: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0A34: 4800001C  b 0x82ec0a50
	pc = 0x82EC0A50; continue 'dispatch;
            }
            0x82EC0A38 => {
    //   block [0x82EC0A38..0x82EC0A50)
	// 82EC0A38: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC0A3C: FD40D890  fmr f10, f27
	ctx.f[10].f64 = ctx.f[27].f64;
	// 82EC0A40: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC0A44: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC0A48: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC0A4C: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC0A50; continue 'dispatch;
            }
            0x82EC0A50 => {
    //   block [0x82EC0A50..0x82EC0A54)
	// 82EC0A50: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x82EC0A54; continue 'dispatch;
            }
            0x82EC0A54 => {
    //   block [0x82EC0A54..0x82EC0A74)
	// 82EC0A54: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC0A58: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 82EC0A5C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0A60: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EC0A64: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC0A68: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC0A6C: FF805090  fmr f28, f10
	ctx.f[28].f64 = ctx.f[10].f64;
	// 82EC0A70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC0A74; continue 'dispatch;
            }
            0x82EC0A74 => {
    //   block [0x82EC0A74..0x82EC0AB0)
	// 82EC0A74: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC0A78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC0A7C: 4200FFF8  bdnz 0x82ec0a74
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC0A74; continue 'dispatch;
	}
	// 82EC0A80: 9B9D0058  stb r28, 0x58(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	// 82EC0A84: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0A88: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0A8C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EC0A90: 409A0020  bne cr6, 0x82ec0ab0
	if !ctx.cr[6].eq {
	pc = 0x82EC0AB0; continue 'dispatch;
	}
	// 82EC0A94: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0A98: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC0A9C: 409A0014  bne cr6, 0x82ec0ab0
	if !ctx.cr[6].eq {
	pc = 0x82EC0AB0; continue 'dispatch;
	}
	// 82EC0AA0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC0AA8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EC0AAC: 419A0008  beq cr6, 0x82ec0ab4
	if ctx.cr[6].eq {
	pc = 0x82EC0AB4; continue 'dispatch;
	}
	pc = 0x82EC0AB0; continue 'dispatch;
            }
            0x82EC0AB0 => {
    //   block [0x82EC0AB0..0x82EC0AB4)
	// 82EC0AB0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EC0AB4; continue 'dispatch;
            }
            0x82EC0AB4 => {
    //   block [0x82EC0AB4..0x82EC0AC8)
	// 82EC0AB4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0AB8: 40820018  bne 0x82ec0ad0
	if !ctx.cr[0].eq {
	pc = 0x82EC0AD0; continue 'dispatch;
	}
	// 82EC0ABC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0AC0: 4181FED8  bgt 0x82ec0998
	if ctx.cr[0].gt {
	pc = 0x82EC0998; continue 'dispatch;
	}
	// 82EC0AC4: 4800000C  b 0x82ec0ad0
	pc = 0x82EC0AD0; continue 'dispatch;
            }
            0x82EC0AC8 => {
    //   block [0x82EC0AC8..0x82EC0AD0)
	// 82EC0AC8: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC0ACC: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82EC0AD0; continue 'dispatch;
            }
            0x82EC0AD0 => {
    //   block [0x82EC0AD0..0x82EC0AF8)
	// 82EC0AD0: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AD4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC0AD8: 409A0020  bne cr6, 0x82ec0af8
	if !ctx.cr[6].eq {
	pc = 0x82EC0AF8; continue 'dispatch;
	}
	// 82EC0ADC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AE0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC0AE4: 409A0014  bne cr6, 0x82ec0af8
	if !ctx.cr[6].eq {
	pc = 0x82EC0AF8; continue 'dispatch;
	}
	// 82EC0AE8: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0AEC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC0AF0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC0AF4: 419A0008  beq cr6, 0x82ec0afc
	if ctx.cr[6].eq {
	pc = 0x82EC0AFC; continue 'dispatch;
	}
	pc = 0x82EC0AF8; continue 'dispatch;
            }
            0x82EC0AF8 => {
    //   block [0x82EC0AF8..0x82EC0AFC)
	// 82EC0AF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EC0AFC; continue 'dispatch;
            }
            0x82EC0AFC => {
    //   block [0x82EC0AFC..0x82EC0B14)
	// 82EC0AFC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0B00: 41820014  beq 0x82ec0b14
	if ctx.cr[0].eq {
	pc = 0x82EC0B14; continue 'dispatch;
	}
	// 82EC0B04: D17D0004  stfs f11, 4(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0B08: D1BD0008  stfs f13, 8(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC0B0C: D19D000C  stfs f12, 0xc(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC0B10: 9B9D0058  stb r28, 0x58(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
	pc = 0x82EC0B14; continue 'dispatch;
            }
            0x82EC0B14 => {
    //   block [0x82EC0B14..0x82EC0B28)
	// 82EC0B14: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0B18: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC0B1C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EC0B20: 4BDED201  bl 0x82cadd20
	ctx.lr = 0x82EC0B24;
	sub_82CADCEC(ctx, base);
	// 82EC0B24: 4BDE8930  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0B28 size=12
    let mut pc: u32 = 0x82EC0B28;
    'dispatch: loop {
        match pc {
            0x82EC0B28 => {
    //   block [0x82EC0B28..0x82EC0B34)
	// 82EC0B28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC0B2C: 386BD358  addi r3, r11, -0x2ca8
	ctx.r[3].s64 = ctx.r[11].s64 + -11432;
	// 82EC0B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0B38 size=84
    let mut pc: u32 = 0x82EC0B38;
    'dispatch: loop {
        match pc {
            0x82EC0B38 => {
    //   block [0x82EC0B38..0x82EC0B80)
	// 82EC0B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0B3C: 4BDE88D1  bl 0x82ca940c
	ctx.lr = 0x82EC0B40;
	sub_82CA93D0(ctx, base);
	// 82EC0B40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0B44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0B48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC0B4C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0B50: 4B755DD9  bl 0x82616928
	ctx.lr = 0x82EC0B54;
	sub_82616928(ctx, base);
	// 82EC0B54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0B58: 41820028  beq 0x82ec0b80
	if ctx.cr[0].eq {
	pc = 0x82EC0B80; continue 'dispatch;
	}
	// 82EC0B5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0B60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0B68: 4BFF47C9  bl 0x82eb5330
	ctx.lr = 0x82EC0B6C;
	sub_82EB5330(ctx, base);
	// 82EC0B6C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0B74: 396BAF44  addi r11, r11, -0x50bc
	ctx.r[11].s64 = ctx.r[11].s64 + -20668;
	// 82EC0B78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0B7C: 48000008  b 0x82ec0b84
	pc = 0x82EC0B84; continue 'dispatch;
            }
            0x82EC0B80 => {
    //   block [0x82EC0B80..0x82EC0B84)
	// 82EC0B80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC0B84; continue 'dispatch;
            }
            0x82EC0B84 => {
    //   block [0x82EC0B84..0x82EC0B8C)
	// 82EC0B84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0B88: 4BDE88D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0B90 size=40
    let mut pc: u32 = 0x82EC0B90;
    'dispatch: loop {
        match pc {
            0x82EC0B90 => {
    //   block [0x82EC0B90..0x82EC0BB8)
	// 82EC0B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0B98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0B9C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82EC0BA0: 4BFAF359  bl 0x82e6fef8
	ctx.lr = 0x82EC0BA4;
	sub_82E6FEF8(ctx, base);
	// 82EC0BA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC0BA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0BB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0BB8 size=12
    let mut pc: u32 = 0x82EC0BB8;
    'dispatch: loop {
        match pc {
            0x82EC0BB8 => {
    //   block [0x82EC0BB8..0x82EC0BC4)
	// 82EC0BB8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC0BBC: 386BD47C  addi r3, r11, -0x2b84
	ctx.r[3].s64 = ctx.r[11].s64 + -11140;
	// 82EC0BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0BC8 size=84
    let mut pc: u32 = 0x82EC0BC8;
    'dispatch: loop {
        match pc {
            0x82EC0BC8 => {
    //   block [0x82EC0BC8..0x82EC0C10)
	// 82EC0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0BCC: 4BDE8841  bl 0x82ca940c
	ctx.lr = 0x82EC0BD0;
	sub_82CA93D0(ctx, base);
	// 82EC0BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0BD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0BD8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC0BDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0BE0: 4B755D49  bl 0x82616928
	ctx.lr = 0x82EC0BE4;
	sub_82616928(ctx, base);
	// 82EC0BE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0BE8: 41820028  beq 0x82ec0c10
	if ctx.cr[0].eq {
	pc = 0x82EC0C10; continue 'dispatch;
	}
	// 82EC0BEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0BF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0BF8: 4BFF4739  bl 0x82eb5330
	ctx.lr = 0x82EC0BFC;
	sub_82EB5330(ctx, base);
	// 82EC0BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0C04: 396BAF7C  addi r11, r11, -0x5084
	ctx.r[11].s64 = ctx.r[11].s64 + -20612;
	// 82EC0C08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0C0C: 48000008  b 0x82ec0c14
	pc = 0x82EC0C14; continue 'dispatch;
            }
            0x82EC0C10 => {
    //   block [0x82EC0C10..0x82EC0C14)
	// 82EC0C10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC0C14; continue 'dispatch;
            }
            0x82EC0C14 => {
    //   block [0x82EC0C14..0x82EC0C1C)
	// 82EC0C14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0C18: 4BDE8844  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0C20 size=120
    let mut pc: u32 = 0x82EC0C20;
    'dispatch: loop {
        match pc {
            0x82EC0C20 => {
    //   block [0x82EC0C20..0x82EC0C60)
	// 82EC0C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0C28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0C2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC0C30: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC0C34: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EC0C38: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0C3C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC0C40: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82EC0C44: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0C48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC0C4C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0C50: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0C54: 409A000C  bne cr6, 0x82ec0c60
	if !ctx.cr[6].eq {
	pc = 0x82EC0C60; continue 'dispatch;
	}
	// 82EC0C58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC0C5C: 48000020  b 0x82ec0c7c
	pc = 0x82EC0C7C; continue 'dispatch;
            }
            0x82EC0C60 => {
    //   block [0x82EC0C60..0x82EC0C7C)
	// 82EC0C60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC0C64: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0C68: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EC0C6C: C00A0C4C  lfs f0, 0xc4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0C70: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0C74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0C78: 4E800421  bctrl
	ctx.lr = 0x82EC0C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC0C7C => {
    //   block [0x82EC0C7C..0x82EC0C98)
	// 82EC0C7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC0C80: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC0C84: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC0C88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0C8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0C90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0C94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC0C98 size=124
    let mut pc: u32 = 0x82EC0C98;
    'dispatch: loop {
        match pc {
            0x82EC0C98 => {
    //   block [0x82EC0C98..0x82EC0CD8)
	// 82EC0C98: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82EC0C9C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82EC0CA0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82EC0CA4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82EC0CA8: 816AD478  lwz r11, -0x2b88(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11144 as u32) ) } as u64;
	// 82EC0CAC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC0CB0: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 82EC0CB4: 3909D46C  addi r8, r9, -0x2b94
	ctx.r[8].s64 = ctx.r[9].s64 + -11156;
	// 82EC0CB8: 40820020  bne 0x82ec0cd8
	if !ctx.cr[0].eq {
	pc = 0x82EC0CD8; continue 'dispatch;
	}
	// 82EC0CBC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EC0CC0: 916AD478  stw r11, -0x2b88(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-11144 as u32), ctx.r[11].u32 ) };
	// 82EC0CC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0CC8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0CCC: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC0CD0: D0080004  stfs f0, 4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC0CD4: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EC0CD8; continue 'dispatch;
            }
            0x82EC0CD8 => {
    //   block [0x82EC0CD8..0x82EC0D14)
	// 82EC0CD8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC0CDC: 394BDAC0  addi r10, r11, -0x2540
	ctx.r[10].s64 = ctx.r[11].s64 + -9536;
	// 82EC0CE0: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC0CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC0CE8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC0CEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC0CF0: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0CF4: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC0CF8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EC0CFC: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0D00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0D04: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC0D08: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC0D0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC0D10: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0D14 size=4
    let mut pc: u32 = 0x82EC0D14;
    'dispatch: loop {
        match pc {
            0x82EC0D14 => {
    //   block [0x82EC0D14..0x82EC0D18)
	// 82EC0D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0D18 size=12
    let mut pc: u32 = 0x82EC0D18;
    'dispatch: loop {
        match pc {
            0x82EC0D18 => {
    //   block [0x82EC0D18..0x82EC0D24)
	// 82EC0D18: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0D1C: 386BB38C  addi r3, r11, -0x4c74
	ctx.r[3].s64 = ctx.r[11].s64 + -19572;
	// 82EC0D20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0D28 size=92
    let mut pc: u32 = 0x82EC0D28;
    'dispatch: loop {
        match pc {
            0x82EC0D28 => {
    //   block [0x82EC0D28..0x82EC0D78)
	// 82EC0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0D2C: 4BDE86E1  bl 0x82ca940c
	ctx.lr = 0x82EC0D30;
	sub_82CA93D0(ctx, base);
	// 82EC0D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0D34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0D38: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC0D3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0D40: 4B755BE9  bl 0x82616928
	ctx.lr = 0x82EC0D44;
	sub_82616928(ctx, base);
	// 82EC0D44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC0D48: 41820030  beq 0x82ec0d78
	if ctx.cr[0].eq {
	pc = 0x82EC0D78; continue 'dispatch;
	}
	// 82EC0D4C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC0D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC0D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0D58: 4BFF45D9  bl 0x82eb5330
	ctx.lr = 0x82EC0D5C;
	sub_82EB5330(ctx, base);
	// 82EC0D5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0D60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0D64: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EC0D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0D6C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EC0D70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0D74: 48000008  b 0x82ec0d7c
	pc = 0x82EC0D7C; continue 'dispatch;
            }
            0x82EC0D78 => {
    //   block [0x82EC0D78..0x82EC0D7C)
	// 82EC0D78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC0D7C; continue 'dispatch;
            }
            0x82EC0D7C => {
    //   block [0x82EC0D7C..0x82EC0D84)
	// 82EC0D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC0D80: 4BDE86DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0D88 size=92
    let mut pc: u32 = 0x82EC0D88;
    'dispatch: loop {
        match pc {
            0x82EC0D88 => {
    //   block [0x82EC0D88..0x82EC0DC8)
	// 82EC0D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC0D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC0D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0D9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0DA0: 396BA890  addi r11, r11, -0x5770
	ctx.r[11].s64 = ctx.r[11].s64 + -22384;
	// 82EC0DA4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0DA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0DAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC0DB0: 41820018  beq 0x82ec0dc8
	if ctx.cr[0].eq {
	pc = 0x82EC0DC8; continue 'dispatch;
	}
	// 82EC0DB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0DB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC0DBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0DC4: 4E800421  bctrl
	ctx.lr = 0x82EC0DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC0DC8 => {
    //   block [0x82EC0DC8..0x82EC0DE4)
	// 82EC0DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC0DCC: 4BFF45FD  bl 0x82eb53c8
	ctx.lr = 0x82EC0DD0;
	sub_82EB53C8(ctx, base);
	// 82EC0DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC0DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC0DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC0DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC0DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC0DE8 size=316
    let mut pc: u32 = 0x82EC0DE8;
    'dispatch: loop {
        match pc {
            0x82EC0DE8 => {
    //   block [0x82EC0DE8..0x82EC0E6C)
	// 82EC0DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0DEC: 4BDE8615  bl 0x82ca9400
	ctx.lr = 0x82EC0DF0;
	sub_82CA93D0(ctx, base);
	// 82EC0DF0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EC0DF4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0DF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EC0DFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC0E00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC0E04: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82EC0E08: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0E0C: 834B0048  lwz r26, 0x48(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0E10: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E14: 41820100  beq 0x82ec0f14
	if ctx.cr[0].eq {
	pc = 0x82EC0F14; continue 'dispatch;
	}
	// 82EC0E18: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0E1C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E20: 418200F4  beq 0x82ec0f14
	if ctx.cr[0].eq {
	pc = 0x82EC0F14; continue 'dispatch;
	}
	// 82EC0E24: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0E28: 813C000C  lwz r9, 0xc(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC0E30: 3BEBB38C  addi r31, r11, -0x4c74
	ctx.r[31].s64 = ctx.r[11].s64 + -19572;
	// 82EC0E34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0E38: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC0E3C: 4BFC88A5  bl 0x82e896e0
	ctx.lr = 0x82EC0E40;
	sub_82E896E0(ctx, base);
	// 82EC0E40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC0E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC0E48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC0E4C: 4BFC8895  bl 0x82e896e0
	ctx.lr = 0x82EC0E50;
	sub_82E896E0(ctx, base);
	// 82EC0E50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC0E54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E58: 419A0014  beq cr6, 0x82ec0e6c
	if ctx.cr[6].eq {
	pc = 0x82EC0E6C; continue 'dispatch;
	}
	// 82EC0E5C: 897E001C  lbz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0E60: 38FE0004  addi r7, r30, 4
	ctx.r[7].s64 = ctx.r[30].s64 + 4;
	// 82EC0E64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E68: 40820008  bne 0x82ec0e70
	if !ctx.cr[0].eq {
	pc = 0x82EC0E70; continue 'dispatch;
	}
	pc = 0x82EC0E6C; continue 'dispatch;
            }
            0x82EC0E6C => {
    //   block [0x82EC0E6C..0x82EC0E70)
	// 82EC0E6C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	pc = 0x82EC0E70; continue 'dispatch;
            }
            0x82EC0E70 => {
    //   block [0x82EC0E70..0x82EC0E88)
	// 82EC0E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E74: 419A0014  beq cr6, 0x82ec0e88
	if ctx.cr[6].eq {
	pc = 0x82EC0E88; continue 'dispatch;
	}
	// 82EC0E78: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0E7C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82EC0E80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E84: 40820008  bne 0x82ec0e8c
	if !ctx.cr[0].eq {
	pc = 0x82EC0E8C; continue 'dispatch;
	}
	pc = 0x82EC0E88; continue 'dispatch;
            }
            0x82EC0E88 => {
    //   block [0x82EC0E88..0x82EC0E8C)
	// 82EC0E88: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x82EC0E8C; continue 'dispatch;
            }
            0x82EC0E8C => {
    //   block [0x82EC0E8C..0x82EC0EF4)
	// 82EC0E8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC0E90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EC0E94: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EC0E98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82EC0E9C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC0EA0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EC0EA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC0EA8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC0EAC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC0EB0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EC0EB4: 409A0044  bne cr6, 0x82ec0ef8
	if !ctx.cr[6].eq {
	pc = 0x82EC0EF8; continue 'dispatch;
	}
	// 82EC0EB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC0EBC: 807A0048  lwz r3, 0x48(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0EC0: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82EC0EC4: 4822D935  bl 0x830ee7f8
	ctx.lr = 0x82EC0EC8;
	sub_830EE7F8(ctx, base);
	// 82EC0EC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC0ECC: 40820028  bne 0x82ec0ef4
	if !ctx.cr[0].eq {
	pc = 0x82EC0EF4; continue 'dispatch;
	}
	// 82EC0ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC0ED4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC0ED8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC0EDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC0EE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC0EE4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC0EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC0EEC: 4E800421  bctrl
	ctx.lr = 0x82EC0EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC0EF0: 48000028  b 0x82ec0f18
	pc = 0x82EC0F18; continue 'dispatch;
            }
            0x82EC0EF4 => {
    //   block [0x82EC0EF4..0x82EC0EF8)
	// 82EC0EF4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	pc = 0x82EC0EF8; continue 'dispatch;
            }
            0x82EC0EF8 => {
    //   block [0x82EC0EF8..0x82EC0F14)
	// 82EC0EF8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82EC0EFC: 807A0048  lwz r3, 0x48(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F00: 38BB0004  addi r5, r27, 4
	ctx.r[5].s64 = ctx.r[27].s64 + 4;
	// 82EC0F04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC0F08: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82EC0F0C: 4822E445  bl 0x830ef350
	ctx.lr = 0x82EC0F10;
	sub_830EF350(ctx, base);
	// 82EC0F10: 48000008  b 0x82ec0f18
	pc = 0x82EC0F18; continue 'dispatch;
            }
            0x82EC0F14 => {
    //   block [0x82EC0F14..0x82EC0F18)
	// 82EC0F14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC0F18; continue 'dispatch;
            }
            0x82EC0F18 => {
    //   block [0x82EC0F18..0x82EC0F24)
	// 82EC0F18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC0F1C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EC0F20: 4BDE8530  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC0F28 size=40
    let mut pc: u32 = 0x82EC0F28;
    'dispatch: loop {
        match pc {
            0x82EC0F28 => {
    //   block [0x82EC0F28..0x82EC0F38)
	// 82EC0F28: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 82EC0F2C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC0F30: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC0F34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC0F38; continue 'dispatch;
            }
            0x82EC0F38 => {
    //   block [0x82EC0F38..0x82EC0F50)
	// 82EC0F38: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC0F3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC0F40: 4200FFF8  bdnz 0x82ec0f38
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC0F38; continue 'dispatch;
	}
	// 82EC0F44: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82EC0F48: 99270058  stb r9, 0x58(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 82EC0F4C: 4BFAEFAC  b 0x82e6fef8
	sub_82E6FEF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC0F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC0F50 size=548
    let mut pc: u32 = 0x82EC0F50;
    'dispatch: loop {
        match pc {
            0x82EC0F50 => {
    //   block [0x82EC0F50..0x82EC0FF4)
	// 82EC0F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC0F54: 4BDE8495  bl 0x82ca93e8
	ctx.lr = 0x82EC0F58;
	sub_82CA93D0(ctx, base);
	// 82EC0F58: DBE1FF90  stfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82EC0F5C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC0F60: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC0F64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC0F68: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82EC0F6C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82EC0F70: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82EC0F74: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC0F78: 828B0048  lwz r20, 0x48(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F7C: 28140000  cmplwi r20, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0F80: 418201B8  beq 0x82ec1138
	if ctx.cr[0].eq {
	pc = 0x82EC1138; continue 'dispatch;
	}
	// 82EC0F84: 81540048  lwz r10, 0x48(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC0F88: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0F8C: 418201AC  beq 0x82ec1138
	if ctx.cr[0].eq {
	pc = 0x82EC1138; continue 'dispatch;
	}
	// 82EC0F90: 8139000C  lwz r9, 0xc(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC0F94: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 82EC0F98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC0F9C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82EC0FA0: 3B6BB38C  addi r27, r11, -0x4c74
	ctx.r[27].s64 = ctx.r[11].s64 + -19572;
	// 82EC0FA4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FA8: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EC0FAC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC0FB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC0FB4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FB8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC0FBC: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC0FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC0FC4: 4BFC871D  bl 0x82e896e0
	ctx.lr = 0x82EC0FC8;
	sub_82E896E0(ctx, base);
	// 82EC0FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC0FCC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC0FD0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC0FD4: 4BFC870D  bl 0x82e896e0
	ctx.lr = 0x82EC0FD8;
	sub_82E896E0(ctx, base);
	// 82EC0FD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC0FDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FE0: 419A0014  beq cr6, 0x82ec0ff4
	if ctx.cr[6].eq {
	pc = 0x82EC0FF4; continue 'dispatch;
	}
	// 82EC0FE4: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC0FE8: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 82EC0FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FF0: 40820008  bne 0x82ec0ff8
	if !ctx.cr[0].eq {
	pc = 0x82EC0FF8; continue 'dispatch;
	}
	pc = 0x82EC0FF4; continue 'dispatch;
            }
            0x82EC0FF4 => {
    //   block [0x82EC0FF4..0x82EC0FF8)
	// 82EC0FF4: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	pc = 0x82EC0FF8; continue 'dispatch;
            }
            0x82EC0FF8 => {
    //   block [0x82EC0FF8..0x82EC1010)
	// 82EC0FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC0FFC: 419A0014  beq cr6, 0x82ec1010
	if ctx.cr[6].eq {
	pc = 0x82EC1010; continue 'dispatch;
	}
	// 82EC1000: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC1004: 3AE30004  addi r23, r3, 4
	ctx.r[23].s64 = ctx.r[3].s64 + 4;
	// 82EC1008: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC100C: 40820008  bne 0x82ec1014
	if !ctx.cr[0].eq {
	pc = 0x82EC1014; continue 'dispatch;
	}
	pc = 0x82EC1010; continue 'dispatch;
            }
            0x82EC1010 => {
    //   block [0x82EC1010..0x82EC1014)
	// 82EC1010: 7FD7F378  mr r23, r30
	ctx.r[23].u64 = ctx.r[30].u64;
	pc = 0x82EC1014; continue 'dispatch;
            }
            0x82EC1014 => {
    //   block [0x82EC1014..0x82EC1080)
	// 82EC1014: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1018: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82EC101C: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82EC1020: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82EC1024: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EC1028: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 82EC102C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82EC1030: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82EC1034: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82EC1038: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 82EC103C: 409A0048  bne cr6, 0x82ec1084
	if !ctx.cr[6].eq {
	pc = 0x82EC1084; continue 'dispatch;
	}
	// 82EC1040: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EC1044: 80740048  lwz r3, 0x48(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1048: 38960004  addi r4, r22, 4
	ctx.r[4].s64 = ctx.r[22].s64 + 4;
	// 82EC104C: 4822D7AD  bl 0x830ee7f8
	ctx.lr = 0x82EC1050;
	sub_830EE7F8(ctx, base);
	// 82EC1050: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1054: 4082002C  bne 0x82ec1080
	if !ctx.cr[0].eq {
	pc = 0x82EC1080; continue 'dispatch;
	}
	// 82EC1058: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC105C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82EC1060: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC1064: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82EC1068: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EC106C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC1070: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EC1074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1078: 4E800421  bctrl
	ctx.lr = 0x82EC107C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC107C: 480000EC  b 0x82ec1168
	pc = 0x82EC1168; continue 'dispatch;
            }
            0x82EC1080 => {
    //   block [0x82EC1080..0x82EC1084)
	// 82EC1080: 3B010090  addi r24, r1, 0x90
	ctx.r[24].s64 = ctx.r[1].s64 + 144;
	pc = 0x82EC1084; continue 'dispatch;
            }
            0x82EC1084 => {
    //   block [0x82EC1084..0x82EC10B8)
	// 82EC1084: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EC1088: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC108C: 4BFC8655  bl 0x82e896e0
	ctx.lr = 0x82EC1090;
	sub_82E896E0(ctx, base);
	// 82EC1090: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82EC1094: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82EC1098: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82EC109C: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82EC10A0: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82EC10A4: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82EC10A8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82EC10AC: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82EC10B0: 40820008  bne 0x82ec10b8
	if !ctx.cr[0].eq {
	pc = 0x82EC10B8; continue 'dispatch;
	}
	// 82EC10B4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x82EC10B8; continue 'dispatch;
            }
            0x82EC10B8 => {
    //   block [0x82EC10B8..0x82EC1118)
	// 82EC10B8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82EC10BC: 80740048  lwz r3, 0x48(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC10C0: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82EC10C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC10C8: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82EC10CC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82EC10D0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC10D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC10D8: 38960004  addi r4, r22, 4
	ctx.r[4].s64 = ctx.r[22].s64 + 4;
	// 82EC10DC: 4822DC75  bl 0x830eed50
	ctx.lr = 0x82EC10E0;
	sub_830EED50(ctx, base);
	// 82EC10E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EC10E4: 419A0034  beq cr6, 0x82ec1118
	if ctx.cr[6].eq {
	pc = 0x82EC1118; continue 'dispatch;
	}
	// 82EC10E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC10EC: 997B001C  stb r11, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EC10F0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC10F4: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EC10F8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC10FC: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EC1100: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC1104: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EC1108: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EC110C: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1110: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EC1114: 917B0018  stw r11, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC1118; continue 'dispatch;
            }
            0x82EC1118 => {
    //   block [0x82EC1118..0x82EC1138)
	// 82EC1118: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC111C: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1120: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1124: D0150004  stfs f0, 4(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC1128: D1B50008  stfs f13, 8(r21)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC112C: D195000C  stfs f12, 0xc(r21)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1130: 9BD50058  stb r30, 0x58(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EC1134: 48000034  b 0x82ec1168
	pc = 0x82EC1168; continue 'dispatch;
            }
            0x82EC1138 => {
    //   block [0x82EC1138..0x82EC114C)
	// 82EC1138: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC113C: 39750010  addi r11, r21, 0x10
	ctx.r[11].s64 = ctx.r[21].s64 + 16;
	// 82EC1140: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EC1144: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC1148: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC114C; continue 'dispatch;
            }
            0x82EC114C => {
    //   block [0x82EC114C..0x82EC1168)
	// 82EC114C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC1150: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC1154: 4200FFF8  bdnz 0x82ec114c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC114C; continue 'dispatch;
	}
	// 82EC1158: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EC115C: 9BD50058  stb r30, 0x58(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82EC1160: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82EC1164: 4BFAED95  bl 0x82e6fef8
	ctx.lr = 0x82EC1168;
	sub_82E6FEF8(ctx, base);
	pc = 0x82EC1168; continue 'dispatch;
            }
            0x82EC1168 => {
    //   block [0x82EC1168..0x82EC1174)
	// 82EC1168: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC116C: CBE1FF90  lfd f31, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EC1170: 4BDE82C8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1178 size=84
    let mut pc: u32 = 0x82EC1178;
    'dispatch: loop {
        match pc {
            0x82EC1178 => {
    //   block [0x82EC1178..0x82EC11B4)
	// 82EC1178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC117C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1184: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1188: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC118C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1190: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC1194: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC1198: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC119C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC11A0: 41820014  beq 0x82ec11b4
	if ctx.cr[0].eq {
	pc = 0x82EC11B4; continue 'dispatch;
	}
	// 82EC11A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC11A8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EC11AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC11B0: 4E800421  bctrl
	ctx.lr = 0x82EC11B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC11B4 => {
    //   block [0x82EC11B4..0x82EC11CC)
	// 82EC11B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC11B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC11BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC11C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC11C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC11C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC11D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC11D0 size=604
    let mut pc: u32 = 0x82EC11D0;
    'dispatch: loop {
        match pc {
            0x82EC11D0 => {
    //   block [0x82EC11D0..0x82EC121C)
	// 82EC11D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC11D4: 4BDE8229  bl 0x82ca93fc
	ctx.lr = 0x82EC11D8;
	sub_82CA93D0(ctx, base);
	// 82EC11D8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82EC11DC: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC11E0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EC11E4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EC11E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC11EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC11F0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82EC11F4: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC11F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC11FC: 4BFC84E5  bl 0x82e896e0
	ctx.lr = 0x82EC1200;
	sub_82E896E0(ctx, base);
	// 82EC1200: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82EC1204: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1208: 41820014  beq 0x82ec121c
	if ctx.cr[0].eq {
	pc = 0x82EC121C; continue 'dispatch;
	}
	// 82EC120C: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC1210: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82EC1214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1218: 40820008  bne 0x82ec1220
	if !ctx.cr[0].eq {
	pc = 0x82EC1220; continue 'dispatch;
	}
	pc = 0x82EC121C; continue 'dispatch;
            }
            0x82EC121C => {
    //   block [0x82EC121C..0x82EC1220)
	// 82EC121C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x82EC1220; continue 'dispatch;
            }
            0x82EC1220 => {
    //   block [0x82EC1220..0x82EC12A0)
	// 82EC1220: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1224: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1228: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 82EC122C: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82EC1230: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EC1234: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 82EC1238: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC123C: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82EC1240: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EC1244: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1248: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 82EC124C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EC1250: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EC1254: 83AA0048  lwz r29, 0x48(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1258: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC125C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1260: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82EC1264: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC1268: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82EC126C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1270: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82EC1274: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC1278: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82EC127C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EC1280: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EC1284: 409A0028  bne cr6, 0x82ec12ac
	if !ctx.cr[6].eq {
	pc = 0x82EC12AC; continue 'dispatch;
	}
	// 82EC1288: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EC128C: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC1290: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 82EC1294: 4822D565  bl 0x830ee7f8
	ctx.lr = 0x82EC1298;
	sub_830EE7F8(ctx, base);
	// 82EC1298: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC129C: 4082000C  bne 0x82ec12a8
	if !ctx.cr[0].eq {
	pc = 0x82EC12A8; continue 'dispatch;
	}
	pc = 0x82EC12A0; continue 'dispatch;
            }
            0x82EC12A0 => {
    //   block [0x82EC12A0..0x82EC12A8)
	// 82EC12A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC12A4: 4800017C  b 0x82ec1420
	pc = 0x82EC1420; continue 'dispatch;
            }
            0x82EC12A8 => {
    //   block [0x82EC12A8..0x82EC12AC)
	// 82EC12A8: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	pc = 0x82EC12AC; continue 'dispatch;
            }
            0x82EC12AC => {
    //   block [0x82EC12AC..0x82EC1308)
	// 82EC12AC: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82EC12B0: 807D0048  lwz r3, 0x48(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC12B4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82EC12B8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC12BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC12C0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC12C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC12C8: 38990004  addi r4, r25, 4
	ctx.r[4].s64 = ctx.r[25].s64 + 4;
	// 82EC12CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC12D0: 4822DA81  bl 0x830eed50
	ctx.lr = 0x82EC12D4;
	sub_830EED50(ctx, base);
	// 82EC12D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC12D8: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12DC: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 82EC12E0: 3BCB9128  addi r30, r11, -0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + -28376;
	// 82EC12E4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC12E8: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12EC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82EC12F0: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC12F4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC12F8: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC12FC: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC1300: 93C100D0  stw r30, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 82EC1304: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EC1308; continue 'dispatch;
            }
            0x82EC1308 => {
    //   block [0x82EC1308..0x82EC1340)
	// 82EC1308: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC130C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC1310: 4200FFF8  bdnz 0x82ec1308
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC1308; continue 'dispatch;
	}
	// 82EC1314: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC1318: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC131C: 9BE10128  stb r31, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[31].u8 ) };
	// 82EC1320: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82EC1324: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC1328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC132C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1330: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1334: 409A000C  bne cr6, 0x82ec1340
	if !ctx.cr[6].eq {
	pc = 0x82EC1340; continue 'dispatch;
	}
	// 82EC1338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC133C: 48000028  b 0x82ec1364
	pc = 0x82EC1364; continue 'dispatch;
            }
            0x82EC1340 => {
    //   block [0x82EC1340..0x82EC1364)
	// 82EC1340: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1344: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC1348: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EC134C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EC1350: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC1354: C00A0C4C  lfs f0, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1358: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC135C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1360: 4E800421  bctrl
	ctx.lr = 0x82EC1364;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC1364 => {
    //   block [0x82EC1364..0x82EC13A4)
	// 82EC1364: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC1368: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC136C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC1370: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EC1374: 4082FF2C  bne 0x82ec12a0
	if !ctx.cr[0].eq {
	pc = 0x82EC12A0; continue 'dispatch;
	}
	// 82EC1378: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC137C: 39610140  addi r11, r1, 0x140
	ctx.r[11].s64 = ctx.r[1].s64 + 320;
	// 82EC1380: D0010134  stfs f0, 0x134(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82EC1384: 93C10130  stw r30, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 82EC1388: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC138C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82EC1390: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82EC1394: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC1398: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC139C: D001013C  stfs f0, 0x13c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 82EC13A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC13A4; continue 'dispatch;
            }
            0x82EC13A4 => {
    //   block [0x82EC13A4..0x82EC1420)
	// 82EC13A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC13A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EC13AC: 4200FFF8  bdnz 0x82ec13a4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC13A4; continue 'dispatch;
	}
	// 82EC13B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC13B4: 9BE10188  stb r31, 0x188(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[31].u8 ) };
	// 82EC13B8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EC13BC: 938100B4  stw r28, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[28].u32 ) };
	// 82EC13C0: 396BAFB8  addi r11, r11, -0x5048
	ctx.r[11].s64 = ctx.r[11].s64 + -20552;
	// 82EC13C4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82EC13C8: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EC13CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC13D0: 996100CC  stb r11, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u8 ) };
	// 82EC13D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC13D8: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82EC13DC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC13E0: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82EC13E4: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EC13E8: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EC13EC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EC13F0: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EC13F4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EC13F8: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EC13FC: 4B2ED2AD  bl 0x821ae6a8
	ctx.lr = 0x82EC1400;
	sub_821AE6A8(ctx, base);
	// 82EC1400: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1404: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EC1408: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82EC140C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82EC1410: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC1414: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1418: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC141C: 4E800421  bctrl
	ctx.lr = 0x82EC1420;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC1420 => {
    //   block [0x82EC1420..0x82EC142C)
	// 82EC1420: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 82EC1424: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EC1428: 4BDE8024  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1430 size=116
    let mut pc: u32 = 0x82EC1430;
    'dispatch: loop {
        match pc {
            0x82EC1430 => {
    //   block [0x82EC1430..0x82EC145C)
	// 82EC1430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC143C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1444: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1448: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC144C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1450: 41820030  beq 0x82ec1480
	if ctx.cr[0].eq {
	pc = 0x82EC1480; continue 'dispatch;
	}
	// 82EC1454: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC1458: 48000020  b 0x82ec1478
	pc = 0x82EC1478; continue 'dispatch;
            }
            0x82EC145C => {
    //   block [0x82EC145C..0x82EC1478)
	// 82EC145C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC1464: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1468: 4BDEB6E9  bl 0x82cacb50
	ctx.lr = 0x82EC146C;
	sub_82CACB50(ctx, base);
	// 82EC146C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1470: 4182002C  beq 0x82ec149c
	if ctx.cr[0].eq {
	pc = 0x82EC149C; continue 'dispatch;
	}
	// 82EC1474: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC1478; continue 'dispatch;
            }
            0x82EC1478 => {
    //   block [0x82EC1478..0x82EC1480)
	// 82EC1478: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC147C: 4082FFE0  bne 0x82ec145c
	if !ctx.cr[0].eq {
	pc = 0x82EC145C; continue 'dispatch;
	}
	pc = 0x82EC1480; continue 'dispatch;
            }
            0x82EC1480 => {
    //   block [0x82EC1480..0x82EC1484)
	// 82EC1480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC1484; continue 'dispatch;
            }
            0x82EC1484 => {
    //   block [0x82EC1484..0x82EC149C)
	// 82EC1484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC148C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1498: 4E800020  blr
	return;
            }
            0x82EC149C => {
    //   block [0x82EC149C..0x82EC14A4)
	// 82EC149C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC14A0: 4BFFFFE4  b 0x82ec1484
	pc = 0x82EC1484; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC14A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC14A8 size=208
    let mut pc: u32 = 0x82EC14A8;
    'dispatch: loop {
        match pc {
            0x82EC14A8 => {
    //   block [0x82EC14A8..0x82EC14CC)
	// 82EC14A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC14AC: 4BDE7F61  bl 0x82ca940c
	ctx.lr = 0x82EC14B0;
	sub_82CA93D0(ctx, base);
	// 82EC14B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC14B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC14B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC14BC: 4BFF3F65  bl 0x82eb5420
	ctx.lr = 0x82EC14C0;
	sub_82EB5420(ctx, base);
	// 82EC14C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC14C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC14C8: 409A000C  bne cr6, 0x82ec14d4
	if !ctx.cr[6].eq {
	pc = 0x82EC14D4; continue 'dispatch;
	}
	pc = 0x82EC14CC; continue 'dispatch;
            }
            0x82EC14CC => {
    //   block [0x82EC14CC..0x82EC14D4)
	// 82EC14CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC14D0: 480000A0  b 0x82ec1570
	pc = 0x82EC1570; continue 'dispatch;
            }
            0x82EC14D4 => {
    //   block [0x82EC14D4..0x82EC156C)
	// 82EC14D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC14D8: 482FAB89  bl 0x831bc060
	ctx.lr = 0x82EC14DC;
	sub_831BC060(ctx, base);
	// 82EC14DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC14E0: 4182008C  beq 0x82ec156c
	if ctx.cr[0].eq {
	pc = 0x82EC156C; continue 'dispatch;
	}
	// 82EC14E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EC14E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC14EC: 3BEB2304  addi r31, r11, 0x2304
	ctx.r[31].s64 = ctx.r[11].s64 + 8964;
	// 82EC14F0: 482FAB71  bl 0x831bc060
	ctx.lr = 0x82EC14F4;
	sub_831BC060(ctx, base);
	// 82EC14F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC14F8: 4BDEB659  bl 0x82cacb50
	ctx.lr = 0x82EC14FC;
	sub_82CACB50(ctx, base);
	// 82EC14FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1500: 4082006C  bne 0x82ec156c
	if !ctx.cr[0].eq {
	pc = 0x82EC156C; continue 'dispatch;
	}
	// 82EC1504: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC1508: 388BBA88  addi r4, r11, -0x4578
	ctx.r[4].s64 = ctx.r[11].s64 + -17784;
	// 82EC150C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1510: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1514: 4B3A670D  bl 0x82267c20
	ctx.lr = 0x82EC1518;
	sub_82267C20(ctx, base);
	// 82EC1518: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC151C: 4182FFB0  beq 0x82ec14cc
	if ctx.cr[0].eq {
	pc = 0x82EC14CC; continue 'dispatch;
	}
	// 82EC1520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC1524: 4BA4C7E5  bl 0x8290dd08
	ctx.lr = 0x82EC1528;
	sub_8290DD08(ctx, base);
	// 82EC1528: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EC152C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1530: 4BFFFF01  bl 0x82ec1430
	ctx.lr = 0x82EC1534;
	sub_82EC1430(ctx, base);
	// 82EC1534: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EC1538: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC153C: 4182FF90  beq 0x82ec14cc
	if ctx.cr[0].eq {
	pc = 0x82EC14CC; continue 'dispatch;
	}
	// 82EC1540: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1544: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1548: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EC154C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC1550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC1554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC1558: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EC155C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1560: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC1564: 4BFBE60D  bl 0x82e7fb70
	ctx.lr = 0x82EC1568;
	sub_82E7FB70(ctx, base);
	// 82EC1568: 4BFFFF64  b 0x82ec14cc
	pc = 0x82EC14CC; continue 'dispatch;
            }
            0x82EC156C => {
    //   block [0x82EC156C..0x82EC1570)
	// 82EC156C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC1570; continue 'dispatch;
            }
            0x82EC1570 => {
    //   block [0x82EC1570..0x82EC1578)
	// 82EC1570: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC1574: 4BDE7EE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1578 size=200
    let mut pc: u32 = 0x82EC1578;
    'dispatch: loop {
        match pc {
            0x82EC1578 => {
    //   block [0x82EC1578..0x82EC15B0)
	// 82EC1578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC157C: 4BDE7E85  bl 0x82ca9400
	ctx.lr = 0x82EC1580;
	sub_82CA93D0(ctx, base);
	// 82EC1580: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1584: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1588: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82EC158C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC1590: 419A009C  beq cr6, 0x82ec162c
	if ctx.cr[6].eq {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC1594: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC1598: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC159C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC15A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC15A4: 40990088  ble cr6, 0x82ec162c
	if !ctx.cr[6].gt {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC15A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EC15AC: 3B6B2304  addi r27, r11, 0x2304
	ctx.r[27].s64 = ctx.r[11].s64 + 8964;
	pc = 0x82EC15B0; continue 'dispatch;
            }
            0x82EC15B0 => {
    //   block [0x82EC15B0..0x82EC15F0)
	// 82EC15B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC15B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC15B8: 4BFC2A71  bl 0x82e84028
	ctx.lr = 0x82EC15BC;
	sub_82E84028(ctx, base);
	// 82EC15BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC15C0: 41820030  beq 0x82ec15f0
	if ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC15C8: 482FAA99  bl 0x831bc060
	ctx.lr = 0x82EC15CC;
	sub_831BC060(ctx, base);
	// 82EC15CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC15D0: 41820020  beq 0x82ec15f0
	if ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC15D8: 482FAA89  bl 0x831bc060
	ctx.lr = 0x82EC15DC;
	sub_831BC060(ctx, base);
	// 82EC15DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EC15E0: 4BDEB571  bl 0x82cacb50
	ctx.lr = 0x82EC15E4;
	sub_82CACB50(ctx, base);
	// 82EC15E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC15E8: 40820008  bne 0x82ec15f0
	if !ctx.cr[0].eq {
	pc = 0x82EC15F0; continue 'dispatch;
	}
	// 82EC15EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	pc = 0x82EC15F0; continue 'dispatch;
            }
            0x82EC15F0 => {
    //   block [0x82EC15F0..0x82EC1624)
	// 82EC15F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC15F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EC15F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC15FC: 4198FFB4  blt cr6, 0x82ec15b0
	if ctx.cr[6].lt {
	pc = 0x82EC15B0; continue 'dispatch;
	}
	// 82EC1600: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82EC1604: 419A0028  beq cr6, 0x82ec162c
	if ctx.cr[6].eq {
	pc = 0x82EC162C; continue 'dispatch;
	}
	// 82EC1608: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC160C: 4B75531D  bl 0x82616928
	ctx.lr = 0x82EC1610;
	sub_82616928(ctx, base);
	// 82EC1610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1614: 41820010  beq 0x82ec1624
	if ctx.cr[0].eq {
	pc = 0x82EC1624; continue 'dispatch;
	}
	// 82EC1618: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC161C: 4BFCBC15  bl 0x82e8d230
	ctx.lr = 0x82EC1620;
	sub_82E8D230(ctx, base);
	// 82EC1620: 48000008  b 0x82ec1628
	pc = 0x82EC1628; continue 'dispatch;
            }
            0x82EC1624 => {
    //   block [0x82EC1624..0x82EC1628)
	// 82EC1624: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC1628; continue 'dispatch;
            }
            0x82EC1628 => {
    //   block [0x82EC1628..0x82EC162C)
	// 82EC1628: 907A000C  stw r3, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x82EC162C; continue 'dispatch;
            }
            0x82EC162C => {
    //   block [0x82EC162C..0x82EC1640)
	// 82EC162C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1630: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82EC1634: 48002A45  bl 0x82ec4078
	ctx.lr = 0x82EC1638;
	sub_82EC4078(ctx, base);
	// 82EC1638: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EC163C: 4BDE7E14  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1640 size=84
    let mut pc: u32 = 0x82EC1640;
    'dispatch: loop {
        match pc {
            0x82EC1640 => {
    //   block [0x82EC1640..0x82EC1688)
	// 82EC1640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1644: 4BDE7DC9  bl 0x82ca940c
	ctx.lr = 0x82EC1648;
	sub_82CA93D0(ctx, base);
	// 82EC1648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC164C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1650: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EC1654: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1658: 4B7552D1  bl 0x82616928
	ctx.lr = 0x82EC165C;
	sub_82616928(ctx, base);
	// 82EC165C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1660: 41820028  beq 0x82ec1688
	if ctx.cr[0].eq {
	pc = 0x82EC1688; continue 'dispatch;
	}
	// 82EC1664: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC166C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1670: 4BFF3CC1  bl 0x82eb5330
	ctx.lr = 0x82EC1674;
	sub_82EB5330(ctx, base);
	// 82EC1674: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC167C: 396BA834  addi r11, r11, -0x57cc
	ctx.r[11].s64 = ctx.r[11].s64 + -22476;
	// 82EC1680: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC1684: 48000008  b 0x82ec168c
	pc = 0x82EC168C; continue 'dispatch;
            }
            0x82EC1688 => {
    //   block [0x82EC1688..0x82EC168C)
	// 82EC1688: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC168C; continue 'dispatch;
            }
            0x82EC168C => {
    //   block [0x82EC168C..0x82EC1694)
	// 82EC168C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1690: 4BDE7DCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1698 size=332
    let mut pc: u32 = 0x82EC1698;
    'dispatch: loop {
        match pc {
            0x82EC1698 => {
    //   block [0x82EC1698..0x82EC16F8)
	// 82EC1698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC169C: 4BDE7D71  bl 0x82ca940c
	ctx.lr = 0x82EC16A0;
	sub_82CA93D0(ctx, base);
	// 82EC16A0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC16A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC16A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC16AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC16B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC16B4: 482FA9AD  bl 0x831bc060
	ctx.lr = 0x82EC16B8;
	sub_831BC060(ctx, base);
	// 82EC16B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC16BC: 41820084  beq 0x82ec1740
	if ctx.cr[0].eq {
	pc = 0x82EC1740; continue 'dispatch;
	}
	// 82EC16C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC16C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC16C8: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC16CC: 482FA995  bl 0x831bc060
	ctx.lr = 0x82EC16D0;
	sub_831BC060(ctx, base);
	// 82EC16D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC16D4: 4BDEB47D  bl 0x82cacb50
	ctx.lr = 0x82EC16D8;
	sub_82CACB50(ctx, base);
	// 82EC16D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC16DC: 40820064  bne 0x82ec1740
	if !ctx.cr[0].eq {
	pc = 0x82EC1740; continue 'dispatch;
	}
	// 82EC16E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC16E4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC16E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC16EC: 4182000C  beq 0x82ec16f8
	if ctx.cr[0].eq {
	pc = 0x82EC16F8; continue 'dispatch;
	}
	// 82EC16F0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC16F4: 4800000C  b 0x82ec1700
	pc = 0x82EC1700; continue 'dispatch;
            }
            0x82EC16F8 => {
    //   block [0x82EC16F8..0x82EC1700)
	// 82EC16F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC16FC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC1700; continue 'dispatch;
            }
            0x82EC1700 => {
    //   block [0x82EC1700..0x82EC1720)
	// 82EC1700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1704: 4BA4C605  bl 0x8290dd08
	ctx.lr = 0x82EC1708;
	sub_8290DD08(ctx, base);
	// 82EC1708: 4BDEA4A9  bl 0x82cabbb0
	ctx.lr = 0x82EC170C;
	sub_82CABBB0(ctx, base);
	// 82EC170C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1714: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1718: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC171C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC1720; continue 'dispatch;
            }
            0x82EC1720 => {
    //   block [0x82EC1720..0x82EC172C)
	// 82EC1720: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1724: 40990008  ble cr6, 0x82ec172c
	if !ctx.cr[6].gt {
	pc = 0x82EC172C; continue 'dispatch;
	}
	// 82EC1728: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC172C; continue 'dispatch;
            }
            0x82EC172C => {
    //   block [0x82EC172C..0x82EC1738)
	// 82EC172C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1730: 409AFFF0  bne cr6, 0x82ec1720
	if !ctx.cr[6].eq {
	pc = 0x82EC1720; continue 'dispatch;
	}
	// 82EC1734: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82EC1738; continue 'dispatch;
            }
            0x82EC1738 => {
    //   block [0x82EC1738..0x82EC1740)
	// 82EC1738: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC173C: 4800009C  b 0x82ec17d8
	pc = 0x82EC17D8; continue 'dispatch;
            }
            0x82EC1740 => {
    //   block [0x82EC1740..0x82EC1788)
	// 82EC1740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1744: 482FA91D  bl 0x831bc060
	ctx.lr = 0x82EC1748;
	sub_831BC060(ctx, base);
	// 82EC1748: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC174C: 41820080  beq 0x82ec17cc
	if ctx.cr[0].eq {
	pc = 0x82EC17CC; continue 'dispatch;
	}
	// 82EC1750: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1758: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EC175C: 482FA905  bl 0x831bc060
	ctx.lr = 0x82EC1760;
	sub_831BC060(ctx, base);
	// 82EC1760: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1764: 4BDEB3ED  bl 0x82cacb50
	ctx.lr = 0x82EC1768;
	sub_82CACB50(ctx, base);
	// 82EC1768: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC176C: 40820060  bne 0x82ec17cc
	if !ctx.cr[0].eq {
	pc = 0x82EC17CC; continue 'dispatch;
	}
	// 82EC1770: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1774: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1778: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC177C: 4182000C  beq 0x82ec1788
	if ctx.cr[0].eq {
	pc = 0x82EC1788; continue 'dispatch;
	}
	// 82EC1780: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1784: 4800000C  b 0x82ec1790
	pc = 0x82EC1790; continue 'dispatch;
            }
            0x82EC1788 => {
    //   block [0x82EC1788..0x82EC1790)
	// 82EC1788: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC178C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC1790; continue 'dispatch;
            }
            0x82EC1790 => {
    //   block [0x82EC1790..0x82EC17B0)
	// 82EC1790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1794: 4BA4C575  bl 0x8290dd08
	ctx.lr = 0x82EC1798;
	sub_8290DD08(ctx, base);
	// 82EC1798: 4BDEA419  bl 0x82cabbb0
	ctx.lr = 0x82EC179C;
	sub_82CABBB0(ctx, base);
	// 82EC179C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC17A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC17A4: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC17A8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC17AC: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC17B0; continue 'dispatch;
            }
            0x82EC17B0 => {
    //   block [0x82EC17B0..0x82EC17BC)
	// 82EC17B0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC17B4: 40990008  ble cr6, 0x82ec17bc
	if !ctx.cr[6].gt {
	pc = 0x82EC17BC; continue 'dispatch;
	}
	// 82EC17B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC17BC; continue 'dispatch;
            }
            0x82EC17BC => {
    //   block [0x82EC17BC..0x82EC17CC)
	// 82EC17BC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC17C0: 409AFFF0  bne cr6, 0x82ec17b0
	if !ctx.cr[6].eq {
	pc = 0x82EC17B0; continue 'dispatch;
	}
	// 82EC17C4: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC17C8: 4BFFFF70  b 0x82ec1738
	pc = 0x82EC1738; continue 'dispatch;
            }
            0x82EC17CC => {
    //   block [0x82EC17CC..0x82EC17D8)
	// 82EC17CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC17D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC17D4: 4BFF3C4D  bl 0x82eb5420
	ctx.lr = 0x82EC17D8;
	sub_82EB5420(ctx, base);
	pc = 0x82EC17D8; continue 'dispatch;
            }
            0x82EC17D8 => {
    //   block [0x82EC17D8..0x82EC17E4)
	// 82EC17D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC17DC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC17E0: 4BDE7C7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC17E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC17E8 size=196
    let mut pc: u32 = 0x82EC17E8;
    'dispatch: loop {
        match pc {
            0x82EC17E8 => {
    //   block [0x82EC17E8..0x82EC1848)
	// 82EC17E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC17EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC17F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC17F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC17F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC17FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1800: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC1804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1808: 388AC178  addi r4, r10, -0x3e88
	ctx.r[4].s64 = ctx.r[10].s64 + -16008;
	// 82EC180C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC1810: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1818: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC181C: 4B326E5D  bl 0x821e8678
	ctx.lr = 0x82EC1820;
	sub_821E8678(ctx, base);
	// 82EC1820: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1824: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC182C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EC1830: C16A0BFC  lfs f11, 0xbfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC1834: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1838: 41820010  beq 0x82ec1848
	if ctx.cr[0].eq {
	pc = 0x82EC1848; continue 'dispatch;
	}
	// 82EC183C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1840: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC1844: 48000028  b 0x82ec186c
	pc = 0x82EC186C; continue 'dispatch;
            }
            0x82EC1848 => {
    //   block [0x82EC1848..0x82EC185C)
	// 82EC1848: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC184C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1850: 4182000C  beq 0x82ec185c
	if ctx.cr[0].eq {
	pc = 0x82EC185C; continue 'dispatch;
	}
	// 82EC1854: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1858: 48000008  b 0x82ec1860
	pc = 0x82EC1860; continue 'dispatch;
            }
            0x82EC185C => {
    //   block [0x82EC185C..0x82EC1860)
	// 82EC185C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EC1860; continue 'dispatch;
            }
            0x82EC1860 => {
    //   block [0x82EC1860..0x82EC186C)
	// 82EC1860: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EC1864: C18B5CC4  lfs f12, 0x5cc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1868: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	pc = 0x82EC186C; continue 'dispatch;
            }
            0x82EC186C => {
    //   block [0x82EC186C..0x82EC1880)
	// 82EC186C: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC1870: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1874: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1878: 41820008  beq 0x82ec1880
	if ctx.cr[0].eq {
	pc = 0x82EC1880; continue 'dispatch;
	}
	// 82EC187C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC1880; continue 'dispatch;
            }
            0x82EC1880 => {
    //   block [0x82EC1880..0x82EC18AC)
	// 82EC1880: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1884: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC1888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC188C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1890: 480027E9  bl 0x82ec4078
	ctx.lr = 0x82EC1894;
	sub_82EC4078(ctx, base);
	// 82EC1894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC189C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC18A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC18A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC18A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC18B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC18B0 size=88
    let mut pc: u32 = 0x82EC18B0;
    'dispatch: loop {
        match pc {
            0x82EC18B0 => {
    //   block [0x82EC18B0..0x82EC1900)
	// 82EC18B0: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC18B4: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC18B8: C1A5000C  lfs f13, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18BC: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC18C0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC18C4: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC18C8: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18CC: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC18D0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC18D4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC18D8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC18DC: 40980024  bge cr6, 0x82ec1900
	if !ctx.cr[6].lt {
	pc = 0x82EC1900; continue 'dispatch;
	}
	// 82EC18E0: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18E4: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC18E8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC18EC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC18F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC18F4: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EC18F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC18FC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	pc = 0x82EC1900; continue 'dispatch;
            }
            0x82EC1900 => {
    //   block [0x82EC1900..0x82EC1908)
	// 82EC1900: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1908 size=68
    let mut pc: u32 = 0x82EC1908;
    'dispatch: loop {
        match pc {
            0x82EC1908 => {
    //   block [0x82EC1908..0x82EC1934)
	// 82EC1908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC190C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1910: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1914: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1918: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC191C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1920: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC1924: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC1928: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC192C: 41820008  beq 0x82ec1934
	if ctx.cr[0].eq {
	pc = 0x82EC1934; continue 'dispatch;
	}
	// 82EC1930: 4B983E81  bl 0x828457b0
	ctx.lr = 0x82EC1934;
	sub_828457B0(ctx, base);
	pc = 0x82EC1934; continue 'dispatch;
            }
            0x82EC1934 => {
    //   block [0x82EC1934..0x82EC194C)
	// 82EC1934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1938: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC193C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC1950 size=12
    let mut pc: u32 = 0x82EC1950;
    'dispatch: loop {
        match pc {
            0x82EC1950 => {
    //   block [0x82EC1950..0x82EC195C)
	// 82EC1950: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC1954: 386BD7B8  addi r3, r11, -0x2848
	ctx.r[3].s64 = ctx.r[11].s64 + -10312;
	// 82EC1958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1960 size=84
    let mut pc: u32 = 0x82EC1960;
    'dispatch: loop {
        match pc {
            0x82EC1960 => {
    //   block [0x82EC1960..0x82EC19A8)
	// 82EC1960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1964: 4BDE7AA9  bl 0x82ca940c
	ctx.lr = 0x82EC1968;
	sub_82CA93D0(ctx, base);
	// 82EC1968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC196C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1970: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC1974: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1978: 4B754FB1  bl 0x82616928
	ctx.lr = 0x82EC197C;
	sub_82616928(ctx, base);
	// 82EC197C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1980: 41820028  beq 0x82ec19a8
	if ctx.cr[0].eq {
	pc = 0x82EC19A8; continue 'dispatch;
	}
	// 82EC1984: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC198C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1990: 4BFF39A1  bl 0x82eb5330
	ctx.lr = 0x82EC1994;
	sub_82EB5330(ctx, base);
	// 82EC1994: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC199C: 396BB000  addi r11, r11, -0x5000
	ctx.r[11].s64 = ctx.r[11].s64 + -20480;
	// 82EC19A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC19A4: 48000008  b 0x82ec19ac
	pc = 0x82EC19AC; continue 'dispatch;
            }
            0x82EC19A8 => {
    //   block [0x82EC19A8..0x82EC19AC)
	// 82EC19A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC19AC; continue 'dispatch;
            }
            0x82EC19AC => {
    //   block [0x82EC19AC..0x82EC19B4)
	// 82EC19AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC19B0: 4BDE7AAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC19B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC19B8 size=192
    let mut pc: u32 = 0x82EC19B8;
    'dispatch: loop {
        match pc {
            0x82EC19B8 => {
    //   block [0x82EC19B8..0x82EC1A18)
	// 82EC19B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC19BC: 4BDE7A51  bl 0x82ca940c
	ctx.lr = 0x82EC19C0;
	sub_82CA93D0(ctx, base);
	// 82EC19C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC19C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC19C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC19CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC19D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC19D4: 482FA68D  bl 0x831bc060
	ctx.lr = 0x82EC19D8;
	sub_831BC060(ctx, base);
	// 82EC19D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC19DC: 41820084  beq 0x82ec1a60
	if ctx.cr[0].eq {
	pc = 0x82EC1A60; continue 'dispatch;
	}
	// 82EC19E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC19E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC19E8: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC19EC: 482FA675  bl 0x831bc060
	ctx.lr = 0x82EC19F0;
	sub_831BC060(ctx, base);
	// 82EC19F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC19F4: 4BDEB15D  bl 0x82cacb50
	ctx.lr = 0x82EC19F8;
	sub_82CACB50(ctx, base);
	// 82EC19F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC19FC: 40820064  bne 0x82ec1a60
	if !ctx.cr[0].eq {
	pc = 0x82EC1A60; continue 'dispatch;
	}
	// 82EC1A00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1A04: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1A08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1A0C: 4182000C  beq 0x82ec1a18
	if ctx.cr[0].eq {
	pc = 0x82EC1A18; continue 'dispatch;
	}
	// 82EC1A10: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1A14: 4800000C  b 0x82ec1a20
	pc = 0x82EC1A20; continue 'dispatch;
            }
            0x82EC1A18 => {
    //   block [0x82EC1A18..0x82EC1A20)
	// 82EC1A18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A1C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC1A20; continue 'dispatch;
            }
            0x82EC1A20 => {
    //   block [0x82EC1A20..0x82EC1A40)
	// 82EC1A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1A24: 4BA4C2E5  bl 0x8290dd08
	ctx.lr = 0x82EC1A28;
	sub_8290DD08(ctx, base);
	// 82EC1A28: 4BDEA189  bl 0x82cabbb0
	ctx.lr = 0x82EC1A2C;
	sub_82CABBB0(ctx, base);
	// 82EC1A2C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1A30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A34: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1A38: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1A3C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC1A40; continue 'dispatch;
            }
            0x82EC1A40 => {
    //   block [0x82EC1A40..0x82EC1A4C)
	// 82EC1A40: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1A44: 40990008  ble cr6, 0x82ec1a4c
	if !ctx.cr[6].gt {
	pc = 0x82EC1A4C; continue 'dispatch;
	}
	// 82EC1A48: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC1A4C; continue 'dispatch;
            }
            0x82EC1A4C => {
    //   block [0x82EC1A4C..0x82EC1A60)
	// 82EC1A4C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1A50: 409AFFF0  bne cr6, 0x82ec1a40
	if !ctx.cr[6].eq {
	pc = 0x82EC1A40; continue 'dispatch;
	}
	// 82EC1A54: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1A58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1A5C: 48000010  b 0x82ec1a6c
	pc = 0x82EC1A6C; continue 'dispatch;
            }
            0x82EC1A60 => {
    //   block [0x82EC1A60..0x82EC1A6C)
	// 82EC1A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1A64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC1A68: 4BFF39B9  bl 0x82eb5420
	ctx.lr = 0x82EC1A6C;
	sub_82EB5420(ctx, base);
	pc = 0x82EC1A6C; continue 'dispatch;
            }
            0x82EC1A6C => {
    //   block [0x82EC1A6C..0x82EC1A78)
	// 82EC1A6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC1A70: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC1A74: 4BDE79E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1A78 size=52
    let mut pc: u32 = 0x82EC1A78;
    'dispatch: loop {
        match pc {
            0x82EC1A78 => {
    //   block [0x82EC1A78..0x82EC1A90)
	// 82EC1A78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1A7C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1A80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1A84: 4182000C  beq 0x82ec1a90
	if ctx.cr[0].eq {
	pc = 0x82EC1A90; continue 'dispatch;
	}
	// 82EC1A88: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1A8C: 4800000C  b 0x82ec1a98
	pc = 0x82EC1A98; continue 'dispatch;
            }
            0x82EC1A90 => {
    //   block [0x82EC1A90..0x82EC1A98)
	// 82EC1A90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A94: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC1A98; continue 'dispatch;
            }
            0x82EC1A98 => {
    //   block [0x82EC1A98..0x82EC1AAC)
	// 82EC1A98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1A9C: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1AA0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1AA4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1AA8: 480025D0  b 0x82ec4078
	sub_82EC4078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1AB0 size=80
    let mut pc: u32 = 0x82EC1AB0;
    'dispatch: loop {
        match pc {
            0x82EC1AB0 => {
    //   block [0x82EC1AB0..0x82EC1AF8)
	// 82EC1AB0: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1AB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC1AB8: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1ABC: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1AC0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1AC4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC1AC8: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1ACC: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1AD0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC1AD4: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC1AD8: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1ADC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC1AE0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1AE4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1AE8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1AEC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1AF0: 41980008  blt cr6, 0x82ec1af8
	if ctx.cr[6].lt {
	pc = 0x82EC1AF8; continue 'dispatch;
	}
	// 82EC1AF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC1AF8; continue 'dispatch;
            }
            0x82EC1AF8 => {
    //   block [0x82EC1AF8..0x82EC1B00)
	// 82EC1AF8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC1AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1B00 size=84
    let mut pc: u32 = 0x82EC1B00;
    'dispatch: loop {
        match pc {
            0x82EC1B00 => {
    //   block [0x82EC1B00..0x82EC1B48)
	// 82EC1B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1B04: 4BDE7909  bl 0x82ca940c
	ctx.lr = 0x82EC1B08;
	sub_82CA93D0(ctx, base);
	// 82EC1B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1B0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1B10: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC1B14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC1B18: 4B754E11  bl 0x82616928
	ctx.lr = 0x82EC1B1C;
	sub_82616928(ctx, base);
	// 82EC1B1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC1B20: 41820028  beq 0x82ec1b48
	if ctx.cr[0].eq {
	pc = 0x82EC1B48; continue 'dispatch;
	}
	// 82EC1B24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC1B28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B30: 4BFF3801  bl 0x82eb5330
	ctx.lr = 0x82EC1B34;
	sub_82EB5330(ctx, base);
	// 82EC1B34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B3C: 396BA84C  addi r11, r11, -0x57b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22452;
	// 82EC1B40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC1B44: 48000008  b 0x82ec1b4c
	pc = 0x82EC1B4C; continue 'dispatch;
            }
            0x82EC1B48 => {
    //   block [0x82EC1B48..0x82EC1B4C)
	// 82EC1B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC1B4C; continue 'dispatch;
            }
            0x82EC1B4C => {
    //   block [0x82EC1B4C..0x82EC1B54)
	// 82EC1B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1B50: 4BDE790C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1B58 size=268
    let mut pc: u32 = 0x82EC1B58;
    'dispatch: loop {
        match pc {
            0x82EC1B58 => {
    //   block [0x82EC1B58..0x82EC1BBC)
	// 82EC1B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1B5C: 4BDE78B1  bl 0x82ca940c
	ctx.lr = 0x82EC1B60;
	sub_82CA93D0(ctx, base);
	// 82EC1B60: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC1B64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1B68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC1B6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC1B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B74: 482FA4ED  bl 0x831bc060
	ctx.lr = 0x82EC1B78;
	sub_831BC060(ctx, base);
	// 82EC1B78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1B7C: 41820040  beq 0x82ec1bbc
	if ctx.cr[0].eq {
	pc = 0x82EC1BBC; continue 'dispatch;
	}
	// 82EC1B80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1B88: 3BCBB050  addi r30, r11, -0x4fb0
	ctx.r[30].s64 = ctx.r[11].s64 + -20400;
	// 82EC1B8C: 482FA4D5  bl 0x831bc060
	ctx.lr = 0x82EC1B90;
	sub_831BC060(ctx, base);
	// 82EC1B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1B94: 4BDEAFBD  bl 0x82cacb50
	ctx.lr = 0x82EC1B98;
	sub_82CACB50(ctx, base);
	// 82EC1B98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1B9C: 40820020  bne 0x82ec1bbc
	if !ctx.cr[0].eq {
	pc = 0x82EC1BBC; continue 'dispatch;
	}
	// 82EC1BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BA4: 4BA4C165  bl 0x8290dd08
	ctx.lr = 0x82EC1BA8;
	sub_8290DD08(ctx, base);
	// 82EC1BA8: 4BDE8819  bl 0x82caa3c0
	ctx.lr = 0x82EC1BAC;
	sub_82CAA3C0(ctx, base);
	// 82EC1BAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC1BB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1BB4: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1BB8: 480000A0  b 0x82ec1c58
	pc = 0x82EC1C58; continue 'dispatch;
            }
            0x82EC1BBC => {
    //   block [0x82EC1BBC..0x82EC1C04)
	// 82EC1BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BC0: 482FA4A1  bl 0x831bc060
	ctx.lr = 0x82EC1BC4;
	sub_831BC060(ctx, base);
	// 82EC1BC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1BC8: 41820084  beq 0x82ec1c4c
	if ctx.cr[0].eq {
	pc = 0x82EC1C4C; continue 'dispatch;
	}
	// 82EC1BCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1BD4: 3BCBB040  addi r30, r11, -0x4fc0
	ctx.r[30].s64 = ctx.r[11].s64 + -20416;
	// 82EC1BD8: 482FA489  bl 0x831bc060
	ctx.lr = 0x82EC1BDC;
	sub_831BC060(ctx, base);
	// 82EC1BDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1BE0: 4BDEAF71  bl 0x82cacb50
	ctx.lr = 0x82EC1BE4;
	sub_82CACB50(ctx, base);
	// 82EC1BE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1BE8: 40820064  bne 0x82ec1c4c
	if !ctx.cr[0].eq {
	pc = 0x82EC1C4C; continue 'dispatch;
	}
	// 82EC1BEC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1BF0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1BF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1BF8: 4182000C  beq 0x82ec1c04
	if ctx.cr[0].eq {
	pc = 0x82EC1C04; continue 'dispatch;
	}
	// 82EC1BFC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC1C00: 4800000C  b 0x82ec1c0c
	pc = 0x82EC1C0C; continue 'dispatch;
            }
            0x82EC1C04 => {
    //   block [0x82EC1C04..0x82EC1C0C)
	// 82EC1C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1C08: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC1C0C; continue 'dispatch;
            }
            0x82EC1C0C => {
    //   block [0x82EC1C0C..0x82EC1C2C)
	// 82EC1C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1C10: 4BA4C0F9  bl 0x8290dd08
	ctx.lr = 0x82EC1C14;
	sub_8290DD08(ctx, base);
	// 82EC1C14: 4BDE9F9D  bl 0x82cabbb0
	ctx.lr = 0x82EC1C18;
	sub_82CABBB0(ctx, base);
	// 82EC1C18: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1C20: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1C24: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1C28: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC1C2C; continue 'dispatch;
            }
            0x82EC1C2C => {
    //   block [0x82EC1C2C..0x82EC1C38)
	// 82EC1C2C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC1C30: 41980008  blt cr6, 0x82ec1c38
	if ctx.cr[6].lt {
	pc = 0x82EC1C38; continue 'dispatch;
	}
	// 82EC1C34: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC1C38; continue 'dispatch;
            }
            0x82EC1C38 => {
    //   block [0x82EC1C38..0x82EC1C4C)
	// 82EC1C38: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC1C3C: 409AFFF0  bne cr6, 0x82ec1c2c
	if !ctx.cr[6].eq {
	pc = 0x82EC1C2C; continue 'dispatch;
	}
	// 82EC1C40: D01D000C  stfs f0, 0xc(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1C44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC1C48: 48000010  b 0x82ec1c58
	pc = 0x82EC1C58; continue 'dispatch;
            }
            0x82EC1C4C => {
    //   block [0x82EC1C4C..0x82EC1C58)
	// 82EC1C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC1C54: 4BFF37CD  bl 0x82eb5420
	ctx.lr = 0x82EC1C58;
	sub_82EB5420(ctx, base);
	pc = 0x82EC1C58; continue 'dispatch;
            }
            0x82EC1C58 => {
    //   block [0x82EC1C58..0x82EC1C64)
	// 82EC1C58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC1C5C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC1C60: 4BDE77FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1C68 size=140
    let mut pc: u32 = 0x82EC1C68;
    'dispatch: loop {
        match pc {
            0x82EC1C68 => {
    //   block [0x82EC1C68..0x82EC1CA4)
	// 82EC1C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1C70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1C74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1C78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1C7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EC1C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1C84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1C88: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC1C8C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC1C90: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC1C94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1C98: 4182000C  beq 0x82ec1ca4
	if ctx.cr[0].eq {
	pc = 0x82EC1CA4; continue 'dispatch;
	}
	// 82EC1C9C: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1CA0: 4800000C  b 0x82ec1cac
	pc = 0x82EC1CAC; continue 'dispatch;
            }
            0x82EC1CA4 => {
    //   block [0x82EC1CA4..0x82EC1CAC)
	// 82EC1CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CA8: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC1CAC; continue 'dispatch;
            }
            0x82EC1CAC => {
    //   block [0x82EC1CAC..0x82EC1CF4)
	// 82EC1CAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1CB8: C00B0AEC  lfs f0, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1CBC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC1CC0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1CC4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC1CC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1CCC: 4E800421  bctrl
	ctx.lr = 0x82EC1CD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1CD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1CD8: 480023A1  bl 0x82ec4078
	ctx.lr = 0x82EC1CDC;
	sub_82EC4078(ctx, base);
	// 82EC1CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC1CF8 size=24
    let mut pc: u32 = 0x82EC1CF8;
    'dispatch: loop {
        match pc {
            0x82EC1CF8 => {
    //   block [0x82EC1CF8..0x82EC1D10)
	// 82EC1CF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1CFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC1D00: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D04: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC1D08: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EC1D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1D10 size=216
    let mut pc: u32 = 0x82EC1D10;
    'dispatch: loop {
        match pc {
            0x82EC1D10 => {
    //   block [0x82EC1D10..0x82EC1D54)
	// 82EC1D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1D28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC1D2C: 4B39EC8D  bl 0x822609b8
	ctx.lr = 0x82EC1D30;
	sub_822609B8(ctx, base);
	// 82EC1D30: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D34: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1D38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC1D3C: 419A0018  beq cr6, 0x82ec1d54
	if ctx.cr[6].eq {
	pc = 0x82EC1D54; continue 'dispatch;
	}
	// 82EC1D40: 4B39EC79  bl 0x822609b8
	ctx.lr = 0x82EC1D44;
	sub_822609B8(ctx, base);
	// 82EC1D44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC1D48: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D4C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC1D50: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC1D54; continue 'dispatch;
            }
            0x82EC1D54 => {
    //   block [0x82EC1D54..0x82EC1DCC)
	// 82EC1D54: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1D58: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC1D5C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC1D60: 4098006C  bge cr6, 0x82ec1dcc
	if !ctx.cr[6].lt {
	pc = 0x82EC1DCC; continue 'dispatch;
	}
	// 82EC1D64: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1D68: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D6C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1D70: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1D74: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1D78: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC1D7C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1D80: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1D84: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1D88: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC1D8C: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC1D90: EDAC4828  fsubs f13, f12, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC1D94: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC1D98: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC1D9C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC1DA0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1DA4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC1DA8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1DAC: 41990020  bgt cr6, 0x82ec1dcc
	if ctx.cr[6].gt {
	pc = 0x82EC1DCC; continue 'dispatch;
	}
	// 82EC1DB0: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 82EC1DB4: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82EC1DB8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EC1DBC: 816A0054  lwz r11, 0x54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC1DC0: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC1DC4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC1DC8: 409A0008  bne cr6, 0x82ec1dd0
	if !ctx.cr[6].eq {
	pc = 0x82EC1DD0; continue 'dispatch;
	}
	pc = 0x82EC1DCC; continue 'dispatch;
            }
            0x82EC1DCC => {
    //   block [0x82EC1DCC..0x82EC1DD0)
	// 82EC1DCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC1DD0; continue 'dispatch;
            }
            0x82EC1DD0 => {
    //   block [0x82EC1DD0..0x82EC1DE8)
	// 82EC1DD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1DDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1DE8 size=280
    let mut pc: u32 = 0x82EC1DE8;
    'dispatch: loop {
        match pc {
            0x82EC1DE8 => {
    //   block [0x82EC1DE8..0x82EC1E70)
	// 82EC1DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1DEC: 4BDE7615  bl 0x82ca9400
	ctx.lr = 0x82EC1DF0;
	sub_82CA93D0(ctx, base);
	// 82EC1DF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1DF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1DF8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EC1DFC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC1E00: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82EC1E04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E0C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC1E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E14: 4E800421  bctrl
	ctx.lr = 0x82EC1E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1E18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC1E20: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82EC1E24: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82EC1E28: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC1E2C: 83EB0250  lwz r31, 0x250(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EC1E30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1E34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1E3C: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1E40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1E44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1E48: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1E4C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC1E50: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC1E54: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC1E58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E5C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E64: 4E800421  bctrl
	ctx.lr = 0x82EC1E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1E68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1E6C: 4082000C  bne 0x82ec1e78
	if !ctx.cr[0].eq {
	pc = 0x82EC1E78; continue 'dispatch;
	}
            }
            0x82EC1E70 => {
    //   block [0x82EC1E70..0x82EC1E78)
	// 82EC1E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1E74: 48000084  b 0x82ec1ef8
	pc = 0x82EC1EF8; continue 'dispatch;
            }
            0x82EC1E78 => {
    //   block [0x82EC1E78..0x82EC1EF8)
	// 82EC1E78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1E7C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EC1E80: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1E84: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EC1E88: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC1E8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1E90: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1E9C: 4E800421  bctrl
	ctx.lr = 0x82EC1EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1EA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1EA4: 4182FFCC  beq 0x82ec1e70
	if ctx.cr[0].eq {
	pc = 0x82EC1E70; continue 'dispatch;
	}
	// 82EC1EA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1EAC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82EC1EB0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82EC1EB4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82EC1EB8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC1EBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC1EC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC1EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC1ECC: 4E800421  bctrl
	ctx.lr = 0x82EC1ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC1ED0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC1ED4: 4182FF9C  beq 0x82ec1e70
	if ctx.cr[0].eq {
	pc = 0x82EC1E70; continue 'dispatch;
	}
	// 82EC1ED8: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1EDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC1EE0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC1EE4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC1EE8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1EEC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC1EF0: 41990008  bgt cr6, 0x82ec1ef8
	if ctx.cr[6].gt {
	pc = 0x82EC1EF8; continue 'dispatch;
	}
	// 82EC1EF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82EC1EF8 => {
    //   block [0x82EC1EF8..0x82EC1F00)
	// 82EC1EF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EC1EFC: 4BDE7554  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC1F00 size=36
    let mut pc: u32 = 0x82EC1F00;
    'dispatch: loop {
        match pc {
            0x82EC1F00 => {
    //   block [0x82EC1F00..0x82EC1F24)
	// 82EC1F00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1F04: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82EC1F08: 806B0228  lwz r3, 0x228(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC1F0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC1F10: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC1F14: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1F18: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC1F1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC1F20: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC1F28 size=88
    let mut pc: u32 = 0x82EC1F28;
    'dispatch: loop {
        match pc {
            0x82EC1F28 => {
    //   block [0x82EC1F28..0x82EC1F64)
	// 82EC1F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC1F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC1F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC1F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC1F40: 3860003C  li r3, 0x3c
	ctx.r[3].s64 = 60;
	// 82EC1F44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC1F48: 4B7549E1  bl 0x82616928
	ctx.lr = 0x82EC1F4C;
	sub_82616928(ctx, base);
	// 82EC1F4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1F50: 41820014  beq 0x82ec1f64
	if ctx.cr[0].eq {
	pc = 0x82EC1F64; continue 'dispatch;
	}
	// 82EC1F54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC1F58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC1F5C: 4BFF354D  bl 0x82eb54a8
	ctx.lr = 0x82EC1F60;
	sub_82EB54A8(ctx, base);
	// 82EC1F60: 48000008  b 0x82ec1f68
	pc = 0x82EC1F68; continue 'dispatch;
            }
            0x82EC1F64 => {
    //   block [0x82EC1F64..0x82EC1F68)
	// 82EC1F64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC1F68; continue 'dispatch;
            }
            0x82EC1F68 => {
    //   block [0x82EC1F68..0x82EC1F80)
	// 82EC1F68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC1F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC1F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC1F74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC1F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC1F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC1F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC1F80 size=164
    let mut pc: u32 = 0x82EC1F80;
    'dispatch: loop {
        match pc {
            0x82EC1F80 => {
    //   block [0x82EC1F80..0x82EC1FE8)
	// 82EC1F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC1F84: 4BDE7489  bl 0x82ca940c
	ctx.lr = 0x82EC1F88;
	sub_82CA93D0(ctx, base);
	// 82EC1F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC1F8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC1F90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC1F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1F98: 482FA0C9  bl 0x831bc060
	ctx.lr = 0x82EC1F9C;
	sub_831BC060(ctx, base);
	// 82EC1F9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC1FA0: 41820070  beq 0x82ec2010
	if ctx.cr[0].eq {
	pc = 0x82EC2010; continue 'dispatch;
	}
	// 82EC1FA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC1FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1FAC: 3BCBB094  addi r30, r11, -0x4f6c
	ctx.r[30].s64 = ctx.r[11].s64 + -20332;
	// 82EC1FB0: 482FA0B1  bl 0x831bc060
	ctx.lr = 0x82EC1FB4;
	sub_831BC060(ctx, base);
	// 82EC1FB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC1FB8: 4BDEAB99  bl 0x82cacb50
	ctx.lr = 0x82EC1FBC;
	sub_82CACB50(ctx, base);
	// 82EC1FBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC1FC0: 40820050  bne 0x82ec2010
	if !ctx.cr[0].eq {
	pc = 0x82EC2010; continue 'dispatch;
	}
	// 82EC1FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC1FC8: 4BA4BD41  bl 0x8290dd08
	ctx.lr = 0x82EC1FCC;
	sub_8290DD08(ctx, base);
	// 82EC1FCC: 4BDE9BE5  bl 0x82cabbb0
	ctx.lr = 0x82EC1FD0;
	sub_82CABBB0(ctx, base);
	// 82EC1FD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC1FD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC1FD8: C1BD000C  lfs f13, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC1FDC: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC1FE0: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC1FE4: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EC1FE8; continue 'dispatch;
            }
            0x82EC1FE8 => {
    //   block [0x82EC1FE8..0x82EC1FFC)
	// 82EC1FE8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC1FEC: 41980010  blt cr6, 0x82ec1ffc
	if ctx.cr[6].lt {
	pc = 0x82EC1FFC; continue 'dispatch;
	}
	// 82EC1FF0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC1FF4: 41990008  bgt cr6, 0x82ec1ffc
	if ctx.cr[6].gt {
	pc = 0x82EC1FFC; continue 'dispatch;
	}
	// 82EC1FF8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EC1FFC; continue 'dispatch;
            }
            0x82EC1FFC => {
    //   block [0x82EC1FFC..0x82EC2010)
	// 82EC1FFC: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EC2000: 409AFFE8  bne cr6, 0x82ec1fe8
	if !ctx.cr[6].eq {
	pc = 0x82EC1FE8; continue 'dispatch;
	}
	// 82EC2004: D1BD000C  stfs f13, 0xc(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2008: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC200C: 48000010  b 0x82ec201c
	pc = 0x82EC201C; continue 'dispatch;
            }
            0x82EC2010 => {
    //   block [0x82EC2010..0x82EC201C)
	// 82EC2010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC2014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2018: 4BFF3409  bl 0x82eb5420
	ctx.lr = 0x82EC201C;
	sub_82EB5420(ctx, base);
	pc = 0x82EC201C; continue 'dispatch;
            }
            0x82EC201C => {
    //   block [0x82EC201C..0x82EC2024)
	// 82EC201C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2020: 4BDE743C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2028 size=96
    let mut pc: u32 = 0x82EC2028;
    'dispatch: loop {
        match pc {
            0x82EC2028 => {
    //   block [0x82EC2028..0x82EC205C)
	// 82EC2028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC202C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2034: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2038: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC203C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2040: C00B0B24  lfs f0, 0xb24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2044: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2048: 48002031  bl 0x82ec4078
	ctx.lr = 0x82EC204C;
	sub_82EC4078(ctx, base);
	// 82EC204C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2050: 4082000C  bne 0x82ec205c
	if !ctx.cr[0].eq {
	pc = 0x82EC205C; continue 'dispatch;
	}
	// 82EC2054: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2058: 4800001C  b 0x82ec2074
	pc = 0x82EC2074; continue 'dispatch;
            }
            0x82EC205C => {
    //   block [0x82EC205C..0x82EC2074)
	// 82EC205C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2064: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC206C: 4E800421  bctrl
	ctx.lr = 0x82EC2070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2070: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82EC2074 => {
    //   block [0x82EC2074..0x82EC2088)
	// 82EC2074: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC207C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2088 size=72
    let mut pc: u32 = 0x82EC2088;
    'dispatch: loop {
        match pc {
            0x82EC2088 => {
    //   block [0x82EC2088..0x82EC20D0)
	// 82EC2088: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC208C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2094: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2098: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC209C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC20A0: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC20A4: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC20A8: C1AB0BEC  lfs f13, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC20AC: D1A30028  stfs f13, 0x28(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC20B0: D1A3002C  stfs f13, 0x2c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC20B4: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC20B8: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC20BC: C0030028  lfs f0, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC20C0: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC20C4: C003002C  lfs f0, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC20C8: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC20CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC20D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC20D0 size=156
    let mut pc: u32 = 0x82EC20D0;
    'dispatch: loop {
        match pc {
            0x82EC20D0 => {
    //   block [0x82EC20D0..0x82EC212C)
	// 82EC20D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC20D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC20D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC20DC: 894A0400  lbz r10, 0x400(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC20E0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC20E4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82EC20E8: C18B0014  lfs f12, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC20EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC20F0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC20F4: ED600332  fmuls f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC20F8: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC20FC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EC2100: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2104: 41980028  blt cr6, 0x82ec212c
	if ctx.cr[6].lt {
	pc = 0x82EC212C; continue 'dispatch;
	}
	// 82EC2108: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC210C: ED400332  fmuls f10, f0, f12
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC2110: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC2114: 41990018  bgt cr6, 0x82ec212c
	if ctx.cr[6].gt {
	pc = 0x82EC212C; continue 'dispatch;
	}
	// 82EC2118: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC211C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2120: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2124: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2128: 40990030  ble cr6, 0x82ec2158
	if !ctx.cr[6].gt {
	pc = 0x82EC2158; continue 'dispatch;
	}
	pc = 0x82EC212C; continue 'dispatch;
            }
            0x82EC212C => {
    //   block [0x82EC212C..0x82EC2140)
	// 82EC212C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC2130: 814A0718  lwz r10, 0x718(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2134: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2138: 41820008  beq 0x82ec2140
	if ctx.cr[0].eq {
	pc = 0x82EC2140; continue 'dispatch;
	}
	// 82EC213C: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82EC2140; continue 'dispatch;
            }
            0x82EC2140 => {
    //   block [0x82EC2140..0x82EC2158)
	// 82EC2140: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2144: C00A0A94  lfs f0, 0xa94(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2148: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC214C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EC2150: 40990008  ble cr6, 0x82ec2158
	if !ctx.cr[6].gt {
	pc = 0x82EC2158; continue 'dispatch;
	}
	// 82EC2154: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC2158; continue 'dispatch;
            }
            0x82EC2158 => {
    //   block [0x82EC2158..0x82EC216C)
	// 82EC2158: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC215C: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2160: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2164: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2170 size=468
    let mut pc: u32 = 0x82EC2170;
    'dispatch: loop {
        match pc {
            0x82EC2170 => {
    //   block [0x82EC2170..0x82EC21DC)
	// 82EC2170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC217C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2180: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EC2184: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EC2188: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC218C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2190: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2194: 897E0400  lbz r11, 0x400(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC2198: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC219C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC21A0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC21A4: 409A00A8  bne cr6, 0x82ec224c
	if !ctx.cr[6].eq {
	pc = 0x82EC224C; continue 'dispatch;
	}
	// 82EC21A8: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21AC: C1BE0404  lfs f13, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC21B4: 409A0028  bne cr6, 0x82ec21dc
	if !ctx.cr[6].eq {
	pc = 0x82EC21DC; continue 'dispatch;
	}
	// 82EC21B8: C01E0408  lfs f0, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21BC: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC21C4: 409A0018  bne cr6, 0x82ec21dc
	if !ctx.cr[6].eq {
	pc = 0x82EC21DC; continue 'dispatch;
	}
	// 82EC21C8: C01E040C  lfs f0, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC21D0: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC21D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC21D8: 419A0008  beq cr6, 0x82ec21e0
	if ctx.cr[6].eq {
	pc = 0x82EC21E0; continue 'dispatch;
	}
	pc = 0x82EC21DC; continue 'dispatch;
            }
            0x82EC21DC => {
    //   block [0x82EC21DC..0x82EC21E0)
	// 82EC21DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EC21E0; continue 'dispatch;
            }
            0x82EC21E0 => {
    //   block [0x82EC21E0..0x82EC224C)
	// 82EC21E0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC21E4: 41820068  beq 0x82ec224c
	if ctx.cr[0].eq {
	pc = 0x82EC224C; continue 'dispatch;
	}
	// 82EC21E8: C01E0404  lfs f0, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21EC: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC21F0: C01E0408  lfs f0, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21F4: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC21F8: C01E040C  lfs f0, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC21FC: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC2200: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2204: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2208: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC220C: C01E0404  lfs f0, 0x404(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2210: C1BE0408  lfs f13, 0x408(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2214: C19E040C  lfs f12, 0x40c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1036 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2218: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC221C: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2220: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2224: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2228: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC222C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2230: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2234: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2238: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC223C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2240: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2244: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2248: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82EC224C; continue 'dispatch;
            }
            0x82EC224C => {
    //   block [0x82EC224C..0x82EC22A0)
	// 82EC224C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2250: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2254: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC2258: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC225C: C15F0030  lfs f10, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2260: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2264: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2268: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC226C: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2270: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2274: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2278: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC227C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2280: 419A0020  beq cr6, 0x82ec22a0
	if ctx.cr[6].eq {
	pc = 0x82EC22A0; continue 'dispatch;
	}
	// 82EC2284: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC2288: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC228C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC2290: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC2294: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2298: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC229C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EC22A0; continue 'dispatch;
            }
            0x82EC22A0 => {
    //   block [0x82EC22A0..0x82EC22E0)
	// 82EC22A0: 4B39E719  bl 0x822609b8
	ctx.lr = 0x82EC22A4;
	sub_822609B8(ctx, base);
	// 82EC22A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC22A8: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC22AC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC22B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC22B4: 388AC7F0  addi r4, r10, -0x3810
	ctx.r[4].s64 = ctx.r[10].s64 + -14352;
	// 82EC22B8: C3CB0058  lfs f30, 0x58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC22BC: 4BFBB405  bl 0x82e7d6c0
	ctx.lr = 0x82EC22C0;
	sub_82E7D6C0(ctx, base);
	// 82EC22C0: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC22C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC22C8: 4182001C  beq 0x82ec22e4
	if ctx.cr[0].eq {
	pc = 0x82EC22E4; continue 'dispatch;
	}
	// 82EC22CC: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC22D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC22D4: 4182000C  beq 0x82ec22e0
	if ctx.cr[0].eq {
	pc = 0x82EC22E0; continue 'dispatch;
	}
	// 82EC22D8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC22DC: 48000008  b 0x82ec22e4
	pc = 0x82EC22E4; continue 'dispatch;
            }
            0x82EC22E0 => {
    //   block [0x82EC22E0..0x82EC22E4)
	// 82EC22E0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EC22E4; continue 'dispatch;
            }
            0x82EC22E4 => {
    //   block [0x82EC22E4..0x82EC2344)
	// 82EC22E4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EC22E8: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC22EC: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC22F0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC22F4: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC22F8: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC22FC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2300: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2304: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2308: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC230C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2310: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC2314: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2318: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC231C: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2320: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC2324: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC232C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2330: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC2334: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EC2338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC233C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2348 size=84
    let mut pc: u32 = 0x82EC2348;
    'dispatch: loop {
        match pc {
            0x82EC2348 => {
    //   block [0x82EC2348..0x82EC2390)
	// 82EC2348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC234C: 4BDE70C1  bl 0x82ca940c
	ctx.lr = 0x82EC2350;
	sub_82CA93D0(ctx, base);
	// 82EC2350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2358: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC235C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2360: 4B7545C9  bl 0x82616928
	ctx.lr = 0x82EC2364;
	sub_82616928(ctx, base);
	// 82EC2364: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2368: 41820028  beq 0x82ec2390
	if ctx.cr[0].eq {
	pc = 0x82EC2390; continue 'dispatch;
	}
	// 82EC236C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2378: 4BFF2FB9  bl 0x82eb5330
	ctx.lr = 0x82EC237C;
	sub_82EB5330(ctx, base);
	// 82EC237C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2384: 396BA800  addi r11, r11, -0x5800
	ctx.r[11].s64 = ctx.r[11].s64 + -22528;
	// 82EC2388: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC238C: 48000008  b 0x82ec2394
	pc = 0x82EC2394; continue 'dispatch;
            }
            0x82EC2390 => {
    //   block [0x82EC2390..0x82EC2394)
	// 82EC2390: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC2394; continue 'dispatch;
            }
            0x82EC2394 => {
    //   block [0x82EC2394..0x82EC239C)
	// 82EC2394: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2398: 4BDE70C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC23A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC23A0 size=40
    let mut pc: u32 = 0x82EC23A0;
    'dispatch: loop {
        match pc {
            0x82EC23A0 => {
    //   block [0x82EC23A0..0x82EC23B8)
	// 82EC23A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC23A4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC23A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC23AC: 4182000C  beq 0x82ec23b8
	if ctx.cr[0].eq {
	pc = 0x82EC23B8; continue 'dispatch;
	}
	// 82EC23B0: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23B4: 4800000C  b 0x82ec23c0
	pc = 0x82EC23C0; continue 'dispatch;
            }
            0x82EC23B8 => {
    //   block [0x82EC23B8..0x82EC23C0)
	// 82EC23B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC23BC: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC23C0; continue 'dispatch;
            }
            0x82EC23C0 => {
    //   block [0x82EC23C0..0x82EC23C8)
	// 82EC23C0: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC23C4: 48001CB4  b 0x82ec4078
	sub_82EC4078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC23C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC23C8 size=80
    let mut pc: u32 = 0x82EC23C8;
    'dispatch: loop {
        match pc {
            0x82EC23C8 => {
    //   block [0x82EC23C8..0x82EC2410)
	// 82EC23C8: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC23D0: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC23D4: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC23D8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC23DC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC23E0: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC23E4: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC23E8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC23EC: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC23F0: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC23F4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC23F8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC23FC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2400: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2404: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2408: 41980008  blt cr6, 0x82ec2410
	if ctx.cr[6].lt {
	pc = 0x82EC2410; continue 'dispatch;
	}
	// 82EC240C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EC2410; continue 'dispatch;
            }
            0x82EC2410 => {
    //   block [0x82EC2410..0x82EC2418)
	// 82EC2410: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC2414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC2418 size=12
    let mut pc: u32 = 0x82EC2418;
    'dispatch: loop {
        match pc {
            0x82EC2418 => {
    //   block [0x82EC2418..0x82EC2424)
	// 82EC2418: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC241C: 386BDC08  addi r3, r11, -0x23f8
	ctx.r[3].s64 = ctx.r[11].s64 + -9208;
	// 82EC2420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2428 size=84
    let mut pc: u32 = 0x82EC2428;
    'dispatch: loop {
        match pc {
            0x82EC2428 => {
    //   block [0x82EC2428..0x82EC2470)
	// 82EC2428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC242C: 4BDE6FE1  bl 0x82ca940c
	ctx.lr = 0x82EC2430;
	sub_82CA93D0(ctx, base);
	// 82EC2430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2438: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EC243C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2440: 4B7544E9  bl 0x82616928
	ctx.lr = 0x82EC2444;
	sub_82616928(ctx, base);
	// 82EC2444: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2448: 41820028  beq 0x82ec2470
	if ctx.cr[0].eq {
	pc = 0x82EC2470; continue 'dispatch;
	}
	// 82EC244C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2450: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2458: 4BFF2ED9  bl 0x82eb5330
	ctx.lr = 0x82EC245C;
	sub_82EB5330(ctx, base);
	// 82EC245C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2464: 396BB0E8  addi r11, r11, -0x4f18
	ctx.r[11].s64 = ctx.r[11].s64 + -20248;
	// 82EC2468: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC246C: 48000008  b 0x82ec2474
	pc = 0x82EC2474; continue 'dispatch;
            }
            0x82EC2470 => {
    //   block [0x82EC2470..0x82EC2474)
	// 82EC2470: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC2474; continue 'dispatch;
            }
            0x82EC2474 => {
    //   block [0x82EC2474..0x82EC247C)
	// 82EC2474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2478: 4BDE6FE4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2480 size=192
    let mut pc: u32 = 0x82EC2480;
    'dispatch: loop {
        match pc {
            0x82EC2480 => {
    //   block [0x82EC2480..0x82EC24E0)
	// 82EC2480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2484: 4BDE6F89  bl 0x82ca940c
	ctx.lr = 0x82EC2488;
	sub_82CA93D0(ctx, base);
	// 82EC2488: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC248C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2490: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC2494: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC2498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC249C: 482F9BC5  bl 0x831bc060
	ctx.lr = 0x82EC24A0;
	sub_831BC060(ctx, base);
	// 82EC24A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC24A4: 41820084  beq 0x82ec2528
	if ctx.cr[0].eq {
	pc = 0x82EC2528; continue 'dispatch;
	}
	// 82EC24A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC24AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC24B0: 3BCBAF1C  addi r30, r11, -0x50e4
	ctx.r[30].s64 = ctx.r[11].s64 + -20708;
	// 82EC24B4: 482F9BAD  bl 0x831bc060
	ctx.lr = 0x82EC24B8;
	sub_831BC060(ctx, base);
	// 82EC24B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC24BC: 4BDEA695  bl 0x82cacb50
	ctx.lr = 0x82EC24C0;
	sub_82CACB50(ctx, base);
	// 82EC24C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC24C4: 40820064  bne 0x82ec2528
	if !ctx.cr[0].eq {
	pc = 0x82EC2528; continue 'dispatch;
	}
	// 82EC24C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC24CC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC24D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC24D4: 4182000C  beq 0x82ec24e0
	if ctx.cr[0].eq {
	pc = 0x82EC24E0; continue 'dispatch;
	}
	// 82EC24D8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC24DC: 4800000C  b 0x82ec24e8
	pc = 0x82EC24E8; continue 'dispatch;
            }
            0x82EC24E0 => {
    //   block [0x82EC24E0..0x82EC24E8)
	// 82EC24E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC24E4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC24E8; continue 'dispatch;
            }
            0x82EC24E8 => {
    //   block [0x82EC24E8..0x82EC2508)
	// 82EC24E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC24EC: 4BA4B81D  bl 0x8290dd08
	ctx.lr = 0x82EC24F0;
	sub_8290DD08(ctx, base);
	// 82EC24F0: 4BDE96C1  bl 0x82cabbb0
	ctx.lr = 0x82EC24F4;
	sub_82CABBB0(ctx, base);
	// 82EC24F4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC24F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC24FC: C01D0014  lfs f0, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2500: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2504: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC2508; continue 'dispatch;
            }
            0x82EC2508 => {
    //   block [0x82EC2508..0x82EC2514)
	// 82EC2508: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC250C: 40990008  ble cr6, 0x82ec2514
	if !ctx.cr[6].gt {
	pc = 0x82EC2514; continue 'dispatch;
	}
	// 82EC2510: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC2514; continue 'dispatch;
            }
            0x82EC2514 => {
    //   block [0x82EC2514..0x82EC2528)
	// 82EC2514: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC2518: 409AFFF0  bne cr6, 0x82ec2508
	if !ctx.cr[6].eq {
	pc = 0x82EC2508; continue 'dispatch;
	}
	// 82EC251C: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2520: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2524: 48000010  b 0x82ec2534
	pc = 0x82EC2534; continue 'dispatch;
            }
            0x82EC2528 => {
    //   block [0x82EC2528..0x82EC2534)
	// 82EC2528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC252C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2530: 48000231  bl 0x82ec2760
	ctx.lr = 0x82EC2534;
	sub_82EC2760(ctx, base);
	pc = 0x82EC2534; continue 'dispatch;
            }
            0x82EC2534 => {
    //   block [0x82EC2534..0x82EC2540)
	// 82EC2534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2538: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC253C: 4BDE6F20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2540 size=136
    let mut pc: u32 = 0x82EC2540;
    'dispatch: loop {
        match pc {
            0x82EC2540 => {
    //   block [0x82EC2540..0x82EC256C)
	// 82EC2540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC254C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2550: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2558: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC255C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2560: 4182000C  beq 0x82ec256c
	if ctx.cr[0].eq {
	pc = 0x82EC256C; continue 'dispatch;
	}
	// 82EC2564: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2568: 4800000C  b 0x82ec2574
	pc = 0x82EC2574; continue 'dispatch;
            }
            0x82EC256C => {
    //   block [0x82EC256C..0x82EC2574)
	// 82EC256C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2570: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC2574; continue 'dispatch;
            }
            0x82EC2574 => {
    //   block [0x82EC2574..0x82EC259C)
	// 82EC2574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC257C: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2580: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2584: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2588: 48000299  bl 0x82ec2820
	ctx.lr = 0x82EC258C;
	sub_82EC2820(ctx, base);
	// 82EC258C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2590: 4082000C  bne 0x82ec259c
	if !ctx.cr[0].eq {
	pc = 0x82EC259C; continue 'dispatch;
	}
	// 82EC2594: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC2598: 4800001C  b 0x82ec25b4
	pc = 0x82EC25B4; continue 'dispatch;
            }
            0x82EC259C => {
    //   block [0x82EC259C..0x82EC25B4)
	// 82EC259C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC25A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC25A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC25A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC25AC: 4E800421  bctrl
	ctx.lr = 0x82EC25B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC25B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82EC25B4 => {
    //   block [0x82EC25B4..0x82EC25C8)
	// 82EC25B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC25B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC25BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC25C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC25C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC25C8 size=16
    let mut pc: u32 = 0x82EC25C8;
    'dispatch: loop {
        match pc {
            0x82EC25C8 => {
    //   block [0x82EC25C8..0x82EC25D8)
	// 82EC25C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC25CC: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC25D0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC25D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC25D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC25D8 size=304
    let mut pc: u32 = 0x82EC25D8;
    'dispatch: loop {
        match pc {
            0x82EC25D8 => {
    //   block [0x82EC25D8..0x82EC2604)
	// 82EC25D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC25DC: 4BDE6E31  bl 0x82ca940c
	ctx.lr = 0x82EC25E0;
	sub_82CA93D0(ctx, base);
	// 82EC25E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC25E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC25E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC25EC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EC25F0: 48000301  bl 0x82ec28f0
	ctx.lr = 0x82EC25F4;
	sub_82EC28F0(ctx, base);
	// 82EC25F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC25F8: 4182000C  beq 0x82ec2604
	if ctx.cr[0].eq {
	pc = 0x82EC2604; continue 'dispatch;
	}
	// 82EC25FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2600: 480000F8  b 0x82ec26f8
	pc = 0x82EC26F8; continue 'dispatch;
            }
            0x82EC2604 => {
    //   block [0x82EC2604..0x82EC262C)
	// 82EC2604: 4B39E3B5  bl 0x822609b8
	ctx.lr = 0x82EC2608;
	sub_822609B8(ctx, base);
	// 82EC2608: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC260C: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2610: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC2614: 40990018  ble cr6, 0x82ec262c
	if !ctx.cr[6].gt {
	pc = 0x82EC262C; continue 'dispatch;
	}
	// 82EC2618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC261C: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2620: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2624: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2628: 480000CC  b 0x82ec26f4
	pc = 0x82EC26F4; continue 'dispatch;
            }
            0x82EC262C => {
    //   block [0x82EC262C..0x82EC268C)
	// 82EC262C: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2630: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2634: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2638: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC263C: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2640: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2644: C13D0008  lfs f9, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC2648: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC264C: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2650: C15D000C  lfs f10, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2654: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2658: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC265C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2660: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2664: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2668: 4098008C  bge cr6, 0x82ec26f4
	if !ctx.cr[6].lt {
	pc = 0x82EC26F4; continue 'dispatch;
	}
	// 82EC266C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2670: 806B023C  lwz r3, 0x23c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EC2674: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2678: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC267C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2680: 4E800421  bctrl
	ctx.lr = 0x82EC2684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2684: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC2688: 396BD244  addi r11, r11, -0x2dbc
	ctx.r[11].s64 = ctx.r[11].s64 + -11708;
            }
            0x82EC268C => {
    //   block [0x82EC268C..0x82EC26A4)
	// 82EC268C: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC2690: 419A0070  beq cr6, 0x82ec2700
	if ctx.cr[6].eq {
	pc = 0x82EC2700; continue 'dispatch;
	}
	// 82EC2694: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EC2698: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC269C: 4082FFF0  bne 0x82ec268c
	if !ctx.cr[0].eq {
	pc = 0x82EC268C; continue 'dispatch;
	}
	// 82EC26A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC26A4; continue 'dispatch;
            }
            0x82EC26A4 => {
    //   block [0x82EC26A4..0x82EC26E4)
	// 82EC26A4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC26A8: 4182004C  beq 0x82ec26f4
	if ctx.cr[0].eq {
	pc = 0x82EC26F4; continue 'dispatch;
	}
	// 82EC26AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC26B0: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26B4: C1AB03A8  lfs f13, 0x3a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(936 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC26BC: 409A0028  bne cr6, 0x82ec26e4
	if !ctx.cr[6].eq {
	pc = 0x82EC26E4; continue 'dispatch;
	}
	// 82EC26C0: C00B03AC  lfs f0, 0x3ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26C4: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC26CC: 409A0018  bne cr6, 0x82ec26e4
	if !ctx.cr[6].eq {
	pc = 0x82EC26E4; continue 'dispatch;
	}
	// 82EC26D0: C00B03B0  lfs f0, 0x3b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC26D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC26D8: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC26DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC26E0: 419A0008  beq cr6, 0x82ec26e8
	if ctx.cr[6].eq {
	pc = 0x82EC26E8; continue 'dispatch;
	}
	pc = 0x82EC26E4; continue 'dispatch;
            }
            0x82EC26E4 => {
    //   block [0x82EC26E4..0x82EC26E8)
	// 82EC26E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC26E8; continue 'dispatch;
            }
            0x82EC26E8 => {
    //   block [0x82EC26E8..0x82EC26F4)
	// 82EC26E8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC26EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC26F0: 40820008  bne 0x82ec26f8
	if !ctx.cr[0].eq {
	pc = 0x82EC26F8; continue 'dispatch;
	}
	pc = 0x82EC26F4; continue 'dispatch;
            }
            0x82EC26F4 => {
    //   block [0x82EC26F4..0x82EC26F8)
	// 82EC26F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC26F8; continue 'dispatch;
            }
            0x82EC26F8 => {
    //   block [0x82EC26F8..0x82EC2700)
	// 82EC26F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC26FC: 4BDE6D60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC2700 => {
    //   block [0x82EC2700..0x82EC2708)
	// 82EC2700: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC2704: 4BFFFFA0  b 0x82ec26a4
	pc = 0x82EC26A4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2708 size=84
    let mut pc: u32 = 0x82EC2708;
    'dispatch: loop {
        match pc {
            0x82EC2708 => {
    //   block [0x82EC2708..0x82EC2750)
	// 82EC2708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC270C: 4BDE6D01  bl 0x82ca940c
	ctx.lr = 0x82EC2710;
	sub_82CA93D0(ctx, base);
	// 82EC2710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2714: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2718: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82EC271C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2720: 4B754209  bl 0x82616928
	ctx.lr = 0x82EC2724;
	sub_82616928(ctx, base);
	// 82EC2724: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2728: 41820028  beq 0x82ec2750
	if ctx.cr[0].eq {
	pc = 0x82EC2750; continue 'dispatch;
	}
	// 82EC272C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC2730: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2738: 4BFF2BF9  bl 0x82eb5330
	ctx.lr = 0x82EC273C;
	sub_82EB5330(ctx, base);
	// 82EC273C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2744: 396BA7E8  addi r11, r11, -0x5818
	ctx.r[11].s64 = ctx.r[11].s64 + -22552;
	// 82EC2748: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC274C: 48000008  b 0x82ec2754
	pc = 0x82EC2754; continue 'dispatch;
            }
            0x82EC2750 => {
    //   block [0x82EC2750..0x82EC2754)
	// 82EC2750: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC2754; continue 'dispatch;
            }
            0x82EC2754 => {
    //   block [0x82EC2754..0x82EC275C)
	// 82EC2754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC2758: 4BDE6D04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2760 size=192
    let mut pc: u32 = 0x82EC2760;
    'dispatch: loop {
        match pc {
            0x82EC2760 => {
    //   block [0x82EC2760..0x82EC27C0)
	// 82EC2760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2764: 4BDE6CA9  bl 0x82ca940c
	ctx.lr = 0x82EC2768;
	sub_82CA93D0(ctx, base);
	// 82EC2768: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC276C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2770: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC2774: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EC2778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC277C: 482F98E5  bl 0x831bc060
	ctx.lr = 0x82EC2780;
	sub_831BC060(ctx, base);
	// 82EC2780: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2784: 41820084  beq 0x82ec2808
	if ctx.cr[0].eq {
	pc = 0x82EC2808; continue 'dispatch;
	}
	// 82EC2788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC278C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2790: 3BCBA628  addi r30, r11, -0x59d8
	ctx.r[30].s64 = ctx.r[11].s64 + -23000;
	// 82EC2794: 482F98CD  bl 0x831bc060
	ctx.lr = 0x82EC2798;
	sub_831BC060(ctx, base);
	// 82EC2798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC279C: 4BDEA3B5  bl 0x82cacb50
	ctx.lr = 0x82EC27A0;
	sub_82CACB50(ctx, base);
	// 82EC27A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC27A4: 40820064  bne 0x82ec2808
	if !ctx.cr[0].eq {
	pc = 0x82EC2808; continue 'dispatch;
	}
	// 82EC27A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC27AC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC27B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC27B4: 4182000C  beq 0x82ec27c0
	if ctx.cr[0].eq {
	pc = 0x82EC27C0; continue 'dispatch;
	}
	// 82EC27B8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC27BC: 4800000C  b 0x82ec27c8
	pc = 0x82EC27C8; continue 'dispatch;
            }
            0x82EC27C0 => {
    //   block [0x82EC27C0..0x82EC27C8)
	// 82EC27C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC27C4: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EC27C8; continue 'dispatch;
            }
            0x82EC27C8 => {
    //   block [0x82EC27C8..0x82EC27E8)
	// 82EC27C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC27CC: 4BA4B53D  bl 0x8290dd08
	ctx.lr = 0x82EC27D0;
	sub_8290DD08(ctx, base);
	// 82EC27D0: 4BDE93E1  bl 0x82cabbb0
	ctx.lr = 0x82EC27D4;
	sub_82CABBB0(ctx, base);
	// 82EC27D4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC27D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC27DC: C01D0010  lfs f0, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC27E0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC27E4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EC27E8; continue 'dispatch;
            }
            0x82EC27E8 => {
    //   block [0x82EC27E8..0x82EC27F4)
	// 82EC27E8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC27EC: 40990008  ble cr6, 0x82ec27f4
	if !ctx.cr[6].gt {
	pc = 0x82EC27F4; continue 'dispatch;
	}
	// 82EC27F0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC27F4; continue 'dispatch;
            }
            0x82EC27F4 => {
    //   block [0x82EC27F4..0x82EC2808)
	// 82EC27F4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EC27F8: 409AFFF0  bne cr6, 0x82ec27e8
	if !ctx.cr[6].eq {
	pc = 0x82EC27E8; continue 'dispatch;
	}
	// 82EC27FC: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2800: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC2804: 48000010  b 0x82ec2814
	pc = 0x82EC2814; continue 'dispatch;
            }
            0x82EC2808 => {
    //   block [0x82EC2808..0x82EC2814)
	// 82EC2808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC280C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2810: 4BFF2C11  bl 0x82eb5420
	ctx.lr = 0x82EC2814;
	sub_82EB5420(ctx, base);
	pc = 0x82EC2814; continue 'dispatch;
            }
            0x82EC2814 => {
    //   block [0x82EC2814..0x82EC2820)
	// 82EC2814: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC2818: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC281C: 4BDE6C40  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2820 size=204
    let mut pc: u32 = 0x82EC2820;
    'dispatch: loop {
        match pc {
            0x82EC2820 => {
    //   block [0x82EC2820..0x82EC2870)
	// 82EC2820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC282C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2838: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC283C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC2840: 388AC178  addi r4, r10, -0x3e88
	ctx.r[4].s64 = ctx.r[10].s64 + -16008;
	// 82EC2844: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC2848: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC284C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2850: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2854: 4B325E25  bl 0x821e8678
	ctx.lr = 0x82EC2858;
	sub_821E8678(ctx, base);
	// 82EC2858: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC285C: 41820014  beq 0x82ec2870
	if ctx.cr[0].eq {
	pc = 0x82EC2870; continue 'dispatch;
	}
	// 82EC2860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2864: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2868: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC286C: 4800002C  b 0x82ec2898
	pc = 0x82EC2898; continue 'dispatch;
            }
            0x82EC2870 => {
    //   block [0x82EC2870..0x82EC2888)
	// 82EC2870: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2874: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2878: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC287C: 4182000C  beq 0x82ec2888
	if ctx.cr[0].eq {
	pc = 0x82EC2888; continue 'dispatch;
	}
	// 82EC2880: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2884: 4800000C  b 0x82ec2890
	pc = 0x82EC2890; continue 'dispatch;
            }
            0x82EC2888 => {
    //   block [0x82EC2888..0x82EC2890)
	// 82EC2888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC288C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC2890; continue 'dispatch;
            }
            0x82EC2890 => {
    //   block [0x82EC2890..0x82EC2898)
	// 82EC2890: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EC2894: C00B5CC4  lfs f0, 0x5cc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(23748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC2898; continue 'dispatch;
            }
            0x82EC2898 => {
    //   block [0x82EC2898..0x82EC28BC)
	// 82EC2898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC289C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC28A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC28A4: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC28A8: 480017D1  bl 0x82ec4078
	ctx.lr = 0x82EC28AC;
	sub_82EC4078(ctx, base);
	// 82EC28AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC28B0: 4082000C  bne 0x82ec28bc
	if !ctx.cr[0].eq {
	pc = 0x82EC28BC; continue 'dispatch;
	}
	// 82EC28B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC28B8: 4800001C  b 0x82ec28d4
	pc = 0x82EC28D4; continue 'dispatch;
            }
            0x82EC28BC => {
    //   block [0x82EC28BC..0x82EC28D4)
	// 82EC28BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC28C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC28C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC28C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC28CC: 4E800421  bctrl
	ctx.lr = 0x82EC28D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC28D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82EC28D4 => {
    //   block [0x82EC28D4..0x82EC28EC)
	// 82EC28D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC28D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC28DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC28E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC28E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC28E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC28F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC28F0 size=120
    let mut pc: u32 = 0x82EC28F0;
    'dispatch: loop {
        match pc {
            0x82EC28F0 => {
    //   block [0x82EC28F0..0x82EC2908)
	// 82EC28F0: 8943000C  lbz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC28F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC28F8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC28FC: 4182000C  beq 0x82ec2908
	if ctx.cr[0].eq {
	pc = 0x82EC2908; continue 'dispatch;
	}
	// 82EC2900: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2904: 48000008  b 0x82ec290c
	pc = 0x82EC290C; continue 'dispatch;
            }
            0x82EC2908 => {
    //   block [0x82EC2908..0x82EC290C)
	// 82EC2908: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC290C; continue 'dispatch;
            }
            0x82EC290C => {
    //   block [0x82EC290C..0x82EC2958)
	// 82EC290C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2910: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2914: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2918: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC291C: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2920: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2924: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2928: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC292C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2930: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC2934: 40980024  bge cr6, 0x82ec2958
	if !ctx.cr[6].lt {
	pc = 0x82EC2958; continue 'dispatch;
	}
	// 82EC2938: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC293C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC2940: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2944: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2948: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC294C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EC2950: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC2954: 41980008  blt cr6, 0x82ec295c
	if ctx.cr[6].lt {
	pc = 0x82EC295C; continue 'dispatch;
	}
	pc = 0x82EC2958; continue 'dispatch;
            }
            0x82EC2958 => {
    //   block [0x82EC2958..0x82EC295C)
	// 82EC2958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC295C; continue 'dispatch;
            }
            0x82EC295C => {
    //   block [0x82EC295C..0x82EC2968)
	// 82EC295C: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82EC2960: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC2964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC2968 size=12
    let mut pc: u32 = 0x82EC2968;
    'dispatch: loop {
        match pc {
            0x82EC2968 => {
    //   block [0x82EC2968..0x82EC2974)
	// 82EC2968: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC296C: 386BDE30  addi r3, r11, -0x21d0
	ctx.r[3].s64 = ctx.r[11].s64 + -8656;
	// 82EC2970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC2978 size=84
    let mut pc: u32 = 0x82EC2978;
    'dispatch: loop {
        match pc {
            0x82EC2978 => {
    //   block [0x82EC2978..0x82EC29C0)
	// 82EC2978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC297C: 4BDE6A91  bl 0x82ca940c
	ctx.lr = 0x82EC2980;
	sub_82CA93D0(ctx, base);
	// 82EC2980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC2988: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82EC298C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2990: 4B753F99  bl 0x82616928
	ctx.lr = 0x82EC2994;
	sub_82616928(ctx, base);
	// 82EC2994: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC2998: 41820028  beq 0x82ec29c0
	if ctx.cr[0].eq {
	pc = 0x82EC29C0; continue 'dispatch;
	}
	// 82EC299C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC29A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC29A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC29A8: 4BFF2989  bl 0x82eb5330
	ctx.lr = 0x82EC29AC;
	sub_82EB5330(ctx, base);
	// 82EC29AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC29B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC29B4: 396BB148  addi r11, r11, -0x4eb8
	ctx.r[11].s64 = ctx.r[11].s64 + -20152;
	// 82EC29B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC29BC: 48000008  b 0x82ec29c4
	pc = 0x82EC29C4; continue 'dispatch;
            }
            0x82EC29C0 => {
    //   block [0x82EC29C0..0x82EC29C4)
	// 82EC29C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC29C4; continue 'dispatch;
            }
            0x82EC29C4 => {
    //   block [0x82EC29C4..0x82EC29CC)
	// 82EC29C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC29C8: 4BDE6A94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC29D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC29D0 size=84
    let mut pc: u32 = 0x82EC29D0;
    'dispatch: loop {
        match pc {
            0x82EC29D0 => {
    //   block [0x82EC29D0..0x82EC29F8)
	// 82EC29D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC29D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC29D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC29DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC29E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC29E4: 48001695  bl 0x82ec4078
	ctx.lr = 0x82EC29E8;
	sub_82EC4078(ctx, base);
	// 82EC29E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC29EC: 4082000C  bne 0x82ec29f8
	if !ctx.cr[0].eq {
	pc = 0x82EC29F8; continue 'dispatch;
	}
	// 82EC29F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC29F4: 4800001C  b 0x82ec2a10
	pc = 0x82EC2A10; continue 'dispatch;
            }
            0x82EC29F8 => {
    //   block [0x82EC29F8..0x82EC2A10)
	// 82EC29F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC29FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2A00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2A08: 4E800421  bctrl
	ctx.lr = 0x82EC2A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2A0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82EC2A10 => {
    //   block [0x82EC2A10..0x82EC2A24)
	// 82EC2A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC2A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2A28 size=112
    let mut pc: u32 = 0x82EC2A28;
    'dispatch: loop {
        match pc {
            0x82EC2A28 => {
    //   block [0x82EC2A28..0x82EC2A44)
	// 82EC2A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC2A2C: 892B000C  lbz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC2A30: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2A34: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2A38: 4182000C  beq 0x82ec2a44
	if ctx.cr[0].eq {
	pc = 0x82EC2A44; continue 'dispatch;
	}
	// 82EC2A3C: C00A0018  lfs f0, 0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2A40: 48000008  b 0x82ec2a48
	pc = 0x82EC2A48; continue 'dispatch;
            }
            0x82EC2A44 => {
    //   block [0x82EC2A44..0x82EC2A48)
	// 82EC2A44: C00A0014  lfs f0, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC2A48; continue 'dispatch;
            }
            0x82EC2A48 => {
    //   block [0x82EC2A48..0x82EC2A8C)
	// 82EC2A48: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2A4C: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2A50: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2A54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC2A58: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2A5C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2A60: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2A64: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2A68: C144000C  lfs f10, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2A6C: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2A70: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC2A74: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2A78: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2A7C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2A80: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC2A84: 41980008  blt cr6, 0x82ec2a8c
	if ctx.cr[6].lt {
	pc = 0x82EC2A8C; continue 'dispatch;
	}
	// 82EC2A88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82EC2A8C; continue 'dispatch;
            }
            0x82EC2A8C => {
    //   block [0x82EC2A8C..0x82EC2A98)
	// 82EC2A8C: 5543063E  clrlwi r3, r10, 0x18
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EC2A90: 986B000C  stb r3, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u8 ) };
	// 82EC2A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2A98 size=92
    let mut pc: u32 = 0x82EC2A98;
    'dispatch: loop {
        match pc {
            0x82EC2A98 => {
    //   block [0x82EC2A98..0x82EC2AF4)
	// 82EC2A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC2AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC2AA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2AAC: 4BFF2885  bl 0x82eb5330
	ctx.lr = 0x82EC2AB0;
	sub_82EB5330(ctx, base);
	// 82EC2AB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2AB8: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2ABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2AC0: 396BB184  addi r11, r11, -0x4e7c
	ctx.r[11].s64 = ctx.r[11].s64 + -20092;
	// 82EC2AC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC2AC8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2ACC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2AD0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2AD4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2AD8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2ADC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2AE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC2AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC2AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC2AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC2AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC2AF8 size=12
    let mut pc: u32 = 0x82EC2AF8;
    'dispatch: loop {
        match pc {
            0x82EC2AF8 => {
    //   block [0x82EC2AF8..0x82EC2B04)
	// 82EC2AF8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC2AFC: 386BDF44  addi r3, r11, -0x20bc
	ctx.r[3].s64 = ctx.r[11].s64 + -8380;
	// 82EC2B00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC2B08 size=36
    let mut pc: u32 = 0x82EC2B08;
    'dispatch: loop {
        match pc {
            0x82EC2B08 => {
    //   block [0x82EC2B08..0x82EC2B2C)
	// 82EC2B08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2B0C: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2B10: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2B14: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2B18: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2B1C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2B20: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2B24: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2B30 size=568
    let mut pc: u32 = 0x82EC2B30;
    'dispatch: loop {
        match pc {
            0x82EC2B30 => {
    //   block [0x82EC2B30..0x82EC2B80)
	// 82EC2B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2B34: 4BDE68D1  bl 0x82ca9404
	ctx.lr = 0x82EC2B38;
	sub_82CA93D0(ctx, base);
	// 82EC2B38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2B3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EC2B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC2B44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EC2B48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC2B4C: 4BFAD3AD  bl 0x82e6fef8
	ctx.lr = 0x82EC2B50;
	sub_82E6FEF8(ctx, base);
	// 82EC2B50: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC2B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2B58: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC2B5C: 4BFC6B85  bl 0x82e896e0
	ctx.lr = 0x82EC2B60;
	sub_82E896E0(ctx, base);
	// 82EC2B60: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC2B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B68: 41820038  beq 0x82ec2ba0
	if ctx.cr[0].eq {
	pc = 0x82EC2BA0; continue 'dispatch;
	}
	// 82EC2B6C: 8943001C  lbz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC2B70: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC2B74: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B78: 40820008  bne 0x82ec2b80
	if !ctx.cr[0].eq {
	pc = 0x82EC2B80; continue 'dispatch;
	}
	// 82EC2B7C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82EC2B80; continue 'dispatch;
            }
            0x82EC2B80 => {
    //   block [0x82EC2B80..0x82EC2B98)
	// 82EC2B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B84: 419A001C  beq cr6, 0x82ec2ba0
	if ctx.cr[6].eq {
	pc = 0x82EC2BA0; continue 'dispatch;
	}
	// 82EC2B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC2B8C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC2B90: 409A0008  bne cr6, 0x82ec2b98
	if !ctx.cr[6].eq {
	pc = 0x82EC2B98; continue 'dispatch;
	}
	// 82EC2B94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82EC2B98; continue 'dispatch;
            }
            0x82EC2B98 => {
    //   block [0x82EC2B98..0x82EC2BA0)
	// 82EC2B98: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC2B9C: 48000008  b 0x82ec2ba4
	pc = 0x82EC2BA4; continue 'dispatch;
            }
            0x82EC2BA0 => {
    //   block [0x82EC2BA0..0x82EC2BA4)
	// 82EC2BA0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82EC2BA4; continue 'dispatch;
            }
            0x82EC2BA4 => {
    //   block [0x82EC2BA4..0x82EC2C04)
	// 82EC2BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2BA8: 409A0170  bne cr6, 0x82ec2d18
	if !ctx.cr[6].eq {
	pc = 0x82EC2D18; continue 'dispatch;
	}
	// 82EC2BAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2BB0: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2BB4: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BB8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2BBC: 419A0098  beq cr6, 0x82ec2c54
	if ctx.cr[6].eq {
	pc = 0x82EC2C54; continue 'dispatch;
	}
	// 82EC2BC0: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BC4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2BC8: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2BCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2BD0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2BD4: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2BD8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2BDC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC2BE0: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2BE4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2BE8: C19F0010  lfs f12, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2BEC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2BF0: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2BF4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2BF8: 4182000C  beq 0x82ec2c04
	if ctx.cr[0].eq {
	pc = 0x82EC2C04; continue 'dispatch;
	}
	// 82EC2BFC: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2C00: 48000008  b 0x82ec2c08
	pc = 0x82EC2C08; continue 'dispatch;
            }
            0x82EC2C04 => {
    //   block [0x82EC2C04..0x82EC2C08)
	// 82EC2C04: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	pc = 0x82EC2C08; continue 'dispatch;
            }
            0x82EC2C08 => {
    //   block [0x82EC2C08..0x82EC2C14)
	// 82EC2C08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C0C: 41820008  beq 0x82ec2c14
	if ctx.cr[0].eq {
	pc = 0x82EC2C14; continue 'dispatch;
	}
	// 82EC2C10: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82EC2C14; continue 'dispatch;
            }
            0x82EC2C14 => {
    //   block [0x82EC2C14..0x82EC2C54)
	// 82EC2C14: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2C18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2C1C: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC2C20: ED8C033A  fmadds f12, f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2C24: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C28: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2C2C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EC2C30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2C34: 41990020  bgt cr6, 0x82ec2c54
	if ctx.cr[6].gt {
	pc = 0x82EC2C54; continue 'dispatch;
	}
	// 82EC2C38: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C3C: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC2C40: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C44: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC2C48: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2C4C: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2C50: 4800010C  b 0x82ec2d5c
	pc = 0x82EC2D5C; continue 'dispatch;
            }
            0x82EC2C54 => {
    //   block [0x82EC2C54..0x82EC2D00)
	// 82EC2C54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2C58: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2C5C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C60: 41820100  beq 0x82ec2d60
	if ctx.cr[0].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2C64: 816A0048  lwz r11, 0x48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2C6C: 419A00F4  beq cr6, 0x82ec2d60
	if ctx.cr[6].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	// 82EC2C70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC2C74: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82EC2C78: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82EC2C7C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82EC2C80: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EC2C84: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82EC2C88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC2C8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2C90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC2C94: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC2C98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EC2C9C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EC2CA0: 806A0048  lwz r3, 0x48(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2CA4: 4822BB55  bl 0x830ee7f8
	ctx.lr = 0x82EC2CA8;
	sub_830EE7F8(ctx, base);
	// 82EC2CA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2CAC: 40820054  bne 0x82ec2d00
	if !ctx.cr[0].eq {
	pc = 0x82EC2D00; continue 'dispatch;
	}
	// 82EC2CB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2CB4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC2CB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC2CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC2CC0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC2CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2CC8: 4E800421  bctrl
	ctx.lr = 0x82EC2CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2CCC: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CD0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2CD4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CD8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EC2CDC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CE0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC2CE4: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CE8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC2CEC: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CF0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC2CF4: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2CF8: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC2CFC: 48000064  b 0x82ec2d60
	pc = 0x82EC2D60; continue 'dispatch;
            }
            0x82EC2D00 => {
    //   block [0x82EC2D00..0x82EC2D18)
	// 82EC2D00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC2D04: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EC2D08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC2D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC2D10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC2D14: 419A004C  beq cr6, 0x82ec2d60
	if ctx.cr[6].eq {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	pc = 0x82EC2D18; continue 'dispatch;
            }
            0x82EC2D18 => {
    //   block [0x82EC2D18..0x82EC2D3C)
	// 82EC2D18: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2D1C: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2D20: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC2D28: C17C000C  lfs f11, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2D2C: 41980010  blt cr6, 0x82ec2d3c
	if ctx.cr[6].lt {
	pc = 0x82EC2D3C; continue 'dispatch;
	}
	// 82EC2D30: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2D34: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC2D38: 40990028  ble cr6, 0x82ec2d60
	if !ctx.cr[6].gt {
	pc = 0x82EC2D60; continue 'dispatch;
	}
	pc = 0x82EC2D3C; continue 'dispatch;
            }
            0x82EC2D3C => {
    //   block [0x82EC2D3C..0x82EC2D5C)
	// 82EC2D3C: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2D40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2D44: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC2D48: D19C0004  stfs f12, 4(r28)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC2D4C: D17C000C  stfs f11, 0xc(r28)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC2D50: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2D54: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2D58: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EC2D5C; continue 'dispatch;
            }
            0x82EC2D5C => {
    //   block [0x82EC2D5C..0x82EC2D60)
	// 82EC2D5C: 9B7C0058  stb r27, 0x58(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(88 as u32), ctx.r[27].u8 ) };
	pc = 0x82EC2D60; continue 'dispatch;
            }
            0x82EC2D60 => {
    //   block [0x82EC2D60..0x82EC2D68)
	// 82EC2D60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EC2D64: 4BDE66F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC2D68 size=708
    let mut pc: u32 = 0x82EC2D68;
    'dispatch: loop {
        match pc {
            0x82EC2D68 => {
    //   block [0x82EC2D68..0x82EC2E0C)
	// 82EC2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC2D6C: 4BDE6685  bl 0x82ca93f0
	ctx.lr = 0x82EC2D70;
	sub_82CA93D0(ctx, base);
	// 82EC2D70: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 82EC2D74: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82EC2D78: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82EC2D7C: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC2D80: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82EC2D84: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82EC2D88: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82EC2D8C: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2D90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2D94: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EC2D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2D9C: 4E800421  bctrl
	ctx.lr = 0x82EC2DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2DA0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EC2DA4: 41820274  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2DAC: 48010AA5  bl 0x82ed3850
	ctx.lr = 0x82EC2DB0;
	sub_82ED3850(ctx, base);
	// 82EC2DB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC2DB4: 41820264  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2DBC: 82EB0048  lwz r23, 0x48(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2DC0: 28170000  cmplwi r23, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DC4: 41820254  beq 0x82ec3018
	if ctx.cr[0].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DC8: 81570048  lwz r10, 0x48(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2DCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DD0: 419A0248  beq cr6, 0x82ec3018
	if ctx.cr[6].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2DD4: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EC2DD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2DDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC2DE0: 388AC5C8  addi r4, r10, -0x3a38
	ctx.r[4].s64 = ctx.r[10].s64 + -14904;
	// 82EC2DE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2DE8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC2DEC: C3CA0C18  lfs f30, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC2DF0: 4B325889  bl 0x821e8678
	ctx.lr = 0x82EC2DF4;
	sub_821E8678(ctx, base);
	// 82EC2DF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2DF8: 41820014  beq 0x82ec2e0c
	if ctx.cr[0].eq {
	pc = 0x82EC2E0C; continue 'dispatch;
	}
	// 82EC2DFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2E00: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2E04: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E08: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
            }
            0x82EC2E0C => {
    //   block [0x82EC2E0C..0x82EC2E2C)
	// 82EC2E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2E10: 48010851  bl 0x82ed3660
	ctx.lr = 0x82EC2E14;
	sub_82ED3660(ctx, base);
	// 82EC2E14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2E18: C00B0EE0  lfs f0, 0xee0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E1C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EC2E20: 409A000C  bne cr6, 0x82ec2e2c
	if !ctx.cr[6].eq {
	pc = 0x82EC2E2C; continue 'dispatch;
	}
	// 82EC2E24: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC2E28: C02B0024  lfs f1, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82EC2E2C; continue 'dispatch;
            }
            0x82EC2E2C => {
    //   block [0x82EC2E2C..0x82EC2EB8)
	// 82EC2E2C: 3BF80004  addi r31, r24, 4
	ctx.r[31].s64 = ctx.r[24].s64 + 4;
	// 82EC2E30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC2E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2E38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC2E3C: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 82EC2E40: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2E44: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82EC2E48: ED600828  fsubs f11, f0, f1
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E4C: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2E50: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E54: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC2E58: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EC2E5C: ED6D0828  fsubs f11, f13, f1
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E60: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2E64: EC0D082A  fadds f0, f13, f1
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E68: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC2E6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EC2E70: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EC2E74: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EC2E78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EC2E7C: ED6C0828  fsubs f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EC2E80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC2E84: EC0C082A  fadds f0, f12, f1
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EC2E88: D1610078  stfs f11, 0x78(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC2E8C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EC2E90: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EC2E94: 480125CD  bl 0x82ed5460
	ctx.lr = 0x82EC2E98;
	sub_82ED5460(ctx, base);
	// 82EC2E98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC2E9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC2EA0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC2EA4: C3AA0BEC  lfs f29, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EC2EA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC2EAC: 4182000C  beq 0x82ec2eb8
	if ctx.cr[0].eq {
	pc = 0x82EC2EB8; continue 'dispatch;
	}
	// 82EC2EB0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2EB4: 4800000C  b 0x82ec2ec0
	pc = 0x82EC2EC0; continue 'dispatch;
            }
            0x82EC2EB8 => {
    //   block [0x82EC2EB8..0x82EC2EC0)
	// 82EC2EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2EBC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC2EC0; continue 'dispatch;
            }
            0x82EC2EC0 => {
    //   block [0x82EC2EC0..0x82EC2EDC)
	// 82EC2EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC2EC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC2EC8: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2ECC: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2ED0: 419A0148  beq cr6, 0x82ec3018
	if ctx.cr[6].eq {
	pc = 0x82EC3018; continue 'dispatch;
	}
	// 82EC2ED4: 3B610090  addi r27, r1, 0x90
	ctx.r[27].s64 = ctx.r[1].s64 + 144;
	// 82EC2ED8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	pc = 0x82EC2EDC; continue 'dispatch;
            }
            0x82EC2EDC => {
    //   block [0x82EC2EDC..0x82EC2F80)
	// 82EC2EDC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2EE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC2EE4: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82EC2EE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC2EEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC2EF0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EC2EF4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82EC2EF8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EC2EFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82EC2F00: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC2F04: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC2F08: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F0C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2F10: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82EC2F14: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F18: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2F1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC2F20: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F24: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC2F28: 80770048  lwz r3, 0x48(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC2F2C: 4822BE25  bl 0x830eed50
	ctx.lr = 0x82EC2F30;
	sub_830EED50(ctx, base);
	// 82EC2F30: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2F34: C1410060  lfs f10, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC2F38: ED6A6828  fsubs f11, f10, f13
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2F3C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F40: C1210064  lfs f9, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC2F44: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC2F48: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2F4C: C1010068  lfs f8, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC2F50: ED886028  fsubs f12, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2F54: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC2F58: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EC2F5C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC2F60: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC2F64: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC2F68: 41990018  bgt cr6, 0x82ec2f80
	if ctx.cr[6].gt {
	pc = 0x82EC2F80; continue 'dispatch;
	}
	// 82EC2F6C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2F70: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F74: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2F78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2F7C: 48000040  b 0x82ec2fbc
	pc = 0x82EC2FBC; continue 'dispatch;
            }
            0x82EC2F80 => {
    //   block [0x82EC2F80..0x82EC2FBC)
	// 82EC2F80: ECE0F828  fsubs f7, f0, f31
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EC2F84: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2F88: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC2F8C: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC2F90: ED296028  fsubs f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC2F94: ED085828  fsubs f8, f8, f11
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC2F98: EC070024  fdivs f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC2F9C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA0: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA4: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC2FA8: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EC2FAC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC2FB0: ED8C482A  fadds f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EC2FB4: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC2FB8: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82EC2FBC; continue 'dispatch;
            }
            0x82EC2FBC => {
    //   block [0x82EC2FBC..0x82EC300C)
	// 82EC2FBC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC2FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC2FC4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EC2FC8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82EC2FCC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC2FD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC2FD4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82EC2FD8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC2FDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC2FE0: 4E800421  bctrl
	ctx.lr = 0x82EC2FE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC2FE4: FF01E800  fcmpu cr6, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82EC2FE8: 40980024  bge cr6, 0x82ec300c
	if !ctx.cr[6].lt {
	pc = 0x82EC300C; continue 'dispatch;
	}
	// 82EC2FEC: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC2FF0: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82EC2FF4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC2FF8: C1810068  lfs f12, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC2FFC: D0160004  stfs f0, 4(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC3000: D1B60008  stfs f13, 8(r22)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC3004: D196000C  stfs f12, 0xc(r22)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC3008: 9B960058  stb r28, 0x58(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(88 as u32), ctx.r[28].u8 ) };
            }
            0x82EC300C => {
    //   block [0x82EC300C..0x82EC3018)
	// 82EC300C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82EC3010: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82EC3014: 4082FEC8  bne 0x82ec2edc
	if !ctx.cr[0].eq {
	pc = 0x82EC2EDC; continue 'dispatch;
	}
	pc = 0x82EC3018; continue 'dispatch;
            }
            0x82EC3018 => {
    //   block [0x82EC3018..0x82EC302C)
	// 82EC3018: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 82EC301C: CBA1FF90  lfd f29, -0x70(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82EC3020: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82EC3024: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EC3028: 4BDE6418  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3030 size=88
    let mut pc: u32 = 0x82EC3030;
    'dispatch: loop {
        match pc {
            0x82EC3030 => {
    //   block [0x82EC3030..0x82EC306C)
	// 82EC3030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC303C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3048: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82EC304C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3050: 4B7538D9  bl 0x82616928
	ctx.lr = 0x82EC3054;
	sub_82616928(ctx, base);
	// 82EC3054: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3058: 41820014  beq 0x82ec306c
	if ctx.cr[0].eq {
	pc = 0x82EC306C; continue 'dispatch;
	}
	// 82EC305C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC3060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC3064: 4BFFFA35  bl 0x82ec2a98
	ctx.lr = 0x82EC3068;
	sub_82EC2A98(ctx, base);
	// 82EC3068: 48000008  b 0x82ec3070
	pc = 0x82EC3070; continue 'dispatch;
            }
            0x82EC306C => {
    //   block [0x82EC306C..0x82EC3070)
	// 82EC306C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC3070; continue 'dispatch;
            }
            0x82EC3070 => {
    //   block [0x82EC3070..0x82EC3088)
	// 82EC3070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC307C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3088 size=164
    let mut pc: u32 = 0x82EC3088;
    'dispatch: loop {
        match pc {
            0x82EC3088 => {
    //   block [0x82EC3088..0x82EC30E0)
	// 82EC3088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC308C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC309C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC30A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC30A4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82EC30A8: 3BC60004  addi r30, r6, 4
	ctx.r[30].s64 = ctx.r[6].s64 + 4;
	// 82EC30AC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82EC30B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC30B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC30B8: C00A0C4C  lfs f0, 0xc4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC30BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC30C0: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC30C4: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC30C8: 4B76C449  bl 0x8262f510
	ctx.lr = 0x82EC30CC;
	sub_8262F510(ctx, base);
	// 82EC30CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC30D0: 41820010  beq 0x82ec30e0
	if ctx.cr[0].eq {
	pc = 0x82EC30E0; continue 'dispatch;
	}
	// 82EC30D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC30D8: C02B0BEC  lfs f1, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC30DC: 48000038  b 0x82ec3114
	pc = 0x82EC3114; continue 'dispatch;
            }
            0x82EC30E0 => {
    //   block [0x82EC30E0..0x82EC3114)
	// 82EC30E0: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC30E4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC30E8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC30EC: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC30F0: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC30F4: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC30F8: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC30FC: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3100: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3104: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3108: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC310C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3110: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	pc = 0x82EC3114; continue 'dispatch;
            }
            0x82EC3114 => {
    //   block [0x82EC3114..0x82EC312C)
	// 82EC3114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC311C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3130 size=84
    let mut pc: u32 = 0x82EC3130;
    'dispatch: loop {
        match pc {
            0x82EC3130 => {
    //   block [0x82EC3130..0x82EC3178)
	// 82EC3130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3134: 4BDE62D9  bl 0x82ca940c
	ctx.lr = 0x82EC3138;
	sub_82CA93D0(ctx, base);
	// 82EC3138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC313C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC3140: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82EC3144: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC3148: 4B7537E1  bl 0x82616928
	ctx.lr = 0x82EC314C;
	sub_82616928(ctx, base);
	// 82EC314C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EC3150: 41820028  beq 0x82ec3178
	if ctx.cr[0].eq {
	pc = 0x82EC3178; continue 'dispatch;
	}
	// 82EC3154: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC3158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC315C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3160: 4BFF21D1  bl 0x82eb5330
	ctx.lr = 0x82EC3164;
	sub_82EB5330(ctx, base);
	// 82EC3164: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC316C: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82EC3170: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC3174: 48000008  b 0x82ec317c
	pc = 0x82EC317C; continue 'dispatch;
            }
            0x82EC3178 => {
    //   block [0x82EC3178..0x82EC317C)
	// 82EC3178: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC317C; continue 'dispatch;
            }
            0x82EC317C => {
    //   block [0x82EC317C..0x82EC3184)
	// 82EC317C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3180: 4BDE62DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3188 size=224
    let mut pc: u32 = 0x82EC3188;
    'dispatch: loop {
        match pc {
            0x82EC3188 => {
    //   block [0x82EC3188..0x82EC31D8)
	// 82EC3188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC318C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC319C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC31A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC31A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC31A8: 4BFACD51  bl 0x82e6fef8
	ctx.lr = 0x82EC31AC;
	sub_82E6FEF8(ctx, base);
	// 82EC31AC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EC31B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC31B4: 388BB38C  addi r4, r11, -0x4c74
	ctx.r[4].s64 = ctx.r[11].s64 + -19572;
	// 82EC31B8: 4BFC6529  bl 0x82e896e0
	ctx.lr = 0x82EC31BC;
	sub_82E896E0(ctx, base);
	// 82EC31BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC31C0: 41820038  beq 0x82ec31f8
	if ctx.cr[0].eq {
	pc = 0x82EC31F8; continue 'dispatch;
	}
	// 82EC31C4: 8943001C  lbz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC31C8: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC31CC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC31D0: 40820008  bne 0x82ec31d8
	if !ctx.cr[0].eq {
	pc = 0x82EC31D8; continue 'dispatch;
	}
	// 82EC31D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC31D8; continue 'dispatch;
            }
            0x82EC31D8 => {
    //   block [0x82EC31D8..0x82EC31F0)
	// 82EC31D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC31DC: 419A001C  beq cr6, 0x82ec31f8
	if ctx.cr[6].eq {
	pc = 0x82EC31F8; continue 'dispatch;
	}
	// 82EC31E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EC31E4: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EC31E8: 409A0008  bne cr6, 0x82ec31f0
	if !ctx.cr[6].eq {
	pc = 0x82EC31F0; continue 'dispatch;
	}
	// 82EC31EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC31F0; continue 'dispatch;
            }
            0x82EC31F0 => {
    //   block [0x82EC31F0..0x82EC31F8)
	// 82EC31F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC31F4: 48000008  b 0x82ec31fc
	pc = 0x82EC31FC; continue 'dispatch;
            }
            0x82EC31F8 => {
    //   block [0x82EC31F8..0x82EC31FC)
	// 82EC31F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EC31FC; continue 'dispatch;
            }
            0x82EC31FC => {
    //   block [0x82EC31FC..0x82EC3228)
	// 82EC31FC: C19E0004  lfs f12, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC3204: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3208: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC320C: 419A0044  beq cr6, 0x82ec3250
	if ctx.cr[6].eq {
	pc = 0x82EC3250; continue 'dispatch;
	}
	// 82EC3210: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3214: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC3218: 41980010  blt cr6, 0x82ec3228
	if ctx.cr[6].lt {
	pc = 0x82EC3228; continue 'dispatch;
	}
	// 82EC321C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3220: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EC3224: 4099002C  ble cr6, 0x82ec3250
	if !ctx.cr[6].gt {
	pc = 0x82EC3250; continue 'dispatch;
	}
	pc = 0x82EC3228; continue 'dispatch;
            }
            0x82EC3228 => {
    //   block [0x82EC3228..0x82EC3250)
	// 82EC3228: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC322C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3230: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3234: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC3238: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC323C: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC3244: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3248: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC324C: 997E0058  stb r11, 0x58(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	pc = 0x82EC3250; continue 'dispatch;
            }
            0x82EC3250 => {
    //   block [0x82EC3250..0x82EC3268)
	// 82EC3250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC325C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC3260: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3268 size=592
    let mut pc: u32 = 0x82EC3268;
    'dispatch: loop {
        match pc {
            0x82EC3268 => {
    //   block [0x82EC3268..0x82EC3334)
	// 82EC3268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC326C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC3274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3278: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82EC327C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82EC3280: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3284: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC328C: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EC3290: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC3294: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3298: 394BB1E0  addi r10, r11, -0x4e20
	ctx.r[10].s64 = ctx.r[11].s64 + -20000;
	// 82EC329C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC32A0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC32A4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC32A8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC32AC: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC32B0: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC32B4: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EC32B8: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82EC32BC: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EC32C0: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC32C4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EC32C8: D3FF0024  stfs f31, 0x24(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EC32CC: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EC32D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC32D4: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EC32D8: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EC32DC: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EC32E0: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EC32E4: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EC32E8: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EC32EC: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EC32F0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EC32F4: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC32F8: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC32FC: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3300: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3304: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3308: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC330C: D3FF00C8  stfs f31, 0xc8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC3310: D3FF00CC  stfs f31, 0xcc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC3314: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC3318: D3FF00D4  stfs f31, 0xd4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC331C: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3320: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC3324: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3328: 4182000C  beq 0x82ec3334
	if ctx.cr[0].eq {
	pc = 0x82EC3334; continue 'dispatch;
	}
	// 82EC332C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3330: 48000008  b 0x82ec3338
	pc = 0x82EC3338; continue 'dispatch;
            }
            0x82EC3334 => {
    //   block [0x82EC3334..0x82EC3338)
	// 82EC3334: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	pc = 0x82EC3338; continue 'dispatch;
            }
            0x82EC3338 => {
    //   block [0x82EC3338..0x82EC33E8)
	// 82EC3338: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC333C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82EC3340: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC3344: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82EC3348: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC334C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3350: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3354: D15F00D8  stfs f10, 0xd8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC3358: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC335C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3364: D1BF00DC  stfs f13, 0xdc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC3368: D1BF00EC  stfs f13, 0xec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC336C: C18B0BF8  lfs f12, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3374: D19F00E0  stfs f12, 0xe0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EC3378: C16B0EE0  lfs f11, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC337C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3380: D17F00E4  stfs f11, 0xe4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC3384: C14B0A7C  lfs f10, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3388: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC338C: D15F00F0  stfs f10, 0xf0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EC3390: C18BBE10  lfs f12, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3394: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3398: D19F00F4  stfs f12, 0xf4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EC339C: D19F00FC  stfs f12, 0xfc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EC33A0: C00B0B64  lfs f0, 0xb64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33A4: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EC33A8: 4BDE6609  bl 0x82ca99b0
	ctx.lr = 0x82EC33AC;
	sub_82CA99B0(ctx, base);
	// 82EC33AC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC33B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33B4: 418200AC  beq 0x82ec3460
	if ctx.cr[0].eq {
	pc = 0x82EC3460; continue 'dispatch;
	}
	// 82EC33B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC33BC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC33C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC33C4: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC33C8: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC33CC: 4B3252AD  bl 0x821e8678
	ctx.lr = 0x82EC33D0;
	sub_821E8678(ctx, base);
	// 82EC33D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33D4: 41820014  beq 0x82ec33e8
	if ctx.cr[0].eq {
	pc = 0x82EC33E8; continue 'dispatch;
	}
	// 82EC33D8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33DC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EC33E0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EC33E4: 409A0020  bne cr6, 0x82ec3404
	if !ctx.cr[6].eq {
	pc = 0x82EC3404; continue 'dispatch;
	}
	pc = 0x82EC33E8; continue 'dispatch;
            }
            0x82EC33E8 => {
    //   block [0x82EC33E8..0x82EC33FC)
	// 82EC33E8: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC33EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC33F0: 4182000C  beq 0x82ec33fc
	if ctx.cr[0].eq {
	pc = 0x82EC33FC; continue 'dispatch;
	}
	// 82EC33F4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC33F8: 48000008  b 0x82ec3400
	pc = 0x82EC3400; continue 'dispatch;
            }
            0x82EC33FC => {
    //   block [0x82EC33FC..0x82EC3400)
	// 82EC33FC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x82EC3400; continue 'dispatch;
            }
            0x82EC3400 => {
    //   block [0x82EC3400..0x82EC3404)
	// 82EC3400: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82EC3404; continue 'dispatch;
            }
            0x82EC3404 => {
    //   block [0x82EC3404..0x82EC3430)
	// 82EC3404: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3408: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC340C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC3410: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EC3414: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3418: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC341C: 4B32525D  bl 0x821e8678
	ctx.lr = 0x82EC3420;
	sub_821E8678(ctx, base);
	// 82EC3420: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3424: 4182000C  beq 0x82ec3430
	if ctx.cr[0].eq {
	pc = 0x82EC3430; continue 'dispatch;
	}
	// 82EC3428: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC342C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82EC3430; continue 'dispatch;
            }
            0x82EC3430 => {
    //   block [0x82EC3430..0x82EC3460)
	// 82EC3430: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3434: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3438: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC343C: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 82EC3440: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3444: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3448: 4B325231  bl 0x821e8678
	ctx.lr = 0x82EC344C;
	sub_821E8678(ctx, base);
	// 82EC344C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3450: 4182002C  beq 0x82ec347c
	if ctx.cr[0].eq {
	pc = 0x82EC347C; continue 'dispatch;
	}
	// 82EC3454: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3458: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC345C: 48000020  b 0x82ec347c
	pc = 0x82EC347C; continue 'dispatch;
            }
            0x82EC3460 => {
    //   block [0x82EC3460..0x82EC3474)
	// 82EC3460: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3464: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3468: 4182000C  beq 0x82ec3474
	if ctx.cr[0].eq {
	pc = 0x82EC3474; continue 'dispatch;
	}
	// 82EC346C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3470: 48000008  b 0x82ec3478
	pc = 0x82EC3478; continue 'dispatch;
            }
            0x82EC3474 => {
    //   block [0x82EC3474..0x82EC3478)
	// 82EC3474: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x82EC3478; continue 'dispatch;
            }
            0x82EC3478 => {
    //   block [0x82EC3478..0x82EC347C)
	// 82EC3478: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82EC347C; continue 'dispatch;
            }
            0x82EC347C => {
    //   block [0x82EC347C..0x82EC34B8)
	// 82EC347C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3480: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3484: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EC3488: 4B3A4799  bl 0x82267c20
	ctx.lr = 0x82EC348C;
	sub_82267C20(ctx, base);
	// 82EC348C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC3490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3494: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EC3498: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC349C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC34A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC34A4: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC34A8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EC34AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC34B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC34B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC34B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC34B8 size=12
    let mut pc: u32 = 0x82EC34B8;
    'dispatch: loop {
        match pc {
            0x82EC34B8 => {
    //   block [0x82EC34B8..0x82EC34C4)
	// 82EC34B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC34BC: 386BE16C  addi r3, r11, -0x1e94
	ctx.r[3].s64 = ctx.r[11].s64 + -7828;
	// 82EC34C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC34C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC34C8 size=8
    let mut pc: u32 = 0x82EC34C8;
    'dispatch: loop {
        match pc {
            0x82EC34C8 => {
    //   block [0x82EC34C8..0x82EC34D0)
	// 82EC34C8: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82EC34CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC34D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC34D0 size=440
    let mut pc: u32 = 0x82EC34D0;
    'dispatch: loop {
        match pc {
            0x82EC34D0 => {
    //   block [0x82EC34D0..0x82EC3520)
	// 82EC34D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC34D4: 4BDE5F39  bl 0x82ca940c
	ctx.lr = 0x82EC34D8;
	sub_82CA93D0(ctx, base);
	// 82EC34D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC34DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC34E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC34E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC34E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC34EC: 3BABAE40  addi r29, r11, -0x51c0
	ctx.r[29].s64 = ctx.r[11].s64 + -20928;
	// 82EC34F0: 482F8B71  bl 0x831bc060
	ctx.lr = 0x82EC34F4;
	sub_831BC060(ctx, base);
	// 82EC34F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC34F8: 4BDE9659  bl 0x82cacb50
	ctx.lr = 0x82EC34FC;
	sub_82CACB50(ctx, base);
	// 82EC34FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3504: 4082001C  bne 0x82ec3520
	if !ctx.cr[0].eq {
	pc = 0x82EC3520; continue 'dispatch;
	}
	// 82EC3508: 4BA4A801  bl 0x8290dd08
	ctx.lr = 0x82EC350C;
	sub_8290DD08(ctx, base);
	// 82EC350C: 4BDE86A5  bl 0x82cabbb0
	ctx.lr = 0x82EC3510;
	sub_82CABBB0(ctx, base);
	// 82EC3510: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3514: D01E00E0  stfs f0, 0xe0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EC3518: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC351C: 48000164  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC3520 => {
    //   block [0x82EC3520..0x82EC3558)
	// 82EC3520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3524: 3BABAE30  addi r29, r11, -0x51d0
	ctx.r[29].s64 = ctx.r[11].s64 + -20944;
	// 82EC3528: 482F8B39  bl 0x831bc060
	ctx.lr = 0x82EC352C;
	sub_831BC060(ctx, base);
	// 82EC352C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3530: 4BDE9621  bl 0x82cacb50
	ctx.lr = 0x82EC3534;
	sub_82CACB50(ctx, base);
	// 82EC3534: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC353C: 4082001C  bne 0x82ec3558
	if !ctx.cr[0].eq {
	pc = 0x82EC3558; continue 'dispatch;
	}
	// 82EC3540: 4BA4A7C9  bl 0x8290dd08
	ctx.lr = 0x82EC3544;
	sub_8290DD08(ctx, base);
	// 82EC3544: 4BDE866D  bl 0x82cabbb0
	ctx.lr = 0x82EC3548;
	sub_82CABBB0(ctx, base);
	// 82EC3548: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC354C: D01E00DC  stfs f0, 0xdc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EC3550: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3554: 4800012C  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC3558 => {
    //   block [0x82EC3558..0x82EC3590)
	// 82EC3558: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC355C: 3BABAE20  addi r29, r11, -0x51e0
	ctx.r[29].s64 = ctx.r[11].s64 + -20960;
	// 82EC3560: 482F8B01  bl 0x831bc060
	ctx.lr = 0x82EC3564;
	sub_831BC060(ctx, base);
	// 82EC3564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3568: 4BDE95E9  bl 0x82cacb50
	ctx.lr = 0x82EC356C;
	sub_82CACB50(ctx, base);
	// 82EC356C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3574: 4082001C  bne 0x82ec3590
	if !ctx.cr[0].eq {
	pc = 0x82EC3590; continue 'dispatch;
	}
	// 82EC3578: 4BA4A791  bl 0x8290dd08
	ctx.lr = 0x82EC357C;
	sub_8290DD08(ctx, base);
	// 82EC357C: 4BDE8635  bl 0x82cabbb0
	ctx.lr = 0x82EC3580;
	sub_82CABBB0(ctx, base);
	// 82EC3580: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3584: D01E00E4  stfs f0, 0xe4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EC3588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC358C: 480000F4  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC3590 => {
    //   block [0x82EC3590..0x82EC35C8)
	// 82EC3590: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3594: 3BABAE10  addi r29, r11, -0x51f0
	ctx.r[29].s64 = ctx.r[11].s64 + -20976;
	// 82EC3598: 482F8AC9  bl 0x831bc060
	ctx.lr = 0x82EC359C;
	sub_831BC060(ctx, base);
	// 82EC359C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC35A0: 4BDE95B1  bl 0x82cacb50
	ctx.lr = 0x82EC35A4;
	sub_82CACB50(ctx, base);
	// 82EC35A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC35A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC35AC: 4082001C  bne 0x82ec35c8
	if !ctx.cr[0].eq {
	pc = 0x82EC35C8; continue 'dispatch;
	}
	// 82EC35B0: 4BA4A759  bl 0x8290dd08
	ctx.lr = 0x82EC35B4;
	sub_8290DD08(ctx, base);
	// 82EC35B4: 4BDE85FD  bl 0x82cabbb0
	ctx.lr = 0x82EC35B8;
	sub_82CABBB0(ctx, base);
	// 82EC35B8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC35BC: D01E00E8  stfs f0, 0xe8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EC35C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC35C4: 480000BC  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC35C8 => {
    //   block [0x82EC35C8..0x82EC3600)
	// 82EC35C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC35CC: 3BABAE00  addi r29, r11, -0x5200
	ctx.r[29].s64 = ctx.r[11].s64 + -20992;
	// 82EC35D0: 482F8A91  bl 0x831bc060
	ctx.lr = 0x82EC35D4;
	sub_831BC060(ctx, base);
	// 82EC35D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC35D8: 4BDE9579  bl 0x82cacb50
	ctx.lr = 0x82EC35DC;
	sub_82CACB50(ctx, base);
	// 82EC35DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC35E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC35E4: 4082001C  bne 0x82ec3600
	if !ctx.cr[0].eq {
	pc = 0x82EC3600; continue 'dispatch;
	}
	// 82EC35E8: 4BA4A721  bl 0x8290dd08
	ctx.lr = 0x82EC35EC;
	sub_8290DD08(ctx, base);
	// 82EC35EC: 4BDE85C5  bl 0x82cabbb0
	ctx.lr = 0x82EC35F0;
	sub_82CABBB0(ctx, base);
	// 82EC35F0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC35F4: D01E00EC  stfs f0, 0xec(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EC35F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC35FC: 48000084  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC3600 => {
    //   block [0x82EC3600..0x82EC3638)
	// 82EC3600: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC3604: 3BABADEC  addi r29, r11, -0x5214
	ctx.r[29].s64 = ctx.r[11].s64 + -21012;
	// 82EC3608: 482F8A59  bl 0x831bc060
	ctx.lr = 0x82EC360C;
	sub_831BC060(ctx, base);
	// 82EC360C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3610: 4BDE9541  bl 0x82cacb50
	ctx.lr = 0x82EC3614;
	sub_82CACB50(ctx, base);
	// 82EC3614: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC361C: 4082001C  bne 0x82ec3638
	if !ctx.cr[0].eq {
	pc = 0x82EC3638; continue 'dispatch;
	}
	// 82EC3620: 4BA4A6E9  bl 0x8290dd08
	ctx.lr = 0x82EC3624;
	sub_8290DD08(ctx, base);
	// 82EC3624: 4BDE858D  bl 0x82cabbb0
	ctx.lr = 0x82EC3628;
	sub_82CABBB0(ctx, base);
	// 82EC3628: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC362C: D01E00F0  stfs f0, 0xf0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EC3630: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3634: 4800004C  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC3638 => {
    //   block [0x82EC3638..0x82EC367C)
	// 82EC3638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC363C: 3BABADD4  addi r29, r11, -0x522c
	ctx.r[29].s64 = ctx.r[11].s64 + -21036;
	// 82EC3640: 482F8A21  bl 0x831bc060
	ctx.lr = 0x82EC3644;
	sub_831BC060(ctx, base);
	// 82EC3644: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC3648: 4BDE9509  bl 0x82cacb50
	ctx.lr = 0x82EC364C;
	sub_82CACB50(ctx, base);
	// 82EC364C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3650: 4082002C  bne 0x82ec367c
	if !ctx.cr[0].eq {
	pc = 0x82EC367C; continue 'dispatch;
	}
	// 82EC3654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3658: 4BA4A6B1  bl 0x8290dd08
	ctx.lr = 0x82EC365C;
	sub_8290DD08(ctx, base);
	// 82EC365C: 4BDE8555  bl 0x82cabbb0
	ctx.lr = 0x82EC3660;
	sub_82CABBB0(ctx, base);
	// 82EC3660: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EC3664: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3668: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC366C: D01E00F4  stfs f0, 0xf4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EC3670: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3674: D01E00D8  stfs f0, 0xd8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EC3678: 48000008  b 0x82ec3680
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC367C => {
    //   block [0x82EC367C..0x82EC3680)
	// 82EC367C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC3680; continue 'dispatch;
            }
            0x82EC3680 => {
    //   block [0x82EC3680..0x82EC3688)
	// 82EC3680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC3684: 4BDE5DD8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3688 size=124
    let mut pc: u32 = 0x82EC3688;
    'dispatch: loop {
        match pc {
            0x82EC3688 => {
    //   block [0x82EC3688..0x82EC3704)
	// 82EC3688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC368C: C0E60000  lfs f7, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3690: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3694: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3698: ECCA02B2  fmuls f6, f10, f10
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC369C: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC36A0: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC36A4: C10B0A98  lfs f8, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC36A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC36AC: ED070232  fmuls f8, f7, f8
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EC36B0: C1250008  lfs f9, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC36B4: ECED0372  fmuls f7, f13, f13
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC36B8: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC36BC: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC36C0: ED40383A  fmadds f10, f0, f0, f7
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EC36C4: ECEB32FA  fmadds f7, f11, f11, f6
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64);
	// 82EC36C8: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC36CC: EDAC533A  fmadds f13, f12, f12, f10
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EC36D0: ED693A7A  fmadds f11, f9, f9, f7
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EC36D4: EC09033A  fmadds f0, f9, f12, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC36D8: ED485A3C  fnmsubs f10, f8, f8, f11
	ctx.f[10].f64 = -(((ctx.f[8].f64 * ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC36DC: C16B0C4C  lfs f11, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC36E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC36E4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC36E8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC36EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EC36F0: 409A0024  bne cr6, 0x82ec3714
	if !ctx.cr[6].eq {
		sub_82EC3704(ctx, base);
		return;
	}
	// 82EC36F4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EC36F8: 409A000C  bne cr6, 0x82ec3704
	if !ctx.cr[6].eq {
		sub_82EC3704(ctx, base);
		return;
	}
	// 82EC36FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3704(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3704 size=88
    let mut pc: u32 = 0x82EC3704;
    'dispatch: loop {
        match pc {
            0x82EC3704 => {
    //   block [0x82EC3704..0x82EC3750)
	// 82EC3704: EC0A0024  fdivs f0, f10, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3708: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC370C: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3710: 48000040  b 0x82ec3750
	pc = 0x82EC3750; continue 'dispatch;
	// 82EC3714: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC371C: C14B0A4C  lfs f10, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3720: ED4902B2  fmuls f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3724: ED405038  fmsubs f10, f0, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3728: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 82EC372C: 4198FFD0  blt cr6, 0x82ec36fc
	if ctx.cr[6].lt {
		sub_82EC3688(ctx, base);
		return;
	}
	// 82EC3730: ED80502C  fsqrts f12, f10
	ctx.f[12].f64 = ((ctx.f[10].f64).sqrt() as f32) as f64;
	// 82EC3734: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3738: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EC373C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3740: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3744: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EC3748: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC374C: EC0C6824  fdivs f0, f12, f13
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
            }
            0x82EC3750 => {
    //   block [0x82EC3750..0x82EC375C)
	// 82EC3750: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3754: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC3760 size=168
    let mut pc: u32 = 0x82EC3760;
    'dispatch: loop {
        match pc {
            0x82EC3760 => {
    //   block [0x82EC3760..0x82EC37C4)
	// 82EC3760: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3764: C14300C8  lfs f10, 0xc8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3768: C12300C4  lfs f9, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC376C: C00300F8  lfs f0, 0xf8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3770: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3774: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3778: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC377C: C14300CC  lfs f10, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3780: C16B004C  lfs f11, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3784: EDAC6ABA  fmadds f13, f12, f10, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC3788: EDAB6A7A  fmadds f13, f11, f9, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC378C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC3790: 40990034  ble cr6, 0x82ec37c4
	if !ctx.cr[6].gt {
	pc = 0x82EC37C4; continue 'dispatch;
	}
	// 82EC3794: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3798: C1A300FC  lfs f13, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC379C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC37A0: 40980054  bge cr6, 0x82ec37f4
	if !ctx.cr[6].lt {
	pc = 0x82EC37F4; continue 'dispatch;
	}
	// 82EC37A4: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EC37A8: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC37AC: C00300C8  lfs f0, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37B0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC37B4: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37B8: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC37BC: C0030020  lfs f0, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37C0: 48000040  b 0x82ec3800
	pc = 0x82EC3800; continue 'dispatch;
            }
            0x82EC37C4 => {
    //   block [0x82EC37C4..0x82EC37F4)
	// 82EC37C4: C00300C4  lfs f0, 0xc4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37C8: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EC37CC: C00300C8  lfs f0, 0xc8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37D0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EC37D4: C00300CC  lfs f0, 0xcc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37D8: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EC37DC: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37E0: C1A300FC  lfs f13, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC37E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC37E8: 4098000C  bge cr6, 0x82ec37f4
	if !ctx.cr[6].lt {
	pc = 0x82EC37F4; continue 'dispatch;
	}
	// 82EC37EC: C00300F0  lfs f0, 0xf0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC37F0: 48000008  b 0x82ec37f8
	pc = 0x82EC37F8; continue 'dispatch;
            }
            0x82EC37F4 => {
    //   block [0x82EC37F4..0x82EC37F8)
	// 82EC37F4: C00300EC  lfs f0, 0xec(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC37F8; continue 'dispatch;
            }
            0x82EC37F8 => {
    //   block [0x82EC37F8..0x82EC3800)
	// 82EC37F8: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC37FC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82EC3800; continue 'dispatch;
            }
            0x82EC3800 => {
    //   block [0x82EC3800..0x82EC3808)
	// 82EC3800: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EC3804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC3808 size=72
    let mut pc: u32 = 0x82EC3808;
    'dispatch: loop {
        match pc {
            0x82EC3808 => {
    //   block [0x82EC3808..0x82EC3838)
	// 82EC3808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC380C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC381C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82EC3820: 4B753109  bl 0x82616928
	ctx.lr = 0x82EC3824;
	sub_82616928(ctx, base);
	// 82EC3824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3828: 41820010  beq 0x82ec3838
	if ctx.cr[0].eq {
	pc = 0x82EC3838; continue 'dispatch;
	}
	// 82EC382C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC3830: 4BFFFA39  bl 0x82ec3268
	ctx.lr = 0x82EC3834;
	sub_82EC3268(ctx, base);
	// 82EC3834: 48000008  b 0x82ec383c
	pc = 0x82EC383C; continue 'dispatch;
            }
            0x82EC3838 => {
    //   block [0x82EC3838..0x82EC383C)
	// 82EC3838: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EC383C; continue 'dispatch;
            }
            0x82EC383C => {
    //   block [0x82EC383C..0x82EC3850)
	// 82EC383C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC3840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC384C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3850 size=712
    let mut pc: u32 = 0x82EC3850;
    'dispatch: loop {
        match pc {
            0x82EC3850 => {
    //   block [0x82EC3850..0x82EC3890)
	// 82EC3850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3854: 4BDE5BB9  bl 0x82ca940c
	ctx.lr = 0x82EC3858;
	sub_82CA93D0(ctx, base);
	// 82EC3858: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82EC385C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82EC3860: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3864: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC386C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3870: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3874: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC3878: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC387C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC3880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3884: 4182000C  beq 0x82ec3890
	if ctx.cr[0].eq {
	pc = 0x82EC3890; continue 'dispatch;
	}
	// 82EC3888: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EC388C: 48000008  b 0x82ec3894
	pc = 0x82EC3894; continue 'dispatch;
            }
            0x82EC3890 => {
    //   block [0x82EC3890..0x82EC3894)
	// 82EC3890: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x82EC3894; continue 'dispatch;
            }
            0x82EC3894 => {
    //   block [0x82EC3894..0x82EC38B4)
	// 82EC3894: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3898: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC389C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EC38A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC38A4: 4B324DD5  bl 0x821e8678
	ctx.lr = 0x82EC38A8;
	sub_821E8678(ctx, base);
	// 82EC38A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC38AC: 41820008  beq 0x82ec38b4
	if ctx.cr[0].eq {
	pc = 0x82EC38B4; continue 'dispatch;
	}
	// 82EC38B0: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82EC38B4; continue 'dispatch;
            }
            0x82EC38B4 => {
    //   block [0x82EC38B4..0x82EC3910)
	// 82EC38B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC38B8: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC38BC: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC38C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC38C4: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC38C8: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC38CC: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC38D0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC38D4: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC38D8: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC38DC: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC38E0: C14A0C18  lfs f10, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC38E4: EC0D0372  fmuls f0, f13, f13
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC38E8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC38EC: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC38F0: ED20002C  fsqrts f9, f0
	ctx.f[9].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC38F4: FF095000  fcmpu cr6, f9, f10
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[10].f64);
	// 82EC38F8: 40990018  ble cr6, 0x82ec3910
	if !ctx.cr[6].gt {
	pc = 0x82EC3910; continue 'dispatch;
	}
	// 82EC38FC: EC1F4824  fdivs f0, f31, f9
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EC3900: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3904: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3908: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC390C: 48000010  b 0x82ec391c
	pc = 0x82EC391C; continue 'dispatch;
            }
            0x82EC3910 => {
    //   block [0x82EC3910..0x82EC391C)
	// 82EC3910: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EC3914: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EC3918: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x82EC391C; continue 'dispatch;
            }
            0x82EC391C => {
    //   block [0x82EC391C..0x82EC3948)
	// 82EC391C: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3920: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3924: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3928: C10B004C  lfs f8, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC392C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EC3930: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3934: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC3938: 41990010  bgt cr6, 0x82ec3948
	if ctx.cr[6].gt {
	pc = 0x82EC3948; continue 'dispatch;
	}
	// 82EC393C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3940: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82EC3944: 409801C4  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	pc = 0x82EC3948; continue 'dispatch;
            }
            0x82EC3948 => {
    //   block [0x82EC3948..0x82EC3A0C)
	// 82EC3948: C00B0058  lfs f0, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC394C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC3950: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3954: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC3958: C12B004C  lfs f9, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC395C: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3960: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3964: C10B0050  lfs f8, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC3968: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC396C: C15E0050  lfs f10, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3970: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3974: C0FE0054  lfs f7, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3978: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC397C: C06B0054  lfs f3, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EC3980: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3984: EC030032  fmuls f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3988: C0CB0034  lfs f6, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC398C: C0FE0034  lfs f7, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3990: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC3994: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC3998: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC399C: ECC53028  fsubs f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC39A0: C18A0A40  lfs f12, 0xa40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC39A4: C05E003C  lfs f2, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EC39A8: FC806090  fmr f4, f12
	ctx.f[4].f64 = ctx.f[12].f64;
	// 82EC39AC: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC39B0: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EC39B4: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EC39B8: ECA22828  fsubs f5, f2, f5
	ctx.f[5].f64 = (((ctx.f[2].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EC39BC: ED6A4028  fsubs f11, f10, f8
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC39C0: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC39C4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC39C8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC39CC: 419A0040  beq cr6, 0x82ec3a0c
	if ctx.cr[6].eq {
	pc = 0x82EC3A0C; continue 'dispatch;
	}
	// 82EC39D0: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC39D4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC39D8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC39DC: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC39E0: C10B003C  lfs f8, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EC39E4: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC39E8: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC39EC: C12B0034  lfs f9, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC39F0: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC39F4: C14B0058  lfs f10, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC39F8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC39FC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3A00: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3A04: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3A08: EC805024  fdivs f4, f0, f10
	ctx.f[4].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	pc = 0x82EC3A0C; continue 'dispatch;
            }
            0x82EC3A0C => {
    //   block [0x82EC3A0C..0x82EC3A68)
	// 82EC3A0C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3A14: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EC3A18: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82EC3A1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC3A20: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3A24: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EC3A28: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3A2C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EC3A30: D0E10070  stfs f7, 0x70(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EC3A34: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EC3A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3A40: D0C10074  stfs f6, 0x74(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EC3A44: D0A10078  stfs f5, 0x78(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EC3A48: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3A4C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3A50: 4BFFFC39  bl 0x82ec3688
	ctx.lr = 0x82EC3A54;
	sub_82EC3688(ctx, base);
	// 82EC3A54: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3A58: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A60: 41980008  blt cr6, 0x82ec3a68
	if ctx.cr[6].lt {
	pc = 0x82EC3A68; continue 'dispatch;
	}
	// 82EC3A64: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EC3A68; continue 'dispatch;
            }
            0x82EC3A68 => {
    //   block [0x82EC3A68..0x82EC3AB4)
	// 82EC3A68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC3A6C: 4182009C  beq 0x82ec3b08
	if ctx.cr[0].eq {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A70: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A74: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A78: 40980090  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A7C: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 82EC3A80: 40980088  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A84: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3A88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3A8C: 4099007C  ble cr6, 0x82ec3b08
	if !ctx.cr[6].gt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3A90: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3A94: 2F0B0019  cmpwi cr6, r11, 0x19
	ctx.cr[6].compare_i32(ctx.r[11].s32, 25, &mut ctx.xer);
	// 82EC3A98: 4098001C  bge cr6, 0x82ec3ab4
	if !ctx.cr[6].lt {
	pc = 0x82EC3AB4; continue 'dispatch;
	}
	// 82EC3A9C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82EC3AA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EC3AA4: 7FCBF92E  stwx r30, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[30].u32) };
	// 82EC3AA8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3AAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC3AB0: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC3AB4; continue 'dispatch;
            }
            0x82EC3AB4 => {
    //   block [0x82EC3AB4..0x82EC3B08)
	// 82EC3AB4: C1BF0058  lfs f13, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3AB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC3ABC: 4098004C  bge cr6, 0x82ec3b08
	if !ctx.cr[6].lt {
	pc = 0x82EC3B08; continue 'dispatch;
	}
	// 82EC3AC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC3AC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3AC8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3ACC: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82EC3AD0: 995F0044  stb r10, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82EC3AD4: C18B004C  lfs f12, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3AD8: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3ADC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AE0: C14B0054  lfs f10, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3AE4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AE8: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3AEC: C1AB0058  lfs f13, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3AF0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3AF4: D19F004C  stfs f12, 0x4c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EC3AF8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3AFC: D17F0050  stfs f11, 0x50(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3B00: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3B04: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82EC3B08; continue 'dispatch;
            }
            0x82EC3B08 => {
    //   block [0x82EC3B08..0x82EC3B18)
	// 82EC3B08: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EC3B0C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EC3B10: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EC3B14: 4BDE5948  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3B18 size=848
    let mut pc: u32 = 0x82EC3B18;
    'dispatch: loop {
        match pc {
            0x82EC3B18 => {
    //   block [0x82EC3B18..0x82EC3B50)
	// 82EC3B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC3B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC3B24: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EC3B28: 4BDEA19D  bl 0x82cadcc4
	ctx.lr = 0x82EC3B2C;
	sub_82CADCA0(ctx, base);
	// 82EC3B2C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3B34: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3B38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3B3C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3B40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3B44: 4082000C  bne 0x82ec3b50
	if !ctx.cr[0].eq {
	pc = 0x82EC3B50; continue 'dispatch;
	}
	// 82EC3B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC3B4C: 48000300  b 0x82ec3e4c
	pc = 0x82EC3E4C; continue 'dispatch;
            }
            0x82EC3B50 => {
    //   block [0x82EC3B50..0x82EC3B88)
	// 82EC3B50: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC3B54: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EC3B58: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC3B5C: C3690C18  lfs f27, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EC3B60: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EC3B64: FDA0D890  fmr f13, f27
	ctx.f[13].f64 = ctx.f[27].f64;
	// 82EC3B68: FD80D890  fmr f12, f27
	ctx.f[12].f64 = ctx.f[27].f64;
	// 82EC3B6C: FD60D890  fmr f11, f27
	ctx.f[11].f64 = ctx.f[27].f64;
	// 82EC3B70: C3490C14  lfs f26, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EC3B74: 4081006C  ble 0x82ec3be0
	if !ctx.cr[0].gt {
	pc = 0x82EC3BE0; continue 'dispatch;
	}
	// 82EC3B78: C0EB0034  lfs f7, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EC3B7C: 393F0060  addi r9, r31, 0x60
	ctx.r[9].s64 = ctx.r[31].s64 + 96;
	// 82EC3B80: C0CB0038  lfs f6, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EC3B84: C0AB003C  lfs f5, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	pc = 0x82EC3B88; continue 'dispatch;
            }
            0x82EC3B88 => {
    //   block [0x82EC3B88..0x82EC3BD4)
	// 82EC3B88: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC3B8C: C128003C  lfs f9, 0x3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EC3B90: ED254828  fsubs f9, f5, f9
	ctx.f[9].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3B94: C0080034  lfs f0, 0x34(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3B98: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3B9C: C0080038  lfs f0, 0x38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3BA0: ED060028  fsubs f8, f6, f0
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3BA4: EC090272  fmuls f0, f9, f9
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EC3BA8: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BAC: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BB0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3BB4: 40990020  ble cr6, 0x82ec3bd4
	if !ctx.cr[6].gt {
	pc = 0x82EC3BD4; continue 'dispatch;
	}
	// 82EC3BB8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3BBC: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3BC0: ED000232  fmuls f8, f0, f8
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EC3BC4: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EC3BC8: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC3BCC: ED88602A  fadds f12, f8, f12
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3BD0: ED60582A  fadds f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x82EC3BD4; continue 'dispatch;
            }
            0x82EC3BD4 => {
    //   block [0x82EC3BD4..0x82EC3BE0)
	// 82EC3BD4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC3BD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC3BDC: 4082FFAC  bne 0x82ec3b88
	if !ctx.cr[0].eq {
	pc = 0x82EC3B88; continue 'dispatch;
	}
	pc = 0x82EC3BE0; continue 'dispatch;
            }
            0x82EC3BE0 => {
    //   block [0x82EC3BE0..0x82EC3C0C)
	// 82EC3BE0: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3BE4: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BE8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3BEC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3BF0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3BF4: 40990018  ble cr6, 0x82ec3c0c
	if !ctx.cr[6].gt {
	pc = 0x82EC3C0C; continue 'dispatch;
	}
	// 82EC3BF8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3BFC: EF200372  fmuls f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3C00: EEE00332  fmuls f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C04: EF0002F2  fmuls f24, f0, f11
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3C08: 48000010  b 0x82ec3c18
	pc = 0x82EC3C18; continue 'dispatch;
            }
            0x82EC3C0C => {
    //   block [0x82EC3C0C..0x82EC3C18)
	// 82EC3C0C: FF20D890  fmr f25, f27
	ctx.f[25].f64 = ctx.f[27].f64;
	// 82EC3C10: FEE0D890  fmr f23, f27
	ctx.f[23].f64 = ctx.f[27].f64;
	// 82EC3C14: FF00D890  fmr f24, f27
	ctx.f[24].f64 = ctx.f[27].f64;
	pc = 0x82EC3C18; continue 'dispatch;
            }
            0x82EC3C18 => {
    //   block [0x82EC3C18..0x82EC3C68)
	// 82EC3C18: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3C1C: C14B003C  lfs f10, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3C20: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3C24: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3C28: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3C2C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC3C30: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3C34: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3C38: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3C3C: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C40: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3C44: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3C48: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3C4C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3C50: 40990018  ble cr6, 0x82ec3c68
	if !ctx.cr[6].gt {
	pc = 0x82EC3C68; continue 'dispatch;
	}
	// 82EC3C54: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3C58: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3C5C: EFA002F2  fmuls f29, f0, f11
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3C60: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3C64: 48000010  b 0x82ec3c74
	pc = 0x82EC3C74; continue 'dispatch;
            }
            0x82EC3C68 => {
    //   block [0x82EC3C68..0x82EC3C74)
	// 82EC3C68: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82EC3C6C: FFA0D890  fmr f29, f27
	ctx.f[29].f64 = ctx.f[27].f64;
	// 82EC3C70: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	pc = 0x82EC3C74; continue 'dispatch;
            }
            0x82EC3C74 => {
    //   block [0x82EC3C74..0x82EC3CEC)
	// 82EC3C74: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3C78: C39F00DC  lfs f28, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EC3C7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EC3C80: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3C84: 388BD1AC  addi r4, r11, -0x2e54
	ctx.r[4].s64 = ctx.r[11].s64 + -11860;
	// 82EC3C88: 4B3249F1  bl 0x821e8678
	ctx.lr = 0x82EC3C8C;
	sub_821E8678(ctx, base);
	// 82EC3C8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3C90: 4182010C  beq 0x82ec3d9c
	if ctx.cr[0].eq {
	pc = 0x82EC3D9C; continue 'dispatch;
	}
	// 82EC3C94: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3C98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3C9C: 41820100  beq 0x82ec3d9c
	if ctx.cr[0].eq {
	pc = 0x82EC3D9C; continue 'dispatch;
	}
	// 82EC3CA0: ED9D0672  fmuls f12, f29, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EC3CA4: EC1E05F2  fmuls f0, f30, f23
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[23].f64) as f32) as f64);
	// 82EC3CA8: ED5807F2  fmuls f10, f24, f31
	ctx.f[10].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3CAC: ED7767F8  fmsubs f11, f23, f31, f12
	ctx.f[11].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3CB0: EDBD0638  fmsubs f13, f29, f24, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3CB4: ED9E5678  fmsubs f12, f30, f25, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3CB8: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3CBC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3CC0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3CC4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EC3CC8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3CCC: 409A0074  bne cr6, 0x82ec3d40
	if !ctx.cr[6].eq {
	pc = 0x82EC3D40; continue 'dispatch;
	}
	// 82EC3CD0: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82EC3CD4: 409A0018  bne cr6, 0x82ec3cec
	if !ctx.cr[6].eq {
	pc = 0x82EC3CEC; continue 'dispatch;
	}
	// 82EC3CD8: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EC3CDC: 409A0010  bne cr6, 0x82ec3cec
	if !ctx.cr[6].eq {
	pc = 0x82EC3CEC; continue 'dispatch;
	}
	// 82EC3CE0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3CE4: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82EC3CE8: 4800000C  b 0x82ec3cf4
	pc = 0x82EC3CF4; continue 'dispatch;
            }
            0x82EC3CEC => {
    //   block [0x82EC3CEC..0x82EC3CF4)
	// 82EC3CEC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3CF0: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	pc = 0x82EC3CF4; continue 'dispatch;
            }
            0x82EC3CF4 => {
    //   block [0x82EC3CF4..0x82EC3D40)
	// 82EC3CF4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3CF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC3CFC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3D00: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D04: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3D08: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D0C: ED3D0332  fmuls f9, f29, f12
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3D10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC3D14: EC1D5838  fmsubs f0, f29, f0, f11
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC3D18: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3D1C: EC1E5338  fmsubs f0, f30, f12, f10
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3D20: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3D24: EC1F4B78  fmsubs f0, f31, f13, f9
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3D28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3D2C: 4B3BB53D  bl 0x8227f268
	ctx.lr = 0x82EC3D30;
	sub_8227F268(ctx, base);
	// 82EC3D30: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3D34: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3D38: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3D3C: 48000030  b 0x82ec3d6c
	pc = 0x82EC3D6C; continue 'dispatch;
            }
            0x82EC3D40 => {
    //   block [0x82EC3D40..0x82EC3D6C)
	// 82EC3D40: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EC3D44: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D48: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3D4C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3D50: ED7E0372  fmuls f11, f30, f13
	ctx.f[11].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D54: ED2C07F2  fmuls f9, f12, f31
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3D58: ED400772  fmuls f10, f0, f29
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EC3D5C: ED4C57B8  fmsubs f10, f12, f30, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3D60: ED805FF8  fmsubs f12, f0, f31, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EC3D64: ED7D4B78  fmsubs f11, f29, f13, f9
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EC3D68: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	pc = 0x82EC3D6C; continue 'dispatch;
            }
            0x82EC3D6C => {
    //   block [0x82EC3D6C..0x82EC3D9C)
	// 82EC3D6C: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EC3D70: ED5F0732  fmuls f10, f31, f28
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D74: ED3D0732  fmuls f9, f29, f28
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D78: ED1E0732  fmuls f8, f30, f28
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3D7C: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3D80: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D84: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3D88: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC3D8C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3D90: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3D94: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EC3D98: 48000084  b 0x82ec3e1c
	pc = 0x82EC3E1C; continue 'dispatch;
            }
            0x82EC3D9C => {
    //   block [0x82EC3D9C..0x82EC3DB8)
	// 82EC3D9C: EC1807F2  fmuls f0, f24, f31
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EC3DA0: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	// 82EC3DA4: EC1E0678  fmsubs f0, f30, f25, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC3DA8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EC3DAC: 4098000C  bge cr6, 0x82ec3db8
	if !ctx.cr[6].lt {
	pc = 0x82EC3DB8; continue 'dispatch;
	}
	// 82EC3DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC3DB4: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EC3DB8; continue 'dispatch;
            }
            0x82EC3DB8 => {
    //   block [0x82EC3DB8..0x82EC3E1C)
	// 82EC3DB8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC3DBC: EC1AE028  fsubs f0, f26, f28
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EC3DC0: ED3F0732  fmuls f9, f31, f28
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DC4: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EC3DC8: ECFE0732  fmuls f7, f30, f28
	ctx.f[7].f64 = (((ctx.f[30].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DCC: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC3DD0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3DD4: ED1D02F2  fmuls f8, f29, f11
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EC3DD8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3DDC: ECDE02B2  fmuls f6, f30, f10
	ctx.f[6].f64 = (((ctx.f[30].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EC3DE0: ECBF0332  fmuls f5, f31, f12
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EC3DE4: ED9E4338  fmsubs f12, f30, f12, f8
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EC3DE8: ED7F32F8  fmsubs f11, f31, f11, f6
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EC3DEC: ED5D2AB8  fmsubs f10, f29, f10, f5
	ctx.f[10].f64 = (((ctx.f[29].f64 * ctx.f[10].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EC3DF0: ED1D0732  fmuls f8, f29, f28
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EC3DF4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3DF8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3DFC: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EC3E00: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E04: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E08: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3E0C: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC3E10: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EC3E14: EDA8582A  fadds f13, f8, f11
	ctx.f[13].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EC3E18: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82EC3E1C; continue 'dispatch;
            }
            0x82EC3E1C => {
    //   block [0x82EC3E1C..0x82EC3E4C)
	// 82EC3E1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC3E20: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC3E24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC3E28: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3E2C: 4B3BB43D  bl 0x8227f268
	ctx.lr = 0x82EC3E30;
	sub_8227F268(ctx, base);
	// 82EC3E30: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E34: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC3E38: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E3C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC3E40: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3E48: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	pc = 0x82EC3E4C; continue 'dispatch;
            }
            0x82EC3E4C => {
    //   block [0x82EC3E4C..0x82EC3E68)
	// 82EC3E4C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC3E50: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82EC3E54: 4BDE9EBD  bl 0x82cadd10
	ctx.lr = 0x82EC3E58;
	sub_82CADCEC(ctx, base);
	// 82EC3E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC3E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC3E60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC3E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3E68 size=344
    let mut pc: u32 = 0x82EC3E68;
    'dispatch: loop {
        match pc {
            0x82EC3E68 => {
    //   block [0x82EC3E68..0x82EC3EB8)
	// 82EC3E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3E6C: 4BDE559D  bl 0x82ca9408
	ctx.lr = 0x82EC3E70;
	sub_82CA93D0(ctx, base);
	// 82EC3E70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3E78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EC3E7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC3E80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EC3E84: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC3E88: C00A0A48  lfs f0, 0xa48(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3E8C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC3E90: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EC3E94: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82EC3E98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3E9C: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EC3EA0: 4182006C  beq 0x82ec3f0c
	if ctx.cr[0].eq {
	pc = 0x82EC3F0C; continue 'dispatch;
	}
	// 82EC3EA4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3EA8: C03F00D8  lfs f1, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EC3EAC: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC3EB0: 4BFC3DF9  bl 0x82e87ca8
	ctx.lr = 0x82EC3EB4;
	sub_82E87CA8(ctx, base);
	// 82EC3EB4: 4800004C  b 0x82ec3f00
	pc = 0x82EC3F00; continue 'dispatch;
            }
            0x82EC3EB8 => {
    //   block [0x82EC3EB8..0x82EC3EE8)
	// 82EC3EB8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3EBC: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC3EC0: 419A0038  beq cr6, 0x82ec3ef8
	if ctx.cr[6].eq {
	pc = 0x82EC3EF8; continue 'dispatch;
	}
	// 82EC3EC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3EC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3ECC: 4182001C  beq 0x82ec3ee8
	if ctx.cr[0].eq {
	pc = 0x82EC3EE8; continue 'dispatch;
	}
	// 82EC3ED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3ED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC3ED8: 4E800421  bctrl
	ctx.lr = 0x82EC3EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC3EDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC3EE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC3EE4: 409A0014  bne cr6, 0x82ec3ef8
	if !ctx.cr[6].eq {
	pc = 0x82EC3EF8; continue 'dispatch;
	}
            }
            0x82EC3EE8 => {
    //   block [0x82EC3EE8..0x82EC3EF8)
	// 82EC3EE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC3EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3EF4: 4BFFF95D  bl 0x82ec3850
	ctx.lr = 0x82EC3EF8;
	sub_82EC3850(ctx, base);
	pc = 0x82EC3EF8; continue 'dispatch;
            }
            0x82EC3EF8 => {
    //   block [0x82EC3EF8..0x82EC3F00)
	// 82EC3EF8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC3EFC: 4BFC3875  bl 0x82e87770
	ctx.lr = 0x82EC3F00;
	sub_82E87770(ctx, base);
	pc = 0x82EC3F00; continue 'dispatch;
            }
            0x82EC3F00 => {
    //   block [0x82EC3F00..0x82EC3F0C)
	// 82EC3F00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC3F04: 4082FFB4  bne 0x82ec3eb8
	if !ctx.cr[0].eq {
	pc = 0x82EC3EB8; continue 'dispatch;
	}
	// 82EC3F08: 480000AC  b 0x82ec3fb4
	pc = 0x82EC3FB4; continue 'dispatch;
            }
            0x82EC3F0C => {
    //   block [0x82EC3F0C..0x82EC3F20)
	// 82EC3F0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EC3F10: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EC3F14: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC3F18: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F1C: 48000090  b 0x82ec3fac
	pc = 0x82EC3FAC; continue 'dispatch;
            }
            0x82EC3F20 => {
    //   block [0x82EC3F20..0x82EC3F54)
	// 82EC3F20: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3F24: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F28: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC3F2C: 419A007C  beq cr6, 0x82ec3fa8
	if ctx.cr[6].eq {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC3F34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3F38: 4182001C  beq 0x82ec3f54
	if ctx.cr[0].eq {
	pc = 0x82EC3F54; continue 'dispatch;
	}
	// 82EC3F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC3F44: 4E800421  bctrl
	ctx.lr = 0x82EC3F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC3F48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC3F4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC3F50: 409A0058  bne cr6, 0x82ec3fa8
	if !ctx.cr[6].eq {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
            }
            0x82EC3F54 => {
    //   block [0x82EC3F54..0x82EC3FA8)
	// 82EC3F54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC3F58: C01F00D8  lfs f0, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3F5C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3F60: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC3F64: C19E0038  lfs f12, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3F68: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3F6C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC3F70: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3F74: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EC3F78: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC3F7C: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EC3F80: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EC3F84: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC3F88: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3F8C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC3F90: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EC3F94: 40980014  bge cr6, 0x82ec3fa8
	if !ctx.cr[6].lt {
	pc = 0x82EC3FA8; continue 'dispatch;
	}
	// 82EC3F98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82EC3F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3FA4: 4BFFF8AD  bl 0x82ec3850
	ctx.lr = 0x82EC3FA8;
	sub_82EC3850(ctx, base);
	pc = 0x82EC3FA8; continue 'dispatch;
            }
            0x82EC3FA8 => {
    //   block [0x82EC3FA8..0x82EC3FAC)
	// 82EC3FA8: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EC3FAC; continue 'dispatch;
            }
            0x82EC3FAC => {
    //   block [0x82EC3FAC..0x82EC3FB4)
	// 82EC3FAC: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3FB0: 4082FF70  bne 0x82ec3f20
	if !ctx.cr[0].eq {
	pc = 0x82EC3F20; continue 'dispatch;
	}
	pc = 0x82EC3FB4; continue 'dispatch;
            }
            0x82EC3FB4 => {
    //   block [0x82EC3FB4..0x82EC3FC0)
	// 82EC3FB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC3FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC3FBC: 4BDE549C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC3FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC3FC0 size=184
    let mut pc: u32 = 0x82EC3FC0;
    'dispatch: loop {
        match pc {
            0x82EC3FC0 => {
    //   block [0x82EC3FC0..0x82EC402C)
	// 82EC3FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC3FC4: 4BDE5449  bl 0x82ca940c
	ctx.lr = 0x82EC3FC8;
	sub_82CA93D0(ctx, base);
	// 82EC3FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC3FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC3FD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EC3FD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EC3FD8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC3FDC: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC3FE0: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EC3FE4: 4BFFFE85  bl 0x82ec3e68
	ctx.lr = 0x82EC3FE8;
	sub_82EC3E68(ctx, base);
	// 82EC3FE8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC3FEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC3FF0: 4182003C  beq 0x82ec402c
	if ctx.cr[0].eq {
	pc = 0x82EC402C; continue 'dispatch;
	}
	// 82EC3FF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC3FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC3FFC: 4BFFFB1D  bl 0x82ec3b18
	ctx.lr = 0x82EC4000;
	sub_82EC3B18(ctx, base);
	// 82EC4000: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC4004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4008: 4BFFF759  bl 0x82ec3760
	ctx.lr = 0x82EC400C;
	sub_82EC3760(ctx, base);
	// 82EC400C: 4B39C9AD  bl 0x822609b8
	ctx.lr = 0x82EC4010;
	sub_822609B8(ctx, base);
	// 82EC4010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4014: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4018: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC401C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EC4020: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EC4024: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC4028: 48000048  b 0x82ec4070
	pc = 0x82EC4070; continue 'dispatch;
            }
            0x82EC402C => {
    //   block [0x82EC402C..0x82EC4064)
	// 82EC402C: 897F00D0  lbz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EC4030: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC4034: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC4038: 409A002C  bne cr6, 0x82ec4064
	if !ctx.cr[6].eq {
	pc = 0x82EC4064; continue 'dispatch;
	}
	// 82EC403C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4040: 4BFFF721  bl 0x82ec3760
	ctx.lr = 0x82EC4044;
	sub_82EC3760(ctx, base);
	// 82EC4044: 4B39C975  bl 0x822609b8
	ctx.lr = 0x82EC4048;
	sub_822609B8(ctx, base);
	// 82EC4048: C01F00D4  lfs f0, 0xd4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC404C: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4050: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4054: 4098001C  bge cr6, 0x82ec4070
	if !ctx.cr[6].lt {
	pc = 0x82EC4070; continue 'dispatch;
	}
	// 82EC4058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC405C: 997F00D0  stb r11, 0xd0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u8 ) };
	// 82EC4060: 48000010  b 0x82ec4070
	pc = 0x82EC4070; continue 'dispatch;
            }
            0x82EC4064 => {
    //   block [0x82EC4064..0x82EC4070)
	// 82EC4064: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4068: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EC406C: 4BFF0B35  bl 0x82eb4ba0
	ctx.lr = 0x82EC4070;
	sub_82EB4BA0(ctx, base);
	pc = 0x82EC4070; continue 'dispatch;
            }
            0x82EC4070 => {
    //   block [0x82EC4070..0x82EC4078)
	// 82EC4070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EC4074: 4BDE53E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC4078 size=156
    let mut pc: u32 = 0x82EC4078;
    'dispatch: loop {
        match pc {
            0x82EC4078 => {
    //   block [0x82EC4078..0x82EC40AC)
	// 82EC4078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC407C: 4BDE5389  bl 0x82ca9404
	ctx.lr = 0x82EC4080;
	sub_82CA93D0(ctx, base);
	// 82EC4080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4084: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC4088: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82EC408C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EC4090: 419A0070  beq cr6, 0x82ec4100
	if ctx.cr[6].eq {
	pc = 0x82EC4100; continue 'dispatch;
	}
	// 82EC4094: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC4098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC409C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC40A0: 40990060  ble cr6, 0x82ec4100
	if !ctx.cr[6].gt {
	pc = 0x82EC4100; continue 'dispatch;
	}
	// 82EC40A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC40A8: 3B8B8FD8  addi r28, r11, -0x7028
	ctx.r[28].s64 = ctx.r[11].s64 + -28712;
	pc = 0x82EC40AC; continue 'dispatch;
            }
            0x82EC40AC => {
    //   block [0x82EC40AC..0x82EC40F0)
	// 82EC40AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC40B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC40B4: 4BFBFF75  bl 0x82e84028
	ctx.lr = 0x82EC40B8;
	sub_82E84028(ctx, base);
	// 82EC40B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC40BC: 482F7FA5  bl 0x831bc060
	ctx.lr = 0x82EC40C0;
	sub_831BC060(ctx, base);
	// 82EC40C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EC40C4: 4BDE8A8D  bl 0x82cacb50
	ctx.lr = 0x82EC40C8;
	sub_82CACB50(ctx, base);
	// 82EC40C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC40CC: 41820024  beq 0x82ec40f0
	if ctx.cr[0].eq {
	pc = 0x82EC40F0; continue 'dispatch;
	}
	// 82EC40D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC40D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EC40D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EC40DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC40E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC40E4: 4E800421  bctrl
	ctx.lr = 0x82EC40E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC40E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC40EC: 41820020  beq 0x82ec410c
	if ctx.cr[0].eq {
	pc = 0x82EC410C; continue 'dispatch;
	}
            }
            0x82EC40F0 => {
    //   block [0x82EC40F0..0x82EC4100)
	// 82EC40F0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EC40F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82EC40F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC40FC: 4198FFB0  blt cr6, 0x82ec40ac
	if ctx.cr[6].lt {
	pc = 0x82EC40AC; continue 'dispatch;
	}
	pc = 0x82EC4100; continue 'dispatch;
            }
            0x82EC4100 => {
    //   block [0x82EC4100..0x82EC4104)
	// 82EC4100: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC4104; continue 'dispatch;
            }
            0x82EC4104 => {
    //   block [0x82EC4104..0x82EC410C)
	// 82EC4104: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC4108: 4BDE534C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC410C => {
    //   block [0x82EC410C..0x82EC4114)
	// 82EC410C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4110: 4BFFFFF4  b 0x82ec4104
	pc = 0x82EC4104; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4118 size=544
    let mut pc: u32 = 0x82EC4118;
    'dispatch: loop {
        match pc {
            0x82EC4118 => {
    //   block [0x82EC4118..0x82EC414C)
	// 82EC4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC411C: 4BDE52ED  bl 0x82ca9408
	ctx.lr = 0x82EC4120;
	sub_82CA93D0(ctx, base);
	// 82EC4120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4128: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC412C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4130: 41820028  beq 0x82ec4158
	if ctx.cr[0].eq {
	pc = 0x82EC4158; continue 'dispatch;
	}
	// 82EC4134: 897F019D  lbz r11, 0x19d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(413 as u32) ) } as u64;
	// 82EC4138: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC413C: 41820010  beq 0x82ec414c
	if ctx.cr[0].eq {
	pc = 0x82EC414C; continue 'dispatch;
	}
	// 82EC4140: 897F019C  lbz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EC4144: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4148: 40820010  bne 0x82ec4158
	if !ctx.cr[0].eq {
	pc = 0x82EC4158; continue 'dispatch;
	}
	pc = 0x82EC414C; continue 'dispatch;
            }
            0x82EC414C => {
    //   block [0x82EC414C..0x82EC4158)
	// 82EC414C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4150: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EC4154: 480001DC  b 0x82ec4330
	pc = 0x82EC4330; continue 'dispatch;
            }
            0x82EC4158 => {
    //   block [0x82EC4158..0x82EC4178)
	// 82EC4158: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC415C: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4160: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4164: 9B9F0394  stb r28, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[28].u8 ) };
	// 82EC4168: 9B9F019D  stb r28, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[28].u8 ) };
	// 82EC416C: 4182000C  beq 0x82ec4178
	if ctx.cr[0].eq {
	pc = 0x82EC4178; continue 'dispatch;
	}
	// 82EC4170: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4174: 48000008  b 0x82ec417c
	pc = 0x82EC417C; continue 'dispatch;
            }
            0x82EC4178 => {
    //   block [0x82EC4178..0x82EC417C)
	// 82EC4178: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82EC417C; continue 'dispatch;
            }
            0x82EC417C => {
    //   block [0x82EC417C..0x82EC41AC)
	// 82EC417C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC4180: 419A002C  beq cr6, 0x82ec41ac
	if ctx.cr[6].eq {
	pc = 0x82EC41AC; continue 'dispatch;
	}
	// 82EC4184: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4188: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC418C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4190: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4194: 816A0044  lwz r11, 0x44(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4198: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC419C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC41A0: 4E800421  bctrl
	ctx.lr = 0x82EC41A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC41A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC41A8: 41820188  beq 0x82ec4330
	if ctx.cr[0].eq {
	pc = 0x82EC4330; continue 'dispatch;
	}
            }
            0x82EC41AC => {
    //   block [0x82EC41AC..0x82EC41BC)
	// 82EC41AC: 897F0397  lbz r11, 0x397(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(919 as u32) ) } as u64;
	// 82EC41B0: 3BBF0334  addi r29, r31, 0x334
	ctx.r[29].s64 = ctx.r[31].s64 + 820;
	// 82EC41B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC41B8: 4182000C  beq 0x82ec41c4
	if ctx.cr[0].eq {
	pc = 0x82EC41C4; continue 'dispatch;
	}
	pc = 0x82EC41BC; continue 'dispatch;
            }
            0x82EC41BC => {
    //   block [0x82EC41BC..0x82EC41C4)
	// 82EC41BC: 389F02D8  addi r4, r31, 0x2d8
	ctx.r[4].s64 = ctx.r[31].s64 + 728;
	// 82EC41C0: 4800003C  b 0x82ec41fc
	pc = 0x82EC41FC; continue 'dispatch;
            }
            0x82EC41C4 => {
    //   block [0x82EC41C4..0x82EC41FC)
	// 82EC41C4: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC41C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC41CC: 4082FFF0  bne 0x82ec41bc
	if !ctx.cr[0].eq {
	pc = 0x82EC41BC; continue 'dispatch;
	}
	// 82EC41D0: 807F01D8  lwz r3, 0x1d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EC41D4: 3BDF02D8  addi r30, r31, 0x2d8
	ctx.r[30].s64 = ctx.r[31].s64 + 728;
	// 82EC41D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC41DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC41E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC41E4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC41E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC41EC: 4E800421  bctrl
	ctx.lr = 0x82EC41F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC41F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC41F4: 41820010  beq 0x82ec4204
	if ctx.cr[0].eq {
	pc = 0x82EC4204; continue 'dispatch;
	}
	// 82EC41F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
            }
            0x82EC41FC => {
    //   block [0x82EC41FC..0x82EC4204)
	// 82EC41FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EC4200: 4BFABCF9  bl 0x82e6fef8
	ctx.lr = 0x82EC4204;
	sub_82E6FEF8(ctx, base);
	pc = 0x82EC4204; continue 'dispatch;
            }
            0x82EC4204 => {
    //   block [0x82EC4204..0x82EC4234)
	// 82EC4204: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4208: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82EC420C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4210: 41820048  beq 0x82ec4258
	if ctx.cr[0].eq {
	pc = 0x82EC4258; continue 'dispatch;
	}
	// 82EC4214: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4218: 816A01BC  lwz r11, 0x1bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC421C: 814A01B8  lwz r10, 0x1b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4220: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC4224: 419A0010  beq cr6, 0x82ec4234
	if ctx.cr[6].eq {
	pc = 0x82EC4234; continue 'dispatch;
	}
	// 82EC4228: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC422C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC4230: 409A0008  bne cr6, 0x82ec4238
	if !ctx.cr[6].eq {
	pc = 0x82EC4238; continue 'dispatch;
	}
	pc = 0x82EC4234; continue 'dispatch;
            }
            0x82EC4234 => {
    //   block [0x82EC4234..0x82EC4238)
	// 82EC4234: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	pc = 0x82EC4238; continue 'dispatch;
            }
            0x82EC4238 => {
    //   block [0x82EC4238..0x82EC4258)
	// 82EC4238: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC423C: D01F0428  stfs f0, 0x428(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1064 as u32), tmp.u32 ) };
	// 82EC4240: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4244: D01F042C  stfs f0, 0x42c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1068 as u32), tmp.u32 ) };
	// 82EC4248: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC424C: D01F0430  stfs f0, 0x430(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1072 as u32), tmp.u32 ) };
	// 82EC4250: 9BDF0434  stb r30, 0x434(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), ctx.r[30].u8 ) };
	// 82EC4254: 48000008  b 0x82ec425c
	pc = 0x82EC425C; continue 'dispatch;
            }
            0x82EC4258 => {
    //   block [0x82EC4258..0x82EC425C)
	// 82EC4258: 9B9F0434  stb r28, 0x434(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1076 as u32), ctx.r[28].u8 ) };
	pc = 0x82EC425C; continue 'dispatch;
            }
            0x82EC425C => {
    //   block [0x82EC425C..0x82EC4278)
	// 82EC425C: 897F0397  lbz r11, 0x397(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(919 as u32) ) } as u64;
	// 82EC4260: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4264: 40820014  bne 0x82ec4278
	if !ctx.cr[0].eq {
	pc = 0x82EC4278; continue 'dispatch;
	}
	// 82EC4268: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC426C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4270: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4274: 41820008  beq 0x82ec427c
	if ctx.cr[0].eq {
	pc = 0x82EC427C; continue 'dispatch;
	}
	pc = 0x82EC4278; continue 'dispatch;
            }
            0x82EC4278 => {
    //   block [0x82EC4278..0x82EC427C)
	// 82EC4278: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82EC427C; continue 'dispatch;
            }
            0x82EC427C => {
    //   block [0x82EC427C..0x82EC42B0)
	// 82EC427C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4280: 5566063E  clrlwi r6, r11, 0x18
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC4284: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC4288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC428C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4290: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82EC4294: 4BFF585D  bl 0x82eb9af0
	ctx.lr = 0x82EC4298;
	sub_82EB9AF0(ctx, base);
	// 82EC4298: 9B9F0397  stb r28, 0x397(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(919 as u32), ctx.r[28].u8 ) };
	// 82EC429C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC42A0: 40820010  bne 0x82ec42b0
	if !ctx.cr[0].eq {
	pc = 0x82EC42B0; continue 'dispatch;
	}
	// 82EC42A4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EC42A8: 917F0398  stw r11, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EC42AC: 48000064  b 0x82ec4310
	pc = 0x82EC4310; continue 'dispatch;
            }
            0x82EC42B0 => {
    //   block [0x82EC42B0..0x82EC42F8)
	// 82EC42B0: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC42B4: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC42B8: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC42BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EC42C0: 419A004C  beq cr6, 0x82ec430c
	if ctx.cr[6].eq {
	pc = 0x82EC430C; continue 'dispatch;
	}
	// 82EC42C4: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC42C8: C1ABFFF0  lfs f13, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC42CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC42D0: 409A0028  bne cr6, 0x82ec42f8
	if !ctx.cr[6].eq {
	pc = 0x82EC42F8; continue 'dispatch;
	}
	// 82EC42D4: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC42D8: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC42DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC42E0: 409A0018  bne cr6, 0x82ec42f8
	if !ctx.cr[6].eq {
	pc = 0x82EC42F8; continue 'dispatch;
	}
	// 82EC42E4: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC42E8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82EC42EC: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC42F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC42F4: 419A0008  beq cr6, 0x82ec42fc
	if ctx.cr[6].eq {
	pc = 0x82EC42FC; continue 'dispatch;
	}
	pc = 0x82EC42F8; continue 'dispatch;
            }
            0x82EC42F8 => {
    //   block [0x82EC42F8..0x82EC42FC)
	// 82EC42F8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EC42FC; continue 'dispatch;
            }
            0x82EC42FC => {
    //   block [0x82EC42FC..0x82EC430C)
	// 82EC42FC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4300: 4182000C  beq 0x82ec430c
	if ctx.cr[0].eq {
	pc = 0x82EC430C; continue 'dispatch;
	}
	// 82EC4304: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 82EC4308: 48000008  b 0x82ec4310
	pc = 0x82EC4310; continue 'dispatch;
            }
            0x82EC430C => {
    //   block [0x82EC430C..0x82EC4310)
	// 82EC430C: 939F0398  stw r28, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[28].u32 ) };
	pc = 0x82EC4310; continue 'dispatch;
            }
            0x82EC4310 => {
    //   block [0x82EC4310..0x82EC4330)
	// 82EC4310: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EC4314: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EC4318: 409A0018  bne cr6, 0x82ec4330
	if !ctx.cr[6].eq {
	pc = 0x82EC4330; continue 'dispatch;
	}
	// 82EC431C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC4320: 939F039C  stw r28, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[28].u32 ) };
	// 82EC4324: 9B9F0400  stb r28, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[28].u8 ) };
	// 82EC4328: 939F0390  stw r28, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[28].u32 ) };
	// 82EC432C: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC4330; continue 'dispatch;
            }
            0x82EC4330 => {
    //   block [0x82EC4330..0x82EC4338)
	// 82EC4330: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC4334: 4BDE5124  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC4338 size=32
    let mut pc: u32 = 0x82EC4338;
    'dispatch: loop {
        match pc {
            0x82EC4338 => {
    //   block [0x82EC4338..0x82EC4358)
	// 82EC4338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC433C: 806B0228  lwz r3, 0x228(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC4340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4344: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC434C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4354: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC4358 size=164
    let mut pc: u32 = 0x82EC4358;
    'dispatch: loop {
        match pc {
            0x82EC4358 => {
    //   block [0x82EC4358..0x82EC4380)
	// 82EC4358: 81430054  lwz r10, 0x54(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC435C: 816A01BC  lwz r11, 0x1bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4360: 80EA01B8  lwz r7, 0x1b8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4364: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC4368: 409A0018  bne cr6, 0x82ec4380
	if !ctx.cr[6].eq {
	pc = 0x82EC4380; continue 'dispatch;
	}
	// 82EC436C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC4370: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EC4374: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC4378: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC437C: 48000078  b 0x82ec43f4
	pc = 0x82EC43F4; continue 'dispatch;
            }
            0x82EC4380 => {
    //   block [0x82EC4380..0x82EC4390)
	// 82EC4380: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82EC4384: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EC4388: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82EC438C: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82EC4390; continue 'dispatch;
            }
            0x82EC4390 => {
    //   block [0x82EC4390..0x82EC43C4)
	// 82EC4390: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4394: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4398: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC439C: 409A0028  bne cr6, 0x82ec43c4
	if !ctx.cr[6].eq {
	pc = 0x82EC43C4; continue 'dispatch;
	}
	// 82EC43A0: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC43A4: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC43A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC43AC: 409A0018  bne cr6, 0x82ec43c4
	if !ctx.cr[6].eq {
	pc = 0x82EC43C4; continue 'dispatch;
	}
	// 82EC43B0: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC43B4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EC43B8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC43BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC43C0: 419A0008  beq cr6, 0x82ec43c8
	if ctx.cr[6].eq {
	pc = 0x82EC43C8; continue 'dispatch;
	}
	pc = 0x82EC43C4; continue 'dispatch;
            }
            0x82EC43C4 => {
    //   block [0x82EC43C4..0x82EC43C8)
	// 82EC43C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82EC43C8; continue 'dispatch;
            }
            0x82EC43C8 => {
    //   block [0x82EC43C8..0x82EC43F4)
	// 82EC43C8: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC43CC: 40820030  bne 0x82ec43fc
	if !ctx.cr[0].eq {
		sub_82EC43FC(ctx, base);
		return;
	}
	// 82EC43D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC43D4: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EC43D8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82EC43DC: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82EC43E0: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC43E4: 409AFFAC  bne cr6, 0x82ec4390
	if !ctx.cr[6].eq {
	pc = 0x82EC4390; continue 'dispatch;
	}
	// 82EC43E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC43EC: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC43F0: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC43F4; continue 'dispatch;
            }
            0x82EC43F4 => {
    //   block [0x82EC43F4..0x82EC43FC)
	// 82EC43F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC43F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC43FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC43FC size=12
    let mut pc: u32 = 0x82EC43FC;
    'dispatch: loop {
        match pc {
            0x82EC43FC => {
    //   block [0x82EC43FC..0x82EC4408)
	// 82EC43FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4400: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EC4404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EC4408 size=140
    let mut pc: u32 = 0x82EC4408;
    'dispatch: loop {
        match pc {
            0x82EC4408 => {
    //   block [0x82EC4408..0x82EC4458)
	// 82EC4408: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EC440C: 806A0054  lwz r3, 0x54(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4410: 816A039C  lwz r11, 0x39c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4414: 812301BC  lwz r9, 0x1bc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4418: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EC441C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC4420: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4424: 39490014  addi r10, r9, 0x14
	ctx.r[10].s64 = ctx.r[9].s64 + 20;
	// 82EC4428: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC442C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC4430: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EC4434: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4438: 81280014  lwz r9, 0x14(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC443C: C009003C  lfs f0, 0x3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4440: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC4444: C1A90034  lfs f13, 0x34(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4448: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC444C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC4450: ED4D037A  fmadds f10, f13, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC4454: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82EC4458; continue 'dispatch;
            }
            0x82EC4458 => {
    //   block [0x82EC4458..0x82EC4488)
	// 82EC4458: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC445C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EC4460: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4464: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EC4468: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EC446C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EC4470: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EC4474: 41980014  blt cr6, 0x82ec4488
	if ctx.cr[6].lt {
	pc = 0x82EC4488; continue 'dispatch;
	}
	// 82EC4478: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82EC447C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82EC4480: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4484: 409AFFD4  bne cr6, 0x82ec4458
	if !ctx.cr[6].eq {
	pc = 0x82EC4458; continue 'dispatch;
	}
	pc = 0x82EC4488; continue 'dispatch;
            }
            0x82EC4488 => {
    //   block [0x82EC4488..0x82EC4494)
	// 82EC4488: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82EC448C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EC4490: 4BFF17F0  b 0x82eb5c80
	crate::recompiler::externs::call(ctx, base, 0x82EB5C80);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4494(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EC4494 size=4
    let mut pc: u32 = 0x82EC4494;
    'dispatch: loop {
        match pc {
            0x82EC4494 => {
    //   block [0x82EC4494..0x82EC4498)
	// 82EC4494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4498 size=172
    let mut pc: u32 = 0x82EC4498;
    'dispatch: loop {
        match pc {
            0x82EC4498 => {
    //   block [0x82EC4498..0x82EC4504)
	// 82EC4498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC449C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC44A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC44A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC44A8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC44AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82EC44B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC44B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EC44B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC44BC: 814BE280  lwz r10, -0x1d80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7552 as u32) ) } as u64;
	// 82EC44C0: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC44C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC44C8: 914BE280  stw r10, -0x1d80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7552 as u32), ctx.r[10].u32 ) };
	// 82EC44CC: 4BFC780D  bl 0x82e8bcd8
	ctx.lr = 0x82EC44D0;
	sub_82E8BCD8(ctx, base);
	// 82EC44D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC44D4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44D8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC44DC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82EC44E0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC44E4: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC44EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EC44F0: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC44F4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC44F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC44FC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC4500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EC4504; continue 'dispatch;
            }
            0x82EC4504 => {
    //   block [0x82EC4504..0x82EC4544)
	// 82EC4504: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC4508: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC450C: 4200FFF8  bdnz 0x82ec4504
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4504; continue 'dispatch;
	}
	// 82EC4510: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4514: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4518: 992100A8  stb r9, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[9].u8 ) };
	// 82EC451C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4520: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EC4524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4528: 4E800421  bctrl
	ctx.lr = 0x82EC452C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC452C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC4530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC4534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC4538: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC453C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC4540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4548 size=812
    let mut pc: u32 = 0x82EC4548;
    'dispatch: loop {
        match pc {
            0x82EC4548 => {
    //   block [0x82EC4548..0x82EC459C)
	// 82EC4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC454C: 4BDE4EBD  bl 0x82ca9408
	ctx.lr = 0x82EC4550;
	sub_82CA93D0(ctx, base);
	// 82EC4550: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4558: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EC455C: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EC4560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4564: 4082003C  bne 0x82ec45a0
	if !ctx.cr[0].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4568: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EC456C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4570: 41820030  beq 0x82ec45a0
	if ctx.cr[0].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4574: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EC4578: 480114B9  bl 0x82ed5a30
	ctx.lr = 0x82EC457C;
	sub_82ED5A30(ctx, base);
	// 82EC457C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC4580: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC4584: 419A001C  beq cr6, 0x82ec45a0
	if ctx.cr[6].eq {
	pc = 0x82EC45A0; continue 'dispatch;
	}
	// 82EC4588: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EC458C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82EC4590: 4098000C  bge cr6, 0x82ec459c
	if !ctx.cr[6].lt {
	pc = 0x82EC459C; continue 'dispatch;
	}
	// 82EC4594: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EC4598: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC459C; continue 'dispatch;
            }
            0x82EC459C => {
    //   block [0x82EC459C..0x82EC45A0)
	// 82EC459C: 907F0068  stw r3, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	pc = 0x82EC45A0; continue 'dispatch;
            }
            0x82EC45A0 => {
    //   block [0x82EC45A0..0x82EC460C)
	// 82EC45A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC45A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC45A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC45AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC45B0: 4E800421  bctrl
	ctx.lr = 0x82EC45B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC45B4: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC45B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EC45BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC45C0: 41820060  beq 0x82ec4620
	if ctx.cr[0].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC45C4: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC45C8: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC45CC: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC45D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC45D4: 419A004C  beq cr6, 0x82ec4620
	if ctx.cr[6].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC45D8: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC45DC: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC45E4: 409A0028  bne cr6, 0x82ec460c
	if !ctx.cr[6].eq {
	pc = 0x82EC460C; continue 'dispatch;
	}
	// 82EC45E8: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC45EC: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC45F4: 409A0018  bne cr6, 0x82ec460c
	if !ctx.cr[6].eq {
	pc = 0x82EC460C; continue 'dispatch;
	}
	// 82EC45F8: C1ABFFF8  lfs f13, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC45FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82EC4600: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4604: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4608: 419A0008  beq cr6, 0x82ec4610
	if ctx.cr[6].eq {
	pc = 0x82EC4610; continue 'dispatch;
	}
            }
            0x82EC460C => {
    //   block [0x82EC460C..0x82EC4610)
	// 82EC460C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EC4610; continue 'dispatch;
            }
            0x82EC4610 => {
    //   block [0x82EC4610..0x82EC4620)
	// 82EC4610: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4614: 4182000C  beq 0x82ec4620
	if ctx.cr[0].eq {
	pc = 0x82EC4620; continue 'dispatch;
	}
	// 82EC4618: 9B9F018C  stb r28, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[28].u8 ) };
	// 82EC461C: 9B9F0394  stb r28, 0x394(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[28].u8 ) };
	pc = 0x82EC4620; continue 'dispatch;
            }
            0x82EC4620 => {
    //   block [0x82EC4620..0x82EC4644)
	// 82EC4620: 4B39C399  bl 0x822609b8
	ctx.lr = 0x82EC4624;
	sub_822609B8(ctx, base);
	// 82EC4624: 809F0414  lwz r4, 0x414(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82EC4628: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC462C: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82EC4630: 409A0014  bne cr6, 0x82ec4644
	if !ctx.cr[6].eq {
	pc = 0x82EC4644; continue 'dispatch;
	}
	// 82EC4634: 897E006C  lbz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4638: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC463C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC4640: 48000018  b 0x82ec4658
	pc = 0x82EC4658; continue 'dispatch;
            }
            0x82EC4644 => {
    //   block [0x82EC4644..0x82EC4658)
	// 82EC4644: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC464C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4650: 4BFBD109  bl 0x82e81758
	ctx.lr = 0x82EC4654;
	sub_82E81758(ctx, base);
	// 82EC4654: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	pc = 0x82EC4658; continue 'dispatch;
            }
            0x82EC4658 => {
    //   block [0x82EC4658..0x82EC467C)
	// 82EC4658: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC465C: 809F0414  lwz r4, 0x414(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1044 as u32) ) } as u64;
	// 82EC4660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4664: 997F0410  stb r11, 0x410(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1040 as u32), ctx.r[11].u8 ) };
	// 82EC4668: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC466C: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4670: 4182000C  beq 0x82ec467c
	if ctx.cr[0].eq {
	pc = 0x82EC467C; continue 'dispatch;
	}
	// 82EC4674: 4BFBD47D  bl 0x82e81af0
	ctx.lr = 0x82EC4678;
	sub_82E81AF0(ctx, base);
	// 82EC4678: 48000008  b 0x82ec4680
	pc = 0x82EC4680; continue 'dispatch;
            }
            0x82EC467C => {
    //   block [0x82EC467C..0x82EC4680)
	// 82EC467C: 4BFBD5BD  bl 0x82e81c38
	ctx.lr = 0x82EC4680;
	sub_82E81C38(ctx, base);
	pc = 0x82EC4680; continue 'dispatch;
            }
            0x82EC4680 => {
    //   block [0x82EC4680..0x82EC4694)
	// 82EC4680: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4684: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4688: 4182000C  beq 0x82ec4694
	if ctx.cr[0].eq {
	pc = 0x82EC4694; continue 'dispatch;
	}
	// 82EC468C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4690: 48000008  b 0x82ec4698
	pc = 0x82EC4698; continue 'dispatch;
            }
            0x82EC4694 => {
    //   block [0x82EC4694..0x82EC4698)
	// 82EC4694: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82EC4698; continue 'dispatch;
            }
            0x82EC4698 => {
    //   block [0x82EC4698..0x82EC4708)
	// 82EC4698: 3BDF027C  addi r30, r31, 0x27c
	ctx.r[30].s64 = ctx.r[31].s64 + 636;
	// 82EC469C: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EC46A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EC46A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC46A8: 4BFAB851  bl 0x82e6fef8
	ctx.lr = 0x82EC46AC;
	sub_82E6FEF8(ctx, base);
	// 82EC46AC: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82EC46B0: 3BBF02D8  addi r29, r31, 0x2d8
	ctx.r[29].s64 = ctx.r[31].s64 + 728;
	// 82EC46B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC46B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC46BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC46C0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC46C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC46C8: 4E800421  bctrl
	ctx.lr = 0x82EC46CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC46CC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC46D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC46D4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82EC46D8: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 82EC46DC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EC46E0: 81660014  lwz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC46E4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EC46E8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC46EC: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC46F0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC46F4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC46F8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC46FC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4700: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC4704: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
            }
            0x82EC4708 => {
    //   block [0x82EC4708..0x82EC4754)
	// 82EC4708: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC470C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC4710: 4200FFF8  bdnz 0x82ec4708
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4708; continue 'dispatch;
	}
	// 82EC4714: 807F01C4  lwz r3, 0x1c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EC4718: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EC471C: 9B8100A8  stb r28, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u8 ) };
	// 82EC4720: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4728: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC472C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4730: 4E800421  bctrl
	ctx.lr = 0x82EC4734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4734: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4738: 987F0396  stb r3, 0x396(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(918 as u32), ctx.r[3].u8 ) };
	// 82EC473C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC4740: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC4744: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4748: 4182000C  beq 0x82ec4754
	if ctx.cr[0].eq {
	pc = 0x82EC4754; continue 'dispatch;
	}
	// 82EC474C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4750: 4800011C  b 0x82ec486c
	pc = 0x82EC486C; continue 'dispatch;
            }
            0x82EC4754 => {
    //   block [0x82EC4754..0x82EC477C)
	// 82EC4754: 897F0394  lbz r11, 0x394(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EC4758: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC475C: 41820020  beq 0x82ec477c
	if ctx.cr[0].eq {
	pc = 0x82EC477C; continue 'dispatch;
	}
	// 82EC4760: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4764: 814B01B8  lwz r10, 0x1b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC4768: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC476C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4770: 409A000C  bne cr6, 0x82ec477c
	if !ctx.cr[6].eq {
	pc = 0x82EC477C; continue 'dispatch;
	}
	// 82EC4774: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4778: 480000F4  b 0x82ec486c
	pc = 0x82EC486C; continue 'dispatch;
            }
            0x82EC477C => {
    //   block [0x82EC477C..0x82EC47B0)
	// 82EC477C: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4780: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EC4784: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4788: 41820028  beq 0x82ec47b0
	if ctx.cr[0].eq {
	pc = 0x82EC47B0; continue 'dispatch;
	}
	// 82EC478C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4790: 38BF0435  addi r5, r31, 0x435
	ctx.r[5].s64 = ctx.r[31].s64 + 1077;
	// 82EC4794: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4798: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EC479C: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC47A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC47A4: 4E800421  bctrl
	ctx.lr = 0x82EC47A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC47A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC47AC: 41820060  beq 0x82ec480c
	if ctx.cr[0].eq {
	pc = 0x82EC480C; continue 'dispatch;
	}
            }
            0x82EC47B0 => {
    //   block [0x82EC47B0..0x82EC47CC)
	// 82EC47B0: 4B39C209  bl 0x822609b8
	ctx.lr = 0x82EC47B4;
	sub_822609B8(ctx, base);
	// 82EC47B4: 897F0410  lbz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EC47B8: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC47BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC47C0: 4182000C  beq 0x82ec47cc
	if ctx.cr[0].eq {
	pc = 0x82EC47CC; continue 'dispatch;
	}
	// 82EC47C4: C01F043C  lfs f0, 0x43c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC47C8: 48000014  b 0x82ec47dc
	pc = 0x82EC47DC; continue 'dispatch;
            }
            0x82EC47CC => {
    //   block [0x82EC47CC..0x82EC47DC)
	// 82EC47CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC47D0: C19F043C  lfs f12, 0x43c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1084 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC47D4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC47D8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EC47DC; continue 'dispatch;
            }
            0x82EC47DC => {
    //   block [0x82EC47DC..0x82EC4808)
	// 82EC47DC: C19F0438  lfs f12, 0x438(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1080 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EC47E0: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EC47E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC47E8: 40980020  bge cr6, 0x82ec4808
	if !ctx.cr[6].lt {
	pc = 0x82EC4808; continue 'dispatch;
	}
	// 82EC47EC: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EC47F0: D1BF0438  stfs f13, 0x438(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), tmp.u32 ) };
	// 82EC47F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC47F8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC47FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4800: 4E800421  bctrl
	ctx.lr = 0x82EC4804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4804: 987F0435  stb r3, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[3].u8 ) };
            }
            0x82EC4808 => {
    //   block [0x82EC4808..0x82EC480C)
	// 82EC4808: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x82EC480C; continue 'dispatch;
            }
            0x82EC480C => {
    //   block [0x82EC480C..0x82EC4864)
	// 82EC480C: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC4810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4814: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4818: 997F019D  stb r11, 0x19d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(413 as u32), ctx.r[11].u8 ) };
	// 82EC481C: 816A0074  lwz r11, 0x74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EC4820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4824: 4E800421  bctrl
	ctx.lr = 0x82EC4828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC482C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4830: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EC4834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4838: 4E800421  bctrl
	ctx.lr = 0x82EC483C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC483C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC4840: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4844: 41820020  beq 0x82ec4864
	if ctx.cr[0].eq {
	pc = 0x82EC4864; continue 'dispatch;
	}
	// 82EC4848: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC484C: 41820018  beq 0x82ec4864
	if ctx.cr[0].eq {
	pc = 0x82EC4864; continue 'dispatch;
	}
	// 82EC4850: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EC4854: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4858: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC485C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4860: 4E800421  bctrl
	ctx.lr = 0x82EC4864;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC4864 => {
    //   block [0x82EC4864..0x82EC486C)
	// 82EC4864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EC4868: 9B9F0435  stb r28, 0x435(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1077 as u32), ctx.r[28].u8 ) };
	pc = 0x82EC486C; continue 'dispatch;
            }
            0x82EC486C => {
    //   block [0x82EC486C..0x82EC4874)
	// 82EC486C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EC4870: 4BDE4BE8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4878 size=580
    let mut pc: u32 = 0x82EC4878;
    'dispatch: loop {
        match pc {
            0x82EC4878 => {
    //   block [0x82EC4878..0x82EC4894)
	// 82EC4878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC487C: 4BDE4B8D  bl 0x82ca9408
	ctx.lr = 0x82EC4880;
	sub_82CA93D0(ctx, base);
	// 82EC4880: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4888: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EC488C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82EC4890: 409A000C  bne cr6, 0x82ec489c
	if !ctx.cr[6].eq {
	pc = 0x82EC489C; continue 'dispatch;
	}
	pc = 0x82EC4894; continue 'dispatch;
            }
            0x82EC4894 => {
    //   block [0x82EC4894..0x82EC489C)
	// 82EC4894: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4898: 48000214  b 0x82ec4aac
	pc = 0x82EC4AAC; continue 'dispatch;
            }
            0x82EC489C => {
    //   block [0x82EC489C..0x82EC48F8)
	// 82EC489C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC48A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC48A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EC48A8: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82EC48AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC48B0: 3BCB9128  addi r30, r11, -0x6ed8
	ctx.r[30].s64 = ctx.r[11].s64 + -28376;
	// 82EC48B4: 409A00C4  bne cr6, 0x82ec4978
	if !ctx.cr[6].eq {
	pc = 0x82EC4978; continue 'dispatch;
	}
	// 82EC48B8: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC48BC: 816A01B8  lwz r11, 0x1b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC48C0: 814A01BC  lwz r10, 0x1bc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC48C4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EC48C8: 419AFFCC  beq cr6, 0x82ec4894
	if ctx.cr[6].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC48CC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EC48D0: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48D4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC48D8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC48DC: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48E0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EC48E4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC48E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC48EC: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC48F0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC48F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC48F8; continue 'dispatch;
            }
            0x82EC48F8 => {
    //   block [0x82EC48F8..0x82EC493C)
	// 82EC48F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC48FC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4900: 4200FFF8  bdnz 0x82ec48f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC48F8; continue 'dispatch;
	}
	// 82EC4904: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4908: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EC490C: 9BA100B8  stb r29, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u8 ) };
	// 82EC4910: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82EC4914: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4918: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC491C: 93C10120  stw r30, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 82EC4920: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4924: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC4928: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC492C: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC4930: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4934: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC4938: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC493C; continue 'dispatch;
            }
            0x82EC493C => {
    //   block [0x82EC493C..0x82EC4978)
	// 82EC493C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4940: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4944: 4200FFF8  bdnz 0x82ec493c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC493C; continue 'dispatch;
	}
	// 82EC4948: 807F01C4  lwz r3, 0x1c4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82EC494C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC4950: 9BA10178  stb r29, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[29].u8 ) };
	// 82EC4954: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EC4958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC495C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4964: 4E800421  bctrl
	ctx.lr = 0x82EC4968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4968: 93810120  stw r28, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82EC496C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4970: 4082FF24  bne 0x82ec4894
	if !ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4974: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
            }
            0x82EC4978 => {
    //   block [0x82EC4978..0x82EC49CC)
	// 82EC4978: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC497C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4980: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EC4984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4988: 4E800421  bctrl
	ctx.lr = 0x82EC498C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC498C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4990: 4182FF04  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4994: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4998: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC499C: 4182FEF8  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC49A0: C01F0404  lfs f0, 0x404(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49A4: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82EC49A8: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC49AC: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82EC49B0: C01F0408  lfs f0, 0x408(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49B4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82EC49B8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC49BC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC49C0: C01F040C  lfs f0, 0x40c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC49C4: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC49C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
            }
            0x82EC49CC => {
    //   block [0x82EC49CC..0x82EC4A88)
	// 82EC49CC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC49D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC49D4: 4200FFF8  bdnz 0x82ec49cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC49CC; continue 'dispatch;
	}
	// 82EC49D8: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82EC49DC: 3BDF03A4  addi r30, r31, 0x3a4
	ctx.r[30].s64 = ctx.r[31].s64 + 932;
	// 82EC49E0: 9BA10118  stb r29, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[29].u8 ) };
	// 82EC49E4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EC49E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC49EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC49F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC49F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC49F8: 4E800421  bctrl
	ctx.lr = 0x82EC49FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC49FC: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4A00: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EC4A04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4A08: 4182FE8C  beq 0x82ec4894
	if ctx.cr[0].eq {
	pc = 0x82EC4894; continue 'dispatch;
	}
	// 82EC4A0C: 817F0390  lwz r11, 0x390(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4A10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EC4A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EC4A18: 419A007C  beq cr6, 0x82ec4a94
	if ctx.cr[6].eq {
	pc = 0x82EC4A94; continue 'dispatch;
	}
	// 82EC4A1C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EC4A20: 4B2E8031  bl 0x821aca50
	ctx.lr = 0x82EC4A24;
	sub_821ACA50(ctx, base);
	// 82EC4A24: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4A28: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4A2C: 39010180  addi r8, r1, 0x180
	ctx.r[8].s64 = ctx.r[1].s64 + 384;
	// 82EC4A30: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82EC4A34: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82EC4A38: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4A3C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4A40: 813F03A0  lwz r9, 0x3a0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4A44: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A4C: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC4A50: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4A54: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EC4A58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4A5C: 4E800421  bctrl
	ctx.lr = 0x82EC4A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4A60: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EC4A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EC4A68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4A6C: 4182001C  beq 0x82ec4a88
	if ctx.cr[0].eq {
	pc = 0x82EC4A88; continue 'dispatch;
	}
	// 82EC4A70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4A74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EC4A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4A7C: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC4A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4A84: 4E800421  bctrl
	ctx.lr = 0x82EC4A88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC4A88 => {
    //   block [0x82EC4A88..0x82EC4A94)
	// 82EC4A88: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4A8C: 40820028  bne 0x82ec4ab4
	if !ctx.cr[0].eq {
	pc = 0x82EC4AB4; continue 'dispatch;
	}
	// 82EC4A90: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	pc = 0x82EC4A94; continue 'dispatch;
            }
            0x82EC4A94 => {
    //   block [0x82EC4A94..0x82EC4AAC)
	// 82EC4A94: 807F0250  lwz r3, 0x250(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 82EC4A98: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EC4A9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4AA0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4AA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4AA8: 4E800421  bctrl
	ctx.lr = 0x82EC4AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC4AAC => {
    //   block [0x82EC4AAC..0x82EC4AB4)
	// 82EC4AAC: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82EC4AB0: 4BDE49A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EC4AB4 => {
    //   block [0x82EC4AB4..0x82EC4ABC)
	// 82EC4AB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EC4AB8: 4BFFFFF4  b 0x82ec4aac
	pc = 0x82EC4AAC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC4AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC4AC0 size=1372
    let mut pc: u32 = 0x82EC4AC0;
    'dispatch: loop {
        match pc {
            0x82EC4AC0 => {
    //   block [0x82EC4AC0..0x82EC4B58)
	// 82EC4AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC4AC4: 4BDE4931  bl 0x82ca93f4
	ctx.lr = 0x82EC4AC8;
	sub_82CA93D0(ctx, base);
	// 82EC4AC8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82EC4ACC: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC4AD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC4AD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4AD8: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4AE0: 4E800421  bctrl
	ctx.lr = 0x82EC4AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4AE4: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4AE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4AEC: 41820520  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4AF0: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4AF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4AF8: 41820060  beq 0x82ec4b58
	if ctx.cr[0].eq {
	pc = 0x82EC4B58; continue 'dispatch;
	}
	// 82EC4AFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B00: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4B04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4B08: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4B0C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4B10: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B14: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4B18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B1C: 4E800421  bctrl
	ctx.lr = 0x82EC4B20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B24: 418204E8  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4B28: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4B2C: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B30: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4B34: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4B38: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B40: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4B44: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4B48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B4C: 4E800421  bctrl
	ctx.lr = 0x82EC4B50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B54: 418204B8  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
            }
            0x82EC4B58 => {
    //   block [0x82EC4B58..0x82EC4B84)
	// 82EC4B58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EC4B60: 83DF0390  lwz r30, 0x390(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4B68: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EC4B6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4B70: 4E800421  bctrl
	ctx.lr = 0x82EC4B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4B74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4B78: 4082000C  bne 0x82ec4b84
	if !ctx.cr[0].eq {
	pc = 0x82EC4B84; continue 'dispatch;
	}
	// 82EC4B7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC4B80: 48000490  b 0x82ec5010
	pc = 0x82EC5010; continue 'dispatch;
            }
            0x82EC4B84 => {
    //   block [0x82EC4B84..0x82EC4BF4)
	// 82EC4B84: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4B88: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EC4B8C: 419A0068  beq cr6, 0x82ec4bf4
	if ctx.cr[6].eq {
	pc = 0x82EC4BF4; continue 'dispatch;
	}
	// 82EC4B90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82EC4B94: 419A0060  beq cr6, 0x82ec4bf4
	if ctx.cr[6].eq {
	pc = 0x82EC4BF4; continue 'dispatch;
	}
	// 82EC4B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4B9C: 815F039C  lwz r10, 0x39c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4BA0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4BA4: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4BA8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EC4BAC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BB0: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4BB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4BB8: 4E800421  bctrl
	ctx.lr = 0x82EC4BBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4BC0: 4182044C  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4BC4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4BC8: 807F0390  lwz r3, 0x390(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EC4BCC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4BD0: 80BF03A0  lwz r5, 0x3a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4BD4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4BDC: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4BE0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4BE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4BE8: 4E800421  bctrl
	ctx.lr = 0x82EC4BEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4BEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4BF0: 4182041C  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
            }
            0x82EC4BF4 => {
    //   block [0x82EC4BF4..0x82EC4C08)
	// 82EC4BF4: 897F0410  lbz r11, 0x410(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EC4BF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4BFC: 4182000C  beq 0x82ec4c08
	if ctx.cr[0].eq {
	pc = 0x82EC4C08; continue 'dispatch;
	}
	// 82EC4C00: C3FF0420  lfs f31, 0x420(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EC4C04: 48000014  b 0x82ec4c18
	pc = 0x82EC4C18; continue 'dispatch;
            }
            0x82EC4C08 => {
    //   block [0x82EC4C08..0x82EC4C18)
	// 82EC4C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EC4C0C: C1BF0420  lfs f13, 0x420(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1056 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4C10: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C14: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EC4C18; continue 'dispatch;
            }
            0x82EC4C18 => {
    //   block [0x82EC4C18..0x82EC4C40)
	// 82EC4C18: 4B39BDA1  bl 0x822609b8
	ctx.lr = 0x82EC4C1C;
	sub_822609B8(ctx, base);
	// 82EC4C1C: C01F0424  lfs f0, 0x424(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C20: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EC4C24: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4C28: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EC4C2C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4C30: 41980010  blt cr6, 0x82ec4c40
	if ctx.cr[6].lt {
	pc = 0x82EC4C40; continue 'dispatch;
	}
	// 82EC4C34: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC4C38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4C3C: 41820350  beq 0x82ec4f8c
	if ctx.cr[0].eq {
	pc = 0x82EC4F8C; continue 'dispatch;
	}
	pc = 0x82EC4C40; continue 'dispatch;
            }
            0x82EC4C40 => {
    //   block [0x82EC4C40..0x82EC4C88)
	// 82EC4C40: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4C44: D01F0424  stfs f0, 0x424(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), tmp.u32 ) };
	// 82EC4C48: 837F039C  lwz r27, 0x39c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4C4C: 82FF03A0  lwz r23, 0x3a0(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 82EC4C50: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4C54: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82EC4C58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4C5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4C64: 4E800421  bctrl
	ctx.lr = 0x82EC4C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4C68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4C6C: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82EC4C70: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC4C74: 418202A4  beq 0x82ec4f18
	if ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4C78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC4C7C: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82EC4C80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC4C84: 3B2B9F1C  addi r25, r11, -0x60e4
	ctx.r[25].s64 = ctx.r[11].s64 + -24804;
            }
            0x82EC4C88 => {
    //   block [0x82EC4C88..0x82EC4CA0)
	// 82EC4C88: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4C8C: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82EC4C90: 816B01BC  lwz r11, 0x1bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC4C94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC4C98: 419A0008  beq cr6, 0x82ec4ca0
	if ctx.cr[6].eq {
	pc = 0x82EC4CA0; continue 'dispatch;
	}
	// 82EC4C9C: 831EFFEC  lwz r24, -0x14(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) } as u64;
	pc = 0x82EC4CA0; continue 'dispatch;
            }
            0x82EC4CA0 => {
    //   block [0x82EC4CA0..0x82EC4CD4)
	// 82EC4CA0: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC4CA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4CA8: 4182002C  beq 0x82ec4cd4
	if ctx.cr[0].eq {
	pc = 0x82EC4CD4; continue 'dispatch;
	}
	// 82EC4CAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CB0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82EC4CB4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4CB8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CBC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EC4CC0: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4CC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4CC8: 4E800421  bctrl
	ctx.lr = 0x82EC4CCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4CCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4CD0: 41820248  beq 0x82ec4f18
	if ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
            }
            0x82EC4CD4 => {
    //   block [0x82EC4CD4..0x82EC4D0C)
	// 82EC4CD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4CD8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC4CDC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EC4CE0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4CE4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EC4CE8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4CEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EC4CF0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4CF4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC4CF8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4CFC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC4D00: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D04: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC4D08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC4D0C; continue 'dispatch;
            }
            0x82EC4D0C => {
    //   block [0x82EC4D0C..0x82EC4D50)
	// 82EC4D0C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4D10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4D14: 4200FFF8  bdnz 0x82ec4d0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4D0C; continue 'dispatch;
	}
	// 82EC4D18: 9B4100B8  stb r26, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u8 ) };
	// 82EC4D1C: C01F0338  lfs f0, 0x338(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D20: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4D28: 409A0028  bne cr6, 0x82ec4d50
	if !ctx.cr[6].eq {
	pc = 0x82EC4D50; continue 'dispatch;
	}
	// 82EC4D2C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D30: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4D38: 409A0018  bne cr6, 0x82ec4d50
	if !ctx.cr[6].eq {
	pc = 0x82EC4D50; continue 'dispatch;
	}
	// 82EC4D3C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC4D44: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4D48: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4D4C: 419A0008  beq cr6, 0x82ec4d54
	if ctx.cr[6].eq {
	pc = 0x82EC4D54; continue 'dispatch;
	}
	pc = 0x82EC4D50; continue 'dispatch;
            }
            0x82EC4D50 => {
    //   block [0x82EC4D50..0x82EC4D54)
	// 82EC4D50: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82EC4D54; continue 'dispatch;
            }
            0x82EC4D54 => {
    //   block [0x82EC4D54..0x82EC4D6C)
	// 82EC4D54: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4D58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EC4D5C: 41820010  beq 0x82ec4d6c
	if ctx.cr[0].eq {
	pc = 0x82EC4D6C; continue 'dispatch;
	}
	// 82EC4D60: 389F02D8  addi r4, r31, 0x2d8
	ctx.r[4].s64 = ctx.r[31].s64 + 728;
	// 82EC4D64: 4BFAB195  bl 0x82e6fef8
	ctx.lr = 0x82EC4D68;
	sub_82E6FEF8(ctx, base);
	// 82EC4D68: 4800000C  b 0x82ec4d74
	pc = 0x82EC4D74; continue 'dispatch;
            }
            0x82EC4D6C => {
    //   block [0x82EC4D6C..0x82EC4D74)
	// 82EC4D6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC4D70: 4B2E9939  bl 0x821ae6a8
	ctx.lr = 0x82EC4D74;
	sub_821AE6A8(ctx, base);
	pc = 0x82EC4D74; continue 'dispatch;
            }
            0x82EC4D74 => {
    //   block [0x82EC4D74..0x82EC4DB0)
	// 82EC4D74: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4D78: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82EC4D7C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82EC4D80: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4D84: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4D88: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82EC4D8C: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 82EC4D90: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EC4D94: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4D98: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC4D9C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DA0: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC4DA4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DA8: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC4DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC4DB0; continue 'dispatch;
            }
            0x82EC4DB0 => {
    //   block [0x82EC4DB0..0x82EC4DD8)
	// 82EC4DB0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC4DB4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC4DB8: 4200FFF8  bdnz 0x82ec4db0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4DB0; continue 'dispatch;
	}
	// 82EC4DBC: 9B410118  stb r26, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[26].u8 ) };
	// 82EC4DC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4DC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC4DC8: 419A0010  beq cr6, 0x82ec4dd8
	if ctx.cr[6].eq {
	pc = 0x82EC4DD8; continue 'dispatch;
	}
	// 82EC4DCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82EC4DD0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EC4DD4: 4B2E98D5  bl 0x821ae6a8
	ctx.lr = 0x82EC4DD8;
	sub_821AE6A8(ctx, base);
	pc = 0x82EC4DD8; continue 'dispatch;
            }
            0x82EC4DD8 => {
    //   block [0x82EC4DD8..0x82EC4E0C)
	// 82EC4DD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4DDC: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82EC4DE0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4DE4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4DE8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4DEC: 93A10180  stw r29, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[29].u32 ) };
	// 82EC4DF0: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DF4: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EC4DF8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4DFC: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EC4E00: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E04: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EC4E08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC4E0C; continue 'dispatch;
            }
            0x82EC4E0C => {
    //   block [0x82EC4E0C..0x82EC4E84)
	// 82EC4E0C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4E10: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4E14: 4200FFF8  bdnz 0x82ec4e0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4E0C; continue 'dispatch;
	}
	// 82EC4E18: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4E1C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC4E20: 9B4101D8  stb r26, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[26].u8 ) };
	// 82EC4E24: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EC4E28: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC4E2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4E30: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EC4E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4E38: 4E800421  bctrl
	ctx.lr = 0x82EC4E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4E3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4E40: 93810180  stw r28, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[28].u32 ) };
	// 82EC4E44: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC4E48: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4E4C: 408200BC  bne 0x82ec4f08
	if !ctx.cr[0].eq {
	pc = 0x82EC4F08; continue 'dispatch;
	}
	// 82EC4E50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC4E54: 39210130  addi r9, r1, 0x130
	ctx.r[9].s64 = ctx.r[1].s64 + 304;
	// 82EC4E58: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EC4E5C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC4E60: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4E64: 93A10120  stw r29, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[29].u32 ) };
	// 82EC4E68: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E6C: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC4E70: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E74: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC4E78: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4E7C: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC4E80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
            }
            0x82EC4E84 => {
    //   block [0x82EC4E84..0x82EC4F08)
	// 82EC4E84: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC4E88: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC4E8C: 4200FFF8  bdnz 0x82ec4e84
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4E84; continue 'dispatch;
	}
	// 82EC4E90: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4E94: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EC4E98: 9B410178  stb r26, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[26].u8 ) };
	// 82EC4E9C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82EC4EA0: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82EC4EA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4EA8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EC4EAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4EB0: 4E800421  bctrl
	ctx.lr = 0x82EC4EB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4EB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EC4EB8: 93810120  stw r28, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82EC4EBC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC4EC0: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4EC4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EC4EC8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4ECC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82EC4ED0: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC4ED4: 40820044  bne 0x82ec4f18
	if !ctx.cr[0].eq {
	pc = 0x82EC4F18; continue 'dispatch;
	}
	// 82EC4ED8: 807F0200  lwz r3, 0x200(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 82EC4EDC: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82EC4EE0: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC4EE4: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 82EC4EE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EC4EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4EF0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC4EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4EF8: 4E800421  bctrl
	ctx.lr = 0x82EC4EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC4EFC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EC4F00: 4082FD88  bne 0x82ec4c88
	if !ctx.cr[0].eq {
	pc = 0x82EC4C88; continue 'dispatch;
	}
	// 82EC4F04: 48000014  b 0x82ec4f18
	pc = 0x82EC4F18; continue 'dispatch;
            }
            0x82EC4F08 => {
    //   block [0x82EC4F08..0x82EC4F18)
	// 82EC4F08: 938100C0  stw r28, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u32 ) };
	// 82EC4F0C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82EC4F10: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EC4F14: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82EC4F18; continue 'dispatch;
            }
            0x82EC4F18 => {
    //   block [0x82EC4F18..0x82EC4F54)
	// 82EC4F18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82EC4F1C: 419A0070  beq cr6, 0x82ec4f8c
	if ctx.cr[6].eq {
	pc = 0x82EC4F8C; continue 'dispatch;
	}
	// 82EC4F20: 937F039C  stw r27, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[27].u32 ) };
	// 82EC4F24: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 82EC4F28: 92FF03A0  stw r23, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[23].u32 ) };
	// 82EC4F2C: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F30: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EC4F34: 93A101E0  stw r29, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 82EC4F38: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F3C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82EC4F40: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EC4F44: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC4F48: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4F4C: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EC4F50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EC4F54; continue 'dispatch;
            }
            0x82EC4F54 => {
    //   block [0x82EC4F54..0x82EC4F8C)
	// 82EC4F54: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC4F58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC4F5C: 4200FFF8  bdnz 0x82ec4f54
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC4F54; continue 'dispatch;
	}
	// 82EC4F60: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82EC4F64: 9B410238  stb r26, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[26].u8 ) };
	// 82EC4F68: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC4F6C: 4BFAAF8D  bl 0x82e6fef8
	ctx.lr = 0x82EC4F70;
	sub_82E6FEF8(ctx, base);
	// 82EC4F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC4F74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC4F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC4F7C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC4F80: 995F0400  stb r10, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u8 ) };
	// 82EC4F84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC4F88: 4E800421  bctrl
	ctx.lr = 0x82EC4F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC4F8C => {
    //   block [0x82EC4F8C..0x82EC4FD0)
	// 82EC4F8C: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC4F90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC4F94: 41820078  beq 0x82ec500c
	if ctx.cr[0].eq {
	pc = 0x82EC500C; continue 'dispatch;
	}
	// 82EC4F98: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC4F9C: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FA0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC4FA8: 409A0028  bne cr6, 0x82ec4fd0
	if !ctx.cr[6].eq {
	pc = 0x82EC4FD0; continue 'dispatch;
	}
	// 82EC4FAC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FB0: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4FB8: 409A0018  bne cr6, 0x82ec4fd0
	if !ctx.cr[6].eq {
	pc = 0x82EC4FD0; continue 'dispatch;
	}
	// 82EC4FBC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FC0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82EC4FC4: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC4FC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC4FCC: 419A0008  beq cr6, 0x82ec4fd4
	if ctx.cr[6].eq {
	pc = 0x82EC4FD4; continue 'dispatch;
	}
	pc = 0x82EC4FD0; continue 'dispatch;
            }
            0x82EC4FD0 => {
    //   block [0x82EC4FD0..0x82EC4FD4)
	// 82EC4FD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82EC4FD4; continue 'dispatch;
            }
            0x82EC4FD4 => {
    //   block [0x82EC4FD4..0x82EC4FF4)
	// 82EC4FD4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC4FD8: 4182001C  beq 0x82ec4ff4
	if ctx.cr[0].eq {
	pc = 0x82EC4FF4; continue 'dispatch;
	}
	// 82EC4FDC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FE0: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC4FE4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FE8: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC4FEC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FF0: 48000018  b 0x82ec5008
	pc = 0x82EC5008; continue 'dispatch;
            }
            0x82EC4FF4 => {
    //   block [0x82EC4FF4..0x82EC5008)
	// 82EC4FF4: C01F02DC  lfs f0, 0x2dc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC4FF8: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC4FFC: C01F02E0  lfs f0, 0x2e0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5000: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC5004: C01F02E4  lfs f0, 0x2e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EC5008; continue 'dispatch;
            }
            0x82EC5008 => {
    //   block [0x82EC5008..0x82EC500C)
	// 82EC5008: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	pc = 0x82EC500C; continue 'dispatch;
            }
            0x82EC500C => {
    //   block [0x82EC500C..0x82EC5010)
	// 82EC500C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC5010; continue 'dispatch;
            }
            0x82EC5010 => {
    //   block [0x82EC5010..0x82EC501C)
	// 82EC5010: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 82EC5014: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EC5018: 4BDE442C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC5020 size=196
    let mut pc: u32 = 0x82EC5020;
    'dispatch: loop {
        match pc {
            0x82EC5020 => {
    //   block [0x82EC5020..0x82EC5060)
	// 82EC5020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5028: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC502C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC5030: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5034: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EC5038: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82EC503C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC5040: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5044: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EC5048: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC504C: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5050: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC5054: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EC5058: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EC505C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC5060; continue 'dispatch;
            }
            0x82EC5060 => {
    //   block [0x82EC5060..0x82EC509C)
	// 82EC5060: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC5064: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC5068: 4200FFF8  bdnz 0x82ec5060
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5060; continue 'dispatch;
	}
	// 82EC506C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5070: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EC5074: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC5078: 99010108  stb r8, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[8].u8 ) };
	// 82EC507C: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5080: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82EC5084: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC5088: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82EC508C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5090: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC5094: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC5098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EC509C; continue 'dispatch;
            }
            0x82EC509C => {
    //   block [0x82EC509C..0x82EC50E4)
	// 82EC509C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC50A0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC50A4: 4200FFF8  bdnz 0x82ec509c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC509C; continue 'dispatch;
	}
	// 82EC50A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC50AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EC50B0: 81630228  lwz r11, 0x228(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(552 as u32) ) } as u64;
	// 82EC50B4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EC50B8: 990100A8  stb r8, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u8 ) };
	// 82EC50BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82EC50C0: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC50C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC50C8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC50CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC50D0: 4E800421  bctrl
	ctx.lr = 0x82EC50D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC50D4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82EC50D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC50DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC50E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC50E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC50E8 size=292
    let mut pc: u32 = 0x82EC50E8;
    'dispatch: loop {
        match pc {
            0x82EC50E8 => {
    //   block [0x82EC50E8..0x82EC5118)
	// 82EC50E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC50EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC50F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EC50F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC50F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC50FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5100: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EC5104: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5108: 40820010  bne 0x82ec5118
	if !ctx.cr[0].eq {
	pc = 0x82EC5118; continue 'dispatch;
	}
	// 82EC510C: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5110: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5114: 419A00E0  beq cr6, 0x82ec51f4
	if ctx.cr[6].eq {
	pc = 0x82EC51F4; continue 'dispatch;
	}
	pc = 0x82EC5118; continue 'dispatch;
            }
            0x82EC5118 => {
    //   block [0x82EC5118..0x82EC5150)
	// 82EC5118: 897F0435  lbz r11, 0x435(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1077 as u32) ) } as u64;
	// 82EC511C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EC5120: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5124: 4082002C  bne 0x82ec5150
	if !ctx.cr[0].eq {
	pc = 0x82EC5150; continue 'dispatch;
	}
	// 82EC5128: 897F0434  lbz r11, 0x434(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1076 as u32) ) } as u64;
	// 82EC512C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5130: 409A0020  bne cr6, 0x82ec5150
	if !ctx.cr[6].eq {
	pc = 0x82EC5150; continue 'dispatch;
	}
	// 82EC5134: 38DF03A0  addi r6, r31, 0x3a0
	ctx.r[6].s64 = ctx.r[31].s64 + 928;
	// 82EC5138: 38BF039C  addi r5, r31, 0x39c
	ctx.r[5].s64 = ctx.r[31].s64 + 924;
	// 82EC513C: 389F0428  addi r4, r31, 0x428
	ctx.r[4].s64 = ctx.r[31].s64 + 1064;
	// 82EC5140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5144: 4BFFF215  bl 0x82ec4358
	ctx.lr = 0x82EC5148;
	sub_82EC4358(ctx, base);
	// 82EC5148: 987F0400  stb r3, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[3].u8 ) };
	// 82EC514C: 48000008  b 0x82ec5154
	pc = 0x82EC5154; continue 'dispatch;
            }
            0x82EC5150 => {
    //   block [0x82EC5150..0x82EC5154)
	// 82EC5150: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	pc = 0x82EC5154; continue 'dispatch;
            }
            0x82EC5154 => {
    //   block [0x82EC5154..0x82EC5188)
	// 82EC5154: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5158: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC515C: 4082002C  bne 0x82ec5188
	if !ctx.cr[0].eq {
	pc = 0x82EC5188; continue 'dispatch;
	}
	// 82EC5160: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC5164: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82EC5168: 812B01BC  lwz r9, 0x1bc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(444 as u32) ) } as u64;
	// 82EC516C: 915F03A0  stw r10, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[10].u32 ) };
	// 82EC5170: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5174: 913F039C  stw r9, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[9].u32 ) };
	// 82EC5178: 816B01B8  lwz r11, 0x1b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC517C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EC5180: 409A0008  bne cr6, 0x82ec5188
	if !ctx.cr[6].eq {
	pc = 0x82EC5188; continue 'dispatch;
	}
	// 82EC5184: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	pc = 0x82EC5188; continue 'dispatch;
            }
            0x82EC5188 => {
    //   block [0x82EC5188..0x82EC51D0)
	// 82EC5188: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC518C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5190: 41820060  beq 0x82ec51f0
	if ctx.cr[0].eq {
	pc = 0x82EC51F0; continue 'dispatch;
	}
	// 82EC5194: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EC5198: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC519C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82EC51A0: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EC51A4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82EC51A8: 98FF0400  stb r7, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[7].u8 ) };
	// 82EC51AC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51B0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EC51B4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51B8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EC51BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EC51C0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC51C4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC51C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EC51CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC51D0; continue 'dispatch;
            }
            0x82EC51D0 => {
    //   block [0x82EC51D0..0x82EC51F0)
	// 82EC51D0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC51D4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC51D8: 4200FFF8  bdnz 0x82ec51d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC51D0; continue 'dispatch;
	}
	// 82EC51DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EC51E0: 9BC100A8  stb r30, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u8 ) };
	// 82EC51E4: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC51E8: 4BFAAD11  bl 0x82e6fef8
	ctx.lr = 0x82EC51EC;
	sub_82E6FEF8(ctx, base);
	// 82EC51EC: 48000008  b 0x82ec51f4
	pc = 0x82EC51F4; continue 'dispatch;
            }
            0x82EC51F0 => {
    //   block [0x82EC51F0..0x82EC51F4)
	// 82EC51F0: 9BDF0400  stb r30, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	pc = 0x82EC51F4; continue 'dispatch;
            }
            0x82EC51F4 => {
    //   block [0x82EC51F4..0x82EC520C)
	// 82EC51F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EC51F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC51FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5200: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EC5204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EC5210 size=752
    let mut pc: u32 = 0x82EC5210;
    'dispatch: loop {
        match pc {
            0x82EC5210 => {
    //   block [0x82EC5210..0x82EC5284)
	// 82EC5210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5214: 4BDE41F1  bl 0x82ca9404
	ctx.lr = 0x82EC5218;
	sub_82CA93D0(ctx, base);
	// 82EC5218: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC521C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5220: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EC5224: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82EC5228: 897F0400  lbz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC522C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5230: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EC5234: 409A02C0  bne cr6, 0x82ec54f4
	if !ctx.cr[6].eq {
	pc = 0x82EC54F4; continue 'dispatch;
	}
	// 82EC5238: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EC523C: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC5240: 3B8B0014  addi r28, r11, 0x14
	ctx.r[28].s64 = ctx.r[11].s64 + 20;
	// 82EC5244: 814A01B8  lwz r10, 0x1b8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(440 as u32) ) } as u64;
	// 82EC5248: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EC524C: 409A0108  bne cr6, 0x82ec5354
	if !ctx.cr[6].eq {
	pc = 0x82EC5354; continue 'dispatch;
	}
	// 82EC5250: C01F0338  lfs f0, 0x338(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5254: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC5258: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EC525C: 409A0028  bne cr6, 0x82ec5284
	if !ctx.cr[6].eq {
	pc = 0x82EC5284; continue 'dispatch;
	}
	// 82EC5260: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5264: C1BF033C  lfs f13, 0x33c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC5268: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC526C: 409A0018  bne cr6, 0x82ec5284
	if !ctx.cr[6].eq {
	pc = 0x82EC5284; continue 'dispatch;
	}
	// 82EC5270: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5274: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82EC5278: C1BF0340  lfs f13, 0x340(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EC527C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EC5280: 419A0008  beq cr6, 0x82ec5288
	if ctx.cr[6].eq {
	pc = 0x82EC5288; continue 'dispatch;
	}
	pc = 0x82EC5284; continue 'dispatch;
            }
            0x82EC5284 => {
    //   block [0x82EC5284..0x82EC5288)
	// 82EC5284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82EC5288; continue 'dispatch;
            }
            0x82EC5288 => {
    //   block [0x82EC5288..0x82EC52C4)
	// 82EC5288: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EC528C: 418200B4  beq 0x82ec5340
	if ctx.cr[0].eq {
	pc = 0x82EC5340; continue 'dispatch;
	}
	// 82EC5290: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC5294: 39010130  addi r8, r1, 0x130
	ctx.r[8].s64 = ctx.r[1].s64 + 304;
	// 82EC5298: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EC529C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82EC52A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EC52A4: 91410120  stw r10, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 82EC52A8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52AC: D0010124  stfs f0, 0x124(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82EC52B0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52B4: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82EC52B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52BC: D001012C  stfs f0, 0x12c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82EC52C0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82EC52C4; continue 'dispatch;
            }
            0x82EC52C4 => {
    //   block [0x82EC52C4..0x82EC5308)
	// 82EC52C4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EC52C8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EC52CC: 4200FFF8  bdnz 0x82ec52c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC52C4; continue 'dispatch;
	}
	// 82EC52D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC52D4: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82EC52D8: 9B610178  stb r27, 0x178(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[27].u8 ) };
	// 82EC52DC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC52E0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC52E4: 91410180  stw r10, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[10].u32 ) };
	// 82EC52E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC52EC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52F0: D0010184  stfs f0, 0x184(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82EC52F4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC52F8: D0010188  stfs f0, 0x188(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82EC52FC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5300: D001018C  stfs f0, 0x18c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 82EC5304: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC5308; continue 'dispatch;
            }
            0x82EC5308 => {
    //   block [0x82EC5308..0x82EC5340)
	// 82EC5308: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC530C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC5310: 4200FFF8  bdnz 0x82ec5308
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5308; continue 'dispatch;
	}
	// 82EC5314: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EC5318: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 82EC531C: 9B6101D8  stb r27, 0x1d8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[27].u8 ) };
	// 82EC5320: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EC5324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5328: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC532C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5330: 4E800421  bctrl
	ctx.lr = 0x82EC5334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC5334: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5338: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EC533C: 40820008  bne 0x82ec5344
	if !ctx.cr[0].eq {
	pc = 0x82EC5344; continue 'dispatch;
	}
            }
            0x82EC5340 => {
    //   block [0x82EC5340..0x82EC5344)
	// 82EC5340: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82EC5344; continue 'dispatch;
            }
            0x82EC5344 => {
    //   block [0x82EC5344..0x82EC5354)
	// 82EC5344: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC5348: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EC534C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EC5350: 480001A8  b 0x82ec54f8
	pc = 0x82EC54F8; continue 'dispatch;
            }
            0x82EC5354 => {
    //   block [0x82EC5354..0x82EC5394)
	// 82EC5354: 548A063E  clrlwi r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82EC5358: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82EC535C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EC5360: 3BAA9128  addi r29, r10, -0x6ed8
	ctx.r[29].s64 = ctx.r[10].s64 + -28376;
	// 82EC5364: 419A00B0  beq cr6, 0x82ec5414
	if ctx.cr[6].eq {
	pc = 0x82EC5414; continue 'dispatch;
	}
	// 82EC5368: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82EC536C: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5370: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EC5374: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EC5378: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC537C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC5380: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EC5384: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC5388: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC538C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EC5390: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC5394; continue 'dispatch;
            }
            0x82EC5394 => {
    //   block [0x82EC5394..0x82EC53D8)
	// 82EC5394: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC5398: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC539C: 4200FFF8  bdnz 0x82ec5394
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5394; continue 'dispatch;
	}
	// 82EC53A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EC53A4: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 82EC53A8: 9B6100B8  stb r27, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[27].u8 ) };
	// 82EC53AC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EC53B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EC53B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC53B8: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 82EC53BC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53C0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EC53C4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53C8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EC53CC: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC53D0: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EC53D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EC53D8; continue 'dispatch;
            }
            0x82EC53D8 => {
    //   block [0x82EC53D8..0x82EC5414)
	// 82EC53D8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EC53DC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EC53E0: 4200FFF8  bdnz 0x82ec53d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC53D8; continue 'dispatch;
	}
	// 82EC53E4: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EC53E8: 3BC0000C  li r30, 0xc
	ctx.r[30].s64 = 12;
	// 82EC53EC: 9B610118  stb r27, 0x118(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[27].u8 ) };
	// 82EC53F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EC53F4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82EC53F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC53FC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EC5400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EC5404: 4E800421  bctrl
	ctx.lr = 0x82EC5408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EC5408: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC540C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EC5410: 41820008  beq 0x82ec5418
	if ctx.cr[0].eq {
	pc = 0x82EC5418; continue 'dispatch;
	}
            }
            0x82EC5414 => {
    //   block [0x82EC5414..0x82EC5418)
	// 82EC5414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EC5418; continue 'dispatch;
            }
            0x82EC5418 => {
    //   block [0x82EC5418..0x82EC5434)
	// 82EC5418: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EC541C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EC5420: 57C90739  rlwinm. r9, r30, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC5424: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EC5428: 4182000C  beq 0x82ec5434
	if ctx.cr[0].eq {
	pc = 0x82EC5434; continue 'dispatch;
	}
	// 82EC542C: 57DE0776  rlwinm r30, r30, 0, 0x1d, 0x1b
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82EC5430: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5434; continue 'dispatch;
            }
            0x82EC5434 => {
    //   block [0x82EC5434..0x82EC5440)
	// 82EC5434: 57C9077B  rlwinm. r9, r30, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EC5438: 41820008  beq 0x82ec5440
	if ctx.cr[0].eq {
	pc = 0x82EC5440; continue 'dispatch;
	}
	// 82EC543C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5440; continue 'dispatch;
            }
            0x82EC5440 => {
    //   block [0x82EC5440..0x82EC5484)
	// 82EC5440: 554B063F  clrlwi. r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5444: 418200B0  beq 0x82ec54f4
	if ctx.cr[0].eq {
	pc = 0x82EC54F4; continue 'dispatch;
	}
	// 82EC5448: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC544C: 394101F0  addi r10, r1, 0x1f0
	ctx.r[10].s64 = ctx.r[1].s64 + 496;
	// 82EC5450: 93A101E0  stw r29, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[29].u32 ) };
	// 82EC5454: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EC5458: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC545C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82EC5460: 939F039C  stw r28, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[28].u32 ) };
	// 82EC5464: 911F03A0  stw r8, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[8].u32 ) };
	// 82EC5468: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC546C: D00101E4  stfs f0, 0x1e4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82EC5470: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC5474: D00101E8  stfs f0, 0x1e8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 82EC5478: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC547C: D00101EC  stfs f0, 0x1ec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 82EC5480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82EC5484; continue 'dispatch;
            }
            0x82EC5484 => {
    //   block [0x82EC5484..0x82EC54D8)
	// 82EC5484: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5488: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82EC548C: 4200FFF8  bdnz 0x82ec5484
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EC5484; continue 'dispatch;
	}
	// 82EC5490: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82EC5494: 9B610238  stb r27, 0x238(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), ctx.r[27].u8 ) };
	// 82EC5498: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 82EC549C: 4BFAAA5D  bl 0x82e6fef8
	ctx.lr = 0x82EC54A0;
	sub_82E6FEF8(ctx, base);
	// 82EC54A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EC54A4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC54A8: 995F0400  stb r10, 0x400(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[10].u8 ) };
	// 82EC54AC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54B0: D01F0404  stfs f0, 0x404(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), tmp.u32 ) };
	// 82EC54B4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54B8: D01F0408  stfs f0, 0x408(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1032 as u32), tmp.u32 ) };
	// 82EC54BC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EC54C0: D01F040C  stfs f0, 0x40c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1036 as u32), tmp.u32 ) };
	// 82EC54C4: 817F039C  lwz r11, 0x39c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EC54C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC54CC: 4182000C  beq 0x82ec54d8
	if ctx.cr[0].eq {
	pc = 0x82EC54D8; continue 'dispatch;
	}
	// 82EC54D0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EC54D4: 48000008  b 0x82ec54dc
	pc = 0x82EC54DC; continue 'dispatch;
            }
            0x82EC54D8 => {
    //   block [0x82EC54D8..0x82EC54DC)
	// 82EC54D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x82EC54DC; continue 'dispatch;
            }
            0x82EC54DC => {
    //   block [0x82EC54DC..0x82EC54F4)
	// 82EC54DC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC54E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC54E4: 917F0390  stw r11, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EC54E8: 814A0064  lwz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EC54EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82EC54F0: 4E800421  bctrl
	ctx.lr = 0x82EC54F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EC54F4 => {
    //   block [0x82EC54F4..0x82EC54F8)
	// 82EC54F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC54F8; continue 'dispatch;
            }
            0x82EC54F8 => {
    //   block [0x82EC54F8..0x82EC5500)
	// 82EC54F8: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82EC54FC: 4BDE3F58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5500 size=200
    let mut pc: u32 = 0x82EC5500;
    'dispatch: loop {
        match pc {
            0x82EC5500 => {
    //   block [0x82EC5500..0x82EC5534)
	// 82EC5500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC550C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5510: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5514: 4BFF6315  bl 0x82ebb828
	ctx.lr = 0x82EC5518;
	sub_82EBB828(ctx, base);
	// 82EC5518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC551C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5520: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5524: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5528: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC552C: 40810054  ble 0x82ec5580
	if !ctx.cr[0].gt {
	pc = 0x82EC5580; continue 'dispatch;
	}
	// 82EC5530: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC5534; continue 'dispatch;
            }
            0x82EC5534 => {
    //   block [0x82EC5534..0x82EC5540)
	// 82EC5534: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5538: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC553C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC5540; continue 'dispatch;
            }
            0x82EC5540 => {
    //   block [0x82EC5540..0x82EC5564)
	// 82EC5540: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5544: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5548: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC554C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5550: 41820014  beq 0x82ec5564
	if ctx.cr[0].eq {
	pc = 0x82EC5564; continue 'dispatch;
	}
	// 82EC5554: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5558: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC555C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5560: 419AFFE0  beq cr6, 0x82ec5540
	if ctx.cr[6].eq {
	pc = 0x82EC5540; continue 'dispatch;
	}
	pc = 0x82EC5564; continue 'dispatch;
            }
            0x82EC5564 => {
    //   block [0x82EC5564..0x82EC5580)
	// 82EC5564: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5568: 41820028  beq 0x82ec5590
	if ctx.cr[0].eq {
	pc = 0x82EC5590; continue 'dispatch;
	}
	// 82EC556C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5570: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5574: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5578: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC557C: 4198FFB8  blt cr6, 0x82ec5534
	if ctx.cr[6].lt {
	pc = 0x82EC5534; continue 'dispatch;
	}
	pc = 0x82EC5580; continue 'dispatch;
            }
            0x82EC5580 => {
    //   block [0x82EC5580..0x82EC5590)
	// 82EC5580: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5584: 409A0018  bne cr6, 0x82ec559c
	if !ctx.cr[6].eq {
	pc = 0x82EC559C; continue 'dispatch;
	}
	// 82EC5588: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC558C: 48000028  b 0x82ec55b4
	pc = 0x82EC55B4; continue 'dispatch;
            }
            0x82EC5590 => {
    //   block [0x82EC5590..0x82EC559C)
	// 82EC5590: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5594: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5598: 48000018  b 0x82ec55b0
	pc = 0x82EC55B0; continue 'dispatch;
            }
            0x82EC559C => {
    //   block [0x82EC559C..0x82EC55B0)
	// 82EC559C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC55A0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC55A4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC55A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC55AC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC55B0; continue 'dispatch;
            }
            0x82EC55B0 => {
    //   block [0x82EC55B0..0x82EC55B4)
	// 82EC55B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC55B4; continue 'dispatch;
            }
            0x82EC55B4 => {
    //   block [0x82EC55B4..0x82EC55C8)
	// 82EC55B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC55B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC55BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC55C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC55C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC55C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC55C8 size=196
    let mut pc: u32 = 0x82EC55C8;
    'dispatch: loop {
        match pc {
            0x82EC55C8 => {
    //   block [0x82EC55C8..0x82EC5600)
	// 82EC55C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC55CC: 4BDE3E39  bl 0x82ca9404
	ctx.lr = 0x82EC55D0;
	sub_82CA93D0(ctx, base);
	// 82EC55D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC55D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC55D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC55DC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC55E0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC55E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC55E8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC55EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC55F0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC55F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC55F8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC55FC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC5600; continue 'dispatch;
            }
            0x82EC5600 => {
    //   block [0x82EC5600..0x82EC562C)
	// 82EC5600: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5604: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5608: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC560C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5610: 4082FFF0  bne 0x82ec5600
	if !ctx.cr[0].eq {
	pc = 0x82EC5600; continue 'dispatch;
	}
	// 82EC5614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5618: 4BFFFEE9  bl 0x82ec5500
	ctx.lr = 0x82EC561C;
	sub_82EC5500(ctx, base);
	// 82EC561C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5620: 4082000C  bne 0x82ec562c
	if !ctx.cr[0].eq {
	pc = 0x82EC562C; continue 'dispatch;
	}
	// 82EC5624: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5628: 48000010  b 0x82ec5638
	pc = 0x82EC5638; continue 'dispatch;
            }
            0x82EC562C => {
    //   block [0x82EC562C..0x82EC5638)
	// 82EC562C: 4BFF61FD  bl 0x82ebb828
	ctx.lr = 0x82EC5630;
	sub_82EBB828(ctx, base);
	// 82EC5630: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5634: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC5638; continue 'dispatch;
            }
            0x82EC5638 => {
    //   block [0x82EC5638..0x82EC565C)
	// 82EC5638: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC563C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5640: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5644: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5648: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC564C: 409A0010  bne cr6, 0x82ec565c
	if !ctx.cr[6].eq {
	pc = 0x82EC565C; continue 'dispatch;
	}
	// 82EC5650: 4BFBA409  bl 0x82e7fa58
	ctx.lr = 0x82EC5654;
	sub_82E7FA58(ctx, base);
	// 82EC5654: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5658: 4800000C  b 0x82ec5664
	pc = 0x82EC5664; continue 'dispatch;
            }
            0x82EC565C => {
    //   block [0x82EC565C..0x82EC5664)
	// 82EC565C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5660: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5664; continue 'dispatch;
            }
            0x82EC5664 => {
    //   block [0x82EC5664..0x82EC5680)
	// 82EC5664: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5668: 41820018  beq 0x82ec5680
	if ctx.cr[0].eq {
	pc = 0x82EC5680; continue 'dispatch;
	}
	// 82EC566C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5670: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5674: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5678: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC567C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5680; continue 'dispatch;
            }
            0x82EC5680 => {
    //   block [0x82EC5680..0x82EC568C)
	// 82EC5680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5684: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5688: 4BDE3DCC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5690 size=68
    let mut pc: u32 = 0x82EC5690;
    'dispatch: loop {
        match pc {
            0x82EC5690 => {
    //   block [0x82EC5690..0x82EC56D4)
	// 82EC5690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC569C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC56A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC56A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC56A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC56AC: 4BFFFF1D  bl 0x82ec55c8
	ctx.lr = 0x82EC56B0;
	sub_82EC55C8(ctx, base);
	// 82EC56B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC56B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC56B8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC56BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC56C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC56C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC56C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC56CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC56D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC56D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC56D8 size=200
    let mut pc: u32 = 0x82EC56D8;
    'dispatch: loop {
        match pc {
            0x82EC56D8 => {
    //   block [0x82EC56D8..0x82EC570C)
	// 82EC56D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC56DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC56E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC56E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC56E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC56EC: 4BFF604D  bl 0x82ebb738
	ctx.lr = 0x82EC56F0;
	sub_82EBB738(ctx, base);
	// 82EC56F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC56F4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC56F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC56FC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5700: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5704: 40810054  ble 0x82ec5758
	if !ctx.cr[0].gt {
	pc = 0x82EC5758; continue 'dispatch;
	}
	// 82EC5708: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC570C; continue 'dispatch;
            }
            0x82EC570C => {
    //   block [0x82EC570C..0x82EC5718)
	// 82EC570C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5710: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5714: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC5718; continue 'dispatch;
            }
            0x82EC5718 => {
    //   block [0x82EC5718..0x82EC573C)
	// 82EC5718: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC571C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5720: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5724: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5728: 41820014  beq 0x82ec573c
	if ctx.cr[0].eq {
	pc = 0x82EC573C; continue 'dispatch;
	}
	// 82EC572C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5730: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5734: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5738: 419AFFE0  beq cr6, 0x82ec5718
	if ctx.cr[6].eq {
	pc = 0x82EC5718; continue 'dispatch;
	}
	pc = 0x82EC573C; continue 'dispatch;
            }
            0x82EC573C => {
    //   block [0x82EC573C..0x82EC5758)
	// 82EC573C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5740: 41820028  beq 0x82ec5768
	if ctx.cr[0].eq {
	pc = 0x82EC5768; continue 'dispatch;
	}
	// 82EC5744: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5748: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC574C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5750: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5754: 4198FFB8  blt cr6, 0x82ec570c
	if ctx.cr[6].lt {
	pc = 0x82EC570C; continue 'dispatch;
	}
	pc = 0x82EC5758; continue 'dispatch;
            }
            0x82EC5758 => {
    //   block [0x82EC5758..0x82EC5768)
	// 82EC5758: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC575C: 409A0018  bne cr6, 0x82ec5774
	if !ctx.cr[6].eq {
	pc = 0x82EC5774; continue 'dispatch;
	}
	// 82EC5760: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5764: 48000028  b 0x82ec578c
	pc = 0x82EC578C; continue 'dispatch;
            }
            0x82EC5768 => {
    //   block [0x82EC5768..0x82EC5774)
	// 82EC5768: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC576C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5770: 48000018  b 0x82ec5788
	pc = 0x82EC5788; continue 'dispatch;
            }
            0x82EC5774 => {
    //   block [0x82EC5774..0x82EC5788)
	// 82EC5774: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5778: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC577C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5780: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5784: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5788; continue 'dispatch;
            }
            0x82EC5788 => {
    //   block [0x82EC5788..0x82EC578C)
	// 82EC5788: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC578C; continue 'dispatch;
            }
            0x82EC578C => {
    //   block [0x82EC578C..0x82EC57A0)
	// 82EC578C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC579C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC57A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC57A0 size=196
    let mut pc: u32 = 0x82EC57A0;
    'dispatch: loop {
        match pc {
            0x82EC57A0 => {
    //   block [0x82EC57A0..0x82EC57D8)
	// 82EC57A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC57A4: 4BDE3C61  bl 0x82ca9404
	ctx.lr = 0x82EC57A8;
	sub_82CA93D0(ctx, base);
	// 82EC57A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC57AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC57B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC57B4: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC57B8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC57BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC57C0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC57C4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC57C8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC57CC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC57D0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC57D4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC57D8; continue 'dispatch;
            }
            0x82EC57D8 => {
    //   block [0x82EC57D8..0x82EC5804)
	// 82EC57D8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC57DC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC57E0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC57E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC57E8: 4082FFF0  bne 0x82ec57d8
	if !ctx.cr[0].eq {
	pc = 0x82EC57D8; continue 'dispatch;
	}
	// 82EC57EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC57F0: 4BFFFEE9  bl 0x82ec56d8
	ctx.lr = 0x82EC57F4;
	sub_82EC56D8(ctx, base);
	// 82EC57F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC57F8: 4082000C  bne 0x82ec5804
	if !ctx.cr[0].eq {
	pc = 0x82EC5804; continue 'dispatch;
	}
	// 82EC57FC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5800: 48000010  b 0x82ec5810
	pc = 0x82EC5810; continue 'dispatch;
            }
            0x82EC5804 => {
    //   block [0x82EC5804..0x82EC5810)
	// 82EC5804: 4BFF5F35  bl 0x82ebb738
	ctx.lr = 0x82EC5808;
	sub_82EBB738(ctx, base);
	// 82EC5808: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC580C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC5810; continue 'dispatch;
            }
            0x82EC5810 => {
    //   block [0x82EC5810..0x82EC5834)
	// 82EC5810: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5814: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5818: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC581C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5820: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5824: 409A0010  bne cr6, 0x82ec5834
	if !ctx.cr[6].eq {
	pc = 0x82EC5834; continue 'dispatch;
	}
	// 82EC5828: 4BFBA231  bl 0x82e7fa58
	ctx.lr = 0x82EC582C;
	sub_82E7FA58(ctx, base);
	// 82EC582C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5830: 4800000C  b 0x82ec583c
	pc = 0x82EC583C; continue 'dispatch;
            }
            0x82EC5834 => {
    //   block [0x82EC5834..0x82EC583C)
	// 82EC5834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5838: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC583C; continue 'dispatch;
            }
            0x82EC583C => {
    //   block [0x82EC583C..0x82EC5858)
	// 82EC583C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5840: 41820018  beq 0x82ec5858
	if ctx.cr[0].eq {
	pc = 0x82EC5858; continue 'dispatch;
	}
	// 82EC5844: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5848: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC584C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5850: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5854: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5858; continue 'dispatch;
            }
            0x82EC5858 => {
    //   block [0x82EC5858..0x82EC5864)
	// 82EC5858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC585C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5860: 4BDE3BF4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5868 size=68
    let mut pc: u32 = 0x82EC5868;
    'dispatch: loop {
        match pc {
            0x82EC5868 => {
    //   block [0x82EC5868..0x82EC58AC)
	// 82EC5868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC586C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5878: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC587C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5884: 4BFFFF1D  bl 0x82ec57a0
	ctx.lr = 0x82EC5888;
	sub_82EC57A0(ctx, base);
	// 82EC5888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC588C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5890: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC5894: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5898: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC589C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC58A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC58A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC58A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC58B0 size=200
    let mut pc: u32 = 0x82EC58B0;
    'dispatch: loop {
        match pc {
            0x82EC58B0 => {
    //   block [0x82EC58B0..0x82EC58E4)
	// 82EC58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC58B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC58B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC58BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC58C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC58C4: 4BFF5EED  bl 0x82ebb7b0
	ctx.lr = 0x82EC58C8;
	sub_82EBB7B0(ctx, base);
	// 82EC58C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC58CC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC58D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC58D4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC58D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC58DC: 40810054  ble 0x82ec5930
	if !ctx.cr[0].gt {
	pc = 0x82EC5930; continue 'dispatch;
	}
	// 82EC58E0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC58E4; continue 'dispatch;
            }
            0x82EC58E4 => {
    //   block [0x82EC58E4..0x82EC58F0)
	// 82EC58E4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58E8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC58EC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC58F0; continue 'dispatch;
            }
            0x82EC58F0 => {
    //   block [0x82EC58F0..0x82EC5914)
	// 82EC58F0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58F4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC58F8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC58FC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5900: 41820014  beq 0x82ec5914
	if ctx.cr[0].eq {
	pc = 0x82EC5914; continue 'dispatch;
	}
	// 82EC5904: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5908: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC590C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5910: 419AFFE0  beq cr6, 0x82ec58f0
	if ctx.cr[6].eq {
	pc = 0x82EC58F0; continue 'dispatch;
	}
	pc = 0x82EC5914; continue 'dispatch;
            }
            0x82EC5914 => {
    //   block [0x82EC5914..0x82EC5930)
	// 82EC5914: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5918: 41820028  beq 0x82ec5940
	if ctx.cr[0].eq {
	pc = 0x82EC5940; continue 'dispatch;
	}
	// 82EC591C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5920: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5924: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5928: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC592C: 4198FFB8  blt cr6, 0x82ec58e4
	if ctx.cr[6].lt {
	pc = 0x82EC58E4; continue 'dispatch;
	}
	pc = 0x82EC5930; continue 'dispatch;
            }
            0x82EC5930 => {
    //   block [0x82EC5930..0x82EC5940)
	// 82EC5930: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5934: 409A0018  bne cr6, 0x82ec594c
	if !ctx.cr[6].eq {
	pc = 0x82EC594C; continue 'dispatch;
	}
	// 82EC5938: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC593C: 48000028  b 0x82ec5964
	pc = 0x82EC5964; continue 'dispatch;
            }
            0x82EC5940 => {
    //   block [0x82EC5940..0x82EC594C)
	// 82EC5940: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5944: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5948: 48000018  b 0x82ec5960
	pc = 0x82EC5960; continue 'dispatch;
            }
            0x82EC594C => {
    //   block [0x82EC594C..0x82EC5960)
	// 82EC594C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5950: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5954: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5958: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC595C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5960; continue 'dispatch;
            }
            0x82EC5960 => {
    //   block [0x82EC5960..0x82EC5964)
	// 82EC5960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC5964; continue 'dispatch;
            }
            0x82EC5964 => {
    //   block [0x82EC5964..0x82EC5978)
	// 82EC5964: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC596C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5978 size=196
    let mut pc: u32 = 0x82EC5978;
    'dispatch: loop {
        match pc {
            0x82EC5978 => {
    //   block [0x82EC5978..0x82EC59B0)
	// 82EC5978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC597C: 4BDE3A89  bl 0x82ca9404
	ctx.lr = 0x82EC5980;
	sub_82CA93D0(ctx, base);
	// 82EC5980: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC598C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5990: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5994: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5998: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC599C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC59A0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC59A4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC59A8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC59AC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC59B0; continue 'dispatch;
            }
            0x82EC59B0 => {
    //   block [0x82EC59B0..0x82EC59DC)
	// 82EC59B0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC59B4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC59B8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC59BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC59C0: 4082FFF0  bne 0x82ec59b0
	if !ctx.cr[0].eq {
	pc = 0x82EC59B0; continue 'dispatch;
	}
	// 82EC59C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC59C8: 4BFFFEE9  bl 0x82ec58b0
	ctx.lr = 0x82EC59CC;
	sub_82EC58B0(ctx, base);
	// 82EC59CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC59D0: 4082000C  bne 0x82ec59dc
	if !ctx.cr[0].eq {
	pc = 0x82EC59DC; continue 'dispatch;
	}
	// 82EC59D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC59D8: 48000010  b 0x82ec59e8
	pc = 0x82EC59E8; continue 'dispatch;
            }
            0x82EC59DC => {
    //   block [0x82EC59DC..0x82EC59E8)
	// 82EC59DC: 4BFF5DD5  bl 0x82ebb7b0
	ctx.lr = 0x82EC59E0;
	sub_82EBB7B0(ctx, base);
	// 82EC59E0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC59E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC59E8; continue 'dispatch;
            }
            0x82EC59E8 => {
    //   block [0x82EC59E8..0x82EC5A0C)
	// 82EC59E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC59EC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC59F0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC59F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC59F8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC59FC: 409A0010  bne cr6, 0x82ec5a0c
	if !ctx.cr[6].eq {
	pc = 0x82EC5A0C; continue 'dispatch;
	}
	// 82EC5A00: 4BFBA059  bl 0x82e7fa58
	ctx.lr = 0x82EC5A04;
	sub_82E7FA58(ctx, base);
	// 82EC5A04: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5A08: 4800000C  b 0x82ec5a14
	pc = 0x82EC5A14; continue 'dispatch;
            }
            0x82EC5A0C => {
    //   block [0x82EC5A0C..0x82EC5A14)
	// 82EC5A0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5A10: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5A14; continue 'dispatch;
            }
            0x82EC5A14 => {
    //   block [0x82EC5A14..0x82EC5A30)
	// 82EC5A14: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5A18: 41820018  beq 0x82ec5a30
	if ctx.cr[0].eq {
	pc = 0x82EC5A30; continue 'dispatch;
	}
	// 82EC5A1C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5A20: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5A24: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5A28: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5A2C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5A30; continue 'dispatch;
            }
            0x82EC5A30 => {
    //   block [0x82EC5A30..0x82EC5A3C)
	// 82EC5A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5A34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5A38: 4BDE3A1C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5A40 size=68
    let mut pc: u32 = 0x82EC5A40;
    'dispatch: loop {
        match pc {
            0x82EC5A40 => {
    //   block [0x82EC5A40..0x82EC5A84)
	// 82EC5A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5A48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5A4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5A50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5A54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5A5C: 4BFFFF1D  bl 0x82ec5978
	ctx.lr = 0x82EC5A60;
	sub_82EC5978(ctx, base);
	// 82EC5A60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5A68: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5A70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5A74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5A78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5A88 size=200
    let mut pc: u32 = 0x82EC5A88;
    'dispatch: loop {
        match pc {
            0x82EC5A88 => {
    //   block [0x82EC5A88..0x82EC5ABC)
	// 82EC5A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5A98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5A9C: 4BFF5BAD  bl 0x82ebb648
	ctx.lr = 0x82EC5AA0;
	sub_82EBB648(ctx, base);
	// 82EC5AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5AA4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5AA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5AAC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5AB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AB4: 40810054  ble 0x82ec5b08
	if !ctx.cr[0].gt {
	pc = 0x82EC5B08; continue 'dispatch;
	}
	// 82EC5AB8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC5ABC; continue 'dispatch;
            }
            0x82EC5ABC => {
    //   block [0x82EC5ABC..0x82EC5AC8)
	// 82EC5ABC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5AC0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5AC4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC5AC8; continue 'dispatch;
            }
            0x82EC5AC8 => {
    //   block [0x82EC5AC8..0x82EC5AEC)
	// 82EC5AC8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5ACC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5AD0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AD4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5AD8: 41820014  beq 0x82ec5aec
	if ctx.cr[0].eq {
	pc = 0x82EC5AEC; continue 'dispatch;
	}
	// 82EC5ADC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5AE0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5AE4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5AE8: 419AFFE0  beq cr6, 0x82ec5ac8
	if ctx.cr[6].eq {
	pc = 0x82EC5AC8; continue 'dispatch;
	}
	pc = 0x82EC5AEC; continue 'dispatch;
            }
            0x82EC5AEC => {
    //   block [0x82EC5AEC..0x82EC5B08)
	// 82EC5AEC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5AF0: 41820028  beq 0x82ec5b18
	if ctx.cr[0].eq {
	pc = 0x82EC5B18; continue 'dispatch;
	}
	// 82EC5AF4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5AF8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5AFC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5B00: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5B04: 4198FFB8  blt cr6, 0x82ec5abc
	if ctx.cr[6].lt {
	pc = 0x82EC5ABC; continue 'dispatch;
	}
	pc = 0x82EC5B08; continue 'dispatch;
            }
            0x82EC5B08 => {
    //   block [0x82EC5B08..0x82EC5B18)
	// 82EC5B08: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5B0C: 409A0018  bne cr6, 0x82ec5b24
	if !ctx.cr[6].eq {
	pc = 0x82EC5B24; continue 'dispatch;
	}
	// 82EC5B10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5B14: 48000028  b 0x82ec5b3c
	pc = 0x82EC5B3C; continue 'dispatch;
            }
            0x82EC5B18 => {
    //   block [0x82EC5B18..0x82EC5B24)
	// 82EC5B18: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5B1C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5B20: 48000018  b 0x82ec5b38
	pc = 0x82EC5B38; continue 'dispatch;
            }
            0x82EC5B24 => {
    //   block [0x82EC5B24..0x82EC5B38)
	// 82EC5B24: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5B28: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5B2C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5B30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5B34: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5B38; continue 'dispatch;
            }
            0x82EC5B38 => {
    //   block [0x82EC5B38..0x82EC5B3C)
	// 82EC5B38: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC5B3C; continue 'dispatch;
            }
            0x82EC5B3C => {
    //   block [0x82EC5B3C..0x82EC5B50)
	// 82EC5B3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5B48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5B4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5B50 size=196
    let mut pc: u32 = 0x82EC5B50;
    'dispatch: loop {
        match pc {
            0x82EC5B50 => {
    //   block [0x82EC5B50..0x82EC5B88)
	// 82EC5B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5B54: 4BDE38B1  bl 0x82ca9404
	ctx.lr = 0x82EC5B58;
	sub_82CA93D0(ctx, base);
	// 82EC5B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5B5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5B64: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5B68: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5B6C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5B70: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5B74: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5B78: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5B7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5B80: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5B84: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC5B88; continue 'dispatch;
            }
            0x82EC5B88 => {
    //   block [0x82EC5B88..0x82EC5BB4)
	// 82EC5B88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5B8C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5B90: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5B94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5B98: 4082FFF0  bne 0x82ec5b88
	if !ctx.cr[0].eq {
	pc = 0x82EC5B88; continue 'dispatch;
	}
	// 82EC5B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5BA0: 4BFFFEE9  bl 0x82ec5a88
	ctx.lr = 0x82EC5BA4;
	sub_82EC5A88(ctx, base);
	// 82EC5BA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5BA8: 4082000C  bne 0x82ec5bb4
	if !ctx.cr[0].eq {
	pc = 0x82EC5BB4; continue 'dispatch;
	}
	// 82EC5BAC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5BB0: 48000010  b 0x82ec5bc0
	pc = 0x82EC5BC0; continue 'dispatch;
            }
            0x82EC5BB4 => {
    //   block [0x82EC5BB4..0x82EC5BC0)
	// 82EC5BB4: 4BFF5A95  bl 0x82ebb648
	ctx.lr = 0x82EC5BB8;
	sub_82EBB648(ctx, base);
	// 82EC5BB8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5BBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC5BC0; continue 'dispatch;
            }
            0x82EC5BC0 => {
    //   block [0x82EC5BC0..0x82EC5BE4)
	// 82EC5BC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5BC4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5BC8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5BCC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5BD0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5BD4: 409A0010  bne cr6, 0x82ec5be4
	if !ctx.cr[6].eq {
	pc = 0x82EC5BE4; continue 'dispatch;
	}
	// 82EC5BD8: 4BFB9E81  bl 0x82e7fa58
	ctx.lr = 0x82EC5BDC;
	sub_82E7FA58(ctx, base);
	// 82EC5BDC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5BE0: 4800000C  b 0x82ec5bec
	pc = 0x82EC5BEC; continue 'dispatch;
            }
            0x82EC5BE4 => {
    //   block [0x82EC5BE4..0x82EC5BEC)
	// 82EC5BE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5BE8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5BEC; continue 'dispatch;
            }
            0x82EC5BEC => {
    //   block [0x82EC5BEC..0x82EC5C08)
	// 82EC5BEC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5BF0: 41820018  beq 0x82ec5c08
	if ctx.cr[0].eq {
	pc = 0x82EC5C08; continue 'dispatch;
	}
	// 82EC5BF4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5BF8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5BFC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5C00: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5C04: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5C08; continue 'dispatch;
            }
            0x82EC5C08 => {
    //   block [0x82EC5C08..0x82EC5C14)
	// 82EC5C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5C0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5C10: 4BDE3844  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5C18 size=68
    let mut pc: u32 = 0x82EC5C18;
    'dispatch: loop {
        match pc {
            0x82EC5C18 => {
    //   block [0x82EC5C18..0x82EC5C5C)
	// 82EC5C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5C28: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5C2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5C30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5C34: 4BFFFF1D  bl 0x82ec5b50
	ctx.lr = 0x82EC5C38;
	sub_82EC5B50(ctx, base);
	// 82EC5C38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5C40: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5C44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5C48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5C60 size=200
    let mut pc: u32 = 0x82EC5C60;
    'dispatch: loop {
        match pc {
            0x82EC5C60 => {
    //   block [0x82EC5C60..0x82EC5C94)
	// 82EC5C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5C68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5C6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5C74: 4BFF5A4D  bl 0x82ebb6c0
	ctx.lr = 0x82EC5C78;
	sub_82EBB6C0(ctx, base);
	// 82EC5C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5C7C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5C80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5C84: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5C88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5C8C: 40810054  ble 0x82ec5ce0
	if !ctx.cr[0].gt {
	pc = 0x82EC5CE0; continue 'dispatch;
	}
	// 82EC5C90: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC5C94; continue 'dispatch;
            }
            0x82EC5C94 => {
    //   block [0x82EC5C94..0x82EC5CA0)
	// 82EC5C94: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5C98: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5C9C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC5CA0; continue 'dispatch;
            }
            0x82EC5CA0 => {
    //   block [0x82EC5CA0..0x82EC5CC4)
	// 82EC5CA0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5CA4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5CA8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5CAC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5CB0: 41820014  beq 0x82ec5cc4
	if ctx.cr[0].eq {
	pc = 0x82EC5CC4; continue 'dispatch;
	}
	// 82EC5CB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5CB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5CBC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5CC0: 419AFFE0  beq cr6, 0x82ec5ca0
	if ctx.cr[6].eq {
	pc = 0x82EC5CA0; continue 'dispatch;
	}
	pc = 0x82EC5CC4; continue 'dispatch;
            }
            0x82EC5CC4 => {
    //   block [0x82EC5CC4..0x82EC5CE0)
	// 82EC5CC4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5CC8: 41820028  beq 0x82ec5cf0
	if ctx.cr[0].eq {
	pc = 0x82EC5CF0; continue 'dispatch;
	}
	// 82EC5CCC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5CD0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5CD4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5CD8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5CDC: 4198FFB8  blt cr6, 0x82ec5c94
	if ctx.cr[6].lt {
	pc = 0x82EC5C94; continue 'dispatch;
	}
	pc = 0x82EC5CE0; continue 'dispatch;
            }
            0x82EC5CE0 => {
    //   block [0x82EC5CE0..0x82EC5CF0)
	// 82EC5CE0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5CE4: 409A0018  bne cr6, 0x82ec5cfc
	if !ctx.cr[6].eq {
	pc = 0x82EC5CFC; continue 'dispatch;
	}
	// 82EC5CE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5CEC: 48000028  b 0x82ec5d14
	pc = 0x82EC5D14; continue 'dispatch;
            }
            0x82EC5CF0 => {
    //   block [0x82EC5CF0..0x82EC5CFC)
	// 82EC5CF0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5CF4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5CF8: 48000018  b 0x82ec5d10
	pc = 0x82EC5D10; continue 'dispatch;
            }
            0x82EC5CFC => {
    //   block [0x82EC5CFC..0x82EC5D10)
	// 82EC5CFC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5D00: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5D04: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5D08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5D0C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5D10; continue 'dispatch;
            }
            0x82EC5D10 => {
    //   block [0x82EC5D10..0x82EC5D14)
	// 82EC5D10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC5D14; continue 'dispatch;
            }
            0x82EC5D14 => {
    //   block [0x82EC5D14..0x82EC5D28)
	// 82EC5D14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5D20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5D24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5D28 size=196
    let mut pc: u32 = 0x82EC5D28;
    'dispatch: loop {
        match pc {
            0x82EC5D28 => {
    //   block [0x82EC5D28..0x82EC5D60)
	// 82EC5D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5D2C: 4BDE36D9  bl 0x82ca9404
	ctx.lr = 0x82EC5D30;
	sub_82CA93D0(ctx, base);
	// 82EC5D30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5D34: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5D3C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5D40: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5D44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5D48: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5D4C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5D50: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5D54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5D58: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5D5C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC5D60; continue 'dispatch;
            }
            0x82EC5D60 => {
    //   block [0x82EC5D60..0x82EC5D8C)
	// 82EC5D60: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5D64: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5D68: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5D6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5D70: 4082FFF0  bne 0x82ec5d60
	if !ctx.cr[0].eq {
	pc = 0x82EC5D60; continue 'dispatch;
	}
	// 82EC5D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5D78: 4BFFFEE9  bl 0x82ec5c60
	ctx.lr = 0x82EC5D7C;
	sub_82EC5C60(ctx, base);
	// 82EC5D7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5D80: 4082000C  bne 0x82ec5d8c
	if !ctx.cr[0].eq {
	pc = 0x82EC5D8C; continue 'dispatch;
	}
	// 82EC5D84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5D88: 48000010  b 0x82ec5d98
	pc = 0x82EC5D98; continue 'dispatch;
            }
            0x82EC5D8C => {
    //   block [0x82EC5D8C..0x82EC5D98)
	// 82EC5D8C: 4BFF5935  bl 0x82ebb6c0
	ctx.lr = 0x82EC5D90;
	sub_82EBB6C0(ctx, base);
	// 82EC5D90: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5D94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC5D98; continue 'dispatch;
            }
            0x82EC5D98 => {
    //   block [0x82EC5D98..0x82EC5DBC)
	// 82EC5D98: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5D9C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5DA0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5DA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5DA8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5DAC: 409A0010  bne cr6, 0x82ec5dbc
	if !ctx.cr[6].eq {
	pc = 0x82EC5DBC; continue 'dispatch;
	}
	// 82EC5DB0: 4BFB9CA9  bl 0x82e7fa58
	ctx.lr = 0x82EC5DB4;
	sub_82E7FA58(ctx, base);
	// 82EC5DB4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5DB8: 4800000C  b 0x82ec5dc4
	pc = 0x82EC5DC4; continue 'dispatch;
            }
            0x82EC5DBC => {
    //   block [0x82EC5DBC..0x82EC5DC4)
	// 82EC5DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5DC0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5DC4; continue 'dispatch;
            }
            0x82EC5DC4 => {
    //   block [0x82EC5DC4..0x82EC5DE0)
	// 82EC5DC4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5DC8: 41820018  beq 0x82ec5de0
	if ctx.cr[0].eq {
	pc = 0x82EC5DE0; continue 'dispatch;
	}
	// 82EC5DCC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5DD0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5DD4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5DD8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5DDC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5DE0; continue 'dispatch;
            }
            0x82EC5DE0 => {
    //   block [0x82EC5DE0..0x82EC5DEC)
	// 82EC5DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5DE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5DE8: 4BDE366C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5DF0 size=68
    let mut pc: u32 = 0x82EC5DF0;
    'dispatch: loop {
        match pc {
            0x82EC5DF0 => {
    //   block [0x82EC5DF0..0x82EC5E34)
	// 82EC5DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5DFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5E00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5E04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5E08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5E0C: 4BFFFF1D  bl 0x82ec5d28
	ctx.lr = 0x82EC5E10;
	sub_82EC5D28(ctx, base);
	// 82EC5E10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5E18: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC5E1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5E20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5E38 size=200
    let mut pc: u32 = 0x82EC5E38;
    'dispatch: loop {
        match pc {
            0x82EC5E38 => {
    //   block [0x82EC5E38..0x82EC5E6C)
	// 82EC5E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5E40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5E44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5E4C: 4BFF570D  bl 0x82ebb558
	ctx.lr = 0x82EC5E50;
	sub_82EBB558(ctx, base);
	// 82EC5E50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC5E54: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC5E58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC5E5C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5E60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5E64: 40810054  ble 0x82ec5eb8
	if !ctx.cr[0].gt {
	pc = 0x82EC5EB8; continue 'dispatch;
	}
	// 82EC5E68: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC5E6C; continue 'dispatch;
            }
            0x82EC5E6C => {
    //   block [0x82EC5E6C..0x82EC5E78)
	// 82EC5E6C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E70: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC5E74: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC5E78; continue 'dispatch;
            }
            0x82EC5E78 => {
    //   block [0x82EC5E78..0x82EC5E9C)
	// 82EC5E78: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E7C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5E80: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5E84: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC5E88: 41820014  beq 0x82ec5e9c
	if ctx.cr[0].eq {
	pc = 0x82EC5E9C; continue 'dispatch;
	}
	// 82EC5E8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5E90: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC5E94: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC5E98: 419AFFE0  beq cr6, 0x82ec5e78
	if ctx.cr[6].eq {
	pc = 0x82EC5E78; continue 'dispatch;
	}
	pc = 0x82EC5E9C; continue 'dispatch;
            }
            0x82EC5E9C => {
    //   block [0x82EC5E9C..0x82EC5EB8)
	// 82EC5E9C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC5EA0: 41820028  beq 0x82ec5ec8
	if ctx.cr[0].eq {
	pc = 0x82EC5EC8; continue 'dispatch;
	}
	// 82EC5EA4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5EA8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC5EAC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC5EB0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC5EB4: 4198FFB8  blt cr6, 0x82ec5e6c
	if ctx.cr[6].lt {
	pc = 0x82EC5E6C; continue 'dispatch;
	}
	pc = 0x82EC5EB8; continue 'dispatch;
            }
            0x82EC5EB8 => {
    //   block [0x82EC5EB8..0x82EC5EC8)
	// 82EC5EB8: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC5EBC: 409A0018  bne cr6, 0x82ec5ed4
	if !ctx.cr[6].eq {
	pc = 0x82EC5ED4; continue 'dispatch;
	}
	// 82EC5EC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC5EC4: 48000028  b 0x82ec5eec
	pc = 0x82EC5EEC; continue 'dispatch;
            }
            0x82EC5EC8 => {
    //   block [0x82EC5EC8..0x82EC5ED4)
	// 82EC5EC8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5ECC: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5ED0: 48000018  b 0x82ec5ee8
	pc = 0x82EC5EE8; continue 'dispatch;
            }
            0x82EC5ED4 => {
    //   block [0x82EC5ED4..0x82EC5EE8)
	// 82EC5ED4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC5ED8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC5EDC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5EE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC5EE4: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5EE8; continue 'dispatch;
            }
            0x82EC5EE8 => {
    //   block [0x82EC5EE8..0x82EC5EEC)
	// 82EC5EE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC5EEC; continue 'dispatch;
            }
            0x82EC5EEC => {
    //   block [0x82EC5EEC..0x82EC5F00)
	// 82EC5EEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5EF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC5EF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC5EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC5EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5F00 size=196
    let mut pc: u32 = 0x82EC5F00;
    'dispatch: loop {
        match pc {
            0x82EC5F00 => {
    //   block [0x82EC5F00..0x82EC5F38)
	// 82EC5F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5F04: 4BDE3501  bl 0x82ca9404
	ctx.lr = 0x82EC5F08;
	sub_82CA93D0(ctx, base);
	// 82EC5F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5F0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5F14: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC5F18: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC5F1C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC5F20: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC5F24: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC5F28: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC5F2C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC5F30: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC5F34: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC5F38; continue 'dispatch;
            }
            0x82EC5F38 => {
    //   block [0x82EC5F38..0x82EC5F64)
	// 82EC5F38: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC5F3C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC5F40: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC5F44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC5F48: 4082FFF0  bne 0x82ec5f38
	if !ctx.cr[0].eq {
	pc = 0x82EC5F38; continue 'dispatch;
	}
	// 82EC5F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5F50: 4BFFFEE9  bl 0x82ec5e38
	ctx.lr = 0x82EC5F54;
	sub_82EC5E38(ctx, base);
	// 82EC5F54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5F58: 4082000C  bne 0x82ec5f64
	if !ctx.cr[0].eq {
	pc = 0x82EC5F64; continue 'dispatch;
	}
	// 82EC5F5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC5F60: 48000010  b 0x82ec5f70
	pc = 0x82EC5F70; continue 'dispatch;
            }
            0x82EC5F64 => {
    //   block [0x82EC5F64..0x82EC5F70)
	// 82EC5F64: 4BFF55F5  bl 0x82ebb558
	ctx.lr = 0x82EC5F68;
	sub_82EBB558(ctx, base);
	// 82EC5F68: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC5F6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC5F70; continue 'dispatch;
            }
            0x82EC5F70 => {
    //   block [0x82EC5F70..0x82EC5F94)
	// 82EC5F70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC5F74: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC5F78: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC5F7C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC5F80: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC5F84: 409A0010  bne cr6, 0x82ec5f94
	if !ctx.cr[6].eq {
	pc = 0x82EC5F94; continue 'dispatch;
	}
	// 82EC5F88: 4BFB9AD1  bl 0x82e7fa58
	ctx.lr = 0x82EC5F8C;
	sub_82E7FA58(ctx, base);
	// 82EC5F8C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC5F90: 4800000C  b 0x82ec5f9c
	pc = 0x82EC5F9C; continue 'dispatch;
            }
            0x82EC5F94 => {
    //   block [0x82EC5F94..0x82EC5F9C)
	// 82EC5F94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC5F98: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC5F9C; continue 'dispatch;
            }
            0x82EC5F9C => {
    //   block [0x82EC5F9C..0x82EC5FB8)
	// 82EC5F9C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC5FA0: 41820018  beq 0x82ec5fb8
	if ctx.cr[0].eq {
	pc = 0x82EC5FB8; continue 'dispatch;
	}
	// 82EC5FA4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC5FA8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC5FAC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC5FB0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC5FB4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC5FB8; continue 'dispatch;
            }
            0x82EC5FB8 => {
    //   block [0x82EC5FB8..0x82EC5FC4)
	// 82EC5FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5FBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC5FC0: 4BDE3494  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC5FC8 size=68
    let mut pc: u32 = 0x82EC5FC8;
    'dispatch: loop {
        match pc {
            0x82EC5FC8 => {
    //   block [0x82EC5FC8..0x82EC600C)
	// 82EC5FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC5FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC5FD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC5FD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC5FD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC5FDC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC5FE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC5FE4: 4BFFFF1D  bl 0x82ec5f00
	ctx.lr = 0x82EC5FE8;
	sub_82EC5F00(ctx, base);
	// 82EC5FE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC5FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC5FF0: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC5FF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC5FF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC5FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6010 size=200
    let mut pc: u32 = 0x82EC6010;
    'dispatch: loop {
        match pc {
            0x82EC6010 => {
    //   block [0x82EC6010..0x82EC6044)
	// 82EC6010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC601C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6024: 4BFF55AD  bl 0x82ebb5d0
	ctx.lr = 0x82EC6028;
	sub_82EBB5D0(ctx, base);
	// 82EC6028: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC602C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6030: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6034: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6038: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC603C: 40810054  ble 0x82ec6090
	if !ctx.cr[0].gt {
	pc = 0x82EC6090; continue 'dispatch;
	}
	// 82EC6040: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC6044; continue 'dispatch;
            }
            0x82EC6044 => {
    //   block [0x82EC6044..0x82EC6050)
	// 82EC6044: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6048: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC604C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC6050; continue 'dispatch;
            }
            0x82EC6050 => {
    //   block [0x82EC6050..0x82EC6074)
	// 82EC6050: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6054: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6058: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC605C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6060: 41820014  beq 0x82ec6074
	if ctx.cr[0].eq {
	pc = 0x82EC6074; continue 'dispatch;
	}
	// 82EC6064: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6068: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC606C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6070: 419AFFE0  beq cr6, 0x82ec6050
	if ctx.cr[6].eq {
	pc = 0x82EC6050; continue 'dispatch;
	}
	pc = 0x82EC6074; continue 'dispatch;
            }
            0x82EC6074 => {
    //   block [0x82EC6074..0x82EC6090)
	// 82EC6074: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6078: 41820028  beq 0x82ec60a0
	if ctx.cr[0].eq {
	pc = 0x82EC60A0; continue 'dispatch;
	}
	// 82EC607C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6080: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC6084: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6088: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC608C: 4198FFB8  blt cr6, 0x82ec6044
	if ctx.cr[6].lt {
	pc = 0x82EC6044; continue 'dispatch;
	}
	pc = 0x82EC6090; continue 'dispatch;
            }
            0x82EC6090 => {
    //   block [0x82EC6090..0x82EC60A0)
	// 82EC6090: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC6094: 409A0018  bne cr6, 0x82ec60ac
	if !ctx.cr[6].eq {
	pc = 0x82EC60AC; continue 'dispatch;
	}
	// 82EC6098: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC609C: 48000028  b 0x82ec60c4
	pc = 0x82EC60C4; continue 'dispatch;
            }
            0x82EC60A0 => {
    //   block [0x82EC60A0..0x82EC60AC)
	// 82EC60A0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC60A4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC60A8: 48000018  b 0x82ec60c0
	pc = 0x82EC60C0; continue 'dispatch;
            }
            0x82EC60AC => {
    //   block [0x82EC60AC..0x82EC60C0)
	// 82EC60AC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC60B0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC60B4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC60B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC60BC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC60C0; continue 'dispatch;
            }
            0x82EC60C0 => {
    //   block [0x82EC60C0..0x82EC60C4)
	// 82EC60C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC60C4; continue 'dispatch;
            }
            0x82EC60C4 => {
    //   block [0x82EC60C4..0x82EC60D8)
	// 82EC60C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC60C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC60CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC60D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC60D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC60D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC60D8 size=196
    let mut pc: u32 = 0x82EC60D8;
    'dispatch: loop {
        match pc {
            0x82EC60D8 => {
    //   block [0x82EC60D8..0x82EC6110)
	// 82EC60D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC60DC: 4BDE3329  bl 0x82ca9404
	ctx.lr = 0x82EC60E0;
	sub_82CA93D0(ctx, base);
	// 82EC60E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC60E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC60E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC60EC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC60F0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC60F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC60F8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC60FC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6100: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC6104: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6108: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC610C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC6110; continue 'dispatch;
            }
            0x82EC6110 => {
    //   block [0x82EC6110..0x82EC613C)
	// 82EC6110: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6114: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC6118: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC611C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC6120: 4082FFF0  bne 0x82ec6110
	if !ctx.cr[0].eq {
	pc = 0x82EC6110; continue 'dispatch;
	}
	// 82EC6124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6128: 4BFFFEE9  bl 0x82ec6010
	ctx.lr = 0x82EC612C;
	sub_82EC6010(ctx, base);
	// 82EC612C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6130: 4082000C  bne 0x82ec613c
	if !ctx.cr[0].eq {
	pc = 0x82EC613C; continue 'dispatch;
	}
	// 82EC6134: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6138: 48000010  b 0x82ec6148
	pc = 0x82EC6148; continue 'dispatch;
            }
            0x82EC613C => {
    //   block [0x82EC613C..0x82EC6148)
	// 82EC613C: 4BFF5495  bl 0x82ebb5d0
	ctx.lr = 0x82EC6140;
	sub_82EBB5D0(ctx, base);
	// 82EC6140: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6144: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC6148; continue 'dispatch;
            }
            0x82EC6148 => {
    //   block [0x82EC6148..0x82EC616C)
	// 82EC6148: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC614C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6150: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC6154: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6158: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC615C: 409A0010  bne cr6, 0x82ec616c
	if !ctx.cr[6].eq {
	pc = 0x82EC616C; continue 'dispatch;
	}
	// 82EC6160: 4BFB98F9  bl 0x82e7fa58
	ctx.lr = 0x82EC6164;
	sub_82E7FA58(ctx, base);
	// 82EC6164: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6168: 4800000C  b 0x82ec6174
	pc = 0x82EC6174; continue 'dispatch;
            }
            0x82EC616C => {
    //   block [0x82EC616C..0x82EC6174)
	// 82EC616C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6170: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC6174; continue 'dispatch;
            }
            0x82EC6174 => {
    //   block [0x82EC6174..0x82EC6190)
	// 82EC6174: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6178: 41820018  beq 0x82ec6190
	if ctx.cr[0].eq {
	pc = 0x82EC6190; continue 'dispatch;
	}
	// 82EC617C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6180: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC6184: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6188: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC618C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6190; continue 'dispatch;
            }
            0x82EC6190 => {
    //   block [0x82EC6190..0x82EC619C)
	// 82EC6190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6194: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6198: 4BDE32BC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC61A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC61A0 size=68
    let mut pc: u32 = 0x82EC61A0;
    'dispatch: loop {
        match pc {
            0x82EC61A0 => {
    //   block [0x82EC61A0..0x82EC61E4)
	// 82EC61A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC61A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC61A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC61AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC61B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC61B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC61B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC61BC: 4BFFFF1D  bl 0x82ec60d8
	ctx.lr = 0x82EC61C0;
	sub_82EC60D8(ctx, base);
	// 82EC61C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC61C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC61C8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC61CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC61D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC61D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC61D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC61DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC61E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC61E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC61E8 size=200
    let mut pc: u32 = 0x82EC61E8;
    'dispatch: loop {
        match pc {
            0x82EC61E8 => {
    //   block [0x82EC61E8..0x82EC621C)
	// 82EC61E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC61EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC61F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC61F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC61F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC61FC: 4BFF52E5  bl 0x82ebb4e0
	ctx.lr = 0x82EC6200;
	sub_82EBB4E0(ctx, base);
	// 82EC6200: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC6204: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6208: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC620C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6210: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6214: 40810054  ble 0x82ec6268
	if !ctx.cr[0].gt {
	pc = 0x82EC6268; continue 'dispatch;
	}
	// 82EC6218: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC621C; continue 'dispatch;
            }
            0x82EC621C => {
    //   block [0x82EC621C..0x82EC6228)
	// 82EC621C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6220: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC6224: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC6228; continue 'dispatch;
            }
            0x82EC6228 => {
    //   block [0x82EC6228..0x82EC624C)
	// 82EC6228: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC622C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6230: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6234: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6238: 41820014  beq 0x82ec624c
	if ctx.cr[0].eq {
	pc = 0x82EC624C; continue 'dispatch;
	}
	// 82EC623C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6240: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC6244: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6248: 419AFFE0  beq cr6, 0x82ec6228
	if ctx.cr[6].eq {
	pc = 0x82EC6228; continue 'dispatch;
	}
	pc = 0x82EC624C; continue 'dispatch;
            }
            0x82EC624C => {
    //   block [0x82EC624C..0x82EC6268)
	// 82EC624C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6250: 41820028  beq 0x82ec6278
	if ctx.cr[0].eq {
	pc = 0x82EC6278; continue 'dispatch;
	}
	// 82EC6254: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6258: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC625C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6260: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC6264: 4198FFB8  blt cr6, 0x82ec621c
	if ctx.cr[6].lt {
	pc = 0x82EC621C; continue 'dispatch;
	}
	pc = 0x82EC6268; continue 'dispatch;
            }
            0x82EC6268 => {
    //   block [0x82EC6268..0x82EC6278)
	// 82EC6268: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC626C: 409A0018  bne cr6, 0x82ec6284
	if !ctx.cr[6].eq {
	pc = 0x82EC6284; continue 'dispatch;
	}
	// 82EC6270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6274: 48000028  b 0x82ec629c
	pc = 0x82EC629C; continue 'dispatch;
            }
            0x82EC6278 => {
    //   block [0x82EC6278..0x82EC6284)
	// 82EC6278: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC627C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6280: 48000018  b 0x82ec6298
	pc = 0x82EC6298; continue 'dispatch;
            }
            0x82EC6284 => {
    //   block [0x82EC6284..0x82EC6298)
	// 82EC6284: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6288: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC628C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6290: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6294: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6298; continue 'dispatch;
            }
            0x82EC6298 => {
    //   block [0x82EC6298..0x82EC629C)
	// 82EC6298: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC629C; continue 'dispatch;
            }
            0x82EC629C => {
    //   block [0x82EC629C..0x82EC62B0)
	// 82EC629C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC62A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC62A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC62A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC62AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC62B0 size=196
    let mut pc: u32 = 0x82EC62B0;
    'dispatch: loop {
        match pc {
            0x82EC62B0 => {
    //   block [0x82EC62B0..0x82EC62E8)
	// 82EC62B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC62B4: 4BDE3151  bl 0x82ca9404
	ctx.lr = 0x82EC62B8;
	sub_82CA93D0(ctx, base);
	// 82EC62B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC62BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC62C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC62C4: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC62C8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC62CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC62D0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC62D4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC62D8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC62DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC62E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC62E4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC62E8; continue 'dispatch;
            }
            0x82EC62E8 => {
    //   block [0x82EC62E8..0x82EC6314)
	// 82EC62E8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC62EC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC62F0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC62F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC62F8: 4082FFF0  bne 0x82ec62e8
	if !ctx.cr[0].eq {
	pc = 0x82EC62E8; continue 'dispatch;
	}
	// 82EC62FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6300: 4BFFFEE9  bl 0x82ec61e8
	ctx.lr = 0x82EC6304;
	sub_82EC61E8(ctx, base);
	// 82EC6304: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6308: 4082000C  bne 0x82ec6314
	if !ctx.cr[0].eq {
	pc = 0x82EC6314; continue 'dispatch;
	}
	// 82EC630C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC6310: 48000010  b 0x82ec6320
	pc = 0x82EC6320; continue 'dispatch;
            }
            0x82EC6314 => {
    //   block [0x82EC6314..0x82EC6320)
	// 82EC6314: 4BFF51CD  bl 0x82ebb4e0
	ctx.lr = 0x82EC6318;
	sub_82EBB4E0(ctx, base);
	// 82EC6318: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC631C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC6320; continue 'dispatch;
            }
            0x82EC6320 => {
    //   block [0x82EC6320..0x82EC6344)
	// 82EC6320: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC6324: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6328: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC632C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6330: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC6334: 409A0010  bne cr6, 0x82ec6344
	if !ctx.cr[6].eq {
	pc = 0x82EC6344; continue 'dispatch;
	}
	// 82EC6338: 4BFB9721  bl 0x82e7fa58
	ctx.lr = 0x82EC633C;
	sub_82E7FA58(ctx, base);
	// 82EC633C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6340: 4800000C  b 0x82ec634c
	pc = 0x82EC634C; continue 'dispatch;
            }
            0x82EC6344 => {
    //   block [0x82EC6344..0x82EC634C)
	// 82EC6344: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6348: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC634C; continue 'dispatch;
            }
            0x82EC634C => {
    //   block [0x82EC634C..0x82EC6368)
	// 82EC634C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6350: 41820018  beq 0x82ec6368
	if ctx.cr[0].eq {
	pc = 0x82EC6368; continue 'dispatch;
	}
	// 82EC6354: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6358: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC635C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6360: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC6364: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6368; continue 'dispatch;
            }
            0x82EC6368 => {
    //   block [0x82EC6368..0x82EC6374)
	// 82EC6368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC636C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6370: 4BDE30E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6378 size=68
    let mut pc: u32 = 0x82EC6378;
    'dispatch: loop {
        match pc {
            0x82EC6378 => {
    //   block [0x82EC6378..0x82EC63BC)
	// 82EC6378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC637C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6388: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC638C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6394: 4BFFFF1D  bl 0x82ec62b0
	ctx.lr = 0x82EC6398;
	sub_82EC62B0(ctx, base);
	// 82EC6398: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC639C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC63A0: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EC63A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC63A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC63AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC63B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC63B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC63B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC63C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC63C0 size=200
    let mut pc: u32 = 0x82EC63C0;
    'dispatch: loop {
        match pc {
            0x82EC63C0 => {
    //   block [0x82EC63C0..0x82EC63F4)
	// 82EC63C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC63C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC63C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC63CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC63D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC63D4: 4BFF5095  bl 0x82ebb468
	ctx.lr = 0x82EC63D8;
	sub_82EBB468(ctx, base);
	// 82EC63D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC63DC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC63E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC63E4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC63E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC63EC: 40810054  ble 0x82ec6440
	if !ctx.cr[0].gt {
	pc = 0x82EC6440; continue 'dispatch;
	}
	// 82EC63F0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC63F4; continue 'dispatch;
            }
            0x82EC63F4 => {
    //   block [0x82EC63F4..0x82EC6400)
	// 82EC63F4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC63F8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC63FC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC6400; continue 'dispatch;
            }
            0x82EC6400 => {
    //   block [0x82EC6400..0x82EC6424)
	// 82EC6400: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6404: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC6408: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC640C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC6410: 41820014  beq 0x82ec6424
	if ctx.cr[0].eq {
	pc = 0x82EC6424; continue 'dispatch;
	}
	// 82EC6414: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6418: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC641C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC6420: 419AFFE0  beq cr6, 0x82ec6400
	if ctx.cr[6].eq {
	pc = 0x82EC6400; continue 'dispatch;
	}
	pc = 0x82EC6424; continue 'dispatch;
            }
            0x82EC6424 => {
    //   block [0x82EC6424..0x82EC6440)
	// 82EC6424: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6428: 41820028  beq 0x82ec6450
	if ctx.cr[0].eq {
	pc = 0x82EC6450; continue 'dispatch;
	}
	// 82EC642C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6430: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC6434: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6438: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC643C: 4198FFB8  blt cr6, 0x82ec63f4
	if ctx.cr[6].lt {
	pc = 0x82EC63F4; continue 'dispatch;
	}
	pc = 0x82EC6440; continue 'dispatch;
            }
            0x82EC6440 => {
    //   block [0x82EC6440..0x82EC6450)
	// 82EC6440: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC6444: 409A0018  bne cr6, 0x82ec645c
	if !ctx.cr[6].eq {
	pc = 0x82EC645C; continue 'dispatch;
	}
	// 82EC6448: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC644C: 48000028  b 0x82ec6474
	pc = 0x82EC6474; continue 'dispatch;
            }
            0x82EC6450 => {
    //   block [0x82EC6450..0x82EC645C)
	// 82EC6450: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6454: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6458: 48000018  b 0x82ec6470
	pc = 0x82EC6470; continue 'dispatch;
            }
            0x82EC645C => {
    //   block [0x82EC645C..0x82EC6470)
	// 82EC645C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6460: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6464: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6468: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC646C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6470; continue 'dispatch;
            }
            0x82EC6470 => {
    //   block [0x82EC6470..0x82EC6474)
	// 82EC6470: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC6474; continue 'dispatch;
            }
            0x82EC6474 => {
    //   block [0x82EC6474..0x82EC6488)
	// 82EC6474: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC647C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6480: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6488 size=196
    let mut pc: u32 = 0x82EC6488;
    'dispatch: loop {
        match pc {
            0x82EC6488 => {
    //   block [0x82EC6488..0x82EC64C0)
	// 82EC6488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC648C: 4BDE2F79  bl 0x82ca9404
	ctx.lr = 0x82EC6490;
	sub_82CA93D0(ctx, base);
	// 82EC6490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6494: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC649C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC64A0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC64A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC64A8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC64AC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC64B0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC64B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC64B8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC64BC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC64C0; continue 'dispatch;
            }
            0x82EC64C0 => {
    //   block [0x82EC64C0..0x82EC64EC)
	// 82EC64C0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC64C4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC64C8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC64CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC64D0: 4082FFF0  bne 0x82ec64c0
	if !ctx.cr[0].eq {
	pc = 0x82EC64C0; continue 'dispatch;
	}
	// 82EC64D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC64D8: 4BFFFEE9  bl 0x82ec63c0
	ctx.lr = 0x82EC64DC;
	sub_82EC63C0(ctx, base);
	// 82EC64DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC64E0: 4082000C  bne 0x82ec64ec
	if !ctx.cr[0].eq {
	pc = 0x82EC64EC; continue 'dispatch;
	}
	// 82EC64E4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC64E8: 48000010  b 0x82ec64f8
	pc = 0x82EC64F8; continue 'dispatch;
            }
            0x82EC64EC => {
    //   block [0x82EC64EC..0x82EC64F8)
	// 82EC64EC: 4BFF4F7D  bl 0x82ebb468
	ctx.lr = 0x82EC64F0;
	sub_82EBB468(ctx, base);
	// 82EC64F0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC64F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC64F8; continue 'dispatch;
            }
            0x82EC64F8 => {
    //   block [0x82EC64F8..0x82EC651C)
	// 82EC64F8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC64FC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC6500: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC6504: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC6508: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC650C: 409A0010  bne cr6, 0x82ec651c
	if !ctx.cr[6].eq {
	pc = 0x82EC651C; continue 'dispatch;
	}
	// 82EC6510: 4BFB9549  bl 0x82e7fa58
	ctx.lr = 0x82EC6514;
	sub_82E7FA58(ctx, base);
	// 82EC6514: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC6518: 4800000C  b 0x82ec6524
	pc = 0x82EC6524; continue 'dispatch;
            }
            0x82EC651C => {
    //   block [0x82EC651C..0x82EC6524)
	// 82EC651C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC6520: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC6524; continue 'dispatch;
            }
            0x82EC6524 => {
    //   block [0x82EC6524..0x82EC6540)
	// 82EC6524: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6528: 41820018  beq 0x82ec6540
	if ctx.cr[0].eq {
	pc = 0x82EC6540; continue 'dispatch;
	}
	// 82EC652C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6530: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC6534: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6538: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC653C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6540; continue 'dispatch;
            }
            0x82EC6540 => {
    //   block [0x82EC6540..0x82EC654C)
	// 82EC6540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6544: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6548: 4BDE2F0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6550 size=68
    let mut pc: u32 = 0x82EC6550;
    'dispatch: loop {
        match pc {
            0x82EC6550 => {
    //   block [0x82EC6550..0x82EC6594)
	// 82EC6550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6558: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC655C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6560: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC6564: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC656C: 4BFFFF1D  bl 0x82ec6488
	ctx.lr = 0x82EC6570;
	sub_82EC6488(ctx, base);
	// 82EC6570: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6578: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC657C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC658C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6598 size=200
    let mut pc: u32 = 0x82EC6598;
    'dispatch: loop {
        match pc {
            0x82EC6598 => {
    //   block [0x82EC6598..0x82EC65CC)
	// 82EC6598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC659C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC65A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC65A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC65A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC65AC: 4BFF4E45  bl 0x82ebb3f0
	ctx.lr = 0x82EC65B0;
	sub_82EBB3F0(ctx, base);
	// 82EC65B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC65B4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC65B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC65BC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC65C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC65C4: 40810054  ble 0x82ec6618
	if !ctx.cr[0].gt {
	pc = 0x82EC6618; continue 'dispatch;
	}
	// 82EC65C8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC65CC; continue 'dispatch;
            }
            0x82EC65CC => {
    //   block [0x82EC65CC..0x82EC65D8)
	// 82EC65CC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65D0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC65D4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC65D8; continue 'dispatch;
            }
            0x82EC65D8 => {
    //   block [0x82EC65D8..0x82EC65FC)
	// 82EC65D8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65DC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC65E0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC65E4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC65E8: 41820014  beq 0x82ec65fc
	if ctx.cr[0].eq {
	pc = 0x82EC65FC; continue 'dispatch;
	}
	// 82EC65EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC65F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC65F4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC65F8: 419AFFE0  beq cr6, 0x82ec65d8
	if ctx.cr[6].eq {
	pc = 0x82EC65D8; continue 'dispatch;
	}
	pc = 0x82EC65FC; continue 'dispatch;
            }
            0x82EC65FC => {
    //   block [0x82EC65FC..0x82EC6618)
	// 82EC65FC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC6600: 41820028  beq 0x82ec6628
	if ctx.cr[0].eq {
	pc = 0x82EC6628; continue 'dispatch;
	}
	// 82EC6604: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6608: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC660C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC6610: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC6614: 4198FFB8  blt cr6, 0x82ec65cc
	if ctx.cr[6].lt {
	pc = 0x82EC65CC; continue 'dispatch;
	}
	pc = 0x82EC6618; continue 'dispatch;
            }
            0x82EC6618 => {
    //   block [0x82EC6618..0x82EC6628)
	// 82EC6618: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC661C: 409A0018  bne cr6, 0x82ec6634
	if !ctx.cr[6].eq {
	pc = 0x82EC6634; continue 'dispatch;
	}
	// 82EC6620: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC6624: 48000028  b 0x82ec664c
	pc = 0x82EC664C; continue 'dispatch;
            }
            0x82EC6628 => {
    //   block [0x82EC6628..0x82EC6634)
	// 82EC6628: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC662C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6630: 48000018  b 0x82ec6648
	pc = 0x82EC6648; continue 'dispatch;
            }
            0x82EC6634 => {
    //   block [0x82EC6634..0x82EC6648)
	// 82EC6634: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6638: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC663C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6640: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC6644: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6648; continue 'dispatch;
            }
            0x82EC6648 => {
    //   block [0x82EC6648..0x82EC664C)
	// 82EC6648: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC664C; continue 'dispatch;
            }
            0x82EC664C => {
    //   block [0x82EC664C..0x82EC6660)
	// 82EC664C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC665C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6660 size=196
    let mut pc: u32 = 0x82EC6660;
    'dispatch: loop {
        match pc {
            0x82EC6660 => {
    //   block [0x82EC6660..0x82EC6698)
	// 82EC6660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6664: 4BDE2DA1  bl 0x82ca9404
	ctx.lr = 0x82EC6668;
	sub_82CA93D0(ctx, base);
	// 82EC6668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC666C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC6670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6674: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EC6678: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EC667C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EC6680: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EC6684: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EC6688: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EC668C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EC6690: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EC6694: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EC6698; continue 'dispatch;
            }
            0x82EC6698 => {
    //   block [0x82EC6698..0x82EC66C4)
	// 82EC6698: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC669C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EC66A0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EC66A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EC66A8: 4082FFF0  bne 0x82ec6698
	if !ctx.cr[0].eq {
	pc = 0x82EC6698; continue 'dispatch;
	}
	// 82EC66AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC66B0: 4BFFFEE9  bl 0x82ec6598
	ctx.lr = 0x82EC66B4;
	sub_82EC6598(ctx, base);
	// 82EC66B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC66B8: 4082000C  bne 0x82ec66c4
	if !ctx.cr[0].eq {
	pc = 0x82EC66C4; continue 'dispatch;
	}
	// 82EC66BC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EC66C0: 48000010  b 0x82ec66d0
	pc = 0x82EC66D0; continue 'dispatch;
            }
            0x82EC66C4 => {
    //   block [0x82EC66C4..0x82EC66D0)
	// 82EC66C4: 4BFF4D2D  bl 0x82ebb3f0
	ctx.lr = 0x82EC66C8;
	sub_82EBB3F0(ctx, base);
	// 82EC66C8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC66CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EC66D0; continue 'dispatch;
            }
            0x82EC66D0 => {
    //   block [0x82EC66D0..0x82EC66F4)
	// 82EC66D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EC66D4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EC66D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EC66DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EC66E0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EC66E4: 409A0010  bne cr6, 0x82ec66f4
	if !ctx.cr[6].eq {
	pc = 0x82EC66F4; continue 'dispatch;
	}
	// 82EC66E8: 4BFB9371  bl 0x82e7fa58
	ctx.lr = 0x82EC66EC;
	sub_82E7FA58(ctx, base);
	// 82EC66EC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EC66F0: 4800000C  b 0x82ec66fc
	pc = 0x82EC66FC; continue 'dispatch;
            }
            0x82EC66F4 => {
    //   block [0x82EC66F4..0x82EC66FC)
	// 82EC66F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EC66F8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EC66FC; continue 'dispatch;
            }
            0x82EC66FC => {
    //   block [0x82EC66FC..0x82EC6718)
	// 82EC66FC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EC6700: 41820018  beq 0x82ec6718
	if ctx.cr[0].eq {
	pc = 0x82EC6718; continue 'dispatch;
	}
	// 82EC6704: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EC6708: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EC670C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EC6710: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EC6714: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6718; continue 'dispatch;
            }
            0x82EC6718 => {
    //   block [0x82EC6718..0x82EC6724)
	// 82EC6718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC671C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EC6720: 4BDE2D34  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6728 size=68
    let mut pc: u32 = 0x82EC6728;
    'dispatch: loop {
        match pc {
            0x82EC6728 => {
    //   block [0x82EC6728..0x82EC676C)
	// 82EC6728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC672C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC6734: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6738: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EC673C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EC6740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6744: 4BFFFF1D  bl 0x82ec6660
	ctx.lr = 0x82EC6748;
	sub_82EC6660(ctx, base);
	// 82EC6748: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EC674C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EC6750: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82EC6754: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EC6758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC675C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC6760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EC6770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EC6770 size=200
    let mut pc: u32 = 0x82EC6770;
    'dispatch: loop {
        match pc {
            0x82EC6770 => {
    //   block [0x82EC6770..0x82EC67A4)
	// 82EC6770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EC6774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EC6778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EC677C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EC6780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EC6784: 4BFF4BF5  bl 0x82ebb378
	ctx.lr = 0x82EC6788;
	sub_82EBB378(ctx, base);
	// 82EC6788: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EC678C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EC6790: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EC6794: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6798: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC679C: 40810054  ble 0x82ec67f0
	if !ctx.cr[0].gt {
	pc = 0x82EC67F0; continue 'dispatch;
	}
	// 82EC67A0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EC67A4; continue 'dispatch;
            }
            0x82EC67A4 => {
    //   block [0x82EC67A4..0x82EC67B0)
	// 82EC67A4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67A8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EC67AC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EC67B0; continue 'dispatch;
            }
            0x82EC67B0 => {
    //   block [0x82EC67B0..0x82EC67D4)
	// 82EC67B0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67B4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EC67B8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC67BC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EC67C0: 41820014  beq 0x82ec67d4
	if ctx.cr[0].eq {
	pc = 0x82EC67D4; continue 'dispatch;
	}
	// 82EC67C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC67C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EC67CC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EC67D0: 419AFFE0  beq cr6, 0x82ec67b0
	if ctx.cr[6].eq {
	pc = 0x82EC67B0; continue 'dispatch;
	}
	pc = 0x82EC67D4; continue 'dispatch;
            }
            0x82EC67D4 => {
    //   block [0x82EC67D4..0x82EC67F0)
	// 82EC67D4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EC67D8: 41820028  beq 0x82ec6800
	if ctx.cr[0].eq {
	pc = 0x82EC6800; continue 'dispatch;
	}
	// 82EC67DC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC67E0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EC67E4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EC67E8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EC67EC: 4198FFB8  blt cr6, 0x82ec67a4
	if ctx.cr[6].lt {
	pc = 0x82EC67A4; continue 'dispatch;
	}
	pc = 0x82EC67F0; continue 'dispatch;
            }
            0x82EC67F0 => {
    //   block [0x82EC67F0..0x82EC6800)
	// 82EC67F0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EC67F4: 409A0018  bne cr6, 0x82ec680c
	if !ctx.cr[6].eq {
	pc = 0x82EC680C; continue 'dispatch;
	}
	// 82EC67F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EC67FC: 48000028  b 0x82ec6824
	pc = 0x82EC6824; continue 'dispatch;
            }
            0x82EC6800 => {
    //   block [0x82EC6800..0x82EC680C)
	// 82EC6800: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6804: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6808: 48000018  b 0x82ec6820
	pc = 0x82EC6820; continue 'dispatch;
            }
            0x82EC680C => {
    //   block [0x82EC680C..0x82EC6820)
	// 82EC680C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EC6810: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EC6814: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EC6818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EC681C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EC6820; continue 'dispatch;
            }
            0x82EC6820 => {
    //   block [0x82EC6820..0x82EC6824)
	// 82EC6820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EC6824; continue 'dispatch;
            }
            0x82EC6824 => {
    //   block [0x82EC6824..0x82EC6838)
	// 82EC6824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EC6828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EC682C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EC6830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EC6834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


